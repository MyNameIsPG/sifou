/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50560
Source Host           : localhost:3306
Source Database       : bbs_sifou

Target Server Type    : MYSQL
Target Server Version : 50560
File Encoding         : 65001

Date: 2020-04-25 13:41:31
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for tb_channels
-- ----------------------------
DROP TABLE IF EXISTS `tb_channels`;
CREATE TABLE `tb_channels` (
  `uuid` varchar(50) NOT NULL,
  `name` varchar(10) DEFAULT NULL COMMENT '名称',
  `url` varchar(50) DEFAULT NULL COMMENT '地址',
  `icon_url` varchar(255) DEFAULT NULL COMMENT '图标',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='频道表';

-- ----------------------------
-- Records of tb_channels
-- ----------------------------
INSERT INTO `tb_channels` VALUES ('04547238127a4676b504cc4496865d7b', '安全', 'netsec', '', '2020-04-14 09:23:09', '2020-04-14 09:23:09');
INSERT INTO `tb_channels` VALUES ('049b3bd76c1e49ccbe48b36197e77f76', '前端', 'frontend', '', '2020-04-08 16:42:59', '2020-04-10 11:33:53');
INSERT INTO `tb_channels` VALUES ('19eb3dd59ef8430d9f637d97449fc417', '开源', 'oss', '', '2020-04-14 09:23:41', '2020-04-14 09:23:41');
INSERT INTO `tb_channels` VALUES ('1a7cc9fbc4654cb0afec84e080816ef1', '游戏', 'game', '', '2020-04-14 09:22:59', '2020-04-14 09:22:59');
INSERT INTO `tb_channels` VALUES ('2a353971222c4aff8e8d3e9c370330cd', '工具', 'toolkit', '', '2020-04-14 09:23:54', '2020-04-14 09:23:54');
INSERT INTO `tb_channels` VALUES ('3798854967b444e0b8156e5154f94b97', '区块链', 'bc', '', '2020-04-14 09:23:31', '2020-04-14 09:23:31');
INSERT INTO `tb_channels` VALUES ('7b3e40f8b9cc4b7780dc39a71d7f580e', '小程序', 'miniprogram', '', '2020-04-08 16:43:43', '2020-04-08 16:43:43');
INSERT INTO `tb_channels` VALUES ('819ad72c1efe450f9d7affc135a4b457', 'Android', 'android', '', '2020-04-14 09:22:31', '2020-04-14 09:22:31');
INSERT INTO `tb_channels` VALUES ('91832bd0c3a244fb88c0bca74c0d404d', '程序员', 'programmer', '', '2020-04-14 09:24:04', '2020-04-14 09:24:04');
INSERT INTO `tb_channels` VALUES ('a0ea520851b4484f9cebac9ff7e47bc6', '金融科技', 'fintech', '', '2020-04-14 09:23:17', '2020-04-14 09:23:17');
INSERT INTO `tb_channels` VALUES ('a2718d66a7234b1499ed897ff4df05c8', '行业', 'industry', '', '2020-04-14 09:24:15', '2020-04-14 09:24:15');
INSERT INTO `tb_channels` VALUES ('a337904dd1d5477b9689d7693be316de', 'IOS', 'ios', '', '2020-04-14 09:22:11', '2020-04-14 09:22:11');
INSERT INTO `tb_channels` VALUES ('b299a2a48cd64e77a3431ce958b42055', '云计算', 'cloud', '', '2020-04-14 09:22:49', '2020-04-14 09:22:49');
INSERT INTO `tb_channels` VALUES ('bb0b7e69ad3e46fcb121baefda8f1f78', '后端', 'backend', '', '2020-04-08 16:43:25', '2020-04-08 16:43:25');
INSERT INTO `tb_channels` VALUES ('cbad2058b4014634aec6515f4adbef0d', 'AI', 'ai', '', '2020-04-14 09:22:41', '2020-04-14 09:22:41');
INSERT INTO `tb_channels` VALUES ('ee1accc0cfb444fa96d6811569830ecd', '其它', '', '', '2020-04-16 15:30:16', '2020-04-16 15:30:16');

-- ----------------------------
-- Table structure for tb_comment
-- ----------------------------
DROP TABLE IF EXISTS `tb_comment`;
CREATE TABLE `tb_comment` (
  `uuid` varchar(50) NOT NULL,
  `recommend_id` varchar(50) DEFAULT NULL COMMENT '文章id/问答id',
  `user_id` varchar(50) DEFAULT NULL COMMENT '用户id',
  `like_number` int(9) DEFAULT '0' COMMENT '点赞数',
  `content` varchar(255) DEFAULT NULL COMMENT '评论内容',
  `create_time` datetime DEFAULT NULL,
  `parent_id` varchar(50) DEFAULT NULL COMMENT '父级id',
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='评论主表';

-- ----------------------------
-- Records of tb_comment
-- ----------------------------
INSERT INTO `tb_comment` VALUES ('30e30671ffb04f12b5047753bca66f52', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是评论4', '2020-04-14 15:34:51', '');
INSERT INTO `tb_comment` VALUES ('47a7bc7cf5ca481fb9785bac2db8251c', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是评论3', '2020-04-14 15:34:43', '');
INSERT INTO `tb_comment` VALUES ('728a0954563542ae9e38108669de6ccf', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-1', '2020-04-14 15:35:23', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('7615021c3af346e791516fc443b03cc7', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-3', '2020-04-14 15:35:39', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('76d33636d29b4f78a717d148dca1a23e', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-2', '2020-04-14 15:35:35', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('7bef431461844a9da921ad1ab29c41d3', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-4', '2020-04-14 15:35:43', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('f18e7b63ceca4166b65c23451535abaa', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是评论1', '2020-04-14 15:34:08', '');

-- ----------------------------
-- Table structure for tb_labels
-- ----------------------------
DROP TABLE IF EXISTS `tb_labels`;
CREATE TABLE `tb_labels` (
  `uuid` varchar(50) NOT NULL,
  `channels_id` varchar(50) DEFAULT NULL COMMENT '频道id',
  `name` varchar(20) DEFAULT NULL COMMENT '标签名称',
  `icon_url` varchar(255) DEFAULT NULL COMMENT '图标',
  `description` varchar(120) DEFAULT NULL COMMENT '描述',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='标签表';

-- ----------------------------
-- Records of tb_labels
-- ----------------------------
INSERT INTO `tb_labels` VALUES ('0009b2289c004b7a9c9ee325d693fd1f', 'cbad2058b4014634aec6515f4adbef0d', '自动驾驶', '', '', '2020-04-16 15:18:15', '2020-04-16 15:18:15');
INSERT INTO `tb_labels` VALUES ('01129607ea6c4b16ad77a7998d8d7e74', '2a353971222c4aff8e8d3e9c370330cd', 'visual-studio-code', null, null, '2020-04-23 11:00:45', '2020-04-23 11:00:45');
INSERT INTO `tb_labels` VALUES ('015783aba70b4c11bc1fddcaffa72d31', '2a353971222c4aff8e8d3e9c370330cd', '路由', null, null, '2020-04-16 16:59:44', '2020-04-16 16:59:44');
INSERT INTO `tb_labels` VALUES ('077a6486ebf94f5e9a589411d2e4adb5', 'ee1accc0cfb444fa96d6811569830ecd', '破解', null, null, '2020-04-16 16:47:08', '2020-04-16 16:47:08');
INSERT INTO `tb_labels` VALUES ('09e0eefc1b14434c936b613d1a2b0bf3', 'ee1accc0cfb444fa96d6811569830ecd', '震动', null, null, '2020-04-16 16:47:11', '2020-04-16 16:47:11');
INSERT INTO `tb_labels` VALUES ('09e48b1bf7c9412aa8fd18d1fb76ba85', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'maven', '', '', '2020-04-16 15:10:14', '2020-04-16 15:10:14');
INSERT INTO `tb_labels` VALUES ('0a5aa8da93084aa6ac3dc20b1cc90863', 'ee1accc0cfb444fa96d6811569830ecd', '心得', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('0b50d8c7b2a44489a9dd703b034feac2', 'a337904dd1d5477b9689d7693be316de', 'sdk', null, null, '2020-04-16 16:50:16', '2020-04-16 16:50:16');
INSERT INTO `tb_labels` VALUES ('0c52f81f27204666928190ebbc74d1aa', 'ee1accc0cfb444fa96d6811569830ecd', 'libevent', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('0e8101b2d5224b029a5f8f4b0948a37e', 'cbad2058b4014634aec6515f4adbef0d', '数据集', null, null, '2020-04-16 16:55:39', '2020-04-16 16:55:39');
INSERT INTO `tb_labels` VALUES ('0f2596e8a00f4ed58d2b4e47f674a118', 'b299a2a48cd64e77a3431ce958b42055', '阿里云', null, null, '2020-04-16 16:56:37', '2020-04-16 16:56:37');
INSERT INTO `tb_labels` VALUES ('1062207552f54e86b0a1ad8dd7c0a888', '049b3bd76c1e49ccbe48b36197e77f76', 'typescript', '', '', '2020-04-16 15:06:19', '2020-04-16 15:06:19');
INSERT INTO `tb_labels` VALUES ('10a8813a8ce34deb9b8d590fcf74124c', 'ee1accc0cfb444fa96d6811569830ecd', 'gnu', null, null, '2020-04-16 16:47:16', '2020-04-16 16:47:16');
INSERT INTO `tb_labels` VALUES ('1103d9e24e014eeab039ce0de76ad440', '2a353971222c4aff8e8d3e9c370330cd', 'gitlab', null, null, '2020-04-16 16:59:47', '2020-04-16 16:59:47');
INSERT INTO `tb_labels` VALUES ('115ec0efd61e4e22942b00b9fd1246b0', 'ee1accc0cfb444fa96d6811569830ecd', '百度', null, null, '2020-04-16 16:47:08', '2020-04-16 16:47:08');
INSERT INTO `tb_labels` VALUES ('12f91faac18b49819869f52fbdbb1960', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'reactnative', null, null, '2020-04-16 16:49:27', '2020-04-16 16:49:27');
INSERT INTO `tb_labels` VALUES ('13f1211b651544e3a17611b2117e9cec', 'cbad2058b4014634aec6515f4adbef0d', '数据挖掘', '', '', '2020-04-16 15:18:34', '2020-04-16 15:18:34');
INSERT INTO `tb_labels` VALUES ('14ab12176ade47da95ba97d7151eb1f9', 'ee1accc0cfb444fa96d6811569830ecd', 'flutter', null, null, '2020-04-16 16:47:14', '2020-04-16 16:47:14');
INSERT INTO `tb_labels` VALUES ('14b1d605b9c340139163c4f22f384a7f', '1a7cc9fbc4654cb0afec84e080816ef1', '魔兽', null, null, '2020-04-16 16:57:54', '2020-04-16 16:57:54');
INSERT INTO `tb_labels` VALUES ('1500b6a8b7a64b41a84f31328c0a3c9a', 'bb0b7e69ad3e46fcb121baefda8f1f78', '缓存', null, null, '2020-04-16 16:48:53', '2020-04-16 16:48:53');
INSERT INTO `tb_labels` VALUES ('152de5fe7cc14dedb342ba8dd2800d42', '049b3bd76c1e49ccbe48b36197e77f76', '技术', null, null, '2020-04-16 16:09:19', '2020-04-16 16:09:19');
INSERT INTO `tb_labels` VALUES ('158af11aa2cf46f68d722bc26e694541', '049b3bd76c1e49ccbe48b36197e77f76', 'vue-router', null, null, '2020-04-23 09:39:06', '2020-04-23 09:39:06');
INSERT INTO `tb_labels` VALUES ('15941dc0af92453481b8a0626f963283', '7b3e40f8b9cc4b7780dc39a71d7f580e', '微信小程序', '', '', '2020-04-09 19:49:34', '2020-04-09 19:49:34');
INSERT INTO `tb_labels` VALUES ('15ef803612034600809b3e6c99cb32ab', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'uni-app', '', '', '2020-04-16 15:13:41', '2020-04-16 15:13:41');
INSERT INTO `tb_labels` VALUES ('17e1a68483b94e4e99ab348cd15d98c5', '049b3bd76c1e49ccbe48b36197e77f76', '格式化', null, null, '2020-04-23 09:39:05', '2020-04-23 09:39:05');
INSERT INTO `tb_labels` VALUES ('18261a31165d4a00b819e4f5132c9049', 'cbad2058b4014634aec6515f4adbef0d', '自然语言处理', '', '', '2020-04-16 15:18:05', '2020-04-16 15:18:05');
INSERT INTO `tb_labels` VALUES ('18a3a500bd184162ac1dc6fc9372c2f8', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'java8', null, null, '2020-04-23 10:28:21', '2020-04-23 10:28:21');
INSERT INTO `tb_labels` VALUES ('1939b672cc5446439db2b7017c7cfa48', 'ee1accc0cfb444fa96d6811569830ecd', '开源协议', null, null, '2020-04-16 16:47:15', '2020-04-16 16:47:15');
INSERT INTO `tb_labels` VALUES ('19b5930ba00e4cf09120e04c1f0a9e6b', 'a337904dd1d5477b9689d7693be316de', 'phonegap', '', '', '2020-04-16 15:14:59', '2020-04-16 15:14:59');
INSERT INTO `tb_labels` VALUES ('1a77ff8ac4c54e58b5e6b22210cff64f', 'ee1accc0cfb444fa96d6811569830ecd', 'mysql', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('1af5f9c4e9a14953af29cb85b3dd6caa', 'ee1accc0cfb444fa96d6811569830ecd', '后端开发', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('1ca15ce069584c35ad17790f81a05a60', 'ee1accc0cfb444fa96d6811569830ecd', 'gui', null, null, '2020-04-16 16:47:14', '2020-04-16 16:47:14');
INSERT INTO `tb_labels` VALUES ('1d0ffae0426e4e6e8add67530ec689b4', '049b3bd76c1e49ccbe48b36197e77f76', 'html', '', '', '2020-04-09 19:47:46', '2020-04-09 19:47:46');
INSERT INTO `tb_labels` VALUES ('1d36446f3db84f4c836556d1513c37f0', '04547238127a4676b504cc4496865d7b', 'thymeleaf', null, null, '2020-04-16 16:58:56', '2020-04-16 16:58:56');
INSERT INTO `tb_labels` VALUES ('1daffe9846d8484ea60a6379e07cadef', '819ad72c1efe450f9d7affc135a4b457', 'xml', '', '', '2020-04-16 15:17:25', '2020-04-16 15:17:25');
INSERT INTO `tb_labels` VALUES ('1f222fff35904eafba3af5103e7f5121', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'gin', null, null, '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_labels` VALUES ('1fb6bf7d213640b28d89fe5a369dc60d', 'b299a2a48cd64e77a3431ce958b42055', 'qingcloud', null, null, '2020-04-16 16:56:36', '2020-04-16 16:56:36');
INSERT INTO `tb_labels` VALUES ('2123747b7b144128911f5df5ccc76295', '049b3bd76c1e49ccbe48b36197e77f76', 'iOS开发', null, null, '2020-04-23 09:39:06', '2020-04-23 09:39:06');
INSERT INTO `tb_labels` VALUES ('219d7aff8dfe4ffc9c8f368e2987187f', '7b3e40f8b9cc4b7780dc39a71d7f580e', '支付宝小程序', '', '', '2020-04-09 19:49:42', '2020-04-09 19:49:42');
INSERT INTO `tb_labels` VALUES ('224db6e7ee264d868ecd07eba961eb6f', '049b3bd76c1e49ccbe48b36197e77f76', '内存泄漏', null, null, '2020-04-16 16:09:10', '2020-04-16 16:09:10');
INSERT INTO `tb_labels` VALUES ('2294832fe5104d73ace4f14ad9549018', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'java', '', '', '2020-04-16 15:09:09', '2020-04-16 15:09:09');
INSERT INTO `tb_labels` VALUES ('259269231c934c80878839ea2f348955', 'b299a2a48cd64e77a3431ce958b42055', '云杉网络', '', '', '2020-04-16 15:21:02', '2020-04-16 15:21:02');
INSERT INTO `tb_labels` VALUES ('25b298296d9948c5aceac5227fa0ef07', 'ee1accc0cfb444fa96d6811569830ecd', '经验教训', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('277530c212aa4407b43c58c657fe8194', 'a0ea520851b4484f9cebac9ff7e47bc6', '大数据', null, null, '2020-04-16 16:59:08', '2020-04-16 16:59:08');
INSERT INTO `tb_labels` VALUES ('278262a4258f4beca20e334398ab06d8', 'a0ea520851b4484f9cebac9ff7e47bc6', '分布式', null, null, '2020-04-16 16:59:10', '2020-04-16 16:59:10');
INSERT INTO `tb_labels` VALUES ('2a09bf1afefd4d659606f43445741ee3', 'cbad2058b4014634aec6515f4adbef0d', '人工智能', '', '', '2020-04-16 15:17:51', '2020-04-16 15:17:51');
INSERT INTO `tb_labels` VALUES ('2a81fe886a0a41028a7b13cb4915b40f', '19eb3dd59ef8430d9f637d97449fc417', '加密技术', null, null, '2020-04-16 16:59:31', '2020-04-16 16:59:31');
INSERT INTO `tb_labels` VALUES ('2ab3859eef1a47078a59550cb6f541b2', '049b3bd76c1e49ccbe48b36197e77f76', '开发工具', null, null, '2020-04-23 09:39:05', '2020-04-23 09:39:05');
INSERT INTO `tb_labels` VALUES ('2deb4787e1714b42b076355a58fa9fcc', 'b299a2a48cd64e77a3431ce958b42055', '百度云', '', '', '2020-04-16 15:20:01', '2020-04-16 15:20:01');
INSERT INTO `tb_labels` VALUES ('2fd0d43e373d4a38add451c1ae47594f', 'ee1accc0cfb444fa96d6811569830ecd', 'aio', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('2ff36c3d3aec49d8a19cd1d17c6e9a7e', 'ee1accc0cfb444fa96d6811569830ecd', '性能测试', null, null, '2020-04-16 16:47:20', '2020-04-16 16:47:20');
INSERT INTO `tb_labels` VALUES ('30ea6d13caf14dc8990e3284489224d9', '2a353971222c4aff8e8d3e9c370330cd', 'svn', null, null, '2020-04-16 16:59:47', '2020-04-16 16:59:47');
INSERT INTO `tb_labels` VALUES ('3180cf8f38994cf8a5c66b720841cb3f', 'bb0b7e69ad3e46fcb121baefda8f1f78', '字符集', null, null, '2020-04-23 10:28:22', '2020-04-23 10:28:22');
INSERT INTO `tb_labels` VALUES ('3283cc5d6e714f1eb30181e3d83d99af', '7b3e40f8b9cc4b7780dc39a71d7f580e', '百度小程序', '', '', '2020-04-09 19:49:47', '2020-04-09 19:49:47');
INSERT INTO `tb_labels` VALUES ('32b327672bf34bb49868560bae1a0ab0', '2a353971222c4aff8e8d3e9c370330cd', '插件', null, null, '2020-04-16 16:59:44', '2020-04-16 16:59:44');
INSERT INTO `tb_labels` VALUES ('32f02ee5a7a04ecfb8e8f2fb56594929', '049b3bd76c1e49ccbe48b36197e77f76', '可视化', null, null, '2020-04-23 09:38:59', '2020-04-23 09:38:59');
INSERT INTO `tb_labels` VALUES ('3300149da71245d9b748b46d3a41c628', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'rpc', null, null, '2020-04-16 16:48:52', '2020-04-16 16:48:52');
INSERT INTO `tb_labels` VALUES ('3450238252414287a0b3fbac4a4e198b', '049b3bd76c1e49ccbe48b36197e77f76', '能力', null, null, '2020-04-16 16:09:19', '2020-04-16 16:09:19');
INSERT INTO `tb_labels` VALUES ('34a4fdb41d174683a033a2528f5432fc', 'ee1accc0cfb444fa96d6811569830ecd', 'netty', null, null, '2020-04-16 16:47:14', '2020-04-16 16:47:14');
INSERT INTO `tb_labels` VALUES ('34b18c0fcab44fec86f4a5d8f9845545', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'sql', null, null, '2020-04-16 16:48:55', '2020-04-16 16:48:55');
INSERT INTO `tb_labels` VALUES ('363e175974654a1da390fd600fdecbc5', '049b3bd76c1e49ccbe48b36197e77f76', '工作', null, null, '2020-04-23 09:39:02', '2020-04-23 09:39:02');
INSERT INTO `tb_labels` VALUES ('37cf11776ac6429fb9acf87d5c755ab2', 'ee1accc0cfb444fa96d6811569830ecd', '设计模式', null, null, '2020-04-16 16:47:14', '2020-04-16 16:47:14');
INSERT INTO `tb_labels` VALUES ('3820770e46ef414faee8ed89ce154fdc', '91832bd0c3a244fb88c0bca74c0d404d', 'devops', null, null, '2020-04-16 17:00:00', '2020-04-16 17:00:00');
INSERT INTO `tb_labels` VALUES ('382be152cdba43989a2a4408c1116f87', 'cbad2058b4014634aec6515f4adbef0d', '模型', null, null, '2020-04-16 16:55:39', '2020-04-16 16:55:39');
INSERT INTO `tb_labels` VALUES ('390975aa461b45efb6a730eef605b94e', '049b3bd76c1e49ccbe48b36197e77f76', '动画', null, null, '2020-04-23 10:00:28', '2020-04-23 10:00:28');
INSERT INTO `tb_labels` VALUES ('3921afbb134d45f6aa368b52d2670e7b', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'leetcode', null, null, '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_labels` VALUES ('3a7297510e14482196aeb38b5b53c846', '3798854967b444e0b8156e5154f94b97', '比特币', '', '', '2020-04-16 15:22:46', '2020-04-16 15:22:46');
INSERT INTO `tb_labels` VALUES ('3b375646301546259a8fb29d74ae4447', '049b3bd76c1e49ccbe48b36197e77f76', '小程序', null, null, '2020-04-16 16:09:06', '2020-04-16 16:09:06');
INSERT INTO `tb_labels` VALUES ('3d2c807983af4eaa89f6eb8772d8d206', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'unicode', null, null, '2020-04-23 10:28:22', '2020-04-23 10:28:22');
INSERT INTO `tb_labels` VALUES ('401f1c4dcfbc499e8f7129c091c299f8', '049b3bd76c1e49ccbe48b36197e77f76', 'html5', '', '', '2020-04-09 19:48:27', '2020-04-09 19:48:27');
INSERT INTO `tb_labels` VALUES ('404982af52c7437280759bb9156099eb', '04547238127a4676b504cc4496865d7b', 'springboot', null, null, '2020-04-16 16:58:56', '2020-04-16 16:58:56');
INSERT INTO `tb_labels` VALUES ('406ef08e86cc4caa88239b8e0e4ea758', '19eb3dd59ef8430d9f637d97449fc417', 'paddle', null, null, '2020-04-16 16:59:30', '2020-04-16 16:59:30');
INSERT INTO `tb_labels` VALUES ('40a18ee9514e46b28a96cc182f4f8df2', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'tomcat', '', '', '2020-04-16 15:10:06', '2020-04-16 15:10:06');
INSERT INTO `tb_labels` VALUES ('40c24c15130143f6be0c452503550a5b', 'b299a2a48cd64e77a3431ce958b42055', 'ucloud', '', '', '2020-04-16 15:21:17', '2020-04-16 15:21:17');
INSERT INTO `tb_labels` VALUES ('410e0ac328ce4db8bebc61f2c565943b', 'a337904dd1d5477b9689d7693be316de', 'macos', '', '', '2020-04-16 15:15:23', '2020-04-16 15:15:23');
INSERT INTO `tb_labels` VALUES ('419c570a467e42b1b29bb02eef1b36dd', '7b3e40f8b9cc4b7780dc39a71d7f580e', '头条小程序', '', '', '2020-04-16 15:13:00', '2020-04-16 15:13:00');
INSERT INTO `tb_labels` VALUES ('43145b2d806a4c3e8bb30d20ef04d61b', 'ee1accc0cfb444fa96d6811569830ecd', 'python', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('448959a7e0394148ae465d890ed2bbd2', 'ee1accc0cfb444fa96d6811569830ecd', '滴滴出行', null, null, '2020-04-16 16:47:21', '2020-04-16 16:47:21');
INSERT INTO `tb_labels` VALUES ('45a9e20bf502451396f25c51ff9f7972', 'a337904dd1d5477b9689d7693be316de', 'dart', null, null, '2020-04-16 16:50:18', '2020-04-16 16:50:18');
INSERT INTO `tb_labels` VALUES ('46aef9d1ce7343688d2eeba3bf10f911', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'lambda', null, null, '2020-04-23 10:28:21', '2020-04-23 10:28:21');
INSERT INTO `tb_labels` VALUES ('4754192fa3a348589f4dce6a37965a21', '819ad72c1efe450f9d7affc135a4b457', 'webview', '', '', '2020-04-16 15:16:22', '2020-04-16 15:16:22');
INSERT INTO `tb_labels` VALUES ('4810ef0267f242fa99b85b2fd8a3cc02', 'ee1accc0cfb444fa96d6811569830ecd', 'ddd', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('499b6d4decaa4985b8272adc258273fc', '7b3e40f8b9cc4b7780dc39a71d7f580e', '异步', null, null, '2020-04-16 16:49:26', '2020-04-16 16:49:26');
INSERT INTO `tb_labels` VALUES ('49f4dbb3a7b24819950d1e3897abf92b', 'bb0b7e69ad3e46fcb121baefda8f1f78', '函数式编程', null, null, '2020-04-23 10:28:21', '2020-04-23 10:28:21');
INSERT INTO `tb_labels` VALUES ('4a2750c3e1fc45fa885bedbd3a9ee7d8', '3798854967b444e0b8156e5154f94b97', 'ico', '', '', '2020-04-16 15:23:01', '2020-04-16 15:23:01');
INSERT INTO `tb_labels` VALUES ('4a80ddea758b47c990fb8b276d19a350', 'cbad2058b4014634aec6515f4adbef0d', '机器人', null, null, '2020-04-16 16:55:38', '2020-04-16 16:55:38');
INSERT INTO `tb_labels` VALUES ('4ad5ca7a9f33456bbe10fa16bd9e5909', '91832bd0c3a244fb88c0bca74c0d404d', '面试', null, null, '2020-04-23 11:01:03', '2020-04-23 11:01:03');
INSERT INTO `tb_labels` VALUES ('4af39019dc66420fb7c786629449fbc9', '1a7cc9fbc4654cb0afec84e080816ef1', '游戏引擎', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('4bbfbe8b4f0e4788a82ceac3f3c96168', '2a353971222c4aff8e8d3e9c370330cd', '编辑器', null, null, '2020-04-23 10:59:28', '2020-04-23 10:59:28');
INSERT INTO `tb_labels` VALUES ('4c3a5a1f039b42a5b26aeb9aca0646bb', '7b3e40f8b9cc4b7780dc39a71d7f580e', '微信开发', null, null, '2020-04-16 16:49:22', '2020-04-16 16:49:22');
INSERT INTO `tb_labels` VALUES ('4c5f061cd88a451d91f4d1f0d52f3ed0', 'a0ea520851b4484f9cebac9ff7e47bc6', 'antdesign', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('50952da4831a49c98a02a58ccc545509', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'golang', null, null, '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_labels` VALUES ('50b1ead18a154fb9a3be3ed4bc61398b', 'b299a2a48cd64e77a3431ce958b42055', '容器', null, null, '2020-04-16 16:56:37', '2020-04-16 16:56:37');
INSERT INTO `tb_labels` VALUES ('55723db96b9f4593bae02bc1e49f1e87', 'ee1accc0cfb444fa96d6811569830ecd', '后端', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('56c120bcbcfd4c189edde979cbe2cc96', '049b3bd76c1e49ccbe48b36197e77f76', '跳槽', null, null, '2020-04-23 09:39:04', '2020-04-23 09:39:04');
INSERT INTO `tb_labels` VALUES ('57f41641447a40eb9bde76ded2a16296', 'ee1accc0cfb444fa96d6811569830ecd', 'segmentfault', null, null, '2020-04-16 16:47:09', '2020-04-16 16:47:09');
INSERT INTO `tb_labels` VALUES ('581c0fef5c3347b8bedbf8c2421d911b', 'b299a2a48cd64e77a3431ce958b42055', '华为云', null, null, '2020-04-16 16:56:35', '2020-04-16 16:56:35');
INSERT INTO `tb_labels` VALUES ('582af48b567844cebb5bd26cc36dee97', 'a337904dd1d5477b9689d7693be316de', 'swift', '', '', '2020-04-16 15:15:39', '2020-04-16 15:15:39');
INSERT INTO `tb_labels` VALUES ('58f71f062add49e089c84a3db4103629', 'a337904dd1d5477b9689d7693be316de', 'sqlite', '', '', '2020-04-16 15:14:30', '2020-04-16 15:14:30');
INSERT INTO `tb_labels` VALUES ('590ea80c67eb433789c1387096d3fc76', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'zookeeper', null, null, '2020-04-23 10:28:30', '2020-04-23 10:28:30');
INSERT INTO `tb_labels` VALUES ('5941ef35934d4ddc85771b5a57e52dec', '049b3bd76c1e49ccbe48b36197e77f76', '上拉加载', null, null, '2020-04-23 09:39:07', '2020-04-23 09:39:07');
INSERT INTO `tb_labels` VALUES ('5bc240f3bc174167bf6eaa745d97c6ae', '049b3bd76c1e49ccbe48b36197e77f76', 'solid原则', null, null, '2020-04-16 16:09:20', '2020-04-16 16:09:20');
INSERT INTO `tb_labels` VALUES ('5efa96b48ac5424bafa02fd88f312984', '19eb3dd59ef8430d9f637d97449fc417', 'tinymce', null, null, '2020-04-23 10:59:01', '2020-04-23 10:59:01');
INSERT INTO `tb_labels` VALUES ('603c056cdb7840da9242d2c0844d5c0f', 'cbad2058b4014634aec6515f4adbef0d', '深度学习', '', '', '2020-04-16 15:18:50', '2020-04-16 15:18:50');
INSERT INTO `tb_labels` VALUES ('60e459d5028e400894856f94e826804c', 'cbad2058b4014634aec6515f4adbef0d', '互联网', null, null, '2020-04-16 16:55:35', '2020-04-16 16:55:35');
INSERT INTO `tb_labels` VALUES ('6224a68b52f54990a07d51854b320f32', 'a337904dd1d5477b9689d7693be316de', 'google', null, null, '2020-04-16 16:50:17', '2020-04-16 16:50:17');
INSERT INTO `tb_labels` VALUES ('62f75a9c3455489e9e5128982e759700', 'a0ea520851b4484f9cebac9ff7e47bc6', '金融', null, null, '2020-04-16 16:59:08', '2020-04-16 16:59:08');
INSERT INTO `tb_labels` VALUES ('631c6273e6474a3d858ca44050a4bc8b', '7b3e40f8b9cc4b7780dc39a71d7f580e', '代理', null, null, '2020-04-16 16:49:25', '2020-04-16 16:49:25');
INSERT INTO `tb_labels` VALUES ('634b81d655c74cb0adc4d0aa362b8819', 'ee1accc0cfb444fa96d6811569830ecd', 'github', null, null, '2020-04-16 16:47:20', '2020-04-16 16:47:20');
INSERT INTO `tb_labels` VALUES ('63b70326a7b34ffeb8eeb2f0098c86c1', '049b3bd76c1e49ccbe48b36197e77f76', 'cookie', null, null, '2020-04-16 16:09:17', '2020-04-16 16:09:17');
INSERT INTO `tb_labels` VALUES ('63c4e1e7ec204b43a62065a3ced4c2ce', '049b3bd76c1e49ccbe48b36197e77f76', '前端', null, null, '2020-04-16 16:09:10', '2020-04-16 16:09:10');
INSERT INTO `tb_labels` VALUES ('640c003521964678a2e591447f8be769', 'a0ea520851b4484f9cebac9ff7e47bc6', '数据安全', null, null, '2020-04-16 16:59:08', '2020-04-16 16:59:08');
INSERT INTO `tb_labels` VALUES ('646ad4ce7b3c43b89c17dcdea128af0b', '91832bd0c3a244fb88c0bca74c0d404d', 'docker', null, null, '2020-04-16 17:00:04', '2020-04-16 17:00:04');
INSERT INTO `tb_labels` VALUES ('6694b0611a0d403e9bb25c543e006f8a', '1a7cc9fbc4654cb0afec84e080816ef1', '云安全', null, null, '2020-04-16 16:57:48', '2020-04-16 16:57:48');
INSERT INTO `tb_labels` VALUES ('66d1b6953b664c409cf7283cdb6c6566', '1a7cc9fbc4654cb0afec84e080816ef1', '开发者', null, null, '2020-04-16 16:57:51', '2020-04-16 16:57:51');
INSERT INTO `tb_labels` VALUES ('66df11ef95064996ba39f328e25451f5', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'mpx', '', '', '2020-04-16 15:13:49', '2020-04-16 15:13:49');
INSERT INTO `tb_labels` VALUES ('674b70b62fa24c7ca9a671f8e54b8d15', 'cbad2058b4014634aec6515f4adbef0d', '开源项目介绍', null, null, '2020-04-16 16:55:40', '2020-04-16 16:55:40');
INSERT INTO `tb_labels` VALUES ('6808a59932024dceb5e1c0898504a56b', 'cbad2058b4014634aec6515f4adbef0d', '搜索', null, null, '2020-04-23 10:55:28', '2020-04-23 10:55:28');
INSERT INTO `tb_labels` VALUES ('695a8bbf358245c5a5284af4df5b2222', 'a0ea520851b4484f9cebac9ff7e47bc6', '蚂蚁金服', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('69a24148dd3149e49273bc7d178fa7bc', 'b299a2a48cd64e77a3431ce958b42055', '公有云', null, null, '2020-04-16 16:56:37', '2020-04-16 16:56:37');
INSERT INTO `tb_labels` VALUES ('6a6ae02394fb478caf6f772dc358e727', '3798854967b444e0b8156e5154f94b97', '智能合约', '', '', '2020-04-16 15:23:09', '2020-04-16 15:23:09');
INSERT INTO `tb_labels` VALUES ('6aec6c8499c44483beecd569d05c7f4b', 'a0ea520851b4484f9cebac9ff7e47bc6', '金融科技', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('6b3ff922b0dd4d378ac2f31d32e5f60d', 'ee1accc0cfb444fa96d6811569830ecd', '行业', null, null, '2020-04-16 16:47:08', '2020-04-16 16:47:08');
INSERT INTO `tb_labels` VALUES ('6b76e0ffbe6a4ccea745d288e312af0b', '3798854967b444e0b8156e5154f94b97', '以太坊', '', '', '2020-04-16 15:23:17', '2020-04-16 15:23:17');
INSERT INTO `tb_labels` VALUES ('6bc7339a27854278b1489eb30425aa1b', '1a7cc9fbc4654cb0afec84e080816ef1', 'wow', null, null, '2020-04-16 16:57:52', '2020-04-16 16:57:52');
INSERT INTO `tb_labels` VALUES ('6bca597168fa41528a5ce2da7f309f13', 'cbad2058b4014634aec6515f4adbef0d', '图像识别', null, null, '2020-04-23 10:55:25', '2020-04-23 10:55:25');
INSERT INTO `tb_labels` VALUES ('6db071127bc8442497d14d9527082793', '1a7cc9fbc4654cb0afec84e080816ef1', 'swoole', null, null, '2020-04-16 16:57:52', '2020-04-16 16:57:52');
INSERT INTO `tb_labels` VALUES ('6dcac97ec78c41b3a5f265d015ca34f5', '1a7cc9fbc4654cb0afec84e080816ef1', '游戏服务端', null, null, '2020-04-16 16:57:52', '2020-04-16 16:57:52');
INSERT INTO `tb_labels` VALUES ('6e98a760af6d411d8e06b244853c67e9', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'async-await', null, null, '2020-04-16 16:49:26', '2020-04-16 16:49:26');
INSERT INTO `tb_labels` VALUES ('6e99f9fefb2d45f59288b87ccf651628', 'a0ea520851b4484f9cebac9ff7e47bc6', '设计', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('6ec468fa6e2a402e84dfa1f10c689405', '7b3e40f8b9cc4b7780dc39a71d7f580e', '微信开发者工具', '', '', '2020-04-16 15:12:51', '2020-04-16 15:12:51');
INSERT INTO `tb_labels` VALUES ('6fa64cc90cb140feb9b431413237469f', 'ee1accc0cfb444fa96d6811569830ecd', 'pandas', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('6fd300174477475faf83572ffb5f6579', 'cbad2058b4014634aec6515f4adbef0d', 'nlp', null, null, '2020-04-23 10:55:28', '2020-04-23 10:55:28');
INSERT INTO `tb_labels` VALUES ('6fe04eb419474fd7ad1248f0b1a2a7e6', 'ee1accc0cfb444fa96d6811569830ecd', '知识产权', null, null, '2020-04-16 16:47:15', '2020-04-16 16:47:15');
INSERT INTO `tb_labels` VALUES ('7415188933514e5ab6d45d3645d83337', '19eb3dd59ef8430d9f637d97449fc417', 'mozilla', null, null, '2020-04-16 16:59:32', '2020-04-16 16:59:32');
INSERT INTO `tb_labels` VALUES ('7506700dea5a42298b9ecb0ac0aaab41', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'taro', '', '', '2020-04-16 15:13:32', '2020-04-16 15:13:32');
INSERT INTO `tb_labels` VALUES ('753b5aee3913424e81fe2b5299626d8c', 'ee1accc0cfb444fa96d6811569830ecd', 'linux', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('754a84ad28ed43fea93a468acd8f727b', '049b3bd76c1e49ccbe48b36197e77f76', '图表', null, null, '2020-04-16 16:09:10', '2020-04-16 16:09:10');
INSERT INTO `tb_labels` VALUES ('762f519a9c8f4151a9ef8506cde667a6', '819ad72c1efe450f9d7affc135a4b457', 'json', '', '', '2020-04-16 15:17:17', '2020-04-16 15:17:17');
INSERT INTO `tb_labels` VALUES ('76784f1e92394410abc853268ee6f31b', '1a7cc9fbc4654cb0afec84e080816ef1', '浏览器原理', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('7684950d0a9e46f1b8067594e8a0161d', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'spring', '', '', '2020-04-16 15:09:41', '2020-04-16 15:09:41');
INSERT INTO `tb_labels` VALUES ('76da78c6bbf04ec78109330e4b617f8e', 'b299a2a48cd64e77a3431ce958b42055', 'alauda', '', '', '2020-04-16 15:21:32', '2020-04-16 15:21:32');
INSERT INTO `tb_labels` VALUES ('77a7bd638e0a45ec84569ef6b79325c1', '04547238127a4676b504cc4496865d7b', '服务器', null, null, '2020-04-16 16:58:55', '2020-04-16 16:58:55');
INSERT INTO `tb_labels` VALUES ('7871a3acb3374d36b738a36c95c3f8ea', '04547238127a4676b504cc4496865d7b', 'zoom', null, null, '2020-04-16 16:58:53', '2020-04-16 16:58:53');
INSERT INTO `tb_labels` VALUES ('789898341cc64d45a1f44e26daab183f', 'bb0b7e69ad3e46fcb121baefda8f1f78', '数据结构', null, null, '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_labels` VALUES ('78b2eb8f68e34e6e8e8863c0ed281b45', '2a353971222c4aff8e8d3e9c370330cd', '思维', null, null, '2020-04-16 16:59:45', '2020-04-16 16:59:45');
INSERT INTO `tb_labels` VALUES ('7937aecb2ef543908ed511c9d5abceb3', '3798854967b444e0b8156e5154f94b97', '区块链', '', '', '2020-04-16 15:22:54', '2020-04-16 15:22:54');
INSERT INTO `tb_labels` VALUES ('79c58d0fa766471e8390a7d60e9f57be', 'ee1accc0cfb444fa96d6811569830ecd', 'nio', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('7a403ab9ce724c2b93506c5fde3efb04', '91832bd0c3a244fb88c0bca74c0d404d', '字节跳动', null, null, '2020-04-23 11:01:03', '2020-04-23 11:01:03');
INSERT INTO `tb_labels` VALUES ('7af79b929d3e4a33892d3b4305e3587f', '7b3e40f8b9cc4b7780dc39a71d7f580e', '小程序云开发', '', '', '2020-04-16 15:13:10', '2020-04-16 15:13:10');
INSERT INTO `tb_labels` VALUES ('7b39e36da1f543c995c416f3d2950cf5', '049b3bd76c1e49ccbe48b36197e77f76', 'css', '', '', '2020-04-09 19:48:41', '2020-04-09 19:48:41');
INSERT INTO `tb_labels` VALUES ('7bdbb73fad864154bd1b93c965c3ea62', '049b3bd76c1e49ccbe48b36197e77f76', '微前端', null, null, '2020-04-16 16:09:11', '2020-04-16 16:09:11');
INSERT INTO `tb_labels` VALUES ('7c555cea2dd347e389848f652e8f6ff7', '049b3bd76c1e49ccbe48b36197e77f76', 'bootstrap', '', '', '2020-04-14 20:02:45', '2020-04-14 20:02:45');
INSERT INTO `tb_labels` VALUES ('7e8a80ce2b624cf78c1048efc7c7a623', '91832bd0c3a244fb88c0bca74c0d404d', '内推', null, null, '2020-04-16 17:00:05', '2020-04-16 17:00:05');
INSERT INTO `tb_labels` VALUES ('80961fb9ea954af187319d2b8e8bd474', 'ee1accc0cfb444fa96d6811569830ecd', 'providers', null, null, '2020-04-16 16:47:19', '2020-04-16 16:47:19');
INSERT INTO `tb_labels` VALUES ('81a4561c1c294e0cae32c9fe6b5dc397', '049b3bd76c1e49ccbe48b36197e77f76', '程序员', null, null, '2020-04-16 16:09:14', '2020-04-16 16:09:14');
INSERT INTO `tb_labels` VALUES ('83f62facb3b943ffa8e46abd1ebc64d9', 'ee1accc0cfb444fa96d6811569830ecd', '数据库', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('84564b2b178141059e2bf061053de54b', 'ee1accc0cfb444fa96d6811569830ecd', 'ios开发工具', null, null, '2020-04-16 16:47:11', '2020-04-16 16:47:11');
INSERT INTO `tb_labels` VALUES ('84e1fca09c4340be87d5c1ef4601b026', 'ee1accc0cfb444fa96d6811569830ecd', 'php', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('85ee959b27f74072b13cc763b9bbf77e', 'a337904dd1d5477b9689d7693be316de', 'ios', '', '', '2020-04-16 15:14:12', '2020-04-16 15:14:12');
INSERT INTO `tb_labels` VALUES ('88d818c918534e0c94dc46380a03493a', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'jar', '', '', '2020-04-16 15:09:32', '2020-04-16 15:09:32');
INSERT INTO `tb_labels` VALUES ('8ac6e1f57bef4d348ee96af25d750c44', 'b299a2a48cd64e77a3431ce958b42055', '腾讯云', '', '', '2020-04-16 15:20:55', '2020-04-16 15:20:55');
INSERT INTO `tb_labels` VALUES ('8d3b9574902f4306bcf2833371d35439', '2a353971222c4aff8e8d3e9c370330cd', 'paas平台', null, null, '2020-04-16 16:59:47', '2020-04-16 16:59:47');
INSERT INTO `tb_labels` VALUES ('8df713ae0be648fc8158438f191920da', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'hibernate', '', '', '2020-04-16 15:09:49', '2020-04-16 15:09:49');
INSERT INTO `tb_labels` VALUES ('8dfc62f227ae4076888ea4872e03cddd', '819ad72c1efe450f9d7affc135a4b457', 'android', '', '', '2020-04-16 15:16:04', '2020-04-16 15:16:04');
INSERT INTO `tb_labels` VALUES ('8ef5bc94d5e84e80baab05e02363c9e5', '7b3e40f8b9cc4b7780dc39a71d7f580e', '京东', null, null, '2020-04-23 10:29:43', '2020-04-23 10:29:43');
INSERT INTO `tb_labels` VALUES ('90ebd6b2270249dc8580eb97aa14aa02', 'ee1accc0cfb444fa96d6811569830ecd', 'redis', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('91a1be3a7ac0413482742452c7613692', 'ee1accc0cfb444fa96d6811569830ecd', '正则表达式', null, null, '2020-04-16 16:47:21', '2020-04-16 16:47:21');
INSERT INTO `tb_labels` VALUES ('9223827da7dc4f1c8f6790777fb42d6e', '2a353971222c4aff8e8d3e9c370330cd', 'facebook', null, null, '2020-04-16 16:59:45', '2020-04-16 16:59:45');
INSERT INTO `tb_labels` VALUES ('9276a7fb738f4d38aec0e4c23347fba7', 'a337904dd1d5477b9689d7693be316de', '系统', null, null, '2020-04-16 16:50:20', '2020-04-16 16:50:20');
INSERT INTO `tb_labels` VALUES ('9332af7a7ee745509ad0cbcf13ea30e0', '2a353971222c4aff8e8d3e9c370330cd', 'windows', null, null, '2020-04-23 11:00:45', '2020-04-23 11:00:45');
INSERT INTO `tb_labels` VALUES ('934e37db9f384f009b12ce399dd89054', 'bb0b7e69ad3e46fcb121baefda8f1f78', '拦截器', null, null, '2020-04-23 10:28:15', '2020-04-23 10:28:15');
INSERT INTO `tb_labels` VALUES ('9424c753324d4c6198c85fff4f681dd4', '1a7cc9fbc4654cb0afec84e080816ef1', '游戏开发', null, null, '2020-04-16 16:57:48', '2020-04-16 16:57:48');
INSERT INTO `tb_labels` VALUES ('944695fd251146a99e7298a08f69d2e2', 'ee1accc0cfb444fa96d6811569830ecd', '通信云', null, null, '2020-04-16 16:47:12', '2020-04-16 16:47:12');
INSERT INTO `tb_labels` VALUES ('95e7c5b00e4743e0aa3dceec593ce6bd', 'a337904dd1d5477b9689d7693be316de', 'safari', '', '', '2020-04-16 15:14:41', '2020-04-16 15:14:41');
INSERT INTO `tb_labels` VALUES ('9661fbcbaed6483c9f5992883e9a62a6', 'ee1accc0cfb444fa96d6811569830ecd', 'select', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('9cbb3f4a239b433aa4be468f5b8c82ec', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'eclipse', '', '', '2020-04-16 15:10:23', '2020-04-16 15:10:23');
INSERT INTO `tb_labels` VALUES ('9cf3a084c4d94f4da9a6423ab27b8649', '819ad72c1efe450f9d7affc135a4b457', 'arm', null, null, '2020-04-16 16:54:49', '2020-04-16 16:54:49');
INSERT INTO `tb_labels` VALUES ('9cf3c6405733421e9693ef7c6e1885c8', 'ee1accc0cfb444fa96d6811569830ecd', '代码质量', null, null, '2020-04-16 16:47:19', '2020-04-16 16:47:19');
INSERT INTO `tb_labels` VALUES ('9d5eb002705648e2bc3d345fa34a8191', '19eb3dd59ef8430d9f637d97449fc417', 'microsoft', null, null, '2020-04-16 16:59:34', '2020-04-16 16:59:34');
INSERT INTO `tb_labels` VALUES ('9eccd82e1d9a4a8cb3a0971df3788f2b', '7b3e40f8b9cc4b7780dc39a71d7f580e', '微信分享', null, null, '2020-04-16 16:49:22', '2020-04-16 16:49:22');
INSERT INTO `tb_labels` VALUES ('9f3d90e736494f6d9cb8cab5f854d73a', '819ad72c1efe450f9d7affc135a4b457', 'android-studio', '', '', '2020-04-16 15:16:30', '2020-04-16 15:16:30');
INSERT INTO `tb_labels` VALUES ('9fc0276000e346da8c0bab1b5f78adaa', 'ee1accc0cfb444fa96d6811569830ecd', '感悟', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('a0ac07cb5e6b446f8d1b9034d86fd880', '1a7cc9fbc4654cb0afec84e080816ef1', '推送', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('a1dff4d6d5dd4ee69cb3d44463606477', '1a7cc9fbc4654cb0afec84e080816ef1', '小游戏', null, null, '2020-04-16 16:57:53', '2020-04-16 16:57:53');
INSERT INTO `tb_labels` VALUES ('a4f4fd7a73b84a7298db0174165eeaac', '1a7cc9fbc4654cb0afec84e080816ef1', '游戏', null, null, '2020-04-16 16:57:48', '2020-04-16 16:57:48');
INSERT INTO `tb_labels` VALUES ('a75d7c6da04041d5a9cf4dd7e270c3cf', 'ee1accc0cfb444fa96d6811569830ecd', 'im', null, null, '2020-04-16 16:47:12', '2020-04-16 16:47:12');
INSERT INTO `tb_labels` VALUES ('a7e018e203b949f0b51e659db4105653', 'ee1accc0cfb444fa96d6811569830ecd', 'kotlin', null, null, '2020-04-16 16:47:11', '2020-04-16 16:47:11');
INSERT INTO `tb_labels` VALUES ('a819e12d8465406d8430a3e7ee826d1c', 'a0ea520851b4484f9cebac9ff7e47bc6', '阿里巴巴', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('a83bf36999c94af989d2d78048df00b8', 'b299a2a48cd64e77a3431ce958b42055', '抓包过滤', null, null, '2020-04-16 16:56:38', '2020-04-16 16:56:38');
INSERT INTO `tb_labels` VALUES ('ab4f466a6a72457aaa22b3d483e4a681', '049b3bd76c1e49ccbe48b36197e77f76', '总结', null, null, '2020-04-23 09:39:02', '2020-04-23 09:39:02');
INSERT INTO `tb_labels` VALUES ('ab8cfc2b4fa94f78beca7b277e36dfd1', 'bb0b7e69ad3e46fcb121baefda8f1f78', '组合', null, null, '2020-04-23 10:28:36', '2020-04-23 10:28:36');
INSERT INTO `tb_labels` VALUES ('ac3b36c7838044519e53efc72ad02613', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'mpvue', '', '', '2020-04-16 15:13:26', '2020-04-16 15:13:26');
INSERT INTO `tb_labels` VALUES ('acf0403b8ea14effb582f96401d99449', '19eb3dd59ef8430d9f637d97449fc417', 'npm', null, null, '2020-04-23 10:59:01', '2020-04-23 10:59:01');
INSERT INTO `tb_labels` VALUES ('aed399344712406e830d6efe028b7fe2', 'ee1accc0cfb444fa96d6811569830ecd', '思否news', null, null, '2020-04-16 16:47:08', '2020-04-16 16:47:08');
INSERT INTO `tb_labels` VALUES ('affcefc3661947ccae893a1ed7dbca10', 'a0ea520851b4484f9cebac9ff7e47bc6', '供应链', null, null, '2020-04-16 16:59:09', '2020-04-16 16:59:09');
INSERT INTO `tb_labels` VALUES ('b350d9c92c524bb4b9feedd40e5eebcd', '049b3bd76c1e49ccbe48b36197e77f76', 'vue.js', '', '', '2020-04-14 20:04:01', '2020-04-14 20:04:01');
INSERT INTO `tb_labels` VALUES ('b397b0f03396401ea7132d8a82b5fac9', '049b3bd76c1e49ccbe48b36197e77f76', '高德地图', null, null, '2020-04-23 09:39:06', '2020-04-23 09:39:06');
INSERT INTO `tb_labels` VALUES ('b3b8c4672aad4d63919b3a05dac79983', '049b3bd76c1e49ccbe48b36197e77f76', 'ecmascript', '', '', '2020-04-14 20:04:12', '2020-04-14 20:04:12');
INSERT INTO `tb_labels` VALUES ('b3f77d5589a04c80899972f9efe8752f', 'b299a2a48cd64e77a3431ce958b42055', '灵雀云', '', '', '2020-04-16 15:21:23', '2020-04-16 15:21:23');
INSERT INTO `tb_labels` VALUES ('b456ad7a7d1d468ba659bb4c31f24e99', '049b3bd76c1e49ccbe48b36197e77f76', '浏览器', null, null, '2020-04-16 16:09:17', '2020-04-16 16:09:17');
INSERT INTO `tb_labels` VALUES ('b687605a1b8842a593f27620e3c26af5', '04547238127a4676b504cc4496865d7b', 'chrome', null, null, '2020-04-16 16:58:55', '2020-04-16 16:58:55');
INSERT INTO `tb_labels` VALUES ('b7460efd3f3b4d6ea78254959a2aebff', 'a337904dd1d5477b9689d7693be316de', 'app', null, null, '2020-04-16 16:50:15', '2020-04-16 16:50:15');
INSERT INTO `tb_labels` VALUES ('b7ff3b2c61d84f139d3fea7fcb5d3131', 'b299a2a48cd64e77a3431ce958b42055', '美团云', '', '', '2020-04-16 15:20:19', '2020-04-16 15:20:19');
INSERT INTO `tb_labels` VALUES ('b84d5a3e64644516915697f2c8409437', '1a7cc9fbc4654cb0afec84e080816ef1', 'serverless', null, null, '2020-04-16 16:57:53', '2020-04-16 16:57:53');
INSERT INTO `tb_labels` VALUES ('ba16f5b739f24380990a4ccacfe6f833', 'b299a2a48cd64e77a3431ce958b42055', 'amazon-web-services', '', '', '2020-04-16 15:19:50', '2020-04-16 15:19:50');
INSERT INTO `tb_labels` VALUES ('ba43c444c9a0480dae0ea17d7463821b', '049b3bd76c1e49ccbe48b36197e77f76', 'ajax', '', '', '2020-04-14 20:03:15', '2020-04-14 20:03:15');
INSERT INTO `tb_labels` VALUES ('ba4a5064430447f5a3a2eb9aae580758', 'ee1accc0cfb444fa96d6811569830ecd', 'paas', null, null, '2020-04-16 16:47:12', '2020-04-16 16:47:12');
INSERT INTO `tb_labels` VALUES ('bacd32e8a1ea43c8967204c5abba4872', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'wepy', '', '', '2020-04-16 15:13:19', '2020-04-16 15:13:19');
INSERT INTO `tb_labels` VALUES ('bad2e32fdd944a439f9b2d3890ef749c', '91832bd0c3a244fb88c0bca74c0d404d', 'nginx', null, null, '2020-04-23 11:01:15', '2020-04-23 11:01:15');
INSERT INTO `tb_labels` VALUES ('bb08094058724cb5a595418407aa6c06', 'ee1accc0cfb444fa96d6811569830ecd', 'dokit', null, null, '2020-04-16 16:47:21', '2020-04-16 16:47:21');
INSERT INTO `tb_labels` VALUES ('bc0022273e34499a9bc31681102eb488', 'a337904dd1d5477b9689d7693be316de', 'xcode', '', '', '2020-04-16 15:14:49', '2020-04-16 15:14:49');
INSERT INTO `tb_labels` VALUES ('bec7f52ed0374eaab0d1172b70a1e739', '1a7cc9fbc4654cb0afec84e080816ef1', 'canvas', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('c0d2479bf6564cf5aa35b1b40604f199', 'ee1accc0cfb444fa96d6811569830ecd', 'talkingdata', null, null, '2020-04-16 16:47:11', '2020-04-16 16:47:11');
INSERT INTO `tb_labels` VALUES ('c2232afd87094fb88ae1b65a43876011', '91832bd0c3a244fb88c0bca74c0d404d', 'kafka', null, null, '2020-04-23 11:01:07', '2020-04-23 11:01:07');
INSERT INTO `tb_labels` VALUES ('c239cd5742204caf9461f570ba33e8ae', '819ad72c1efe450f9d7affc135a4b457', '编程语言', null, null, '2020-04-23 10:35:00', '2020-04-23 10:35:00');
INSERT INTO `tb_labels` VALUES ('c5c7574f5419441aba6a3361c81ef09e', '049b3bd76c1e49ccbe48b36197e77f76', 'es6', null, null, '2020-04-16 16:09:04', '2020-04-16 16:09:04');
INSERT INTO `tb_labels` VALUES ('c62a8c466b0546c19e04906b878a96d2', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'java-ee', '', '', '2020-04-16 15:09:22', '2020-04-16 15:09:22');
INSERT INTO `tb_labels` VALUES ('c6611ad44f6e40fea7acd54a33ad01c2', 'a0ea520851b4484f9cebac9ff7e47bc6', '微服务', null, null, '2020-04-16 16:59:09', '2020-04-16 16:59:09');
INSERT INTO `tb_labels` VALUES ('c6be57ee659c4ebe8f254e3e7adf74a2', 'a0ea520851b4484f9cebac9ff7e47bc6', 'oceanbase', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('c7913adc87544598962767df48355990', 'cbad2058b4014634aec6515f4adbef0d', '语音', null, null, '2020-04-16 16:55:38', '2020-04-16 16:55:38');
INSERT INTO `tb_labels` VALUES ('c825aa5f765543a1a8c96368462f9371', '1a7cc9fbc4654cb0afec84e080816ef1', '即时通讯', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('c8cd9b29a54f4d27bee226951a981924', '049b3bd76c1e49ccbe48b36197e77f76', 'oop', null, null, '2020-04-16 16:09:20', '2020-04-16 16:09:20');
INSERT INTO `tb_labels` VALUES ('c9c8ca5b55c44b598a25593a4a204e20', 'ee1accc0cfb444fa96d6811569830ecd', '数据分析', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('cb1ca7cb006244a3a4b5b52cb568301c', 'ee1accc0cfb444fa96d6811569830ecd', '购物车', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('cb77a1c04f4241b98e8f6d57d78e3e10', 'a2718d66a7234b1499ed897ff4df05c8', '电信', null, null, '2020-04-16 17:00:14', '2020-04-16 17:00:14');
INSERT INTO `tb_labels` VALUES ('cc944f24ed5e4383a975481674f255e0', 'cbad2058b4014634aec6515f4adbef0d', '又拍云', null, null, '2020-04-16 16:55:35', '2020-04-16 16:55:35');
INSERT INTO `tb_labels` VALUES ('ccaaa3888a50432ebcbc469fa62c40b5', 'a337904dd1d5477b9689d7693be316de', 'afnetworking', null, null, '2020-04-16 16:50:18', '2020-04-16 16:50:18');
INSERT INTO `tb_labels` VALUES ('cdff0c49eb5e40918b3cfb6f3048b361', 'b299a2a48cd64e77a3431ce958b42055', 'deepflow', '', '', '2020-04-16 15:21:10', '2020-04-16 15:21:10');
INSERT INTO `tb_labels` VALUES ('cefcbb7ca2c24b738ea0386eb45886de', 'ee1accc0cfb444fa96d6811569830ecd', 'graphql', null, null, '2020-04-16 16:47:09', '2020-04-16 16:47:09');
INSERT INTO `tb_labels` VALUES ('cf84afe221f24e72b201344b3e15fa85', 'ee1accc0cfb444fa96d6811569830ecd', '移动应用开发', null, null, '2020-04-16 16:47:21', '2020-04-16 16:47:21');
INSERT INTO `tb_labels` VALUES ('cf8fd6f64b3f46d5a7a3468a046b4d3e', '19eb3dd59ef8430d9f637d97449fc417', '开源框架', null, null, '2020-04-16 16:59:36', '2020-04-16 16:59:36');
INSERT INTO `tb_labels` VALUES ('cfd640a90e5f4fa7b713a1afcedf12cf', 'cbad2058b4014634aec6515f4adbef0d', '亚马逊', null, null, '2020-04-16 16:55:38', '2020-04-16 16:55:38');
INSERT INTO `tb_labels` VALUES ('cff4263234c04178b6f716310595544e', '19eb3dd59ef8430d9f637d97449fc417', '监控工具', null, null, '2020-04-16 16:59:33', '2020-04-16 16:59:33');
INSERT INTO `tb_labels` VALUES ('d009d894f21a489c88c52d85c142b3ba', 'a0ea520851b4484f9cebac9ff7e47bc6', '黑客马拉松', null, null, '2020-04-16 16:59:10', '2020-04-16 16:59:10');
INSERT INTO `tb_labels` VALUES ('d07dbcd8900c4d34811137be64dd4301', '049b3bd76c1e49ccbe48b36197e77f76', 'css3', '', '', '2020-04-09 19:48:44', '2020-04-09 19:48:44');
INSERT INTO `tb_labels` VALUES ('d0d5d1c0f4924513816e10a4cf13fb12', 'cbad2058b4014634aec6515f4adbef0d', 'tensorflow', '', '', '2020-04-16 15:18:57', '2020-04-16 15:18:57');
INSERT INTO `tb_labels` VALUES ('d114b152c3b644a6ab136104b4330b6f', '19eb3dd59ef8430d9f637d97449fc417', 'paddlefl', null, null, '2020-04-16 16:59:30', '2020-04-16 16:59:30');
INSERT INTO `tb_labels` VALUES ('d16a93d83052441a90afaa57d69fdc3c', '049b3bd76c1e49ccbe48b36197e77f76', 'node.js', '', '', '2020-04-14 20:04:47', '2020-04-14 20:04:47');
INSERT INTO `tb_labels` VALUES ('d1d122dcdca34dceaad794efaef79d56', '19eb3dd59ef8430d9f637d97449fc417', '数据仓库', null, null, '2020-04-16 16:59:29', '2020-04-16 16:59:29');
INSERT INTO `tb_labels` VALUES ('d3d03b3c361b4e3f9148f6ae02761c29', '91832bd0c3a244fb88c0bca74c0d404d', 'kubernetes', null, null, '2020-04-16 17:00:00', '2020-04-16 17:00:00');
INSERT INTO `tb_labels` VALUES ('d56b9fa723c243c3bfff49e3717856d3', '2a353971222c4aff8e8d3e9c370330cd', '应用', null, null, '2020-04-16 16:59:47', '2020-04-16 16:59:47');
INSERT INTO `tb_labels` VALUES ('d684aaace0484f8dbc17e1e28457d432', '1a7cc9fbc4654cb0afec84e080816ef1', '2019总结', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('d7416e100af54eb7a4d9274b9a462240', 'ee1accc0cfb444fa96d6811569830ecd', '运维', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('d79254c4ca5e45dca9d484307c935281', '049b3bd76c1e49ccbe48b36197e77f76', 'javascript', '', '', '2020-04-09 19:49:00', '2020-04-09 19:49:00');
INSERT INTO `tb_labels` VALUES ('d900360696e74d06b4c4ae08198d3c11', '19eb3dd59ef8430d9f637d97449fc417', '分布式系统', null, null, '2020-04-23 10:58:56', '2020-04-23 10:58:56');
INSERT INTO `tb_labels` VALUES ('d9330057da5647f68af981444ac862f0', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'struts', '', '', '2020-04-16 15:09:57', '2020-04-16 15:09:57');
INSERT INTO `tb_labels` VALUES ('d93a57344da0482d9257c6279866c8a1', 'b299a2a48cd64e77a3431ce958b42055', '金山云', '', '', '2020-04-16 15:20:09', '2020-04-16 15:20:09');
INSERT INTO `tb_labels` VALUES ('d986ab02dd4345098381ef8b01db7e4d', '19eb3dd59ef8430d9f637d97449fc417', '美团', null, null, '2020-04-16 16:59:29', '2020-04-16 16:59:29');
INSERT INTO `tb_labels` VALUES ('db5ba932c64646c2a6e112753fbd78d2', '3798854967b444e0b8156e5154f94b97', '数字化货币', '', '', '2020-04-16 15:23:25', '2020-04-16 15:23:25');
INSERT INTO `tb_labels` VALUES ('db6b58ae709645f2b64166fd73f2f705', 'b299a2a48cd64e77a3431ce958b42055', '工具', null, null, '2020-04-16 16:56:38', '2020-04-16 16:56:38');
INSERT INTO `tb_labels` VALUES ('dc85b19b1d3742cabe11b25cce8f79b2', '19eb3dd59ef8430d9f637d97449fc417', 'Tars', null, null, '2020-04-16 16:59:35', '2020-04-16 16:59:35');
INSERT INTO `tb_labels` VALUES ('dced02b7f53045f9b0bc172e06ba8202', 'a2718d66a7234b1499ed897ff4df05c8', '华为', null, null, '2020-04-16 17:00:14', '2020-04-16 17:00:14');
INSERT INTO `tb_labels` VALUES ('dd1f4cf63050478eb6179b794afaf40c', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'idea', '', '', '2020-04-16 15:10:47', '2020-04-16 15:10:47');
INSERT INTO `tb_labels` VALUES ('ddfb55921ea24001b6178c86a1d11095', 'ee1accc0cfb444fa96d6811569830ecd', '系统架构', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('df5b4b0986d44f169be91f7496d1dbc5', 'a337904dd1d5477b9689d7693be316de', 'react-native', null, null, '2020-04-16 16:50:15', '2020-04-16 16:50:15');
INSERT INTO `tb_labels` VALUES ('df8bf047f459444da79182766276661c', 'b299a2a48cd64e77a3431ce958b42055', '七牛云存储', '', '', '2020-04-16 15:19:40', '2020-04-16 15:19:40');
INSERT INTO `tb_labels` VALUES ('e08558de0cef4bd899b5b6aa03550a21', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'cpu', null, null, '2020-04-16 16:48:53', '2020-04-16 16:48:53');
INSERT INTO `tb_labels` VALUES ('e0a1c37357374c5b81385440f46da50d', '049b3bd76c1e49ccbe48b36197e77f76', 'react.js', '', '', '2020-04-14 20:03:42', '2020-04-14 20:03:42');
INSERT INTO `tb_labels` VALUES ('e1461b476a0f4662aa26c90ecff5579b', 'a0ea520851b4484f9cebac9ff7e47bc6', '组件库', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('e2937a6cc53645a0909a3904d8b4517d', 'a337904dd1d5477b9689d7693be316de', 'objective-c', '', '', '2020-04-16 15:14:19', '2020-04-16 15:14:19');
INSERT INTO `tb_labels` VALUES ('e75baefb206a4efe959a99aad77632a3', '049b3bd76c1e49ccbe48b36197e77f76', '安全', null, null, '2020-04-16 16:09:18', '2020-04-16 16:09:18');
INSERT INTO `tb_labels` VALUES ('e7ef2c314f5244fd810e87742ea22b53', 'ee1accc0cfb444fa96d6811569830ecd', '网络安全', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('e80d97c3472e428dabdaf417adac7a3c', 'b299a2a48cd64e77a3431ce958b42055', '云计算', '', '', '2020-04-16 15:19:24', '2020-04-16 15:19:24');
INSERT INTO `tb_labels` VALUES ('ead69bffd58e43f2a5ead395c498cf8e', '7b3e40f8b9cc4b7780dc39a71d7f580e', '组件化', null, null, '2020-04-16 16:49:24', '2020-04-16 16:49:24');
INSERT INTO `tb_labels` VALUES ('ec3409e632664448918190c226301c4b', '04547238127a4676b504cc4496865d7b', 'ssh', null, null, '2020-04-16 16:58:56', '2020-04-16 16:58:56');
INSERT INTO `tb_labels` VALUES ('ed28022185f44ae4ba91f8f8b36dc265', '1a7cc9fbc4654cb0afec84e080816ef1', '云存储', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('ee14e23a519141ae9086e8f917ca1d67', 'a337904dd1d5477b9689d7693be316de', 'ipad', '', '', '2020-04-16 15:15:32', '2020-04-16 15:15:32');
INSERT INTO `tb_labels` VALUES ('efd45535a5504d5595fba4d1dbbc489c', 'cbad2058b4014634aec6515f4adbef0d', '机器学习', '', '', '2020-04-16 15:18:41', '2020-04-16 15:18:41');
INSERT INTO `tb_labels` VALUES ('f0e336796bd94b8299ef69b2b2529ec4', '049b3bd76c1e49ccbe48b36197e77f76', 'http', null, null, '2020-04-16 16:09:20', '2020-04-16 16:09:20');
INSERT INTO `tb_labels` VALUES ('f24f055e94ea41f8bf02c87b34244ace', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'utf-8', null, null, '2020-04-23 10:28:22', '2020-04-23 10:28:22');
INSERT INTO `tb_labels` VALUES ('f2fb7d236fec4c138cacd9162eb4488c', 'a337904dd1d5477b9689d7693be316de', 'https', null, null, '2020-04-16 16:50:18', '2020-04-16 16:50:18');
INSERT INTO `tb_labels` VALUES ('f3eb17e6e5664a97af3e9b1fca12b286', 'ee1accc0cfb444fa96d6811569830ecd', '开放源代码', null, null, '2020-04-16 16:47:15', '2020-04-16 16:47:15');
INSERT INTO `tb_labels` VALUES ('f4485e212bb64f2a8d2761524742e3d7', '91832bd0c3a244fb88c0bca74c0d404d', '找工作', null, null, '2020-04-16 17:00:05', '2020-04-16 17:00:05');
INSERT INTO `tb_labels` VALUES ('f4fda25145b9451a9b0d77d6a2a63712', '2a353971222c4aff8e8d3e9c370330cd', 'git', null, null, '2020-04-16 16:59:46', '2020-04-16 16:59:46');
INSERT INTO `tb_labels` VALUES ('f6a07ced05b54932b0989568f55b64ee', '049b3bd76c1e49ccbe48b36197e77f76', 'webpack', null, null, '2020-04-23 09:38:59', '2020-04-23 09:38:59');
INSERT INTO `tb_labels` VALUES ('f7e58b2632604a99bbb8f9471c0675ad', 'ee1accc0cfb444fa96d6811569830ecd', '前端框架', null, null, '2020-04-16 16:47:20', '2020-04-16 16:47:20');
INSERT INTO `tb_labels` VALUES ('f831bc1c03f94b4b9e49390a3a354a3e', '7b3e40f8b9cc4b7780dc39a71d7f580e', '云服务', null, null, '2020-04-16 16:49:23', '2020-04-16 16:49:23');
INSERT INTO `tb_labels` VALUES ('f913584336564c05976ae3797003d1f3', 'bb0b7e69ad3e46fcb121baefda8f1f78', '继承', null, null, '2020-04-23 10:28:36', '2020-04-23 10:28:36');
INSERT INTO `tb_labels` VALUES ('f989bd033828421fba0efd21536e57e4', 'cbad2058b4014634aec6515f4adbef0d', '神经网络', '', '', '2020-04-16 15:18:25', '2020-04-16 15:18:25');
INSERT INTO `tb_labels` VALUES ('f9a5763f0e7f47a99e6d6f8f962f1d92', '049b3bd76c1e49ccbe48b36197e77f76', '测试', null, null, '2020-04-23 09:39:05', '2020-04-23 09:39:05');
INSERT INTO `tb_labels` VALUES ('faf36da502544b51be926ab85450c40d', 'bb0b7e69ad3e46fcb121baefda8f1f78', '算法', null, null, '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_labels` VALUES ('fb364499fe3f4b5bb7f0442e2fe0df82', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'apache', null, null, '2020-04-16 16:48:54', '2020-04-16 16:48:54');
INSERT INTO `tb_labels` VALUES ('fb50fb634b0d40f5af9f608e6ebbd8d1', 'b299a2a48cd64e77a3431ce958b42055', '又拍云存储', '', '', '2020-04-16 15:19:31', '2020-04-16 15:19:31');
INSERT INTO `tb_labels` VALUES ('fd167cdfd8a045b59f76eaf678fc15b9', 'a337904dd1d5477b9689d7693be316de', 'cocoa', '', '', '2020-04-16 15:15:08', '2020-04-16 15:15:08');
INSERT INTO `tb_labels` VALUES ('fe12e28fbbf0499eb1f1008377ea09ff', 'ee1accc0cfb444fa96d6811569830ecd', '代码规范', null, null, '2020-04-16 16:47:19', '2020-04-16 16:47:19');
INSERT INTO `tb_labels` VALUES ('fe213d41bcb743e2840d8aa58cf48d3e', '049b3bd76c1e49ccbe48b36197e77f76', '网页爬虫', null, null, '2020-04-16 16:09:14', '2020-04-16 16:09:14');
INSERT INTO `tb_labels` VALUES ('fe6fc6074c634420b6d2a69f54fc6c50', '7b3e40f8b9cc4b7780dc39a71d7f580e', '百度智能小程序', '', '', '2020-04-16 15:12:38', '2020-04-16 15:12:38');

-- ----------------------------
-- Table structure for tb_recommend
-- ----------------------------
DROP TABLE IF EXISTS `tb_recommend`;
CREATE TABLE `tb_recommend` (
  `uuid` varchar(50) CHARACTER SET utf8 NOT NULL,
  `title` varchar(60) CHARACTER SET utf8 DEFAULT NULL COMMENT '标题',
  `excerpt` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '列表展示字段',
  `content` longtext CHARACTER SET utf8mb4 COMMENT '富文本内容',
  `markdown_content` longtext COMMENT 'markdown内容',
  `image_url` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '封面图',
  `user_id` varchar(50) CHARACTER SET utf8 DEFAULT NULL COMMENT '用户id',
  `channels_id` varchar(50) DEFAULT NULL COMMENT '频道id',
  `labels` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '标签id',
  `views_word` int(11) DEFAULT NULL COMMENT '阅读数',
  `status` int(1) DEFAULT NULL COMMENT '1、草稿箱  2、审核中 3、推荐',
  `type` int(1) DEFAULT NULL COMMENT '1 文章  2 问答',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=sjis COMMENT='文章、问答表';

-- ----------------------------
-- Records of tb_recommend
-- ----------------------------
INSERT INTO `tb_recommend` VALUES ('02145521c95a40a5b974716615870da6', 'GitHub 发了大福利后，羊毛党正在路上', '内容提要：GitHub 从今天起，面向全体个人和团队，免费提供不限制协作人数的私有仓库，所有核心功能也统统免费。不过，全面免费政策背后，也带来一些隐忧。', '<blockquote>\n 内容提要：GitHub 从今天起，面向全体个人和团队，免费提供不限制协作人数的私有仓库，所有核心功能也统统免费。不过，全面免费政策背后，也带来一些隐忧。\n</blockquote> \n<blockquote>\n 关键词：GitHub 团队 免费 滥用\n</blockquote> \n<p>重磅消息！GitHub 今天凌晨官宣，面向全体 GitHub 用户和团队，提供不限制协作人数的私有仓库，并且，GitHub 的全部核心功能现已对所有人免费提供。</p> \n<h2>喜大普奔，GitHub 发放超级福利</h2> \n<p>GitHub 的 CEO Nat Friedman 在官宣博客中说，到目前为止，如果任何组织要使用 GitHub 进行私有开发，都必须付费。但是每个开发人员都应该可以访问 GitHub，价格不应该成为障碍。</p> \n<p>现在，这一免费计划的公布，意味着团队现在可以在一个地方一起管理他们的工作：CI / CD，项目管理，代码审查，软件包等等。GitHub 希望每个人都能在平台上发布出色的软件。</p> \n<p>而需要高级功能（例如代码所有者）、企业功能（例如 SAML）或个性化支持的团队，可以进行付费升级。</p> \n<p>此外，付费团队月定价，也从 9 美元/人降低到 4 美元/人，立即生效。已付费用户怎么办？不用担心，GitHub 会在 30 天内退还差价。</p> \n<p>具体计划和价格变化如下：</p> \n<ul> \n <li>面向组织的 GitHub Free 立即可用，包括私有仓库将不再有人数限制；</li> \n <li>以前使用 Team for Open Source 的所有组织，现在都拥有 GitHub Free；</li> \n <li>面向个人开发人员的 GitHub Free 对协作组人数不作限制；</li> \n <li>使用 GitHub Free 的组织和个人，将获得 GitHub Community Support；</li> \n <li>GitHub Pro 现在将包括 2GB 的 Packages 存储和 10GB 的数据传输；每月价格从 7 美元降至 4 美元；</li> \n <li>GitHub Team 现在每个用户的月费降低为 4 美元，不设最低消费；</li> \n <li>自 5 月 14 日起，GitHub 团队每月将为私有仓库提供 3000 分钟的 actions 时间。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5yt\" src=\"http://localhost:8060/tup/2020/4/23/f8e7ef62a0d64f1aa6210e47dc2ce019.jpg\" alt=\"6c9fc1191544382709d9b8b952a7c240.jpg\" title=\"6c9fc1191544382709d9b8b952a7c240.jpg\"></span></p> \n<ul>\n <li><em>最新定价表，GitHub Free 新增面向团队私有仓库，GitHub Team 月定价由 9 美元降为 4 美元</em></li>\n</ul> \n<h2>用户：真香！感谢微软爸爸</h2> \n<p>Nat Friedman 在声明中写道，GitHub 上已经有超过 4000 万开发者，团队估计 2025 年这个数字会达到 1 个亿。</p> \n<p>也就是说，截至目前，就有超过 4000 万用户将享受到这些福利。</p> \n<p>在大家喜大普奔之余，都很好奇：GitHub 怎么这么有钱了？靠什么盈利呢？</p> \n<p>在今天 Hacker News 上 Nat Friedman 的在线答疑中，一位网友忍不住好奇直接发问，而 Friedman 的回答是，「我们的大型企业用户真的很多！」</p> \n<p>但是，事实是否真的如此？</p> \n<p>其实 GitHub 的盈利模式此前一直是大家探讨的热门话题。曾有人分析， GitHub 与 BitBucket、Gitlab 相比，盈利方面都没有竞争优势。比如，Gitlab 基于其开源版本之上的解决方案，可能更适合愿意支付高价的大企业。</p> \n<p>微软当初收购 GitHub 的目的，也并不是看中其盈利与否，而更在意 GitHub 带来的客户资源及其在未来创造的更大的价值。</p> \n<p>如此说来，GitHub 就可以只负责吸引更多用户，其它花钱什么的，交给财大气粗的微软爸爸就好。</p> \n<p>在 Nat Friedman 公布此消息的推文下面，清一色的欢呼叫好声，以及对微软爸爸的感恩。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5y8\" src=\"http://localhost:8060/tup/2020/4/23/43b81a3d36ed473794cbc8b699eef503.jpg\" alt=\"c12f137d44b32fdf204a94c518315cb6.jpg\" title=\"c12f137d44b32fdf204a94c518315cb6.jpg\"></span></p> \n<p>微博上也满满的写着开心：有微软爸爸真好！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5zC\" src=\"http://localhost:8060/tup/2020/4/23/6bf84df8124746e680993767904dbad1.jpg\" alt=\"b1dfe970bd9bd128a84afb649f08c89d.jpg\" title=\"b1dfe970bd9bd128a84afb649f08c89d.jpg\"></span></p> \n<p>的确，GitHub 的一系列免费政策，都是在被微软收购之后。</p> \n<p>去年 1 月 8 日， GitHub 就宣布了面向个人开发者私有仓库免费，即 GitHub Free，同时提供 3 个免费协作人数的名额，如果需要更多的协作人数，则需要付费。</p> \n<p>这一宣布在当时已经被大家「真香」了，现在，GitHub 又大手一挥，直接面向团队开放 GitHub Free，一大批新用户可能正在赶来。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5zI\" src=\"http://localhost:8060/tup/2020/4/23/7bed78323dc5453bbee0b60731724e41.jpg\" alt=\"3903231a54485d52ad5c19ac57a5b57a.jpg\" title=\"3903231a54485d52ad5c19ac57a5b57a.jpg\"></span></p> \n<ul>\n <li><em>国内很多开发者还表示要去修墙</em></li>\n</ul> \n<h2>图床、矿机、云盘：福利也带来滥用风险</h2> \n<p>在微软财力支持下，GitHub 越来越良心，这对于大部分开发者来说是好事。</p> \n<p>但是，这也不免让人担忧它是否会被滥用？比如无限的云存储空间被当做免费网盘或图床来使用。</p> \n<p>知乎网友用 GitHub 来做轻量级网盘</p> \n<p>甚至还有开发者针对如何将 GitHub 变为无限云网盘写了教程：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5Ae\" src=\"http://localhost:8060/tup/2020/4/23/2ac05c5b65f7452797fff27849c88e2f.jpg\" alt=\"fff27ae6cfd192c40df544bce2232d30.jpg\" title=\"fff27ae6cfd192c40df544bce2232d30.jpg\"></span></p> \n<ul>\n <li><em>让微软为你的无限云存储买单</em></li>\n</ul> \n<p>今天 GitHub 福利刚发出来，可能一大波羊毛党就已经坐不住了。</p> \n<p>此外，还有黑客利用 GitHub 的免费网页代管服务 GitHub Pages 从事网钓攻击行动。</p> \n<p>这些担忧并不是多余的，免费服务被薅羊毛、滥用的例子已有之。比如 Google Colab 提供的免费 GPU 资源，就会被一些羊毛党用来挖矿。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5Ai\" src=\"http://localhost:8060/tup/2020/4/23/4931362dbe5e452d97749eacc004557e.jpg\" alt=\"6682fbdfb07097fac40758d9c189ba79.jpg\" title=\"6682fbdfb07097fac40758d9c189ba79.jpg\"></span></p> \n<p>这些滥用操作只会对平台和用户造成伤害。不过，相信 GitHub 也会考虑到这些问题，出台相关限制政策，让平台更加良性地发展下去。</p> \n<p>&lt;完&gt;</p>', null, 'http://localhost:8060/tup/2020/4/23/6b301c2163d642a7ab48e5e21c2283bf.jpg', 'f53014d680884163a5bd5ce762e90cdf', 'cbad2058b4014634aec6515f4adbef0d', '634b81d655c74cb0adc4d0aa362b8819,efd45535a5504d5595fba4d1dbbc489c', '0', '3', '1', '2020-04-23 10:55:31', '2020-04-23 10:55:31');
INSERT INTO `tb_recommend` VALUES ('0276ececfbe5410a924ed9ce3c909944', '当浏览器全面禁用三方 Cookie', '苹果公司前不久对 Safari 浏览器进行一次重大更新，这次更新完全禁用了第三方 Cookie，这意味着，默认情况下，各大广告商或网站将无法对你的个人隐私进行追踪。而微软和 Mozilla 等也纷纷采取了措施禁用第三方 Co...', '<p>苹果公司前不久对 <code>Safari</code> 浏览器进行一次重大更新，这次更新完全禁用了第三方 <code>Cookie</code>，这意味着，默认情况下，各大广告商或网站将无法对你的个人隐私进行追踪。而微软和 <code>Mozilla</code> 等也纷纷采取了措施禁用第三方 <code>Cookie</code>，但是由于这些浏览器市场份额较小，并没有给市场带来巨大的冲击。</p> \n<p>从 <code>2017</code> 年截至 <code>2019</code> 年底， <code>Google</code> 面临的罚款总额已经超过 93 亿欧元，其中一大原因便是侵犯用户数据隐私。迫于巨大压力，<code>Google Chrome</code> 官方团队前不久也宣布，为了提升用户隐私和安全，未来两年将完全禁用第三方 <code>Cookie</code>。</p> \n<p>在完全不能写入三方 <code>Cookie</code> 的情况下，将会对前端的数据读写方式，甚至是整个广告行业带来巨大影响。</p> \n<h2>Cookie 的意义</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386156\" src=\"http://localhost:8060/tup/2020/4/23/4361ee1ac7f44aab81d5fdd8640b9230.jpg\" alt=\"\" title=\"\"></span></p> \n<p>众所周知，<code>HTTP</code> 协议是无状态的协议，如果你在同一个客户端向服务器发送多次请求，服务器不会知道这些请求来自同一客户端。</p> \n<p>这正是 <code>HTTP</code> 协议得以广泛应用的原因，试想一下，如果它是有状态协议，你必须要时刻与服务器建立链接，那么如果连接意外断开，整个会话就会丢失，重新连接之后一般需要从头开始；而如果是无状态协议，使得会话与连接本身独立起来，这样即使连接断开了，会话状态也不会受到严重伤害，保持会话也不需要保持连接本身。</p> \n<p>如果 <code>HTTP</code> 协议只是用来访问静态文件，那不会有任何问题，但是如果你要为广大用户提供更好的服务，服务器就需要知道每个请求具体来自于哪个用户，比如你在逛淘宝的时候你只需要登录一次，当你发起一次购买请求，服务器就已经知道你登录过了，不会再让你进行登录。</p> \n<p>所以 <code>HTTP</code> 协议需要占用浏览器的一小块存储，存储当前访问用户的一些 ”状态“，然后每次发起 <code>HTTP</code> 请求，请求中就会携带这些状态，从而让服务器知道你是谁。 <code>Cookie</code> 出现的的意义就是为了解决这个问题，让无状态的 <code>HTTP</code> 协议拥有一小块记忆。</p> \n<p>但是， <code>Cookie</code> 一经出现，就成了各大广告和购物网站窥探用户隐私的利器，他们使用第三方 <code>Cookie</code> 不断获取你的数据，那么什么第三方 <code>Cookie</code> 呢？</p> \n<h2>第三方 Cookie</h2> \n<p>如果是你正常的正在逛着天猫，天猫会把你的信息写入一些 <code>Cookie</code> 到 <code>.tmall.com</code> 这个域下，然而打开控制台你会看到，并不是所有 <code>Cookie</code> 都是 <code>.tmall.com</code> 这个域下的，里面还有很多其他域下的 <code>Cookie</code> ，这些所有非当前域下的 <code>Cookie</code> 都属于第三方 <code>Cookie</code>，虽然你可能从来没访问过这些域，但是他们已经悄悄的通过这些第三方 <code>Cookie</code>来标识你的信息，然后把你的个人信息发送过去了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386155\" src=\"http://localhost:8060/tup/2020/4/23/517cc729c2314b82a563566d053105e0.jpg\" alt=\"\" title=\"\"></span></p> \n<p>而 <code>.tmall.com</code> 这个域下的 <code>Cookie</code> 都属于第一方 <code>Cookie</code>，那么为什么还需要第三方 <code>Cookie</code> 呢？再打开 <code>taobao.com</code>，你会发现你已经不需要再登录了，因为淘宝、天猫都属于阿里旗下的产品，阿里为他们提供统一的登录服务，同时，你的登录信息也会存到这个统一登录服务的域下，所以存到这个域下的 <code>Cookie</code> 就成了三方 <code>Cookie</code>。</p> \n<p>我们再打开已经完全禁用了第三方 <code>Cookie</code> 的 <code>Safari</code>，发现只剩下 <code>.tmall.com</code> 这个域下的 <code>Cookie</code> 了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386158\" src=\"http://localhost:8060/tup/2020/4/23/b0c4e6b0db92471895b8a131b8be84e9.jpg\" alt=\"\" title=\"\"></span></p> \n<p>这时你会发现即使你已经登录了天猫，再访问淘宝也还是需要登录的，你已经无法享用这样的功能了，而三方 <code>Cookie</code> 可不仅仅就这么点用途，在 <code>Web</code> 开发中，三方 <code>Cookie</code> 的应用非常之广，下面我们再来具体看几个应用场景：</p> \n<h2>三方Cookie的用途</h2> \n<h3>前端日志打点</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386157\" src=\"http://localhost:8060/tup/2020/4/23/64a06d46247a4125916a04d0477c092f.jpg\" alt=\"\" title=\"\"></span></p> \n<p>大多数 <code>Web</code> 站点都会引用一些第三方 <code>SDK</code> 来进行前端异常或性能监控，这些 <code>SDK</code> 会通过一些接口将监控到的信息上传到他们的服务器。一般它们都需要标识每个用户来方便排查问题或者统计 <code>UV</code> 数据，所以当你一此请求这个站点的时候，它们可能会在你的站点上 <code>set</code> 一个 <code>Cookie</code>，后续所有的日志上报请求都会带上这个 <code>Cookie</code> 。</p> \n<p>由于一般这些第三方 <code>SDK</code> 都是用于监控的通用服务，它们肯定会拥有自己独立的域名，比如 <code>log.com</code>，它在你的域名 <code>mysite.com</code> 下种下的 <code>Cookie</code> 就属于第三方 <code>Cookie</code>。</p> \n<h3>广告营销神器 - Facebook Pixel</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386162\" src=\"http://localhost:8060/tup/2020/4/23/8992fb53deb04aaa841522e8baf68897.jpg\" alt=\"\" title=\"\"></span></p> \n<p>在电商业务中，追踪流量、导流量、转换率、销售额这些都是商家最关心的问题。这时候你就可以使用 <code>Facebook Pixel</code>，简单来说 <code>Facebook Pixel</code> 像素就是一串 <code>JavaScript</code> 代码，可以追踪广告的转化量、改进受众定位、使广告花费回报最大化。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386159\" src=\"http://localhost:8060/tup/2020/4/23/14eb907340ff4568b8e59298881e7539.jpg\" alt=\"\" title=\"\"></span></p> \n<p>当访客进入到被设有 <code>Facebook Pixel</code> 的页面时，便会触发这段代码。比如，查看了商品或者加入购物车， <code>Facebook Pixel</code> 便会向系统发送请求来记录这些行为，系统可以利用这些收到的行为信息进一步的做追踪和优化。</p> \n<p>举一个实际例子，我们进入一个国外的电商网站 <code>Brava Fabrics</code> ，你会发现已经被写入了一堆 <code>facebook.com</code> 下的三方 <code>cookie</code>：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386161\" src=\"http://localhost:8060/tup/2020/4/23/e9ac7f14f6754355ad904f56c5f52ed4.jpg\" alt=\"\" title=\"\"></span></p> \n<p>我猜测这个 <code>fr</code> 应该就是用来标识我身份信息的 <code>cookie</code>，然后点击几个页面，在 <code>network</code> 里面找到了几个 <code>facebook</code> 发送的请求，下面是其中一个：</p> \n<pre><code class=\"js\">https://www.facebook.com/tr/?id=382444918612794&amp;ev=PageView&amp;dl=https%3A%2F%2Fbravafabrics.com%2Fcollections%2Fa-moment-of-bliss&amp;rl=https%3A%2F%2Fbravafabrics.com%2F&amp;if=false&amp;ts=1586868288778&amp;sw=1680&amp;sh=1050&amp;ud[ct]=eb045d78d273107348b0300c01d29b7552d622abbc6faf81b3ec55359aa9950c&amp;ud[country]=eb045d78d273107348b0300c01d29b7552d622abbc6faf81b3ec55359aa9950c&amp;v=2.9.15&amp;r=stable&amp;ec=0&amp;o=30&amp;fbp=fb.1.1586867082370.951509876&amp;it=1586868284974&amp;coo=false&amp;rqm=GET</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386160\" src=\"http://localhost:8060/tup/2020/4/23/ee94b349f4b54353aa535fe6a2f10996.jpg\" alt=\"\" title=\"\"></span></p> \n<p>查看详情你会发现，有下面几个主要的参数：</p> \n<pre><code>dl: https://bravafabrics.com/collections/a-moment-of-bliss\nrl: https://bravafabrics.com/</code></pre> \n<p>这时 <code>facebook</code> 已经知道了我从 <code>https://bravafabrics.com/</code> 来到了 <code>https://bravafabrics.com/collections/a-moment-of-bliss</code> 这个页面，同时，这个请求会携带 <code>fr=09wX7ui8MrvCh2SIa..BdNoGz.f.F6R.0.0.Belanb.AWXCDx</code> 这个 <code>Cookie</code>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386163\" src=\"http://localhost:8060/tup/2020/4/23/1cf7d512c8f54e9abc1cb9ccf2ee0b96.jpg\" alt=\"\" title=\"\"></span></p> \n<p>来到 <code>facebook</code>，当你登录后，<code>facebook</code> 会把刚刚这些 <code>Cookie</code> 和你的 <code>facebook Id</code> 关联起来，然后他就可以好好的分析你的行为了：</p> \n<ul> \n <li>有人在你的网站上完成了购买。</li> \n <li>有人注册进行试用，或者以其他方式将自己标识为你网站上的潜在客户。</li> \n <li>有人在你网站上的购买过程中输入他们的付款信息。</li> \n <li>有人将产品添加你网站上的购物车中。</li> \n <li>有人选择特定版本的产品，例如选择某种颜色。</li> \n <li>有人发起了结账，但没有付款</li> \n <li>...</li> \n</ul> \n<p>而如此强大的追踪能力，只需要你复制一段 <code>Facebook Pixel</code> 的 <code>JavaScript</code> 脚本到你的页面上就可以了。而这一切能力就建立在一个小小的 <code>Cookie</code> 的基础上，因为有了这个 <code>Cookie</code> ，<code>Facebook</code> 才能将这些行为与它的账号体系进行关联。</p> \n<h3>无处不在的的 mmstat</h3> \n<p>再来看一个我们国内的例子，平时我们在国内的搜索引擎或视频网站上搜索到一些东西，然后打开购物网站就可以收到各种你兴趣的相关推荐，这已经是大众习以为常的事情了，各大购物网站、广告商，会通过第三方 <code>Cookie</code> 收集你的年龄、性别、浏览历史等从而判断你的兴趣喜好，然后带给你精准的信息推荐。</p> \n<p>比如，我们在浏览百度、优酷、天猫等网站时，都能看到几个 <code>.mmstat.com</code> 这个域下的 <code>Cookie</code></p> \n<p>百度：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386164\" src=\"http://localhost:8060/tup/2020/4/23/0aadfc25ecbd43e2955150e327a424e1.jpg\" alt=\"\" title=\"\"></span></p> \n<p>优酷：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386165\" src=\"http://localhost:8060/tup/2020/4/23/11a09747bdac4b3bbe6a72c1f7c55e16.jpg\" alt=\"\" title=\"\"></span></p> \n<p>天猫：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386166\" src=\"http://localhost:8060/tup/2020/4/23/1a1bc313c0c64559978a67f0c0ec87a5.jpg\" alt=\"\" title=\"\"></span></p> \n<p>当你在百度、优酷、淘宝等进行一系列的操作时，<code>.mmstat.com</code> 已经悄悄的通过三方 <code>Cookie</code> 把你的个人信息运送到了他们那边。 <code>.mmstat.com</code> 应该就是阿里旗下的大数据营销平台阿里妈妈旗下的域名（只是个人猜测）。打开阿里妈妈首页，可以看到，其号称是更懂消费者的数据金矿，已经建立起5亿用户的身份识别体系。你的每一次搜索、每一次购买、都会让它变的更精准，下一次你就收到更精准的推荐。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386167\" src=\"http://localhost:8060/tup/2020/4/23/a8a4efdff51e4db29c398ffb745505bb.jpg\" alt=\"\" title=\"\"></span></p> \n<p>当然，三方 <code>Cookie</code> 只是众多获取你喜好信息的一种方式，只不过这种方式更便捷，成本更低。</p> \n<h2>浏览器的策略</h2> \n<p>最近几大浏览器针对 <code>Cookie</code> 策略的频繁改动，意味着三方 <code>Cookie</code> 被全面禁用已经不远了：</p> \n<h3>Firefox、Safari —— 默认禁用</h3> \n<p>在 <code>Safari 13.1</code>、<code>Firefox 79</code> 版本中，三方 <code>Cookie</code> 已经被默认禁用，但是由于这些游览器市场份额较小，并没有给市场带来巨大的冲击。因为阿里的登录信息是统一存在一个三方 <code>Cookie</code> 下的，淘宝刚开始的处理方式，甚至是弹个框出来，告诉用户手动开启三方 <code>Cookie</code> ：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386168\" src=\"http://localhost:8060/tup/2020/4/23/67adc50213d94ecc86e707d8e826ac26.jpg\" alt=\"\" title=\"\"></span></p> \n<p>但是这样的处理方式对于庞大的用户来讲肯定体验是极低的，解决方案可能是先将 <code>Cookie</code> 种在当前域下，所有就有了我们上面的测试结果，淘宝、天猫两个网站需要登录两次。</p> \n<p>但是三方 <code>Cookie</code>做的事情远不止这些，等到 <code>Chrome</code> 全面禁用之前，一定要提前作出改变。</p> \n<h3>Chrome —— SameSite Cookie</h3> \n<p>还好由于三方 <code>Cookie</code> 对 <code>Google</code> 的广告业务影响较大，所以其没有立即进行禁用，而是一直陆续修改一些小的策略来对三方 <code>Cookie</code> 进行限制，比如 <code>SameSite</code></p> \n<p><code>SameSite</code> 是 <code>Chrome 51</code> 版本为浏览器的 <code>Cookie</code> 新增的了一个属性， <code>SameSite</code> 阻止浏览器将此 <code>Cookie</code> 与跨站点请求一起发送。其主要目标是降低跨源信息泄漏的风险。同时也在一定程度上阻止了 <code>CSRF</code> 攻击。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386172\" src=\"http://localhost:8060/tup/2020/4/23/6bc1ded6f8e34fe7b0ddaee871830e4f.jpg\" alt=\"\" title=\"\"></span></p> \n<p><code>SameSite</code> 可以避免跨站请求发送 <code>Cookie</code>，有以下三个属性：</p> \n<h4>Strict</h4> \n<p><code>Strict</code> 是最严格的防护，将阻止浏览器在所有跨站点浏览上下文中将 <code>Cookie</code> 发送到目标站点，即使在遵循常规链接时也是如此。因此这种设置可以阻止所有 <code>CSRF</code> 攻击。然而，它的用户友好性太差，即使是普通的 <code>GET</code> 请求它也不允许通过。</p> \n<p>例如，对于一个普通的站点，这意味着如果一个已经登录的用户跟踪一个发布在公司讨论论坛或电子邮件上的网站链接，这个站点将不会收到 <code>Cookie</code> ，用户访问该站点还需要重新登陆。</p> \n<p>不过，具有交易业务的网站很可能不希望从外站链接到任何交易页面，因此这种场景最适合使用 <code>strict</code> 标志。</p> \n<h4>Lax</h4> \n<p>对于允许用户从外部链接到达本站并使用已有会话的网站站，默认的 <code>Lax</code> 值在安全性和可用性之间提供了合理的平衡。 <code>Lax</code> 属性只会在使用危险 <code>HTTP</code> 方法发送跨域 <code>Cookie</code> 的时候进行阻止，例如 <code>POST</code> 方式。同时，使用 <code>JavaScript</code> 脚本发起的请求也无法携带 <code>Cookie</code>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386169\" src=\"http://localhost:8060/tup/2020/4/23/80e9ae496b584bccae7e9f6d7856dc13.jpg\" alt=\"\" title=\"\"></span></p> \n<p>例如，一个用户在 A 站点 点击了一个 B 站点（GET请求），而假如 B 站点 使用了<code>Samesite-cookies=Lax</code>，那么用户可以正常登录 B 站点。相对地，如果用户在 A 站点提交了一个表单到 B站点（POST请求），那么用户的请求将被阻止，因为浏览器不允许使用 <code>POST</code> 方式将 <code>Cookie</code> 从A域发送到Ｂ域。</p> \n<h4>None</h4> \n<p>浏览器会在同站请求、跨站请求下继续发送 <code>Cookies</code>，不区分大小写。</p> \n<h4>策略更新</h4> \n<p>在旧版浏览器，如果 <code>SameSite</code> 属性没有设置，或者没有得到运行浏览器的支持，那么它的行为等同于 <code>None</code>，<code>Cookies</code> 会被包含在任何请求中——包括跨站请求。</p> \n<p>但是，在 <code>Chrome 80+</code> 版本中，<code>SameSite</code> 的默认属性是 <code>SameSite=Lax</code>。换句话说，当 <code>Cookie</code> 没有设置 <code>SameSite</code> 属性时，将会视作 <code>SameSite</code> 属性被设置为<code>Lax</code> 。如果想要指定 <code>Cookies</code> 在同站、跨站请求都被发送，那么需要明确指定 <code>SameSite</code> 为 <code>None</code>。具有 <code>SameSite=None</code> 的 <code>Cookie</code> 也必须标记为安全并通过 <code>HTTPS</code> 传送。这意味着所有使用 <code>JavaScript</code> 脚本收集用户信息的请求默认将不能携带三方 <code>Cookie</code>。</p> \n<p>然而这个改动并不会造成太大的影响，它只是给各大网站提了一个信号，因为你只需要把你想要发送的 <code>Cookie</code> 的属性手动设置为 <code>none</code> 即可：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386170\" src=\"http://localhost:8060/tup/2020/4/23/bf6f2e94722c4800825bce876d356adb.jpg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386171\" src=\"http://localhost:8060/tup/2020/4/23/fd11c777802c45d4ac8ccaabb089a744.jpg\" alt=\"\" title=\"\"></span></p> \n<p>真正可怕的是我们将无法直接指定 <code>SameSite</code> 为 <code>None</code>，只能用户自己去选择，这才是真正的默认禁用。</p> \n<p><code>Chrome</code> 也宣布，将在下个版本也就是 <code>Chrome 83</code> 版本，在访客模式下禁用三方 <code>Cookie</code>，在 <code>2022</code> 年全面禁用三方 <code>Cookie</code>，到时候，即使你能指定 <code>SameSite</code> 为 <code>None</code> 也没有意义，因为你已经无法写入第三方 <code>Cookie</code> 了。</p> \n<h2>当三方 Cookie 被全面禁止</h2> \n<p>现在，我们想象一下，当浏览器禁用了三方 <code>Cookie</code>，而我们又没有作出任何改变的情况下，会发生什么：</p> \n<h3>前端日志异常</h3> \n<p>可能有一天你会突然发现，你的 <code>UV</code> 暴涨，但是 <code>PV</code> 却没有什么变化，那可能是你的打点 <code>SDK</code> 使用的三方 <code>Cookie</code> 被禁用掉了。</p> \n<p>这时这个 <code>SDK</code> 将无法在你的域下写入一个三方 <code>Cookie</code>，导致你的每次刷新页面它都会带一个新的 <code>Cookie</code> 回来，后端接受到的信号就是这些都是不同用户的请求，所以都会计入 <code>UV</code>。同时你在排查问题时，你也无法将用户的行为串联起来，导致排查非常困难。</p> \n<h3>智能广告推荐消失</h3> \n<p>上面我们提到，广告服务通过你的年龄、性别、行为来推断你的喜好，从而推送给你精准的广告，使用了三方 <code>Cookie</code> 来进行信息追踪的广告主将无法获得你的这些喜好，从而无法推荐给你感兴趣的广告。</p> \n<p>这时，广告主只能在你当时的访问环境进行预定义广告，比如你正在访问宠物网站，就给你推荐宠物用品等等。</p> \n<p>同时，可能之前广告主还会通过 <code>Cookie</code> 判断你阅读某个广告的次数，一旦你阅读同一个广告多次但是没有发生转化，其就会停止向你推送该广告。或者你已经购买过了这个商品，那你也不会再看到这个广告了。如果没有了频率控制，那么你可能要连续很多天盯着一个你永远也不会去点的广告，或者你会持续看到一个你已经购买过的产品广告。</p> \n<h3>无法追踪转化率</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386174\" src=\"http://localhost:8060/tup/2020/4/23/1d805d7640fe448aa3f57274a6c1aa36.jpg\" alt=\"\" title=\"\"></span></p> \n<p>当你查看一则广告时，该广告会在你的浏览器中放置一个 <code>Cookie</code>，表示你已经看到它。如果随后你进入转化阶段（购买、下载等），广告主们需要能追踪每一个他们投放到你网站上的转化率，这样他们才能计算投放的效果，从而作出优化策略，如果你无法再追踪广告转化率了，那么也很难再进行投放了。</p> \n<p>当然，以上只是建立在你没有进行任何改变的基础上，距离全面禁用三方 <code>Cookie</code> 还有一年多的时间，这应该是一个足够的时间让你及时作出应对。</p> \n<h3>是好是坏</h3> \n<p>虽然，这对你带来的可能是糟糕的广告体验，但是全面禁用三方 <code>Cookie</code> 对我们用户来讲肯定是一件好事，因为你的信息不会被轻而易举的就被别人追踪了，你的隐私信息也不会容易被泄漏。</p> \n<p>然而事情真的那么简单么？贪婪的广告商绝对不会直接放弃对你的信息追踪，首先他们已经对你掌握了足够多的信息，而且三方 <code>Cookie</code> 只是众多获取你信息的一种手段，只不过这种方法更方便简单，为了利益，他们一定会找到更多的替代方案：</p> \n<h2>使用一方 Cookie 替代 三方 Cookie</h2> \n<p>如果我们引入了一个三方的 <code>SDK</code>，比如 <code>google analytics</code> ，说明我们对其是信任的，它对我们的信息收集追踪都是在允许范围内的。所以这些 <code>SDK</code> 依然可以使用第一方 <code>Cookie</code> 来完成用户身份标识符。</p> \n<p>比如，<code>gtag.js</code> 和 <code>analytics.js</code> 会设置以下 <code>Cookie</code> 用户标识用户信息：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386175\" src=\"http://localhost:8060/tup/2020/4/23/ccbeb90d7aa24c1ab4df9c3c9b7cd4e6.jpg\" alt=\"\" title=\"\"></span></p> \n<p>但是，这些 <code>Cookie</code> 并不是第三方 <code>Cookie</code>，而是设在你的域下的第一方 <code>Cookie</code>，比如打开 <code>twitter</code> 的 <code>Cookie</code> 信息：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386176\" src=\"http://localhost:8060/tup/2020/4/23/b3cdede224e34e08a9e32ed26a24eaa2.jpg\" alt=\"\" title=\"\"></span></p> \n<p>我们发现 <code>_ga</code> 、<code>_gid</code> 这两个 <code>Cookie</code> 正是设置在其自己域下面的。</p> \n<p>如果使用正常的 <code>Set-Cookie</code> 的形式，<code>google analytics</code> 是无法直接将 <code>Cookie</code> 设置到 <code>twitter.com</code> 这个域下面的，而且 <code>google analytics</code> 发起的日志收集请求也无法携带 <code>twitter.com</code> 这个域下的 <code>Cookie</code>。</p> \n<p>打开 <code>sdk</code> 的代码我发现里面有使用 js 设置 <code>Cookie</code> 的代码：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386173\" src=\"http://localhost:8060/tup/2020/4/23/89f8f4be14b940c59171cdb90ee8adf5.jpg\" alt=\"\" title=\"\"></span></p> \n<p>并且，收集日志的请求中也又没携带任何 <code>Cookie</code>，而是把这信息带在了参数中：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386180\" src=\"http://localhost:8060/tup/2020/4/23/3fd1df7df21947eab6ee43e4b5420a34.jpg\" alt=\"\" title=\"\"></span></p> \n<p>这样的方式就模拟了使用三方 <code>Cookie</code> 标识用户信息的过程，并且完全可以替代它。总而言之禁用三方 <code>Cookie</code> 对这种三方 <code>SDK</code> 的影响并不大，只要稍微改变一下思维即可。</p> \n<p>当然，由于 <code>Safari</code> 和 <code>Firefox</code> 已经全面禁用了三方 <code>Cookie</code>，一些广告营销服务也正在给出使用一方 <code>Cookie</code> 的替代方案，比如 <code>Facebook Pixel</code>：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386179\" src=\"http://localhost:8060/tup/2020/4/23/3f672f64a29940949766cd0d8f2f463e.jpg\" alt=\"\" title=\"\"></span></p> \n<p>你允许了其读取一方 <code>Cookie</code> 就意味着它能获取你更多的数据，这意味着你需要承担更大的用户信息泄漏的风险。而且使用一方 <code>Cookie</code> 也不像使用三方 <code>Cookie</code> 那样灵活，在某些场景下也是有很大限制的。</p> \n<h2>浏览器指纹</h2> \n<p>三方 <code>Cookie</code> 的主要作用是标识你的身份，从而在你下一次访问时知道你是谁，那么如果有一种技术直接就可以获取你的唯一标识时，那么就不需要再存储 <code>Cookie</code> 了，这个技术就是 “浏览器指纹” 。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386178\" src=\"http://localhost:8060/tup/2020/4/23/451fd718e3b24cdf8a39aedd9da5fe2b.jpg\" alt=\"\" title=\"\"></span></p> \n<p>“浏览器指纹”是一种通过浏览器对网站可见的配置和设置信息来跟踪 <code>Web</code> 浏览器的方法，浏览器指纹就像我们人手上的指纹一样，每个人拥有一份接近于独一无二的配置。</p> \n<p>如果单单拿出一个配置来讲可能很多人和你拥有一样的配置，比如下面的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386183\" src=\"http://localhost:8060/tup/2020/4/23/3510051cacec43d89e84d094abab4395.jpg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li> <p>系统版本：</p> \n  <ul> \n   <li>我的系统版本是 <code>Mac OS X 10_14_6</code> </li> \n   <li>大约 <code>11.91%</code> 的人与我的配置相同</li> \n   <li>大约每 <code>8</code> 个人中有一个和我配置相同</li> \n  </ul> </li> \n <li> <p><code>Chrome</code> 版本：</p> \n  <ul> \n   <li>我使用的浏览器是 <code>Chrome</code>，并且版本是：<code>81.0.4044.92</code> </li> \n   <li>大约 <code>0.08%</code> 的人与我的配置相同</li> \n   <li>大约每 <code>1250</code> 个人中有一个和我配置相同</li> \n  </ul> </li> \n <li> <p><code>UTC+8</code> 时间：</p> \n  <ul> \n   <li>我的<code>UTC+8</code> 时间是 <code>2020.4.15 23:00:00</code> </li> \n   <li>大约 <code>2.30%</code> 的人与我的配置相同</li> \n   <li>大约每 <code>43</code> 个人中有一个和我配置相同</li> \n  </ul> </li> \n</ul> \n<p>如果单独看每个配置，那他们都不能作为你独一无二的特征，但是综合起来看呢？比如就看这三项，三项的配置与你都相同的人的概率就会大大减小了。以上只是一些简单的特征，比如系统版本，浏览器版本，这些只需要一个简单的 <code>navigator.userAgent</code> 属性就可以拿到。</p> \n<p>像这样的属性还有非常多个，他们可能来自 <code>HTTP Header</code>、<code>Javascript attributes</code>、<code>浏览器插件</code> 等等</p> \n<h3>HTTP Header</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386181\" src=\"http://localhost:8060/tup/2020/4/23/be905c84966a4877a1db12a561e3aea7.jpg\" alt=\"\" title=\"\"></span></p> \n<p>上面的 <code>HTTP Header</code> 中就包含了大量的定制化特性，可以看到每一项配置中与我相同的概率是非常低的，然而这些信息属于普通的浏览器指纹，普通指纹可以理解为容易被发现并且容易修改的部分，而且你也可以轻易的篡改他们，有些配置比如 <code>User-Agent</code> 、<code>language</code> 使用 <code>JavaScript</code> 的 <code>navigator</code> 对象获取是最准确而且不会被篡改的。下面还有一些其他常见的 <code>JavaScript</code> 属性：</p> \n<h3>Javascript attributes</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386177\" src=\"http://localhost:8060/tup/2020/4/23/7a697c4400c84303811ac1ebad0e9479.jpg\" alt=\"\" title=\"\"></span></p> \n<p>这里面包含一些使用 <code>Javascript</code> 很容易获取的一些配置：</p> \n<ul> \n <li> <code>Screen width</code>：屏幕宽度</li> \n <li> <code>Screen height</code>：屏幕高度</li> \n <li> <code>Cookies enabled</code>：是否允许 <code>Cookie</code> </li> \n <li> <code>Content language</code>：语言信息</li> \n <li> <code>List of fonts</code>：字体信息</li> \n <li> <code>Timezone</code>：时区信息</li> \n <li> <code>Navigator properties：Navigator</code> 对象中包含的属性信息</li> \n <li>...</li> \n</ul> \n<p>以上这些信息非常容易获取，而且带有的信息较少，最后生成出来的指纹可能碰撞的概率就越大，实际上通过 <code>JS</code> 能获取的远不止这些，下面还有一些重复率非常低的指标：</p> \n<h3>Canvas 指纹</h3> \n<p><code>Canvas</code> 是 <code>HTML5</code> 中用于在网页上绘制 <code>2D</code> 图形元素。浏览器在绘制图形时，会调用操作系统的绘图接口，即便使用 <code>Cavans</code> 绘制相同的元素，但是由于系统的差别，不同浏览器使用了不同的图形处理引擎、不同的图片导出选项、不同的默认压缩级别、对抗锯齿、次像素渲染等算法也不同。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386182\" src=\"http://localhost:8060/tup/2020/4/23/f935a853d33d422791b57c9a0eb024cf.jpg\" alt=\"\" title=\"\"></span></p> \n<p>具体获取流程如下：在画布上渲染一些文字，再用 <code>toDataURL</code> 转换出来，你就会得到属于你的 <code>Cavans</code> 指纹：</p> \n<pre><code class=\"js\">    const canvas = document.getElementById(\"canvas-fingerprint\");\n    const context = canvas.getContext(\"2d\");\n    context.font = \"18pt Arial\";\n    context.textBaseline = \"top\";\n    context.fillText(\"canvas-fingerprint-test\", 2, 2);\n    return canvas.toDataURL(\"image/jpeg\");</code></pre> \n<p>上面的图中可以看到，<code>Canvas</code> 指纹和我相同的概率是 <code>&lt;0.01%</code> 的，可见这是一个在浏览器指纹中非常重要的指标。</p> \n<h3>WebGL</h3> \n<p><code>WebGL</code> 是一种用于在网页上呈现3D图像的 <code>JavaScript</code> 浏览器API。网站可利用 <code>WebGL</code> 来识别你的设备指纹：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386185\" src=\"http://localhost:8060/tup/2020/4/23/428b744bea654f61885e5ffdb2246e62.jpg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li> <code>WebGL</code> 报告 —— 完整的 <code>WebGL</code> 浏览器报告表是可获取、可被检测的。在一些情况下，它会被转换成为哈希值以便更快地进行分析。</li> \n <li> <code>WebGL</code> 图像 —— 渲染和转换为哈希值的隐藏3D图像。由于最终结果取决于进行计算的硬件设备，因此此方法会为设备及其驱动程序的不同组合生成唯一值。这种方式为不同的设备组合和驱动程序生成了唯一值。</li> \n</ul> \n<h3>WebRTC</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386184\" src=\"http://localhost:8060/tup/2020/4/23/267d5357d48940a1a6c759014be0181a.jpg\" alt=\"\" title=\"\"></span></p> \n<p><code>WebRTC</code> （网页实时通信，<code>Web Real Time Communication</code>），是可以让浏览器有音视频实时通信的能力，通常被需要快速直接连接的网络应用程序所应用。即便你使用了代理，网站也能借此获取你真实的公共和本地IP地址。该插件可被用于泄漏你的本地 <code>IP</code> 地址或追踪媒体设备。<code>WebRTC</code> 会暴露你的：</p> \n<ul> \n <li>公共IP地址</li> \n <li>本地IP地址</li> \n <li>媒体设备的数量及其哈希值</li> \n</ul> \n<h3>CSS</h3> \n<p>就算用户禁用了 <code>JavaScript</code> ，网站也可以通过纯 <code>CSS</code> 来获取到一些信息，比如这样：</p> \n<pre><code>@media(device-width: 1920px) {\n  body {\n    background: url(\"https://example.org/1920.png\");\n  }\n}</code></pre> \n<p>通过统计 <code>1920.png</code> 这个图片的请求日志，便可知道有哪些用户的窗口宽度是 <code>1920px</code>。</p> \n<h3>UUID 的计算</h3> \n<p>综合以上的指标特征，可以计算出一个属于你自己的唯一的 <code>uuid</code>，这就是你的 \"浏览器指纹\" 了。当然，计算时不能简单的将上述指标进行叠加，因为某些指标在一些场景下聚合度比较高，每个指标带来的信息量也不相同，一般每个指标都拥有一个自己的 \"信息熵\" :</p> \n<blockquote>\n 信息熵（entropy）是接收的每条消息中包含的信息的平均量，熵越高，则能传输越多的信息，熵越低，则意味着传输的信息越少。\n</blockquote> \n<p>在计算 <code>uuid</code> 时，一般信息熵较大的指标会拥有较大的权重，这样可以大大降低碰撞率，提高 <code>uuid</code> 的准确性。</p> \n<p>当然，这些也不用你自己去挨个费劲的去获取了，使用 <code>clientjs</code>（<code>https://github.com/jackspirou/clientjs</code>） 可以轻而易举的帮你获取这些指标，并最终获取 <code>uuid</code>：</p> \n<pre><code class=\"js\">// Create a new ClientJS object\nconst client = new ClientJS();\n\n// Get the client\'s fingerprint id\nconst fingerprint = client.getFingerprint();\n\n// Print the 32bit hash id to the console\nconsole.log(fingerprint);</code></pre> \n<p>你也可以单独获取这些信息：</p> \n<pre><code class=\"js\">  const client = new ClientJS();\n  client.getBrowserData();\n  client.getFingerprint();\n  client.getCustomFingerprint(...);\n  client.isCanvas();\n  client.getCanvasPrint();\n  client.getFlashVersion();\n  client.isSilverlight();\n  client.getSilverlightVersion();\n  // 。。。</code></pre> \n<h2>参考</h2> \n<ul> \n <li><a href=\"https://zhuanlan.zhihu.com/p/34591096\" rel=\"nofollow noreferrer\">https://zhuanlan.zhihu.com/p/...</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s/5-oObFPiRP6a5O49YsS9wg\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/5-...</a></li> \n <li><a href=\"https://juejin.im/post/5d97fb5ef265da5ba12cdea9\" rel=\"nofollow noreferrer\">https://juejin.im/post/5d97fb...</a></li> \n</ul> \n<h2>小结</h2> \n<p>作为一名普通用户，我会感叹，太难了，我很难保护我的个人隐私，收集我信息的平台无处不在，收集我信息的手段也是各种各样。。。</p> \n<p>在现实世界里，没有什么会保持不变的。</p> \n<p>作为一名开发者，你要时刻保持警惕，有危机意识，第一时间更新你的技术以应对外部环境的变化，否则你就会被淘汰。</p> \n<p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p> \n<p>想阅读更多优质文章、可关注我的<a href=\"https://github.com/ConardLi/ConardLi.github.io\" rel=\"nofollow noreferrer\">github博客</a>，你的star✨、点赞和关注是我持续创作的动力！</p> \n<p>推荐关注我的微信公众号【code秘密花园】，每天推送高质量文章，我们一起交流成长。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386186\" src=\"http://localhost:8060/tup/2020/4/23/3e136b0a12bd4e938e665850b0a9119f.jpg\" alt=\"\" title=\"\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/5a5184ad92a04d6e88f81e05cc88c997.jpg', 'c56940aa8b004dab84568e86900b2ee6', '04547238127a4676b504cc4496865d7b', '63c4e1e7ec204b43a62065a3ced4c2ce,d79254c4ca5e45dca9d484307c935281,b456ad7a7d1d468ba659bb4c31f24e99,63b70326a7b34ffeb8eeb2f0098c86c1,e75baefb206a4efe959a99aad77632a3', '0', '3', '1', '2020-04-23 10:58:23', '2020-04-23 10:58:23');
INSERT INTO `tb_recommend` VALUES ('0a7ac0eadf264e49b94fed52f2b01f87', '你真的懂Promise吗', '在异步编程中，Promise 扮演了举足轻重的角色，比传统的解决方案（回调函数和事件）更合理和更强大。可能有些小伙伴会有这样的疑问：2020年了，怎么还在谈论Promise？事实上，有些朋友对于这个几乎每天都在打交道...', '<h2>前言</h2> \n<p>在异步编程中，Promise 扮演了举足轻重的角色，比传统的解决方案（回调函数和事件）更合理和更强大。可能有些小伙伴会有这样的疑问：2020年了，怎么还在谈论Promise？事实上，有些朋友对于这个几乎每天都在打交道的“老朋友”，貌似全懂,但稍加深入就可能疑问百出，本文带大家深入理解这个熟悉的陌生人—— Promise.</p> \n<h2>基本用法</h2> \n<h3>1.语法</h3> \n<pre><code class=\"javascript\">new Promise( function(resolve, reject) {...} /* executor */  )</code></pre> \n<ul> \n <li>构建 Promise 对象时，需要传入一个 executor 函数，主要业务流程都在 executor 函数中执行。</li> \n <li>Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor，resolve 和 reject 函数被调用时，分别将promise的状态改为fulfilled（完成）或rejected（失败）。<strong>一旦状态改变，就不会再变</strong>，任何时候都可以得到这个结果。</li> \n <li>在 executor 函数中调用 resolve 函数后，会触发 promise.then 设置的回调函数；而调用 reject 函数后，会触发 promise.catch 设置的回调函数。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022427420\" src=\"http://localhost:8060/tup/2020/4/23/12b3e1febd7f4ff9b5bc3cd95b1b09ee.jpg\" alt=\"\" title=\"\"></span></p> \n<p>值得注意的是，<strong>Promise 是用来管理异步编程的，它本身不是异步的</strong>，new Promise的时候会立即把executor函数执行，只不过我们一般会在executor函数中处理一个异步操作。比如下面代码中，一开始是会先打印出2。</p> \n<pre><code class=\"javascript\">let p1 = new Promise(()=&gt;{\n    setTimeout(()=&gt;{\n      console.log(1)\n    },1000)\n    console.log(2)\n  })\nconsole.log(3) // 2 3 1</code></pre> \n<p>Promise 采用了回调函数延迟绑定技术，在执行 resolve 函数的时候，回调函数还没有绑定，那么只能<strong>推迟回调函数的执行</strong>。这具体是啥意思呢？我们先来看下面的例子：</p> \n<pre><code class=\"javascript\">let p1 = new Promise((resolve,reject)=&gt;{\n  console.log(1);\n  resolve(\'浪里行舟\')\n  console.log(2)\n})\n// then:设置成功或者失败后处理的方法\np1.then(result=&gt;{\n //p1延迟绑定回调函数\n  console.log(\'成功 \'+result)\n},reason=&gt;{\n  console.log(\'失败 \'+reason)\n})\nconsole.log(3)\n// 1\n// 2\n// 3\n// 成功 浪里行舟</code></pre> \n<p>new Promise的时候先执行executor函数，打印出 1、2，Promise在执行resolve时，触发微任务，还是继续往下执行同步任务，<br>执行p1.then时，存储起来两个函数（此时这两个函数还没有执行）,然后打印出3，此时同步任务执行完成，最后执行刚刚那个微任务，从而执行.then中成功的方法。</p> \n<h3>错误处理</h3> \n<p>Promise 对象的错误<strong>具有“冒泡”性质，会一直向后传递</strong>，直到被 onReject 函数处理或 catch 语句捕获为止。具备了这样“冒泡”的特性后，就不需要在每个 Promise 对象中单独捕获异常了。</p> \n<p>要遇到一个then，要执行成功或者失败的方法，但如果此方法并没有在当前then中被定义，则顺延到下一个对应的函数</p> \n<pre><code class=\"javascript\">function executor (resolve, reject) {\n  let rand = Math.random()\n  console.log(1)\n  console.log(rand)\n  if (rand &gt; 0.5) {\n    resolve()\n  } else {\n    reject()\n  }\n}\nvar p0 = new Promise(executor)\nvar p1 = p0.then((value) =&gt; {\n  console.log(\'succeed-1\')\n  return new Promise(executor)\n})\nvar p2 = p1.then((value) =&gt; {\n  console.log(\'succeed-2\')\n  return new Promise(executor)\n})\np2.catch((error) =&gt; {\n  console.log(\'error\', error)\n})\nconsole.log(2)</code></pre> \n<p>这段代码有三个 Promise 对象：p0～p2。无论哪个对象里面抛出异常，都可以通过最后一个对象 p2.catch 来捕获异常，通过这种方式可以将所有 Promise 对象的错误合并到一个函数来处理，这样就解决了每个任务都需要单独处理异常的问题。</p> \n<p>通过这种方式，我们就消灭了嵌套调用和频繁的错误处理，这样使得我们写出来的代码更加优雅，更加符合人的线性思维。</p> \n<h3>Promise链式调用</h3> \n<p>我们都知道可以把多个Promise连接到一起来表示一系列异步骤。这种方式可以实现的关键在于以下两个Promise 固有行为特性：</p> \n<ul> \n <li>每次你对Promise调用then，它都会创建并返回一个新的Promise，我们可以将其链接起来；</li> \n <li>不管从then调用的完成回调（第一个参数）返回的值是什么，它都会被自动设置为被链接Promise（第一点中的）的完成。</li> \n</ul> \n<p>先通过下面的例子，来解释一下刚刚这段话是什么意思，然后详细介绍下链式调用的执行流程</p> \n<pre><code class=\"JavaScript\">let p1=new Promise((resolve,reject)=&gt;{\n    resolve(100) // 决定了下个then中成功方法会被执行\n})\n// 连接p1\nlet p2=p1.then(result=&gt;{\n    console.log(\'成功1 \'+result)\n    return Promise.reject(1) \n// 返回一个新的Promise实例，决定了当前实例是失败的，所以决定下一个then中失败方法会被执行\n},reason=&gt;{\n    console.log(\'失败1 \'+reason)\n    return 200\n})\n// 连接p2 \nlet p3=p2.then(result=&gt;{\n    console.log(\'成功2 \'+result)\n},reason=&gt;{\n    console.log(\'失败2 \'+reason)\n})\n// 成功1 100\n// 失败2 1</code></pre> \n<p>我们通过返回 Promise.reject(1) ，完成了第一个调用then创建并返回的promise p2。p2的then调用在运行时会从return Promise.reject(1) 语句接受完成值。当然，p2.then又创建了另一个新的promise，可以用变量p3存储。</p> \n<p>new Promise出来的实例，成功或者失败，取决于executor函数执行的时候，<strong>执行的是resolve还是reject决定的</strong>，或<strong>executor函数执行发生异常错误</strong>，这两种情况都会把实例状态改为失败的。</p> \n<p>p2执行then返回的新实例的状态，决定下一个then中哪一个方法会被执行，有以下几种情况：</p> \n<ul> \n <li>不论是成功的方法执行，还是失败的方法执行（then中的两个方法），凡是执行抛出了异常，则都会把实例的状态改为失败。</li> \n <li>方法中如果返回一个新的Promise实例（比如上例中的Promise.reject(1)），返回这个实例的结果是成功还是失败，也决定了当前实例是成功还是失败。</li> \n <li>剩下的情况基本上都是让实例变为成功的状态，上一个then中方法返回的结果会传递到下一个then的方法中。</li> \n</ul> \n<p>我们再来看个例子</p> \n<pre><code class=\"javascript\">new Promise(resolve=&gt;{\n    resolve(a) // 报错 \n// 这个executor函数执行发生异常错误，决定下个then失败方法会被执行\n}).then(result=&gt;{\n    console.log(`成功：${result}`)\n    return result*10\n},reason=&gt;{\n    console.log(`失败：${reason}`)\n// 执行这句时候，没有发生异常或者返回一个失败的Promise实例，所以下个then成功方法会被执行\n// 这里没有return，最后会返回 undefined\n}).then(result=&gt;{\n    console.log(`成功：${result}`)\n},reason=&gt;{\n    console.log(`失败：${reason}`)\n})\n// 失败：ReferenceError: a is not defined\n// 成功：undefined</code></pre> \n<h3>async &amp; await</h3> \n<p>从上面一些例子，我们可以看出，虽然使用 Promise 能很好地解决回调地狱的问题，但是这种方式充满了 Promise 的 then() 方法，如果处理流程比较复杂的话，那么整段代码将充斥着 then，语义化不明显，代码不能很好地表示执行流程。</p> \n<p>ES7中新增的异步编程方法，async/await的实现是基于 Promise的，简单而言就是async 函数就是返回Promise对象，是generator的语法糖。很多人认为async/await是异步操作的终极解决方案：</p> \n<ul> \n <li>语法简洁，更像是同步代码，也更符合普通的阅读习惯；</li> \n <li>改进JS中异步操作串行执行的代码组织方式，减少callback的嵌套；</li> \n <li>Promise中不能自定义使用try/catch进行错误捕获，但是在Async/await中可以像处理同步代码处理错误。</li> \n</ul> \n<p>不过也存在一些缺点，因为 await 将异步代码改造成了同步代码，如果多个异步代码没有依赖性却使用了 await 会导致性能上的降低。</p> \n<pre><code class=\"javascript\">async function test() {\n  // 以下代码没有依赖性的话，完全可以使用 Promise.all 的方式\n  // 如果有依赖性的话，其实就是解决回调地狱的例子了\n  await fetch(url1)\n  await fetch(url2)\n  await fetch(url3)\n}</code></pre> \n<p>观察下面这段代码，你能判断出打印出来的内容是什么吗？</p> \n<pre><code class=\"javascript\">let p1 = Promise.resolve(1)\nlet p2 = new Promise(resolve =&gt; {\n  setTimeout(() =&gt; {\n    resolve(2)\n  }, 1000)\n})\nasync function fn() {\n  console.log(1)\n// 当代码执行到此行（先把此行），构建一个异步的微任务\n// 等待promise返回结果，并且await下面的代码也都被列到任务队列中\n  let result1 = await p2\n  console.log(3)\n  let result2 = await p1\n  console.log(4)\n}\nfn()\nconsole.log(2)\n// 1 2 3 4</code></pre> \n<p>如果 await 右侧表达逻辑是个 promise，await会等待这个promise的返回结果，<strong>只有返回的状态是resolved情况</strong>，才会把结果返回,如果promise是失败状态，则await不会接收其返回结果，await下面的代码也不会在继续执行。</p> \n<pre><code class=\"javascript\">let p1 = Promise.reject(100)\nasync function fn1() {\n  let result = await p1\n  console.log(1) //这行代码不会执行\n}</code></pre> \n<p>我们再来看道比较复杂的题目：</p> \n<pre><code>console.log(1)\nsetTimeout(()=&gt;{console.log(2)},1000)\nasync function fn(){\n    console.log(3)\n    setTimeout(()=&gt;{console.log(4)},20)\n    return Promise.reject()\n}\nasync function run(){\n    console.log(5)\n    await fn()\n    console.log(6)\n}\nrun()\n//需要执行150ms左右\nfor(let i=0;i&lt;90000000;i++){}\nsetTimeout(()=&gt;{\n    console.log(7)\n    new Promise(resolve=&gt;{\n        console.log(8)\n        resolve()\n    }).then(()=&gt;{console.log(9)})\n},0)\nconsole.log(10)\n// 1 5 3 10 4 7 8 9 2</code></pre> \n<p>做这道题之前，读者需明白：</p> \n<ul> \n <li>基于微任务的技术有 MutationObserver、Promise 以及以 Promise 为基础开发出来的很多其他的技术，本题中resolve()、await fn()都是微任务。</li> \n <li>不管宏任务是否到达时间，以及放置的先后顺序，每次主线程执行栈为空的时候，引擎会优先处理微任务队列，<strong>处理完微任务队列里的所有任务</strong>，再去处理宏任务。</li> \n</ul> \n<p>接下来，我们一步一步分析：</p> \n<ul> \n <li>首先执行同步代码，输出 1，遇见第一个setTimeout，将其回调放入任务队列（宏任务）当中，继续往下执行</li> \n <li>运行run(),打印出 5，并往下执行，遇见 await fn()，将其放入任务队列（微任务）</li> \n <li>await fn() 当前这一行代码执行时，fn函数会立即执行的,打印出3，遇见第二个setTimeout，将其回调放入任务队列（宏任务），await fn() 下面的代码需要等待返回Promise成功状态才会执行，所以6是不会被打印的。</li> \n <li>继续往下执行，遇到for循环同步代码，需要等150ms,虽然第二个setTimeout已经到达时间，但不会执行，遇见第三个setTimeout，将其回调放入任务队列（宏任务），然后打印出10。值得注意的是，这个定时器 推迟时间0毫秒实际上达不到的。根据HTML5标准，setTimeOut推迟执行的时间，最少是4毫秒。</li> \n <li>同步代码执行完毕，此时没有微任务，就去执行宏任务，上面提到已经到点的setTimeout先执行，打印出4</li> \n <li>然后执行下一个setTimeout的宏任务，所以先打印出7，new Promise的时候会立即把executor函数执行，打印出8，然后在执行resolve时，触发微任务，于是打印出9</li> \n <li>最后执行第一个setTimeout的宏任务，打印出2</li> \n</ul> \n<h2>常用的方法</h2> \n<h3>1、Promise.resolve()</h3> \n<p>Promise.resolve(value)方法返回一个以给定值解析后的Promise 对象。<br>Promise.resolve()等价于下面的写法:</p> \n<pre><code class=\"javascript\">Promise.resolve(\'foo\')\n// 等价于\nnew Promise(resolve =&gt; resolve(\'foo\'))</code></pre> \n<p>Promise.resolve方法的参数分成四种情况。</p> \n<p>（1）参数是一个 Promise 实例</p> \n<p>如果参数是 Promise 实例，那么Promise.resolve将<strong>不做任何修改、原封不动地</strong>返回这个实例。</p> \n<pre><code class=\"javascript\">const p1 = new Promise(function (resolve, reject) {\n  setTimeout(() =&gt; reject(new Error(\'fail\')), 3000)\n})\nconst p2 = new Promise(function (resolve, reject) {\n  setTimeout(() =&gt; resolve(p1), 1000)\n})\np2\n  .then(result =&gt; console.log(result))\n  .catch(error =&gt; console.log(error))\n// Error: fail</code></pre> \n<p>上面代码中，p1是一个 Promise，3 秒之后变为rejected。p2的状态在 1 秒之后改变，resolve方法返回的是p1。由于p2返回的是另一个 Promise，导致p2自己的状态无效了，由p1的状态决定p2的状态。所以，后面的then语句都变成针对后者（p1）。又过了 2 秒，p1变为rejected，导致触发catch方法指定的回调函数。</p> \n<p>（2）参数不是具有then方法的对象，或根本就不是对象</p> \n<pre><code class=\"javascript\">Promise.resolve(\"Success\").then(function(value) {\n // Promise.resolve方法的参数，会同时传给回调函数。\n  console.log(value); // \"Success\"\n}, function(value) {\n  // 不会被调用\n});</code></pre> \n<p>（3）不带有任何参数</p> \n<p>Promise.resolve()方法允许调用时不带参数，直接返回一个resolved状态的 Promise 对象。如果希望得到一个 Promise 对象，比较方便的方法就是直接调用Promise.resolve()方法。</p> \n<pre><code class=\"javascript\">Promise.resolve().then(function () {\n  console.log(\'two\');\n});\nconsole.log(\'one\');\n// one two</code></pre> \n<p>（4）参数是一个thenable对象</p> \n<p>thenable对象指的是具有then方法的对象,Promise.resolve方法会将这个对象转为 Promise 对象，然后就立即执行thenable对象的then方法。</p> \n<pre><code class=\"javascript\">let thenable = {\n  then: function(resolve, reject) {\n    resolve(42);\n  }\n};\nlet p1 = Promise.resolve(thenable);\np1.then(function(value) {\n  console.log(value);  // 42\n});</code></pre> \n<h3>2、Promise.reject()</h3> \n<p>Promise.reject()方法返回一个带有拒绝原因的Promise对象。</p> \n<pre><code class=\"javascript\">new Promise((resolve,reject) =&gt; {\n    reject(new Error(\"出错了\"));\n});\n// 等价于\n Promise.reject(new Error(\"出错了\"));  \n\n// 使用方法\nPromise.reject(new Error(\"BOOM!\")).catch(error =&gt; {\n    console.error(error);\n});</code></pre> \n<p>值得注意的是，调用resolve或reject以后，Promise 的使命就完成了，后继操作应该放到then方法里面，而<strong>不应该直接写在resolve或reject的后面</strong>。所以，最好在它们前面加上return语句，这样就不会有意外。</p> \n<pre><code class=\"javascript\">new Promise((resolve, reject) =&gt; {\n  return reject(1);\n  // 后面的语句不会执行\n  console.log(2);\n})</code></pre> \n<h3>3、Promise.all()</h3> \n<pre><code class=\"JavaScript\">let p1 = Promise.resolve(1)\nlet p2 = new Promise(resolve =&gt; {\n  setTimeout(() =&gt; {\n    resolve(2)\n  }, 1000)\n})\nlet p3 = Promise.resolve(3)\nPromise.all([p3, p2, p1])\n  .then(result =&gt; {\n // 返回的结果是按照Array中编写实例的顺序来\n    console.log(result) // [ 3, 2, 1 ]\n  })\n  .catch(reason =&gt; {\n    console.log(\"失败:reason\")\n  })</code></pre> \n<p>Promise.all 生成并返回一个新的 Promise 对象，所以它可以使用 Promise 实例的所有方法。参数传递promise数组中<strong>所有的 Promise 对象都变为resolve的时候</strong>，该方法才会返回， 新创建的 Promise 则会使用这些 promise 的值。</p> \n<p>如果参数中的<strong>任何一个promise为reject的话</strong>，则整个Promise.all调用会<strong>立即终止</strong>，并返回一个reject的新的 Promise 对象。</p> \n<h3>4、Promise.allSettled()</h3> \n<p>有时候，我们不关心异步操作的结果，只关心这些操作有没有结束。这时，ES2020 引入Promise.allSettled()方法就很有用。如果没有这个方法，想要确保所有操作都结束，就很麻烦。Promise.all()方法无法做到这一点。</p> \n<p>假如有这样的场景：一个页面有三个区域，分别对应三个独立的接口数据，使用 Promise.all 来并发请求三个接口，如果其中任意一个接口出现异常，状态是reject,这会导致页面中该三个区域数据全都无法出来，显然这种状况我们是无法接受，Promise.allSettled的出现就可以解决这个痛点：</p> \n<pre><code class=\"javascript\">Promise.allSettled([\n  Promise.reject({ code: 500, msg: \'服务异常\' }),\n  Promise.resolve({ code: 200, list: [] }),\n  Promise.resolve({ code: 200, list: [] })\n]).then(res =&gt; {\n  console.log(res)\n  /*\n    0: {status: \"rejected\", reason: {…}}\n    1: {status: \"fulfilled\", value: {…}}\n    2: {status: \"fulfilled\", value: {…}}\n  */\n  // 过滤掉 rejected 状态，尽可能多的保证页面区域数据渲染\n  RenderContent(\n    res.filter(el =&gt; {\n      return el.status !== \'rejected\'\n    })\n  )\n})</code></pre> \n<p>Promise.allSettled跟Promise.all类似, 其参数接受一个Promise的数组, 返回一个新的Promise, <strong>唯一的不同在于, 它不会进行短路</strong>, 也就是说当Promise全部处理完成后,我们可以拿到每个Promise的状态, 而不管是否处理成功。</p> \n<h3>5、Promise.race()</h3> \n<p>Promise.all()方法的效果是\"谁跑的慢，以谁为准执行回调\"，那么相对的就有另一个方法\"谁跑的快，以谁为准执行回调\"，这就是Promise.race()方法，这个词本来就是赛跑的意思。race的用法与all一样，接收一个promise对象数组为参数。</p> \n<p>Promise.all在接收到的所有的对象promise都变为FulFilled或者Rejected状态之后才会继续进行后面的处理，与之相对的是Promise.race<strong>只要有一个promise对象进入FulFilled或者Rejected状态的话</strong>，就会继续进行后面的处理。</p> \n<pre><code class=\"javascript\">// `delay`毫秒后执行resolve\nfunction timerPromisefy(delay) {\n    return new Promise(resolve =&gt; {\n        setTimeout(() =&gt; {\n            resolve(delay);\n        }, delay);\n    });\n}\n// 任何一个promise变为resolve或reject的话程序就停止运行\nPromise.race([\n    timerPromisefy(1),\n    timerPromisefy(32),\n    timerPromisefy(64)\n]).then(function (value) {\n    console.log(value);    // =&gt; 1\n});</code></pre> \n<p>上面的代码创建了3个promise对象，这些promise对象会分别在1ms、32ms 和 64ms后变为确定状态，即FulFilled，并且在第一个变为确定状态的1ms后，.then注册的回调函数就会被调用。</p> \n<h3>6、Promise.prototype.finally()</h3> \n<p>ES9 新增 finally() 方法返回一个Promise。在promise结束时，无论结果是fulfilled或者是rejected，都会执行指定的回调函数。<strong>这为在Promise是否成功完成后都需要执行的代码提供了一种方式</strong>。这避免了同样的语句需要在then()和catch()中各写一次的情况。</p> \n<p>比如我们发送请求之前会出现一个loading，当我们请求发送完成之后，不管请求有没有出错，我们都希望关掉这个loading。</p> \n<pre><code class=\"javascript\">this.loading = true\nrequest()\n  .then((res) =&gt; {\n    // do something\n  })\n  .catch(() =&gt; {\n    // log err\n  })\n  .finally(() =&gt; {\n    this.loading = false\n  })</code></pre> \n<p>finally方法的回调函数不接受任何参数，这表明，finally方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。</p> \n<h2>实际应用</h2> \n<p>假设有这样一个需求：红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？<br>三个亮灯函数已经存在：</p> \n<pre><code class=\"javascript\">function red() {\n    console.log(\'red\');\n}\nfunction green() {\n    console.log(\'green\');\n}\nfunction yellow() {\n    console.log(\'yellow\');\n}</code></pre> \n<p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是亮完一遍就结束的一锤子买卖，我们可以通过递归来实现：</p> \n<pre><code class=\"javascript\">// 用 promise 实现\nlet task = (timer, light) =&gt; {\n  return new Promise((resolve, reject) =&gt; {\n    setTimeout(() =&gt; {\n      if (light === \'red\') {\n        red()\n      }\n      if (light === \'green\') {\n        green()\n      }\n      if (light === \'yellow\') {\n        yellow()\n      }\n      resolve()\n    }, timer);\n  })\n}\nlet step = () =&gt; {\n  task(3000, \'red\')\n    .then(() =&gt; task(1000, \'green\'))\n    .then(() =&gt; task(2000, \'yellow\'))\n    .then(step)\n}\nstep()</code></pre> \n<p>同样也可以通过async/await 的实现：</p> \n<pre><code class=\"javascript\">//  async/await 实现\nlet step = async () =&gt; {\n  await task(3000, \'red\')\n  await task(1000, \'green\')\n  await task(2000, \'yellow\')\n  step()\n}\nstep()</code></pre> \n<p>使用 async/await 可以实现用同步代码的风格来编写异步代码,毫无疑问，还是 async/await 的方案更加直观，不过深入理解Promise 是掌握async/await的基础。<strong>给大家推荐一个好用的BUG监控工具<a href=\"https://www.fundebug.com/?utm_source=liao\" rel=\"nofollow noreferrer\">Fundebug</a>，欢迎免费试用！</strong></p> \n<p>欢迎关注公众号：前端工匠，你的成长我们一起见证！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022427419\" src=\"http://localhost:8060/tup/2020/4/23/fcce02ea188449b09f3310f10559cb8a.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>参考资料</h2> \n<ul> \n <li><a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Promise\" rel=\"nofollow noreferrer\">MDN 文档</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3NTY3MTQzMg==&amp;mid=2247485112&amp;idx=1&amp;sn=115b56a3d13fd896bf010d613ec2cc5a&amp;chksm=fd1edb5fca6952490ba88564b5847960fe723c9ddcf90c1ee1ebeadc4c759c836220a43940ab#rd\" rel=\"nofollow noreferrer\">你了解Promise吗？</a></li> \n <li><a href=\"https://time.geekbang.org/column/article/136895\" rel=\"nofollow noreferrer\">浏览器工作原理与实践</a></li> \n <li><a href=\"http://www.zhufengpeixun.cn/\" rel=\"nofollow noreferrer\">Web前端开发高级工程师</a></li> \n <li><a href=\"https://gitbook.cn/gitchat/column/5c91c813968b1d64b1e08fde/topic/5cbbe7a5bbbba80861a35beb\" rel=\"nofollow noreferrer\">前端开发核心知识进阶</a></li> \n <li><a href=\"https://coding.imooc.com/learn/list/389.html\" rel=\"nofollow noreferrer\">再学JavaScript ES(6-10)全版本语法大全</a></li> \n <li><a href=\"https://es6.ruanyifeng.com/#docs/promise\" rel=\"nofollow noreferrer\">《ECMAScript 6 入门教程》</a></li> \n <li><a href=\"https://book.douban.com/subject/26351021/\" rel=\"nofollow noreferrer\">《你不知道的javascript(中卷)》</a></li> \n</ul>', null, 'http://localhost:8060/tup/2020/4/23/0b5bf36474c147d5950468eeaf768af9.jpg', '1894b118d35d44cb8fe8009529c4154b', '049b3bd76c1e49ccbe48b36197e77f76', '63c4e1e7ec204b43a62065a3ced4c2ce,81a4561c1c294e0cae32c9fe6b5dc397,d79254c4ca5e45dca9d484307c935281,b350d9c92c524bb4b9feedd40e5eebcd,d16a93d83052441a90afaa57d69fdc3c', '0', '3', '1', '2020-04-23 10:26:24', '2020-04-23 10:26:24');
INSERT INTO `tb_recommend` VALUES ('0cfdff377547435b848b103305f380d8', 'Remax One - 重新设计小程序的跨平台开发', '小程序作为一项非标准的技术，各个小程序平台之间虽然大体上相似，但依然有非常多的差异。“一次开发多端运行”当然是非常美好的愿望，但我们在设计 Remax 之初就意识到各个小程序平台之间的差异是无法被抹平的，每...', '<h3>跨平台开发的挑战</h3> \n<p>小程序作为一项非标准的技术，各个小程序平台之间虽然大体上相似，但依然有非常多的差异。“一次开发多端运行”当然是非常美好的愿望，但我们在设计 Remax 之初就意识到各个小程序平台之间的差异是无法被抹平的，每家小程序平台有太多的私货，更没有一个标准来指导我们该如何抹平这些差异。</p> \n<p>所以我们在最开始，为每个小程序平台提供了独立的基础组件。开发者如果要做跨平台开发，需要自己去封装基础组件。但很快，我们也意识到这对开发者来说是一件很麻烦的事情，特别是后面我们要支持更多平台的话。</p> \n<h3>Remax One</h3> \n<p>受 CSS 属性名前缀的启发，我们重新设计了 Remax 的跨平台方案。我们非常克制地选取了 9 个基础组件，统一了他们之间非平台私有的属性，并且以属性名前缀的方式来支持各个平台私有的特性。我们希望开发者在做跨平台开发时能清楚地意识到你写下的这行代码只会在特定的平台上生效。</p> \n<p><a href=\"https://remaxjs.org/one/intro\" rel=\"nofollow noreferrer\">Remax One</a> 就是我们提供的跨平台解决方案。通过<code>remax/one</code>提供跨平台的组件。</p> \n<pre><code class=\"js\">import * as React from \'react\';\nimport { View, Button } from \'remax/one\';\n\nexport default () =&gt; {\n  const [count, setCount] = React.useState(0);\n\n  return (\n    &lt;View alipay-onAppear={() =&gt; console.log(\'Aha!\')}&gt;\n      &lt;View&gt;{count}&lt;/View&gt;\n      &lt;Button onTap={() =&gt; setCount(count + 1)}&gt;+1&lt;/Button&gt;\n    &lt;/View&gt;\n  );\n};\n</code></pre> \n<p>可以看到，对于<code>onTap</code>这样通用的属性我们进行了统一，而支付宝独有的<code>onAppear</code>属性，则需要加上<code>alipay-</code>的前缀。</p> \n<p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/remaxjs/examples/tree/master/one\" rel=\"nofollow noreferrer\">完整的示例项目</a></p> \n<h3>使用</h3> \n<p>从模板创建项目：</p> \n<pre><code class=\"bash\">$ npx degit remaxjs/template-one my-app\n$ cd my-app</code></pre> \n<p>或者在已有的项目中引入：</p> \n<pre><code class=\"js\">// remax.config.js\nmodule.export = {\n  // 通过设置 one: true 来开启 Remax One。\n  one: true,\n  // 通过环境变量区分不同平台的输出目录\n  output: \'dist/\' + process.env.REMAX_PLATFORM,\n};\n</code></pre> \n<h2>小程序配置</h2> \n<p><code>app.config.js</code>以及页面的<code>config.js</code>配置文件支持多端配置方式：</p> \n<pre><code class=\"js\">// app.config.js\nconst title = \'小程序标题\';\nconst bgColor = \'#fff\';\nconst pages = [\'pages/index/index\'];\n\n// 支付宝\nexports.alipay = {\n  pages,\n  window: {\n    defaultTitle: title,\n    titleBarColor: backgroundColor,\n  },\n};\n\n// 微信\nexports.wechat = {\n  pages,\n  window: {\n    navigationBarTitleText: title,\n    navigationBarBackgroundColor: backgroundColor,\n  },\n};\n</code></pre> \n<h2>使用文件名后缀区分不同平台代码</h2> \n<p>通过创建不同平台的同名文件来封装跨平台组件和 API。例如：</p> \n<pre><code class=\"js\">// src/api/showToast/index.js\nimport { showToast } from \'remax/alipay\';\n\nexport default showToast;\n// src/api/showToast/index.wechat.js\nimport { showToast } from \'remax/wechat\';\n\nexport default options =&gt; {\n  showToast({\n    ...options,\n    title: options.content,\n  });\n};\n// src/pages/index.js\nimport { View } from \'remax-one\';\nimport showToast from \'@/api/showToast\';\n\nexport default () =&gt; {\n  return (\n    &lt;View\n      onClick={() =&gt; {\n        showToast({ content: \'Hello World!\' });\n      }}\n    &gt;\n      CLICK ME!\n    &lt;/View&gt;\n  );\n};\n</code></pre> \n<p><code>remax-cli</code>会优先读取<code>[target].js</code>文件，这个规则针对 CSS 等其他文件同样有效。</p> \n<h2>组件</h2> \n<p>如上面所说，我们非常克制谨慎地对<code>remax/one</code>中提供的组件做了筛选和重新设计，只保留了我们能保证在各个平台之间行为一致的组件和属性。</p> \n<p>如果需要使用某个平台特有的组件，可以直接从对应平台导入。如：</p> \n<pre><code class=\"js\">import * as React from \'react\';\nimport { View, Text } from \'remax/one\';\nimport { ScrollView } from \'remax/wechat\';\n\nexport default () =&gt; {\n  return (\n    &lt;ScrollView&gt;\n      &lt;View&gt;view&lt;/View&gt;\n      &lt;Text&gt;text&lt;/Text&gt;\n    &lt;/ScrollView&gt;\n  );\n};\n</code></pre> \n<p>如果需要使用某个平台特有的属性，可以通过<code>{平台前缀}-{平台原生属性名称}</code>来设置，例如：</p> \n<pre><code class=\"js\">import * as React from \'react\';\nimport { View, TapEvent } from \'remax-one\';\n\nexport default () =&gt; {\n  return (\n    &lt;View\n      id=\"id\"\n      className=\"class\"\n      alipay-onAppear={() =&gt; {}}\n      wechat-bindanimationend={() =&gt; {}}\n      wechat-disable-scroll={true}\n      onTap={(event: TapEvent) =&gt; {\n        console.log(event);\n      }}\n    &gt;\n      view\n    &lt;/View&gt;\n  );\n};\n</code></pre> \n<p>通过 Remax One 开发者可以非常方便地构建跨小程序平台的应用。</p> \n<p>另外社区同学开发的跨平台组件也正在路上：<a href=\"https://github.com/AnnaSearl/anna-remax-ui\" rel=\"nofollow noreferrer\">https://github.com/AnnaSearl/...</a></p>', null, null, '5ca4567d892841b087fac5246effac40', '7b3e40f8b9cc4b7780dc39a71d7f580e', '63c4e1e7ec204b43a62065a3ced4c2ce,3b375646301546259a8fb29d74ae4447,15941dc0af92453481b8a0626f963283,219d7aff8dfe4ffc9c8f368e2987187f', '0', '3', '1', '2020-04-23 10:30:12', '2020-04-23 10:30:12');
INSERT INTO `tb_recommend` VALUES ('0fc3e09977594746b30285c05306eece', 'GitHub 的 App 会开源吗？', '早在 2019 年的 GitHub Universe 大会上，GitHub 官方就宣布，他们即将推出移动端 App。而近日，GitHub APP 终于问世了。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbE7E6\" src=\"http://localhost:8060/tup/2020/4/23/4492715397534a57812c60d21b3db4cf.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>早在 2019 年的 GitHub Universe 大会上，GitHub 官方就宣布，他们即将推出移动端 App。而近日，GitHub APP 终于问世了。</p> \n<p>作为世界上最受欢迎的同性交友网站，在发布之后自然是喜大普奔，但在此之外，也有很多开发者提出功能不太全面，希望可以添加比如代码编辑之类的其他功能。</p> \n<p>对此，有热心的开发者留言建议，建议将 GitHub 的移动应用程序开源，大家一起来进行优化。</p> \n<p>对于此事，GitHub 的总监给出了回复。</p> \n<h2>GitHub 的移动应用程序会开源么？</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbE7Fe\" src=\"http://localhost:8060/tup/2020/4/23/e62080eb276540f0a4b9ac793b7c6120.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>对于这个问题，GitHub 的工程总监 Ryan Nystrom 给出了两个回复：</p> \n<p>\"It\'s not right now。\"</p> \n<p>\"Maybe.\"</p> \n<p>开源是现在的一个大趋势，虽然有很多软件确实是不需要开源的，但作为全球最大的开源软件平台，自己的产品不应该开源么？</p> \n<p>当今很多开源项目的开发都是在 GitHub 上或者通过 GitHub 进行的。对于这一开发者用来“吃饭”的工具，改善 GitHub App 的使用体验能有效的改善开发者的工作效率和方式，所以如果该项目真的开源，一定会吸引很多开发者参与其中。</p> \n<p>但 Ryan Nystrom 之所以不急于开源或者不“期待”开源的原因，是他认为要想让开源项目蓬勃发展，既要有对其感兴趣的开发者群体，也需要该群体具备足够的能力来为项目作出贡献。</p> \n<p>我们可以看一下 Linux。Linux 的开源之所以做的好，是因为每个开发者都需要这样的一个操作系统，并且有相当一部分人有能力对其作出贡献。</p> \n<p>但根据业内分析师给出的分析，假如 GitHub 推出一个收费程序，那么开发者的兴趣就会大幅降低；如果 GitHub App 的开源项目只是通过加载项/扩展的方式进行开发，那么 GitHub 项目的开源就没有太大的意义。</p> \n<p>所以 GitHub 总监说的“Maybe”，可能真的就是个“Maybe”了，毕竟没有人比他们更了解开源能带来多少价值。</p> \n<h2>开源的定义</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbE7Ff\" src=\"http://localhost:8060/tup/2020/4/23/b1106665fdc840b6b4864e5147f2d6c4.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>开源的概念，在电脑诞生前就已经出现了。最早的开源可能是发生在「吃」的领域，为了生存下去、提升食物的品质，人类学会了分享食谱。而目前对于开源比较认可的定义，由 Debian 的创始人 Bruce Perens 提出：</p> \n<blockquote> \n <ul>\n  <li>自由再散布（Free Distribution）：</li>\n </ul> \n <p>允许获得源代码的人可自由再将此源代码散布。</p> \n <ul>\n  <li>源代码（Source Code）：</li>\n </ul> \n <p>程序的可执行档在散布时，必需以随附完整源代码或是可让人方便的事后获取源代码。</p> \n <ul>\n  <li>派生著作（Derived Works）：</li>\n </ul> \n <p>让人可依此源代码修改后，在依照同一许可协议的情形下再散布。</p> \n <ul>\n  <li>原创作者程序源代码的完整性（Integrity of The Author’s Source Code）：</li>\n </ul> \n <p>意即修改后的版本，需以不同的版本号码以与原始的代码做分别，保障原始的代码完整性。</p> \n <ul>\n  <li>不得对任何人或团体有差别待遇（No Discrimination Against Persons or Groups）：</li>\n </ul> \n <p>开放源代码软件不得因性别、团体、国家、族群等设置限制，但若是因为法律规定的情形则为例外（如：美国政府限制高加密软件的出口）。</p> \n <ul>\n  <li>对程序在任何领域内的利用不得有差别待遇（No Discrimination Against Fields of Endeavor）：</li>\n </ul> \n <p>意即不得限制商业使用。</p> \n <ul>\n  <li>散布许可协议（Distribution of License）：</li>\n </ul> \n <p>若软件再散布，必需以同一条款散布之。</p> \n <ul>\n  <li>许可协议不得专属于特定产品（License Must Not Be Specific to a Product）：</li>\n </ul> \n <p>若多个程序组合成一套软件，则当某一开放源代码的程序单独散布时，也必需要符合开放源代码的条件。</p> \n <ul>\n  <li>许可协议不得限制其他软件（License Must Not Restrict Other Software）：</li>\n </ul> \n <p>当某一开放源代码软件与其他非开放源代码软件一起散布时（例如放在同一光盘），不得限制其他软件的许可条件也要遵照开放源代码的许可。</p> \n <ul>\n  <li>许可协议必须技术中立（License Must Be Technology-Neutral）：</li>\n </ul> \n <p>意即许可协议不得限制为电子格式才有效，若是纸本的许可协议也应视为有效。</p> \n</blockquote> \n<p>在软件产业中，免费软件、开源软件与自由软件的概念常常被不同程度地混淆起来，一般人并没有理顺其中的逻辑关系，造成了一定的误解，也引发了不少的错误决策。</p> \n<p>但其实简单来说，免费软件不一定必然开源，开源软件不一定必然免费。这点大家都很好理解。</p> \n<p>严格地来说，开放源代码软件与自由软件是两个不同的概念，只要符合开源软件定义的软件就能被称为开放源代码软件（开源软件）。自由软件是一个比开源软件更严格的概念，因此所有自由软件都是开放源代码的，但不是所有的开源软件都是“自由”的。</p> \n<p>虽说自由的态度就是要激励打破牢笼穿越围墙迎接思想的开放，努力分享展示自己的技术、原理，而不为了蝇头小利而对自己所谓的“技术”沾沾自喜而固步自封，但自由软件是否一定免费呢？</p> \n<p>也不能一概而论。</p> \n<p>每一位自由软件的贡献者当然是此软件的开发者和免费使用者，但对于普通用户而言，就不那么确定了。普通用户一般需要的不是软件而是服务，软件也许是免费，但是服务就从来都不是免费的了。</p> \n<h2>开源的价值</h2> \n<p>对于很多人来说，提到开源想到的就是「免费」和「非专业软件」。但实际上，随着开源的发展，现在的「开源」已经成为技术发展最好的生长模式之一。</p> \n<p>可以这么说，如果没有开源，很多的科技企业都不能达到今天的行业高度，比如谷歌、Facebook 和我们前面提到的 Linux。</p> \n<p>为了让更多人能够使用优秀的产品、让技术或者项目能够群策群力、快速的发展升级，都离不开开源带来的价值。</p> \n<p>美国的科技企业之所以热衷于开源，和文化有很大的关系。如果一家企业没有开源项目，会被质疑这家公司只会一味的索取，而不为行业和生态做出应有的贡献。</p> \n<p>所以从企业层面来说，开源一方面可以树立品牌形象，另外还可以通过开源项目吸引人才，招揽员工。往大了说开源对于企业甚至具有一定的战略意义。</p> \n<p>比如 Android，最初就是通过开源和病毒式的传播一下就赶上了 iOS。</p> \n<p>从个人层面来说，尝试开源也有着两个比较突出的意义。</p> \n<p>第一是有助于提升自己的代码水平。既然是开源项目，那么在写代码的时候一定会尽量的展现自身最好的水平，这会逼着自己让代码更简洁、易懂。其次，你的代码开源后，别人也能针对性的给你提出一些建议，帮助你进行代码的优化。</p> \n<p>其次可以通过开源项目展示个人的能力。虽然现在 GitHub 已经快被「别有用心的人」给玩坏了，但对于企业招聘来说仍然具有一定的参考价值。如果个人有个不错的开源项目，那么在面试的时候一定是个不错的加分项。</p> \n<p>对于开源，你怎么看？</p> \n<p>如果你有自己开源项目，可以和我私信进行交流，我们会定期对社区用户的优质开源项目进行推荐。</p> \n<blockquote>\n 参考资料：\n <p>《GitHub\'s mobile app to go open source? Definitely \"maybe\"》：<br><a href=\"https://www.techrepublic.com/article/githubs-mobile-app-to-go-open-source-definitely-maybe/\" rel=\"nofollow noreferrer\">https://www.techrepublic.com/...</a><br>《免费、开源与自由》：<br><a href=\"https://www.jianshu.com/p/eab781d2f8b9\" rel=\"nofollow noreferrer\">https://www.jianshu.com/p/eab...</a></p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCJ1M\" src=\"http://localhost:8060/tup/2020/4/23/ed102627a8804b7781a48331bc0e743e.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/1d477ff65b494af5b7a9c62707b2bc8f.jpg', '6fbfa4aaad3a43458f21c8acf0038ac5', '19eb3dd59ef8430d9f637d97449fc417', '634b81d655c74cb0adc4d0aa362b8819,f3eb17e6e5664a97af3e9b1fca12b286', '0', '3', '1', '2020-04-23 10:59:19', '2020-04-23 10:59:19');
INSERT INTO `tb_recommend` VALUES ('12c8f015b914487681b20d39a1063bda', '自动补全、回滚！介绍一款可视化 sql 诊断利器', 'Yearning MYSQL 是一个SQL语句审核平台。提供查询审计，SQL审核等多种功能，支持Mysql，可以在一定程度上解决运维与开发之间的那一环，功能丰富，代码开源，安装部署容易！', '<p><strong>Yearning简介</strong> </p> \n<p>=================</p> \n<p>Yearning MYSQL 是一个SQL语句审核平台。提供查询审计，SQL审核等多种功能，支持Mysql，可以在一定程度上解决运维与开发之间的那一环，功能丰富，代码开源，安装部署容易！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420074\" src=\"http://localhost:8060/tup/2020/4/23/5b7ec90333264929a2c515affc1f24e6.jpg\" alt=\"\" title=\"\"></span></p> \n<blockquote>\n <em>项目地址：<a href=\"https://gitee.com/cookieYe/Yearning\" rel=\"nofollow noreferrer\">https://gitee.com/cookieYe/Ye...</a></em>\n</blockquote> \n<h3>注意:</h3> \n<p>Yearning 1.x版本需inception提供SQL审核及回滚功能。</p> \n<p>Yearning 2.0开始无需依赖Inception，已自己实现了SQL审核/回滚功能</p> \n<p>Yearning&nbsp;功能介绍 </p> \n<p>================</p> \n<ul> \n <li>SQL查询</li> \n <li>查询工单</li> \n <li>导出</li> \n <li>自动补全，智能提示</li> \n <li>查询语句审计</li> \n <li>SQL审核</li> \n <li>流程化工单</li> \n <li>SQL语句检测与执行</li> \n <li>SQL回滚</li> \n <li>历史审核记录</li> \n <li>推送</li> \n <li>E-mail工单推送</li> \n <li>钉钉webhook机器人工单推送</li> \n <li>用户权限及管理</li> \n <li>角色划分</li> \n <li>基于用户的细粒度权限</li> \n <li>注册</li> \n <li>其他</li> \n <li>todoList</li> \n <li>LDAP登录</li> \n <li>动态审核规则配置</li> \n <li>AutoTask自动执行</li> \n</ul> \n<h1><strong>Yearning安装</strong></h1> \n<p>Yearning 不依赖于任何第三方SQL审核工具作为审核引擎,内部已自己实现审核/回滚相关逻辑。</p> \n<ul> \n <li> <strong>仅依赖Mysql数据库</strong>。mysql版本必须<strong>5.7及以上版本</strong>，创建Yearning库字符集应为<strong>UTF8mb4</strong>(仅Yearning所需mysql版本)</li> \n <li>Yearning日志仅输出error级别,没有日志即可认为无运行错误！</li> \n <li>Yearning 基于1080p分辨率开发仅支持1080p及以上显示器访问</li> \n</ul> \n<h1>Yearning下载</h1> \n<p>Yearning-go官方提供二进制下载包，下载地址&nbsp;<a href=\"https://github.com/cookieY/Yearning/releases\" rel=\"nofollow noreferrer\">https://github.com/cookieY/Ye...</a>。选择你所需要下载的软件包进行下载。</p> \n<p>源码安装：你先需要安装一些依赖等，一些相关的安装步骤如下：</p> \n<pre><code>[root@test&nbsp;~]# git clone https://github.com/cookieY/Yearning.git  \n[root@test&nbsp;~]# mv Yearning /usr/local/yearning  \n[root@test&nbsp;~]# cd /usr/local/yearning/  \n[root@test&nbsp;yearning]# cd install/  \n[root@test&nbsp;install]# ll  \ntotal 26728  \n-rw-r--r-- 1 root root 57763 Apr 23 16:06 connections.py  \n-rw-r--r-- 1 root root 16818 Apr 23 16:06 cursors.py  \n-rw-r--r-- 1 root root 679 Apr 23 16:06 docker_start.sh  \n-rw-r--r-- 1 root root 27270656 Apr 23 16:06 inception.tar  -rw-r--r-- 1 root root 11762 Apr 23 16:06 Yearning.sh  \n[root@test&nbsp;install]# tar xf inception.tar  \n[root@test&nbsp;install]# cd inception/bin/  \n[root@test&nbsp;bin]# ll  \ntotal 12472  \n-rw-r--r-- 1 501 games 722 Jan 3 10:39 inc.cnf  \n-rwxr-xr-x 1 501 games 9016999 Oct 12 2017 Inception  \n-rwxr-xr-x 1 501 games 3747312 Oct 12 2017 mysql</code></pre> \n<p>不过现在官方让直接下载.zip包，直接解压即可（所以这里就不建议使用源码安装了），比较方便。</p> \n<pre><code>mysql&gt;&nbsp;create database Yearning default character&nbsp;set&nbsp;utf8mb4 collate utf8mb4_unicode_ci;Query OK, 1 row affected (0.00 sec)</code></pre> \n<pre><code>mysql&gt; show databases;\n+--------------------+\n| Database&nbsp; &nbsp;    &nbsp; &nbsp; |\n+--------------------+\n| information_schema |\n| Yearning&nbsp; &nbsp;     &nbsp; &nbsp;|\n| mysql&nbsp; &nbsp; &nbsp; &nbsp;      &nbsp;|\n| performance_schema |\n| sys&nbsp; &nbsp; &nbsp; &nbsp;      &nbsp; &nbsp;|\n+--------------------+\n5&nbsp;rows&nbsp;in&nbsp;set (0.00&nbsp;sec)</code></pre> \n<p>只需要提前安装好Mysql数据库，并按前面的要求进行配置即可。</p> \n<pre><code>[root@CentOS7-1 ~]#&nbsp;ll\ntotal&nbsp;14036\n-rw-------. 1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1320&nbsp;Apr&nbsp;&nbsp;8 05:08&nbsp;anaconda-ks.cfg\n-rw-r--r--&nbsp;&nbsp;1&nbsp;root&nbsp;root&nbsp;14349178&nbsp;Apr&nbsp;11 09:26&nbsp;Yearning-2.2.0.linux-amd64.zip</code></pre> \n<p>上面我们直接从github上下载的最新版本2.2.0：</p> \n<pre><code>[root@CentOS7-1 ~]#&nbsp;cd&nbsp;Yearning-go/\n[root@CentOS7-1 Yearning-go]#&nbsp;ll\ntotal&nbsp;9772\n-rw-r--r--&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;127&nbsp;Aug&nbsp;&nbsp;1&nbsp;&nbsp;2019&nbsp;conf.toml\ndrwxr-xr-x&nbsp;6&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;116&nbsp;Apr&nbsp;&nbsp;6&nbsp;22:32&nbsp;dist\n-rw-r--r--&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;620&nbsp;Jan&nbsp;&nbsp;8&nbsp;21:06&nbsp;docker-compose.yml\n-rw-r--r--&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;597&nbsp;Aug&nbsp;21&nbsp;&nbsp;2019&nbsp;Dockerfile\n-rw-r--r--&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;177&nbsp;Aug&nbsp;23&nbsp;&nbsp;2019&nbsp;#&nbsp;README\n-rwxr--r--&nbsp;1&nbsp;root&nbsp;root&nbsp;9985356&nbsp;Apr&nbsp;&nbsp;6&nbsp;22:35&nbsp;Yearning\n-rw-r--r--&nbsp;1&nbsp;root&nbsp;root&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;283&nbsp;Jan&nbsp;15&nbsp;03:55&nbsp;yearning.service</code></pre> \n<p>修改配置文件</p> \n<pre><code>vim conf.toml\n\n[Mysql]\nDb =&nbsp;\"Yearning\"\nHost =&nbsp;\"127.0.0.1\"\nPort =&nbsp;\"3306\"\nPassword =&nbsp;\"xxxx\"\nUser =&nbsp;\"root\"\n\n[General]&nbsp;#数据库加解密key，只可更改一次。\nSecretKey =&nbsp;\"dbcjqheupqjsuwsm\"</code></pre> \n<blockquote> \n <em>SecretKey是token/数据库密码加密/解密的salt。建议所有用户在初次安装Yearning之前将SecretKey更改(不更改将存在安全风险)，格式: 大小写字母均可, 长度必须为16位。</em>\n <p><em>特别注意:此key仅可在初次安装时更改!之后不可再次更改!如再次更改会导致之前已存放的数据源密码无法解密,最终导致无法获取相关数据源信息。</em></p> \n</blockquote> \n<p>初始化</p> \n<pre><code>./Yearning -m</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGeD7\" src=\"http://localhost:8060/tup/2020/4/23/a923d337edd7495e832e3085be312b82.jpg\" alt=\"640.png\" title=\"640.png\"></span></p> \n<p>务必在-s启动前首先执行-m 初始化操作！如要再次初始化，需要把yearning库下所有表删除，否则重复执行无效。 </p> \n<p>启动服务</p> \n<pre><code>#默认启动\n./Yearning -s\n\n#参数启动\n./Yearning -s -b&nbsp;\"192.168.1.9\"&nbsp;-p&nbsp;\"8000\"</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420075\" src=\"http://localhost:8060/tup/2020/4/23/67d7dbd4af284829a23fbbcb954b01ac.jpg\" alt=\"\" title=\"\"></span></p> \n<p>使用帮助</p> \n<hr> \n<pre><code>[root@CentOS7-1 Yearning-go]# ./Yearning&nbsp;-h\nversion:&nbsp;Yearning/2.2.0&nbsp;general&nbsp;author:&nbsp;HenryYee\nUsage:&nbsp;Yearning&nbsp;[-m migrate]&nbsp;[-p port]&nbsp;[-s start]&nbsp;[-b web-bind]&nbsp;[-h help]&nbsp;[-c config file]\n\nOptions:&nbsp;-s&nbsp;&nbsp;启动Yearning&nbsp;\n-m&nbsp;&nbsp;数据初始化(第一次安装时执行)&nbsp;\n-p&nbsp;&nbsp;端口&nbsp;\n-b&nbsp;&nbsp;钉钉/邮件推送时显示的平台地址&nbsp;\n-x&nbsp;&nbsp;表结构修复,升级时可以操作。如出现错误可直接忽略。&nbsp;\n-h&nbsp;&nbsp;帮助&nbsp;\n-c&nbsp;&nbsp;配置文件路径&nbsp;\n-k&nbsp;&nbsp;用户权限变更为权限组(2.1.7以下升级至2.1.7及以上使用)&nbsp;\n-f&nbsp;&nbsp;初始化Admin用户密码</code></pre> \n<p>打开浏览器&nbsp;<a href=\"http://192.168.1.9\" rel=\"nofollow noreferrer\">http://192.168.1.9</a>:8000</p> \n<p>默认密码：admin/Yearning_admin</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420077\" src=\"http://localhost:8060/tup/2020/4/23/5255ffc7a1f0437296c817ac8c83c6aa.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>相关功能模块介绍</strong> </p> \n<p><strong>1、用户模块</strong> </p> \n<p>Dashboard：dashboard主要展示Yearning各项数据包括用户数/数据源数/工单数/查询数以及其他图表，个人信息栏内用户可以修改密码/邮箱/真实姓名，同时可以查看该用户权限以及申请权限(申请权限2.1.7版本后作废)。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420076\" src=\"http://localhost:8060/tup/2020/4/23/75175969747e468da38e2abfca5050b0.jpg\" alt=\"\" title=\"\"></span></p> \n<p>我的工单：展示用户提交的工单信息，对于执行失败/驳回的工单点击详细信息后可以重新修改sql并提交，对于执行成功的工单可以查看回滚语句并且快速提交SQL。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420078\" src=\"http://localhost:8060/tup/2020/4/23/c61e55b80ae84f7b92817ddf0b8a7e56.jpg\" alt=\"\" title=\"\"></span></p> \n<p>工单DLL：DDL相关SQL提交审核，查看表结构/索引，SQL语法高亮/自动补全。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420079\" src=\"http://localhost:8060/tup/2020/4/23/ede87396c9864d289f2041380cd323c9.jpg\" alt=\"\" title=\"\"></span></p> \n<p>DML审核：DML相关SQL提交审核，SQL语法高亮/自动补全。</p> \n<p><img alt=\"\" title=\"\"></p> \n<p>查询：查询/导出数据 SQL语法高亮/自动补全 快速DML语句提交。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420080\" src=\"http://localhost:8060/tup/2020/4/23/ebf97656f549471093b5b20a3ed5295f.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>2、审核模块</strong> </p> \n<p>工单审核：DDL/DML管理员审核并执行。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420083\" src=\"http://localhost:8060/tup/2020/4/23/ab3b2763b8cb42758e4c98fd1614c5cc.jpg\" alt=\"\" title=\"\"></span></p> \n<p>查询审核：用户的查询审核。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420082\" src=\"http://localhost:8060/tup/2020/4/23/68f46c0c079540759b38e760e4f943ed.jpg\" alt=\"\" title=\"\"></span></p> \n<p>权限审核：用户的权限审核（2.1.7版本以下）</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420081\" src=\"http://localhost:8060/tup/2020/4/23/22af2f81e80041d29c6f1917402b0cde.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>3、管理管理模块</strong> </p> \n<p>用户管理：创建/修改/删除用户</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420084\" src=\"http://localhost:8060/tup/2020/4/23/332e362c7766410c8223ebfd44e1fee0.jpg\" alt=\"\" title=\"\"></span></p> \n<p>数据库管理：添加/编辑/删除 数据源</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420087\" src=\"http://localhost:8060/tup/2020/4/23/197b6e71c7c546e99278ed2b89bb1648.jpg\" alt=\"\" title=\"\"></span>用户权限：用户权限修改/清空</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420085\" src=\"http://localhost:8060/tup/2020/4/23/383fe8f802534112a9d91e3d4ec48ac2.jpg\" alt=\"\" title=\"\"></span></p> \n<p>功能设置：设置消息推送相关信息 包括钉钉机器人/email，设置LDAP相关信息，全局配置信息，全局配置开关</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420086\" src=\"http://localhost:8060/tup/2020/4/23/3440a11b673e441ab85384a8042556ce.jpg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420088\" src=\"http://localhost:8060/tup/2020/4/23/0013d0461b9d4938818dfc64ab34334b.jpg\" alt=\"\" title=\"\"></span></p> \n<p>审核规则：设置SQL检测规则</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022420089\" src=\"http://localhost:8060/tup/2020/4/23/34d7d412e4f8444e8afd8b2ca8e81aa7.jpg\" alt=\"\" title=\"\"></span></p> \n<p>AutoTask自动执行任务</p> \n<p>2.1.4版本新增：用户可通过改功能设置自动执行任务。当提交的dml语句符合相应任务条件。将会自动执行，无需审核人审核。该功能仅限dml语句使用。请慎重使用！</p> \n<h1>总结</h1> \n<p>Yearning是一个SQL审核平台，在一定程度上可以解决运维与开发中间的问题，遗憾的是只支持Mysql，感兴趣的可以尝试下！</p> \n<blockquote>\n 参考资料：\n <br>\n <a href=\"https://guide.yearning.io/\" rel=\"nofollow noreferrer\">https://guide.yearning.io/</a>\n <br>\n <a href=\"https://gitee.com/cookieYe/Yearning\" rel=\"nofollow noreferrer\">https://gitee.com/cookieYe/Ye...</a> \n</blockquote>', null, 'http://localhost:8060/tup/2020/4/23/6914c30df0114f0e83df6eb5572aec47.jpg', '5ca4567d892841b087fac5246effac40', '91832bd0c3a244fb88c0bca74c0d404d', '1a77ff8ac4c54e58b5e6b22210cff64f,83f62facb3b943ffa8e46abd1ebc64d9,d7416e100af54eb7a4d9274b9a462240,55723db96b9f4593bae02bc1e49f1e87,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-23 11:01:03', '2020-04-23 11:01:03');
INSERT INTO `tb_recommend` VALUES ('13caab36984e4397b0d48c111e234c0d', 'iOS 14 或将推出新的 App 体验方式：无需下载即可使用', '通过分析 iOS 14 早期版本代码发现，苹果正在开发一种名为「Clips」的新 API。该 API 可以实现在用户扫描到某个 App 的二维码或打开链接时，不再跳转到 AppStore 的下载页面，而是直接在屏幕上显示一个浮窗卡片，...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQL9\" src=\"http://localhost:8060/tup/2020/4/23/3f18f6896afe4a928cc12a8ab4a32213.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>据 9to5mac 报道，苹果正在研究一种新的 App 体验方式，让用户无需下载 App 即可体验某款应用程序的部分功能。</p> \n<p>通过分析 iOS 14 早期版本代码发现，苹果正在开发一种名为「Clips」的新 API。该 API 可以实现在用户扫描到某个 App 的二维码或打开链接时，不再跳转到 AppStore 的下载页面，而是直接在屏幕上显示一个浮窗卡片，展示 App 本身的内容。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQML\" src=\"http://localhost:8060/tup/2020/4/23/7131383dfe5141638a7e7d7377cc2981.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>根据透露的消息显示，「Clips」API 与开发者可以访问的内部版本中的 QR Code 阅读器直接相关，因此用户可以扫描链接到应用程序的代码，然后直接从显示在屏幕上的卡上与其进行交互。也就是说，它允许开发人员为他们的应用程序提供交互式和动态内容，即使用户尚未安装它们。</p> \n<p>不过开发人员将需要指定应用程序的哪一部分可供下载并读取，同时跳出的浮动卡片会显示“从App Store下载完整版本的应用程序”的选项或“在已安装的应用程序中打开该内容”的选项。</p> \n<hr> \n<p>Android有一个类似的功能，叫做「Slices」，可以在谷歌搜索结果和谷歌助手等地方显示应用的交互部分。</p> \n<p>代码还显示，苹果公司正在测试 OpenTable、Yelp、DoorDash 和索尼 PS4 Second Screen、YouTube 以进一步优化新的 API。</p> \n<p>资料来源：<a href=\"https://9to5mac.com/2020/04/09/ios-14-apple-developing-clips-feature-for-using-apps-without-requiring-full-downloads/\" rel=\"nofollow noreferrer\">9to5mac</a></p>', null, 'http://localhost:8060/tup/2020/4/23/8231068d1c764c79aec37612008d5b77.jpg', 'c56940aa8b004dab84568e86900b2ee6', 'a337904dd1d5477b9689d7693be316de', '85ee959b27f74072b13cc763b9bbf77e,b7460efd3f3b4d6ea78254959a2aebff', '0', '3', '1', '2020-04-23 10:31:32', '2020-04-23 10:31:32');
INSERT INTO `tb_recommend` VALUES ('146f65a89295433f874aee1f3233d4fb', '框架设计：小程序框架与组件化如何选型定制', '如今早已是全民联网年代，可以发现自己的父母大姑大姨等亲戚甚至爷爷奶奶，只要他们在使用千元智能机了，无论是看头条还是微信还是抖音，都在参与整个互联网的流量和内容的产生，他/她们通过手机消费了自己的时间...', '<blockquote>\n 著作权归作者所有。商业转载请联系 Scott 获得授权，非商业转载请注明出处[务必保留全文，勿做删减]。\n</blockquote> \n<p>蚂蚁雄兵的年代，人人皆可为王。</p> \n<p>如今早已是全民联网年代，可以发现自己的父母大姑大姨等亲戚甚至爷爷奶奶，只要他们在使用千元智能机了，无论是看头条还是微信还是抖音，都在参与整个互联网的流量和内容的产生，他/她们通过手机消费了自己的时间，同时为所有的产品提供了更多人物画像的行为数据，无论是上翻下翻还是留言点赞，每一个 APP 都是一个独立的平台，而在这两年，冉冉升起的区别于 APP 的新应用平台，非小程序莫属:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1564468241133-734aa6af-b89e-489c-88bc-7170fbdcb011.png#align=left&amp;display=inline&amp;height=1044&amp;originHeight=1044&amp;originWidth=1884&amp;size=0&amp;status=done&amp;width=1884\" src=\"http://localhost:8060/tup/2020/4/23/e86fcbc2d0b341be9f5319ca51c88cf7.jpg\" alt=\"\" title=\"\"></span></p> \n<p>上图是从阿拉丁公布的数据报告中截取引用过来的，整个 2018 年，基于小程序生态的融资规模是 80 亿，是 2017 年的整整 8 倍，小程序几乎扎根了所有领域的所有层面，而且除了微信小程序，其他小程序小应用也都在布局：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1564468241116-fbe087ba-444d-4658-a968-e352bfb7c289.png#align=left&amp;display=inline&amp;height=1054&amp;originHeight=1054&amp;originWidth=1898&amp;size=0&amp;status=done&amp;style=none&amp;width=1898\" src=\"http://localhost:8060/tup/2020/4/23/3b9e272732124a8aa29a847a85ade985.jpg\" alt=\"\" title=\"\"></span></p> \n<p>在整个泛小程序生态崛起的过程中，许多创业公司都主动登船，小菜也不例外，我们是在 2018 年 3 月份开始技术预研和拥抱小程序生态，至此 1 年我们业务上收获颇丰，而技术这里，也略有积淀，就跟大家分享小程序这块我们的思考和沉淀。</p> \n<p><a></a></p> \n<h2>用原生还是用框架</h2> \n<p>小菜前端的个别同学，包括我都有过一些开发小程序的经验，没使用任何框架就用小程序原生语法来实现，但小程序的功能都比较简单，所以也自然没遇到太大的工程挑战，而我们 2018 年要启动的小程序产品具有两个特征：第一个是功能和交互足够的复杂，第二是迭代速度要非常快，两周就要首版上线，之后每周至少发一到两个版本，基于这样的业务背景，我们也就毅然的选择使用框架而非原生，但这个决策带来的后期风险也的确超出了我们的预期。</p> \n<p>如果我们再回到一年前做选型，估计还是会选择框架，但至少不会那么乐观的 All in 其中，而是择时机尽早切回原生（虽然我们目前已是半原生）。所以给大家的建议是：如果产品功能相对简单，一二十个页面也没有太奇怪的交互和太大的列表数据量，用框架用原生都可以，开发周期短的话就用框架，实际上市面上看到的绝大多数小程序都不属于是复杂应用，用框架都能很好很快的 hold 住，但反过来假如你要实现的产品交互和前端列表数据量较大，图片图表视频多媒体复杂搜索应有尽有，那么能用原生就用原生。</p> \n<p><a></a></p> \n<h2>如何选择框架</h2> \n<p>框架的核心价值就是效率，一旦我们决定使用框架，那么就要把当下及未来市面上可用的小程序框架，做一个必要的比较和选择，这个过程通常会比较纠结。因为截止到 2019 年，还并没有一个小程序框架足够足够的好，大家都在六七十分上下，那我们可以从哪些方面来考虑呢？</p> \n<p>小菜前端最初选型框架主要考虑如下几个方面（都很必要但优先级程度自上向下依次降低）：</p> \n<ul> \n <li>框架的成熟程度与开发效率 - 是否满足产品迭代需求</li> \n <li>多端（H5/小程序）的兼容程度 - 是否满足产品的端覆盖需求</li> \n <li>配置成本/易用性/拓展性 - 是否满足工程师的工程架构需求</li> \n <li>整体性能的表现 - 是否能顶得住复杂交互和大数据列表</li> \n <li>团队成员的学习成本 - 是否有必要的人员和技术栈储备</li> \n <li>框架背后的团队实力 - 是否有足够好的工程实践和开发支持</li> \n <li>框架在社区的沉淀和生态 - 是否有群众基础和社区方案</li> \n <li>框架是否是 KPI 产品 - 是否会慢慢 Bug 不修弃坑跑路</li> \n</ul> \n<p>总体做选型的路子是优先保产品，再看工程质量及合理性，最后看社区及开发者生态健康程度。</p> \n<p>很可惜，即便我们考虑了这么多，限于当时（2018 年 3~5 月）的小程序框架生态太过早期也太单薄，我们最终选择了美团的 MPVue（实际上没得选），但上面的参考项今天看来对大家依然是通用的，当时的比对过程我再给大家呈现下，帮大家加深下这个选型运用的过程：</p> \n<p>首先针对能否优先保产品，也就是框架成熟程度和开发效率，多端兼容程度这块，我们实际上只有 wepy，MPVue，Taro 可选，针对他们三个，我们是这样比对的：</p> \n<ul> \n <li>社区生态是否足够活跃</li> \n <li>跨端迁移成本</li> \n <li>框架核心团队是否背靠大厂，是否是 KPI 产物</li> \n <li>开发效率问题，更多是踩坑时间问题</li> \n</ul> \n<p>其次，针对工程质量与合理性，也就是框架的配置成本/易用性/拓展性，整体性能这块，我们是这样评估的：</p> \n<ul> \n <li>框架上手成本</li> \n <li>底层工程架构基建是否支持到位</li> \n <li>性能问题: 先上再说，过得去就好，剩下的就慢慢优化</li> \n</ul> \n<p>最后，针对社区/开发者生态，也就是团队成员既有技术栈、社区反馈和生态这块，我们是这样评估的：</p> \n<ul> \n <li>团队成员中是否有人具备相应的技术栈能力</li> \n <li>框架是否支持已有的库快速接入</li> \n <li>社区对于该框架的反应如何，是否还属于半成品或者存在 Bug 很多的问题</li> \n</ul> \n<p><a></a></p> \n<h2>如何做组件化</h2> \n<p>小菜最初的产品端载体主要是 APP 和 PC Web，尤其是 APP，有 7 个之多，所以 RN 的组件化在 2018 年是有过两个大版本的累计了好几十个，但这个对于小程序来讲远水解不了近渴，而小程序的页面数目越来越多，组件复用变成了刚需，所以我们开始了小程序的组件建设之旅。</p> \n<p>基于 MPVue 在小程序里写组件，也是比较神伤。因为小程序端代码是静态的(即提前编译好的模版)， 所以像 HOC 就没办法用了（还有很多其他一些 Vue 语法糖编译不了）, 我们这里用的都是 mixins，基础的 mixins&nbsp;有很多:</p> \n<ul> \n <li>函数调用相关(去抖/节流)</li> \n <li>列表加载相关</li> \n <li>用户基础信息/微信信息</li> \n <li>数据初始化相关</li> \n <li>分享调用相关</li> \n <li>页面下拉/滚动相关</li> \n <li>收集 Form Id</li> \n <li>授权处理相关</li> \n</ul> \n<p>基于 mixins 就可以来设计组件了，一旦决定要抽象出一个组件，我们主要考虑如下因素：</p> \n<ul> \n <li>UI/功能的耦合程度</li> \n <li>内外部调用的耦合程度</li> \n <li>组合组件（组件间的通信层）</li> \n <li>组件性质（基础/业务）</li> \n <li>兼容问题</li> \n <li>后期扩展能力</li> \n</ul> \n<p>我们已经沉淀的组件有：</p> \n<ul> \n <li>上传组件（Upload）</li> \n <li>Tabbar</li> \n <li>Spinner</li> \n <li>Radio/Radio Group</li> \n <li>Video</li> \n <li>Cell</li> \n <li>Input/Textarea</li> \n <li>SearchBar</li> \n <li>授权/登录弹窗 组件</li> \n <li>保存/预览图片 组件</li> \n <li>图片懒加载/占位 组件</li> \n <li>语音录制/播放 组件（Record-bubble/Record-button）</li> \n <li>页面异常状态组件 (102/404)</li> \n <li>其他业务组件......</li> \n</ul> \n<p>这些组件里面：</p> \n<p>比如 Input/Textarea 组件，它需要重点考虑 UI/功能的耦合，要如何设计？</p> \n<ul>\n <li>组件复杂度高的话，可以切分数据服务层与 UI 层，采用 Mixin 混合抽象方法到 UI 层里。</li>\n</ul> \n<p>比如授权/登录弹窗组件，它需要重点考虑内外部调用的耦合，要如何设计？</p> \n<ul> \n <li>组件需要具备单一职责，不能图方便把很多东西都耦合进去</li> \n <li>如何和其他组件配合使用</li> \n</ul> \n<p>比如 Upload Group 组件，它属于是组合组件，要如何设计？</p> \n<ul> \n <li>上传发生异常的处理与上抛。</li> \n <li>组合层之间调用的 Hook。</li> \n <li>注意 Props 的透传与值的双向绑定。</li> \n</ul> \n<p>比如语音录制/播放组件，它需要组件性质，要如何设计？</p> \n<ul> \n <li>业务级别的组件，在复杂度高的情况下，也可以考虑切分 UI/数据服务层。</li> \n <li>如果通信层较复杂的话，可以考虑类似 redux 的设计，下层组件 dispatch action 到上层，上层统一管理 action 并 分发数据/事件 给下层组件。</li> \n</ul> \n<p>除此以外，组件设计的时候还要兼顾小程序端上与 Vue 的差异性。比如生命周期（组件与页面），在 MPVue 编译完后，&nbsp;Vue 组件生命周期并不会编译成小程序组件的生命周期，说白了就是需要你熟悉两套生命周期:&nbsp;&nbsp;Vue&nbsp;组件生命周期与小程序组件/页面生命周期。</p> \n<ol> \n <li>MPVue&nbsp;编译完的 Vue&nbsp;组件生命周期并不会和 小程序组件生命周期的调用一致，比如<strong>第二次</strong>点开同一个页面，非页面级别的组件 <code>mounted</code>&nbsp;永远只会调用一次（除非你在组件或者组件上层挂了&nbsp;<code>v-if</code>&nbsp;），而实际上这个组件在小程序里被调用了两次 <code>attached</code>&nbsp;小程序组件生命周期。</li> \n <li>更不用说&nbsp;<code>beforeMount/onUnload</code>&nbsp;的问题了。</li> \n <li>页面数据缓存问题，小程序本身会缓存打开过的页面数据，常见场景就是商品详情页面，第二次打开的时候，在进行页面数据更新之前，页面并不是空状态，而是上一次详情的数据。处理的话就有很多种方法了，可以在 <code>beforeMount/onUnload/其他生命周期</code>&nbsp;里初始化页面数据及置空所有状态，具体就看你怎么设计和抽象了，最主要的目的还是让开发者尽可能少的感知/手动调用。</li> \n</ol> \n<p>除了要考虑以上这些问题之外，我们还需要去解决端上的兼容问题以及框架带来的问题。</p> \n<p>微信端的兼容问题简直是层出不穷，不仅和机型、系统版本有关，甚至还和微信版本有关。所以当遇到这一类问题的时候，我们只能求助于&nbsp;<a href=\"https://developers.weixin.qq.com/\" rel=\"nofollow noreferrer\">微信开发者社区</a>，期待有相应的解决方案。</p> \n<p>框架带来的问题有时候就有点恶心了。比如说 MPVue 并不支持动态的传入&nbsp;<code>input</code>&nbsp;的&nbsp;<code>type</code>&nbsp;属性，这就导致如果我们需要文本键盘、数字键盘、带小数点数字键盘等等这一类的&nbsp;<code>input</code>&nbsp;时，我们需要每种类型都写一个&nbsp;<code>input</code>&nbsp;组件，平白增加了代码量，并且定位到问题也不方便。</p> \n<p><a></a></p> \n<h2>逃不过的原生能力</h2> \n<p>以上我们探讨了框架选型和组件化设计，最后再回归到我们认为非常核心的一个能力，就是小程序的原生开发和优化能力，MPVue 编译完的代码运行时的性能在很多场景里并不达到你的要求，比如输入组件的双向绑定之光标闪烁/内容回退,，大数据量之操作延迟等等...... （没遇到过的同学<a href=\"https://github.com/Meituan-Dianping/mpvue/issues\" rel=\"nofollow noreferrer\">自行搜索</a>）。总的来说就是&nbsp;MPVue 底层对于数据的操作实现的很稀烂，这个问题也只有当我们将项目做大了才遇到。</p> \n<p>当遇到类似上面这种性能问题的时候，就避免不了去寻找解决方案。但所谓的解决方案很有限，要么换框架，这时候已经上车，全量换框架工程太过浩大不敢想。要么写原生，写原生不仅工程量也浩大，而且原生代码的复用成本也难度不小，这就是框架选型带来的后续维护成本和风险了。</p> \n<p>但问题是躲不过去的，终究要解决。除了上面这几点需要去衡量的之外, 还要衡量一些非技术因素:</p> \n<ul> \n <li>产品发展形态/可预见的趋势：随着业务的发展以及小程序的权限收缩，为了继续扩大产品的可触达范围，势必会新增更多的端。</li> \n <li>用户群体：需要去收集用户的地理信息、手机型号、网络环境等等，综合这些数据去优化相应的点，做到有的放矢。</li> \n</ul> \n<p>我们最终还是决定当部分组件替换为原生组件，比如：</p> \n<ul> \n <li>MPVue 写的 <code>input/textarea</code>&nbsp;在输入的时候就会出现光标闪烁/内容回滚的异常（原因就不赘述了），所以使用小程序原生语法重写了 <code>input/textarea</code>&nbsp;组件，主要目的就是让组件的输入能够脱离 MPVue 的更新，直接组件内部走小程序的 <code>setData</code>&nbsp;，因为当时 MPVue&nbsp;还没有对数据更新做&nbsp;<code>diff</code>&nbsp;操作，目前据说做了一层 <code>diff</code>&nbsp;（实际效果大家自己去测评吧）</li> \n <li>产品中的文章详情需要 Markdown 渲染，因为文章内容相对来说都是数据量比较大的，使用 MPVue 去对这部分数据进行解析的话性能会相对来说较差。因此我们也使用了原生去实现了一个 Markdown 渲染的组件。</li> \n</ul> \n<p>其实除了将组件替换为原生组件之外，我们还可以去优化原生的 <code>setData</code>&nbsp;方法，具体内容可以阅读 <a href=\"https://github.com/Tencent/westore\" rel=\"nofollow noreferrer\">westore</a>&nbsp;这个库，进一步提升性能。</p> \n<p>最终，我们的架构慢慢就会变成了这样：Vue 会慢慢成为一个数据注入/数据分析/事件分发三者集合的中心枢纽一样的存在，底层是由各种高性能的原生组件，上层是由 Vue 来分发事件给不同组件，注入数据到不同组件里，收集埋点行为/事件。</p> \n<p>这样一个现状依然有它新的问题，首先是多端复用成本低，现在还无法一套代码在 H5/小程序里全部通用，其次是小程序原生学习成本还是比框架要高，这对于不熟悉原生的同学都是一个不小的技术学习成本。</p> \n<p><a></a></p> \n<h2>当下的困境</h2> \n<p>当下来看，我们之前选择的 MPVue 已经不能很好地支撑业务需求了。其一是因为 Vue 与我们的主体技术栈的分割，二来 MPVue 并不能支持跨多个平台开发。</p> \n<p>跨多平台开发已经是当下的一个迫切需求。假如一个需求需要维护多端的代码，那么势必会需要更多的前端资源投入，这个成本是难以接受的。因此我们也开始考虑到底是使用市面上类似 Taro 这样的框架还是选择自研，两者的选择都有各自的好处。选择 Taro 这样的框架能够让我们迅速进入开发，但是长远来看免不了可能会出现 MPVue 类似的维护问题；选择自研的话虽然不会存在维护上的问题，但是会短期内需要投入更多的前端资源。</p> \n<p>以上这些问题就是我们当下遇到的一个困境，选择任何一个方案都可能对将来造成巨大的问题，就比如当初我们选择 MPVue 那样。</p> \n<blockquote>\n Scott 近两年无论是面试还是线下线上的技术分享，遇到许许多多前端同学，由于团队原因，个人原因，职业成长，技术方向，甚至家庭等等原因，在理想国与现实之间，在放弃与坚守之间，摇摆不停，心酸硬扛，大家可以找我聊聊南聊聊北，对工程师的宿命有更多的了解，有更多的看见与听见，Scott 微信： codingdream，也可以来\n <a href=\"https://www.yuque.com/iscott\" rel=\"nofollow noreferrer\">关注 Scott 跟进我的动态</a>。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882754189-781488ce-b345-45cf-a3b7-cb5309e9caa6.png#align=left&amp;display=inline&amp;height=399&amp;name=2.png&amp;originHeight=600&amp;originWidth=600&amp;size=158647&amp;status=done&amp;style=none&amp;width=399\" src=\"http://localhost:8060/tup/2020/4/23/db965f99149a45c8880bc978def519df.jpg\" alt=\"2.png\" title=\"2.png\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882773713-309efa88-e1fc-481f-865b-3c0cb0d3ec43.png#align=left&amp;display=inline&amp;height=398&amp;name=1.png&amp;originHeight=600&amp;originWidth=600&amp;size=134434&amp;status=done&amp;style=none&amp;width=398\" src=\"http://localhost:8060/tup/2020/4/23/825c194b184c423e8cf9a8a6f77fc427.jpg\" alt=\"1.png\" title=\"1.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/a2b68233e87b4fd98ce7ec625e9f6164.jpg', '1c5851dc916d4e70a60f0c957f548876', '7b3e40f8b9cc4b7780dc39a71d7f580e', '63c4e1e7ec204b43a62065a3ced4c2ce,3b375646301546259a8fb29d74ae4447,ead69bffd58e43f2a5ead395c498cf8e', '0', '3', '1', '2020-04-23 10:29:59', '2020-04-23 10:29:59');
INSERT INTO `tb_recommend` VALUES ('182c47216f184ab1b490aaa49764b136', 'Flutter 学习笔记《插件篇》：路由插件 fluro', 'Flutter 自身是提供了 Navigator widget 来实现应用的路由功能。但使用一些路由插件，可以帮助我们更方便快捷的实现 Flutter 应用页面间的跳转和传值等功能。', '<p>Flutter 自身是提供了 <code>Navigator</code> widget 来实现应用的路由功能。但使用一些路由插件，可以帮助我们更方便快捷的实现 Flutter 应用页面间的跳转和传值等功能。</p> \n<p>这篇笔记我们主要来学习一下 fluro 这个插件。</p> \n<h1>1. 项目引入 fluro</h1> \n<p>Flutter 应用中要使用任何第三方插件，都需要先在项目中进行引入。</p> \n<p>打开项目根目录中的 <code>pubspec.yaml</code> 文件，在 <code>dependencies</code> 属性下面添加 fluro 的配置代码：</p> \n<pre><code class=\"yaml\">dependencies:\n  fluro: ^1.6.3</code></pre> \n<p>参考代码截图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFMXv\" src=\"http://localhost:8060/tup/2020/4/23/bbdc4d5d1edc4f6a8e2be401c01d38ae.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<blockquote>\n 说明：1.6.3 是当前（2020.04.13）fluro 的最新版本号，大家以后在使用时，建议先去\n <a href=\"https://github.com/theyakka/fluro\" rel=\"nofollow noreferrer\">官网</a>看看最新的版本号是多少，配置的时候就改成最新版本号即可。\n</blockquote> \n<h1>2. fluro 的基本使用</h1> \n<p>fluro 最基本的功能就是“跳转页面”，其他的“传值”、“返回”等功能对于我们菜鸡来说都是高级操作了，所以先不谈。我们先来学基操！</p> \n<h2>2.1 建立路由文件</h2> \n<p>一般情况下，我们都会在项目的 lib 目录中创建一个的新的文件夹（例如：<code>lib/routers</code>），专门用来存放与路由相关的配置代码。</p> \n<h2>2.2 路由配置</h2> \n<p>创建一个 <code>lib/routers/routes.dart</code> 文件用来进行路由的相关配置：</p> \n<pre><code class=\"dart\">import \'package:flutter/material.dart\';\n// 引入 fluro\nimport \'package:fluro/fluro.dart\';\n// 引入路由要跳转的页面文件\nimport \'package:flutter_fluro_demo/home_page.dart\';\nimport \'package:flutter_fluro_demo/login_page.dart\';\n\nclass Routes {\n  // 各个页面的路径字符串\n  static String home = \'/home\';\n  static String login = \'/login\';\n  // 创建一个 configureRoutes 方法，用于路由配置\n  static void configureRoutes(Router router) {\n    // 配置 home 首页路由\n    router.define(home, handler: Handler(\n        handlerFunc: (BuildContext context, Map&lt;String, List&lt;String&gt;&gt; params) {\n          return HomePage();\n        },\n      ),\n    );\n    // 配置 login 登录页路由\n    router.define(login, handler: Handler(\n        handlerFunc: (BuildContext context, Map&lt;String, List&lt;String&gt;&gt; params) {\n          return LoginPage();\n        }\n      ),\n    );\n  }\n}</code></pre> \n<p>在这个配置文件里，我们以“首页”和“登录页”为例，做了一个最基础的路由配置。</p> \n<h2>2.3 路由静态化处理</h2> \n<p>为了方便我们后面在各个页面中使用路由，我建议（官方也建议）先对路由做一个静态化处理。</p> \n<p>在 <code>lib/routers</code> 中再创建一个 <code>application.dart</code> 文件，添加以下代码：</p> \n<pre><code class=\"dart\">import \'package:fluro/fluro.dart\';\n\nclass Application {\n  static Router router;\n}</code></pre> \n<p>在这段代码中，我们创建了一个 Application 对象，并设置了一个静态属性 router。</p> \n<p>在下一步全局注入路由的时候，我们会把调用 <code>Router()</code> 方法得到的路由对象保存在 <code>Application.router</code> 属性中。这样，在后续各个页面中使用路由时，就可以直接通过 <code>Application.router</code> 来拿到路由对象，而不需要反复调用 <code>Router()</code> 方法了。</p> \n<h2>2.4 全局注入路由</h2> \n<p>各项配置完成之后，接下来就需要在项目入口文件 <code>main.dart</code> 中注入路由来使我们的路由生效。</p> \n<pre><code class=\"dart\">import \'package:flutter/material.dart\';\nimport \'package:fluro/fluro.dart\';\nimport \'package:flutter_fluro_demo/routers/routes.dart\'; // 路由配置文件\nimport \'package:flutter_fluro_demo/routers/application.dart\';  // 路由静态化文件\n\nvoid main() {\n  final router = Router();  // 获取路由对象\n  Routes.configureRoutes(router);  // 调用路由配置方法\n  Application.router = router;  // 将路由对象静态化\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      onGenerateRoute: Application.router.generator,  // 将路由配置到 MaterialApp 中\n      // ...\n    );\n  }\n}</code></pre> \n<h2>2.5 路由跳转</h2> \n<p>fluro 中最简单的跳转方式就是通过 <code>navigateTo()</code> 方法来实现：</p> \n<pre><code class=\"dart\">import \'package:flutter_fluro_demo/routers/application.dart\';\n// ...\nApplication.router.navigateTo(context, \'/home\');</code></pre> \n<p>参考代码截图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFNGP\" src=\"http://localhost:8060/tup/2020/4/23/3292ae8eb1bf4f419557a5b0b380c923.jpg\" alt=\"image.png\" title=\"image.png\"></span><br>到这一步，我们一个最简单的路由跳转就实现啦。</p> \n<h1>3. fluro 的进阶使用</h1> \n<p>路由的基本使用学会了之后，接下来我们就需要增加一丢丢的难度了。</p> \n<h2>3.1 拆分路由配置文件</h2> \n<p>在前面的路由基础用法里，我们将所有关于路由的配置都放在了 <code>routes.dart</code> 文件中，当我们项目的页面逐渐增多时，就会导致这个文件变得越来越大，代码越来越多，后期维护起来也会越来越不方便。</p> \n<p>所以，我们要对 <code>routes.dart</code> 文件中的代码进行拆分。</p> \n<p><code>routes.dart</code> 原本的代码如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF2EA\" src=\"http://localhost:8060/tup/2020/4/23/0149808689f54a0582335d809961e970.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>从图中代码可以看到，路由操作的大部分代码都集中在了 <code>handler</code> 属性中，因此，我们就把每一个 <code>handler</code> 属性的属性值都提取出去。</p> \n<p>在 <code>lib/routers</code> 中再创建一个文件：<code>route_handlers.dart</code>，将拆分出来的代码放进去：</p> \n<pre><code class=\"dart\">import \'package:flutter/material.dart\';\nimport \'package:fluro/fluro.dart\';\n\nimport \'package:flutter_fluro_demo/home_page.dart\';\nimport \'package:flutter_fluro_demo/login_page.dart\';\n\nHandler homeHandler = Handler(\n  handlerFunc: (BuildContext context, Map&lt;String, List&lt;String&gt;&gt; params) {\n    return HomePage();\n  },\n);\n\nHandler loginHandler = Handler(\n  handlerFunc: (BuildContext context, Map&lt;String, List&lt;String&gt;&gt; params) {\n    return LoginPage();\n  },\n);</code></pre> \n<p>这样拆分后，我们原本的 <code>routes.dart</code> 文件就变得很干净了。</p> \n<pre><code class=\"dart\">import \'package:fluro/fluro.dart\';\nimport \'./route_handlers.dart\';\n\nclass Routes {\n  static String home = \'/home\';\n  static String login = \'/login\';\n\n  static void configureRoutes(Router router) {\n    router.define(home, handler: homeHandler);\n    router.define(login, handler: loginHandler);\n  }\n}</code></pre> \n<h2>3.2 路由传参</h2> \n<p>虽然我们把路由传参划分到了进阶用法里，但是实际上我们应该都清楚，任何一个 App 里，路由传参功能都是必不可少的。更何况，fluro 的路由传参其实 so easy～</p> \n<blockquote>\n 路由传参其实简单理解为一个点外卖的过程。例如我们要将 home 页面的数据传递 detail 页面，那么 home 页面就是商家，detial 页面就是整天宅在家里扣 jio 的你，而 fluro，就是我们的外卖骑手。\n</blockquote> \n<p>理解了传参的流程之后，接下来我们就可以开始搬砖了。</p> \n<p><strong>第一步：在 detial 页面配置要接收的参数</strong></p> \n<p>detail 页面中的代码如下：</p> \n<pre><code class=\"dart\">import \'package:flutter/material.dart\';\n\nclass DetailPage extends StatelessWidget {\n  DetailPage({this.detailId});\n  final String detailId;\n\n  //...\n}</code></pre> \n<p>这里我们定义了一个 <code>detailId</code>，用来接收后面 home 传递过来的参数。</p> \n<p>我的案例代码截图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFWpy\" src=\"http://localhost:8060/tup/2020/4/23/90c4ff68e7b348138644511965faa9c6.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p><strong>第二步：在 home 页面设置要传递的参数</strong></p> \n<p>home 页面的路由跳转和传参代码如下：</p> \n<pre><code class=\"dart\">RaisedButton(\n  child: Text(\'去详情页\'),\n  onPressed: () {\n    Application.router.navigateTo(context, \'/detail/001\');\n  },\n),</code></pre> \n<p><code>/detail/001</code> 中的 <code>/detail</code> 就是我们要去到的 detail 页面的路径，<code>001</code> 就是我们要传递给 detail 页面的参数。</p> \n<p><strong>第三步：在路由配置文件中对 detail 路由进行配置</strong></p> \n<p>打开 <code>lib/routers/routes.dart</code> 文件，对 detail 的路由进行如下配置：</p> \n<pre><code class=\"dart\">class Routes {\n  // ...\n  static String detail = \'/detail/:id\';\n\n  static void configureRoutes(Router router) {\n    // ...\n    router.define(detail, handler: detailHandler);\n  }\n}</code></pre> \n<p>参考代码截图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF2EH\" src=\"http://localhost:8060/tup/2020/4/23/36612c15fd1c458baaeacbe1aa72ee09.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>（<code>detailHandler</code> 报错是因为我们还没创建这个变量，下一步创建好就不会报错了。）</p> \n<p><code>/detail/:id</code> 中的 <code>id</code> 是我们自己定义的一个参数名，是对 home 页面传递的参数进行命名。 </p> \n<p>接下来，再打开 <code>lib/routers/routes_handlers.dart</code> 文件，配置 detail 的 handler 方法。</p> \n<pre><code class=\"dart\">import \'package:flutter_fluro_demo/detail_page.dart\';\n// ...\nHandler detailHandler = Handler(\n  handlerFunc: (BuildContext context, Map&lt;String, List&lt;String&gt;&gt; params) {\n    String id = params[\'id\'].first; // 通过 params 获取到路由中传递的参数\n    return DetailPage(detailId: id);\n  },\n);</code></pre> \n<p>到此，我们 home 页面，通过路由往 detail 页面的传参就已经完成了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFWpC\" src=\"http://localhost:8060/tup/2020/4/23/d0f7555d70b848c5b6cefbded76fbeb4.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<h2>3.3 返回页面</h2> \n<p>在 Flutter 中，跳转后的页面左上角会自带一个返回箭头，但是有的时候，我们也需要点击界面其他地方来实现页面的返回，又或者，我们想返回到一个指定的界面。</p> \n<h3>3.3.1 返回到上一页面</h3> \n<p>页面返回的代码很简单：</p> \n<pre><code class=\"dart\">RaisedButton(\n  child: Text(\'返回上一页\'),\n  onPressed: () {\n    // flutter \n    Navigator.pop(context);\n    // fluro\n    // Application.router.pop(context);\n  },\n)</code></pre> \n<p>从上面代码可以看出，实现“返回上一页面”功能的方式两种：一种是 flutter 自带的 <code>Navigator</code> widget 提供的 pop 方法；另一种是 fluro 中提供的 pop 方法。</p> \n<p>这里我们列出 flutter 原生的返回方式，是因为 flutter 原生的方式更简洁一些，所以路由的返回功能我们更多会选择直接用 <code>Navigator</code> 的方法返回。</p> \n<h3>3.3.2 返回到指定页面</h3> \n<p>fluro 中并没有提供专门的“返回到指定页面”的方法（我有看 fluro 的源码，确实没有找到，如果这里说法有误请大家评论里告诉我）。所以如果我们想要实现“返回到指定页面”的效果，可以直接用 <code>navigateTo</code> 页面跳转方法实现。</p> \n<p>具体代码可以参考前面「2.5 路由跳转」的示例代码。</p> \n<h2>3.4 管理历史记录</h2> \n<p>默认情况下，每一次的路由跳转，都会有一个新的路由记录注册到路由表中。</p> \n<p>fluro 中的 <code>navigateTo()</code> 方法可以设置第三个参数来管理路由历史记录。</p> \n<h3>3.4.1 替换历史记录</h3> \n<p>替换历史记录是指用“跳转后的新页面”记录替换掉“当前页面”记录。将 <code>navigateTo()</code> 方法的第三个参数设置为 <code>replace: true</code> 即可。</p> \n<pre><code class=\"dart\">child: RaisedButton(\n  child: Text(\'去详情页\'),\n  onPressed: () {\n    Application.router.navigateTo(context, \'/detail/001\', replace: true);\n  },\n),</code></pre> \n<p>参考代码截图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF2CX\" src=\"http://localhost:8060/tup/2020/4/23/976d6a517cc243c199ff090ccad00bcc.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>当我们从“登录页”跳转到“首页”，再从“首页”跳转到“详情页”，然后点击“详情页”左上角的返回按钮，可以发现，直接返回到了“登录页”。因为我们的历史记录里面已经没有保留“首页”的记录了。</p> \n<h3>3.4.2 清空历史记录</h3> \n<p>除了替换一条历史记录外，<code>navigateTo()</code> 方法还可以将第三个参数设置为 <code>clearStack: true</code> 来实现清空历史记录的效果。</p> \n<pre><code class=\"dart\">child: RaisedButton(\n  child: Text(\'去详情页\'),\n  onPressed: () {\n    Application.router.navigateTo(context, \'/detail/001\', clearStack: true);\n  },\n),</code></pre> \n<h1>4. 最后</h1> \n<p>fluro 的用法大概就是这些了，如果还有没写到的知识点，大家可以在评论里告诉我，我再补充。</p>', null, 'http://localhost:8060/tup/2020/4/23/9af47d15fb7746c7887cbf0c513411cd.jpg', '3f69fcc9b13843d1910b3dac597f5215', '2a353971222c4aff8e8d3e9c370330cd', '14ab12176ade47da95ba97d7151eb1f9,015783aba70b4c11bc1fddcaffa72d31,32b327672bf34bb49868560bae1a0ab0', '0', '3', '1', '2020-04-23 11:00:47', '2020-04-23 11:00:47');
INSERT INTO `tb_recommend` VALUES ('18f3a13836344458a38da4a961425c40', '百度开源联邦学习框架 PaddleFL，让大规模分布式集群中部署联邦学习系统更容易', 'PaddleFL是一个基于飞桨（ PaddlePaddle）的开源联邦学习框架。研究人员可以很轻松地用PaddleFL复制和比较不同的联邦学习算法。开发人员也可以从padderFL中获益，因为用PaddleFL在大规模分布式集群中部署联邦学习...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFJDQ\" src=\"http://localhost:8060/tup/2020/4/23/4b2677279513418a99c15ae3f1b6f4b2.jpg\" alt=\"开源联邦学习框架PaddleFL.jpg\" title=\"开源联邦学习框架PaddleFL.jpg\"></span></p> \n<p>PaddleFL是一个基于飞桨（ PaddlePaddle）的开源联邦学习框架。研究人员可以很轻松地用PaddleFL复制和比较不同的联邦学习算法。开发人员也可以从padderFL中获益，因为用PaddleFL在大规模分布式集群中部署联邦学习系统很容易。</p> \n<p>PaddleFL提供很多联邦学习策略及其在计算机视觉、自然语言处理、推荐算法等领域的应用。此外，PaddleFL还将提供传统机器学习训练策略的应用，例如多任务学习、联邦学习环境下的迁移学习。依靠着PaddlePaddle的大规模分布式训练和Kubernetes对训练任务的弹性调度能力，PaddleFL可以基于全栈开源软件轻松地部署。</p> \n<h4>联邦学习</h4> \n<p>如今，数据变得越来越昂贵，而且跨组织共享原始数据非常困难。联合学习旨在解决组织间数据隔离和数据知识安全共享的问题。联邦学习的概念是由谷歌的研究人员提出的。</p> \n<h4>PaddleFL概述</h4> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022300915\" src=\"http://localhost:8060/tup/2020/4/23/6167e9e5cd5246fe92ce264d70084bbf.jpg\" alt=\"PaddleFL概述\" title=\"PaddleFL概述\"></span></p> \n<p>在PaddleFL中，横向和纵向联邦学习策略将根据给出的分类来实现。PaddleFL也将提供在自然语言处理，计算机视觉和推荐算法等领域的应用示例。</p> \n<h4>联邦学习策略</h4> \n<ul> \n <li> <strong>纵向联邦学习</strong>: 带privc的逻辑回归，带第三方privc的神经网络[5]</li> \n <li> <strong>横向联邦学习</strong>: 联邦平均，差分隐私</li> \n</ul> \n<h4>训练策略</h4> \n<ul> \n <li><strong>多任务学习</strong></li> \n <li><strong>迁移学习</strong></li> \n <li><strong>主动学习</strong></li> \n</ul> \n<h4>PaddleFL框架设计</h4> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022300914\" src=\"http://localhost:8060/tup/2020/4/23/c895b3e3b56146bcb0869ebbd5aba33c.jpg\" alt=\"PaddleFL框架设计\" title=\"PaddleFL框架设计\"></span></p> \n<p>在PaddeFL中，用于定义联邦学习任务和联邦学习训练工作的组件如下：</p> \n<p><strong>编译时</strong></p> \n<ul> \n <li> <strong>FL-Strategy</strong>: 用户可以使用FL-Strategy定义联邦学习策略，例如Fed-Avg[1]。</li> \n <li> <strong>User-Defined-Program</strong>: PaddlePaddle的程序定义了机器学习模型结构和训练策略，如多任务学习。</li> \n <li> <strong>Distributed-Config</strong>: 在联邦学习中，系统会部署在分布式环境中。分布式训练配置定义分布式训练节点信息。</li> \n <li> <strong>FL-Job-Generator</strong>: 给定FL-Strategy, User-Defined Program 和 Distributed Training Config，联邦参数的Server端和Worker端的FL-Job将通过FL Job Generator生成。FL-Jobs 被发送到组织和联邦参数服务器以进行联合训练。</li> \n</ul> \n<p><strong>运行时</strong></p> \n<ul> \n <li> <strong>FL-Server</strong>: 在云或第三方集群中运行的联邦参数服务器。</li> \n <li> <strong>FL-Worker</strong>: 参与联合学习的每个组织都将有一个或多个与联合参数服务器通信的Worker。</li> \n <li> <strong>FL-Scheduler</strong>: 训练过程中起到调度Worker的作用，在每个更新周期前，决定哪些Worker可以参与训练。</li> \n</ul> \n<h4>安装指南和快速入门</h4> \n<p>请参考<a href=\"https://paddlefl.readthedocs.io/en/latest/instruction.html\" rel=\"nofollow noreferrer\">快速开始</a>。</p> \n<h4>Kubernetes简单部署</h4> \n<p>kubectl apply -f ./paddle_fl/examples/k8s_deployment/master.yaml</p> \n<p>请参考<a href=\"https://github.com/PaddlePaddle/PaddleFL/blob/master/paddle_fl/examples/k8s_deployment/README.md\" rel=\"nofollow noreferrer\">K8S部署实例</a></p> \n<p>也可以参考<a href=\"https://github.com/PaddlePaddle/PaddleFL/blob/master/paddle_fl/examples/k8s_deployment/deploy_instruction.md\" rel=\"nofollow noreferrer\">K8S集群申请及kubectl安装</a>配置自己的K8S集群</p> \n<h4>性能测试</h4> \n<p>Gru4Rec [9] 在基于会话的推荐中引入了递归神经网络模型。PaddlePaddle的GRU4RC实现代码在<a href=\"https://github.com/PaddlePaddle/models/tree/develop/PaddleRec/gru4rec\" rel=\"nofollow noreferrer\">https://github.com/PaddlePaddle/models/tree/develop/PaddleRec/gru4rec</a>. 一个基于联邦学习训练Gru4Rec模型的示例请参考<a href=\"https://paddlefl.readthedocs.io/en/latest/examples/gru4rec_examples.html\" rel=\"nofollow noreferrer\">Gru4Rec in Federated Learning</a></p> \n<p><strong>项目地址</strong>：<a href=\"https://github.com/PaddlePaddle/PaddleFL\" rel=\"nofollow noreferrer\">https://github.com/PaddlePadd...</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"http://localhost:8060/tup/2020/4/23/a5cd544b3efb47eab0121c02acfb80a7.jpg\" alt=\"SegmentFault思否微信公众号\" title=\"SegmentFault思否微信公众号\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/b1a67cfc80d34840b83c0476a12fb90b.jpg', '1c5851dc916d4e70a60f0c957f548876', '19eb3dd59ef8430d9f637d97449fc417', '674b70b62fa24c7ca9a671f8e54b8d15,115ec0efd61e4e22942b00b9fd1246b0,d114b152c3b644a6ab136104b4330b6f,406ef08e86cc4caa88239b8e0e4ea758,f3eb17e6e5664a97af3e9b1fca12b286', '0', '3', '1', '2020-04-23 10:59:07', '2020-04-23 10:59:07');
INSERT INTO `tb_recommend` VALUES ('195838acc2014a4fba41d246640381f3', '除了经典怀旧服，还有什么能重新激活《魔兽世界》', '在昨天早上 6：00 开服的那一刻，就涌入了大批前来追忆经典的游戏玩家，甚至在斗鱼等游戏直播平台，仅一个上午，就有近 3000 名魔兽世界的主播，同时直播。', '<blockquote>\n 自 2004 年公测的《魔兽世界》已经经历了 PC 时代、移动时代、VR 时代，在正在来临的 人工智能 时代，这款经典会如何续写。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYNT?w=650&amp;h=437\" src=\"http://localhost:8060/tup/2020/4/23/4245666294184253adb14c5d6411d1e2.jpg\" alt=\"图片描述\" title=\"图片描述\"></span><br>《魔兽世界》经典怀旧服在昨天开服了！</p> \n<p>在昨天早上 6：00 开服的那一刻，就涌入了大批前来追忆经典的游戏玩家，甚至在斗鱼等游戏直播平台，仅一个上午，就有近 3000 名魔兽世界的主播，同时直播。</p> \n<p>《魔兽世界》是否有机会借助当下人工智能之势，找出自己与人工智能结合的道路？</p> \n<h1>永不磨灭的经典：为了部落</h1> \n<p>其实，早在今天的凌晨 5 点 55 分时，客户端显示的排队人数就已经高达了 1 万 8 千人。</p> \n<p>更有些热门服务器，比如「范克里夫」服务器的排队人数高达 2 万 6 千人，也就是需要等待 5 个多小时才有机会进入游戏。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYN2?w=815&amp;h=476\" src=\"http://localhost:8060/tup/2020/4/23/c79d9fa83b0042bcbda536709a1e4fc1.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<blockquote>\n <em>6：00 开服后就十分火爆</em>\n</blockquote> \n<p>《魔兽世界》在 2005 年进入国内之后，一度是网络游戏领域的霸主，在 2008 年年底，在发布了《巫妖王之怒》资料片后不久，暴雪宣布全球用户数量达到 1150 万人。</p> \n<h1>没落的黄金一代</h1> \n<p>在最巅峰的 2011 年，《魔兽世界》全球用户数曾触达 1200 万。此后的几年里，用户数就再难以为继，持续滑落至 900 多万。</p> \n<p>2012 年，在《熊猫人之谜》资料片之后，游戏用户数重回 1000 万大关。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYOh?w=2352&amp;h=804\" src=\"http://localhost:8060/tup/2020/4/23/600df5e62fcd4f70ad6cc8d3e1c7ebb4.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<blockquote>\n <em>2015 年第三季度之后，暴雪就再没有公布过《魔兽世界》具体的玩家数量</em>\n</blockquote> \n<p>但此后的几个新的资料片《德拉诺之王》、《军团再临》和《争霸艾泽拉斯》并没能挽回暴雪的颓势。</p> \n<p>《魔兽世界》这些年的辉煌和近年的衰落有目共睹。这一类 MMORPG（大型多人在线）游戏在近几年的发展中，逐渐失去竞争力。</p> \n<p>在全球的游戏市场中，《魔兽世界》前有 DOTA 、LOL 这些经典 MOBA（多人在线战术竞技）游戏的竞争，后有 《绝地求生》、《APEX 英雄》这类生存射击游戏的追赶，更别提移动端游戏 《王者荣耀》、《和平精英》在 90、00 后人群里的绝对优势了。</p> \n<h1>魔兽世界：能靠 AI 创造更好的体验么？</h1> \n<p>其实在《魔兽世界》里，就已经增加入了基于人工智能技术的 NPC。</p> \n<p>一个叫做莫克西·开锁的 NPC 会流窜于联盟的各个主城，去银行偷窃。有玩家曾在伯拉勒斯港银行遇到了这个 NPC。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYO1?w=640&amp;h=377\" src=\"http://localhost:8060/tup/2020/4/23/09c5367e3c7c4b84b21591bec42eb54c.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<blockquote>\n <em>这个 NPC 会根据环境的情况，选择是否偷窃，还会与周围的玩家进行对话</em>\n</blockquote> \n<p>不仅如此，《魔兽世界》的岛屿探险模式里，还加入的敌对 NPC 。</p> \n<p>这些敌人 NPC 会模仿人类玩家的操作风格：比如 NPC 可以通过玩家行为来判断玩家的目的，从而进行下一步策略：是盗取玩家的背包里的资源，还是打断玩家的治疗进程。</p> \n<h2>游戏环境：是 AI 整体发展的加速器</h2> \n<p>游戏，是完美的 AI 测试平台。游戏有方便处理的数据，固定的规则，多种可假设的策略，游戏也就是模拟场景，它对于人工智能的研发来说是一个非常理想的场所。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYRD?w=1920&amp;h=1080\" src=\"http://localhost:8060/tup/2020/4/23/046d028e0c864ff9b6bc9d1976360d45.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<blockquote>\n <em>星际这类 RTS 游戏：背后有着复杂的策略和数据</em>\n</blockquote> \n<p>纽约大学游戏研究中心副教授 Julian Togelius 说，「我们还没有看到很多东西是通过游戏训练，然后再转移到现实世界的。但我们已经看到，为玩游戏而发明的方法，转移到了现实世界。」</p> \n<h2>游戏 AI ：是人类玩家最好的老师和对手</h2> \n<p>一方面，AI 可以帮助发现一些更完美的策略，提高人类玩家竞技技能。柯洁就认为和 AlphaGo 的对战，打开了思路，提高了围棋水平；</p> \n<p>另一方面， AI 的介入，可以为玩家打造更适配的对手，经过调整的 AI，不仅能够成为人类玩家的教练，适配不同玩家的水平与之对战。</p> \n<p>还能够避免如今游戏里的人类玩家动辄相互发飙，如果有一个佛系 AI 在你的对面，一定能维持一个更加文明的游戏环境。</p> \n<p>希望《魔兽世界》能够多多跟上时代的步伐，抓住技术的潮流，创造更好的游戏体验和玩家互动环境，让年轻人也有意愿去体验 80、90 后的共同记忆。</p> \n<p>为了游戏玩家，为了共同的青春记忆，也为了艾泽拉斯。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYQG?w=290&amp;h=160\" src=\"http://localhost:8060/tup/2020/4/23/e2420dcc246b4fac889216c2b0bb3e24.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/b6c86a4aa8ee43b3b94907ed1b364fd6.jpg', '692c6787030d4b8882077b2ab9279c52', '1a7cc9fbc4654cb0afec84e080816ef1', '2a09bf1afefd4d659606f43445741ee3,a4f4fd7a73b84a7298db0174165eeaac,14b1d605b9c340139163c4f22f384a7f', '0', '3', '1', '2020-04-23 10:58:19', '2020-04-23 10:58:19');
INSERT INTO `tb_recommend` VALUES ('199a3dc2f82b41e4a224f575f3ff0674', 'Nodejs - Win环境下在js文件中编辑代码， 使得运行npm run dev', '# 最终结果 配合VSCode插件 Code Runner 食用更加美味 {代码...} # 其他借鉴 {代码...} # 参考资料 批处理 - 做一个一键启动指定程序的.bat Nodejs里运行npm run dev shell脚本无效果？ Nodejs child_process（子...', '<h4># 最终结果</h4> \n<blockquote>\n 配合VSCode插件 \n <code>Code Runner</code> 食用更加美味\n</blockquote> \n<pre><code>var exec = require(\'child_process\').execSync;\nexec(\'npm run dev\', {stdio: \'inherit\'});</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF93M\" src=\"http://localhost:8060/tup/2020/4/23/5772a8a5c04d453589588b8dcf50bcd5.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<h4># 其他借鉴</h4> \n<pre><code>var exec = require(\'child_process\').execSync\nfunction execute(cmd) {\n    exec(cmd, function(error, stdout, stderr) {\n        if (error) {\n            console.error(error, stderr)\n        } else {\n            console.log(\'success\', stdout)\n        }\n    })\n}\nexecute(\'npm run dev\')</code></pre> \n<hr> \n<h4># 参考资料</h4> \n<ul> \n <li><a href=\"https://gitee.com/PLQin/FE_ISSUE/issues/IOJR5\" rel=\"nofollow noreferrer\">批处理 - 做一个一键启动指定程序的.bat</a></li> \n <li><a href=\"https://segmentfault.com/q/1010000015718827\">Nodejs里运行npm run dev shell脚本无效果？</a></li> \n <li><a href=\"http://nodejs.cn/api/child_process.html#child_process_child_process\" rel=\"nofollow noreferrer\">Nodejs child_process（子进程）</a></li> \n</ul>', null, 'http://localhost:8060/tup/2020/4/23/1ea612c50f1644c5aed8599f0f940818.jpg', '692c6787030d4b8882077b2ab9279c52', '2a353971222c4aff8e8d3e9c370330cd', 'd79254c4ca5e45dca9d484307c935281,d16a93d83052441a90afaa57d69fdc3c,f4fda25145b9451a9b0d77d6a2a63712,9332af7a7ee745509ad0cbcf13ea30e0,01129607ea6c4b16ad77a7998d8d7e74', '0', '3', '1', '2020-04-23 11:00:44', '2020-04-23 11:00:44');
INSERT INTO `tb_recommend` VALUES ('1a2949262a6443b2b14533e2a391caa1', '【思否编程公开课】游戏制作人招募（兼职），Reworld教你简单开发好玩的游戏', 'Reworld 物理引擎是一款极具创造性的 3D 游戏创作工具，游戏类型不受限制；具有天然物理属性，将现实中的力和约束拟真到游戏中；其内置商店有免费美术、特效、音频、模型等海量素材，在创作中按需拖拽即可；这些...', '<p><em>思否编程 联合<strong>代码乾坤</strong>，邀请<strong>原卓越游戏副总裁，重启世界联合创始人 董钰鹏（飞月）</strong>为大家带来了技术公开课。<strong>大咖坐镇，限时免费！</strong></em></p> \n<hr> \n<h5>直播主题：</h5> \n<p>游戏制作人招募（兼职），Reworld 教你简单开发好玩的游戏</p> \n<h5>内容介绍：</h5> \n<p>如果你会编程，热爱游戏，有创作游戏的想法，现在只需要一台电脑和创意即可轻松做出好玩的游戏。</p> \n<p>Reworld 物理引擎是一款极具创造性的 3D 游戏创作工具，游戏类型不受限制；具有天然物理属性，将现实中的力和约束拟真到游戏中；其内置商店有免费美术、特效、音频、模型等海量素材，在创作中按需拖拽即可；这些功能旨在能够很大程度降低游戏开发难度，提升效率，使游戏创作更简单有趣。使用 Reworld 物理引擎创作的游戏，上传到游戏平台后可以在 PC、安卓、iOS 平台完美运行。</p> \n<p>本次直播中除了 Reworld 物理引擎功能介绍，还将现场展示开发出一款好玩的游戏，观看直播的开发者也可以参与进来，感受创作游戏的乐趣。</p> \n<p><strong>直播主要内容：</strong></p> \n<ul> \n <li>游戏及游戏行业的概述</li> \n <li>游戏开发的乐趣：简单的游戏机制</li> \n <li>Reworld游戏制作人招募</li> \n</ul> \n<h5>直播时间：</h5> \n<p>2020 年 3 月 13 日（周五）晚上 8：00</p> \n<h5>讲师介绍：</h5> \n<p><strong>董钰鹏（飞月）</strong>，原卓越游戏副总裁，重启世界联合创始人，先后负责游戏项目包括《成吉思汗》、《画皮》、《我叫MT》、《我叫MT3》的运营工作，专注于游戏行业从业15年，拥有丰富的游戏开发经验和游戏项目的运营经验，同时也是一位热爱游戏的知识分享者。</p> \n<h5>直播地址：扫码入群看直播</h5> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEmgF\" src=\"http://localhost:8060/tup/2020/4/23/9d73fad638884ad38dce688f7ae3d922.jpg\" alt=\"海报(4).png\" title=\"海报(4).png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/b41c2438d10d42098f025ddc72269a96.jpg', '1c5851dc916d4e70a60f0c957f548876', '1a7cc9fbc4654cb0afec84e080816ef1', '9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-23 10:57:14', '2020-04-23 10:57:14');
INSERT INTO `tb_recommend` VALUES ('1a6efe46fd7c47a99a59aaddf76d89cd', 'Android | 教你如何开发扫二维码功能', '最近要做一个停车场扫码收费的app，在网上搜了一圈，首先接触到了ZXing，上手试了下，集成过程不复杂，但是感觉效果欠佳，比如距离稍微远点儿就扫不出来了，另外角度对的不好，反光或者光线比较暗的时候，成功率...', '<h1>前言</h1> \n<p>  最近要做一个停车场扫码收费的app，在网上搜了一圈，首先接触到了ZXing，上手试了下，集成过程不复杂，但是感觉效果欠佳，比如距离稍微远点儿就扫不出来了，另外角度对的不好，反光或者光线比较暗的时候，成功率也比较低，集成好给我们老大看了下，感觉不是很满意。最近偶尔看到了华为一个发布会里面有介绍扫码功能，稍微研究了下，居然是一款免费扫码神器，官方称之为Scan Kit，号称还同时支持Android和iOS，半信半疑上手搞了一把发现效果还真不错！测了下发现对于一些有反光，污损，形变，超远距离的场景都能很好地识别！<br>  今天简单总结了下，分享给大家，码字不易，也算是疫情期间，给大家的一点小小福利。</p> \n<hr> \n<h1>官网的Demo和Sample代码体验</h1> \n<p>  官网有Demo可以直接下下来体验，还有sample代码样例，小伙伴们可以直接到官网下载Demo或者示例代码体验下：<a href=\"https://developer.huawei.com/consumer/cn/doc/development/HMS-Examples/scan-sample-code4\" rel=\"nofollow noreferrer\">华为官网的Demo和示例代码</a>，示例代码下下来就可以运行。<br>我自己也结合下面的讲解写了个简易的sample，各位看官也可以下下来参考。<br>  <a href=\"https://download.csdn.net/download/winisit86/12243327\" rel=\"nofollow noreferrer\">简易扫码sample示例</a></p> \n<hr> \n<h2>1 开发准备</h2> \n<h3>1.1 android studio 安装</h3> \n<p>  这里就不啰嗦了，到官网下载和安装：<a href=\"https://developer.android.com/studio\" rel=\"nofollow noreferrer\">Android studio官网下载链接</a>，<a href=\"https://www.cnblogs.com/xiadewang/p/7820377.html\" rel=\"nofollow noreferrer\">Android studio安装流程参考链接</a></p> \n<h3>1.2 在项目级gradle里添加华为maven仓</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022352728\" src=\"http://localhost:8060/tup/2020/4/23/e1263ee913ed4172b3ead312ac880804.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>  增量添加如下maven地址：</p> \n<pre><code class=\"java\">buildscript {\n    repositories {        \n        maven {url \'http://developer.huawei.com/repo/\'}\n    }    \n}\nallprojects {\n    repositories {       \n        maven { url \'http://developer.huawei.com/repo/\'}\n    }\n}</code></pre> \n<h3>1.3 在应用级的build.gradle里面加上SDK依赖</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022352727\" src=\"http://localhost:8060/tup/2020/4/23/e836d1a6a309445bad82552831521938.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>  增量添加SDK依赖，SDK他们有两种版本，plus和普通版，plus效果好点儿但是包稍微大一点儿，这个地方我选了plus版本,小伙伴们可以根据自己需要自行选择,版本号填他们最新的版本就好。</p> \n<pre><code class=\"java\">dependencies{ \n  implementation \'com.huawei.hms:scanplus:1.1.1.301\' \n }</code></pre> \n<h3>1.4 加一下混淆配置</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022352729\" src=\"http://localhost:8060/tup/2020/4/23/487a57c6a28340d0ae3efabd069cb3e4.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>  复制粘贴华为官网上给的混淆代码就可以了</p> \n<pre><code class=\"java\">-ignorewarnings \n-keepattributes *Annotation*  \n-keepattributes Exceptions  \n-keepattributes InnerClasses  \n-keepattributes Signature  \n-keepattributes SourceFile,LineNumberTable  \n-keep class com.hianalytics.android.**{*;}  \n-keep class com.huawei.**{*;}</code></pre> \n<h3>1.5 Manifest申请静态权限和扫码页面声明：</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022352730\" src=\"http://localhost:8060/tup/2020/4/23/6f7ac968d10b42108b4f058f6e10bada.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>  申请静态权限和使用特性</p> \n<pre><code class=\"java\">&lt;!--相机权限--&gt; \n&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt; \n&lt;!--读文件权限--&gt; \n&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt; \n&lt;!--使用特性--&gt; \n&lt;uses-feature android:name=\"android.hardware.camera\" /&gt; \n&lt;uses-feature android:name=\"android.hardware.camera.autofocus\" /&gt;</code></pre> \n<p>  在application标签内添加对扫码页面的声明</p> \n<pre><code class=\"java\">&lt;!—对扫码页面进行声明--&gt; \n&lt;activity android:name=\"com.huawei.hms.hmsscankit.ScanKitActivity\" /&gt;</code></pre> \n<h2>2 代码开发</h2> \n<h3>2.1 动态申请权限</h3> \n<p>  在启动扫码Activity的地方添加动态权限申请。</p> \n<pre><code class=\"java\">public void loadScanKitBtnClick(View view) {\n    requestPermission(CAMERA_REQ_CODE, DECODE);\n}\n\nprivate void requestPermission(int requestCode, int mode) {\n    ActivityCompat.requestPermissions(\n            this,\n            new String[]{Manifest.permission.CAMERA, Manifest.permission.READ_EXTERNAL_STORAGE},\n            requestCode);\n}</code></pre> \n<h3>2.2 在权限申请回调中启动扫码界面</h3> \n<p>  扫码格式通过setHmsScanTypes指定为QR码，小伙伴们如果需要支持其它码可以自己指定。</p> \n<pre><code class=\"java\">@Override\npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n    if (permissions == null || grantResults == null) {\n        return;\n    }\n    if (grantResults.length &lt; 2 || grantResults[0] != PackageManager.PERMISSION_GRANTED || grantResults[1] != PackageManager.PERMISSION_GRANTED) {\n        return;\n    }\n    if (requestCode == CAMERA_REQ_CODE) {\n        ScanUtil.startScan(this, REQUEST_CODE_SCAN_ONE, new HmsScanAnalyzerOptions.Creator().setHmsScanTypes(HmsScan.QRCODE_SCAN_TYPE).create());\n    }\n}</code></pre> \n<h3>2.3 在activity回调里面获取码结果</h3> \n<pre><code class=\"java\">@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n   super.onActivityResult(requestCode, resultCode, data);\n   if (resultCode != RESULT_OK || data == null) {\n       return;\n   }\n   if (requestCode == REQUEST_CODE_SCAN_ONE) {\n       HmsScan obj = data.getParcelableExtra(ScanUtil.RESULT);\n       if (obj != null) {\n           this.textView.setText(obj.originalValue);\n       }\n   }\n}</code></pre> \n<hr> \n<h1>结后语</h1> \n<p>  整个代码开发过程就结束了，是不是超简单，给大家看下效果：<br>效果非常赞，支持自动缩放，两米开外瞬间就识别成功了！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022352731\" src=\"http://localhost:8060/tup/2020/4/23/a9327f6399de49769a0f87352e9650f6.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>附官方开发指南<br><a href=\"https://developer.huawei.com/consumer/cn/doc/development/HMS-Guides/scan-introduction-4\" rel=\"nofollow noreferrer\">华为扫码服务员官方指南</a></p> \n<hr> \n<p>往期链接：Android | 教你如何用代码一键实现银行卡绑定</p> \n<p>内容来源：<a href=\"https://developer.huawei.com/consumer/cn/forum/topicview?tid=0201217390745110144&amp;fid=18\" rel=\"nofollow noreferrer\">https://developer.huawei.com/consumer/cn/forum/topicview?tid=0201217390745110144&amp;fid=18</a></p> \n<p>原文来源：<a href=\"https://blog.csdn.net/winisit86/article/details/104807678\" rel=\"nofollow noreferrer\">https://blog.csdn.net/winisit...</a></p> \n<p>原作者：winisit86</p>', null, 'http://localhost:8060/tup/2020/4/23/615e1732f1dd4d929ada6149492f780c.jpg', '3f69fcc9b13843d1910b3dac597f5215', '819ad72c1efe450f9d7affc135a4b457', '8dfc62f227ae4076888ea4872e03cddd,2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-23 10:35:04', '2020-04-23 10:35:04');
INSERT INTO `tb_recommend` VALUES ('1ab2c486b2e64533979715bf80cf1c80', '5分钟带你快速了解Zookeeper工作原理', '学习者（learner），包括跟随者（follower）和观察者（observer），follower用于接受客户端请求并想客户端返回结果，在选主过程中参与投票Observer可以接受客户端连接，将写请求转发给leader，但observer不参加投...', '<p><strong>1、Zookeeper的角色</strong></p> \n<ul> \n <li>领导者（leader），负责进行投票的发起和决议，更新系统状态。</li> \n <li>学习者（learner），包括跟随者（follower）和观察者（observer），follower用于接受客户端请求并想客户端返回结果，在选主过程中参与投票Observer可以接受客户端连接，将写请求转发给leader，但observer不参加投票过程，只同步leader的状态，observer的目的是为了扩展系统，提高读取速度。</li> \n <li>&nbsp;客户端（client），请求发起方。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431519\" src=\"http://localhost:8060/tup/2020/4/23/39e4d66319ab4a1bb9ef63cdedf4e863.jpg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431523\" src=\"http://localhost:8060/tup/2020/4/23/71dbf486675f41fc8acb2f2e265d6dfa.jpg\" alt=\"\" title=\"\"></span></p> \n<p>• Zookeeper的核心是原子广播，这个机制保证了各个Server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式（选主）和广播模式（同步）。当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数Server完成了和leader的状态同步以后，恢复模式就结束了。状态同步保证了leader和Server具有相同的系统状态。</p> \n<p>• 为了保证事务的顺序一致性，zookeeper采用了递增的事务id号（zxid）来标识事务。所有的提议（proposal）都在被提出的时候加上了zxid。实现中zxid是一个64位的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch，标识当前属于那个leader的统治时期。低32位用于递增计数。</p> \n<p>• 每个Server在工作过程中有三种状态：</p> \n<p>LOOKING：当前Server不知道leader是谁，正在搜寻。</p> \n<p>LEADING：当前Server即为选举出来的leader。</p> \n<p>FOLLOWING：leader已经选举出来，当前Server与之同步。</p> \n<p>其他文档：<a href=\"http://www.cnblogs.com/lpshou/archive/2013/06/14/3136738.html\" rel=\"nofollow noreferrer\">http://www.cnblogs.com/lpshou...</a></p> \n<p><strong>2、Zookeeper 的读写机制</strong></p> \n<ul> \n <li>Zookeeper是一个由多个server组成的集群</li> \n <li>&nbsp;一个leader，多个follower</li> \n <li>每个server保存一份数据副本</li> \n <li>全局数据一致</li> \n <li>分布式读写</li> \n <li>更新请求转发，由leader实施</li> \n</ul> \n<p><strong>3、Zookeeper 的保证　</strong></p> \n<ul> \n <li>更新请求顺序进行，来自同一个client的更新请求按其发送顺序依次执行。</li> \n <li>&nbsp;数据更新原子性，一次数据更新要么成功，要么失败。</li> \n <li>全局唯一数据视图，client无论连接到哪个server，数据视图都是一致的。</li> \n <li>&nbsp;实时性，在一定事件范围内，client能读到最新数据。</li> \n</ul> \n<p><strong>4、Zookeeper节点数据操作流程</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431521\" src=\"http://localhost:8060/tup/2020/4/23/ae8108697267481d90a07d01392323d2.jpg\" alt=\"\" title=\"\"></span></p> \n<p>注：1.在Client向Follwer发出一个写的请求</p> \n<p>2.Follwer把请求发送给Leader</p> \n<p>3.Leader接收到以后开始发起投票并通知Follwer进行投票</p> \n<p>4.Follwer把投票结果发送给Leader</p> \n<p>5.Leader将结果汇总后如果需要写入，则开始写入同时把写入操作通知给Leader，然后commit;</p> \n<p>6.Follwer把请求结果返回给Client</p> \n<p>• Follower主要有四个功能：</p> \n<p>• 1. 向Leader发送请求（PING消息、REQUEST消息、ACK消息、REVALIDATE消息）；</p> \n<p>• 2 .接收Leader消息并进行处理；</p> \n<p>• 3 .接收Client的请求，如果为写请求，发送给Leader进行投票；</p> \n<p>• 4 .返回Client结果。</p> \n<p>• Follower的消息循环处理如下几种来自Leader的消息：</p> \n<p>• 1 .PING消息： 心跳消息；</p> \n<p>• 2 .PROPOSAL消息：Leader发起的提案，要求Follower投票；</p> \n<p>• 3 .COMMIT消息：服务器端最新一次提案的信息；</p> \n<p>• 4 .UPTODATE消息：表明同步完成；</p> \n<p>• 5 .REVALIDATE消息：根据Leader的REVALIDATE结果，关闭待revalidate的session还是允许其接受消息；</p> \n<p>• 6 .SYNC消息：返回SYNC结果到客户端，这个消息最初由客户端发起，用来强制得到最新的更新。</p> \n<p><strong>5、Zookeeper leader 选举　</strong></p> \n<p>• 半数通过</p> \n<p>– 3台机器 挂一台 2&gt;3/2</p> \n<p>– 4台机器 挂2台 2！&gt;4/2</p> \n<p>• A提案说，我要选自己，B你同意吗？C你同意吗？B说，我同意选A；C说，我同意选A。(注意，这里超过半数了，其实在现实世界选举已经成功了。但是计算机世界是很严格，另外要理解算法，要继续模拟下去。)</p> \n<p>• 接着B提案说，我要选自己，A你同意吗；A说，我已经超半数同意当选，你的提案无效；C说，A已经超半数同意当选，B提案无效。</p> \n<p>• 接着C提案说，我要选自己，A你同意吗；A说，我已经超半数同意当选，你的提案无效；B说，A已经超半数同意当选，C的提案无效。</p> \n<p>• 选举已经产生了Leader，后面的都是follower，只能服从Leader的命令。而且这里还有个小细节，就是其实谁先启动谁当头。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431520\" src=\"http://localhost:8060/tup/2020/4/23/4f1a562a30d745c98d4e9bbe0ce0c9e3.jpg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431522\" src=\"http://localhost:8060/tup/2020/4/23/824b10d8e24b4f5bb9126805dc314472.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>6、zxid</strong></p> \n<p>• znode节点的状态信息中包含czxid, 那么什么是zxid呢?</p> \n<p>• ZooKeeper状态的每一次改变, 都对应着一个递增的Transaction id, 该id称为zxid. 由于zxid的递增性质, 如果zxid1小于zxid2, 那么zxid1肯定先于zxid2发生.</p> \n<p>创建任意节点, 或者更新任意节点的数据, 或者删除任意节点, 都会导致Zookeeper状态发生改变, 从而导致zxid的值增加.</p> \n<p><strong>7、Zookeeper工作原理</strong></p> \n<ul> \n <li>Zookeeper的核心是原子广播，这个机制保证了各个server之间的同步。实现这个机制的协议叫做Zab协议。Zab协议有两种模式，它们分别是恢复模式和广播模式。</li> \n <li>当服务启动或者在领导者崩溃后，Zab就进入了恢复模式，当领导者被选举出来，且大多数server的完成了和leader的状态同步以后，恢复模式就结束了。</li> \n <li>状态同步保证了leader和server具有相同的系统状态，一旦leader已经和多数的follower进行了状态同步后，他就可以开始广播消息了，即进入广播状态。这时候当一个server加入zookeeper服务中，它会在恢复模式下启动，</li> \n <li>发现leader，并和leader进行状态同步。待到同步结束，它也参与消息广播。Zookeeper服务一直维持在Broadcast状态，直到leader崩溃了或者leader失去了大部分的followers支持。</li> \n <li>广播模式需要保证proposal被按顺序处理，因此zk采用了递增的事务id号(zxid)来保证。所有的提议(proposal)都在被提出的时候加上zxid。</li> \n <li>实现中zxid是一个64为的数字，它高32位是epoch用来标识leader关系是否改变，每次一个leader被选出来，它都会有一个新的epoch。低32位是个递增计数。</li> \n <li>当leader崩溃或者leader失去大多数的follower，这时候zk进入恢复模式，恢复模式需要重新选举出一个新的leader，让所有的server都恢复到一个正确的状态。</li> \n <li>每个Server启动以后都询问其它的Server它要投票给谁。</li> \n <li>对于其他server的询问，server每次根据自己的状态都回复自己推荐的leader的id和上一次处理事务的zxid（系统启动时每个server都会推荐自己）</li> \n <li>收到所有Server回复以后，就计算出zxid最大的哪个Server，并将这个Server相关信息设置成下一次要投票的Server。</li> \n <li>计算这过程中获得票数最多的的sever为获胜者，如果获胜者的票数超过半数，则改server被选为leader。否则，继续这个过程，直到leader被选举出来。</li> \n <li>&nbsp;leader就会开始等待server连接。</li> \n <li>Follower连接leader，将最大的zxid发送给leader。</li> \n <li>&nbsp;Leader根据follower的zxid确定同步点。</li> \n <li>&nbsp;完成同步后通知follower 已经成为uptodate状态。</li> \n <li>Follower收到uptodate消息后，又可以重新接受client的请求进行服务了。</li> \n</ul> \n<p><strong>8、数据一致性与paxos 算法</strong></p> \n<p>• 据说Paxos算法的难理解与算法的知名度一样令人敬仰，所以我们先看如何保持数据的一致性，这里有个原则就是：</p> \n<p>• 在一个分布式数据库系统中，如果各节点的初始状态一致，每个节点都执行相同的操作序列，那么他们最后能得到一个一致的状态。</p> \n<p>• Paxos算法解决的什么问题呢，解决的就是保证每个节点执行相同的操作序列。好吧，这还不简单，master维护一个全局写队列，所有写操作都必须 放入这个队列编号，那么无论我们写多少个节点，只要写操作是按编号来的，就能保证一致性。没错，就是这样，可是如果master挂了呢。</p> \n<p>• Paxos算法通过投票来对写操作进行全局编号，同一时刻，只有一个写操作被批准，同时并发的写操作要去争取选票，只有获得过半数选票的写操作才会被 批准（所以永远只会有一个写操作得到批准），其他的写操作竞争失败只好再发起一轮投票，就这样，在日复一日年复一年的投票中，所有写操作都被严格编号排 序。编号严格递增，当一个节点接受了一个编号为100的写操作，之后又接受到编号为99的写操作（因为网络延迟等很多不可预见原因），它马上能意识到自己 数据不一致了，自动停止对外服务并重启同步过程。任何一个节点挂掉都不会影响整个集群的数据一致性（总2n+1台，除非挂掉大于n台）。</p> \n<p><strong>总结</strong></p> \n<p>&nbsp;Zookeeper 作为 Hadoop 项目中的一个子项目，是 Hadoop 集群管理的一个必不可少的模块，它主要用来控制集群中的数据，如它管理 Hadoop 集群中的 NameNode，还有 Hbase 中 Master Election、Server 之间状态同步等。</p> \n<p>关于Paxos算法可以查看文章 Zookeeper全解析——Paxos作为灵魂</p> \n<p><strong>9、Observer　</strong></p> \n<p>• Zookeeper需保证高可用和强一致性；</p> \n<p>• 为了支持更多的客户端，需要增加更多Server；</p> \n<p>• Server增多，投票阶段延迟增大，影响性能；</p> \n<p>• 权衡伸缩性和高吞吐率，引入Observer</p> \n<p>• Observer不参与投票；</p> \n<p>• Observers接受客户端的连接，并将写请求转发给leader节点；</p> \n<p>• 加入更多Observer节点，提高伸缩性，同时不影响吞吐率</p> \n<p><strong>10、 为什么zookeeper集群的数目，一般为奇数个？</strong></p> \n<p>•Leader选举算法采用了Paxos协议；</p> \n<p>•Paxos核心思想：当多数Server写成功，则任务数据写成功如果有3个Server，则两个写成功即可；如果有4或5个Server，则三个写成功即可。</p> \n<p>•Server数目一般为奇数（3、5、7）如果有3个Server，则最多允许1个Server挂掉；如果有4个Server，则同样最多允许1个Server挂掉由此，</p> \n<p>我们看出3台服务器和4台服务器的的容灾能力是一样的，所以为了节省服务器资源，一般我们采用奇数个数，作为服务器部署个数。</p> \n<p><strong>11、Zookeeper 的数据模型　</strong></p> \n<ul> \n <li>层次化的目录结构，命名符合常规文件系统规范。</li> \n <li>每个节点在zookeeper中叫做znode,并且其有一个唯一的路径标识。</li> \n <li>节点Znode可以包含数据和子节点，但是EPHEMERAL类型的节点不能有子节点。</li> \n <li>Znode中的数据可以有多个版本，比如某一个路径下存有多个数据版本，那么查询这个路径下的数据就需要带上版本。</li> \n <li>客户端应用可以在节点上设置监视器。</li> \n <li>节点不支持部分读写，而是一次性完整读写。</li> \n</ul> \n<p><strong>12、Zookeeper 的节点</strong></p> \n<ul> \n <li>Znode有两种类型，短暂的（ephemeral）和持久的（persistent）</li> \n <li>Znode的类型在创建时确定并且之后不能再修改</li> \n <li>短暂znode的客户端会话结束时，zookeeper会将该短暂znode删除，短暂znode不可以有子节点</li> \n <li>持久znode不依赖于客户端会话，只有当客户端明确要删除该持久znode时才会被删除</li> \n <li>Znode有四种形式的目录节点</li> \n <li>PERSISTENT（持久的）</li> \n <li>EPHEMERAL(暂时的)</li> \n <li>PERSISTENT_SEQUENTIAL（持久化顺序编号目录节点）</li> \n <li>EPHEMERAL_SEQUENTIAL（暂时化顺序编号目录节点）</li> \n</ul>', null, 'http://localhost:8060/tup/2020/4/23/61147168641c4933a78371e1d8f41e44.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', 'bb0b7e69ad3e46fcb121baefda8f1f78', '55723db96b9f4593bae02bc1e49f1e87,d7416e100af54eb7a4d9274b9a462240,81a4561c1c294e0cae32c9fe6b5dc397,77a7bd638e0a45ec84569ef6b79325c1,590ea80c67eb433789c1387096d3fc76', '0', '3', '1', '2020-04-23 10:28:28', '2020-04-23 10:28:28');
INSERT INTO `tb_recommend` VALUES ('1fcb5bffadff41a0b76a965d792691c1', 'TiKV Committer 庄天翼：只要能提升 Codebase 质量，就值得提交 PR', '2020 年 2 月，TiKV 项目迎来了一位新晋 Committer —— 庄天翼（GitHub ID：TennyZhuang），他 2018 年毕业于清华大学，目前在旷视科技担任分布式存储开发工程师，平时爱看动漫，工作之余也喜欢写一些代码，实现自...', '<p>2020 年 2 月，TiKV 项目迎来了一位新晋 Committer —— 庄天翼（GitHub ID：TennyZhuang），他 2018 年毕业于清华大学，目前在旷视科技担任分布式存储开发工程师，平时爱看动漫，工作之余也喜欢写一些代码，实现自己的想法。前天，我们“正儿八经”地采访了庄天翼同学，在互相努力憋笑中，愉快地掉落了以下文字……</p> \n<h2>传说中的“天才少年”</h2> \n<p>天翼并不是普通意义上的计算机“天才少年”。</p> \n<p>虽然他在大四时和队友一起拿了 CCPC（中国大学生程序设计竞赛）区域赛金牌，但他第一次接触编程已经是高中了，当时并没有深入研究编程，只是觉得学起来挺喜欢。在拿到化学竞赛金牌并保送清华后他也没有选择计算机专业，而是在材料学院就读，直到大三才正式转专业到了软件学院。</p> \n<p>为了顺利转系到软件学院，他利用课余时间修了大一和大二的计算机课程。得力于之前给学院老师留下的深刻印象，大三一开学他就成为软件学院的助教，协助老师设计课程并分享自己做这门课程的心得。</p> \n<p><strong>天翼说突破舒适区，学习新的东西是一件很有成就感的事。</strong></p> \n<p>“大三时学院有一门 Haskell 课程，当时作业分级，我完成了最高难度的题并且做了拓展，写了一个比较完整的 scheme 解释器，这门课拿了满分。虽然现在看来没那么厉害，但当时觉得很有成就感。”</p> \n<h2>理解“开源社区”</h2> \n<h3>与开源结缘</h3> \n<p>当被问到第一次是怎么接触到开源时，天翼笑了笑说“这要定义一下开源了，一开始是学习 Git 的使用，因为本科提交作业需要版本管理，接触了 Git。当时就想要不把代码公开上传 GitHub 吧，电脑万一坏了作业也不会丢。等我到高年级时有些自己的小项目被学弟发现竟然还有些 star，这可能算是我第一个开源项目吧。后来也陆续给一些其他小的开源项目做贡献，主要是自己平时会用到。”</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022074911\" src=\"http://localhost:8060/tup/2020/4/23/2b2d5973f1204c06854a824d7cd3368e.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>对“社区贡献”的理解</h3> \n<p>天翼对社区的理解和我们不谋而合：<strong>只要对 Codebase 的质量有提升，就值得去提交 PR</strong>。</p> \n<p>“我之前给 Golang 提交过一个很小的 PR。当时我在调试 TiDB 的一个性能 regression 问题，感觉 Go 编译器在判断一个函数是否可以 inline 的调试日志里缺失了 cost 信息，于是我手动编译了 Go，在 debug 日志中添加了自己需要的信息来解决了我当时遇到的问题。很多人到这一步可能就结束了，但我还是将这行调试 log 作为一个 patch 提交给了 Golang。这个 PR 可能很小，但如果下一个 Go 开发者遇到了跟我相似的问题，也需要这行信息，他就可以省去自己完整编译一遍 Go 的时间，我觉得这就值得去提交一个 PR。我认为一个 PR 只要能提升 Codebase 的质量，就是对开源社区的贡献。”</p> \n<h2>TiDB 社区印象</h2> \n<p>谈到对 TiDB 社区的整体印象，天翼说道，“<strong>TiDB 社区建设是我见过开源项目中最好的。对任务的定义很明确并且每个组件都有明确的负责人。TiDB 社区对新人更友好，比如 issue 会标注难度，组建划分的很清楚，可以方便的找到适合自己的任务</strong>。另外源码阅读系列比较有意义，我一般不看源码的实现细节，但源码阅读指南会让我更理解组件之间调用关系。”</p> \n<h3>参与社区</h3> \n<p>天翼是分布式存储工程师，对存储和数据库相关的项目比较感兴趣，因此 TiDB 是他参与的第一个比较正式的开源项目。当时 TiDB 还有若干篇教你“如何十分钟成为 Contributor” 的指南，于是就来试了一下。</p> \n<p>在工作中天翼用 Go 比较多，大概是三四年前他就有接触过 Rust 了，当时就觉得这个语言设计得非常优美，但因为一直没有工程实践所以看完书之后总是容易忘记。通过贡献 TiKV，天翼有了真正的生产经验，对 Rust 特性理解也更加深刻。</p> \n<p><strong>“对我来说，参与社区贡献，除了增加了 Rust 使用经验和真正用于生产的数据库开发经验，同时也认识了很多人，扩大了社交圈，让我学到了很多东西。”</strong></p> \n<p>他也很喜欢参与社区的活动，在 Infra Meetup 中担任过讲师，在两届 TiDB Hackathon 和 TiDB 挑战赛并都取得了优异的成绩，可以说是收获满满。</p> \n<p>对于 Hackathon 这样 48 小时的脑暴活动，天翼有一些小心得：“<strong>无论拿不拿奖，idea 的实现很重要</strong>”，比如在 2019 年的 TiDB Hackathon 上，天翼和队友完成的项目 <a href=\"https://pingcap.com/blog-cn/geographic-data-distribution-traffic-and-latency-halved/\" rel=\"nofollow noreferrer\">解决了跨数据中心场景下 TiDB 的 latency 问题</a>，使得跨地域 SQL 查询延迟下降 50%，跨节点消息数减半（即网络流量减半），实现上方法上主要从 Raft 层面来解决的，比较巧妙地提升了 Follower Read 的性能，并用 Follower Replication 减少带宽成本。这个项目获得了评审们和 TiDB 用户的好评，并且斩获了二等奖。</p> \n<h3>感受最深的一个 PR</h3> \n<p>天翼说在他成为 Committer 之前解决了一个很繁琐的 PR，改动了 80 多个文件 1000 多行代码。虽然难度不高，但令他印象十分深刻，“当时必须修改一个 TiDB 大部分模块都引用的公共接口，于是导致今天改完明天不合并，马上就冲突，给合并带来很大困难，我差一点就要放弃了，但又不甘心，于是我和 breezewish（PingCAP 的小伙伴）一起改动这个 PR 直到凌晨四点，PR 才通过单元测试，被 review 完。第二天上午就迅速合并了，避免了和别的 PR 产生冲突，这次合作印象很深。”</p> \n<h3>进阶！进阶！</h3> \n<p>从 Contributor 到 Committer，天翼在 TiDB 社区得到了成长和认可，对于如何晋升到社区下一个角色 Maintainer，他也有自己的想法。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022074910\" src=\"http://localhost:8060/tup/2020/4/23/7ebea491b9e943d5b5cbd096943713c8.jpg\" alt=\"\" title=\"\"></span></p> \n<p>“Maintainer 是一个要求比较高的角色。我觉得提多少 PR 或者 Review 多少 PR 都不是很关键。比如 孙晓光，他给 TiKV 提了一个独立设计的 feature，我认为这样才配得上一个 Maintainer。参与社区这个过程对我来说是很有意思的，可能在我贡献的过程中慢慢就会达到这个要求。”</p> \n<h2>分享一个参加挑战赛的 Tip</h2> \n<p>在访谈最后，作为 <a href=\"https://pingcap.com/blog-cn/pcp-report-202002/\" rel=\"nofollow noreferrer\">第一季 TiDB 挑战赛</a> 的第一名，天翼为大家分享了一个小 Tip：比赛过程中时刻和 Mentor 保持同步。</p> \n<p>“参加第一季时，我队友有一个 2000 分的 PR，写着写着废弃了，因为当时改动涉及的模块较多，且修改破坏了原本的分层设计最终没能合并。因此有接口设计变更随时和 Mentor 保持同步，及时达成一致意见，对大项目是非常重要的。如果涉及的模块较多，建议优先提交 RFC，经过多个 Reviewer 评审再开始具体工作。避免最后 Review 的时候对设计的理解有冲突而需要大量更改甚至不能合并。”</p> \n<p>（注：天翼所在的 .* Team 也参加了第二季 TiDB 挑战赛之易用性挑战赛，已经斩获了上千积分，想在积分排行榜上与天翼“过过招”的同学，可以看看这份“捞分指南”哦）</p> \n<blockquote> \n <strong>最后在关麦之前……</strong>\n <p>我们请天翼对下一位采访嘉宾提一个问题。天翼说：“什么都可以问吗？” 我们：“对啊，反正不能露出的我们就会掐掉。”</p> \n <p>两个小时过后，天翼终于绞尽脑汁想出了一个问题：“<strong>不知道下一位嘉宾平时做饭么，最喜欢吃哪道菜？</strong>”</p> \n <p>行吧就它了（冷风吹过.gif ），话筒准备递给下一位嘉宾了！至于下一位嘉宾是谁，熟悉社区的小伙伴肯定都知道啦，先卖个关子，敬请期待～</p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021958757\" src=\"http://localhost:8060/tup/2020/4/23/6dad812b15104a398ee250c19ea7a8cc.jpg\" alt=\"\" title=\"\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/b079358a6e9d4a20805019f75ec58263.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '19eb3dd59ef8430d9f637d97449fc417', '83f62facb3b943ffa8e46abd1ebc64d9,f3eb17e6e5664a97af3e9b1fca12b286', '0', '3', '1', '2020-04-23 10:59:24', '2020-04-23 10:59:24');
INSERT INTO `tb_recommend` VALUES ('200aa774402245a09a661873d3e41da4', '「开位」你所应该知道的HTTP——HTTPS篇', '前言 接上篇，本章主要讲解HTTPS相关知识点，重点是STL/SSL的握手。 《你所应该知道的HTTP》系列的其他篇章： 基础篇 进阶篇 缓存篇 拓展篇 优化篇 概述 HTTPS全称Secure Hypertext Transfer Protocol（安全超文...', '<h2>前言</h2> \n<p>接上篇，本章主要讲解HTTPS相关知识点，重点是STL/SSL的握手。</p> \n<p>《你所应该知道的HTTP》系列的其他篇章：</p> \n<ul> \n <li><a href=\"https://segmentfault.com/a/1190000022295229\">基础篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022322405\">进阶篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022336086\">缓存篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022374136\">拓展篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022384920\">优化篇</a></li> \n</ul> \n<h2>概述</h2> \n<p>HTTPS全称Secure Hypertext Transfer Protocol（安全超文本传输协议），是一个安全通信通道，用于在客户计算机和服务器之间交换信息。它使用安全套接字层进行信息交换，简单来说它是HTTP的安全版，是使用TLS/SSL加密的HTTP协议。</p> \n<pre><code>HTTPS = HTTP + TLS/SSL</code></pre> \n<p>HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。<br>TLS全称Transport Layer Security（安全传输层协议）, 前身是SSL，故现在用TLS/SSL统称。是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p> \n<p>套用在TCP/IP四层模型里的结构如下：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFWHy\" src=\"http://localhost:8060/tup/2020/4/23/26ebd684a41c4489b35624af08b8dff7.jpg\" alt=\"模型\" title=\"模型\"></span></p> \n<h2>TLS/SSL原理</h2> \n<p>TLS/SSL的功能实现主要依赖于三类基本算法：散列函数（Hash）、对称加密和非对称加密。<br>其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p> \n<pre><code>TLS/SSL = 非对称加密 + 对称加密 + 散列算法</code></pre> \n<h3>非对称加密</h3> \n<p>加密和解密使用不同密钥的加密算法，也称为公私钥加密。密钥成对出现，一般称为公钥（publickey）和私钥（privatekey），公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。即服务器持有私钥，客户端持有公钥，客户端要发送的信息经过公钥加密后传递给服务器，服务器用私钥解密得到明文信息。</p> \n<p>特点：</p> \n<ul> \n <li>可以实现1对多的通信；</li> \n <li>保密性比较好，只有公钥需要被传递，故私钥被劫持的概率很低；</li> \n <li>安全性高，保密性保证私钥安全，因此安全性仅依赖于算法本身；</li> \n <li>计算复杂，加密速度慢。</li> \n</ul> \n<p>在TLS/SSL中，非对称加密仅用于“身份认证”和“密钥协商”，不在后续正文数据传输中使用，这是安全性与性能之间的平衡取舍。</p> \n<h3>对称加密</h3> \n<p>加密和解密使用相同密钥的加密算法。即客户端与服务器所持有的密钥是相同的，客户端要发送的信息经过密钥加密后传递给服务器，服务器用相同密钥解密得到明文信息。</p> \n<p>特点：</p> \n<ul> \n <li>通信方式是1对1，为了足够安全，服务器和N个客户端通信，需要维持N个密码记录；</li> \n <li>安全性不仅取决于加密算法本身，密钥管理的安全性更是重要；</li> \n <li>计算量小、加密速度快、加密效率高；</li> \n <li>缺少吊销和修改密钥的机制。</li> \n</ul> \n<p>在TLS/SSL中，对称加密的密钥是通过非对称加密的“密钥协商”产生的，这样就最大限度的保证了密钥的安全。由于其效率高的特点，正文数据传输使用了该加密方式。</p> \n<h3>散列函数（Hash）</h3> \n<p>一种将任意长度的消息压缩到某一固定长度的消息摘要的函数，常用于防止信息篡改并验证数据的完整性。</p> \n<p>特点：</p> \n<ul> \n <li>单向不可逆；</li> \n <li>对输入非常敏感，即一点输入的改变都会导致结果不同；</li> \n <li>输出长度固定。</li> \n</ul> \n<p>在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密。<br>在TLS/SSL中，“密钥协商”的最后步骤和传输正文信息都会带上散列函数计算出的信息摘要，他们一起经过对称加密后传输，用来验证完整性。</p> \n<h2>PKI体系</h2> \n<h3>非对称加密的隐患</h3> \n<p>前面讲到“身份验证”和“密钥协商”是TLS/SSL的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但非对称加密算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息。<br>假定出现以下的情况：</p> \n<ul> \n <li>客户端C和服务器S进行通信，中间节点M截获了二者的通信;</li> \n <li>节点M自己计算产生一对公钥pub_M和私钥pri_M;</li> \n <li>C向S请求公钥时，M把自己的公钥pub_M发给了C;</li> \n <li>C使用公钥pub_M加密的数据能够被M解密，因为M掌握对应的私钥pri_M，而C无法根据公钥信息判断服务器的身份，从而C和M之间建立了\"可信\"加密连接。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZka\" src=\"http://localhost:8060/tup/2020/4/23/1eb94938a183420f94b1c7e679de03a0.jpg\" alt=\"中间人攻击.png\" title=\"中间人攻击.png\"></span></p> \n<p>如图，中间节点M和服务器S之间再建立合法的连接，因此C和S之间通信被M完全掌握，M可以进行信息的窃听、篡改等操作，这类攻击被称为“中间人攻击”。</p> \n<h3>身份验证CA和证书</h3> \n<p>为了解决上述的隐患，关键是确保获取公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构CA。<br>CA全称Certificate Authority（证书颁发机构），它负责核实公钥的拥有者的信息，并颁发认证\"证书\"，同时能够为使用者提供证书验证服务，即PKI体系。</p> \n<pre><code>证书 = 公钥 + 申请者与颁发者信息 + 有效时间 + 域名信息 + 签名</code></pre> \n<p>CA认证流程如下：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZp8\" src=\"http://localhost:8060/tup/2020/4/23/88e3c8b0bab94e6ab2b74f7122345ff1.jpg\" alt=\"PKI.png\" title=\"PKI.png\"></span></p> \n<p>客户端会内置信任CA的证书信息（包含公钥），如果CA不被信任，则找不到对应CA的证书，证书也会被判定非法。<br>也可以这样理解，网站千千万，浏览器厂商没办法一家一家去认证，于是跟CA合作，通过维护一个CA列表，只要网站有经过这个列表里CA的认证，就可以信任该网站的证书。</p> \n<h2>TLS/SSL握手过程</h2> \n<p>TLS/SSL握手过程也就是所谓的HTTPS四次握手（不含证书验证步骤）。</p> \n<ol> \n <li>客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数random_C（明文），扩展字段等信息。</li> \n <li>服务端返回协商的信息结果，随机数random_S（明文），证书链等。</li> \n <li>对证书进行验证，包括证书可信性、有效性等，可能需要联系CA。</li> \n <li> <p>细分为四步：</p> \n  <ol> \n   <li>client_key_exchange：客户端计算产生随机数字Pre-master，并用证书公钥加密，发送给服务器;</li> \n   <li>客户端根据random_C、random_S以及Pre-master，计算得到协商密钥enc_key（即对称加密用的密钥）；</li> \n   <li>change_cipher_spec：客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信;</li> \n   <li>encrypted_handshake_message：结合之前所有通信参数的hash值与其它相关信息生成一段数据，采用协商密钥enc_key进行加密，然后发送给服务器用于数据与握手验证;</li> \n  </ol> </li> \n <li> <p>细分为四步：</p> \n  <ol> \n   <li>服务器使用私钥解密Pre-master，根据random_C、random_S以及Pre-master，计算得到协商密钥enc_key；</li> \n   <li>计算之前所有接收信息的hash值，然后解密客户端发送的encrypted_handshake_message，验证数据和密钥正确性；</li> \n   <li>change_cipher_spec：验证通过之后，服务器同样发送change_cipher_spec以告知客户端后续的通信都采用协商的密钥与算法进行加密通信;</li> \n   <li>encrypted_handshake_message：服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥enc_key加密并发送到客户端;</li> \n  </ol> </li> \n <li>握手结束，开始使用协商密钥enc_key进行对称加密通信（包含hash完整性验证）。</li> \n</ol> \n<p>示意图如下：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZxx\" src=\"http://localhost:8060/tup/2020/4/23/9461851f2a0f462c85988f5a53c74d57.jpg\" alt=\"TLS握手.png\" title=\"TLS握手.png\"></span></p> \n<h2>HTTPS的使用成本</h2> \n<ul> \n <li>证书费用及维护更新<br>一般正规CA颁发的证书都是需要付费购买的，并且到期后还得续费。</li> \n <li>增加了访问延迟<br>分析前面的握手过程，一次完整的握手至少需要两端依次来回两次通信，至少增加延时2RTT，利用会话缓存从而复用连接，延时也至少1RTT。</li> \n <li>消耗较多CPU资源<br>加解密是需要消耗性能的，前面也有提到非对称加密的特点，因此会成为性能瓶颈。</li> \n</ul> \n<h2>HTTPS的优化</h2> \n<h3>TLS False Start</h3> \n<p>在TLS/SSL协商第二阶段，也就是浏览器生成最后一个随机数并用公钥加密发送给服务器后，立即发送加密的应用层数据，而无需等待服务器的确认。</p> \n<h3>Session Identifier（会话标识符）</h3> \n<p>如果用户的一个业务请求包含了多条的加密流，客户端与服务器要反复握手，必定导致更多的时间损耗。或某些特殊情况导致会话中断，需要重新握手。<br>服务器为每一次的会话生成并记录一个sessionId，发送给客户端，客户端重新连接只需要提供这个id，不需要重新握手。</p> \n<h3>OCSP Stapling</h3> \n<p>OCSP全称Online Certificate Status Protocol。由web服务器向OCSP server周期性地查询证书状态，获得一个带有时间戳和签名的OCSP response并缓存它。当有客户端发起请求时，web服务器会把这个response在TLS握手过程中发给客户端。<br>（谷歌浏览器默认只使用内置列表检查，故这个优化对谷歌无效）</p> \n<h3>HSTS（HTTP Strict-Transport-Security）</h3> \n<p>一个报文头部字段，告诉浏览器，接下来的一段时间内，当前域名(及其子域名)的后续通信应该强制性使用HTTPS，直到超过有效期为止。</p> \n<p>形如：</p> \n<pre><code>Strict-Transport-Security: max-age=31536000;includeSubDomains</code></pre>', null, 'http://localhost:8060/tup/2020/4/23/24ed6010e4434629bb17fe7919ee3196.jpg', '6fbfa4aaad3a43458f21c8acf0038ac5', '04547238127a4676b504cc4496865d7b', 'f0e336796bd94b8299ef69b2b2529ec4,63c4e1e7ec204b43a62065a3ced4c2ce,f2fb7d236fec4c138cacd9162eb4488c', '0', '3', '1', '2020-04-23 10:58:35', '2020-04-23 10:58:35');
INSERT INTO `tb_recommend` VALUES ('23a50beb305645f29334e10e4ae37525', 'Android 11 第二个开发者预览版发布，目前支持 Pixel 2/3/3a/4 系列刷机', '今天，谷歌发布了Android 11的第二个开发者预览版。和此前发布的第一个预览版相同，该预览版也仅适用于开发人员，需要手动下载，目前支持Pixel 2/3/3a/4系列刷机。', '<p>今天，谷歌发布了Android 11的第二个开发者预览版。和此前发布的第一个预览版相同，该预览版也仅适用于开发人员，需要手动下载，目前支持Pixel 2/3/3a/4系列刷机。</p> \n<p>Android 11的第二个开发者预览版并没有引入任何突破性的新功能，很大程度上是首个预览版的维护升级版本。对此，谷歌研发副总裁 Dave Burke 表示：“它仍然是早期版本，但是您可以开始了解操作系统如何在此版本中实现新体验，从无缝5G连接到围绕着屏幕改进UI，再到更智能的键盘和更快的消息传递体验。”</p> \n<p>下面我们来看一下究竟有哪些更新。</p> \n<h2>全新体验</h2> \n<p><strong>一、5G 状态 API</strong></p> \n<p>DP2 增加了 5G 状态 API，可以让您快速检查用户当前是否连接至 5G New Radio (新空口) 或 Non-Standalone (非独立组网模式) 网络。您可以使用它来展示您的应用的 5G 体验，或是在用户连接成功后进行品牌宣传。您可以将此 API 与 5G 动态计费状态 API、带宽估测 API 以及现有的网络连接 (Connectivity Manager) API 结合使用，以充分活用 5G 更高的速度和更低的延迟。</p> \n<blockquote> \n <strong>动态计费状态 API：</strong>\n <p><a href=\"https://developer.android.google.cn/reference/android/net/NetworkCapabilities.html#NET_CAPABILITY_NOT_METERED\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n <p><strong>带宽估测 API</strong></p> \n <p><a href=\"https://developer.android.google.cn/reference/android/net/NetworkCapabilities.html#getLinkDownstreamBandwidthKbps()\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n <p><strong>现有的网络连接 (Connectivity Manager) API</strong></p> \n <p><a href=\"https://developer.android.google.cn/reference/android/net/ConnectivityManager\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<p><strong>二、可折叠设备的铰链角度</strong></p> \n<p>针对可折叠设备，开发者们提出的头号要求是通过 API 获取设备的屏幕折叠角度。Android 11 现在支持铰链角度传感器，应用可以直接查询，或通过新的 AndroidX API 获取精确的铰链角度，从而为可折叠设备打造自适应体验。</p> \n<blockquote> \n <strong>铰链角度传感器</strong>\n <p><a href=\"https://developer.android.google.cn/reference/android/hardware/Sensor#STRING_TYPE_HINGE_ANGLE\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<p><strong>三、呼叫过滤服务的改进</strong></p> \n<p>为了帮助用户管理语音自动电话 (robocall)，我们添加了新的 API，以使呼叫过滤应用可以为用户提供更多帮助。除了将来电的 STIR / SHAKEN 状态 (均为防范呼叫者 ID 欺诈的标准) 纳入其呼叫详细信息进行验证外，呼叫过滤应用还可以报告拒绝来电的原因，在获得许可的前提下，这些应用还可以查看电话是否通向或来自用户联系人中的号码。应用还可以自定义系统提供的呼叫后屏幕 (post call screen)，方便用户执行诸如 “将呼叫方标记为骚扰电话” 或 “添加到联系人” 之类的操作。我们将在近期与大家分享更多这方面的信息。</p> \n<blockquote> \n <strong>STIR / SHAKEN 状态</strong>\n <p><a href=\"https://developer.android.google.cn/reference/android/telecom/Call.Details.html#getCallerNumberVerificationStatus()\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n <p><strong>呼叫后屏幕 (post call screen)</strong></p> \n <p><a href=\"https://developer.android.google.cn/reference/android/telecom/TelecomManager.html#ACTION_POST_CALL\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<p><strong>五、Neural Networks API 的新算子和控制</strong></p> \n<p>激活函数控制着神经网络中节点的输出。Google AI 团队发现了一个 swish 激活函数，它可以在相当多样的任务中带来更快的训练速度和更高的准确度。现在我们将该函数的一个计算有效版本，hard-swish 算子，加入到了 Android 11 中。这个算子在加速下一代设备上视觉模型 (如 MobileNetV3) 中至关重要，该模型也是许多迁移学习用例的基础。另外，新增的控制算子使得支持分支和循环的更高级的机器学习模型成为可能。我们还添加了新的运行控制，以帮助您最大程度地减少常见用例的延迟: Asynchronous Command Queue API 减少了运行小型链接模型时的开销。请参见 NDK 样例代码了解如何使用这些新 API。</p> \n<blockquote> \n <strong>swish 激活函数</strong>\n <p><a href=\"https://arxiv.org/pdf/1710.05941.pdf\" rel=\"nofollow noreferrer\">https://arxiv.org/pdf/1710.05...</a></p> \n <p><strong>MobileNetV3</strong></p> \n <p><a href=\"https://ai.googleblog.com/2019/11/introducing-next-generation-on-device.html\" rel=\"nofollow noreferrer\">https://ai.googleblog.com/201...</a></p> \n <p><strong>NDK 样例代码</strong></p> \n <p><a href=\"https://github.com/android/ndk-samples/tree/master/nn-samples/\" rel=\"nofollow noreferrer\">https://github.com/android/nd...</a></p> \n</blockquote> \n<h2>隐私和安全</h2> \n<p><strong>一、摄像头和麦克风的前台服务类型</strong></p> \n<p>在 Android 10 中，我们引入了清单属性 foregroundServiceType，以进一步明晰特定用例的适用范围。最初，应用可以选择 “位置” 和其他几种类型。现在，我们在 Android 11 中添加了两种新类型: “摄像头” 和 “麦克风”。如果您的应用要从前台服务访问摄像头或麦克风数据，则需要将对应的 foregroundServiceType 值添加到清单中。</p> \n<p><strong>二、分区存储的更新</strong></p> \n<p>我们一直在致力于更好地保护外部存储上的应用和用户数据。在这个版本中，我们带来了进一步的强化和更改，比如我们现在支持将文件从旧模型迁移到新的分区存储模型，并且改善了缓存文件的管理方式。阅读官方文档了解更多信息，并请留意后续更新中的更多增强功能。</p> \n<blockquote> \n <strong>foregroundServiceType</strong>\n <br>\n <a href=\"https://developer.android.google.cn/preview/privacy/foreground-service-types\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a>\n <p><strong>官方文档: Android 11 中的存储更新</strong><br><a href=\"https://developer.android.google.cn/preview/privacy/storage\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> </p> \n <p><strong>官方文档:Android 11 中的隐私权</strong> <br><a href=\"https://developer.android.google.cn/preview/privacy\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<h2>优化与品质</h2> \n<p><strong>一、同步 IME 切换效果</strong></p> \n<p>这是一组全新的 API，让您可以在 IME (输入法编辑器，也叫软键盘) 和系统栏进出屏幕时同步调整应用中的内容，从而更轻松地创建出自然、直观、高品质的 IME 切换效果。为了确保切换时做到逐帧精确，新的边衬区动画监听器 (Insets Animation Listener) 会在 IME 或系统栏移动时逐帧告知应用边衬区的变化。此外，应用可以通过 WindowInsetsAnimationController API 控制 IME 和系统栏切换效果。由应用控制 IME 的切换效果可以让 IME 更精准地与应用 UI 同步，比如配合过度滚动 UI 时的动画。请上手体验这些新的 IME 切换效果，并告诉我们您还想要支持哪些其他切换效果。</p> \n<blockquote> \n <strong>新的边衬区动画监听器 (Insets Animation Listener)</strong>\n <br>\n <a href=\"https://developer.android.google.cn/reference/android/view/WindowInsetsAnimation.Callback\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a>\n <p><strong>WindowInsetsAnimationController</strong><br><a href=\"https://developer.android.google.cn/reference/android/view/WindowInsetsAnimationController\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<p><strong>二、可变刷新率</strong></p> \n<p>应用和游戏现在可以为其窗口设置首选帧率。大多数 Android 设备以 60Hz 的刷新率更新屏幕，但是某些设备支持多种刷新率，例如 90Hz 和 60Hz，并可在运行时切换。在这些设备上，系统会基于首选帧率来为应用选择最佳刷新率。您可以通过 SDK 和 NDK 来使用本 API。请前往官方文档了解更多信息。</p> \n<blockquote>\n 设置首选帧率\n <p><a href=\"https://developer.android.google.cn/reference/android/view/Surface#setFrameRate(float,%20int)\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<p><strong>三、重启后恢复</strong></p> \n<p>Android 11 改进了夜间定时 OTA 软件更新的体验。和以往版本的 Android 一样，设备需要重启才能应用 OTA 更新，现在有了重启后恢复，应用得以在 OTA 重启后访问可信凭据加密 (Credential Encrypted) 存储，而无需用户解锁设备。这样应用就得以立刻恢复正常功能，并且继续正常接收消息——由于 OTA 更新往往被定时在夜间执行，这时设备无人操作，因此重启后恢复功能就十分必要了。应用依然可以支持直接启动 (Direct Boot)，从而在所有类型的重启后立刻访问设备加密 (Device Encrypted) 存储。请在您的下一个开发者预览版 OTA 更新时点击 \"在凌晨 2 点后重启\" 来体验一下重启后恢复功能吧。</p> \n<p><strong>四、模拟器中的摄像头支持</strong></p> \n<p>Android 模拟器现在可以模拟前置和后置摄像头。后置摄像头支持 Camera2 API HW Level 3 (包括 YUV 再处理和 RAW 捕获)。它是完全符合 CTS 第 3 级要求的设备，可用于测试高级功能，例如 ZSL 和 RAW / DNG 支持。前置摄像头通过逻辑摄像头 (一个逻辑设备及两个隐藏的物理设备) 支持 FULL HW 级别。它强调逻辑摄像头的支持，对应的物理设备则包括窄视角和宽视角摄像头。有了模拟摄像头的支持，您可以构建并测试 Android 11 中新增的任何摄像头功能。我们会在近期公布更多详细信息。</p> \n<blockquote> \n <strong>HW LEVEL_3 和 FULL 级别</strong>\n <br>\n <a href=\"https://source.android.google.cn/devices/camera/versioning#camera_api2\" rel=\"nofollow noreferrer\">https://source.android.google...</a> \n</blockquote> \n<h2>应用兼容性</h2> \n<p>在推出新的平台版本时，进一步通过推进应用兼容性来让用户使用更快速、更流畅的 Android 体验 。在 Android 11 中，添加了新的流程、工具以及发布里程碑版本，以最大程度地减少平台更新带来的影响，让开发者们更轻松地完成更新。</p> \n<p>通过这次发布的开发者预览版 2，在发布路线上更进一步迈向 Beta 版本。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbELwv\" src=\"http://localhost:8060/tup/2020/4/23/6522771cff2f4cf68f1e20025dca3e3c.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>在推出平台稳定版本后，就意味着系统行为、非 SDK 灰名单和 API 已经处于完成状态。现在，可以在 Pixel 2、3、3a 或 4 设备以及 Android 模拟器上开始进行兼容性测试。只需刷新系统版本，安装当前版本的应用，然后测试其完整流程即可，无需更改应用的 targetSdkVersion。</p> \n<p>为了帮助进行测试，安卓此次将多项重大变更设定为可逐一开启/关闭。可以通过开发者选项或 adb 来强制启用或禁用它们，前往官方文档了解更多信息。</p> \n<blockquote> \n <strong>官方文档: 发布日程</strong> \n <br>\n <a href=\"https://developer.android.google.cn/preview/overview\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> \n <br>\n <strong>行为变更</strong>\n <br>\n <a href=\"https://developer.android.google.cn/preview/behavior-changes-all\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> \n <br>\n <strong>官方文档:打开或关闭变化项目</strong> \n <br>\n <a href=\"https://developer.android.google.cn/preview/test-changes\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a>\n <br>\n <strong>Android 11 中有关限制非 SDK 接口的更新</strong>\n <br>\n <a href=\"https://developer.android.google.cn/preview/non-sdk-11\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCJ1M\" src=\"http://localhost:8060/tup/2020/4/23/ce86f335d88c4f76b147bc78ffd0e043.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/62703581fa7247c2aaf5f3459f24100a.jpg', '1894b118d35d44cb8fe8009529c4154b', '819ad72c1efe450f9d7affc135a4b457', '8dfc62f227ae4076888ea4872e03cddd', '0', '3', '1', '2020-04-23 10:36:58', '2020-04-23 10:36:58');
INSERT INTO `tb_recommend` VALUES ('244982edbb5a4239b1a6da0172af5e6c', 'Vue Cli 3 打包配置--自动忽略 console.log 语句', '不过这时会有一个问题，就是在开发环境的时候编译会非常慢。例如修改了一个变量的值，我的电脑要编译 10 秒才能重新刷出来页面，一直卡在 92% chunk asset optimization。', '<p>下载插件</p> \n<pre><code class=\"js\">npm i -D uglifyjs-webpack-plugin</code></pre> \n<p>在 vue.config.js 引入使用</p> \n<pre><code class=\"js\">const UglifyJsPlugin = require(\'uglifyjs-webpack-plugin\')\nmodule.exports = {\n    configureWebpack: {\n        plugins: [\n            new UglifyJsPlugin({\n                uglifyOptions: {\n                    compress: {\n                        drop_console: true,\n                    },\n                },\n            }),\n        ],\n    },\n    devServer: {\n        proxy: {\n            \'/xxx\': {\n                target: \'http://192.168.150.17:8080/\',\n                changeOrigin: true,\n                ws: true,\n                pathRewrite: {\n                    \'^/xxx\': \'xxx\',\n                },\n            },\n        },\n    },\n    publicPath: \'./\',\n}</code></pre> \n<p>这时执行 <code>npm run build</code> 打包后的文件就没有 <code>console.log</code> 语句了。</p> \n<p>不过这时会有一个问题，就是在开发环境的时候编译会非常慢。例如修改了一个变量的值，我的电脑要编译 10 秒才能重新刷出来页面，一直卡在 <code>92% chunk asset optimization</code>。</p> \n<p>由于去掉 <code>console.log</code> 语句这个功能只有在打包时才需要，所以我们可以加一个判断，只在生产环境时才把上述配置代码加上。</p> \n<p>所以正确的配置如下：</p> \n<pre><code class=\"js\">const UglifyJsPlugin = require(\'uglifyjs-webpack-plugin\')\n\nconst config = {\n    devServer: {\n        proxy: {\n            \'/xxx\': {\n                target: \'http://192.168.150.17:8080/\',\n                changeOrigin: true,\n                ws: true,\n                pathRewrite: {\n                    \'^/xxx\': \'xxx\',\n                },\n            },\n        },\n    },\n    publicPath: \'./\',\n}\n\nif (process.env.NODE_ENV === \'production\') {\n    config.configureWebpack = {\n        plugins: [\n            new UglifyJsPlugin({\n                uglifyOptions: {\n                    compress: {\n                        drop_console: true,\n                    },\n                },\n            }),\n        ],\n    }\n}\n\nmodule.exports = config</code></pre> \n<h2>参考资料</h2> \n<ul>\n <li><a href=\"https://github.com/webpack-contrib/uglifyjs-webpack-plugin\" rel=\"nofollow noreferrer\">uglifyjs-webpack-plugin</a></li>\n</ul>', null, null, 'c56940aa8b004dab84568e86900b2ee6', '049b3bd76c1e49ccbe48b36197e77f76', '63c4e1e7ec204b43a62065a3ced4c2ce,d79254c4ca5e45dca9d484307c935281,b350d9c92c524bb4b9feedd40e5eebcd,f6a07ced05b54932b0989568f55b64ee', '0', '3', '1', '2020-04-23 10:26:04', '2020-04-23 10:26:04');
INSERT INTO `tb_recommend` VALUES ('2c9711c22cc14fe1938eedeaeb315da9', '打造百亿量级、亿级日活SDK的十大关键要点', '一个好的SDK应该具备易用性、稳定性、轻量、灵活的特点，而个推作为国内第三方推送市场的早期进入者，一直致力于为开发者提供高效稳定的推送SDK。', '<p>一个好的SDK应该具备易用性、稳定性、轻量、灵活的特点，而个推作为国内第三方推送市场的早期进入者，一直致力于为开发者提供高效稳定的推送SDK。</p> \n<p>经过十年的深耕与创新，个推夯实了行业地位。截止2019年6月，个推SDK累计安装量超440亿，日活独立设备数达4.3 亿，并成功服务了人民日报、新华社、微博、马蜂窝、酷我音乐等一系列明星APP。辉煌数据的背后是强大的技术支撑。</p> \n<p>这期文章，我们特地采访了个推Android 资深开发敬瑜，以个推推送SDK为例，来聊聊打造大型SDK的关键技术点。</p> \n<p>作者 个推Android 资深开发 敬瑜</p> \n<p><strong>01 开发 SDK 和 开发APP 有什么联系？</strong></p> \n<p>APP 和 SDK两者关系密切，APP是SDK的主要载体， SDK 则是 APP开发所需的重要工具。从研发者的角度来看，SDK开发和 APP开发均属于 Android 顶层应用开发，并无本质区别，两者的目的均是要提供产品给客户使用；但从商业角度来讲，APP 是to C 的产品，用户是广大群众；而 SDK 则是to B 的产品，用户为广大开发者，两者在运营模式上有所不同。</p> \n<p><strong>02 SDK 开发最关键的点是什么？</strong></p> \n<p>SDK没有UI交互，用户使用 APP 时并不会感知到SDK 的存在。但是作为APP的重要部分，SDK的性能直接影响着APP的性能，也间接影响着用户在使用APP时的体验和感受。总结个推推送SDK的开发经验，我们认为SDK开发最需要注意的是其稳定性。</p> \n<p>作为一款第三方 SDK，稳定性是第一要素，我们要保证推送SDK在不同环境下（APP、终端设备等）都能正常运行。要想保障稳定性，复杂环境的兼容是关键。减少使用非 SDK 接口也有助于提升稳定性。</p> \n<p>除了稳定性外，以下几个问题对于打造优质SDK也很重要。</p> \n<p><strong>03 SDK 版本适配以及厂商兼容情况如何？</strong></p> \n<p>个推 SDK 支持 Android 端和 iOS 端，以下文章均使用 Android 端来举例。</p> \n<p>截止目前，Android 系统从07年发布第一版至今，经历了多次迭代，Android Q为其最新版本。个推Android SDK 支持 Android 2.3及以上版本，几乎可以在市面上现存的所有Android 版本上运行。</p> \n<p><strong> 1）版本适配</strong><br>APP 主要在手机上运行，若想 APP 在 Pad、电视之类的智能设备上运行，则基本需要单独适配，也就是说，APP 会根据其使用环境调试相应的版本。而 SDK 的运行环境相对复杂，我们根本不知道自己开发的 SDK 会在什么样的环境下运行，可能是手机、Pad、电视，也可能是车载设备，甚至是冰箱等智能家居设备。这类设备的 Android 系统版本从 2.3至10.0 不等。我们在开发SDK 的时候需要尽量地向下兼容。为此，个推推送 SDK 依旧保留着对 Android 2.3 系统的兼容。 </p> \n<p><strong> 2）厂商兼容</strong><br>一个成熟的 SDK 势必要保证在不同的厂商设备上正常运行，尤其是当SDK 内部涉及到Android 四大组件时需要特别注意厂商的兼容性，注意其是否会限制固定 action 的广播使用及限制固定类名 service 的启动。而如果 SDK 开发涉及到 Android framewrok 的引用，某些功能可能会失效。比如AndFix 的底层实现依托于 Art/Dalvik 虚拟机的架构，但是大部分厂商会对虚拟机进行定制，修改底层 ArtMethod 结构，这时，AndFix将无法在修改过虚拟机的设备上生效。</p> \n<p>所以在 SDK 开发过程中我们要尽量避免Android Framework 的引用。个推在使用Android 四大组件的时候，会要求开发者提供自定义 Service，其Service 只需要继承个推默认的即可，这样可以保证 SDK 在不同厂商上均能正常运行。</p> \n<p><strong>04 怎么看待现在市面上的 SDK广泛支持多混合开发这一现象？</strong></p> \n<p>大前端开发是必然的趋势，现在新推出的产品会优先使用混合开发，保证一套代码可以在多个终端上运行。因此，一个成熟的 SDK 有必要对不同的语言框架进行适配。目前，个推 SDK 不仅支持 Android、iOS系统，还支持混合开发，如unity3d cocos2dx react-native flutter cordova apicloud等。具体见<a href=\"https://github.com/GetuiLaboratory\" rel=\"nofollow noreferrer\">个推实验室</a></p> \n<p><strong>05 Android SDK 是否会使用开源项目？</strong></p> \n<p>不会使用。<br>有以下几点考虑：</p> \n<ul> \n <li>使用开源项目会增加包的体积；</li> \n <li>不能保证开源项目支持复杂的终端环境；</li> \n</ul> \n<p>-客户的 APP可能已使用开源项目，将导致编译失败；</p> \n<p><strong>06 如何适配海外市场环境？</strong></p> \n<p>开拓Google Play 市场是各大互联网公司的长远规划之一。个推Android SDK Google Play版本自发布以来，积极适配复杂的海外环境，为海外App消息的稳定下发提供强大的支撑和保障。为了有更好的用户体验，个推推送 SDK 还在国外众多地方布置了机房，以保证推送的到达率。另外，个推推送SDK还需要对 Google Play 制定的各种规则进行适配，以及还要考虑不同国家不同版本机型的适配问题。这要求我们在开发过程中尽量使用 Google 生产的手机进行调试与测试。</p> \n<p><strong>07 SDK 如何降低手机电量、流量的消耗？</strong></p> \n<p>为了给用户更好的使用体验，我们会尽可能地降低SDK对电量以及流量所造成的消耗。为此，我们不会使用蓝牙这类电量消耗较高的工具。此外，我们还会采用多链路合并技术来节约流量。</p> \n<p>为了准确地了解所耗电量、流量的降低情况，我们还会做一个全面的测试。每次发版之前，我们都会采用严格的测试标准，使用特定的 APP 进行电量压测。为了尽可能地排除外来因素的干扰，保证测试的准确性，我们往往会使用集成了个推推送 SDK 的 APP来测量。常见测量 APP 的方式有Batterystats &amp; bugreport和Battery Historian。具体细节可以自行查阅 PowerProfile.java 和 power_profile.xml 的使用与原理。</p> \n<p><strong>08 如何自主检测 SDK 的异常？</strong></p> \n<p>经过近 10 年的优化与升级，个推推送 SDK 的异常情况已经控制在一个非常非常低的水平，但因为 Android 市场碎片化非常严重，SDK 在如此碎片化的环境下运行难免会出现各种意想不到的突发情况，为此我们专门开发了SDK运行自查系统，类似于精简版的 bugly。该内部产品与 SDK 相辅相成，可以自主检测 SDK 的异常情况，并在发现异常后主动上报。其次，在代码层面，我们也做了一些防控，避免 SDK 因为异常而导致无法正常使用。另外，我们还成立了技术支持团队，服务广大的开发者，定期回访客户，帮助解决客户遇到的问题。</p> \n<p><strong>09 开发SDK还有什么是需要注意的么？</strong></p> \n<p>SDK开发过程中，我们还需要注意安全性。安全性不仅仅代表网络数据交互的安全、本地数据存储的安全，也涉及到 SDK 的加固、混淆、第三方安全软件审核。举例来说，个推 Android SDK 提供了四大组件的对接，SDK 内部会特别注意，避免这些组件被反序列化攻击。为了让开发者更加放心地使用我们的SDK，我们公司内部建立了严格的安全管理机制，来保障SDK的安全性。</p> \n<p><strong>10 对 SDK 开发者有何建议？</strong></p> \n<p>其实从 Android APP 诞生开始，SDK 的开发就从未中断过。SDK 开发者与 APP 开发者的工作内容基本相同，但是开发 SDK 更注重对 Java 语言以及 Android 底层的理解。如果大家想从事Android SDK 开发，建议多研究 Java 的相关知识，深入理解 Android framework 层。</p> \n<p>开发SDK并不难，难的是如何让自己开发的 SDK 在复杂的环境下稳定运行。这需要我们对 SDK 的架构有一个比较清晰的认知，并对前文所提到的问题进行认真思考。</p> \n<p>多年来，个推 SDK始终以服务开发者为己任，持续为用户提供优质的体验。为了进一步提升推送后台的保活能力，个推已发布 2.13.3.0版本，并对 Android Q 进行了适配，请前往个推文档中心下载<a href=\"http://docs.getui.com/download.html\" rel=\"nofollow noreferrer\">http://docs.getui.com/downloa...</a>，即刻体验。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022161427\" src=\"http://localhost:8060/tup/2020/4/23/5569b2725459482e9c193d1424eafd7f.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/6480b78eeb584bfc89c841bc987929de.jpg', '1c5851dc916d4e70a60f0c957f548876', 'a337904dd1d5477b9689d7693be316de', '0b50d8c7b2a44489a9dd703b034feac2,8dfc62f227ae4076888ea4872e03cddd,85ee959b27f74072b13cc763b9bbf77e', '0', '3', '1', '2020-04-23 10:31:39', '2020-04-23 10:31:39');
INSERT INTO `tb_recommend` VALUES ('2cbfab59ee3b4dd380b80407c46af08c', '从零开始的Flutter之旅: StatefulWidget', '往期回顾 从零开始的Flutter之旅: StatelessWidget 在之前的文章中，我们介绍了StatelessWidget的特性与它在Flutter中的呈现原理。 这次我们接着来聊聊它的兄弟StatefulWidget，俗称有状态小部件。 特性 如果你看...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037786\" src=\"http://localhost:8060/tup/2020/4/23/3665dd4851604412819b2f39d20b9918.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>往期回顾</h2> \n<p><a href=\"https://segmentfault.com/a/1190000021938948\">从零开始的Flutter之旅: StatelessWidget</a></p> \n<p>在之前的文章中，我们介绍了StatelessWidget的特性与它在Flutter中的呈现原理。</p> \n<p>这次我们接着来聊聊它的兄弟StatefulWidget，俗称有状态小部件。</p> \n<h2>特性</h2> \n<p>如果你看了我之前的文章，你可能已经非常熟悉无状态小部件StatelessWidget。它们是由一个蓝图与不可变的element配置来实现的，实际安装到屏幕上的是各个StatelessElement。</p> \n<p>不可变的东西我是非常喜欢的，就像写代码一样，一旦定义了一个不可变的变量，我就不用再关心它之后的所有事情，因为它不可变的性质，致使它不会发生不可预期的问题，只需直接使用它即可。</p> \n<p>但一个程序只有不可变的配置是不行的，我们不可能编写一个只绘制一次后就停止的应用。因为一旦数据改变，不可变的配置是不可能帮助我们刷新ui，达到我们预期的效果；而有状态小部件StatefulWidget却可以轻松解决这些事情。</p> \n<p>StatefulWidget提供不可变的配置信息以及可以随着时间变化而触发的状态对象；通过监听状态的变化来达到ui的更新。</p> \n<p>简单点，我们从<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>挑选一个实例。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037791\" src=\"http://localhost:8060/tup/2020/4/23/b3120087ebc24074b40eddbd4a38ec6b.jpg\" alt=\"\" title=\"\"></span></p> \n<p>当我们点击其中一个未读通知信息时，我们需要将其ui状态变成已读的样式。根据状态来改变ui，StatefulWidget能够很好的实现这种场景。来看一下其实现</p> \n<pre><code>class NotificationTabPage extends BasePage&lt;_NotificationPageState&gt; {\n  const NotificationTabPage();\n \n  @override\n  _NotificationPageState createBaseState() =&gt; _NotificationPageState();\n}\n \nclass _NotificationPageState\n    extends BaseState&lt;NotificationVM, NotificationTabPage&gt; {\n  @override\n  NotificationVM createVM() =&gt; NotificationVM(context);\n \n  @override\n  Widget createContentWidget() {\n    return RefreshIndicator(\n      onRefresh: vm.handlerRefresh,\n      child: Scrollbar(\n        child: ListView.builder(\n          itemCount: vm.notifications?.length ?? 0,\n          itemBuilder: (BuildContext context, int index) {\n            final NotificationModel item = vm.notifications[index];\n            return GestureDetector(\n              onTap: () {\n                vm.contentTap(index);\n              },\n              child: Container(\n                color: item.unread ? Colors.white : Color.fromARGB(13, 0, 0, 0),\n                padding: EdgeInsets.only(left: 15.0, top: 10.0, right: 15.0),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: &lt;Widget&gt;[\n                    Text(\n                      item.repository.fullName,\n                      style: TextStyle(\n                        fontWeight: FontWeight.bold,\n                        fontSize: 16.0,\n                        color: item.unread\n                            ? Colors.black87\n                            : Color.fromARGB(255, 102, 102, 102),\n                      ),\n                    ),\n                    Row(\n                      children: &lt;Widget&gt;[\n                        Padding(\n                          padding: EdgeInsets.only(top: 5.0),\n                          child: Image.asset(\n                            vm.getTypeFlagSrc(item.subject.type),\n                            width: 18.0,\n                            height: 18.0,\n                          ),\n                        ),\n                        Expanded(\n                          child: Padding(\n                            padding: EdgeInsets.only(top: 5.0, left: 10.0),\n                            child: Text(\n                              item.subject.title,\n                              overflow: TextOverflow.ellipsis,\n                              maxLines: 1,\n                              style: TextStyle(\n                                fontSize: 14.0,\n                                color: item.unread\n                                    ? Color.fromARGB(255, 17, 17, 17)\n                                    : Color.fromARGB(255, 102, 102, 102),\n                              ),\n                            ),\n                          ),\n                        ),\n                      ],\n                    ),\n                    Padding(\n                      padding: EdgeInsets.only(top: 10.0),\n                      child: Divider(\n                        height: 1.0,\n                        endIndent: 0.0,\n                        color: Color.fromARGB(255, 207, 216, 220),\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}</code></pre> \n<p>这里的BasePage是<code>MSVM</code>架构中的基类，它继承于StatefulWidget；_NotificationPageState也是一样，它继承于State</p> \n<pre><code>abstract class BasePage&lt;S extends BaseState&gt;\n    extends StatefulWidget {\n    ...\n}\n \nabstract class BaseState&lt;VM extends BaseVM, T extends StatefulWidget&gt;\n    extends State implements VMSContract {\n    ...\n}</code></pre> \n<blockquote>\n 关于MSVM后续会专门开文章介绍，想了解的可以期待一下\n</blockquote> \n<p>我们来看createContentWidget方法中的布局，找到上述情况关联的ui，在ListView的item中。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037788\" src=\"http://localhost:8060/tup/2020/4/23/77ec474d8dc64736afe8985810763bc7.jpg\" alt=\"\" title=\"\"></span></p> \n<p>item布局的状态是根据item.unread来判断的，未读状态为ture。</p> \n<p>当用户onTap点击时，将会向服务器发送thread阅读请求，当请求成功之后，再将相应位置的item.unread值改为false。</p> \n<p>但就这样改变你会发现ui是不会刷新的，因为在StatefulWidget，如果你想改变某个值，同时要同步更新ui，需要使用setState方法。</p> \n<pre><code>  _markThreadRead(int index) async {\n    try {\n      Response response =\n          await dio.patch(\'/notifications/threads/${_notifications[index].id}\');\n      if (response != null &amp;&amp;\n          response.statusCode &gt;= 200 &amp;&amp;\n          response.statusCode &lt; 300) {\n        _notifications[index].unread = false;\n        notifyStateChanged();\n      }\n    } on DioError catch (e) {\n      Toast.show(\'makThreadRead error: ${e.message}\', context);\n    }\n  }</code></pre> \n<p>这里将setState方法封装到notifyStateChanged方法中。所以现在再回过去看ui，会发现ui已经刷新了。</p> \n<p>以上是使用StatefulWidget来达到ui的动态改变。再对比于之前的StatelessWidget，它们之间的区别显而易见了。</p> \n<h2>呈现原理</h2> \n<p>与StatelessWidget一样，接下来看下StatefulWidget的呈现原理。</p> \n<p>StatefulWidget也是继承于Widget，所以它的内部也是存在createElement方法。本质也是通过createElement来创建对应的Element Tree，只不过创建的是StatefulElement；然后再调用对应的Widget Tree中的build方法来获取相应的蓝图。</p> \n<p>但与StatelessWidget所不同的是，它还有另外一个方法</p> \n<pre><code>  @protected\n  State createState();</code></pre> \n<p>通过createState来创建对应的State。StatefulWidget保留了StatelessWidget的特性，即保证final数据的不变性，而对于非final可变数据，将通过Stete进行管理。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037790\" src=\"http://localhost:8060/tup/2020/4/23/2b776191e30e48b78a3751b3dc0a821d.jpg\" alt=\"\" title=\"\"></span></p> \n<p>上面是之前StatelessWidget呈现原理图，下面来对照看下StatefulWidget的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037787\" src=\"http://localhost:8060/tup/2020/4/23/e32080b2483644d085b42e75f8b1332b.jpg\" alt=\"\" title=\"\"></span></p> \n<p>除了Widget Tree与Element Tree，还有对应的State，它管理着可变的数据，例如item.unread。</p> \n<p>一旦item.unread改变了，且通知到State，State将会再下一帧重新要求Widget Tree进行刷新。重新构建一个Container</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037785\" src=\"http://localhost:8060/tup/2020/4/23/b16ed56b62734137bdccc074ca791cae.jpg\" alt=\"\" title=\"\"></span></p> \n<p>由于是同一种类型Container，将会直接被替换，同时使用更新后的item.unread，所以对应的Container的color也将发生改变。最终呈现的是布局的刷新。</p> \n<p>值得一提的是，State依附于Element Tree中，所以它的生命周期非常长，即使Widget Tree中的NotificationTabPage被移除重建，只要保证重建的类型是一致的，同时Widget Tree 与Element Tree的对应位置是没有变化的，那么Widget可以避免重建，只是会将其标记为脏状态，然后它的子widget将会通过build方法进行重建，替换State中的变化的值。</p> \n<p>如果你要监听Widget的变化，可以重写didUpdateWidget</p> \n<pre><code>  @override\n  void didUpdateWidget(StatefulWidget oldWidget) {\n    // TODO: implement didUpdateWidget\n    super.didUpdateWidget(oldWidget);\n  }</code></pre> \n<p>综上所述，StatefulWidget使你可以随时跟踪数据的变化并更新应用的ui。但你深入Flutter之后，你会发现自己写的更多的是StatelessWidget，因为需要用到的StatefulWidget基本上已经实现了，我们更多的是对StatelessWidget的封装，是不是很有意思呢，期待你的加入。</p> \n<p>文中的代码都是来自于<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>，这是一个基于Flutter的Github客户端同时支持Android与IOS，支持账户密码与认证登陆。使用dart语言进行开发，项目架构是基于Model/State/ViewModel的MSVM；使用Navigator进行页面的跳转；网络框架使用了dio。项目正在持续更新中，感兴趣的可以关注一下。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbEdtZ\" src=\"http://localhost:8060/tup/2020/4/23/85b5333afe694c1b8311f0b08a43bd6c.jpg\" alt=\"\" title=\"\"></span></p> \n<p>当然如果你想了解Android原生，相信<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>的纯Android版本<a href=\"https://github.com/idisfkj/AwesomeGithub\" rel=\"nofollow noreferrer\">AwesomeGithub</a>是一个不错的选择。</p> \n<h2>下期预告</h2> \n<p><strong>从零开始的Flutter之旅: InheritWidget</strong></p> \n<p>如果你喜欢我的文章模式，或者对我接下来的文章感兴趣，可以点击一下我的头像进行关注，当然您也可以关注我微信公众号：【Android补给站】</p> \n<p>或者扫描下方二维码，与我建立有效的沟通，同时更快更准的收到我的更新推送。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037789\" src=\"http://localhost:8060/tup/2020/4/23/7053e02c0dc34c3eabeba0c3ff6461dc.jpg\" alt=\"\" title=\"\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/71101dca7cd548049bc166d8d6d7f636.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', 'a337904dd1d5477b9689d7693be316de', '14ab12176ade47da95ba97d7151eb1f9,8dfc62f227ae4076888ea4872e03cddd,85ee959b27f74072b13cc763b9bbf77e,63c4e1e7ec204b43a62065a3ced4c2ce,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-23 10:31:54', '2020-04-23 10:31:54');
INSERT INTO `tb_recommend` VALUES ('2dc40dcfecf945de99c74d2145622b10', '面试必问的几种线程安全的 Map 解析', 'HashMap线程安全的吗？ Java中平时用的最多的Map集合就是HashMap了，它是线程不安全的。 看下面两个场景： 1、当用在方法内的局部变量时，局部变量属于当前线程级别的变量，其他线程访问不了，所以这时也不存在线...', '<blockquote>\n <strong>HashMap线程安全的吗？</strong>\n</blockquote> \n<p>Java中平时用的最多的Map集合就是HashMap了，它是线程不安全的。</p> \n<p>看下面两个场景：</p> \n<p>1、当用在方法内的局部变量时，局部变量属于当前线程级别的变量，其他线程访问不了，所以这时也不存在线程安全不安全的问题了。</p> \n<p>2、当用在单例对象成员变量的时候呢？这时候多个线程过来访问的就是同一个HashMap了，对同个HashMap操作这时候就存在线程安全的问题了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022438185\" src=\"http://localhost:8060/tup/2020/4/23/8894e715d68247718fc8f49807693fe0.jpg\" alt=\"\" title=\"\"></span></p> \n<blockquote>\n <strong>线程安全的Map</strong>\n</blockquote> \n<p>为了避免出现场景2的线程安全的问题，不能使用HashMap作为成员变量，要寻求使用线程安全的Map，下面来总结下有哪些线程安全的Map呢？</p> \n<p><strong>1、HashTable</strong></p> \n<p>private&nbsp;Map&lt;String, Object&gt;&nbsp;map&nbsp;=&nbsp;new&nbsp;Hashtable&lt;&gt;();</p> \n<p>来看看HashTable的源码</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGjiW\" src=\"http://localhost:8060/tup/2020/4/23/8616cac7559f40debc3c86a7c2886214.jpg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGjiX\" src=\"http://localhost:8060/tup/2020/4/23/7cba011cd8774ca6b5b32e16ee484da5.jpg\" alt=\"\" title=\"\"></span></p> \n<p>HashTable的get/put方法都被synchronized关键字修饰，说明它们是方法级别阻塞的，它们占用共享资源锁，所以导致同时只能一个线程操作get或者put，而且get/put操作不能同时执行，所以这种同步的集合效率非常低，一般不建议使用这个集合。</p> \n<p><strong>2、SynchronizedMap</strong></p> \n<p>private&nbsp;Map&lt;String, Object&gt;&nbsp;map&nbsp;= Collections.synchronizedMap(new&nbsp;HashMap&lt;String, Object&gt;());</p> \n<p>这种是直接使用工具类里面的方法创建SynchronizedMap，把传入进行的HashMap对象进行了包装同步而已，来看看它的源码。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022438184\" src=\"http://localhost:8060/tup/2020/4/23/a37edcb8143b4101bf4f49ce9e12678f.jpg\" alt=\"\" title=\"\"></span></p> \n<p>这个同步方式实现也比较简单，看出SynchronizedMap的实现方式是加了个对象锁，每次对HashMap的操作都要先获取这个mutex的对象锁才能进入，所以性能也不会比HashTable好到哪里去，也不建议使用。</p> \n<p>3、<strong>ConcurrentHashMap - 推荐</strong></p> \n<p>private&nbsp;Map&lt;String, Object&gt;&nbsp;map&nbsp;=&nbsp;new&nbsp;ConcurrentHashMap&lt;&gt;();</p> \n<p>这个也是最推荐使用的线程安全的Map，也是实现方式最复杂的一个集合，每个版本的实现方式也不一样，在jdk8之前是使用分段加锁的一个方式，分成16个桶，每次只加锁其中一个桶，而在jdk8又加入了红黑树和CAS算法来实现。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022438186\" src=\"http://localhost:8060/tup/2020/4/23/083ed108c6fe4db9aa9aab1751c56616.jpg\" alt=\"\" title=\"\"></span></p> \n<p>虽然实现起来很复杂，但使用起来也是非常简单的，在java面试中问的频率也非常高，最重要的是性能要比上面两种同步方式要快太多，推荐使用。</p> \n<p><strong>推荐去我的博客阅读更多：</strong></p> \n<p>1.<a href=\"http://www.javastack.cn/categories/Java/\" rel=\"nofollow noreferrer\">Java JVM、集合、多线程、新特性系列教程</a></p> \n<p>2.<a href=\"http://www.javastack.cn/categories/Spring/\" rel=\"nofollow noreferrer\">Spring MVC、Spring Boot、Spring Cloud 系列教程</a></p> \n<p>3.<a href=\"http://www.javastack.cn/categories/%E5%B7%A5%E5%85%B7/\" rel=\"nofollow noreferrer\">Maven、Git、Eclipse、Intellij IDEA 系列工具教程</a></p> \n<p>4.<a href=\"http://www.javastack.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/\" rel=\"nofollow noreferrer\">Java、后端、架构、阿里巴巴等大厂最新面试题</a></p> \n<p>觉得不错，别忘了点赞+转发哦！</p>', null, 'http://localhost:8060/tup/2020/4/23/f454deabfa974d46af803c341b04a7ad.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', 'bb0b7e69ad3e46fcb121baefda8f1f78', '2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-23 10:28:15', '2020-04-23 10:28:15');
INSERT INTO `tb_recommend` VALUES ('2ed7264af8ca48639a5371e4c798a3c1', '今天聊：前端跳槽要不要找猎头', '著作权归作者所有。商业转载请联系 Scott 获得授权，非商业转载请注明出处[务必保留全文，勿做删减]。本号常年不在状态，讲话无凭无据，你可不要太当真哦。', '<blockquote>\n 著作权归作者所有。商业转载请联系 Scott 获得授权，非商业转载请注明出处[务必保留全文，勿做删减]。\n <p>本号常年不在状态，讲话无凭无据，你可不要太当真哦。</p> \n</blockquote> \n<p>工作没几年的时候，觉得猎头是一个可高级的岗位了，能被勾搭上都觉得自己身价陡增，倍儿有面子。</p> \n<p>是的，我当年就是这么想的。</p> \n<p>QQ 好友里躺了好几百个猎头，每次打开都一排排的粉色头像在晃动，仿佛在跟我说：Scott，快来快来，这里有一个 Offer 等着你，基于你现在&nbsp; 10k 的薪资，再涨 8 千...</p> \n<p>直到我开始自己创业的时候，我才发觉自己多么单纯。</p> \n<p>跟上百的猎头聊下来，他们也帮我推荐了工作，不可否认，有许多很专业的猎头（功课做得足，专业知识够，沟通技巧高...），是非常值得托付终（Jian）身（Li）的人。</p> \n<p>但同时，市面上充斥这各种层次不齐的半路猎头，他们可能只是对你好奇，过来打击一下你，过来讥讽一下你，过来挑逗一下你，过来装模作样了解一下你，甚至过来只是例行公事的骚扰一下你，拿走你的简历转手送人，更有甚者，想要来跟你做一笔交易，你入职她会陪你吃花酒...(嘘！我不能透漏更多了)</p> \n<p>基于这个现实，前端跳槽要不要找猎头呢？</p> \n<p>我的答案是，当你在社区有影响力的时候，不要找，当你技术水平还不足的时候，不要找，当你不了解目标公司用人标准的时候，不要找。</p> \n<p>为什么呢？</p> \n<p>如果你影响力比较大，社区很多人都了解你的时候，你在很多公司都有人脉的时候，你想一下，自己内推自己过去入职率高，还是猎头推荐你过去入职率高？</p> \n<p>答案显然是自己找朋友内推成功率高，因为没有谁比你朋友更了解你了。</p> \n<p>如果你技术还不够好，或者对目标公司用人标准不够了解的时候，仓促找了猎头投了简历，可能会碰到这种结果：</p> \n<ul>\n <li>面试过关，但不发 Offer</li>\n</ul> \n<p>好诡异的结果，原因是你可能面试刚刚摸到了公司的用人标准线，公司咬咬牙是想把你招进来的，结果一想到要支付猎头一大笔介绍费，就退却了（毕竟对于很多公司，能省一点省一点，何况这笔费用还不菲）。</p> \n<p>那什么时候找猎头呢？就是技术水平还不错（最好是已经到了技术专家，也就是 P7 的水平以上），在社区里比较沉默影响力不够，或者目标是去一家外企的时候，可以考虑猎头。</p> \n<p>那怎么联系猎头呢？放心，只要你有一点点风声出去，猎头都会来找你的。</p> \n<p>那如何甄别猎头呢？你只需要考一考他/她对前端职业的了解程度，听听他/她对这个职业的理解深度，以及他/她能如数家珍出多少个前端社区有影响力的人，并且知道他们分别在什么公司带什么团队大概什么层级，以及他/她能基本分得清 Java 和 Javascript，分得清 Vue/Angular/React，分得清前端和大前端，知道这一两年的前端风向是什么，是 BFF 还是 Serverless，如果他/她能大概说的清楚，那么这个猎头可以再深度对接对接了。</p> \n<p>真正专业的猎头，不会打击你，而是会给你提供事实案例和有价值的建议，真正专业的猎头，更不会嘲讽你，而是会帮你理清楚目标职位跟你的实力有距离的时候，你所面临的利害关系（比如一旦被面试唰下来，在这家公司再被捞起来的概率可能是大幅降低的），真正专业的猎头，是会认真跟你交朋友的，因为当下的你可能还只是弱鸡，三年后可能就一鸣惊人了，至少我见过的好的猎头，会带候选人一起参加面试，会跟有交情的主面试官打个客套，甚至会给候选人带吃的喝的全程陪护（考虑到有的高级岗位会面试一个上午加半个下午的情况）。</p> \n<p>本来只想发 500 字，一不小心说这么多，大家听听就好，千万别当真哦。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2020/png/87555/1579178669691-3b97de17-d9b4-419d-84ee-57366d957032.png#align=left&amp;display=inline&amp;height=315&amp;name=image.png&amp;originHeight=539&amp;originWidth=1280&amp;size=1569079&amp;status=done&amp;style=none&amp;width=746\" src=\"http://localhost:8060/tup/2020/4/23/bb595242d29c491394d5b820889ca13f.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<blockquote>\n Scott 近两年无论是面试还是线下线上的技术分享，遇到许许多多前端同学，由于团队原因，个人原因，职业成长，技术方向，甚至家庭等等原因，在理想国与现实之间，在放弃与坚守之间，摇摆不停，心酸硬扛，大家可以找我聊聊南聊聊北，对工程师的宿命有更多的了解，有更多的看见与听见，Scott 微信： codingdream，也可以来\n <a href=\"https://www.yuque.com/iscott\" rel=\"nofollow noreferrer\">关注 Scott 语雀跟进最新动态</a>，本文未经许可不许转载，获得许可请联系 Scott，否则在公众号上直接转载，尤其是裁剪内容后转载，我都会直接进行投诉处理。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882754189-781488ce-b345-45cf-a3b7-cb5309e9caa6.png#align=left&amp;display=inline&amp;height=399&amp;name=2.png&amp;originHeight=600&amp;originWidth=600&amp;size=158647&amp;status=done&amp;style=none&amp;width=399\" src=\"http://localhost:8060/tup/2020/4/23/144db037543d4427886f2807616d22e1.jpg\" alt=\"2.png\" title=\"2.png\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882773713-309efa88-e1fc-481f-865b-3c0cb0d3ec43.png#align=left&amp;display=inline&amp;height=398&amp;name=1.png&amp;originHeight=600&amp;originWidth=600&amp;size=134434&amp;status=done&amp;style=none&amp;width=398\" src=\"http://localhost:8060/tup/2020/4/23/3d9fefb9219d4924b2152c2a0befb93b.jpg\" alt=\"1.png\" title=\"1.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/90e4e0ddcc7d4eaabca2df5b5b3be011.jpg', 'c56940aa8b004dab84568e86900b2ee6', '049b3bd76c1e49ccbe48b36197e77f76', '63c4e1e7ec204b43a62065a3ced4c2ce,56c120bcbcfd4c189edde979cbe2cc96,f4485e212bb64f2a8d2761524742e3d7', '0', '3', '1', '2020-04-23 10:26:07', '2020-04-23 10:26:07');
INSERT INTO `tb_recommend` VALUES ('318d49be4e9f4ca2a43bf5df656221df', 'IOT、AI、云计算等融合技术推进制造业产业转型', '3月31日，BoCloud博云、京东智联云、海尔集团联手，以“制造”到“智造”为主题，进行了IT赋能企业数字化转型实践分享。博云售前解决方案架构师尹贺杰，京东云与AI企业云业务部高级业务技术经理吴世超，海尔集团智能...', '<blockquote>\n 3月31日，BoCloud博云、京东智联云、海尔集团联手，以“制造”到“智造”为主题，进行了IT赋能企业数字化转型实践分享。\n <br>博云售前解决方案架构师尹贺杰，京东云与AI企业云业务部高级业务技术经理吴世超，海尔集团智能制造产业技术总监亢晓飞三位制造业转型专家，分别从传统制造业互联网化改造、工业制造业融合技术和工业互联网制造企业转型等多个角度进行了实践及案例分享。我们将分三期，分别回顾活动中的精彩内容。\n <br>本期内容，我们将回顾京东云与AI企业云业务部高级业务技术经理吴世超，讲解京东智联云如何通过物联网技术、AI技术及云平台帮助用户实现数字化及智能化转型。\n</blockquote> \n<p>通过新技术提升制造业全要素生产率，成为优化经济结构、驱动传统产业转型升级的国家战略。以物联网、云计算、AI为代表的新一代信息技术，为传统行业，特别是制造业升级转型赋能，成为制造业释放数字能力，探索智能创新的战略化手段。而京东智联云，围绕客户，利用云计算、大数据、物联网和人工智能等新的IT技术，通过企业商业模式创新、客户体验再造、业务流程重构和组织机构重组，以实现企业的发展和转型。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321566\" src=\"http://localhost:8060/tup/2020/4/23/a88d4571ca1d45c99c8e51bb73c2d4ff.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<ul> \n <li> <strong>智能平台</strong>：建设人工智能能力中台，利用计算机视觉、语音及声 学、机器学习、深度学习、知识图谱等能力助力企业快速进入AI时代。</li> \n <li> <strong>IOT平台</strong>：平台提供安全可靠的设备连接通信能力与管理能力，将海量设备数据采集，同时提供了设备数据转发，设备存储，帮助应用快速集成。</li> \n <li> <strong>云平台</strong>：提供可靠、安全、易于管理的云服务，支撑上层实现高聚合、松耦合、数据高可用、资源易集成等，再结合微服务方式，将企业核心业务下沉至基础设施中，基于前后端分离的模式，为企业打造敏捷集成、自动化运维的共享平台。</li> \n</ul> \n<h3>AIoT软硬一体</h3> \n<h3>打造面向全场景的万物智联解决方案</h3> \n<p>在数字化进程中， 制造业企业首先需要解决数字接入能力，京东物联网平台包含To C和To B两方面，包括智能家居、智能车联、工业物联、智能地产、智能园区、门店科技六大场景服务，利用云技术、物流、商城等成熟、丰富的技术能力打造全场景IOT服务场景。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321569\" src=\"http://localhost:8060/tup/2020/4/23/bf8cacf4fdf54abea847c008bb58762b.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>京东智联云工业物联网平台包含四个理念：</p> \n<p>1.<strong>全息的感知</strong>：实现从感知、采集、分析、应用，全设备、全链路、全业务的贯通。<br>2.<strong>泛在的连接</strong>：建立设备层、平台侧、用户侧、合作伙伴的泛在的连接生态。<br>3.<strong>开放共享</strong>：打造数据共享平台，同时打造能力开放行业的新业态。<br>4.<strong>融合创新</strong>：融合京东智联云、京东大数据、京东物流、京东AI等相关能力，赋能制造行业智能化发展。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321565\" src=\"http://localhost:8060/tup/2020/4/23/7f518fc9a5cd4e91b15e37a5ff1cb32c.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>通过这四个理念，京东智联云能够将制造业企业设备、数据、流程进行整合，实现数字生态中人、设备、数据的互联与交互，为企业通过数字化技术开发新技术与产品提供数字基础。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321567\" src=\"http://localhost:8060/tup/2020/4/23/393d02ed3b114e1fbe4ff09a80f243fa.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>京东物联管理平台主要有以下技术特点：</p> \n<ul> \n <li> <strong>设备接入</strong>：接入设备品类超过200个，有丰富的物模型管理经验。接入适配层，多协议支持，支持动态数据转换、多种设备配网方案，显著提升了设备接入效率。</li> \n <li> <strong>连接规模</strong>：京东物联平台发展已近5年，已连接设备量级过亿，系统有丰富的百万级高并发处理经验。平台的稳定性和高性能得到过真实检验。</li> \n <li> <strong>松耦合性</strong>：与云平台松耦合，可以快速部署在各类云服务平台之上。物管平台模块间的松耦合，包括平台后台和边缘节点之间，平台后台数据处理组件和设备管理组件之间。</li> \n <li> <strong>开放性</strong>：京东物联管理平台南向具备很强的灵活性，对边缘框架的接入持有开放的态度，支持不同边缘框架的适配接入。北向支持按电力业务场景定制接口。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321568\" src=\"http://localhost:8060/tup/2020/4/23/2bcd11868a9a48728d55b657230e0480.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><em>京东物联中台在国家电网中的应用</em></p> \n<h3>京东AI</h3> \n<h3>清晰全面的人工智能战略布局</h3> \n<p>京东AI基于语音声学、语义、知识图谱、对话、计算机视觉、机器学习这六大能力，针对行业客户提供AI支持与能力。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321570\" src=\"http://localhost:8060/tup/2020/4/23/f8693aac2db34723b6cbd2cff35e6237.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>基于六项核心技术，能够为客户提供人工智能开发与训练平台，为开发人员提供研发环境及工具，结合自身业务进行相关的AI应用探索。京东AI拥有四十余项久经考验的通用API，直接能够为业务使用。客服、零售、市政、医疗四大场景，京东智联云产品及解决方案结合实际业务场景，帮助业务提升的能力。</p> \n<h3>京东智联云</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321573\" src=\"http://localhost:8060/tup/2020/4/23/ab6ce897b71e4be88565da84427087b4.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><em>制造业场景典型云平台架构</em></p> \n<p>在制造行业中，为了保护自身企业数据安全，用户更倾向于使用私有云或专有云平台。为了结合客户实际需求，京东智联云为客户提供了既能保障本地数据安全的私有云方案和同时能够利用京东AI、大数据等线上能力的混合云架构两种方案。</p> \n<p>与生产业务强相关、对数据时效性要求较高的业务系统部署在本地的专有云上，与外界进行物理隔离，保障企业数据安全；本地基础的应用，如物联网平台、私有云平台、生产应用平台则部署在本地的平台。同时搭建了混合云架构，在公有云上做本地数据云上的灾备和冷备，用户可以使用AI、大数据等技术来进行分析和处理，提升生产力、降低能耗，降低整体建设成本。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321572\" src=\"http://localhost:8060/tup/2020/4/23/8aae68e0e957416599528bcf7ebb7cb9.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>京东智联云的专有云平台 JD Cloud Stack 产品，是汇聚了京东在云计算和大数据领域多年技术积累的核心成果之一，包含60 多个云计算平台资源产品，涵盖基础资源、弹性计算、网络、 存储、数据库与缓存、互联网中间件、大数据、混合云、安全、网络流量接入、用户接入、后台管理平台、运维工具等各个层次，并通过统一的 JD Cloud Stack 服务目录向用户提供IaaS、PaaS、SaaS、DaaS、 AIaaS 等通用和定制化的云计算服务。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321571\" src=\"http://localhost:8060/tup/2020/4/23/f5a21c2d24d74d0e87dba77bbec09a93.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><em>JD Cloud Mesh 多云管理</em></p> \n<p><strong>京东智联云安全保护体系</strong></p> \n<p>数据安全保护体系是以合规监管要求和用户业务需求为输入，结合数据安全在人员组织、制度流程、技术保障的执行要求，通过技术工具的使用，贯穿整个数据全生命周期过程域的安全能力建设。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321574\" src=\"http://localhost:8060/tup/2020/4/23/d0a0ab47e1f84a718540de9807d1cf22.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p><strong>点击“<a href=\"https://www.jdcloud.com/cn/products/jdstack?utm_source=PMM_Segmentfault&amp;utm_medium=ReadMore_235&amp;utm_campaign=ReadMore&amp;utm_term=NA\" rel=\"nofollow noreferrer\">阅读</a>”了解京东智联云JDStack 专有云！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321575\" src=\"http://localhost:8060/tup/2020/4/23/078c1adf4c004f93905112be168421fa.jpg\" alt=\"Alt\" title=\"Alt\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321576\" src=\"http://localhost:8060/tup/2020/4/23/067330a260be42a180074c4c63a59262.jpg\" alt=\"Alt\" title=\"Alt\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/e721da17e98a4e298665e26a2002a628.jpg', '1c5851dc916d4e70a60f0c957f548876', 'b299a2a48cd64e77a3431ce958b42055', 'e80d97c3472e428dabdaf417adac7a3c,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-23 10:56:01', '2020-04-23 10:56:01');
INSERT INTO `tb_recommend` VALUES ('33471f208d4e4f6eb4ce68e54ab5e016', 'Android 模拟器支持运行 ARM 应用，Android 11 系统映像可直接将 ARM 指令转换成 x86 指令', '此前，依赖 ARM 库且无法构建 x86 版本应用的开发者只能使用完整的 ARM 模拟系统映像 (其速度远低于在 x86 设备上运行 x86 系统映像) 或者实体机。Android 11 系统映像能够在不影响整个系统的前提下，直接将 ARM ...', '<p>技术编辑：鸣飞转载于<a href=\"https://mp.weixin.qq.com/s/sGGR7vuvLPSaCilrPT6F-g\" rel=\"nofollow noreferrer\">谷歌开发者</a>公众号</p> \n<hr> \n<p>随着 <a href=\"https://segmentfault.com/a/1190000022069857\">Android 11 开发者预览版的发布</a>，我们同时也推出了Android 11 系统映像。新的系统映像在执行 ARM 二进制文件方面取得了显著的性能提升。</p> \n<p>此前，依赖 ARM 库且无法构建 x86 版本应用的开发者只能使用完整的 ARM 模拟系统映像 (其速度远低于在 x86 设备上运行 x86 系统映像) 或者实体机。Android 11 系统映像能够在不影响整个系统的前提下，直接将 ARM 指令转换成 x86 指令。开发者无需搭建高负载的 ARM 环境即可执行 ARM 二进制文件并进行测试。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022298674\" src=\"http://localhost:8060/tup/2020/4/23/6a847510648543bfae53dd408b44b581.jpg\" alt=\"\" title=\"\"></span></p> \n<p>全新的 Android 11 (Google API) x86 系统映像支持 ARM 应用二进制接口 (ABI)，较旧版本的 Android Oreo 系统映像并不提供该支持</p> \n<ul>\n <li>Android 11 系统映像<a href=\"https://developer.android.google.cn/studio/releases/emulator\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> </li>\n</ul> \n<p><strong>技术细节</strong></p> \n<p>我们可能需要结合具体情景来说明这项新技术的重要性，尤其是如果您只使用 Kotlin 或 Java 编程语言来构建应用的话。Kotlin 和 Java 编程语言均在 ART (Android 运行时) 上执行，但 C++ 则与它们不同，Android 应用中的所有 C++ 指令会直接编译为机器指令，也就是说，目标设备的平台架构决定着 C++ 的编译方法。移动手机一般搭载 ARM 处理器，因此，您为应用添加的许多 C++ 依赖项 (例如摄像头条形码扫描库) 仅与 ARM 处理器兼容。在这种情形下，如果您使用基于 x86 处理器的设备进行开发工作，便会遇到应用无法运行的问题。</p> \n<p>过去，开发者需要通过模拟器镜系统映像搭建一个完整的 ARM 环境，才能绕过这个限制并在 x86 机器上执行 ARM 应用。但是，把整个系统的 ARM 指令都转换成 x86 指令会造成过高的性能负荷，因此与基于 x86 的系统映像相比，完整的 ARM 系统映像在 x86 宿主机上的运行速度会慢很多，而且它还无法使用 x86 处理器提供的硬件加速和 CPU 虚拟化技术。</p> \n<p>全新的Android 11 系统映像与 ARM 兼容，它不仅允许整个系统在本机运行 x86 指令，而且还可以照常使用虚拟化技术。当应用的某个进程需要使用 ARM 二进制代码时，代码仅会在该进程内被转换成 x86 指令，其余进程将继续在 x86 环境内执行，包括 Android 运行时 (ART) 以及其它性能关键库，例如libGLES和libvulkan。除此以外，指令转换器也不会执行低层的硬件特定库，从而避免高成本的内存访问检测和相应的性能影响。在 ARM 公司的协作下，新的模拟器系统映像在本地和持续集成框架内均可运行。</p> \n<ul> \n <li>Android 11 系统映像<br><a href=\"https://developer.android.google.cn/studio/releases/emulator\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> </li> \n <li>libGLES <a href=\"https://developer.android.google.cn/ndk/guides/stable_apis#graphics\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> </li> \n <li>libvulkan<p><a href=\"https://developer.android.google.cn/ndk/guides/graphics/design-notes\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> </li> \n</ul> \n<p><strong>下一步</strong></p> \n<p>如果您之前由于缺乏高性能的 ARM 支持，去选择了实体机而非模拟器，不妨尝试一下Android 11 系统映像。此映像文件目前已随 Android 11 开发者预览版一同开放下载。您可通过 SDK Manager 或者Android Virtual Device Manager将最新版本的系统映像下载至 Android Studio。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022298673\" src=\"http://localhost:8060/tup/2020/4/23/a60f0802fc1a48aab0e2811bbd74ac6d.jpg\" alt=\"\" title=\"\"></span></p> \n<p>使用 Android Virtual Device Manager 创建一个运行 Android 11 的 AVD</p> \n<ul> \n <li>Android 11 系统映像<p><a href=\"https://developer.android.google.cn/studio/releases/emulator\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> </li> \n <li>Android Virtual Device Manager&nbsp;<p><a href=\"https://developer.android.google.cn/studio/run/managing-avds#createavd\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> </li> \n</ul> \n<p>一旦应用在模拟器中成功运行后，请考虑适配 Chrome OS。Chrome OS 同样也支持在 x86 笔记本上执行 ARM 版本的 Android 应用。通过构建适用于 Chrome OS 的应用，您可以挖掘大屏幕设备生态圈所蕴含的海量机遇，让全球更多的用户认识您的应用。</p> \n<ul>\n <li>适配 Chrome OS<p><a href=\"https://developer.android.google.cn/topic/arc\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> </li>\n</ul> \n<p>这项技术可以帮助更多开发者在 Android 模拟器上进行测试。我们建议开发者同时构建 x86 和 ARM ABI 两个版本的应用，使其在物理设备上拥有最佳的运行性能并吸引尽可能多的用户。接下来，我们计划在多个 API 级别普及这项技术，同时确保它能和实体机一样支持所有测试用例。欢迎大家向我们提交反馈，帮助我们进一步优化这项新技术。</p> \n<ul>\n <li>提交反馈<p><a href=\"https://issuetracker.google.com/issues?q=componentid:192727%20status:open\" rel=\"nofollow noreferrer\">https://issuetracker.google.com/issues?q=componentid:192727%20status:open</a></p> </li>\n</ul> \n<p><em>请注意: ARM - x86 指令转换技术可用于执行 ARM 公司旗下的产品。该技术只可通过 Google API 和 Play Store 系统映像获取，且仅用于在 x86 台式机、笔记本、客户端本地服务器或自购的云环境上进行应用开发和调试。该技术不可在商用托管服务下使用。</em></p> \n<p><em>Java 是 Oracle 和/或其附属公司的注册商标。</em></p> \n<p>原文链接：<a href=\"https://mp.weixin.qq.com/s/sGGR7vuvLPSaCilrPT6F-g\" rel=\"nofollow noreferrer\">在 Android 模拟器上运行 ARM 应用</a></p>', null, 'http://localhost:8060/tup/2020/4/23/72316301a12f44e8bdbb488de0ee6b16.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '819ad72c1efe450f9d7affc135a4b457', '8dfc62f227ae4076888ea4872e03cddd,9cf3a084c4d94f4da9a6423ab27b8649,6224a68b52f54990a07d51854b320f32', '0', '3', '1', '2020-04-23 10:35:14', '2020-04-23 10:35:14');
INSERT INTO `tb_recommend` VALUES ('33627a3544d94e219b5a453615a009f4', '无需额外工具，又小拍的简单抓包教程', '大家可能都听说过一个名词，“抓包”。比如软件开发前后端联调，调用后端接口无反应，这时我们常常会说：“抓个包看看前端传递的数据吧”。又或者我们的网站接入 CDN 之后，想要看一下网站静态资源的缓存时间和自己设...', '<p>大家可能都听说过一个名词，“抓包”。比如软件开发前后端联调，调用后端接口无反应，这时我们常常会说：“抓个包看看前端传递的数据吧”。又或者我们的网站接入 CDN 之后，想要看一下网站静态资源的缓存时间和自己设置的缓存策略是否一致，也会用到抓包。那什么是抓包呢？</p> \n<p>主机之间的数据通信都是通过网络来进行传输，而将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，就是抓包。</p> \n<p>抓包经常被用来进行数据截取与观察，用于获取 HTTP 标头、内容、大小等信息来进行分析，对判断软件的 Debug 很大的帮助。所以，学会抓包，对于排查一些网络问题十分重要。</p> \n<h2>主流抓包工具对比</h2> \n<p>先来简单看下有哪些常见的抓包工具，主要有下面几种：</p> \n<ul> \n <li>Charles</li> \n <li>Fiddler</li> \n <li>WireShark</li> \n <li>TcpDump</li> \n <li>Chrome Network</li> \n</ul> \n<p>其中目前主流的抓包工具有：TcpDump、WireShark、Fiddler，下面我们对这几个抓包工具的性能进行一些简单的对比。</p> \n<p><strong>1. TcpDump</strong></p> \n<p>Android 平台下的网络数据抓包工具，Android模拟器中自带 TcpDump 文件。</p> \n<p>用 TcpDump 对网络数据抓包，手机不用走代理——将网络数据包添加到 WireShark 中分析即可。</p> \n<p>缺点：</p> \n<ul> \n <li>手机必须获取 root 权限；</li> \n <li>不能查看实时通信数据——因为抓取的是 dump 出来的文件，而不能实时数据交互；</li> \n <li>获取的数据很多，分析时需要过滤出真正有用的信息。</li> \n</ul> \n<p><strong>2. WireShark</strong></p> \n<p>PC 端截获、分析通过该网卡的所有网络通信的数据包（针对移动端时候，就要对移动端设置代理服务器）强大的工具，完整查看网络中的每层、每个协议、每个数据包的详细组成信息；TCP、UDP、HTTP、HTTPS 等协议的数据包均可获取；</p> \n<p>缺点：</p> \n<ul> \n <li>获取的信息太多，需要手动过滤、进行分析。</li> \n <li>只能查看，不能修改、重发送网络数据包。</li> \n</ul> \n<p><strong>3. Fiddler</strong></p> \n<p>HTTP 协议的代理工具，抓取、分析电脑中所有进出该网卡、与网络进行数据交互的数据（针对移动端抓包时，需要设置代理服务器)，主要针对的是 HTTP/HTTPS 协议；能够清晰查看数据包中的内容——HTTPS中的数据包可以解密出来。</p> \n<p>缺点：</p> \n<ul> \n <li>只适用于一次请求，下次请求需要重新设定</li> \n <li>手动修改需要花费时间，如果程序等待超时，本次设定的 Response 结果失效</li> \n</ul> \n<h2>Chrome Network 抓包介绍</h2> \n<p>上文中可以看到主流的抓包工具都或多或少地存在缺点，那有没有一款界面简单、易操作，可以非常方便的查看网页中所有的网络请求，并审核检查单个资源的属性，比如 HTTP 标头、内容、大小等的抓包工具呢？</p> \n<p>Chrome Network 就可以做到。Chrome Network 是属于 Chrome DevTools 套件中的一个调试工具，下面我来对它的使用做一个简单介绍。</p> \n<p>注：本篇教程适用于使用 Chromium 内核的浏览器，Microsoft Edge 和 Firefox 也有类似的控制面板，在此不再赘述。</p> \n<p><strong>如何打开开发者工具面板</strong></p> \n<ol>\n <li>使用快捷键打开。</li>\n</ol> \n<ul> \n <li>Control+Shift+J 或者 F12 (Windows)</li> \n <li>Command+Option+J (Mac)</li> \n</ul> \n<p>2.通过 [更多工具] - [开发者工具] 打开。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228413\" src=\"http://localhost:8060/tup/2020/4/23/b4eedfaeff7f4678b3525af6667e2bb4.jpg\" alt=\"\" title=\"\"></span></p> \n<p>打开开发者工具后，切换到 [Network 面板]，面板的构成可查看下图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228412\" src=\"http://localhost:8060/tup/2020/4/23/bfd99e17585f4fb7be5c233057dbe2b2.jpg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li>控制器：可以开启/关闭 Network 工具的网络活动记录功能，以及其它一些配置选项。</li> \n <li>过滤器：过滤请求列表中显示资源。</li> \n <li>概览：以图形化的方式，显示 HTTP 请求响应的时间轴。</li> \n <li>请求列表：网页中每一个资源请求记录，默认时间排序，点击可查看详细信息。</li> \n <li>概要：包含了当前抓取的请求数，传输大小以及传输耗时等信息</li> \n</ul> \n<p>接下来我们就来认识一下各个模块。</p> \n<p><strong>控制器</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228414\" src=\"http://localhost:8060/tup/2020/4/23/a30d35a0479349fab9dffa31d2fb1a63.jpg\" alt=\"\" title=\"\"></span></p> \n<p>从左至右按钮的功能依次是：</p> \n<ul> \n <li>停止/开始抓包，红色圆圈代表正在抓包；</li> \n <li>清除请求列表中的所有请求；</li> \n <li>屏幕截图；</li> \n <li>隐藏/显示过滤器窗格；</li> \n <li>查找搜索；</li> \n <li>增大请求列表每一行的行高；</li> \n <li>隐藏/显示概览窗格</li> \n <li>按照框架来整合资源</li> \n <li>跨页面加载保存请求</li> \n <li>停用浏览器缓存</li> \n <li>模拟离线访问</li> \n <li>模拟慢网速访问，可自定义网速</li> \n</ul> \n<p>我们简单的来体验一下其中几个功能的使用。</p> \n<p><strong>场景一：</strong>如何模拟在本地没有缓存的情况下访问网页？</p> \n<p>我们可以打开控制器的 [Disable cache] 功能，重新刷新页面，浏览器会模拟不带缓存的请求访问，保证每一个请求都是向网络中发起的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228415\" src=\"http://localhost:8060/tup/2020/4/23/669cd27d350e41f4a2e1066d762638a9.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景二：</strong>请求列表只记录当前页面的访问请求，如果点击了一个超链接，跳转到另一个网页，这样就会清空之前的记录。能否在点击链接跳转之后，依旧保存之前的请求记录呢？</p> \n<p>我们可以打开控制器的 [Preserve log] 功能，这样在点击链接跳转到新的页面后，跳转前的请求记录依旧会保留，方便我们跟踪请求响应。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228416\" src=\"http://localhost:8060/tup/2020/4/23/b8404621a275416baf36da409b61cf9c.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>过滤器</strong></p> \n<p>我们在访问一个网站的时候，可能会有几十个或者上百个请求，这些请求中有些是我们关心的，有些是我们不需要的，这个时候就可以快速的使用过滤器来筛选出我们关心的那些请求。</p> \n<p>过滤器常见的过滤方式就是按类型过滤。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228417\" src=\"http://localhost:8060/tup/2020/4/23/f63c22ec737643bf83ccd2d087673ffc.jpg\" alt=\"\" title=\"\"></span></p> \n<p>默认过滤中已经内置几种类型，比方说我们可以筛选出 JS 类的请求、图片类的请求或者是WebSocket 类型的请求，按住 [Ctrl(Windows)] 或者 [Command(Mac)] 可以同时选择多个过滤类型。<br>那么 [Hide data URLs] 选项是什么意思呢？</p> \n<p>网站开发者很多时候会将一些小的图片或者 CSS 脚本，以 BASE64 格式嵌入到 HTML 中，以减少 HTTP 请求数。当勾选了 Hide data URLs 选项后，就可以隐藏掉请求列表中的像 data: 或者 blob: 类请求。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228418\" src=\"http://localhost:8060/tup/2020/4/23/d686690a8309441cb9e626cc436c7b9e.jpg\" alt=\"\" title=\"\"></span></p> \n<p>除了以上几个 Chrome 提供的过滤器以外，还可以非常灵活的在过滤框中使用过滤属性进行请求日志的筛选。</p> \n<p>常见的过滤属性可参考下表。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228419\" src=\"http://localhost:8060/tup/2020/4/23/98bad62ebec94c1f88b56d217865d808.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景一：</strong>打开又拍云官网的时候，我们想筛选网页中来自于不同域名的请求资源，就可以在过滤框中输入 [domain:] ，Chrome 会帮我们自动补齐相关的域名信息。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228420\" src=\"http://localhost:8060/tup/2020/4/23/0c74a3270bb548c0b29d6fdaa9f216a7.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景二：</strong>打开的网页中，如何查看哪些请求使用了缓存？使用命令 [is:from-cache] </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228421\" src=\"http://localhost:8060/tup/2020/4/23/bed11efc5270457fa7b8a0f622bdf601.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>请求列表</strong></p> \n<p>请求列表默认是按照资源请求发起的时间升序排列的，我们也可以选择按指定列排序，例如 [Waterfall] 列上右键，按照活动时间来进行排序。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228422\" src=\"http://localhost:8060/tup/2020/4/23/91aaa29104c8446b909cab928fd10a9e.jpg\" alt=\"\" title=\"\"></span></p> \n<p>请求列表中默认每列的含义为：</p> \n<ul> \n <li>Name：请求资源的名称</li> \n <li>Status HTTP：状态码</li> \n <li>Type：请求资源的 MIME 类型</li> \n <li>Initiator：发起请求的对象或进程</li> \n <li>Size：服务器返回的响应大小（包括头体和包体），可显示解压后大小</li> \n <li>Time：总持续时间，从请求的开始到接收响应中的最后一个字节</li> \n <li>Waterfall：各请求相关活动的直观分析图</li> \n</ul> \n<p>我们也可以添加其它的一些列目录，在请求列上右键呼出菜单，可看到更多列选项。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228423\" src=\"http://localhost:8060/tup/2020/4/23/d1988fa43006470a91aa27afcbd00ef0.jpg\" alt=\"\" title=\"\"></span></p> \n<p>此外我们也可以配置自定义列，在请求列上右键呼出菜单-Response Headers- Manage Header Columns 中添加想列出的响应头信息。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228425\" src=\"http://localhost:8060/tup/2020/4/23/1271d84faeb54e5b897ee390abaa68f0.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景：</strong>如何自定义显示请求经过了CDN 的哪些节点？</p> \n<p>CDN 会在每一个响应头中添加上Via 响应头，那么我们就可以自定义请求列表显示 Via 列。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228424\" src=\"http://localhost:8060/tup/2020/4/23/12a43613c0bf48ae83b6b0607edb81fc.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>HTTP 请求与响应</strong></p> \n<p>点击请求列表中的具体的请求，则可以打开请求内容详情，在内容详情中我们可以执行以下操作：</p> \n<ul> \n <li>查看 HTTP 请求/响应头部</li> \n <li>查看 cookie</li> \n <li>预览响应正文，例如查看图像</li> \n <li>查看响应正文</li> \n <li>时间详细分布</li> \n <li>将请求数据复制到剪贴板</li> \n <li>查看未压缩的资源大小，Use Large Request Rows</li> \n</ul> \n<p><strong>场景一：</strong>查看请求的响应与请求报文</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228426\" src=\"http://localhost:8060/tup/2020/4/23/676b699bbf694f479c60468a60dc5a03.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景二：</strong>预览图片</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228427\" src=\"http://localhost:8060/tup/2020/4/23/4a51091c019b47ceb007b9848059b148.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景三：</strong>将一个请求导出为 cURL 命令</p> \n<p>在请求上右键呼出菜单，选择 Copy 选项。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228428\" src=\"http://localhost:8060/tup/2020/4/23/f94a12638f6a46e8828644112bd28730.jpg\" alt=\"\" title=\"\"></span></p> \n<p>以上就是对 Chrome 的 Network 面板的介绍，通过一些场景来帮助大家理解使用面板的功能。相比起 Wireshark 等一些网络抓包工具而言，Chrome Network 更为简单易用，查看 HTTP/2 或者 HTTPS 等请求报文也更为方便，对于前端展示或者网络连接产生的一些问题，定位也更为轻松快捷。</p> \n<h6>推荐阅读</h6> \n<p><a href=\"https://www.upyun.com/tech/article/533/IPv6%20%E6%97%B6%E4%BB%A3%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1%20DDoS%20%E6%94%BB%E5%87%BB%EF%BC%9F.html\" rel=\"nofollow noreferrer\">IPv6 时代如何防御 DDoS 攻击？</a></p> \n<p><a href=\"https://www.upyun.com/tech/article/523/%E4%BA%8C%E7%8B%97%E5%AD%90%20%E3%80%81%E5%88%9D%E6%81%8B%E5%8F%8AHTTPS.html\" rel=\"nofollow noreferrer\">二狗子 、初恋及HTTPS</a></p>', null, 'http://localhost:8060/tup/2020/4/23/1b5d6f64109a4408babfba75d0918e29.jpg', '692c6787030d4b8882077b2ab9279c52', 'b299a2a48cd64e77a3431ce958b42055', 'cc944f24ed5e4383a975481674f255e0,81a4561c1c294e0cae32c9fe6b5dc397,db6b58ae709645f2b64166fd73f2f705,a83bf36999c94af989d2d78048df00b8,63c4e1e7ec204b43a62065a3ced4c2ce', '0', '3', '1', '2020-04-23 10:56:18', '2020-04-23 10:56:18');
INSERT INTO `tb_recommend` VALUES ('3e1c29341f89446ca66f2fcda98ce5a2', '低级失误恐酿大祸？NASA 向 AWS 迁移数据，忽略了 3000 万美元的成本...', 'NASA 为了节约时间和资源，选择将数据迁移至 AWS，但做预算的时候却忽略了后续数据下载所需要的费用。初步计算，因为 NASA 庞大的数据使用量，这笔钱将高达 3000 万美元/年。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFB8d\" src=\"http://localhost:8060/tup/2020/4/23/e7b3dad41eaa44839602272385a14e85.jpg\" alt=\"![图片描述\" title=\"![图片描述\"></span></p> \n<p>谁能想到，可能代表了人类最高智力团体的机构，竟然会犯一个看似明显却又相当致命的错误。</p> \n<p>NASA 为了节约时间和资源，选择将数据迁移至 AWS，但做预算的时候却忽略了后续数据下载所需要的费用。初步计算，因为 NASA 庞大的数据使用量，这笔钱将高达 3000 万美元/年。</p> \n<p>按照国外媒体的评价，这一项决策遗漏，让 NASA 的云战略“pointing at the ground rather than at the heavens.”</p> \n<h2>NASA 的数据上云计划</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFB8b\" src=\"http://localhost:8060/tup/2020/4/23/899b28fd9db443d2bad97580fef55008.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>NASA 为了进行相关的科学研究，收集了大量的有关气候和自然地球现象的卫星数据和其他信息，为了管理这些数据，NASA 于 2019 年 7 月 启动了 Earthdata Cloud 项目，致力于将所有的数据上云，存储到分布式存档中心 DAAC（分布式活动存档中心）中。</p> \n<p>目前 NASA 已成立 12 个 DAAC，分布在不同地点（大学，政府机构等）。NASA 的全球水文资源中心分布式活动档案中心（GHRC DAAC）被选为第一个类目，GHRC DAAC 现在与内部部署系统同时在云中运行，数据迁移已接近完成，预计将在 2020 年全面移交。</p> \n<p>去年，NASA 选择了亚马逊云服务（AWS）来托管地球科学和 ESDIS 信息系统的数据。此项计划旨在从与地球观测相关的众多空间任务中收集信息。收集完成后，相应读数将由地球观测系统数据与信息系统（EOSDIS）向各研究机构交付。</p> \n<h2>小失误每年损失 3000 万美元</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFB8B\" src=\"http://localhost:8060/tup/2020/4/23/c7c903f4dda148d6b781244417bcf568.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>NASA 监察长在今年 3 月发布的审计报告中提到：EOSDIS 并没有在这项云端计划当中正确核算数据在出口端被下载产生的费用。</p> \n<p>“目前，当用户访问 DAAC 并从 DAAC 获取数据时，除了维护当前的基础架构之外，NASA 不会付出额外的成本。但是当用户从 Earthdata Cloud 下载数据或上传数据时，代理机构（而不是用户）都将被收取费用。因此，ESDIS 必须承担 12 个 DAAC 的运营成本以及与云相关的运营成本（包括与数据输出相关的成本）。</p> \n<p>也就是说，NASA 终于意识到了，他们之前忽略的一笔庞大费用。</p> \n<p>此前，NASA 与 AWS 达成了 6500 万美元的交易，而根据统计，NASA 每年在数据下载上要额外支付约 3000 万美元。</p> \n<p>最重要的是，该报告发现该项目的组织者在决定购买云服务之前没有进行充分的咨询，没有遵循 NIST 数据完整性标准，并且在内部审核期间没有适当地试图控制成本，而部分原因是这个团队之前大部分的时间都花在具体的项目当中。</p> \n<p>监管机构对此给出的结论是：“总体而言，如果 NASA 出于成本控制的原因而限制了数据输出量，这将带来潜在的风险，即最终用户无法获得科学数据。”</p> \n<p>对此，监管机构对 NASA 提出了三点建议：</p> \n<ol> \n <li>一旦 NISAR 与 SWOT 投入运行并产生足够的数据，NASA 应进行独立分析，以确定支持云迁移和运营同时保持当前 DAAC 足迹的长期财务可持续性；</li> \n <li>结合适当的机构指导，NASA 应在数据管理计划制定期间，协调 ESDIS 和 OCIO 的早期任务生命周期；</li> \n <li>确保在 DAAC 分类期间考虑所有适用的信息类型，确定影响级别和数据使用的前提，并且适当的将分类程序标准化。</li> \n</ol> \n<h2>坎坷的登月计划</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFB8D\" src=\"http://localhost:8060/tup/2020/4/23/fa345a60fe5f4328a1d41dab55064a35.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>NASA 一直致力于让人类在月球定居。在今年最新的研究报告中，NASA 提出了一个基本成型的方案，并且给出了其中的三个关键要素：</p> \n<ol> \n <li>月球地形车（LTV）。机组人员可以使用它来绕月。从本质上讲，这是一辆漫游车，但它没有封闭的座舱，所以宇航员在短途旅行中要穿着全面的防护性舱外活动（EVA）太空服。</li> \n <li>一个可居住的移动平台。它将是一个较大的流动站，被完全容纳并加压，从而可以从航天器着陆点到更远的地方进行更长的行程，一次最多 45 天。</li> \n <li>月球地表栖地。可以在较短的停留时间内充当机组人员的更永久、固定的住所。尽管可居住的机动平台将是地面任务的主要主动住所，但它可以一次容纳多达四名宇航员，而绕月球飞行的 Gateway 空间站将是不从事主动地面探索和科学工作的机组人员的主要行动基地。</li> \n</ol> \n<p>NASA 之前已经公布将在 2024 年将两名宇航员送上月球，一个月前开始的太空人训练班已经从 1.2万个候选人中做完了最终筛选。但因为疫情的影响，此前就已经宣布计划将被推迟，再加上此次的财务问题，估计 NASA 的下次登月真的遥遥无期了...</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFxVM\" src=\"http://localhost:8060/tup/2020/4/23/15db7e515f9840248bc60fa459a1b8ba.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/10895473db6847fda1c76306bc2ca75d.jpg', 'f53014d680884163a5bd5ce762e90cdf', 'b299a2a48cd64e77a3431ce958b42055', 'f831bc1c03f94b4b9e49390a3a354a3e,ba16f5b739f24380990a4ccacfe6f833', '0', '3', '1', '2020-04-23 10:56:14', '2020-04-23 10:56:14');
INSERT INTO `tb_recommend` VALUES ('40176d1fe34a463098963c8191ce26ed', '折腾 2 年多！我们终于见面了！', '2018年3月，我与张老师就这么在微信上聊了起来，起初我并没有写书的打算，我们之间只是通过讨论、交流的形式聊聊关于出书的方方面面。最终，敌不过张老师超强的专业能力、细致的解说与盛情相邀，我答应张老师写一...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022434352\" src=\"http://localhost:8060/tup/2020/4/23/b7c3a4c1dc7b437ca3206ed6450f9a0c.jpg\" alt=\"\" title=\"\"></span></p> \n<p>2018年3月，我与张老师就这么在微信上聊了起来，起初我并没有写书的打算，我们之间只是通过讨论、交流的形式聊聊关于出书的方方面面。最终，敌不过张老师超强的专业能力、细致的解说与盛情相邀，我答应张老师写一本<strong>Linux系统运维</strong>的图书并由人邮出版。由此，我踏上了漫漫2年多的写书之路。</p> \n<p><strong>为什么写这本书</strong></p> \n<p>写书一方面是我对自己所学知识的查漏补缺过程，另一方面也可以<strong>向即将进入或已经入行的Linux系统运维同行们分享一些经验，以便他们在学习的路上少走一些弯路，对企业实际环境的运维工作有一个完整而清晰的认识，从而更快地进入企业运维工程</strong><strong>师的角色。</strong></p> \n<p>其实，我公众号中的老读者都知道，我是半路出家自学的Linux系统运维，一路上磕磕绊绊、跌跌撞撞，最终算是“小有所成”（自我感觉还是学到与得到了一些），能糊一口饭吃，能够保一家温饱。</p> \n<p>回想起自学的那段经历，我至今难忘，挺苦逼的，那时互联网没有这么发达，查找资料也没有现在这么方便、丰富，很多时候只有靠自己看官方资料去慢慢摸索，一个错误几小时、几天可能都难以解决，然后通过不断地总结、再反复练习，方能掌握一个个知识点。</p> \n<p><strong>还有一个苦</strong>，就是如果你的基础功底不扎实，有时请教别人问题，你都很难将问题描述清楚，别人也很难从你的只言片语中看出你的问题所在，久而久之，不再有人愿意为你解答或提供解答思路。当下，这种情况仍然存在于众多初学者身上，他们总喜欢跳跃式学习，没能重视到学习是一个进阶的过程。这里给大家推荐一下我总结的一些学习方法：<a href=\"http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;mid=2247491161&amp;idx=2&amp;sn=3a12a4fdd41ab0dc9cfbc48e6c62e3f4&amp;chksm=e91b7b45de6cf253bcf7cd5729e5963ca5f85ba1cbe3e2d61c7a9d18b359fc43887a08ee1aa0&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">民工哥自学方法</a>。</p> \n<p><strong>学习与实践总归是不同的</strong>。企业里的实际生产运维环境可不是你我能练手的地方，所以，从虚拟机中的练习到企业实际环境的运用，这是一个<strong>将学到的知识转化成操作与运用的过程，</strong>很多人难以适应一时的转变。这使得很多人在学习的时候感觉自己都会了，但一到企业实际生产环境操作时就慌。</p> \n<p>其实这是一个正常现象，民工哥也是这么过来的。不怕出错，怕的是不出错，出错、排错是一个学习的过程，也是一个自我检验的过程，更是一个加深理解的过程。<strong>一段时间后，你会发现很多知识点就这样在无形当中学到了、学会了。</strong>久而久之，你会发现这真的是一件很有成就感的事！</p> \n<p>基于以上的原因，我决心将自己自学的过程以及工作经验总结成书。</p> \n<p><strong>写书的过程</strong></p> \n<p>很多人不知道写一本书所需的巨大的工作量！这里我稍稍科普一下：</p> \n<p>1、确定选题方向——出版社审核——审核通过后签合同。</p> \n<p>2、开始写作，其实在这之前，有很大一部分工作量是编写全书的大纲，只有把整个大纲确定了，你才好下笔。</p> \n<p>3、分段交稿，这期间编辑会不断将审稿老师的建议反馈给作者，提醒作者后续写作过程中注意避免某些问题，比如：文字口语化严重、标题不可出现4级标题、图表不规范等。</p> \n<p>4、全部交稿后，书稿会进入三审三校阶段，在三审期间，可能随时需要作者修改，大到章节安排，小到词句的准确性。这是我和张老师两年来沟通最频繁的时候，有时还起有争议，毕竟双方看待问题的角度不同，但我们的目标是一致的——为了出版一本质量过硬的好书，所以我们最终还是会达成统一的意见。我已经数不清反复修改了多少回，只记得很多次，其中有合并章节、修改格式、统一用法，等等。</p> \n<p>5、最终阶段就是确定定价、下厂印刷与销售了。</p> \n<p>看似很简单顺畅的过程，这其中工作量其实很大，有太多琐碎、繁杂的事。在整个写作过程中，民工哥尽可能地将每一个知识点都表达清楚，所以一直有如履薄冰之感。虽然<strong>很苦、很累、很闹心，但看到这本书出版，心里还是会有满满的成就感！</strong></p> \n<p><strong>今天这本书终于要与大家见面了！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022434351\" src=\"http://localhost:8060/tup/2020/4/23/9b9bb6748bb840cbb1874538d79c5498.jpg\" alt=\"\" title=\"\"></span></p> \n<p>在此，感谢<strong>优维科技CEO王总、Segmentfault思否社区的CTO祁总、新钛云服的架构师胥峰（排名不分先后）</strong>在百忙之中抽空为本书写推荐语！</p> \n<blockquote>\n 本书结构清晰，从最基本的Linux系统和命令开始，深入到上层常用中间件服务的运维，如Keepalived、Mysql、Apache、Nginx等，再深入到高阶服务的运维管理。作者利用大量的篇幅重点介绍了常用的运维工具和服务，如Zabbix、SCM、容器技术、配置管理和日志服务等。全书内容全面，由浅入深，十分适合作为手边的实战参考书。希望本书能帮助你成为一名Linux运维专家！\n <p>——精益运维发起人，优维科技CEO王津银</p> \n <p>民工哥是SegmentFault社区非常活跃的技术专家，也是社区2019年度的“TopWriter”。Linux运维的相关知识非常繁杂，民工哥结合自己的日常经验，从基础命令入手，选择了常用的服务配置作为实战部分，讲解深入浅出，为读者从入门到精通Linux运维指明了一条路。</p> \n <p>——思否（SegmentFault）CTO，Typecho开源项目作者</p> \n <p>祁宁</p> \n <p>民工哥一直活跃在运维圈中，并运营微信公众号“民工哥技术之路”，为运维技术的传播和发展做出了积极的贡献。这本新作值得每一位运维人员收藏和细读。本书从Linux运维入门开始讲起，循序渐进地过渡到企业级运维实战，包括常见的基础应用环境的搭建、数据库系统管理、集群管理等。更难能可贵的是，本书最后还重点介绍了数据备份和运维管理实战。我从这本书中获益良多，也相信它能给你带来一些新的想法和收获。</p> \n <p>——新钛云服首席解决方案架构师，</p> \n <p>《Linux系统安全：纵深防御、安全扫描与入侵检测》作者胥峰</p> \n</blockquote> \n<p>最后，<strong>要感谢我公众号的读者们</strong>，你们一直以来的关注与支持是我写作的最大动力。很多读者私信我，说看了我之前写的运维相关的文章，学习到了很多，并表示感谢，我真的很感动。</p> \n<p><strong>下面进入正题，</strong>今天我要为自己代言，为新书宣传一下，本书目前正在火热销售中！<strong>现正值4.23活动，有超低折扣！</strong>各位读者伙伴们，<strong>抓紧时间扫码订购吧</strong>！感谢支持！！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGimq\" src=\"http://localhost:8060/tup/2020/4/23/a6e17ffb199d4719b93059f1e0184ff0.jpg\" alt=\"京东自营.png\" title=\"京东自营.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/08a705f9562e4cefaa56b703320a3c27.jpg', '6fbfa4aaad3a43458f21c8acf0038ac5', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'd7416e100af54eb7a4d9274b9a462240,753b5aee3913424e81fe2b5299626d8c,81a4561c1c294e0cae32c9fe6b5dc397,55723db96b9f4593bae02bc1e49f1e87,83f62facb3b943ffa8e46abd1ebc64d9', '0', '3', '1', '2020-04-23 10:28:22', '2020-04-23 10:28:22');
INSERT INTO `tb_recommend` VALUES ('40d522b17da94c4d9b8ab9f9cd1acd2f', '送你 13 款高逼格且实用的 Linux 运维必备工具，拿好了', '本文介绍几款 Linux 运维比较实用的工具，希望对 Linux 运维人员有所帮助。本文出自 “求知无坦途，学问无捷径！” 博客 1. 查看进程占用带宽情况 - Nethogs Nethogs 是一个终端下的网络流量监控工具可以直观的显示...', '<p>本文介绍几款 Linux 运维比较实用的工具，希望对 Linux 运维人员有所帮助。本文出自 “求知无坦途，学问无捷径！” 博客</p> \n<h4>1. 查看进程占用带宽情况 - Nethogs</h4> \n<p>Nethogs 是一个终端下的网络流量监控工具可以直观的显示每个进程占用的带宽。</p> \n<blockquote>\n 下载：\n <a href=\"http://sourceforge.net/projects/nethogs/files/nethogs/0.8/nethogs-0.8.0.tar.gz/download\" rel=\"nofollow noreferrer\">http://sourceforge.net/projec...</a> \n</blockquote> \n<p><code>[root@localhost ~]#yum &nbsp;-y install libpcap-devel &nbsp;ncurses-devel</code></p> \n<p><code>[root@localhost ~]# tar zxvf nethogs-0.8.0.tar.gz</code></p> \n<p><code>[root@localhost ~]# cd nethogs</code></p> \n<p><code>[root@localhost nethogs]# make &amp;&amp; make install</code></p> \n<p><code>[root@localhost nethogs]# nethogs eth0</code></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022434318\" src=\"http://localhost:8060/tup/2020/4/23/bfc3d69b0d6942309fa4b639300425a9.jpg\" alt=\"\" title=\"\"></span></p> \n<h4>2. 硬盘读取性能测试 - IOZone</h4> \n<hr> \n<p>IOZone 是一款 Linux 文件系统性能测试工具 可以测试不同的操作系统中文件系统的读写性能。</p> \n<blockquote>\n 下载：\n <a href=\"http://www.iozone.org/src/current/\" rel=\"nofollow noreferrer\">http://www.iozone.org/src/cur...</a> \n</blockquote> \n<p><code>[root@localhost current]# tar xvf iozone3_420.tar</code></p> \n<p><code>[root@localhost ~]# cd iozone3_420/src/current/</code></p> \n<p><code>[root@localhost current]# make linux</code></p> \n<p><code>[root@localhost current]# ./iozone -a -n 512m -g 16g -i 0 -i 1 -i 5 -f /mnt/iozone -Rb ./iozone.xls</code></p> \n<p>-a 使用全自动模式</p> \n<p>-n 为自动模式设置最小文件大小 (Kbytes)。</p> \n<p>-g 设置自动模式可使用的最大文件大小 Kbytes。</p> \n<p>-i 用来指定运行哪个测试。</p> \n<p>-f 指定测试文件的名字完成后自动删除</p> \n<p>-R 产生 Excel 到标准输出</p> \n<p>-b 指定输出到指定文件上</p> \n<h4>3.实时监控磁盘 IO-IOTop</h4> \n<hr> \n<p>IOTop 命令是专门显示硬盘 IO 的命令, 界面风格类似 top 命令。</p> \n<p><code>[root@localhost ~]# yum -y install iotop</code></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022434319\" src=\"http://localhost:8060/tup/2020/4/23/35c3b1b0f22b4718a114763f57ec6cc4.jpg\" alt=\"\" title=\"\"></span></p> \n<h4>4. 网络流量监控 - IPtraf</h4> \n<hr> \n<p>IPtraf 是一个运行在 Linux 下的简单的网络状况分析工具。</p> \n<p><code>[root@localhost ~]# yum -y install iptraf</code></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022434320\" src=\"http://localhost:8060/tup/2020/4/23/3cf76056da004b2f8257b6b9197bb8a4.jpg\" alt=\"\" title=\"\"></span></p> \n<h4>5.网络流量监控 - IFTop</h4> \n<hr> \n<p>iftop 是类似于 linux 下面 top 的实时流量监控工具。比 iptraf 直观些。</p> \n<p>下载：<a href=\"http://www.ex-parrot.com/~pdw/iftop/\" rel=\"nofollow noreferrer\">http://www.ex-parrot.com/~pdw...</a></p> \n<pre><code>\n [root@localhost ~]# tar zxvf iftop-0.17.tar.gz\n    \n[root@localhost ~]# cd iftop-0.17\n    \n[root@localhost iftop-0.17]# ./configure\n    \n[root@localhost iftop-0.17]# make &amp;&amp; make install\n    \n[root@localhost iftop-0.17]# iftop\n    \n[root@localhost iftop-0.17]# iftop -i eth0 &nbsp;\n# 指定监控网卡接口`\n    </code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022434321\" src=\"http://localhost:8060/tup/2020/4/23/cb933d1c084c4d6881214aca651b1eaf.jpg\" alt=\"\" title=\"\"></span></p> \n<p>TX：发送流量</p> \n<p>RX：接收流量</p> \n<p>TOTAL：总流量</p> \n<p>Cumm：运行 iftop 到目前时间的总流量</p> \n<p>peak：流量峰值</p> \n<p>rates：分别表示过去 2s 10s 40s 的平均流量</p> \n<h4>6. 进程实时监控 - HTop</h4> \n<hr> \n<p>HTop 是一个 Linux 下的交互式的进程浏览器可以用来替换 Linux 下的 top 命令。</p> \n<p>rpm -ivh&nbsp;<a href=\"http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.2-2.el6.rf.x86\" rel=\"nofollow noreferrer\">http://pkgs.repoforge.org/rpm...</a>_64.rpm（安装第三方 YUM 源）</p> \n<p><code>[root@localhost ~]# yum -y install htop</code></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022434322\" src=\"http://localhost:8060/tup/2020/4/23/7a95b0e5cfa344568d66ebd65899e21f.jpg\" alt=\"\" title=\"\"></span></p> \n<h4>7. 系统资源监控 - NMON</h4> \n<hr> \n<p>NMON 是一种在 AIX 与各种 Linux 操作系统上广泛使用的监控与分析工具</p> \n<p>下载：<a href=\"http://sourceforge.jp/projects/sfnet_nmon/releases/\" rel=\"nofollow noreferrer\">http://sourceforge.jp/project...</a></p> \n<pre><code>[root@localhost ~]# chmod +x nmon_x86_64_rhel6 \n    \n[root@localhost ~]# mv nmon_x86_64_rhel6 /usr/sbin/nmon\n    \n[root@localhost ~]# nmon\n    </code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022434323\" src=\"http://localhost:8060/tup/2020/4/23/4ce4def918f74856bbe24ad5baf9f85e.jpg\" alt=\"\" title=\"\"></span></p> \n<h4>8.&nbsp;监控多个日志 - MultiTail</h4> \n<hr> \n<p>MultiTail 是在控制台打开多个窗口用来实现同时监控多个日志文档、类似 tail 命令的功能的软件。</p> \n<p>rpm -ivh&nbsp;<a href=\"http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.2-2.el6.rf.x86_64.rpm\" rel=\"nofollow noreferrer\">http://pkgs.repoforge.org/rpm...</a>&nbsp;（安装第三方 YUM 源）</p> \n<pre><code>[root@localhost ~]# yum -y install &nbsp;multitail\n    \n[root@localhost ~]# multitail -e \"fail\" /var/log/secure\n#筛选关键字进行监控\n    \n[root@localhost ~]# multitail -l \"ping baidu.com\" \n#监控后面的命令 - l 将要执行的命令\n    \n[root@localhost ~]# multitail -i /var/log/messages -i /var/log/secure \n#-i 指定一个文件名</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022434325\" src=\"http://localhost:8060/tup/2020/4/23/1f70c94dbf2e4f9ea1c481e25667431e.jpg\" alt=\"\" title=\"\"></span></p> \n<h4>9. SSH 暴力破解防护 - Fail2ban</h4> \n<hr> \n<p>Fail2ban 可以监视你的系统日志然后匹配日志的错误信息正则式匹配执行相应的屏蔽动作一般情况下是调用防火墙屏蔽</p> \n<p>下载：<a href=\"http://www.fail2ban.org/wiki/index.php/Downloads\" rel=\"nofollow noreferrer\">http://www.fail2ban.org/wiki/...</a></p> \n<pre><code>\n[root@localhost ~]# cd fail2ban-0.8.11\n    \n[root@localhost fail2ban-0.8.11]# python setup.py install\n    \n[root@localhost fail2ban-0.8.11]# cd files/\n    \n[root@localhost files]# cp ./redhat-initd /etc/init.d/fail2ban\n    \n[root@localhost files]# service fail2ban start\n    \n[root@localhost files]# chkconfig --add fail2ban\n    \n[root@localhost files]# chkconfig fail2ban on\n    </code></pre> \n<p>注：需要配置 iptables 实用，如果重启 iptables 了也要重启 fail2ban，因为 fail2ban 的原理是调用 iptables 实时阻挡外界的攻击。</p> \n<pre><code>[root@localhost ~]# grep -v \"^#\" /etc/fail2ban/jail.conf | grep -v \"^$\"\n    \n[DEFAULT]\n    \nignoreip = 127.0.0.1/8\n#忽略本机 IP  \nbantime &nbsp;= 600  \n#符合规则后封锁时间\nfindtime &nbsp;= 600 \n# 在多长时间内符合规则执行封锁如 600 秒达到 3 次则执行\n    \nmaxretry = 3 # 最大尝试次数\n    \nbackend = auto  #日志修改检测日志 gamin、polling 和 auto 这三种\n    \nusedns = warn\n    \n[ssh-iptables]\n    \nenabled &nbsp;= true# 默认是禁用 false\n    \nfilter &nbsp; = sshd\n\naction &nbsp; = iptables[name=SSH, port=ssh, protocol=tcp]\n    \n# sendmail-whois[name=SSH,dest = 收件人邮箱, sender = 发件人邮箱, sendername=\"Fail2Ban\"]\n    \nlogpath &nbsp;= /var/log/sshd.log &nbsp;# 响应的错误日志一般在 / var/log/secure\n    \nmaxretry = 5 # 尝试错误次数覆盖全局中的 maxretry\n    </code></pre> \n<p>注：默认所有的应用防护都是关闭的，需要我们手动开启。fail2ban.conf 文件是日志信息，jail.conf 文件是保护的具体服务和动作配置信息。</p> \n<pre><code>\n[root@localhost ~]# touch /var/log/sshd.log\n    \n[root@localhost ~]# service fail2ban restart\n    \n[root@localhost ~]# fail2ban-client status &nbsp; &nbsp;\n# 查看监控已经开启 \n    \nStatus   \n|- Number of jail:1    \n- Jail list: &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; ssh-iptables    \n[root@localhost ~]# iptables -L &nbsp;\n#iptables 过滤表有 fail2ban 一条规则`     \nfail2ban-SSH &nbsp;tcp &nbsp;-- &nbsp;anywhere &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; anywhere &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;tcp dpt:ssh    \n</code></pre> \n<h4>10. 连接会话终端持续化 - Tmux</h4> \n<hr> \n<p>Tmux 是一个优秀的终端复用软件类似 GNU Screen 比 Screen 更加方面、灵活和高效。为了确保连接 SSH 时掉线不影响任务运行。</p> \n<p>rpm -ivh&nbsp;<a href=\"http://pkgs.repoforge.org/rpmforge-release/rpmforge-release-0.5.2-2.el6.rf.x86\" rel=\"nofollow noreferrer\">http://pkgs.repoforge.org/rpm...</a>_64.rpm（安装第三方 YUM 源）</p> \n<h4>11.&nbsp;页面显示磁盘空间使用情况 - Agedu</h4> \n<hr> \n<p>下载：<a href=\"http://www.chiark.greenend.org.uk/~sgtatham/agedu/\" rel=\"nofollow noreferrer\">http://www.chiark.greenend.or...</a></p> \n<pre><code>[root@localhost ~]# tar zxvf agedu-r9723.tar.gz\n    \n[root@localhost ~]# cd agedu-r9723\n    \n[root@localhost ~]# ./configure\n    \n[root@localhost ~]# make &amp;&amp; make install\n    \n[root@localhost ~]# agedu -s / &nbsp; &nbsp;#-s 扫描\n    \n[root@localhost ~]# agedu -w --address 192.168.0.10:80 #-w 输入一个网页链接\n    \n[root@localhost ~]# agedu -w --address 192.168.0.108080 --auth none\n#--auth 关闭认证如果不加端口号会生成一个随机的用浏览器访问\n    \n</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022434324\" src=\"http://localhost:8060/tup/2020/4/23/d006f67bcaeb42cebbf5d4378f6dc62f.jpg\" alt=\"\" title=\"\"></span></p> \n<h4>12. 安全扫描工具 - NMap</h4> \n<hr> \n<p>NMap 是 Linux 下的网络连接扫描和嗅探工具包用来扫描网上电脑开放的网络连接端。</p> \n<p>下载：<a href=\"http://nmap.org/download.html\" rel=\"nofollow noreferrer\">http://nmap.org/download.html</a></p> \n<pre><code>[root@localhost ~]# tar jxvf nmap-6.40.tar.bz2 \n\n[root@localhost nmap-6.40]# ./configure \n\n[root@localhost nmap-6.40]# make &amp;&amp; make install \n\n[root@localhost ~]# nmap 192.168.0.10\n#获取基本信息 \n\n[root@localhost ~]# nmap -O 192.168.0.10\n#获取系统版本信息 \n\n[root@localhost ~]# nmap -A 192.168.0.10\n#获取系统综合信息 \n\n[root@localhost ~]# nmap 192.168.0.0/24\n# 获取一个网段工作设备基本信息</code></pre> \n<p>-sSTCP 扫描</p> \n<p>-sV 系统版本检测</p> \n<ul>\n <li></li>\n</ul> \n<h2>13.Web 压力测试 - Httperf</h2> \n<p>Httperf 比 ab 更强大，能测试出 web 服务能承载的最大服务量及发现潜在问题；比如：内存使用、稳定性。最大优势：可以指定规律进行压力测试，模拟真实环境。</p> \n<p>下载：<a href=\"http://code.google.com/p/httperf/downloads/list\" rel=\"nofollow noreferrer\">http://code.google.com/p/http...</a></p> \n<ol> \n <li><code>[root@localhost ~]# tar zxvf httperf-0.9.0.tar.gz</code></li> \n <li><code>[root@localhost ~]# cd httperf-0.9.0</code></li> \n <li><code>[root@localhost httperf-0.9.0]# ./configure</code></li> \n <li><code>[root@localhost httperf-0.9.0]# make &amp;&amp; make install</code></li> \n <li><code>[root@localhost ~]# httperf --hog --server=192.168.0.202 --uri=/index.html --num-conns=10000 --wsess=10,10,0.1</code></li> \n</ol> \n<p><strong>参数说明：</strong></p> \n<p>--hog：让 httperf 尽可能多产生连接，httperf 会根据硬件配置，有规律的产生访问连接</p> \n<p>--num-conns：连接数量，总发起 10000 请求</p> \n<p>--wsess： 用户打开网页时间规律模拟，第一个 10 表示产生 10 个会话连接，第二个 10 表示每个会话连接进行 10 次请求，0.1 表示每个会话连接请求之间的间隔时间 / s</p>', null, 'http://localhost:8060/tup/2020/4/23/c5e3eabf0b3248c28514516978f0fcfd.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', 'bb0b7e69ad3e46fcb121baefda8f1f78', '753b5aee3913424e81fe2b5299626d8c,d7416e100af54eb7a4d9274b9a462240,81a4561c1c294e0cae32c9fe6b5dc397,55723db96b9f4593bae02bc1e49f1e87,77a7bd638e0a45ec84569ef6b79325c1', '0', '3', '1', '2020-04-23 10:28:23', '2020-04-23 10:28:23');
INSERT INTO `tb_recommend` VALUES ('433310e55cbb44049c7e0792b091deda', '有了这款产品，APP实现秒级登录不是梦！用户：极度舒适', '近年来，验证领域迎来一个黑科技——用户在APP上进行账号注册或者号码绑定时，不需要接收短信验证码，直接可以以本机号码实现秒级验证。这种新颖且便捷的验证方式称为“一键认证”。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021911803\" src=\"http://localhost:8060/tup/2020/4/23/7b38f1c765c64e7f9c23dbf7f8cd2eb3.jpg\" alt=\"\" title=\"\"></span></p> \n<p>近年来，验证领域迎来一个黑科技——用户在APP上进行账号注册或者号码绑定时，不需要接收短信验证码，直接可以以本机号码实现秒级验证。这种新颖且便捷的验证方式称为“一键认证”。</p> \n<p>一键认证大幅度地简化了用户注册/登录流程，且提升了账号安全性，逐步成为新一代的主流验证登录方式。<strong>什么是一键认证，它的实现条件是什么，又有哪些功能优势呢</strong>？接下来，个推君将为大家一一解答。</p> \n<h1>一、什么是一键认证</h1> \n<p>一键认证是依托运营商的移动数据网络，采用“通信网关取号”及SIM卡识别等技术实现的一种移动互联网身份认证方法。</p> \n<p>它主要有两个形式，一是“<strong>一键登录</strong>”，一键登录具备授权页面，APP开发者经用户授权后可获得号码，适用于注册、登录等场景；二是“<strong>本机号码校验</strong>”，本机号码校验不返回号码，仅返回待校验号码与本机号码是否一致的结果，适用于基于手机号码的安全风控场景。</p> \n<p>对于用户来说，无论是一键登录还是本机号码校验，都无需经历输入密码或者等待短信验证码的过程，可以真正体验到“秒级验证”的快感。</p> \n<h1>二、一键认证的能力优势</h1> \n<p>传统的验证登录方式，如“手机+验证码”登录，存在登录时间长、短信验证码接收慢等问题。而现在较为普及的第三方帐号登录，表面简化了流程，但多数APP会在用户授权后要求捆绑手机号码，不仅未能缩短用户登录时长，还容易造成“一人多号”的情况。</p> \n<p>区别于以上几种验证方式，一键认证的主要优势在于：</p> \n<ol> \n <li> <strong>简化了注册/登录的流程</strong>，减少了用户的等待时间；</li> \n <li> <strong>避免出现短信验证码收不到或接收慢的问题</strong>，优化用户体验；</li> \n <li> <strong>降低了注册/登录门槛</strong>，用户不必为记忆各种账号和密码而困扰，提升了注册登录率。</li> \n</ol> \n<h1>三、一键认证的实现条件</h1> \n<p>由于运营商的取号能力是通过数据网关实现的，在手机未打开流量或未插入SIM卡的情况下，运营商无法进行取号。</p> \n<p>“一键认证”的基本实现条件如下：</p> \n<ol> \n <li> <strong>需要打开数据网络</strong>，目前支持的网络环境是：移动：2G、3G、4G；联通：3G、4G；电信：4G；</li> \n <li>手机需<strong>插入SIM卡</strong>，且通话和网络的SIM卡必须为同一张卡，否则会导致验证失败；</li> \n <li>对于wifi环境，在数据网络开通的情况下，会使用数据网络触发网关请求，若未开通则无法校验；</li> \n <li> <strong>支持双卡手机</strong>，以开启数据流量的SIM卡进行认证。</li> \n</ol> \n<p>APP可自定义预登录操作（如用户点击“我要登录”、进入个人中心“我的”等）提前判断用户当前网络环境是否支持一键登录，若不支持，可向用户切换其他登录方式。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021911804\" src=\"http://localhost:8060/tup/2020/4/23/9f33c7791e5443c8a52b4a3229d344e0.jpg\" alt=\"\" title=\"\"></span></p> \n<h1>四、个推“一键认证”SDK</h1> \n<p>个推作为深耕移动互联网领域多年的数据智能服务商，在持续打磨开发者服务的道路上从未停歇。个推面向开发者推出的“一键认证”产品——个验，旨在通过专业的技术和服务，帮助开发者简化APP登录流程，有效减少用户流失，大幅度提升用户转化与帐号安全。</p> \n<p>个验不仅整合了三大运营商的网关认证能力，并且兼容iOS和Android智能手机，覆盖了全网用户，大幅提升了用户的验证通过率。此外，个验为用户首次登录APP提供了畅通无阻的通道，帮助用户迅速与APP建立起连接。</p> \n<p>最重要的一点是，个验兼备<strong>反欺诈能力和动画验证码</strong>的功能，可以帮助APP开发者有效识别风险设备、保障业务安全。</p> \n<h2>1. 反欺诈能力</h2> \n<p>依托个推海量的数据沉淀和强大的算法建模能力，个验SDK创建了反欺诈防护体系，并设置了数千个指标、数百个风控规则，旨在帮助APP开发者全面提升大数据风控能力。</p> \n<p>APP开发者可以根据个验构建的反欺诈模型有效识别和评估各种作弊行为和风险设备，针对不同风险等级的设备实施不同的应对和防护措施，实现业务安全和账号安全双保障。</p> \n<h2>2. 动画验证码</h2> \n<p>动画验证码可以有效区分人类和机器，可用于防范短信轰炸、机器秒杀、评论注水、在线刷票等场景。</p> \n<p>目前动画验证码有两种模式：智能无感模式和动画验证模式。前者会智能判定设备风险等级，可信设备无感验证通过，怀疑设备则弹出动画验证码进行校验；而后者对所有设备都会进行动画验证。动画验证码的展现形式丰富，可通过图层叠加、控制播放速度等措施迷惑攻击者，大幅度保障设备的安全性。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021911805\" src=\"http://localhost:8060/tup/2020/4/23/4bfa32dc3e92405babc4b237148a0461.jpg\" alt=\"\" title=\"\"></span></p> \n<p>对于APP开发者来说，“一键认证”产品免去了诸如短信验证、输入密码等复杂的交互环节的设计过程，是APP增加用户黏性、提高留存的有效工具。更重要的是，基于个推海量数据积累和强大的分析能力，“一键认证”具备了强大的“反欺诈能力”，这为APP识别风险设备、保障业务安全提供了强有力的支撑。</p> \n<p>相信在不久的未来，随着5G的全面普及和大数据的不断加持，这种新型的技术会成为APP稳步健康发展的利器。</p>', null, 'http://localhost:8060/tup/2020/4/23/d43f4130a573412cbb4594f672682249.jpg', '6fbfa4aaad3a43458f21c8acf0038ac5', 'a337904dd1d5477b9689d7693be316de', 'b7460efd3f3b4d6ea78254959a2aebff,8dfc62f227ae4076888ea4872e03cddd,85ee959b27f74072b13cc763b9bbf77e', '0', '3', '1', '2020-04-23 10:32:04', '2020-04-23 10:32:04');
INSERT INTO `tb_recommend` VALUES ('45c10a5a1dcd498a8c22e3886e203176', '[宝宝也能看懂的活动篇][30-Day LeetCoding Challenge] 第十天', '最小栈 Hi 大家好，我是张小猪。欢迎来到『宝宝也能看懂』系列特别篇 - 官方小活动 『30-Day LeetCoding Challenge』。 这里是 4 月 10 号的题，也是题目列表中的第 155 题 -- 『最小栈』 题目描述 设计一个支持 ...', '<h1>最小栈</h1> \n<p>Hi 大家好，我是张小猪。欢迎来到『宝宝也能看懂』系列特别篇 - 官方小活动 『30-Day LeetCoding Challenge』。</p> \n<p>这里是 4 月 10 号的题，也是题目列表中的第 155 题 -- 『最小栈』</p> \n<h2>题目描述</h2> \n<p>设计一个支持 <code>push</code>，<code>pop</code>，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p> \n<ul> \n <li> <code>push(x)</code> —— 将元素 x 推入栈中。</li> \n <li> <code>pop()</code> —— 删除栈顶的元素。</li> \n <li> <code>top()</code> —— 获取栈顶元素。</li> \n <li> <code>getMin()</code> —— 检索栈中的最小元素。</li> \n</ul> \n<p>示例:</p> \n<pre><code class=\"shell\">MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.getMin();   --&gt; 返回 -2.</code></pre> \n<h2>官方难度</h2> \n<p>EASY</p> \n<h2>解决思路</h2> \n<p>题目要求很简单，就是要封装一个叫做 <code>MinStack</code> 的类，几个操作都是普通的栈操作，不过多了一个返回最小的元素值。由于原生 JS 的 <code>Array</code> 就集合了队列和栈的操作行为，所以我们可以直接基于它来实现。</p> \n<h3>直接方案</h3> \n<p>直接基于原生的 <code>Array</code> 来实现栈的操作，另外我们用一个变量来记录栈内数据的最小值。这里小猪用一个 <code>_top</code> 指针来标识栈顶的位置，从而避免数据的擦除开销和数组动态缩短的开销，另外在每一次 <code>pop</code> 的时候通过遍历去更新记录的最小值。具体代码如下：</p> \n<pre><code class=\"js\">class MinStack {\n  constructor() {\n    this._top = -1;\n    this.data = [];\n    this.min = Number.MAX_SAFE_INTEGER;\n  }\n  push(n) {\n    this.data[++this._top] = n;\n    n &lt; this.min &amp;&amp; (this.min = n);\n  }\n  pop() {\n    this.min = Number.MAX_SAFE_INTEGER;\n    for (let i = --this._top; i &gt;= 0; --i) {\n      this.data[i] &lt; this.min &amp;&amp; (this.min = this.data[i]);\n    }\n  }\n  top() {\n    return this.data[this._top];\n  }\n  getMin() {\n    return this.min;\n  }\n}</code></pre> \n<h3>优化</h3> \n<p>上述代码有个问题，<code>pop</code> 操作的时间复杂度其实是 O(n)，因为需要通过遍历来完成最小值的更新。我们来尝试把它变成 O(1)。</p> \n<p>为了直接更新最小值，那么它可能来自于可以直接计算或者提前算好了存起来。由于数据并没有什么数学联系，所以直接计算显然是不现实的，那么我们就从提前算好来考虑。我们可以想象一下在插入一个新数据的时候发生的情况：当前栈中的最小值我是知道的；新数据是否最小我也是知道的。那么就相当于插入数据前的最小值和插入数据后的最小值我都知道。那么反过来，它们其实也就是弹出数据前和弹出数据后的最小值。</p> \n<p>到此，我们便得到了实现思路。具体代码如下：</p> \n<pre><code class=\"js\">class MinStack {\n  constructor() {\n    this._top = -1;\n    this.data = [];\n    this.min = Number.MAX_SAFE_INTEGER;\n  }\n  push(n) {\n    this.data[++this._top] = this.min;\n    this.data[++this._top] = n;\n    n &lt; this.min &amp;&amp; (this.min = n);\n  }\n  pop() {\n    this.min = this.data[--this._top];\n    --this._top;\n  }\n  top() {\n    return this.data[this._top];\n  }\n  getMin() {\n    return this.min;\n  }\n}</code></pre> \n<h2>总结</h2> \n<p>优化方式中包含了一点思维的转换，不过也非常简单，希望能帮助到有需要的小伙伴。</p> \n<p>如果觉得不错的话，记得『三连』哦。小猪爱你们哟~</p> \n<h2>相关链接</h2> \n<ul> \n <li><a href=\"https://github.com/poppinlp/leetcode#30-day-leetcoding-challenge\" rel=\"nofollow noreferrer\">活动题目列表</a></li> \n <li><a href=\"https://github.com/poppinlp/leetcode\" rel=\"nofollow noreferrer\">leetcode 题解 repo</a></li> \n <li><a href=\"https://segmentfault.com/blog/zxzfbz\">我的 segmentfault 专栏</a></li> \n <li><a href=\"https://zhuanlan.zhihu.com/zxzfbz\" rel=\"nofollow noreferrer\">我的知乎专栏</a></li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCAAa\" src=\"http://localhost:8060/tup/2020/4/23/9e678e1210534608a1df1fe1fe5a13ce.jpg\" alt=\"qrcode_green.jpeg\" title=\"qrcode_green.jpeg\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/82037d4bb9684c5c962c16babf80f64b.jpg', '1c5851dc916d4e70a60f0c957f548876', 'cbad2058b4014634aec6515f4adbef0d', '3921afbb134d45f6aa368b52d2670e7b,faf36da502544b51be926ab85450c40d,789898341cc64d45a1f44e26daab183f,63c4e1e7ec204b43a62065a3ced4c2ce,55723db96b9f4593bae02bc1e49f1e87', '0', '3', '1', '2020-04-23 10:55:36', '2020-04-23 10:55:36');
INSERT INTO `tb_recommend` VALUES ('45d80751af804740acf9cf538a659a0b', '微信小程序上拉加载 加载更多数据 触底加载 点击加载更多数据', '开发需求 进入页面，加载初始数据，当向上拖动页面至底部，自动加载新的数据，即上拉加载更多数据。 演示 index.wxml {代码...} index.js {代码...} 说明1、url修改为你的服务端链接，格式是 {代码...} 例如： {...', '<h2>开发需求</h2> \n<p>进入页面，加载初始数据，当向上拖动页面至底部，自动加载新的数据，即上拉加载更多数据。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhfu\" src=\"http://localhost:8060/tup/2020/4/23/013d4726c6d54193963c1e02cdb0b501.jpg\" alt=\"微信截图_20200420133041.png\" title=\"微信截图_20200420133041.png\"></span></p> \n<h2>演示</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhfE\" src=\"http://localhost:8060/tup/2020/4/23/9cd5d927498f428dbae42d66f0e075e2.jpg\" alt=\"GIF 2020-4-20 13-31-41.gif\" title=\"GIF 2020-4-20 13-31-41.gif\"></span></p> \n<h2>index.wxml</h2> \n<pre><code>&lt;!-- 数据列表 --&gt;\n&lt;view wx:for=\"{{listdata}}\" wx:key=\"listdata\" class=\'listitem\'&gt;\n  &lt;view class=\'title\'&gt;{{item.title}}&lt;/view&gt;\n  &lt;view class=\'title\'&gt;资源ID:{{item.id}}&lt;/view&gt;\n  &lt;image src=\"{{item.coverimg}}\" class=\'cover\'&gt;&lt;/image&gt;\n&lt;/view&gt;\n\n&lt;!-- 如果还有更多数据可以加载，则显示玩命加载中 --&gt;\n&lt;view class=\"load-more-wrap\"&gt;\n&lt;block wx:if=\"{{hasMore}}\"&gt;\n  &lt;view class=\"load-content\"&gt;\n    &lt;text class=\"weui-loading\"/&gt;&lt;text class=\"loading-text\"&gt;玩命加载中&lt;/text&gt;\n  &lt;/view&gt;\n&lt;/block&gt;\n&lt;!-- 否则显示没有更多内容了 --&gt;\n&lt;block wx:else&gt;\n  &lt;view class=\"load-content\"&gt;\n    &lt;text&gt;没有更多内容了&lt;/text&gt;\n  &lt;/view&gt;\n&lt;/block&gt;\n&lt;/view&gt;</code></pre> \n<h2>index.js</h2> \n<pre><code>Page({\n  data: {\n    listdata:[],  //数据\n    moredata: \'\',\n    p:0, //当前分页；默认第一页\n    hasMore:true //提示\n  },\n\n  //加载初始数据\n  onLoad: function (options) {\n    var that = this;\n\n  //初始页面\n  var p = that.data.p;\n    this.loadmore();\n  },\n\n  //触底事件\n  onReachBottom:function(){\n    var that = this;\n    //检查是否还有数据可以加载\n    var moredata = that.data.moredata;\n    //如果还有，则继续加载\n    if (moredata.more != 0) {\n      this.loadmore();\n      //如果没有了，则停止加载，显示没有更多内容了\n    }else{\n      that.setData({\n        \"hasMore\": false\n      })\n    }\n  },\n\n  //发起请求\n  loadmore:function(){\n\n    //加载提示\n    wx.showLoading({\n      title: \'加载中\',\n    })\n\n    var that = this;\n    //页面累加\n    var p = ++that.data.p;\n\n    //请求服务器\n    wx.request({\n      url: \'你的服务器/server.php?page=\' + p,\n      data: {\n        \"json\": JSON.stringify({\n          \"p\": p\n        })\n      },\n\n      method: \'POST\',\n      header: {\n        \'content-type\': \'application/x-www-form-urlencoded\'\n      },\n\n      //请求成功，回调函数\n      success:function(res){\n        \n        //隐藏加载提示\n        wx.hideLoading();\n\n        //判断市局是否为空\n        if (res.data != 0) {\n          that.setData({\n            //把新加载的数据追加到原有的数组\n            \"listdata\": that.data.listdata.concat(res.data), //加载数据\n            \"moredata\": res.data,\n            \"p\":p\n          })\n        } else {\n          that.setData({\n            \"hasMore\":false\n          })\n        }\n      }\n    })\n  }\n})</code></pre> \n<p><strong>说明</strong><br>1、url修改为你的服务端链接，格式是</p> \n<pre><code>http:域名/目录/?page=页码</code></pre> \n<p>例如：</p> \n<pre><code>http://www.baidu.com/api/data.php?page=1</code></pre> \n<p>页码是可变的，所以声明一个变量p，所以就是</p> \n<pre><code>`url: \'http://www.baidu.com/api/data.php?page\' + p,`</code></pre> \n<h2>index.wxss</h2> \n<pre><code>.listitem{\n  width: 90%;\n  height: 155px;\n  background: rgba(0, 0, 0, 0.2);\n  margin:10px auto;\n  text-align: center;\n  position: relative;\n  color:#fff;\n}\n\n.listitem .cover{\n  width:100%;\n  height:155px;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: -100;\n}\n\n.load-more-wrap .load-content{\n  text-align: center;\n  margin:30px auto 30px;\n  color:#ccc;\n  font-size: 15px;\n}</code></pre> \n<h2>服务端返回的数据格式</h2> \n<p>返回json数组的形式，例如</p> \n<pre><code>[\n    {\"id\":\"1\",\"title\":\"标题1\",\"coverimg\":\"url1\"},\n    {\"id\":\"2\",\"title\":\"标题2\",\"coverimg\":\"url2\"},\n    {\"id\":\"3\",\"title\":\"标题3\",\"coverimg\":\"url3\"},\n    {\"id\":\"4\",\"title\":\"标题4\",\"coverimg\":\"url4\"},\n    {\"id\":\"5\",\"title\":\"标题5\",\"coverimg\":\"url5\"}\n]</code></pre> \n<h2>作者</h2> \n<p>Author:TANKING<br>Date:2020-04-20<br>Web:<a href=\"http://www.likeyunba.com\" rel=\"nofollow noreferrer\">www.likeyunba.com</a><br>WeChat:face6009</p>', null, 'http://localhost:8060/tup/2020/4/23/872b81176c62497a935696965941d8a2.jpg', '3f69fcc9b13843d1910b3dac597f5215', '049b3bd76c1e49ccbe48b36197e77f76', 'd79254c4ca5e45dca9d484307c935281,84e1fca09c4340be87d5c1ef4601b026,3b375646301546259a8fb29d74ae4447,5941ef35934d4ddc85771b5a57e52dec,15941dc0af92453481b8a0626f963283', '0', '3', '1', '2020-04-23 10:26:19', '2020-04-23 10:26:19');
INSERT INTO `tb_recommend` VALUES ('49441c39e0ae49a79d7c23a7497059f1', '不交“赎金”就打爆！出海游戏企业如何应对DDoS勒索', '2019年12月下旬，某游戏公司突然遭到70G流量的DDoS攻击，并基于前期购买的UCloud高防服务抵抗住了这一波攻击。游戏公司负责人G先生本以为这就是一次小打小闹，黑客方应该已经知难而退。', '<p>近年来，中国互联网出海已成燎原之势，游戏出海，网络先行。但是，DDoS 攻击却始终是环绕在出海游戏企业头顶的噩梦。</p> \n<p>近期，UCloud安全中心就接到一例关于DDoS勒索攻击的求助，最终经过完备的云上安全防护，成功逼退黑客。</p> \n<h2><strong>不交“赎金”就打爆！</strong></h2> \n<p>2019年12月下旬，某游戏公司突然遭到70G流量的DDoS攻击，并基于前期购买的UCloud高防服务抵抗住了这一波攻击。游戏公司负责人G先生本以为这就是一次小打小闹，黑客方应该已经知难而退。</p> \n<p>没有料到的是，这仅仅是一次攻击的前奏曲。</p> \n<p>当天晚上，G先生便收到了来自黑客组织的勒索消息。黑客方声称来自A记，A记是一个臭名昭著的国际黑客组织，从2018年起便陆续被各大安全厂商曝光DDoS勒索的行径。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979751\" src=\"http://localhost:8060/tup/2020/4/23/b464e67c5a2e4f14804c1baec5fc9d1f.jpg\" alt=\"\" title=\"\"></span></p> \n<p>图：黑客勒索的沟通截图</p> \n<p>在G先生与黑客的沟通过程中，黑客声称第一次的70G DDoS攻击只是一个引子，如若G先生不妥协，将持续发动更大规模的攻击。</p> \n<p>这也是A记黑客组织一贯的攻击套路，通常先进行小规模攻击试探，并威胁企业支付“赎金”，如果被拒便会发起更为猛烈的大流量攻击，以此胁迫企业就范。可以看出来，黑客应该已有多次勒索成功经历，似乎笃定了这次G先生也会妥协，言辞之间非常狂妄嚣张。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979752\" src=\"http://localhost:8060/tup/2020/4/23/0f4230e4955a4b749878f29ce0fa7428.jpg\" alt=\"\" title=\"\"></span></p> \n<p>图：黑客态度非常狂妄</p> \n<h2><strong>妥协 or 拒绝？</strong></h2> \n<p>可能有很多人不太理解，为什么黑客组织会有勒索成功的经历，以下稍作说明。</p> \n<p>DDoS攻击与其他黑客攻击的区别在于，DDoS没有太多花样，不像钓鱼链接、后门等需要伪装潜伏的攻击手段，DDoS攻击非常简单粗暴，就是<strong>以攻击量取胜</strong>。</p> \n<p>这也便导致了2个问题：</p> \n<p>1、防御成本远远高于攻击成本；</p> \n<p>2、大流量攻击下出海游戏企业难以抵御。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979754\" src=\"http://localhost:8060/tup/2020/4/23/d247f3d8f3d54cf894ef34d7e9925723.jpg\" alt=\"\" title=\"\"></span></p> \n<p>什么意思呢？对于游戏企业来讲，网络稳定性至关重要，访问中断几小时或者几天，便足够毁掉一个企业。正因如此，不少黑客瞄准了受害者的心理，出海游戏企业便成为了DDoS受害的重灾区。此外，当发生上百G甚至更高的大流量攻击时，通常需要多集群防护与足够的带宽资源，这也对提供抗DDoS服务的安全企业提出了较高的要求。</p> \n<p><strong>由于缺钱缺资源、攻击紧迫性又非常高</strong>，不少企业出于“花钱买平安”的心态，便会屈服于黑客的勒索之下。</p> \n<p>此时，摆在G先生面前也是同样一个问题：<strong>妥协 or &nbsp;拒绝？</strong></p> \n<p>毫无疑问，G先生果断拒绝。</p> \n<h2><strong>成功化解300G大流量攻击</strong></h2> \n<p>黑客与G先生谈崩以后，恼羞成怒，摈弃之前小规模的试探，在当天下午2点钟左右便开始发动猛烈的攻势。如下图，攻击流量瞬时达到了<strong>近300G的峰值</strong>！ </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979753\" src=\"http://localhost:8060/tup/2020/4/23/3f7afd0ba8824fbc91f4215c641ed58a.jpg\" alt=\"\" title=\"\"></span></p> \n<p>图：攻击流量监控图</p> \n<p>可能有读者无法直观体会300G大流量攻击的威力，来看近期发生的一个案例：2月28日，加密货币交易所 OKEx 先是遭到300G流量攻击，致使网络宕机1分钟左右，之后又遭到400G流量攻击，直接导致 OKEx 暂停相关交易40分钟。</p> \n<p>在本次针对游戏企业的攻击过程中，除了超大流量外，黑客还发动了多种攻击手段，先是<strong>DNS反射与LDAP反射齐飞</strong>，接着又陆续发动<strong>TCP SYN Flood</strong>、<strong>ACK Flood</strong>以及各种<strong>IP层报文的混合攻击</strong>……总攻击时长持续<strong>73分钟</strong>，累计攻击流量<strong>39PB</strong>。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979755\" src=\"http://localhost:8060/tup/2020/4/23/0426ff06f03c43108f63a4cc782d7241.jpg\" alt=\"\" title=\"\"></span></p> \n<p>图：各类攻击手段数据统计</p> \n<p>可以看到，黑客几乎拿出了所有看家本领。但是，在UCloud的协助布防下，这次攻击对用户网络丝毫无影响，在此期间，游戏业务正常稳定运行。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979756\" src=\"http://localhost:8060/tup/2020/4/23/7b7407c704e34b7abec1d27f9a4b6513.jpg\" alt=\"\" title=\"\"></span></p> \n<p>图：与用户确认业务是否受影响</p> \n<p>在游戏公司遭受第一波小规模DDoS攻击时，UCloud安全中心便已介入了解该事件。在了解到勒索情况后，由于无法预估黑客具体的攻击数字，UCloud和用户沟通后建议采用<strong>弹性防护措施布防</strong>，并先后采取高防IP分配、特殊转发规则配置、精细化防护策略添加等手段，实现隐藏用户源站IP的效果。</p> \n<p>当黑客开始攻击时，所有的攻击量及攻击手段全部被转移至UCloud云端高防IP站点，该高防站点设置攻击上限为1T，可轻松实现300G的攻击量抵御。最终，成功逼退A记黑客组织。</p> \n<h2><strong>黑客攻击手段分析</strong></h2> \n<p>此次事件并不是个例，在UCloud安全中心的监测历史中，DDoS攻击的发生频率非常高，我们也帮助用户做了不少防御。</p> \n<p>我们注意到，黑客的攻击手段在不断进化，除了常规的的Syn Flood攻击、CC攻击等，近几年更为流行的是<strong>反射放大型攻击</strong>，也是本次攻击过程中黑客使用较多的一类手段：攻击者只需要付出少量的代价，即可对需要攻击的目标产生巨大的流量，对网络带宽资源、连接资源和计算机资源造成巨大的压力。</p> \n<p>常规DDoS攻击的缺点是耗时长且隐蔽度不够，黑客很可能出现伤敌一千、自损八百的情况，而反射放大型攻击则充分实现了<strong>四两拨千斤</strong>的效果。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979758\" src=\"http://localhost:8060/tup/2020/4/23/01bf77165722437fbfc5c858b256541f.jpg\" alt=\"\" title=\"\"></span></p> \n<p>图：反射放大攻击示意</p> \n<p>以DNS反射放大型攻击原理为例，网络上有大量的开放DNS解析服务器，它们会响应来自任何地址的解析请求。通常发出很小的解析请求长度后，便会收到大量的结果，尤其是查询某一域名所有类型的DNS记录时，返回的数据量就更大了。攻击者利用被控制的机器发起伪造的解析请求，然后将放大数倍的解析结果返回给被攻击目标，以此达成反射放大攻击的目的。</p> \n<h2><strong>公有云抗DDoS指南</strong></h2> \n<p>针对公有云 DDoS 防护问题，除了常规的高防服务以外，我们还自研了 Anycast 全球清洗技术，充分利用 UCloud 覆盖全球多地域节点的 BGP 宣告能力及节点间的专线资源，帮助海外公有云用户实现 DDoS 的无忧防护。</p> \n<p>Anycast 清洗技术主要针对部分海外业务场景中网络复杂、基础设施保障不稳定的情况，如下图，基于强大的检测集群、清洗集群及上联带宽资源，AnycastClean 可从横向扩充清洗节点的角度完成大流量 DDoS 清洗。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979757\" src=\"http://localhost:8060/tup/2020/4/23/8cd96210ca7846aa87b2a404c5999745.jpg\" alt=\"\" title=\"\"></span></p> \n<p>图：攻击流量被引至法兰克福/华盛顿/台北节点分散清洗</p> \n<p>同时&nbsp;Anycast&nbsp;清洗能力不设上限，集合海外多个地域节点的清洗能力，可帮助用户全力进行抗攻击保障。换句话讲，AnycastClean 能够将海量集中的攻击源分散至多处 UCloud 海外节点，将原本巨大的攻击流一一化解，从而达到以柔克刚的效果</p> \n<h2><strong>结语</strong></h2> \n<p>在面临黑客DDoS攻击和恶意勒索时，相信没有一个公司愿意屈服。事实上这是一场决心和能力的博弈，如果有坚强的决心，加上完善的技术手段、足够的资源和运营经验来应对，来自外部的攻击是可以化解的。UCloud作为业界领先的云服务商，也一直在完善我们的能力，为客户的业务提供全方位的防护。</p>', null, 'http://localhost:8060/tup/2020/4/23/136bb6aed7aa4c068f08a6f6baa5176f.jpg', '692c6787030d4b8882077b2ab9279c52', '1a7cc9fbc4654cb0afec84e080816ef1', '6694b0611a0d403e9bb25c543e006f8a,a4f4fd7a73b84a7298db0174165eeaac,e80d97c3472e428dabdaf417adac7a3c,40c24c15130143f6be0c452503550a5b', '0', '3', '1', '2020-04-23 10:57:09', '2020-04-23 10:57:09');
INSERT INTO `tb_recommend` VALUES ('4a8d48cd266c4477a07f138f1a60a40d', 'Java集合类，一张图说清楚！', '作者：skywang12345[链接]2019-03-23 10:32:24 Java集合是java提供的工具包，包含了常用的数据结构：集合、链表、队列、栈、数组、映射等。 Java集合工具包位置是java.util.*，Java集合主要可以划分为4个部分： L...', '<blockquote>\n 作者：skywang12345\n <br>\n <a href=\"https://www.cnblogs.com/skywang12345/p/3308498.html\" rel=\"nofollow noreferrer\">https://www.cnblogs.com/skywa...</a>\n <br>2019-03-23 10:32:24\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022437955\" src=\"http://localhost:8060/tup/2020/4/23/b235ec1c8930463f867bd0ac26365156.jpg\" alt=\"\" title=\"\"></span></p> \n<p>Java集合是java提供的工具包，包含了常用的数据结构：<strong>集合、链表、队列、栈、数组、映射</strong>等。</p> \n<p>Java集合工具包位置是<strong>java.util.*，</strong>Java集合主要可以划分为4个部分：</p> \n<ul> \n <li>List列表</li> \n <li>Set集合</li> \n <li>Map映射</li> \n <li>工具类(Iterator迭代器、Enumeration枚举类、Arrays和Collections)</li> \n</ul> \n<p>Java集合工具包框架图(如下)：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022437956\" src=\"http://localhost:8060/tup/2020/4/23/1febcf1c94c74723911f5b80d87ff011.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>大致说明：</strong></p> \n<p>看上面的框架图，先抓住它的主干，即Collection和<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484146&amp;idx=1&amp;sn=4aed1eab1106e0cc6aee09db84f275d7&amp;chksm=eb5387c4dc240ed22b87c0bd6f4aef0ccc653a49758317ec84545ae20871d10b8acd40475261&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Map</a>。</p> \n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247486804&amp;idx=1&amp;sn=277ec197ea06ce25c9e9fdef60d8c8a8&amp;chksm=eb538862dc2401744ec01c5d4b429ed81fe92ce9f531e1ed4ae42106431ca33bf377d3fea7cc&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\"><strong>一、Collection是一个接口，是高度抽象出来的集合，它包含了集合的基本操作和属性。</strong></a></p> \n<p>Collection包含了List和Set两大分支。</p> \n<p>List是一个有序的队列，每一个元素都有它的索引。第一个元素的索引值是0。<br>List的实现类有LinkedList, ArrayList, Vector, Stack。</p> \n<p>Set是一个不允许有重复元素的集合。Set的实现类有HastSet和TreeSet。HashSet依赖于HashMap，它实际上是通过HashMap实现的；TreeSet依赖于TreeMap，它实际上是通过TreeMap实现的。</p> \n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247487850&amp;idx=2&amp;sn=036ce8c9fdf76bb9885318c991fe27c2&amp;chksm=eb53945cdc241d4aa51f68c4199613fa98de5616e0cad1a281903758888734f2a09ae175186a&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\"><strong>二、Map是一个映射接口，即key-value键值对。Map中的每一个元素包含“一个key”和“key对应的value”。</strong></a></p> \n<p>AbstractMap是个抽象类，它实现了Map接口中的大部分API。而HashMap，TreeMap，WeakHashMap都是继承于AbstractMap。</p> \n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247487887&amp;idx=1&amp;sn=93eb6607ca6371b418a4e6680fc146e0&amp;chksm=eb5394b9dc241daf3cda3763fe657bcb6d60022c24e0005ae71b4327608960557d43635dad40&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Hashtable</a>虽然继承于Dictionary，但它实现了Map接口。</p> \n<p>接下来，再看Iterator。它是遍历集合的工具，即我们通常通过Iterator迭代器来遍历集合。</p> \n<p>我们说Collection依赖于Iterator，是因为Collection的实现类都要实现iterator()函数，返回一个Iterator对象。ListIterator是专门为遍历List而存在的。</p> \n<p>再看Enumeration，它是JDK 1.0引入的抽象类。作用和Iterator一样，也是遍历集合；但是Enumeration的功能要比Iterator少。在上面的框图中，Enumeration只能在Hashtable, Vector, Stack中使用。</p> \n<p>最后，看Arrays和Collections。它们是操作数组、集合的两个工具类。</p> \n<p>有了上面的整体框架之后，我们接下来可以对每个类分别进行分析了。</p> \n<p>关注Java技术栈微信公众号，在后台回复关键字：_<strong>Java</strong>_，可以获取更多栈长整理的Java技术干货。</p> \n<p><strong>推荐去我的博客阅读更多：</strong></p> \n<p>1.<a href=\"http://www.javastack.cn/categories/Java/\" rel=\"nofollow noreferrer\">Java JVM、集合、多线程、新特性系列教程</a></p> \n<p>2.<a href=\"http://www.javastack.cn/categories/Spring/\" rel=\"nofollow noreferrer\">Spring MVC、Spring Boot、Spring Cloud 系列教程</a></p> \n<p>3.<a href=\"http://www.javastack.cn/categories/%E5%B7%A5%E5%85%B7/\" rel=\"nofollow noreferrer\">Maven、Git、Eclipse、Intellij IDEA 系列工具教程</a></p> \n<p>4.<a href=\"http://www.javastack.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/\" rel=\"nofollow noreferrer\">Java、后端、架构、阿里巴巴等大厂最新面试题</a></p> \n<p>觉得不错，别忘了点赞+转发哦！</p>', null, 'http://localhost:8060/tup/2020/4/23/d4da73e38eb645649d0c9bfd2965af6a.jpg', '1894b118d35d44cb8fe8009529c4154b', 'bb0b7e69ad3e46fcb121baefda8f1f78', '2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-23 10:28:19', '2020-04-23 10:28:19');
INSERT INTO `tb_recommend` VALUES ('4df1b90d50a548039e662077b629c59e', '文档代码化', '文档代码化，将文档以类代码的领域特定语言的方式编写，并借鉴软件开发的方式（如源码管理、部署）进行管理。它可以借助于特定的工具进行编辑、预览、查看，又或者是通过专属的系统部署到服务器上。面向非技术人...', '<blockquote>\n 文档代码化，将文档以类代码的领域特定语言的方式编写，并借鉴软件开发的方式（如源码管理、部署）进行管理。它可以借助于特定的工具进行编辑、预览、查看，又或者是通过专属的系统部署到服务器上。面向非技术人员的文档代码化的一种常见架构模式是：\n <a href=\"https://www.phodal.com/blog/editing-publishing-coding-seperate/\" rel=\"nofollow noreferrer\">编辑-发布-开发分离</a>』，\n</blockquote> \n<p>最近一个月里，我在开发一个基于 Git + Markdown 的全新文档系统。我定制了一个基于 markdown 的标记语言，以支持起雷达图、条形统计图、思维导图等图表的文档系统。这个系统将在未来几个月内发布。当然了，视进度而看，也可能是月底。</p> \n<p>过去的几年里，我们一直在讨论各种各样的代码化，基础设施代码化、设计代码化、需求代码化……。在我的那一篇《<a href=\"https://github.com/phodal/cloud-dev\" rel=\"nofollow noreferrer\">云研发：研发即代码</a>》中，设计了一个完全代码化的软件开发流程。而今天我们将讨论另外一个有趣的存在：文档。</p> \n<p>在《<a href=\"https://www.phodal.com/blog/architecture-pyramid/\" rel=\"nofollow noreferrer\">架构金字塔</a>》中，我将文档定义为支撑五层架构模型的一种存在。因为文档在一个系统中是非常重要的存在，我们用它来指导开发工作，用它来记录问题，用它来写下规范……。总而言之，它很重要，所以我们重新讨论一下这个话题。</p> \n<h2>引子 1：架构决策记录：格式化文档</h2> \n<p>三年前，当我第一次接触到『<a href=\"https://www.phodal.com/blog/documenting-architecture-decisions/\" rel=\"nofollow noreferrer\">架构决策记录</a>』的概念时，我被它的理念所吸引：</p> \n<ul> \n <li>使用轻量级文本格式化语言描述重大决策</li> \n <li>跟随代码一起版本化</li> \n <li>使用某种特定的文档格式（标题、上下文、决策、状态、后果）</li> \n</ul> \n<p>随后，我使用 Node.js + TypeScript 写了一个 <a href=\"https://github.com/phodal/adr\" rel=\"nofollow noreferrer\">ADR</a> 工具。现在，在我的大部分开源荐中，我都会使用它来管理一些技术决策。因为基于这个理论设计的这个文档系统真非常棒，我可以查询到：</p> \n<ul> \n <li>一个技术决策发生的时间和架构改变，对应的修改人</li> \n <li>回溯所有的技术决策，从中整理出架构发展过程</li> \n <li>所有的决策都是记录在版本控制系统中，可恢复</li> \n <li>易于管理和维护</li> \n</ul> \n<p>对于一个长期开发的系统来说，它真的非常有用。</p> \n<h2>引子 2：静态站点生成：数据代码化</h2> \n<blockquote>\n 静态站点生成是一种混合式的 Web 开发方法，它通过部署预先构建的静态文件进行部署，来让开发者在本地构建基于服务器的网站。\n</blockquote> \n<p>当 GitHub Pages 成为了程序员首选的 博客/内容/文档 服务器时，他/她也采用了静态站点生成这一项技术。静态站点生成有各种各样的优点：</p> \n<ul> \n <li>可靠性、安全性、稳定性、可用性等更好</li> \n <li>可版本控制</li> \n <li>易于测试</li> \n <li>易于实践持续部署。提交即可上线</li> \n <li>灵活，易于定制</li> \n</ul> \n<p>而事实上，静态站点生成所做的最主要的一件事是：将数据库中的数据进行代码化。采用诸如 Wordpress 这样的 CMS 时，我们是将数据存储在数据库中，以实现对于数据的 CRUD。一篇文章变为数据库二进制文件中的一个片段。</p> \n<p>随后，静态站点生成工具做了第二件事情便是将文本内容可视化出来，便于人们阅读。这样一来，我们便实现了发布-开发分离。</p> \n<h2>引子 3：定制的标记语言：扩充</h2> \n<p>将数据代码化时，我们面临了一个非常大的挑战：易于编写、阅读的标记语言（如 markdown）只设计了内容的形式，缺少了内容相关的其它信息，诸如于创建时间、作者、修改时间等等。</p> \n<p>于是各个静态站点生成器定制了自己的 markdown，添加了一些额外的信息，如 hexo 采用 <code>:year-:month-:day-:title.md</code> 的形式来管理文章的日期和标题等。这样一来说，就不需要通过读取这个文章的 Git 信息来构建出整个信息。</p> \n<p>我们所熟悉的 GitHub Flavored Markdown 也是如此，通过不明显破坏内容格式的兼容模式来扩展 markdown 数据字段。</p> \n<p>除此，我们可以定制基于 markdown 数据的图表、思维导图等内容。</p> \n<h2>引子 4：编辑-发布-开发分离：面向非技术人员</h2> \n<p>面向非技术人员设计是代码文档化的一大挑战。作为一个程序员，我们觉得 markdown 语法再简单不过了，但是对于非技术人员来说并非如此。他/她需要：一个易于上手的可视化编程器。而要实现这样一个目的，我们需要在架构上做一些转变，我们可以尝试使用 『编辑-发布-开发分离』 模式来解决这个问题。</p> \n<p>即，我们将过程拆为了三步：</p> \n<ul> \n <li>编辑人员，可以使用常用的编辑器或者是定制的编辑器</li> \n <li>开发人员，编写内容的展示</li> \n <li>发布的时候，集成这两部分代码</li> \n</ul> \n<p>我们依旧可以选择用源码管理的方式来管理内容。只需要将数据库接口，转变为 Git 服务器接口即可 —— 当然它们是稍有不同的。不过呢，把本地的 Git 转换为 Git remote 那就基本一致了。</p> \n<p>如此一来，最后我们的成本就落在改造出一个基于 Git 的 markdown 编辑器。</p> \n<h2>文档代码化</h2> \n<p>完美，我又一次在引子里，把中心思想表达完了。</p> \n<h3>为什么你需要将文档代码化？</h3> \n<p>主要原因有：文档不代码化，就没有重构的可能性。</p> \n<p>剩下的原因有：</p> \n<ul> \n <li>二进制的文档难以进行版本管理。想象一下 <code>2020-02-30.docx</code> 和 <code>2020-02-31.docx</code>。</li> \n <li>无法准确地知道谁是文档的修改者，大家可能都是 admin，又或者是会议上的张三</li> \n <li>找不到哪个是最新的文档</li> \n <li>文档写得很烂，但是你没办法重构二进制文档</li> \n <li>供应商绑定</li> \n <li>……</li> \n</ul> \n<p>应该还有更多。</p> \n<h3>什么是文档代码化？</h3> \n<p>回到正题上：</p> \n<blockquote>\n 文档代码化，将文档以类代码的领域特定语言的方式编写，并借鉴软件开发的方式（如源码管理、部署）进行管理。它可以借助于特定的工具进行编辑、预览、查看，又或者是通过专属的系统部署到服务器上。\n</blockquote> \n<p>它具备这么一些特征：</p> \n<ul> \n <li>使用标记语言编写内容。如 markdown</li> \n <li>可通过版本控制系统进行版本控制。如 git</li> \n <li>与编程一致的编程体验（除了内容写不了测试）</li> \n</ul> \n<p>而一个高效的文档代码化系统，还具备这么一些特征：</p> \n<ul> \n <li>持续部署，即修改完内容可自动发布。</li> \n <li>与特定的形式组织内容索引。如以知识库的形式来组织内容。</li> \n <li>特定的文本格式。如架构决策记录、静态内容生成，以用于以提供更好的用户体验</li> \n <li>可支持 REST API。以通过编辑器来修改内容</li> \n <li>可以支持多种方式的输出。如网站标准 HTML，又或者是 Docx、Latex 等</li> \n <li>支持编辑、校对工作流</li> \n <li>支持搜索</li> \n <li>多人协作</li> \n</ul> \n<p>而事实上，大部分的团队并不需要上述的高级功能，而且它们都已经有了成熟的方案。</p> \n<h2>如何设计一个文档代码化系统？</h2> \n<p>事实上，我们在四个引子中标明了我们所需要的要素：</p> \n<ol> \n <li>使用格式化的文档</li> \n <li>借助静态站点生成技术来发布系统</li> \n <li>通过定制标记语言扩充能力</li> \n <li>面向非技术人员实现编辑器</li> \n</ol> \n<p>设计一个标记语言及其扩展语法，然后实现它即可。</p> \n<h3>1. 确立关键因素</h3> \n<p>考虑到我和我的同事们最近实现了这么一个系统，我还是忍受一下手的痛楚，简单说一下怎么做这样一个系统。我们所考虑的主要因素是：</p> \n<ul> \n <li>图表渲染</li> \n <li>流程图渲染</li> \n <li>可视化展示</li> \n</ul> \n<p>因为由 DSL 转换成的图表易于修改，并且可以索引。于是乎，我们：</p> \n<ol> \n <li>通过 markdown 的 Code 语法来扩充这些能力</li> \n <li>使用 markdown 的 table 和 list 来提供数据</li> \n <li>使用 D3.js 来支持流程图绘制</li> \n <li>使用 Echarts 来进行图表绘制</li> \n <li>尽量使用 SVG 图片</li> \n <li>……</li> \n</ol> \n<h3>2. 实现一个 MVP</h3> \n<p>我们使用 Angular + GitHub，快速实现了一个 MVP：</p> \n<ol> \n <li>我们使用 Git 作为数据库.它就可以实现多人协作的目的，并且可以追踪所有的变化</li> \n <li>我们使用 GitHub Pages 作为服务器。只要一修改文档或者代码，就会部署最新的文档。</li> \n <li>我们使用 marked.js，它可以让我们快速扩展语法。</li> \n <li>使用 textarea 结合 markdown 制作了一个简易的编辑器。</li> \n</ol> \n<p>随后，我们在这个基础上进行了快速的迭代。</p> \n<h3>3. 扩展语法</h3> \n<p>我们使用了 markdown 的 <code>code</code> 作为图表的 DSL，扩展了这么一些语法：</p> \n<ul> \n <li>echarts。直接渲染 Echarts 图表</li> \n <li>mindmap。Markdown List 转为思维导图</li> \n <li>radar。Markdown List 转为雷达图</li> \n <li>process-table。带流程的图表</li> \n <li>process-step。另外一种带流程的图表</li> \n <li>pyramid。金字塔图形</li> \n <li>quadrant。四象限图</li> \n <li>class。直接调用 CSS 的 class</li> \n <li>graphviz。使用 Dot 渲染图片</li> \n <li>mermaid。使用 mermaid 可视化</li> \n <li>webcomponents。调用 WebComponents 组件</li> \n <li> <p>toolset。调用 Toolset 相关的组件</p> \n  <ul> \n   <li>slider。权衡滑块</li> \n   <li>line-chart。表图</li> \n  </ul> </li> \n</ul> \n<p>所以，对于使用者来说，只需要编写下面的代码：</p> \n<ul>\n <li> <p>质量成熟度评估模型</p> \n  <ul> \n   <li>质量内建: 3 -&gt; 4</li> \n   <li>优化业务价值: 2 -&gt; 2</li> \n   <li>质量统一，可视化: 1 -&gt; 5</li> \n   <li>全员参与: 3 -&gt; 4</li> \n   <li>快速交付: 4 -&gt; 5</li> \n   <li>测试作为资产: 2 -&gt; 3</li> \n   <li>快速反馈: 5 -&gt; 5</li> \n  </ul> </li>\n</ul> \n<p>config: {\"legend\": [\"当前\", \"未来\"]}</p> \n<p>就可以生成对应的图表：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGdXj\" src=\"http://localhost:8060/tup/2020/4/23/99558f12e5544ca3903f54dd49d179cb.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>又或者是用于制作技术雷达图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGdXg\" src=\"http://localhost:8060/tup/2020/4/23/271b2b1ee9da4dd88e8017f19e92860c.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>我们还通过 config 来输入 JSON，进行一定的懒惰化处理（不要累死自己）。</p> \n<h3>3.1 重写 markdown 渲染器</h3> \n<p>我们在这个过程中，遇到的最大的挑战是，随着我们对 markdown 语法的不断扩充，相关的代码已经变成了一坨大泥球。所以，我们不得不重写了这部分代码：</p> \n<ol> \n <li>借助于 marked.js 的 lexer 解析出 token</li> \n <li>根据 token 修改生成新的 token</li> \n <li>遍历新生成的 token，渲染出元素</li> \n <li>结合虚拟滚动，解决性能问题</li> \n</ol> \n<p>已经开源在 GitHub，并发布对应的 npm 包：<code>@ledge-framework/render</code>。</p> \n<h3>4. 发布这个项目</h3> \n<p>我们已经在 GitHub 上发布了这个文档化系统，你可以参与到其中的使用和开发。</p> \n<p>GitHub：<a href=\"https://github.com/phodal/ledge\" rel=\"nofollow noreferrer\">https://github.com/phodal/ledge</a></p> \n<p>项目首页：<a href=\"https://devops.phodal.com/\" rel=\"nofollow noreferrer\">https://devops.phodal.com/</a></p> \n<h2>总结</h2> \n<p>然后，你就成为了一个 Markdown 工程师，D3.js 设计师，Echart 配置管理员。</p>', null, 'http://localhost:8060/tup/2020/4/23/caf066063cb546a996ee20b4c0877917.jpg', '3f69fcc9b13843d1910b3dac597f5215', '2a353971222c4aff8e8d3e9c370330cd', '81a4561c1c294e0cae32c9fe6b5dc397,4bbfbe8b4f0e4788a82ceac3f3c96168,634b81d655c74cb0adc4d0aa362b8819', '0', '3', '1', '2020-04-23 10:59:31', '2020-04-23 10:59:31');
INSERT INTO `tb_recommend` VALUES ('4e0e28a4de7945919fdf875d3f842831', '高德APP启动耗时剖析与优化实践（iOS篇）', '前言最近高德地图APP完成了一次启动优化专项，超预期将双端启动的耗时都降低了65%以上，iOS在iPhone7上速度达到了400毫秒以内。就像产品们用后说的，快到不习惯。算一下每天为用户省下的时间，还是蛮有成就感的，...', '<p><strong>前言</strong><br>最近高德地图APP完成了一次启动优化专项，超预期将双端启动的耗时都降低了65%以上，iOS在iPhone7上速度达到了400毫秒以内。就像产品们用后说的，快到不习惯。算一下每天为用户省下的时间，还是蛮有成就感的，本文做个小结。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431164\" src=\"http://localhost:8060/tup/2020/4/23/379e5ba51cdf40a5b855321bb0aac196.jpg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431163\" src=\"http://localhost:8060/tup/2020/4/23/64a025fc2813481fbb175a841ae29bbd.jpg\" alt=\"\" title=\"\"></span></p> \n<p>（文中配图均为多才多艺的技术哥哥手绘）</p> \n<p><strong>启动阶段性能多维度分析</strong></p> \n<p>要优化，首先要做到的是对启动阶段的各个性能纬度做分析，包括主线程耗时、CPU、内存、I/O、网络。这样才能更加全面的掌握启动阶段的开销，找出不合理的方法调用。</p> \n<p>启动越快，更多的方法调用就应该做成按需执行，将启动压力分摊，只留下那些启动后方法都会依赖的方法和库的初始化，比如网络库、Crash库等。而剩下那些需要预加载的功能可以放到启动阶段后再执行。</p> \n<p>启动有哪几种类型，有哪些阶段呢？</p> \n<p>启动类型分为：</p> \n<ul> \n <li>Cold：APP重启后启动，不在内存里也没有进程存在。</li> \n <li>Warm：APP最近结束后再启动，有部分在内存但没有进程存在。</li> \n <li>Resume：APP没结束，只是暂停，全在内存中，进程也存在。</li> \n</ul> \n<p>分析阶段一般都是针对Cold类型进行分析，目的就是要让测试环境稳定。为了稳定测试环境，有时还需要找些稳定的机型，对于iOS来说iPhone7性能中等，稳定性也不错就很适合，Android的Vivo系列也相对稳定，华为和小米系列数据波动就比较大。</p> \n<p>除了机型外，控制测试机温度也很重要，一旦温度过高系统还会降频执行，影响测试数据。有时候还会设置飞行模式采用Mock网络请求的方式来减少不稳定的网络影响测试数据。最好是重启后退iCloud账号，放置一段时间再测，更加准确些。</p> \n<p>了解启动阶段的目的就是聚焦范围，从用户体验上来确定哪个阶段要快，以便能够让用户可视和响应用户操作的时间更快。</p> \n<p>简单来说iOS启动分为加载Mach-O和运行时初始化过程，加载Mach-O会先判断加载的文件是不是Mach-O，通过文件第一个字节，也叫魔数来判断，当是下面四种时可以判定是Mach-O文件：</p> \n<ul> \n <li>0xfeedface对应的loader.h里的宏是MH_MAGIC</li> \n <li>0xfeedfact宏是MH_MAGIC_64</li> \n <li>NXSwapInt(MH_MAGIC)宏MH_GIGAM</li> \n <li>NXSwapInt(MH_MAGIC_64)宏MH_GIGAM_64</li> \n</ul> \n<p>Mach-O主要分为：</p> \n<ul> \n <li>中间对象文件（MH_OBJECT）</li> \n <li>可执行二进制（MH_EXECUTE）</li> \n <li>VM 共享库文件（MH_FVMLIB）</li> \n <li>Crash 产生的Core文件（MH_CORE）</li> \n <li>preload（MH_PRELOAD）</li> \n <li>动态共享库（MH_DYLIB）</li> \n <li>动态链接器（MH_DYLINKER）</li> \n <li>静态链接文件（MH_DYLIB_STUB）符号文件和调试信息（MH_DSYM）这几种。</li> \n</ul> \n<p>确定是Mach-O后，内核会fork一个进程，execve开始加载。检查Mach-O Header。随后加载dyld和程序到Load Command地址空间。通过 dyld_stub_binder开始执行dyld，dyld会进行rebase、binding、lazy binding、导出符号，也可以通过DYLD_INSERT_LIBRARIES进行hook。</p> \n<p>dyld_stub_binder给偏移量到dyld解释特殊字节码Segment中，也就是真实地址，把真实地址写入到la_symbol_ptr里，跳转时通过stub的jump指令跳转到真实地址。dyld加载所有依赖库，将动态库导出的trie结构符号执行符号绑定，也就是non lazybinding，绑定解析其他模块功能和数据引用过程，就是导入符号。</p> \n<p>Trie也叫数字树或前缀树，是一种搜索树。查找复杂度O(m)，m是字符串的长度。和散列表相比，散列最差复杂度是O(N)，一般都是 O(1)，用 O(m)时间评估 hash。散列缺点是会分配一大块内存，内容越多所占内存越大。Trie不仅查找快，插入和删除都很快，适合存储预测性文本或自动完成词典。</p> \n<p>为了进一步优化所占空间，可以将Trie这种树形的确定性有限自动机压缩成确定性非循环有限状态自动体（DAFSA），其空间小，做法是会压缩相同分支。</p> \n<p>对于更大内容，还可以做更进一步的优化，比如使用字母缩减的实现技术，把原来的字符串重新解释为较长的字符串；使用单链式列表，节点设计为由符号、子节点、下一个节点来表示；将字母表数组存储为代表ASCII字母表的256位的位图。</p> \n<p>尽管Trie对于性能会做很多优化，但是符号过多依然会增加性能消耗，对于动态库导出的符号不宜太多，尽量保持公共符号少，私有符号集丰富。这样维护起来也方便，版本兼容性也好，还能优化动态加载程序到进程的时间。</p> \n<p>然后执行attribute的constructor函数。举个例子：</p> \n<pre><code>#include &lt;stdio.h&gt;\n\n\\_\\_attribute\\_\\_((constructor))\nstatic void prepare() {\n    printf(\"%s\\\\n\", \"prepare\");\n}\n\n\\_\\_attribute\\_\\_((destructor))\nstatic void end() {\n    printf(\"%s\\\\n\", \"end\");\n}\n\nvoid showHeader() { \n    printf(\"%s\\\\n\", \"header\");\n}\n</code></pre> \n<p>运行结果：</p> \n<pre><code>ming@mingdeMacBook-Pro macho\\_demo % ./main \"hi\"\nprepare\nhi\nend</code></pre> \n<p>运行时初始化过程分为：</p> \n<ul> \n <li>加载类扩展。</li> \n <li>加载C++静态对象。</li> \n <li>调用+load函数。</li> \n <li>执行main函数。</li> \n <li>Application初始化，到applicationDidFinishLaunchingWithOptions执行完。</li> \n <li>初始化帧渲染，到viewDidAppear执行完，用户可见可操作。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431166\" src=\"http://localhost:8060/tup/2020/4/23/51bc61b3a5584f22a0ad3eb1b0127a17.jpg\" alt=\"\" title=\"\"></span></p> \n<p>也就是说对启动阶段的分析以viewDidAppear为截止。这次优化之前已经对Application初始化之前做过优化，效果并不明显，没有本质的提高，所以这次主要针对Application初始化到viewDidAppear这个阶段各个性能多纬度进行分析。</p> \n<p>工具的选择其实目前看来是很多的，Apple提供的System Trace会提供全面系统的行为，可以显示底层系统线程和内存调度情况，分析锁、线程、内存、系统调用等问题。总的来说，通过System Trace能清楚知道每时每刻APP对系统资源的使用情况。</p> \n<p>System Trace能查看线程的状态，可以了解高优线程使用相对于CPU数量是否合理，可以看到线程在执行、挂起、上下文切换、被打断还是被抢占的情况。虚拟内存使用产生的耗时也能看到，比如分配物理内存，内存解压缩，无缓存时进行缓存的耗时等。甚至是发热情况也能看到。</p> \n<p>System Trace还提供手动打点进行信息显式，在你的代码中导入sys/kdebug_signpost.h后，配对kdebug_signpost_start和kdebug_signpost_end就可以了。这两个方法有五个参数，第一个是id，最后一个是颜色，中间都是预留字段。</p> \n<p>Xcode11开始XCTest还提供了测量性能的Api。苹果在<a href=\"https://developer.apple.com/videos/play/wwdc2019/423/\" rel=\"nofollow noreferrer\">2019年WWDC启动优化专题</a>：</p> \n<p>也介绍了Instruments里的最新模板App launch如何分析启动性能。但是要想达到对启动数据进行留存取均值、Diff、过滤、关联分析等自动化操作，App launch目前还没法做到。</p> \n<p>下面针对主线程耗时、CPU、网络、内存、I/O 等多维度进行分析：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431160\" src=\"http://localhost:8060/tup/2020/4/23/26819ae0226f4ad6a58b327eb01fab5d.jpg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li>主线程耗时</li>\n</ul> \n<p>多个纬度性能分析中最重要、最终用户体感到的是主线程耗时分析。对主线程方法耗时可以直接使用Massier，这是<a href=\"https://everettjf.github.io/2019/05/06/messier/\" rel=\"nofollow noreferrer\">everettjf开发的一个Objective-C方法跟踪工具</a>：</p> \n<p>生成trace json进行分析，或者参看这个代码</p> \n<p><a href=\"https://github.com/ming1016/GCDFetchFeed/blob/master/GCDFetchFeed/GCDFetchFeed/Lib/SMLagMonitor/SMCallTraceCore.c\" rel=\"nofollow noreferrer\">GCDFetchFeed/SMCallTraceCore.c at master · ming1016/GCDFetchFeed · GitHub</a></p> \n<p>自己手动hook objc_msgSend生成一份Objective-C方法耗时数据进行分析。还有种插桩方式，可以解析IR（加快编译速度），然后在每个方法前后插入耗时统计函数。</p> \n<p>文章后面我会着重介绍如何开发工具进一步分析这份数据，以达到监控启动阶段方法耗时的目的。</p> \n<p>hook所有的方法调用，对详细分析时很有用，不过对于整个启动时间影响很大，要想获取启动每个阶段更准确的时间消耗还需要依赖手动埋点。</p> \n<p>为了更好的分析启动耗时问题，手动埋点也会埋的越来越多，也会影响启动时间精确度，特别是当团队很多，模块很多时，问题会突出。但是每个团队在排查启动耗时往往只会关注自己或相关某几个模块的分析，基于此，可以把不同模块埋点分组，灵活组合，这样就可以照顾到多种需求了。</p> \n<ul>\n <li>CPU</li>\n</ul> \n<p>为什么分析启动慢除了分析主线程方法耗时外，还要分析其它纬度的性能呢？</p> \n<p>我们先看看启动慢的表现，启动慢意味着界面响应慢、网络慢（数据量大、请求数多）、CPU超负荷降频（并行任务多、运算多），可以看出影响启动的因素很多，还需要全面考虑。</p> \n<p>对于CPU来说，WWDC的</p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2018/228/\" rel=\"nofollow noreferrer\">What’s New in Energy Debugging - WWDC 2018 - Videos - Apple Developer</a></p> \n<p>介绍了用Energy Log来查CPU耗电，当前台三分钟或后台一分钟CPU线程连续占用80%以上就判定为耗电，同时记录耗电线程堆栈供分析。还有一个MetrickKit专门用来收集电源和性能统计数据，每24小时就会对收集的数据进行汇总上报，Mattt在<a href=\"https://nshipster.com/metrickit/\" rel=\"nofollow noreferrer\">NShipster网站上也发了篇文章</a>专门进行介绍：</p> \n<p>那么，CPU的详细使用情况如何获取呢？也就是说哪个方法用了多少CPU。</p> \n<p>有好几种获取详细CPU使用情况的方法。线程是计算机资源调度和分配的基本单位。CPU使用情况会提现到线程这样的基本单位上。task_theads的act_list数组包含所有线程，使用thread_info的接口可以返回线程的基本信息，这些信息定义在thread_basic_info_t结构体中。这个结构体内的信息包含了线程运行时间、运行状态以及调度优先级，其中也包含了CPU使用信息cpu_usage。</p> \n<p>获取方式参看：</p> \n<p><a href=\"https://stackoverflow.com/questions/43866416/get-detailed-ios-cpu-usage-with-different-states\" rel=\"nofollow noreferrer\">objective c - Get detailed iOS CPU usage with different states - Stack Overflow</a></p> \n<p><a href=\"https://github.com/Tencent/GT\" rel=\"nofollow noreferrer\">GT GitHub - Tencent/GT</a></p> \n<p>也有获取CPU的代码。</p> \n<p>整体CPU占用率可以通过host_statistics函数取到host_cpu_load_info，其中cpu_ticks数组是CPU运行的时钟脉冲数量。通过cpu_ticks数组里的状态，可以分别获取CPU_STATE_USER、CPU_STATE_NICE、CPU_STATE_SYSTEM这三个表示使用中的状态，除以整体CPU就可以取到CPU的占比。</p> \n<p>通过NSProcessInfo的activeProcessorCount还可以得到CPU的核数。线上数据分析时会发现相同机型和系统的手机，性能表现却截然不同，这是由于手机过热或者电池损耗过大后系统降低了CPU频率所致。</p> \n<p>所以，如果取得CPU频率后也可以针对那些降频的手机来进行针对性的优化，以保证流畅体验。获取方式可以参考：</p> \n<p><a href=\"https://github.com/zenny-chen/CPU-Dasher-for-iOS\" rel=\"nofollow noreferrer\">https://github.com/zenny-chen...</a></p> \n<ul>\n <li>内存</li>\n</ul> \n<p>要想获取APP真实的内存使用情况可以查<a href=\"https://github.com/WebKit/webkit/blob/52bc6f0a96a062cb0eb76e9a81497183dc87c268/Source/WTF/wtf/cocoa/MemoryFootprintCocoa.cpp\" rel=\"nofollow noreferrer\">看WebKit的源码</a>：</p> \n<p>JetSam会判断APP使用内存情况，超出阈值就会杀死APP，JetSam获取阈值的<a href=\"https://github.com/apple/darwin-xnu/blob/0a798f6738bc1db01281fc08ae024145e84df927/bsd/kern/kern_memorystatus.c\" rel=\"nofollow noreferrer\">代码在这里</a>：</p> \n<p>整个设备物理内存大小可以通过NSProcessInfo的physicalMemory来获取。</p> \n<ul>\n <li>网络</li>\n</ul> \n<p>对于网络监控可以使用Fishhook这样的工具Hook网络底层库CFNetwork。网络的情况比较复杂，所以需要定些和时间相关的关键的指标，指标如下：</p> \n<ul> \n <li>DNS时间</li> \n <li>SSL时间</li> \n <li>首包时间</li> \n <li>响应时间</li> \n</ul> \n<p>有了这些指标才能够有助于更好的分析网络问题。启动阶段的网络请求是非常多的，所以HTTP的性能是非常要注意的。以下是WWDC网络相关的Session：</p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2015/719/\" rel=\"nofollow noreferrer\">Your App and Next Generation Networks - WWDC 2015 - Videos - Apple Developer</a></p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2015/711/\" rel=\"nofollow noreferrer\">Networking with NSURLSession - WWDC 2015 - Videos - Apple Developer</a></p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2016/714/\" rel=\"nofollow noreferrer\">Networking for the Modern Internet - WWDC 2016 - Videos - Apple Developer</a></p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2017/707/\" rel=\"nofollow noreferrer\">Advances in Networking, Part 1 - WWDC 2017 - Videos - Apple Developer</a></p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2017/709/\" rel=\"nofollow noreferrer\">Advances in Networking, Part 2 - WWDC 2017 - Videos - Apple Developer</a></p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2018/714/\" rel=\"nofollow noreferrer\">Optimizing Your App for Today’s Internet - WWDC 2018 - Videos - Apple Developer</a></p> \n<ul>\n <li>I/O</li>\n</ul> \n<p>对于I/O可以使用</p> \n<p><a href=\"https://www.frida.re/\" rel=\"nofollow noreferrer\">Frida • A world-class dynamic instrumentation framework | Inject JavaScript to explore native apps on Windows, macOS, GNU/Linux, iOS, Android, and QNX</a></p> \n<p>这种动态二进制插桩技术，在程序运行时去插入自定义代码获取I/O的耗时和处理的数据大小等数据。Frida还能够在其它平台使用。</p> \n<p>关于多维度分析更多的资料可以看看历届WWDC的介绍。下面我列下16年来 WWDC关于启动优化的Session，每场都很精彩。</p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2016/418/\" rel=\"nofollow noreferrer\">Using Time Profiler in Instruments - WWDC 2016 - Videos - Apple Developer</a></p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2016/719/\" rel=\"nofollow noreferrer\">Optimizing I/O for Performance and Battery Life - WWDC 2016 - Videos - Apple Developer</a></p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2016/406/\" rel=\"nofollow noreferrer\">Optimizing App Startup Time - WWDC 2016 - Videos - Apple Developer</a></p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2017/413/\" rel=\"nofollow noreferrer\">App Startup Time: Past, Present, and Future - WWDC 2017 - Videos - Apple Developer</a></p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2018/407/\" rel=\"nofollow noreferrer\">Practical Approaches to Great App Performance - WWDC 2018 - Videos - Apple Developer</a></p> \n<p><a href=\"https://developer.apple.com/videos/play/wwdc2019/423/\" rel=\"nofollow noreferrer\">Optimizing App Launch - WWDC 2019 - Videos - Apple Developer</a></p> \n<p><strong>延后任务管理</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431165\" src=\"http://localhost:8060/tup/2020/4/23/4e610d15f4ca4f908eb13f11df740438.jpg\" alt=\"\" title=\"\"></span></p> \n<p>经过前面所说的对主线程耗时方法和各个纬度性能分析后，对于那些分析出来没必要在启动阶段执行的方法，可以做成按需或延后执行。</p> \n<p>任务延后的处理不能粗犷的一口气在启动完成后在主线程一起执行，那样用户仅仅只是看到了页面，依然没法响应操作。那该怎么做呢？套路一般是这样，创建四个队列，分别是：</p> \n<ul> \n <li>异步串行队列</li> \n <li>异步并行队列</li> \n <li>闲时主线程串行队列</li> \n <li>闲时异步串行队列</li> \n</ul> \n<p>有依赖关系的任务可以放到异步串行队列中执行。异步并行队列可以分组执行，比如使用dispatch_group，然后对每组任务数量进行限制，避免CPU、线程和内存瞬时激增影响主线程用户操作，定义有限数量的串行队列，每个串行队列做特定的事情，这样也能够避免性能消耗短时间突然暴涨引起无法响应用户操作。使用dispatch_semaphore_t在信号量阻塞主队列时容易出现优先级反转，需要减少使用，确保QoS传播。可以用dispatch group替代，性能一样，功能不差。异步编程可以直接GCD接口来写，也可以使用阿里的协程框架</p> \n<p><a href=\"https://github.com/alibaba/coobjc\" rel=\"nofollow noreferrer\">coobjc GitHub - alibaba/coobjc</a></p> \n<p>闲时队列实现方式是监听主线程runloop状态，在kCFRunLoopBeforeWaiting时开始执行闲时队列里的任务，在kCFRunLoopAfterWaiting时停止。</p> \n<p><strong>优化后如何保持？</strong></p> \n<p>攻易守难，就像刚到新团队时将包大小减少了48兆，但是一年多一直能够守住，除了决心还需要有手段。对于启动优化来说，将各个性能纬度通过监控的方式盯住是必要的，但是发现问题后快速、便捷的定位到问题还是需要找些突破口。我的思路是将启动阶段方法耗时多的按照时间线一条一条排出来，每条包括方法名、方法层级、所属类、所属模块、维护人。考虑到便捷性，最好还能方便的查看方法代码内容。</p> \n<p>接下来我通过开发一个工具，详细介绍下怎么实现这样的效果。</p> \n<ul>\n <li>解析json</li>\n</ul> \n<p>如前面所说在输出一份Chrome trace规范的方法耗时json后，先要解析这份数据。这份json数据类似下面的样子：</p> \n<pre><code> {\"name\":\"\\[SMVeilweaa\\]upVeilState:\",\"cat\":\"catname\",\"ph\":\"B\",\"pid\":2381,\"tid\":0,\"ts\":21},\n{\"name\":\"\\[SMVeilweaa\\]tatLaunchState:\",\"cat\":\"catname\",\"ph\":\"B\",\"pid\":2381,\"tid\":0,\"ts\":4557},\n{\"name\":\"\\[SMVeilweaa\\]tatTimeStamp:state:\",\"cat\":\"catname\",\"ph\":\"B\",\"pid\":2381,\"tid\":0,\"ts\":4686},\n{\"name\":\"\\[SMVeilweaa\\]tatTimeStamp:state:\",\"cat\":\"catname\",\"ph\":\"E\",\"pid\":2381,\"tid\":0,\"ts\":4727},\n{\"name\":\"\\[SMVeilweaa\\]tatLaunchState:\",\"cat\":\"catname\",\"ph\":\"E\",\"pid\":2381,\"tid\":0,\"ts\":5732},\n{\"name\":\"\\[SMVeilweaa\\]upVeilState:\",\"cat\":\"catname\",\"ph\":\"E\",\"pid\":2381,\"tid\":0,\"ts\":5815},\n…</code></pre> \n<p>通过Chrome的Trace-Viewer可以生成一个火焰图。其中name字段包含了类、方法和参数的信息，cat字段可以加入其它性能数据，ph为B表示方法开始，为E表示方法结束，ts字段表示。</p> \n<p>很多工程在启动阶段会执行大量方法，很多方法耗时很少，可以过滤那些小于10毫秒的方法，让分析更加聚焦。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431161\" src=\"http://localhost:8060/tup/2020/4/23/783eae0ddcfc460da0b2b84805f1fe3d.jpg\" alt=\"\" title=\"\"></span></p> \n<p>耗时的高低也做了颜色的区分。外部耗时指的是子方法以外系统或没源码的三方方法的耗时，规则是父方法调用的耗时减去其子方法总耗时。</p> \n<p>目前为止通过过滤耗时少的方法调用，可以更容易发现问题方法。但是，有些方法单次执行耗时不多，但是会执行很多次，累加耗时会大，这样的情况也需要体现在展示页面里。另外外部耗时高时或者碰到自己不了解的方法时，是需要到工程源码里去搜索对应的方法源码进行分析的，有的方法名很通用时还需要花大量时间去过滤无用信息。</p> \n<p>因此接下来还需要做两件事情，首先累加方法调用次数和耗时，体现在展示页面中，另一个是从工程中获取方法源码能够在展示页面中进行点击显示。</p> \n<p>完整思路如下图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431162\" src=\"http://localhost:8060/tup/2020/4/23/b597d8b137b54c5b90f71656d0de48aa.jpg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li>展示方法源码</li>\n</ul> \n<p>在页面上展示源码需要先解析.xcworkspace文件，通过.xcworkspace文件取到工程里所有的.xcodeproj文件。分析.xcodeproj文件取到所有.m和.mm源码文件路径，解析源码，取到方法的源码内容进行展示。</p> \n<p>解析.xcworkspace</p> \n<p>开.xcworkspace，可以看到这个包内主要文件是contents.xcworkspacedata。内容是一个xml：</p> \n<pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;Workspace\n   version = \"1.0\"&gt;\n   &lt;FileRef\n      location = \"group:GCDFetchFeed.xcodeproj\"&gt;\n   &lt;/FileRef&gt;\n   &lt;FileRef\n      location = \"group:Pods/Pods.xcodeproj\"&gt;\n   &lt;/FileRef&gt;\n&lt;/Workspace&gt;</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431170\" src=\"http://localhost:8060/tup/2020/4/23/dfd6fa30a5a344a4badba7379cbabcb8.jpg\" alt=\"\" title=\"\"></span></p> \n<p>解析.xcodeproj</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431172\" src=\"http://localhost:8060/tup/2020/4/23/2d05ca0545814dbaaafb8cf715b23ded.jpg\" alt=\"\" title=\"\"></span></p> \n<p>通过XML的解析可以获取FileRef节点内容，xcodeproj的文件路径就在FileRef节点的location属性里。每个xcodeproj文件里会有project工程的源码文件。为了能够获取方法的源码进行展示，那么就先要取出所有project工程里包含的源文件的路径。</p> \n<p>xcodeproj的文件内容看起来大概是下面的样子。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431168\" src=\"http://localhost:8060/tup/2020/4/23/6d45f802401a4dbeb1f2cc817946d250.jpg\" alt=\"\" title=\"\"></span></p> \n<p>其实内容还有很多，需要一个个解析出来。</p> \n<p>考虑到xcodeproj里的注释很多，也都很有用，因此会多设计些结构来保存值和注释。思路是根据XcodeprojNode的类型来判断下一级是key value结构还是array结构。如果XcodeprojNode的类型是dicStart表示下级是key value结构。如果类型是arrStart就是array结构。当碰到类型是dicEnd，同时和最初dicStart是同级时，递归下一级树结构。而arrEnd不用递归，xcodeproj里的array只有值类型的数据。</p> \n<p>有了基本节点树结构以后就可以设计xcodeproj里各个section的结构。主要有以下的section：</p> \n<ul> \n <li>PBXBuildFile：文件，最终会关联到PBXFileReference。</li> \n <li>PBXContainerItemProxy：部署的元素。</li> \n <li>PBXFileReference：各类文件，有源码、资源、库等文件。</li> \n <li>PBXFrameworksBuildPhase：用于framework的构建。</li> \n <li>PBXGroup：文件夹，可嵌套，里面包含了文件与文件夹的关系。</li> \n <li>PBXNativeTarget：Target的设置。</li> \n <li>PBXProject：Project的设置，有编译工程所需信息。</li> \n <li>PBXResourcesBuildPhase：编译资源文件，有xib、storyboard、plist以及图片等资源文件。</li> \n <li>PBXSourcesBuildPhase：编译源文件（.m）。</li> \n <li>PBXTargetDependency：Taget的依赖。</li> \n <li>PBXVariantGroup：.storyboard文件。</li> \n <li>XCBuildConfiguration：Xcode编译配置，对应Xcode的Build Setting面板内容。</li> \n <li>XCConfigurationList：构建配置相关，包含项目文件和target文件。</li> \n</ul> \n<p>得到section结构Xcodeproj后，就可以开始分析所有源文件的路径了。根据前面列出的section的说明，PBXGroup包含了所有文件夹和文件的关系，Xcodeproj的pbxGroup字段的key是文件夹，值是文件集合，因此可以设计一个结构体XcodeprojSourceNode用来存储文件夹和文件关系。</p> \n<p>接下来需要取得完整的文件路径。通过recusiveFatherPaths函数获取文件夹路径。这里需要注意的是需要处理 ../ 这种文件夹路径符。</p> \n<p>解析.m .mm文件</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431167\" src=\"http://localhost:8060/tup/2020/4/23/578241cdd72e4b81b80aded08162b0cd.jpg\" alt=\"\" title=\"\"></span></p> \n<p>对Objective-C解析可以参考LLVM，这里只需要找到每个方法对应的源码，所以自己也可以实现。分词前先看看LLVM是怎么定义token的。定义文件<a href=\"https://opensource.apple.com/source/lldb/lldb-69/llvm/tools/clang/include/clang/Basic/TokenKinds.def\" rel=\"nofollow noreferrer\">在这里</a>：</p> \n<p>根据这个定义我设计了token的结构体，主体部分如下：</p> \n<pre><code>// 切割符号 \\[\\](){}.&amp;=\\*+-&lt;&gt;~!/%^|?:;,#@\npublic enum OCTK {\n    case unknown // 不是 token\n    case eof // 文件结束\n    case eod // 行结束\n    case codeCompletion // Code completion marker\n    case cxxDefaultargEnd // C++ default argument end marker\n    case comment // 注释\n    case identifier // 比如 abcde123\n    case numericConstant(OCTkNumericConstant) // 整型、浮点 0x123，解释计算时用，分析代码时可不用\n    case charConstant // ‘a’\n    case stringLiteral // “foo”\n    case wideStringLiteral // L”foo”\n    case angleStringLiteral // &lt;foo&gt; 待处理需要考虑作为小于符号的问题\n\n    // 标准定义部分\n    // 标点符号\n    case punctuators(OCTkPunctuators)\n\n    //  关键字\n    case keyword(OCTKKeyword)\n\n    // @关键字\n    case atKeyword(OCTKAtKeyword)\n}</code></pre> \n<p>完整的定义在这里：</p> \n<p><a href=\"https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/OC/ParseOCTokensDefine.swift\" rel=\"nofollow noreferrer\">MethodTraceAnalyze/ParseOCTokensDefine.swift</a></p> \n<p>分词过程可以参看LLVM的实现：</p> \n<p><a href=\"http://clang.llvm.org/doxygen/Lexer_8cpp_source.html\" rel=\"nofollow noreferrer\">clang: lib/Lex/Lexer.cpp Source File</a></p> \n<p>我在处理分词时主要是按照分隔符一一对应处理，针对代码注释和字符串进行了特殊处理，一个注释一个token，一个完整字符串一个token。我分词实现代码：</p> \n<p><a href=\"https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/OC/ParseOCTokens.swift\" rel=\"nofollow noreferrer\">MethodTraceAnalyze/ParseOCTokens.swift</a></p> \n<p>由于只要取到类名和方法里的源码，所以语法分析时，只需要对类定义和方法定义做解析就可以，语法树中节点设计：</p> \n<pre><code>// OC 语法树节点\npublic struct OCNode {\n    public var type: OCNodeType\n    public var subNodes: \\[OCNode\\]\n    public var identifier: String   // 标识\n    public var lineRange: (Int,Int) // 行范围\n    public var source: String       // 对应代码\n}\n// 节点类型\npublic enum OCNodeType {\n    case \\`default\\`\n    case root\n    case \\`import\\`\n    case \\`class\\`\n    case method\n}</code></pre> \n<p>其中lineRange记录了方法所在文件的行范围，这样就能够从文件中取出代码，并记录在source字段中。</p> \n<p>解析语法树需要先定义好解析过程的不同状态：</p> \n<pre><code>private enum RState {\n    case normal\n    case eod                   // 换行\n    case methodStart           // 方法开始\n    case methodReturnEnd       // 方法返回类型结束\n    case methodNameEnd         // 方法名结束\n    case methodParamStart      // 方法参数开始\n    case methodContentStart    // 方法内容开始\n    case methodParamTypeStart  // 方法参数类型开始\n    case methodParamTypeEnd    // 方法参数类型结束\n    case methodParamEnd        // 方法参数结束\n    case methodParamNameEnd    // 方法参数名结束\n\n    case at                    // @\n    case atImplementation      // @implementation\n\n    case normalBlock           // oc方法外部的 block {}，用于 c 方法\n}</code></pre> \n<p>完整解析出方法所属类、方法行范围的代码在这里：</p> \n<p><a href=\"https://github.com/ming1016/MethodTraceAnalyze/blob/master/MethodTraceAnalyze/OC/ParseOCNodes.swift\" rel=\"nofollow noreferrer\">MethodTraceAnalyze/ParseOCNodes.swift</a></p> \n<p>解析.m和.mm文件，一个一个串行解的话，对于大工程，每次解的速度很难接受，所以采用并行方式去读取解析多个文件。经过测试，发现每组在60个以上时能够最大利用我机器（2.5 GHz双核Intel Core i7）的CPU，内存占用只有60M，一万多.m文件的工程大概2分半能解完。</p> \n<p>使用的是dispatch group的wait，保证并行的一组完成再进入下一组。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431171\" src=\"http://localhost:8060/tup/2020/4/23/b18d6eaa1c8248d9b8bb05c855e4b82e.jpg\" alt=\"\" title=\"\"></span></p> \n<p>现在有了每个方法对应的源码，接下来就可以和前面trace的方法对应上。页面展示只需要写段js就能够控制点击时展示对应方法的源码。</p> \n<p>页面展示</p> \n<p>在进行HTML页面展示前，需要将代码里的换行和空格替换成HTML里的对应的和&nbsp;。</p> \n<pre><code>let allNodes = ParseOC.ocNodes(workspacePath: “/Users/ming/Downloads/GCDFetchFeed/GCDFetchFeed/GCDFetchFeed.xcworkspace”)\nvar sourceDic = \\[String:String\\]()\nfor aNode in allNodes {\n    sourceDic\\[aNode.identifier\\] = aNode.source.replacingOccurrences(of: “\\\\n”, with: “&lt;/br&gt;”).replacingOccurrences(of: “ “, with: “&amp;nbsp;”)\n}</code></pre> \n<p>用p标签作为源码展示的标签，方法执行顺序的编号加方法名作为p标签的id，然后用display: none; 将p标签隐藏。方法名用a标签，click属性执行一段js代码，当a标签点击时能够显示方法对应的代码。这段js代码如下：</p> \n<pre><code>function sourceShowHidden(sourceIdName) {\n    var sourceCode = document.getElementById(sourceIdName);\n    sourceCode.style.display = “block”;\n}</code></pre> \n<p>最终效果如下图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431169\" src=\"http://localhost:8060/tup/2020/4/23/2fad704bf5434bb2a680fb3ea8c11c73.jpg\" alt=\"\" title=\"\"></span></p> \n<p>将动态分析和静态分析进行了结合，后面可以通过不同版本进行对比，发现哪些方法的代码实现改变了，能展示在页面上。还可以进一步静态分析出哪些方法会调用到I/O函数、起新线程、新队列等，然后展示到页面上，方便分析。</p> \n<p>读到最后，可以看到这个方法分析工具并没有用任何一个轮子，其实有些是可以使用现有轮子的，比如json、xml、xcodeproj、Objective-C语法分析等，之所以没有用是因为不同轮子使用的语言和技术区别较大，当格式更新时如果使用的单个轮子没有更新会影响整个工具。开发这个工具主要工作是在解析上，所以使用自有解析技术也能够让所做的功能更聚焦，不做没用的功能，减少代码维护量，所要解析格式更新后，也能够自主去更新解析方式。更重要的一点是可以亲手接触下这些格式的语法设计。</p> \n<p><strong>结语</strong></p> \n<p>本文小结了启动优化的技术手段，总的来说，对启动进行优化的决心的重要程度是远大于技术手段的，决定着是否能够优化的更多。技术手段有很多，我觉得手段的好坏区别只是在效率上，最差的情况全用手动一个个去查耗时也是能够解题的。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVby2A6\" src=\"http://localhost:8060/tup/2020/4/23/9fac9ee6abab48209fa4579dfbef7a08.jpg\" alt=\"关注图.jpg\" title=\"关注图.jpg\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/c114afeabec7463eb42c209aa9b56284.jpg', 'f53014d680884163a5bd5ce762e90cdf', '049b3bd76c1e49ccbe48b36197e77f76', '63c4e1e7ec204b43a62065a3ced4c2ce,b397b0f03396401ea7132d8a82b5fac9,2123747b7b144128911f5df5ccc76295', '0', '3', '1', '2020-04-23 10:26:14', '2020-04-23 10:26:14');
INSERT INTO `tb_recommend` VALUES ('4e449d24a8444387a5160691ad216d68', 'Facebook 推出实验性工具链 Rome，为 JavaScript 提供「多合一」解决方案', '近期，Facebook 推出了一个 JavaScript 的实验性工具链，用于 JavaScript 和 TypeScript 开发的「多合一」解决方案。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFK7d\" src=\"http://localhost:8060/tup/2020/4/23/d6764ceac34643f8849c5f529c6268e2.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>近期，Facebook 推出了一个 JavaScript 的实验性工具链，用于 JavaScript 和 TypeScript 开发的「多合一」解决方案。</p> \n<p>据悉，该项目以「条条大路通罗马」和「罗马不是一天建成的」俗语来命名，徽标选择的是古希腊的斯巴达头盔。</p> \n<hr> \n<p>该项目由塞巴斯蒂安·麦肯齐（Sebastian McKenzie）发起，塞巴斯蒂安·麦肯齐是 Babas 和 Yarn 的创建者。现在该项目已交由 Facebook 的 React Native 团队进行开发。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFLa3\" src=\"http://localhost:8060/tup/2020/4/23/b60bcc146131446989bfe1ccb83749b1.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>Rome 是一个 JavaScript 的实验性工具链。该工具链由编译器，linter，格式化程序，打包器，测试框架等组成。旨在成为与 JavaScript 源代码处理相关的所有功能的综合工具。</p> \n<p>据 FaceBook 工程师介绍，Rome 使用 JavaScript 工具的方法与现有的开放源代码堆栈不同，并且可能与大型公司中基于内部基于单仓库的工具相似。Rome 负责所有构建和编译步骤，因此开发人员避免了在不同阶段必须通过多个工具传递源代码的情况。</p> \n<p>罗马的所有编译都是按模块进行的，从而允许在工作线程池中处理每个模块。为了避免这种情况导致需要重新解析每个模块，需要对它们进行预先命名，以便它们都可以共享一个作用域。</p> \n<p>当对每个文件进行编译时，Rome 可以通过在所有模块作用域变量之前加上基于模块文件名生成的标识符，来捆绑各个元素。这也适用于每个模块的导入和导出标识符，这意味着任何模块导出都可以仅使用模块的文件名和导出名称来解决：</p> \n<p>该工具链用 TypeScript 编写的，并且完全是自托管的，没有第三方依赖性，可用于处理 JSX，Flow 和 TypeScript 代码。</p> \n<p>但 Rome 尚未在生产中使用，仍处于试验阶段，但可以尝试从源码进行构建。目前，该项目在 GitHub 上已获得近 5K Star。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFLbW\" src=\"http://localhost:8060/tup/2020/4/23/838774846e754ee19bd5bc538911254a.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<blockquote> \n <strong>参考资料：</strong>\n <p>Rome 官网：<a href=\"https://romejs.dev/\" rel=\"nofollow noreferrer\">https://romejs.dev/</a> GitHub<br>地址：<a href=\"https://github.com/facebookexperimental/rome\" rel=\"nofollow noreferrer\">https://github.com/facebookex...</a></p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFtEG\" src=\"http://localhost:8060/tup/2020/4/23/0b7fb825ded94b0aa506967e4d2ffa10.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/e560082c2a0b4cc28a7ae9847d153279.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', '2a353971222c4aff8e8d3e9c370330cd', 'd79254c4ca5e45dca9d484307c935281,db6b58ae709645f2b64166fd73f2f705,9223827da7dc4f1c8f6790777fb42d6e,63c4e1e7ec204b43a62065a3ced4c2ce', '0', '3', '1', '2020-04-23 11:00:58', '2020-04-23 11:00:58');
INSERT INTO `tb_recommend` VALUES ('5075144b05244635bd40ed2ba7e5d565', 'Chrome 81 发布 ！消灭混合内容的最后一步～', 'Chrome 81 于前天正式发布了，这个版本其实最初是计划在 3 月 17 号 发布的，但由于冠状病毒（COVID-19）爆发而导致推迟到了现在。Chrome 81 的延迟也扰乱了 Google 正常的六周发布时间表。因此 Google 此前也宣...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309252\" src=\"http://localhost:8060/tup/2020/4/23/d8ab388886bc41189e5d39f84a9f5282.jpg\" alt=\"\" title=\"\"></span></p> \n<p><code>Chrome 81</code> 于前天正式发布了，这个版本其实最初是计划在 <code>3 月 17 号</code> 发布的，但由于冠状病毒（<code>COVID-19</code>）爆发而导致推迟到了现在。<code>Chrome 81</code> 的延迟也扰乱了 <code>Google</code> 正常的六周发布时间表。因此 <code>Google</code> 此前也宣布，下一个版本将直接跳过 <code>Chrome 82</code> ，直接发布 <code>Chrome 83</code>。</p> \n<p>下面我就来带大家看看 <code>Chrome 81</code> 有哪些重要的更新。</p> \n<h2>速览</h2> \n<ul> \n <li>混合内容升级三步走的第三步 —— 禁用混合img资源</li> \n <li>删除 FTP 协议支持</li> \n <li>弃用 TLS 1.0 和 TLS 1.1（延迟）</li> \n <li>TLS 1.3 稳定性增强</li> \n <li>不安全的下载将被直接阻止</li> \n <li>支持 WEB NFC</li> \n</ul> \n<h2>混合内容升级三步走的第三步 —— 禁用混合img资源</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309250\" src=\"http://localhost:8060/tup/2020/4/23/411d624151c6434a93fbddece4f1c59d.jpg\" alt=\"\" title=\"\"></span></p> \n<p><code>Chrome 81</code> 标志着 <code>Google</code> 分三步走的计划中的最后一个版本，该计划目的是从网络上全面消除混合 <code>HTTPS</code> 内容。</p> \n<blockquote>\n 混合 \n <code>HTTPS</code> 内容早在上个版本（\n <code>Chrome 80</code>）的更新中我就介绍过了：是指通过 \n <code>HTTP</code> 和 \n <code>HTTPS</code> 加载图像、\n <code>JavaScript</code> 或样式表等内容的网页，这意味着该站点实际上并不完全通过 \n <code>HTTPS</code> 加载。\n</blockquote> \n<p><code>Google</code> 宣布的最终目标是将所有 <code>HTTP</code> 内容自动升级到他们的模拟 <code>HTTPS URL</code>。但是，一次性执行这样的操作是很危险的，因为这可能会导致大量混合内容的站点出现问题。</p> \n<p>因此，为了防止造成重大破坏，<code>Google</code> 为该过程选择了一个三步计划：</p> \n<p>在 <code>2019</code> 年 12 月发布的 <code>Chrome 79</code> 中，该团队将引入一个新设置来取消阻止特定网站上的混合内容。此设置将应用于混合脚本、<code>iframe</code> 和 <code>Chrome</code> 当前默认阻止的其他类型的内容。用户可以通过单击任意 <code>https://</code> 页面上的锁定图标并单击“站点设置”来切换此设置。这将替换显示在多功能框右侧的屏蔽图标，以取消阻止以前版本的台式机 <code>Chrome</code> 浏览器中的混合内容。</p> \n<p>在 <code>Chrome 80</code> 中，混合的音频和视频资源将自动升级到 <code>https://</code>，如果它们无法通过 <code>https://</code> 加载，则 <code>Chrome</code> 默认会阻止它们。 <code>Chrome 80</code> 仍然可以加载混合图像资源，但它们会使 <code>Chrome</code> 在状态框上显示不安全。</p> \n<p>在 <code>Chrome 81</code> 中，混合的图像资源会自动升级到 <code>https://</code>，如果无法通过 <code>https://</code> 加载，<code>Chrome</code>默认会阻止它们。</p> \n<h2>弃用 TLS 1.0 和 TLS 1.1（延迟）</h2> \n<p><code>Chrome</code> 小组早在去年10月就宣布了淘汰旧版TLS版本（<code>TLS 1.0和1.1</code>）的计划。<code>Firefox 74</code> 也在前几天宣布将禁用基于 <code>TLS 1.0 和 TSL 1.1</code> 协议的网站。</p> \n<p>在 <code>Chrome 81</code> 中，<code>Chrome</code> 将用整页警告标记用户不支持 <code>TLS 1.2</code> 更高版本的站点连接不完全安全。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309248\" src=\"http://localhost:8060/tup/2020/4/23/b3f78e8a7e8746edae4802db0acc0ff8.jpg\" alt=\"\" title=\"\"></span></p> \n<p>但是，在最新的 <code>Chrome</code> 官方博客中我发现：从 <code>Chrome</code> 删除 <code>TLS 1.0</code> 和 <code>TLS 1.1</code> 加密协议的计划现在延迟到了 <code>Chrome84</code>。延迟删除这两个协议的决定与当前的新冠病毒爆发有关，因为很多重要政府医疗网站还在使用 <code>TLS 1.0 和 1.1</code> 来建立其 <code>HTTPS</code> 连接，现在进行整页警告可能会对抗击疫情造成影响。</p> \n<p>目前 <code>Chrome</code> 将继续针对使用 <code>TLS 1.0</code> 或 <code>1.1</code> 的网站显示 “不安全” 提示， <code>Chrome 81 Beta</code> 会显示受影响网站的整页插页式警告。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309249\" src=\"http://localhost:8060/tup/2020/4/23/987134adbd7e4ca99d8aa3f00cba931f.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>删除 FTP 协议支持</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309253\" src=\"http://localhost:8060/tup/2020/4/23/118f1a9079c04c12b0b899aa948263c7.jpg\" alt=\"\" title=\"\"></span></p> \n<p><code>Chrome 81</code> 将不再直接支持 <code>FTP</code> 协议，建议用户使用本机 FTP 客户端。</p> \n<h2>TLS 1.3 稳定性增强</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309251\" src=\"http://localhost:8060/tup/2020/4/23/71011d38c7da43cc95b9d660f679e476.jpg\" alt=\"\" title=\"\"></span></p> \n<p>在 <code>Chrome</code> 之前的更新中，由于开启了 <code>TLS 1.3</code>，但是兼容性没有处理好，而 <code>TLS 1.3</code> 只有在浏览器端和服务器同时支持的时候才能正常访问。从而导致大量用户无法访问站点，谷歌官方当时给出的解决办法是先关闭浏览器的 <code>TLS 1.3</code> 版本的支持。后来 <code>Chrome</code> 又禁用了一些 <code>TLS 1.3</code> 的功能才使得访问稳定。</p> \n<p><code>Chrome 81</code> 中又对 <code>TLS 1.3</code> 做了加强，防止攻击者降级到 <code>TLS 1.2</code> 及更早版本，并且支持了 <code>TLS 1.3</code> 完整功能的向后兼容。</p> \n<h2>不安全的下载将被直接阻止</h2> \n<p>从 <code>Chrome 83</code> 开始，不安全的下载将直接被阻止，和上面的混合内容更新一样，这个更新也是分步进行的，直到 <code>Chrome 86</code> 所有在安全页面上的不安全的下载将被全部阻止：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309254\" src=\"http://localhost:8060/tup/2020/4/23/af6c95a3a743492eacacf60a6836ce5f.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>支持 WEB NFC</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309255\" src=\"http://localhost:8060/tup/2020/4/23/2710b89bf3414d47909dc51b6575a90a.jpg\" alt=\"\" title=\"\"></span></p> \n<p><code>Chrome</code> 中添加的新的 <code>Web NFC</code> 标准将允许网站与 <code>NFC</code> 标签进行交互，从而无需用户在手机上安装特殊的应用程序。</p> \n<pre><code class=\"js\">const reader = new NDEFReader();\n\nasync function startScan() {\n  await reader.scan();\n  reader.onreading = (e) =&gt; {\n    console.log(e.message);\n  };\n}</code></pre> \n<p><code>Google</code> 相信，新的 <code>Web NFC</code> 标准将在 <code>Web</code> 开发人员中取得广泛的应用，尤其是对于 <code>Android</code> 版 <code>Chrome</code> 而言，该标准可用于以下场景：</p> \n<p>当用户将运行 <code>Chrome</code> 的智能手机或平板电脑触摸展览附近的 <code>NFC</code> 卡时，博物馆和美术馆可以显示有关显示器的其他信息。</p> \n<p>处理公司库存的网站，公司站点和 <code>Intranet</code> 将能够读取数据或将数据写入容器或产品上的 <code>NFC</code> 标签，从而简化库存管理。</p> \n<p>会议现场可以使用它来扫描 <code>NFC</code> 标签。</p> \n<h2>AR（增强现实）支持</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309256\" src=\"http://localhost:8060/tup/2020/4/23/193c170109f74672975ab55a0fa113e3.jpg\" alt=\"\" title=\"\"></span></p> \n<p>谷歌为 <code>WebXR API</code> 增加了两个沉浸性特性，允许在相机视图中放置虚拟物体。</p>', null, 'http://localhost:8060/tup/2020/4/23/d5dc8da3181b48cd9e020ad5eed56b86.jpg', '3f69fcc9b13843d1910b3dac597f5215', '04547238127a4676b504cc4496865d7b', '63c4e1e7ec204b43a62065a3ced4c2ce,b687605a1b8842a593f27620e3c26af5,e75baefb206a4efe959a99aad77632a3', '0', '3', '1', '2020-04-23 10:58:39', '2020-04-23 10:58:39');
INSERT INTO `tb_recommend` VALUES ('5140e68c6b1746e9ae5efe7f40c2e637', '小姐姐用动画图解Git命令，一看就懂！', '但是呢，民工哥，也经常在后台看到读者说，命令太多了不好记啊，时间长了不用又忘记了等等的吐槽。是啊，要学一门技术真难，何况现在技术更新、迭代这么快.....', '<p>无论是开发、运维，还是测试，大家都知道Git在日常工作中的地位。所以，也是大家的必学、必备技能之一。之前公众号也发过很多git相关的文章：</p> \n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;mid=2247492361&amp;idx=2&amp;sn=56c8cc90d6018805e5770eb3df4f54ed&amp;chksm=e9188615de6f0f0375c35dcfecc14e88faa7b96485a79ba18fbd0d94864fc44a47272a882c3e&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Git这些高级用法，喜欢就拿去用！</a> <br><a href=\"http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;mid=2247490976&amp;idx=2&amp;sn=f2d1c9e39375c1235a7c96191e6cc8be&amp;chksm=e91b78bcde6cf1aa82eab8c794b0b155bec7afdffe0fe354c8553c306e676e4ee560c0fc7c15&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">一文速查Git常用命令，搞定版本控制照做就ok</a> <br><a href=\"http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;mid=2247490468&amp;idx=2&amp;sn=c0ffd551fc6be91334c07391339dc96b&amp;chksm=e91b7eb8de6cf7aef37a926dbac8ca6295e148fd79ca61ffcbf8988f543302b6e1d3aec2f921&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">大牛总结的Git使用技巧，写得太好了！</a> <br><a href=\"http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;mid=2247486125&amp;idx=1&amp;sn=ce871dd581b847ce8d6418f616d208ef&amp;chksm=e91b6fb1de6ce6a7129022c167e46b780a0a4a91d7e54c6c3de63b1121c3f487bf561f9c13c5&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">掌握这10条规范，轻松搞定Git！</a></p> \n<p>但是呢，民工哥，也经常在后台看到读者说，命令太多了不好记啊，时间长了不用又忘记了等等的吐槽。是啊，要学一门技术真难，何况现在技术更新、迭代这么快.....</p> \n<p>所以，对于学习Git这门技术，要是有一个一看就懂，一学就会的入门资料就好了。前不久，国外的一位小姐姐写了一篇这样的文章《CS Visualized: Useful Git Commands》。作者是来自英属哥伦比亚的小姐姐 Lydia Hallie，在这篇文章里面，她通过生动形象的动画，以更加直观的方式，向开发者展示 Git 命令中的 merge、rebase、reset、revert、cherry-pick 等常用骚操作的具体原理。</p> \n<p><strong>下面就给大家带来一些实例分享：</strong></p> \n<p><strong>1、git&nbsp;merge</strong> </p> \n<p>fast-forward模式</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGazO\" src=\"http://localhost:8060/tup/2020/4/23/b9ca2dfbf89f4ffc807b323d4f8ab175.jpg\" alt=\"640.gif\" title=\"640.gif\"></span></p> \n<p>no-fast-forward模式</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGazQ\" src=\"http://localhost:8060/tup/2020/4/23/d72770ccb11a483793b6e52fdea0e6b8.jpg\" alt=\"640 (1).gif\" title=\"640 (1).gif\"></span></p> \n<p>合并冲突修复的过程 ，动画演示如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGazR\" src=\"http://localhost:8060/tup/2020/4/23/908d50189d9447ae852b7b451f839497.jpg\" alt=\"640 (2).gif\" title=\"640 (2).gif\"></span></p> \n<p><strong>2、git&nbsp;rebase</strong> </p> \n<p>git rebase 指令会复制当前分支的所有最新提交，然后将这些提交添加到指定分支提交记录之上。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGazU\" src=\"http://localhost:8060/tup/2020/4/23/a4ce91f3a48044e495c369f68860ff67.jpg\" alt=\"640 (4).gif\" title=\"640 (4).gif\"></span></p> \n<p>git rebase还提供了 6 种操作模式：</p> \n<ul> \n <li>reword：修改提交信息</li> \n <li>edit：修改此提交</li> \n <li>squash：将当前提交合并到之前的提交中</li> \n <li>fixup：将当前提交合并到之前的提交中，不保留提交日志消息</li> \n <li>exec：在每一个需要变基的提交上执行一条命令</li> \n <li>drop：删除提交</li> \n</ul> \n<p>以 drop 为例：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGazW\" src=\"http://localhost:8060/tup/2020/4/23/57dd634e75c745b3aa1876992d1dc12e.jpg\" alt=\"640 (5).gif\" title=\"640 (5).gif\"></span></p> \n<p>以 squash 为例：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGazW\" src=\"http://localhost:8060/tup/2020/4/23/508b456a6b324aea830ec1022207e3d0.jpg\" alt=\"640 (7).gif\" title=\"640 (7).gif\"></span></p> \n<p><strong>3、git reset</strong></p> \n<p>以下图为例：9e78i 提交添加了 style.css 文件，035cc 提交添加了 index.js 文件。使用软重置，我们可以撤销提交记录，但是保留新建的 style.css 和 index.js 文件。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGaz6\" src=\"http://localhost:8060/tup/2020/4/23/e7e5282cdcd64ef0b491e2fa8d41a1ca.jpg\" alt=\"640 (6).gif\" title=\"640 (6).gif\"></span></p> \n<h3><strong>Hard reset硬重置</strong></h3> \n<p>硬重置时：无需保留提交已有的修改，直接将当前分支的状态恢复到某个特定提交下。需要注意的是，硬重置还会将当前工作目录（working directory）中的文件、已暂存文件（staged files）全部移除！如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGaAk\" src=\"http://localhost:8060/tup/2020/4/23/639dd85776a24b24a3d60b6e3031b174.jpg\" alt=\"640 (8).gif\" title=\"640 (8).gif\"></span></p> \n<p><strong>4、git revert</strong></p> \n<p>举个例子，我们在 ec5be 上添加了 index.js 文件。之后发现并不需要这个文件。那么就可以使用 git revert ec5be 指令还原之前的更改。如下图所示：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGaAn\" src=\"http://localhost:8060/tup/2020/4/23/df692d7b98304022aa4ee7deec395963.jpg\" alt=\"640 (9).gif\" title=\"640 (9).gif\"></span></p> \n<p><strong>5、git cherry-pick</strong></p> \n<p>举个例子：dev 分支上的 76d12 提交添加了 index.js 文件，我们需要将本次提交更改加入到 master 分支，那么就可以使用 git cherry-pick 76d12 单独检出这条记录修改。如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGaAp\" src=\"http://localhost:8060/tup/2020/4/23/38d24fceac28418da2b87d110e3dc417.jpg\" alt=\"640 (10).gif\" title=\"640 (10).gif\"></span></p> \n<p><strong>6、git fetch</strong></p> \n<p>使用 git fetch 指令将远程分支上的最新的修改下载下来。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGaAr\" src=\"http://localhost:8060/tup/2020/4/23/2fb86bce135b4a46bff450555aa4d975.jpg\" alt=\"640 (11).gif\" title=\"640 (11).gif\"></span><br><strong>7、git pull</strong></p> \n<p>git pull 指令实际做了两件事：git fetch 和 git merge。</p> \n<p>如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGaAs\" src=\"http://localhost:8060/tup/2020/4/23/8639a6c954f44baea049063062dd9620.jpg\" alt=\"640 (12).gif\" title=\"640 (12).gif\"></span><br><strong>8、git reflog</strong></p> \n<p>git reflog 用于显示所有已执行操作的日志！包括合并、重置、还原，也就是记录了对分支的一切更改行为。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGaAw\" src=\"http://localhost:8060/tup/2020/4/23/9bdd9720842c461090abb2baa7d80487.jpg\" alt=\"640 (13).gif\" title=\"640 (13).gif\"></span></p> \n<p>如果，你不想合并 origin/master 分支了。就需要执行 git reflog 命令，合并之前的仓库状态位于 HEAD@{1} 这个地方，所以我们使用 git reset 指令将 HEAD 头指向 HEAD@{1}就可以了。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGaAG\" src=\"http://localhost:8060/tup/2020/4/23/f0bb288f04ce49c6aa6bf94bce919f8b.jpg\" alt=\"640 (14).gif\" title=\"640 (14).gif\"></span></p> \n<p>以上就是民工哥今天给大家带来的分享，如果本文对你有所帮助，请点个在看与转发分享支持一下，感谢大家。我们一起学习，共同进步！！！</p> \n<blockquote> \n <em>原作者：莉迪亚·哈莉（Lydia Hallie）</em>\n <br>\n <em>原文：<a href=\"https://dev.to/lydiahallie/cs-visualized-useful-git-commands-37p1\" rel=\"nofollow noreferrer\">https://dev.to/lydiahallie/cs...</a></em>\n <br>\n <em>民工哥通过翻译作者原文再加上一些个人理解总结而成，版权归原作者所有，纯属技术分享，不作为商业目的。</em> \n</blockquote>', null, 'http://localhost:8060/tup/2020/4/23/8f516e91c89240e3a7ca56f007fa4dea.jpg', '1894b118d35d44cb8fe8009529c4154b', '2a353971222c4aff8e8d3e9c370330cd', '55723db96b9f4593bae02bc1e49f1e87,d7416e100af54eb7a4d9274b9a462240,753b5aee3913424e81fe2b5299626d8c,f4fda25145b9451a9b0d77d6a2a63712,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-23 10:59:33', '2020-04-23 10:59:33');
INSERT INTO `tb_recommend` VALUES ('531193a197e44e10ad251d3aa2644430', '区块链上的虚拟开放世界游戏是怎样的？| TVP思享', '区块链是一种具有颠覆性意义的互联网基础设施，这种颠覆性体现在可以为各行各业构建低成本的资产交易功能，进而让资产可以更方便地流动。金融行业本身具有虚拟属性，区块链天然支持金融特性，所以金融行业本身就...', '<blockquote>\n 区块链是一种具有颠覆性意义的互联网基础设施，这种颠覆性体现在可以为各行各业构建低成本的资产交易功能，进而让资产可以更方便地流动。金融行业本身具有虚拟属性，区块链天然支持金融特性，所以金融行业本身就成为了区块链最先落地的行业。然而游戏行业也具备类似的虚拟性质，区块链的开发者们已经在游戏上做了诸多探索，其中类似《我的世界》的虚拟开放世界游戏最为热门，本文是对TVP陈浩老师的直播演讲整理，分享区块链是如何打造不一样的虚拟开放游戏世界的。「TVP思享」专栏，凝结大咖思考，汇聚专家分享，收获全新思想，欢迎长期关注。\n</blockquote> \n<h2><strong>一、区块链世界游戏的前身</strong></h2> \n<hr> \n<p>虚拟开放世界游戏的发展已经有不少年头了，和区块链结合之后，更是焕发了别样的生机。从我们玩过的游戏开始谈起，下面介绍三款游戏：豆瓣的阿尔法城、我的世界、头号玩家里的绿洲。</p> \n<p>豆瓣阿尔法城严格意义上来说不算是一款游戏，而是一个社交类的虚拟社区，虽然带了一些游戏的概念，但主导的还是社交。这是一个比较小众的社区，截止2015年3月份也只有8万用户，对于整个互联网的体量来说，显得相当小众。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132075\" src=\"http://localhost:8060/tup/2020/4/23/3692d2873950459791fad51297977c95.jpg\" alt=\"\" title=\"\"></span></p> \n<p>但就是这么一款游戏，它带来了一些新的概念，把街道做的具象化。玩家可以进入到社区里面去，入住的街道都是具象化的，玩家可以在里面开小店，开面包房，还有民政局、婚介所......它是一个完完全全虚拟化的镜像社区，模拟了现实世界。这也是一个开放的社区，用户可以自由进行创作。</p> \n<p>当前世界上用户和玩家人数最多的、市值最高的一款世界游戏的当属「我的世界」。它是一个高度自由开放的像素方块游戏，玩家可以在这个世界当中进行探索。不像传统游戏那样，有游戏任务目标、副本、主线，在这里没有直接的任务目标，玩家最大乐趣就是在里面制作一些建筑，以及完成一些简单的小任务。这款游戏是源码级开放的，用户可以改到源码层面，这样就会带来非常大规模的游戏体量上的创造，也就是用户的创造和探索。</p> \n<p>在这款游戏中有一个红石系统，玩家可以基于红石系统去做自己的作品。比如做一个单片机，做一个计算器，甚至去做一款游戏都是可以的，极大的释放了玩家们的想象力。在这款游戏当中，玩家可以做他想做的任何事情，限制只在于自身的想象力。这其实也是一个虚拟世界的游戏，玩家看到的作品都是可以分享给其他玩家的一种资产。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132076\" src=\"http://localhost:8060/tup/2020/4/23/ff9a4e11d9ef4411bdd3e1cd2690dd77.jpg\" alt=\"\" title=\"\"></span></p> \n<p>在2018年斯皮尔伯格导演了一部电影—头号玩家，电影当中有一款游戏叫做绿洲。绿洲可以说就是前文提到的两款游戏的一个升级版本，或者说是一种完全体。游戏是完全开放的，玩家在里面可以做很多的事情。对于这款游戏本身而言，也有一些比较有特色的地方，比如它有一个自由的经济体系，玩家在绿洲中所获得的游戏币，是可以拿出来在现实中做交易的。例如，头号玩家主角升级版的体感设备就是他通过打游戏获得的。</p> \n<p>可以说绿洲这款游戏，已经突破了虚实世界之间的界限，用户可以进入到完全虚拟的开放世界当中去，有一个自己的化身，用化身来进行创造，去探索更多的游戏内容。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132074\" src=\"http://localhost:8060/tup/2020/4/23/a2319a65cd154f9abf87760231ba19be.jpg\" alt=\"\" title=\"\"></span></p> \n<p>上面提到的这三款游戏基本上都强调了用户创造和探索这样的概念。</p> \n<h2><strong>二、区块链上的虚拟开放游戏</strong></h2> \n<hr> \n<p>下面开始正式介绍区块链上的一款世界游戏：Cryptovoxels。</p> \n<p>严格意义上来说，它不像传统类型的游戏。首先它没有一个严格意义上的游戏运营，它的像素风格看起来甚至比较原始，而且它的整体游戏性也不是特别高。我更愿意称之为一个平台，它是一个开放式的平台，玩家可以在上面去做很多的事情。这款游戏比较有意思地方叫做创意空间，里面有很多的玩家，发挥自己的艺术创造力，在游戏中构建和欣赏，特定社区特定圈子里面拥有共同语言的作品。</p> \n<p>在这款游戏当中，玩家也同样可以去做社交。相对来说，它目前的社交还比较原始，更多像是一种概念，而不是严格意义上的一种服务。玩家在里面可以做自己想做的任何事情，比如去号召大家开个舞会，号召大家去拍集体照等，游戏中的很多元素都是要玩家主动去驱动社区成员或者团体的成员一起去完成的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132079\" src=\"http://localhost:8060/tup/2020/4/23/538197a52d5844bb8f7bced03f378f42.jpg\" alt=\"\" title=\"\"></span></p> \n<p>除了以上这些特色以外，它还有其他一些特点，就要涉及到区块链上的一些特性了。</p> \n<p>（1）原生资产交易</p> \n<p>用户创造出来的东西，其实是一种资产。比如玩家在我的世界上做了一个单片机，这样的一个系统其实是玩家创造的游戏资产，可以拿去交易。在我的世界虽然比较困难，但是在区块链的世界里却是可以办到的。</p> \n<p>在比较早期的时候，很多人在谈一个概念叫资产上映，就是指把现实世界当中的一些资产映射到区块链上面去。但是随着区块链的发展，例如现在区块链上比较火的一些游戏，衍变出了区块链原生资产。用户在区块链上创造出来的原生资产，它也是有一定的价值，只要是被社区共识所认可的资产，都是可以拿去做交易的。</p> \n<p>（2）社区共同发展</p> \n<p>当玩家去创造一个作品，做一个很好玩的东西的时候，其实就是在跟社区共同发展。Cryptovoxel这款游戏其实就是基于社区创造的，它本身不具有特别多的游戏性，基本都是通过用户去驱动的，并渐渐形成了社区的共识。</p> \n<p>也可以认为，这款游戏本身是没有任何价值的，只有当你真正融入到游戏的社区圈层里来，你才会发现更多的内容，变得喜欢上这款游戏。这就是区块链所赋予游戏的特点：社区共同发展。</p> \n<p>（3）基于区块链</p> \n<p>在这款游戏当中，土地是需要玩家去购买的。想要拥有一片土地，得去拿数字货币去购买。而这款游戏目前是基于以太坊，所以玩家得拿自己手中的以太坊去购买土地。</p> \n<p>获得土地之后，接下去玩家就可以做游戏当中任何想做的事情。这里还有一个特性，购买的土地，会被区块链永久记录。也就是说这块土地是永久的属于玩家，而且不能被销毁。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132077\" src=\"http://localhost:8060/tup/2020/4/23/892faa35fb5a474686531c04dfe93227.jpg\" alt=\"\" title=\"\"></span></p> \n<p>其实这款游戏的用户数、交易的规模在圈内都不算大，但是它的衍生意义是比较强的，给了很多区块链从业者一个非常好的启发。</p> \n<p>游戏中的土地可以用来拍卖和租用，而在别的游戏当中可能需要游戏策划设计才会产生，这款游戏本身就具有这样一套土地交易系统。玩家可以从土地的发行商去购买，买到之后可以再租给他人，一切交易活动都通过一个公开的交易市场。</p> \n<p>除了土地本身以外，玩家还可以在土地上创造作品，拍卖自己的作品。区块链还为玩家提供多元化的个性社交入口。社交的主场最早的时候是个人网站，然后到博客，再到朋友圈和微博，一直到现在的短视频和vlog。那么，下一步会有什么样的个性社交入口呢？很可能就像Cryptovoxels里面所展现的那样，每个人都有一个区块链上面的化身系统，化身系统不单单是游戏，它可以做一切你想做的事情。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132078\" src=\"http://localhost:8060/tup/2020/4/23/ac24d9df8a8e4f94b1367b986b5e8c02.jpg\" alt=\"\" title=\"\"></span></p> \n<h2><strong>三、细说Token和NFT交易市场</strong></h2> \n<hr> \n<p>前文提到，土地是登记在区块链上面的，而区块链上就用Token来查看和验证玩家土地的所有权。土地的公开交易信息，展示在OpenSea网站上，它是一个第三方公开的交易市场，并不属于这个游戏，在OpenSea上可以来交易土地资源的Token。</p> \n<p>那什么是Token呢？在区块链上是一个比较专业性的名词，翻译成代币或者通证都是可以的，它其实是一个比较开放性的工具，代表了某某物体或某某事件。可以认为它是一种符号，或者说是一种价值标识都是可以的。作为一种价值标识，Token其实是有分类的：</p> \n<h3><strong>1. 同质型Token</strong></h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132081\" src=\"http://localhost:8060/tup/2020/4/23/3ad63fe5eacc453ab3cbde121670e86f.jpg\" alt=\"\" title=\"\"></span></p> \n<p>在公开的二级市场进行交易的时候，交易的标的物基本上用的都是同质型Token。怎么去理解？</p> \n<p>例如货币、证券、黄金这些都算是同质型Token。最简单来看，它们的使用是不做具体单个区分的。比如我手上的100元钞票，和你手上的100元钞票，在使用的时候，是不进行区分的，只要它代表的面值是100元，就可以了。因为它是同质性的，我们可以延伸定义它为标准资产，它还有个性质就是流动性高。所谓流动性高就容易被市场接纳，容易被买卖掉，通常是由大范围的社会共识决定的。最典型的就是大家手上的现金，现金总是很容易购买和交易的。如果你手上有很多的实物资产，比如说有100台挖掘机，是很难找到对方去买你的挖掘机的。所以同质型Token通常具有流动性高这样的特点，基本上它的价值也是比较稳定的。</p> \n<h3><strong>2. 非同质性Token（NFT）</strong></h3> \n<p>与同质型Token对应的是NFT：非同质性Token，英文全称为Non-Fungible Token。非同质性Token，跟我们前文提到的那几款游戏是有联系的，我们刚刚提到的能交易的土地，还有玩家创造出来的作品，其实都是非同质性Token。</p> \n<p>总的来说，它是一种非标准资产。比方说常见的收藏品、游戏项目、数字艺术品、活动门票或者域名，以及实物资产的所有权记录，这些都是都可以认为是非标准资产。</p> \n<p>它最大特点是唯一性，比如说我家有一幅画，它是全世界唯一的，如果你家里也有一幅的话，那么肯定有一个是假的，这就表明了这种价值标记的唯一性。延伸来看，它的流动性其实是比较低的。如果存在小范围的社区共识，在圈子里面流动是比较方便的，但想要出圈子往往比较困难，它会带来比较高的鉴定成本。</p> \n<p>这两年很火的A追鞋子，其实就是一种非同质性Token，鞋子拿到二级市场去交易的时候，除了做交易之外，它还附带了一个功能叫做鉴定，由交易市场主体机构来去背书为你的产品生成一个证书。</p> \n<p>非同质性Token，它的流动性比较低，与之对应的价值波动也比较大，由相应的销售门槛或者销售能力所决定的，也由供需决定。很多时候并不是要对每个资产都进行区分，确定它的唯一性。比如做大宗商品的时候，我们其实关注是某一类或者某一批货物。比如一集装箱的鞋子，品质基本上是比较接近的，我们去标记它们的时候，直接标记集装箱就可以了，而不需要标记到每一个鞋子上面。做这种业务上的简化是很有必要的，这就是衍生出来的 Non-Fungible with classes 概念。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132082\" src=\"http://localhost:8060/tup/2020/4/23/eb3b1d783de445d3901c4668a549181b.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>（1）NFT的六大特征</strong></p> \n<p>区块链上已经被实践或是被用到的NFT主要有两类：</p> \n<p>第一类就是：游戏当中的稀缺资源和角色，就像上文提到的土地，它就是一种稀缺资源。</p> \n<p>另一类就是被人创造出来的，在区块链世界当中独一无二的稀缺资源，比如玩家在游戏中创造出的数字艺术品，我们就可以用NFT去标记它。</p> \n<p>从Token的获取上来看，可能涉及到Token的发行机制。以前文提到的Cryptovoxels游戏来看，是玩家直接去找游戏的开发商买土地，买了土地Token就归属玩家。还有一种就是玩家创造出来的，比如在土地上盖个性化的房子，这就是玩家创造的一个资产，也就是说资产因为玩家的劳作而被增值了，更富有价值。这时还可以考虑把这片土地和房子一起卖掉，进行一个循环交易。</p> \n<p>另外NFT交易还存在第三方标准化的交易场所，而并不是我们想象的游戏的开发商。它跟游戏运营商没有关系，甚至可以说没有半点关系，就是一个单纯的NFT交易市场。至于买方是谁，用户并不关心，只要价位合理，符合心理预期就可以交易。这样的第三方标准化交易场所，目前在区块链行业里面也有很多了。</p> \n<p>NFT还有一个特性，就是它的可追溯性是很强的。无论它在第三方交易市场被交易了多少次，都能去追溯到Token的源头，最多就是程序加载或者优化的工作量稍微多一点而已。可追溯性同样带给了NFT一个特性，就是它的鉴定成本降低了。只要找到初始的鉴定人或者中间环节的鉴定人，目前Token所代表的物件，或者是说数字艺术品，就一定是真的，这是大家都可以去监督的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132080\" src=\"http://localhost:8060/tup/2020/4/23/719d41187a8147ad83db5cb319970a92.jpg\" alt=\"\" title=\"\"></span></p> \n<p>NFT最主要的特性是标准化，也即是把资产标准化。</p> \n<p>不管是游戏当中创造的资产，还是把链下的资产标准化登记到链上去，标准化的意义就在于可以相互打通，更方便的完成交易。可交易性体现在NFT现在可以很方便的可以出现在第三方交易市场，自由交易。</p> \n<p>也因为有了第三方交易市场，它的流动性也变高了。因为它的可追溯性，又带来了不变性这样的特点。Token所代表的线上的虚拟资产，是永远不变的。除非是对资产进一步修改之后，它重新派出了一个新的资产，这样跟原来资产就不是同一个标记了。这证明了用户所创造出来的资产，不管是游戏角色还是作品等，它都是具有稀缺性的。对于NFT的标准化和可继承性，在下文还会有更加详细的介绍。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132085\" src=\"http://localhost:8060/tup/2020/4/23/5e119f76e4cf40959dee63b13be21d42.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>（2）NFT交易市场</strong></p> \n<p>前面提到的第三方交易市场叫OpenSea，它是全球数字收藏品和NFT的交易市场，其中包括ERC721和ERC1155资产。ERC721和ERC1155，其实就是标准化协议的一种，以太坊区块链上面的NFT的资产标准化协议，通常就是指这两个协议。ERC1155是向下兼容ERC72I的，所以目前很多行业的以太坊的开发社区通常用1155协议会比较多！</p> \n<p>OpenSea是一个很开放的交易市场，只要你有以太坊的地址和以太坊钱包，就可以在上面进行交易。</p> \n<p>第二个是SuperRare，它是基于以太坊IPFS的去中心化数字艺术品交易市场。在区块链上，如果用虚拟和数字的方式创造了画作等艺术品，就可以在区块链上把它卖掉。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132083\" src=\"http://localhost:8060/tup/2020/4/23/b4021e21d19949f7ba2c0da6818534cb.jpg\" alt=\"\" title=\"\"></span></p> \n<p>第三个是Rare Bits，也是一个NFT交易市场，但是它并不局限于艺术品交易，人们可以在上面买卖很多的NFT。</p> \n<p>还有诸如Known Origin等，其实它们的服务内容基本相同，都是服务于以太坊区块链的。区分链上的NFT交易市场，其实是有很大的竞争空间的。比如说OpenSea 提供服务跟SuperRare提供的服务，在行业类别上可能有些细微差异，但是它们的服务内容是比较类似的。SuperRare和Known Origin，它们的服务内容也是处于竞争的关系。所以如果现在要去做这样一个交易市场的话，目前是有很多对手的。类似互联网发展的历史，如果想要超前，就必须赶在行业的前头，创建这样一个场景，把用户给导入进来。</p> \n<p>这一切的工作，区块链可以帮你完成一半，这一半对应的就是导流工作。并不需要花费大量人力去做获客行为，现在只需要把交易市场建立起来，然后投放出去，基本上就会有用户过来在你的垂直交易市场进行买卖行为了。NFT交易市场的建立和繁荣，也极大的推动了区块链的行业发展！</p> \n<h2><strong>四、区块链为游戏行业注入新的想象力</strong></h2> \n<hr> \n<p>接下来重点延伸一下，区块链所带来的这些标准化、可继承等概念到底有什么不一样？它未来可以发展成怎样的路径？</p> \n<p>对于游戏资产标准化，这个概念可以这样理解。如果用传统的游戏发行方式，游戏里面的土地都是属于游戏运营商的，里面可能也有超级管理的角色。其实也佐证了现在很多的游戏，它们都是各自为政的，开发出来的游戏有一套自己的标准。整个游戏生态其实是封闭的，跟别的游戏没有关系。传统的游戏会受到游戏策划的制约，而区块链上的游戏，则不会受到任何人的制约，基本上社区想做什么都可以。所以游戏资产的标准化为我们衍生出一些新的想法，如果游戏资产被标准化，那么将会赋予玩家和用户更多的创造性和流动性，也会使游戏变得更加开放，其次还可以把游戏里面的资产放到第三方交易场所去交易。</p> \n<p>游戏资产标准化应该是区块链带给游戏行业最大的点，游戏里面的资产，绝大部分应该都是NFT。在不同区块链上有不同的协议，比如在以太网上，就是前文提到的ERC721和ERC1155协议，在元界上是MIT协议，都是开放的标准。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132086\" src=\"http://localhost:8060/tup/2020/4/23/5949e8b840bf42f8ad044547921ca539.jpg\" alt=\"\" title=\"\"></span></p> \n<p>任何一个游戏都有可以预期的生命周期，游戏从上线到最后整个社区玩不动了，玩家逐渐减少，到最后关闭。在整个游戏的生命周期，玩家对这款游戏的设计和发展，几乎全程没有参与感，基本上都由游戏策划说了算。</p> \n<p>如果游戏最后被关闭了，玩家曾经在游戏里叱咤风云的记录也就随之消失。还有典型的二次元壁现象，也即游戏里创造出任何东西都跟现实生活没有关系。</p> \n<p>而区块链上的游戏则有很大的不同。区块链上的游戏是取决于社区的，只要社区有人想玩，游戏就会一直延续下去，只要社区想发展它，游戏就会一直发展下去，没有尽头。而只要社区一直保持存在，游戏的生命就会一直长久。</p> \n<p>典型的例子就是「我的世界」，「我的世界」的游戏生命周期很长，就得益于它的开放性。而且玩家的参与感也增强了，由玩家决定游戏的玩法。</p> \n<p>另外游戏数据可以永久保存，区块链可以永久记录玩家的游戏资产。关于突破虚实界限，上文也提到过，就是用户创造出来的游戏资产，可以拿数字货币直接交易和购买，它们其实就已经开始突破虚拟世界和现实世界之间的界限。</p> \n<p>比如头号玩家里面，主角的游戏体感设备就是通过玩游戏得来的，在区块链上已经能够做到这样的事情了，这也是未来的发展趋势。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132084\" src=\"http://localhost:8060/tup/2020/4/23/946c247880414cb780656bdb54962a58.jpg\" alt=\"\" title=\"\"></span></p> \n<p>在区块链上做游戏，并不意味着一定不能使用传统的方法。如果把传统做游戏的方法完全抛抛不看，其实是不对的，需要我们结合去看待。</p> \n<p>下图所示左边这张图是传统游戏网络拓扑结构，首先有个用户终端-APP，连接到服务器,底层是数据库。右边是加入区块链技术以后，除了连接自己的数据库之外，还要再连接区块链。具体用哪条区块链，由你自己去选，再根据NFT资产标准化的协议将数据放上去。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132087\" src=\"http://localhost:8060/tup/2020/4/23/4db60acfeabd4ed6948d2578330fe46d.jpg\" alt=\"\" title=\"\"></span></p> \n<p>这中间涉及到元数据的概念，并不需要把所有的游戏资产全部放上去。比如不需要把游戏的全部美术资源放上去，容易撑爆区块链，所以是不可取的。</p> \n<p>只要把游戏中一些关键参数，比如游戏的所有权、游戏道具的基本特性等传上去，这就是元数据，尽可能小而全面的关键数据。剩下的美术资源等数据依然可以存在数据库中。</p> \n<p>所以区块链如果要应用到游戏行业，并不一定要把原来所有东西全部抛除掉，只需要把区块链加进来就可以。前文只谈到了一家运营商，游戏的可玩性其实是不够的。为此我们引入多家游戏运营商，如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132088\" src=\"http://localhost:8060/tup/2020/4/23/fe85cf493a5c458f8c9d3088c44eb40e.jpg\" alt=\"\" title=\"\"></span></p> \n<p>左边是A游戏运营商，右边是B游戏运营商，传统游戏的现状可能是这样：假设A和B游戏运营商都运营了两款游戏，拥有两台服务器。可以看出，A游戏运营商和B游戏运营商基本没有关系，即使有关系可能也只是支付关系。例如用户可能在游戏中产生一笔支付，都接入到第三方中介平台，如支付机构、登记机构等。这是一个非常弱的关系，跟游戏本身几乎没有任何联系。如果把中介拿掉，对游戏本身其实是没有任何影响的。而如果这两个游戏运营商都加入区块链的话，变成如下这样的拓扑结构，游戏立马就能被打通了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132089\" src=\"http://localhost:8060/tup/2020/4/23/35aced2960384ac8b4525a5b4e23c67a.jpg\" alt=\"\" title=\"\"></span></p> \n<p>将A、B游戏运营商的游戏资产，依照标准化协议了，登记到区块链上，形成标准化资产。如果两家公司的游戏资产都是标准化的，它们之间的NFT是否就能够进行交易呢？所以这可能也是未来的一个发展方向。</p> \n<p>最后再来谈谈区块链上游戏的可继承性，在正式描述之前可以先来介绍一下区块链上游戏的发展历史。之前以太坊上存在一款CryptoKitties（以太猫）的游戏，最开始的时候非常火，折合算下来需要花费数万元才能购买到一只猫。后来用户逐渐开始萎缩，到游戏几乎消失在大众视野。但是这款游戏的日活虽然降下去了，它里面所有的用户数据，用户的游戏资产仍然存在区块链上面。</p> \n<p>后面又有一家游戏公司，拿之前CryptoKitties在区块链上的公开数据，又做了一款游戏叫CryptoHats(以太帽子)，可以继续去玩这只猫。玩的方法不一样在于玩家可以给猫做一些个性化的帽子。这个游戏非常简单，它不一样的地方在于完美继承了「以太猫」的所有用户数据，它并不需要去拉新，只需要简单激活一下就可以。</p> \n<p>所以游戏的生命周期不再局限于某一家游戏运营商，当某款游戏消失以后，仍然可以在区块链的历史上把它找出来，再增加新的idea让它继续发展下去。所以在区块链中游戏的生命周期被极大延长了，可以被完美的继承下去，一代又一代。游戏的所有用户都被完美的继承下去了。</p> \n<p>区块链为游戏行业带来了新的想象力，游戏行业里面的策划可能就不再局限于自己的一块天地了，而是面对着全世界的策划一起接受挑战，比当下单纯构造自己的游戏世界要有趣的多。</p> \n<h2><strong>五、Q&amp;A</strong></h2> \n<hr> \n<p><strong>Q：</strong>区块链数据没有办法销毁，在这种情况下，数据的所有权归谁呢？如果有些不好的数据删除，应该怎么样处理？</p> \n<p><strong>A：</strong>首先，区块链上的数据确实没有办法销毁的，这是事实。重要的是掌握好展示的途径，展示就是人类可读这件事情，总的还是要用户端或者中发的服务器来进行二次传播，只要在用户终端进行控制，其也就可以了。数据的所有权归最后一棒，就是资产最后转到谁，所有权就归谁。如果一直不动的话，归属权也是不会变化的。</p> \n<p><strong>Q：</strong>现在玩这种游戏的人多吗？</p> \n<p><strong>A：</strong>前文介绍的几款游戏，总的来说游戏画面是很一般的，暂时还不能对它们的游戏性和美术资源有比较高的标准。更多的是它对游戏本身的创新，它的开放性，它的资产交易NFT这些理念上的创新。</p> \n<h2><strong>讲师简介</strong></h2> \n<hr> \n<p>陈浩，<strong>腾讯云最具价值专家TVP</strong>，元界区块链 CTO。区块链创业者，资深数字货币交易系统架构师，《区块链第一课》一书作者，区块链技术和Token经济布道者，C++码农，拥有公链架构和高并发系统架构双重经验，拥有丰富的区块链技术分析和讲演经验。主导团队设计实现了开源公链——Metaverse元界。</p>', null, 'http://localhost:8060/tup/2020/4/23/e50ab033a278446d880e5953724b5a00.jpg', '3f69fcc9b13843d1910b3dac597f5215', '1a7cc9fbc4654cb0afec84e080816ef1', '7937aecb2ef543908ed511c9d5abceb3,9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-23 10:57:01', '2020-04-23 10:57:01');
INSERT INTO `tb_recommend` VALUES ('53249b7360074b84a7cbd6ac81fdbca0', 'Google 推出 Android 系统盲文键盘 APP，更新无障碍套件即可使用', '谷歌于 4 月 10 日宣布推出了适用于 Android 系统的虚拟盲文键盘，该盲文键盘旨在使视力低下或失明的人无需额外的硬件即可在手机上打字。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFPln\" src=\"http://localhost:8060/tup/2020/4/23/f56063ac1b92413298789232d1bfa2b6.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>谷歌于 4 月 10 日宣布推出了适用于 Android 系统的虚拟盲文键盘，该盲文键盘旨在使视力低下或失明的人无需额外的硬件即可在手机上打字。</p> \n<p>谷歌表示，它与盲文开发人员和用户合作创建了它，并确保可以在用户常用任何的键入场景使用它，包括社交媒体、文本消息和电子邮件应用程序。</p> \n<p>根据世界卫生组织的数据，全球至少有 22 亿人患有视力障碍或失明。为了满足他们的需求，Google 先前开发并发布了 BrailleBack，这是一种 Android 辅助功能，可帮助用户使用盲文设备，但 BrailleBack 不提供屏幕打字功能。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFPlz\" src=\"http://localhost:8060/tup/2020/4/23/2370f52504fe402d8e0dfdf7dfbe9299.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>虽然当前已经有实体的盲文键盘来帮助盲人和视力受损的人在手机、平板电脑与电脑上打字。然而 Google 指出，在手机等移动设备上，「每次想要快速输入内容时，连接外部设备都可能很耗时」。</p> \n<p>而 Google 此次提出的解决方案是将虚拟盲文键盘集成到 Android 操作系统中，基于屏幕实现一个典型的盲文键盘 6 键的布局。它可以「用在任何你通常会输入文字的地方使用，让你可以方便地删除字母和单词，添加回车，并发送文本。」，不过略显遗憾的是，目前这款盲文输入法还尚不能原生支持中文。</p> \n<p>目前，这项更新已经面向所有的 Android 版本 5.0 以上的设备推出；对于有需求的用户，可以在 Google Play Store 中将「Android 无障碍套件」应用更新至最新的版本即可尝试体验。</p> \n<blockquote> \n <strong>参考资料：</strong>\n <br>\n <a href=\"https://venturebeat.com/2020/04/09/google-launches-braille-keyboard-for-android-devices/\" rel=\"nofollow noreferrer\">https://venturebeat.com/2020/...</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFPlO\" src=\"http://localhost:8060/tup/2020/4/23/74bd066066f64b4a872719399d35a5bc.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFPkW\" src=\"http://localhost:8060/tup/2020/4/23/6d51235e21384da9a3a9bac7ede478fc.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/0b43020b3eda4ef9997cdd1ad3394a55.jpg', '1c5851dc916d4e70a60f0c957f548876', '819ad72c1efe450f9d7affc135a4b457', '6224a68b52f54990a07d51854b320f32,8dfc62f227ae4076888ea4872e03cddd', '0', '3', '1', '2020-04-23 10:35:12', '2020-04-23 10:35:12');
INSERT INTO `tb_recommend` VALUES ('53525c0ea70f4c61a0569bb39066e2c3', 'DeepL：一家在翻译领域超越谷歌和微软的德国公司', '科技巨头谷歌、微软和Facebook都在将机器学习的经验教训应用到翻译领域，但一家名为DeepL的小公司却超越了他们，提高了这个领域的标准。它的翻译工具的速度不亚于那些规模庞大的竞争对手，但比我们尝试过的任何一...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道丨公众号：SegmentFault</strong></p> \n<hr> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFP66\" src=\"http://localhost:8060/tup/2020/4/23/2f46a2cf44154663a8c5eb592fc2d424.jpg\" alt=\"AI Assistance for Language。DeepL trains artificial intelligenceto understand and translate texts.\" title=\"AI Assistance for Language。DeepL trains artificial intelligenceto understand and translate texts.\"></span></p> \n<p>科技巨头谷歌、微软和Facebook都在将机器学习的经验教训应用到翻译领域，但一家名为DeepL的小公司却超越了他们，提高了这个领域的标准。它的翻译工具的速度不亚于那些规模庞大的竞争对手，但比我们尝试过的任何一款翻译工具都要准确和细致。</p> \n<p>经过几次试验，我们都认为DeepL的翻译普遍优于Google Translate和Bing的翻译。Google Translate经常会去找一个非常直白的翻译，错过了一些细微的差别和成语（或者是把这些成语翻译成错了），而DeepL经常提供一个更自然的翻译，更接近于一个训练有素的翻译者的翻译。</p> \n<p><strong>DeepL从Linguee演化而来</strong></p> \n<p>DeepL诞生于同样优秀的Linguee，这是一款已经存在多年的翻译工具，虽然很受欢迎，但一直没有达到谷歌翻译的水平--毕竟后者在品牌和地位上有很大的优势。Linguee的联合创始人Gereon Frahling曾在Google Research工作过，但在2007年离开Google并开始了自己的新的事业Linguee。</p> \n<p>这支团队多年来一直致力于机器学习，从事与核心翻译相邻的任务，但直到去年，他们才开始认真地研究一个全新的系统和公司，而这两个系统和公司的名字都将是DeepL。</p> \n<p>Frahling提到现在时机已经成熟：\"我们已经建立了一个神经翻译网络，其中包含了大部分最新的发展，我们在其中加入了自己的想法。\"</p> \n<p>一个由超过10亿个翻译和查询组成的庞大数据库，再加上通过在网络上搜索类似的片段进行落地翻译的方法，为新模型的训练打下了坚实的基础。他们还把他们声称的世界上第23台最强大的超级计算机放在了一起，位于冰岛境内。</p> \n<p>DeepL的翻译服务使用了搭建在Linguee数据库之上的卷积神经网络及另一种并未公布的专有方法涉及注意力机制。DeepL GmbH拥有一台浮点性能为5 Petaflops的机器，用于其翻译服务的训练和生产。</p> \n<p>由大学、研究机构以及Linguee公司的竞争对手所公布的发展情况表明，卷积神经网络才是发展的方向，而不是该公司之前一直使用的递归神经网络。现在真的不是深入研究CNNs和RNNNs之间的区别的地方，所以必须要说的是，对于长的、复杂的相关词串的准确翻译，只要你能控制好它的弱点，前者是一个更好的选择。</p> \n<p>例如，CNN大致可以说是可以一次解决一个单词的句子。但当比如经常发生的情况，句尾的一个词决定了句子开头的一个词应该如何组成时，这就成了问题。通读整个句子，只是发现网络选取的第一个词是错误的，然后再根据这个知识重新开始，这是很浪费的，所以DeepL和机器学习领域的其他人应用了 \"注意力机制\"，监控这种潜在的绊脚石，并在CNN转移到下一个词或短语之前解决它们。</p> \n<p><strong>关于隐私政策</strong></p> \n<p>无论是DeepL Pro还是免费的DeepL Translator都不允许被用于翻译“包含任何种类个人资料的文本” 与免费版不同，DeepL Pro宣称并不会储存翻译文本。更多可以查看他们的<a href=\"https://www.deepl.com/privacy.html\" rel=\"nofollow noreferrer\">privacy</a>。</p> \n<p>感兴趣的同学们可以试一试，相信Deepl会成为你新的助力你翻译的生产力工具。我们也非常欢迎对Deepl背后技术的同学们分享更多他们更多技术相关的细节。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"http://localhost:8060/tup/2020/4/23/7b08ea392d7f4eafb346daeda24d54ee.jpg\" alt=\"SegmentFault思否微信公众号\" title=\"SegmentFault思否微信公众号\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/3196a7fa7f964c2ca7da89ebbbc14fe9.jpg', '1894b118d35d44cb8fe8009529c4154b', '2a353971222c4aff8e8d3e9c370330cd', 'efd45535a5504d5595fba4d1dbbc489c,db6b58ae709645f2b64166fd73f2f705,9223827da7dc4f1c8f6790777fb42d6e,9d5eb002705648e2bc3d345fa34a8191', '0', '3', '1', '2020-04-23 11:00:53', '2020-04-23 11:00:53');
INSERT INTO `tb_recommend` VALUES ('55fcd0ffd6bb445b827f6469dd037605', '用 MelonJS 开发一个游戏', '游戏开发并不需要局限于使用 Unity 或 Unreal Engine4 的用户。 JavaScript 游戏开发已经有一段时间了。实际上，最流行的浏览器（例如Chrome，Firefox和Edge）的最新版本提供了对高级图形渲染（例如WebGL）的支持...', '<blockquote>\n 作者：Fernando Doglio\n <p>翻译：疯狂的技术宅</p> \n <p>原文：<a href=\"https://blog.bitsrc.io/writing-a-typing-game-with-melonjs-ef0dd42f37bf\" rel=\"nofollow noreferrer\">https://blog.bitsrc.io/writin...</a></p> \n <p><strong>未经允许严禁</strong></p> \n</blockquote> \n<p>游戏开发并不需要局限于使用 Unity 或 Unreal Engine4 的用户。 JavaScript 游戏开发已经有一段时间了。实际上，最流行的浏览器（例如Chrome，Firefox和Edge）的最新版本提供了对高级图形渲染（例如<a href=\"https://get.webgl.org/\" rel=\"nofollow noreferrer\">WebGL</a>）的支持，从而带来了非常有趣的游戏开发机会。</p> \n<p>不过用 WebGL 进行游戏开发没有办法在一篇文章中涵盖其所有内容（有专门为此编写的完整书籍），并且出于个人喜好，在深入研究特定技术之前，我更倾向于依赖框架的帮助。</p> \n<p>这就是为什么经过研究后，我决定用 <a href=\"http://www.melonjs.org/\" rel=\"nofollow noreferrer\">MelonJS</a> 编写此快速教程的原因。</p> \n<h2>什么是 MelonJS？</h2> \n<p>你可能已经猜到了，MelonJS 是一个 JavaScript 游戏引擎，与所有主流浏览器完全兼容（从 Chrome 到 Opera，一直到移动版 Chrome 和 iOS Safari）。</p> \n<p>它具有一系列功能，在我的研究过程中非常引人注目：</p> \n<ul> \n <li>对于初学者来说，它是完全独立的，不需要外部依赖就可以使它工作。</li> \n <li>但是，它可以与多个第三方工具集成在一起，使你的工作更加轻松，例如<a href=\"https://github.com/bjorn/tiled/wiki\" rel=\"nofollow noreferrer\">Tiled</a>（可帮助你创建地图和游戏关卡），<a href=\"https://github.com/melonjs/melonJS/wiki/How-to-use-Texture-Atlas-with-TexturePacker\" rel=\"nofollow noreferrer\">TexturePacker</a>（帮助你创建所需的纹理图集并简化和优化精灵管理）。</li> \n <li>集成了 2D 物理引擎。这意味着你可以使用开箱即用的逼真的 2D 运动和碰撞检测。这很关键，因为必须解决所有这些问题，这需要大量的工作（更不用说数学运算了，这并不是我的菜）。</li> \n <li>支持声音 API，使你能够以出色的简便性添加声音效果和背景音乐。</li> \n</ul> \n<p>该引擎还有其他令人赞叹的功能，你可以在其网站上进行查看，不过以上是本文中我们最关注的功能。</p> \n<p><strong>提示：</strong>使用 <a href=\"https://bit.dev/\" rel=\"nofollow noreferrer\"><strong>Bit</strong></a>（<a href=\"https://github.com/teambit/bit\" rel=\"nofollow noreferrer\">Github</a>）可以轻松共享和重用 JS 模块，项目中的 UI 组件，建议更新。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqEU?w=650&amp;h=355\" src=\"http://localhost:8060/tup/2020/4/23/d90a532250124b5ba0ea1a6bf2ec9c29.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>Bit 组件：能够轻松地在团队中跨项目共享</p> \n<h2>设计我们的游戏</h2> \n<p>打字游戏的目的是通过打字（或敲击随机键）为玩家提供移动或执行某种动作的能力。</p> \n<p>我记得小时候曾经学过如何打字（是的，很久以前）了，当时在“Mario Teaches Typing” 这个游戏中，必须键入单个字母才能前进，要么跳到乌龟上，要么从下面打一个方块。下图为你提供了游戏外观以及怎样与之进行互动的想法。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqEW?w=523&amp;h=347\" src=\"http://localhost:8060/tup/2020/4/23/723b3c6c135a4b24acf09dce1c4951f4.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>尽管这是一个有趣的小游戏，但它并不是一个真正的平台游戏，Mario 所执行的动作始终对应一个按键，并且永远不会失效。</p> \n<p>不过，对于本文，我想让事情变得更有趣，并不是创建一个简单的打字游戏，例如上面的游戏：</p> \n<p>游戏不会通过单个字母来决定下一步的行动，而是提供了五个选择，并且每个选择都必须写一个完整的单词：</p> \n<ol> \n <li>前进</li> \n <li>向前跳</li> \n <li>跳起来</li> \n <li>向后跳</li> \n <li>向后移动</li> \n</ol> \n<p>换句话说，你可以通过输入的单词来移动角色，而不是经典的基于箭头进行控制。</p> \n<p>除此之外，该游戏将是一个经典平台游戏，玩家可以通过走动收集金币。为了简洁起见，我们会将敌人和其他类型的实体排除在本教程之外（尽管你应该能够推断出所使用的代码，并能基于该代码创建自己的实体）。</p> \n<p>为了使本文保持合理的长度，我将只关注一个阶段，全方位的动作（换句话说，你将能够执行所有 5 个动作）、几个敌人、一种收藏品，还有数量可观的台阶供你跳来跳去。</p> \n<h2>你需要的工具</h2> \n<p>尽管 melonJS 是完全独立的，但在此过程中有一些工具可以帮助大家，我建议你使用它们：</p> \n<ul> \n <li> <a href=\"https://www.codeandweb.com/texturepacker\" rel=\"nofollow noreferrer\">Texture Packer</a>：有了这个，你将能够自动生成纹理图集，这是另一种表达 JSON 文件的方式，其中打包了所有图像，以便引擎以后可以检索并根据需要使用它们。 如果你没有这个工具，那么手动维护地图集可能会消耗太多的时间。</li> \n <li>Tiled：这将是我们的关卡编辑器。尽管你可以免费下载它（你需要找到显示“No thanks, just take me to the downloads” 的链接），但是你可以向该神奇工具的作者捐献最低 1 美元。如果你有可用的 PayPal 帐户或借记卡，建议你这样做，这样的软件需要维护，并且需要付出时间和精力。</li> \n</ul> \n<p>使用这些工具，你将可以继续学习并完成本教程，所以让我们开始编码吧。</p> \n<h2>基本的平台游戏</h2> \n<p>为了开始这个项目，我们可以使用一些示例代码。下载引擎时，它将默认附带一组示例项目，你可以检出这些项目（它们位于 <em>example</em> 文件夹中）。</p> \n<p>这些示例代码是我们用来快速启动项目的代码。在其中，你会发现：</p> \n<ul> \n <li> <em>data</em> 文件夹，包含与代码无关的所有内容。在这里你可以找到声音、音乐、图像、地图定义甚至字体。</li> \n <li> <em>js文件夹</em>，你将在这里保存所有与游戏相关的代码。</li> \n <li> <em>index.html 和 index.css文件</em>。这些是你的应用与外界互动所需的联系点。</li> \n</ul> \n<h3>了解现有代码</h3> \n<p>现在暂时将资源留在 <em>data</em> 文件夹中，我们需要了解该示例为我们提供了什么。</p> \n<h4>执行游戏</h4> \n<p>要执行游戏，你需要做一些事情：</p> \n<ol> \n <li>一份 melonJS。如果已下载，请确保获得 <code>dist</code> 文件夹的内容。将其复制到任意文件夹中，并确保像其他 JS 文件一样，将其添加到 <code>index.html</code> 文件中。</li> \n <li>安装（如果尚未安装）npm 中提供的 <a href=\"https://www.npmjs.com/package/http-server\" rel=\"nofollow noreferrer\">http-server</a> 模块，该模块可以快速为相关文件夹提供 HTTP 服务。如果尚未安装，只需执行以下操作：</li> \n</ol> \n<pre><code class=\"bash\">$ npm install -g http-server</code></pre> \n<p>安装完成后，从项目文件夹中运行：</p> \n<pre><code class=\"bash\">$ http-server</code></pre> \n<p>这时你可以通过访问 <code>http://localhost:8080</code> 来测试游戏。</p> \n<h4>查看代码</h4> \n<p>在游戏中你会发现这是一个能够进行基本（非常尴尬）动作的平台游戏，几个不同的敌人和一个收藏品。基本上这与我们的目标差不多，但控制方案略有不同。</p> \n<p>这里要检查的关键文件是：</p> \n<ul> \n <li> <strong>game.js</strong>：该文件包含所有初始化代码，有趣的是如何实例化游戏图形和主控件。</li> \n <li> <strong>screens/play.js</strong>：包含设置关卡所需的所有代码。你会注意到它内容并不多。由于级别定义是使用其他工具（即 Tiled）完成的，所以此代码只是启用了该功能。</li> \n <li> <strong>entities/player.js</strong>：显然这是你的主要目标。该文件包含你角色的移动代码，碰撞反应和控制键绑定。虽然规模并不大，却是你想花费最多时间的地方。</li> \n <li> <strong>entities/enemies.js</strong>：仅次于 player 代码，这很重要，因为你将看到如何基于预定义的坐标来设置自动行为。</li> \n</ul> \n<p>其余文件也很有用，但并不是那么重要，我们会在需要时使用它们。</p> \n<h3>了解一切从何而来</h3> \n<p>如果你提前做好了了功课，可能已经注意到了，没有一行实例化玩家或敌人的代码。他们的坐标无处可寻。那么，游戏该如何理解呢？</p> \n<p>这是关卡编辑器所起到的作用。如果你下载了Tiled，则可以在 <code>data/map</code> 文件夹中打开名为 <code>map1.tmx</code> 的文件，然后会看到类似下面的内容：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFa?w=674&amp;h=383\" src=\"http://localhost:8060/tup/2020/4/23/136ace00040b4ab891c7fa9b3c647498.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>屏幕的中心部分向你显示正在设计的关卡。如果仔细观察，你会看到图像和矩形形状，其中一些具有不同的颜色和名称。这些对象代表游戏中的 <em>东西</em>，具体取决于它们的名称和所属的层。</p> \n<p>在屏幕的右侧，你会在其中看到图层列表（在右上方）。有不同类型的层：</p> \n<ul> \n <li>图像层：用于背景或前景图像</li> \n <li>对象层：用于碰撞对象、实体以及你想在地图中实例化的任何对象。</li> \n <li>Tile 层：你将在其中放置 Tile 以创建实际关卡的位置。</li> \n</ul> \n<p>右下角包含此地图的图块。 tileet 也可以由 Tiled 创建，并且可以在同一文件夹中以 <em>tsx</em> 扩展名找到该 tileet。</p> \n<p>最后，在屏幕左侧，你会看到“属性”部分，在这里你将看到有关所选对象或单击的图层的详细信息。你将能够更改通用属性（例如图层的颜色，以便更好地了解其对象的位置）并添加自定义属性（稍后将其作为参数传递给游戏中实体的构造函数）。</p> \n<h2>更改运动方案</h2> \n<p>现在我们已经准备好进行编码了，让我们专注于本文的主要目的，我们将以示例的工作版本为例，尝试对其进行修改，使其可以用作打字游戏。</p> \n<p>这意味着，需要更改的第一件事是运动方案，或者换句话说：更改控制。</p> \n<p>转到 <code>entities/player.js</code> 并检查 <code>init</code> 方法。你会注意到很多 <code>bindKey</code> 和 <code>bindGamepad</code> 调用。这些代码本质上是将特定按键与逻辑操作绑定在一起。简而言之，它可以确保无论你是按向右箭头键，D 键还是向右移动模拟摇杆，都会在代码中触发相同的“向右”动作。</p> \n<p>所有这些都需要将其删除，这对我们没什么用。同时创建一个新文件，将其命名为 <code>wordServices.js</code>，并在此文件中创建一个对象，该对象将在每个回合中返回单词，这能够帮助我们了解玩家到底选择了哪个动作。</p> \n<pre><code class=\"javascript\">/**\n * Shuffles array in place.\n * @param {Array} a items An array containing the items.\n */\nfunction shuffle(a) {\n    var j, x, i;\n    for (i = a.length - 1; i &gt; 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        x = a[i];\n        a[i] = a[j];\n        a[j] = x;\n    }\n    return a;\n}\n\n\nActionWordsService = {\n\n    init: function(totalActions) {\n        //load words...\n        this.words = [\n            \"test\", \"hello\", \"auto\", \"bye\", \"mother\", \"son\", \"yellow\", \"perfect\", \"game\"\n        ]\n        this.totalActions = totalActions\n        this.currentWordSet = []\n    },\n\n    reshuffle: function() {\n        this.words = shuffle(this.words)\n    },\n\n    getRegionPostfix: function(word) {\n        let ws = this.currentWordSet.find( ws =&gt; {\n            return ws.word == word\n        })\n        if(ws) return ws.regionPostfix\n        return false\n    },\n\n    getAction: function(word) {\n        let match = this.getWords().find( am =&gt; {\n            return am.word == word\n        })\n        if(match) return match.action\n        return false\n    },\n\n    getWords: function() {\n        let actions = [ { action: \"right\", coords: [1, 0], regionPostfix: \"right\"}, \n                        { action: \"left\", coords: [-1, 0], regionPostfix: \"left\"}, \n                        { action: \"jump-ahead\", coords: [1,-0.5], regionPostfix: \"upper-right\"}, \n                        { action: \"jump-back\", coords:[-1, -0.5], regionPostfix: \"upper-left\"},\n                        { action: \"up\", coords: [0, -1], regionPostfix: \"up\"}\n                    ]\n\n       this.currentWordSet = this.words.slice(0, this.totalActions).map( w =&gt; {\n            let obj = actions.shift()\n            obj.word = w\n            return obj\n       })\n       return this.currentWordSet\n    }\n}</code></pre> \n<p>本质上，该服务包含一个单词列表，然后将其随机排列，并且每次请求该列表时（使用 getWords 方法），都会随机获取一组单词，并将它们分配给上面提到的一种操作。还有与每个操作相关的其他属性：</p> \n<ul> \n <li>基于动作 HUD，<strong>coords</strong> 属性用于将文本放置在正确的坐标中（稍后会详细介绍）</li> \n <li> <strong>regionPostfix</strong> 属性用于为 HUD 操作选择正确的框架。</li> \n</ul> \n<p>现在，让我们看看如何在游戏过程中请求用户输入。</p> \n<p>注意：继续前进之前，请记住，为了使新服务可用于其余代码，你必须将其包含在 <code>index.html</code> 文件中，就像其他 JS 库一样：</p> \n<pre><code class=\"html\">&lt;script type=\"text/javascript\" src=\"js/wordServices.js\"&gt;&lt;/script&gt;</code></pre> \n<h3>如何捕获用户输入</h3> \n<p>你可以潜在地使用键绑定的组合来模仿使用游戏元素的输入字段的行为，但是请考虑输入字段默认提供的所有可能的组合和行为（例如，粘贴文本、选择、移动而不删除字符等） ），必须对所有程序进行编程以使其可用。</p> \n<p>相反，我们可以简单地在 HTML 主页面中添加一个文本字段，并使用 CSS 对其进行样式设置，使其位于 Canvas 元素之上，它将成为游戏的一部分。</p> \n<p>你只需要在 <code>&lt;body&gt;</code> 内的这段代码即可：</p> \n<pre><code class=\"html\">&lt;input type=\"text\" id=\"current-word\" /&gt;</code></pre> \n<p>尽管这完全取决于你，但我还是建议你使用 <a href=\"https://jquery.com/\" rel=\"nofollow noreferrer\">jQuery</a> 来简化将回调附加到 <code>keypress</code> 事件上所需的代码。当然可以使用原生 JS 完成此操作，但我更喜欢这个库提供的语法糖。</p> \n<p>以下代码位于 <code>game.js</code> 文件的 <code>load</code> 方法中，负责捕获用户的输入：</p> \n<pre><code class=\"javascript\">me.$input = $(\"#current-word\")\n\nlet lastWord = \'\'\nme.$input.keydown( (evnt) =&gt; {\n\n    if(evnt.which == 13) {\n        console.log(\"Last word: \", lastWord)\n        StateManager.set(\"lastWord\", lastWord)\n        lastWord = \'\'\n        me.$input.val(\"\")\n    } else {\n        if(evnt.which &gt; 20) {\n            let validChars = /[a-z0-9]+/gi\n            if(!String.fromCharCode(evnt.which).match(validChars)) return false\n          }\n\n        setTimeout(_ =&gt; {\n            lastWord = me.$input.val() //String.fromCharCode(evnt.which)\n            console.log(\"Partial: \", lastWord)\n        }, 1)\n    }\n    setTimeout(() =&gt; {\n        StateManager.set(\"partialWord\", me.$input.val())\n    }, 1);\n})</code></pre> \n<p>本质上是我们捕获输入元素并将其存储在全局对象 <code>me</code> 中。这个全局变量包含游戏所需的一切。</p> \n<p>这样，我们可以为按下的任何按键设置事件处理程序。如你所见，我正在检查键码 13（代表ENTER键）以识别玩家何时完成输入，否则我将确保他们输入的是有效字符（我只是避免使用特殊字符，这样可以防止 melonJS 提供的默认字体出现问题）。</p> \n<p>最后我在 <code>StateManager</code> 对象上设置了两个不同的状态，<em>lastWord</em> 了解玩家输入的最后一个单词，<em>partialWord</em> 解现在正在输入的内容。这两种状态很重要。</p> \n<h3>组件之间共享数据</h3> \n<p>如何在组件之间共享数据是很多框架中的常见问题。我们将捕获的输入作为 <code>game</code> 组件的一部分，那么该如何与他人共享这个输入呢？</p> \n<p>我的解决方案是创建一个充当<a href=\"https://nodejs.org/api/events.html\" rel=\"nofollow noreferrer\">事件发送器（event emitter）</a>的全局组件：</p> \n<pre><code class=\"javascript\">const StateManager = {\n\n    on: function(k, cb) {\n        console.log(\"Adding observer for: \", k)\n        if(!this.observers) {\n            this.observers = {}\n        }\n\n        if(!this.observers[k]) {\n            this.observers[k] = []\n        }\n        this.observers[k].push(cb)\n    },\n    clearObserver: function(k) {\n        console.log(\"Removing observers for: \", k)\n        this.observers[k] = []\n    },\n    trigger: function(k) {\n        this.observers[k].forEach( cb =&gt; {\n            cb(this.get(k))\n        })\n    },\n    set: function(k, v) {\n        this[k] = v\n        this.trigger(k)\n    },\n    get: function(k) {\n        return this[k]\n    }\n\n}</code></pre> \n<p>代码非常简单，你可以为特定状态设置多个“观察者”（它们是回调函数），并且一旦设置了该状态（即更改），便会用新值调用所有这些回调。</p> \n<h3>添加 UI</h3> \n<p>创建关卡之前的最后一步是显示一些基本的 UI。因为我们需要显示玩家可以移动的方向以及需要输入的单词。</p> \n<p>为此将使用两个不同的UI元素：</p> \n<ul> \n <li>一个用于图形，它将具有几个不同的帧，本质上一个用于正常图像，然后一个将每个方向显示为“selected”（与 <code>ActionWordsService</code> 上的 <code>regionPostfix</code> 属性相关联）</li> \n <li>一个用于在图像周围输出文本。顺便说一下，这也与 <code>ActionWordsService</code> 上的 <code>coords</code> 属性相关联。</li> \n</ul> \n<p>我们可以在 js 文件夹内搭上现有的 HUD.js 文件。在其中添加两个新组件。</p> \n<p>第一个是 <code>ActionControl</code> 组件，如下所示：</p> \n<pre><code class=\"javascript\">game.HUD.ActionControl = me.GUI_Object.extend({\n    init: function(x, y, settings) {\n        game.HUD.actionControlCoords.x = x //me.game.viewport.width - (me.game.viewport.width / 2)\n        game.HUD.actionControlCoords.y = me.game.viewport.height - (me.game.viewport.height / 2) + y\n\n        settings.image = game.texture;\n\n        this._super(me.GUI_Object, \"init\", [\n            game.HUD.actionControlCoords.x, \n            game.HUD.actionControlCoords.y, \n            settings\n        ])\n\n        //update the selected word as we type\n        StateManager.on(\'partialWord\', w =&gt; {\n            let postfix = ActionWordsService.getRegionPostfix(w)\n            if(postfix) {\n                this.setRegion(game.texture.getRegion(\"action-wheel-\" + postfix))\n            } else {\n                this.setRegion(game.texture.getRegion(\"action-wheel\")\n            }\n            this.anchorPoint.set(0.5,1)\n        })\n\n        //react to the final word\n        StateManager.on(\'lastWord\', w =&gt; {\n            let act = ActionWordsService.getAction(w)\n            if(!act) {\n\n                me.audio.play(\"error\", false);\n                me.game.viewport.shake(100, 200, me.game.viewport.AXIS.X)\n                me.game.viewport.fadeOut(\"#f00\", 150, function(){})\n           } else {\n               game.data.score += Constants.SCORES.CORRECT_WORD\n           }\n        })\n    }\n})</code></pre> \n<p>看起来很多，但是它只是做了一点事情：</p> \n<ol> \n <li>它从 <code>settings</code> 属性中提取其坐标，在 Tiled 上设置地图后，我们将对其进行检查。</li> \n <li>添加对输入了一部分的单词作出反应的代码。我们将 <code>postfix</code> 属性用于当前编写的单词。</li> \n <li>并添加了对完整的词做出反应的代码。如果某个动作与该字词相关联（即是正确的词），那么它将为玩家加分。否则将晃动屏幕并播放错误声音。</li> \n</ol> \n<p>第二个图形部分，即要输入的单词，如下所示：</p> \n<pre><code class=\"javascript\">game.HUD.ActionWords = me.Renderable.extend({\n    init: function(x, y) {\n        this.relative = new me.Vector2d(x, y);\n\n        this._super(me.Renderable, \"init\", [\n            me.game.viewport.width + x,\n            me.game.viewport.height + y,\n            10, //x &amp; y coordinates\n            10\n        ]);\n\n         // Use screen coordinates\n        this.floating = true;\n\n        // make sure our object is always draw first\n        this.z = Infinity;\n        // create a font\n        this.font = new me.BitmapText(0, 0, {\n            font : \"PressStart2P\",\n            size: 0.5,\n            textAlign : \"right\",\n            textBaseline : \"bottom\"\n        });\n\n        // recalculate the object position if the canvas is resize\n        me.event.subscribe(me.event.CANVAS_ONRESIZE, (function(w, h){\n            this.pos.set(w, h, 0).add(this.relative);\n        }).bind(this));\n\n        this.actionMapping = ActionWordsService.getWords()\n    },\n\n    update: function() {\n        this.actionMapping = ActionWordsService.getWords()\n        return true\n    },\n    draw: function(renderer) {\n        this.actionMapping.forEach( am =&gt; {\n            if(am.coords[0] == 0 &amp;&amp; am.coords[1] == 1) return \n            let x = game.HUD.actionControlCoords.x + (am.coords[0]*80) + 30\n            let y = game.HUD.actionControlCoords.y + (am.coords[1]*80) - 30\n            this.font.draw(renderer, am.word, x, y)\n        })\n    }\n})</code></pre> \n<p>该组件的繁重工作是通过 <code>draw</code> 方法完成的。 <code>init</code> 方法只是初始化变量。在调用 <code>draw</code> 的过程中，我们将迭代选定的单词，并使用与之相关的坐标以及一组固定数字，将单词定位在 <code>ActionControl</code> 组件的坐标周围。</p> \n<p>这是建议的动作控制设计的样子（以及坐标如何与之关联）：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFp?w=333&amp;h=255\" src=\"http://localhost:8060/tup/2020/4/23/632098a6c904450aa1468bfa3bddb6df.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>当然，它应该有透明的背景。</p> \n<p>只需确保将这些图像保存在 <code>/data/img/assets/UI</code> 文件夹中，这样当你打开 TexturePacker 时，它将识别出新图像并将其添加到纹理中地图集。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFt?w=678&amp;h=351\" src=\"http://localhost:8060/tup/2020/4/23/a63bf280ba7a4b4186594f928bc73f90.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>上图显示了如何添加 action wheel 的新图像。然后，你可以单击“Publish sprite sheet”并接受所有默认选项。它将覆盖现有的地图集，因此对于你的代码无需执行任何操作。这一步骤至关重要，因为纹理地图集将作为资源加载（一分钟内会详细介绍），并且多个实体会将其用于动画之类的东西。请记住，在游戏上添加或更新图形时，都务必这样做。</p> \n<h2>将所有内容与Tiled放在一起</h2> \n<p>好了，现在我们已经介绍了基础知识，让我们一起玩游戏。首先要注意的是：地图。</p> \n<p>通过使用 tiled 和 melonJS 中包含的默认 tileet，我创建了这个地图（ 25x16 tiles 地图，其中 tile 为 32 x 32px）：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFE?w=676&amp;h=338\" src=\"http://localhost:8060/tup/2020/4/23/0a7c91675ba54fae89854ae26c3d6492.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>这些是我正在使用的图层：</p> \n<ul>\n <li>HUD：它仅包含一个名为 <strong>HUD.ActionControl</strong> 的元素（重要的是要保持名称相同，一会儿你会明白为什么）。下图显示了此元素的属性（请注意自定义属性）</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFJ?w=265&amp;h=412\" src=\"http://localhost:8060/tup/2020/4/23/729606b8fb8f4a1fbbb3802f2cde7b1d.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<ul> \n <li>collision：默认情况下，melonJS 会把以 <code>collision</code> 开头的所有层都假定为碰撞层，这意味着其中的任何形状都是不可遍历的。在这里你将定义地板和平台的所有形状。</li> \n <li>player：该层仅包含 <strong>mainPlayer</strong> 元素（一种形状，该形状将使 melonJS 知道在游戏开始时需要放置玩家的位置）。</li> \n <li>entities：在这一层中，我再次添加了硬币，它们的名称很重要，请保持一致，因为它们需要与你在代码中注册的名称相匹配。</li> \n <li>最后三层就可以在其中添加地图和背景的图像。</li> \n</ul> \n<p>准备好之后，我们可以转到 <code>game.js</code> 文件，并在 <code>loaded</code> 方法内添加以下几行：</p> \n<pre><code class=\"javascript\">// register our objects entity in the object pool\nme.pool.register(\"mainPlayer\", game.PlayerEntity);\nme.pool.register(\"CoinEntity\", game.CoinEntity);\nme.pool.register(\"HUD.ActionControl\", game.HUD.ActionControl);</code></pre> \n<p>这些代码用来注册你的实体（你要使用 Tiled 直接放置在地图上的实体）。第一个参数提供的名称是你需要用 Tiled 进行匹配的名称。</p> \n<p>此外，在此文件中，<code>onLoad</code> 方法应如下所示：</p> \n<pre><code class=\"javascript\">  onload: function() {\n\n        // init the video\n        if (!me.video.init(965, 512, {wrapper : \"screen\", scale : \"auto\", scaleMethod : \"fit\", renderer : me.video.AUTO, subPixel : false })) {\n            alert(\"Your browser does not support HTML5 canvas.\");\n            return;\n        }\n\n        // initialize the \"sound engine\"\n        me.audio.init(\"mp3,ogg\");\n\n        // set all ressources to be loaded\n        me.loader.preload(game.resources, this.loaded.bind(this));\n        ActionWordsService.init(5)\n    },</code></pre> \n<p>我们的基本要求是 <code>965x512</code> 的分辨率（我发现，当屏幕的高度与地图的高度相同时效果很好。在我们的例子中为 <code>16*32 = 512</code>）之后，将使用5个单词（这些是你可以继续前进的5个方向）初始化 <code>ActionWordsService</code> 。</p> \n<p><code>onLoad</code> 方法中另一条有趣的代码是：</p> \n<pre><code class=\"javascript\">me.loader.preload(game.resources, this.loaded.bind(this));</code></pre> \n<h3>资源文件</h3> \n<p>游戏需要的所有类型的资源（即图像、声音、背景音乐、JSON 配置文件等）都需要添加到 <code>resources.js</code> 文件中。</p> \n<p>这是你资源文件的内容：</p> \n<pre><code class=\"javascript\">game.resources = [\n\n    { name: \"tileset\",     type:\"image\", src: \"data/img/tileset.png\" },\n    { name: \"background\",  type:\"image\", src: \"data/img/background.png\" },\n    { name: \"clouds\",      type:\"image\", src: \"data/img/clouds.png\" },\n\n    \n    { name: \"screen01\", type: \"tmx\", src: \"data/map/screen01.tmx\" },\n\n    { name: \"tileset\",  type: \"tsx\", src: \"data/map/tileset.json\" },\n\n    { name: \"action-wheel\", type:\"image\", src: \"data/img/assets/UI/action-wheel.png\" },\n    { name: \"action-wheel-right\", type:\"image\", src: \"data/img/assets/UI/action-wheel-right.png\" },\n    { name: \"action-wheel-upper-right\",type:\"image\", src: \"data/img/assets/UI/action-wheel-upper-right.png\" },\n    { name: \"action-wheel-up\", type:\"image\", src: \"data/img/assets/UI/action-wheel-up.png\" },\n    { name: \"action-wheel-upper-left\", type:\"image\", src: \"data/img/assets/UI/action-wheel-upper-left.png\" },\n    { name: \"action-wheel-left\", type:\"image\", src: \"data/img/assets/UI/action-wheel-left.png\" },\n\n    { name: \"dst-gameforest\", type: \"audio\", src: \"data/bgm/\" },\n\n    { name: \"cling\",     type: \"audio\", src: \"data/sfx/\" },\n    { name: \"die\",       type: \"audio\", src: \"data/sfx/\" },\n    { name: \"enemykill\", type: \"audio\", src: \"data/sfx/\" },\n    { name: \"jump\",      type: \"audio\", src: \"data/sfx/\" },\n\n    { name: \"texture\",   type: \"json\",  src: \"data/img/texture.json\" },\n    { name: \"texture\",   type: \"image\", src: \"data/img/texture.png\" },\n\n    { name: \"PressStart2P\", type:\"image\", src: \"data/fnt/PressStart2P.png\" },\n    { name: \"PressStart2P\", type:\"binary\", src: \"data/fnt/PressStart2P.fnt\"}\n];</code></pre> \n<p>其中你可以使用诸如图块集、屏幕映射之类的东西（请注意，名称始终是不带扩展名的文件名，这是强制性的要求，否则将找不到资源）。</p> \n<h3>硬币</h3> \n<p>游戏中的硬币非常简单，但是当你与它们碰撞时，需要发生一些事情，它们的代码如下所示：</p> \n<pre><code class=\"javascript\">game.CoinEntity = me.CollectableEntity.extend({\n\n    /**\n     * constructor\n     */\n    init: function (x, y, settings) {\n        // call the super constructor\n        this._super(me.CollectableEntity, \"init\", [\n            x, y ,\n            Object.assign({\n                image: game.texture,\n                region : \"coin.png\"\n            }, settings)\n        ]);\n\n    },\n\n    /**\n     * collision handling\n     */\n    onCollision : function (/*response*/) {\n\n        // do something when collide\n        me.audio.play(\"cling\", false);\n        // give some score\n        game.data.score += Constants.SCORES.COIN\n\n        //avoid further collision and delete it\n        this.body.setCollisionMask(me.collision.types.NO_OBJECT);\n\n        me.game.world.removeChild(this);\n\n        return false;\n    }\n});</code></pre> \n<p>请注意，硬币实体实际上是扩展了 <code>CollectibleEntity</code> （这给它提供了一个特殊的冲撞类型给实体，因此melonJS知道在玩家移过它时会调用碰撞处理程序），你要做的就是调用其父级的构造函数，然后当你拾起它时,在 <code>onCollision</code> 方法上会播放声音，在全局得分中加 1，最后从世界中删除对象。</p> \n<h2>成品</h2> \n<p>将所有内容放在一起，就有了一个可以正常工作的游戏，该游戏可以让你根据输入的单词在 5 个不同的方向上移动。</p> \n<p>它看起来应该像这样：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFK?w=677&amp;h=358\" src=\"http://localhost:8060/tup/2020/4/23/9e7cd82f32664f8a93184ee7246c5084.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>并且由于本教程已经太长了，你可以在 <a href=\"https://github.com/deleteman/plaformer-sample-1\" rel=\"nofollow noreferrer\">Github</a> 上查看该游戏的完整代码。</p> \n<hr> \n<h4>本文首发微信公众号：前端先锋</h4> \n<h4>欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章</h4> \n<h2><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVRyYe?w=430&amp;h=430\" src=\"http://localhost:8060/tup/2020/4/23/34fbb1e1e7fc41c5b8d7588ee894dbb2.jpg\" alt=\"欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章\" title=\"欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章\"></span></h2> \n<h3>欢迎继续阅读本专栏其它高赞文章：</h3> \n<ul> \n <li><a href=\"https://segmentfault.com/a/1190000019115050\">深入理解Shadow DOM v1</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019135847\">一步步教你用 WebVR 实现虚拟现实游戏</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019154021\">13个帮你提高开发效率的现代CSS框架</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019085935\">快速上手BootstrapVue</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019205065\">JavaScript引擎是如何工作的？从调用栈到Promise你需要知道的一切</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019216390\">WebSocket实战：在 Node 和 React 之间进行实时通信</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019315509\">关于 Git 的 20 个面试题</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019302858\">深入解析 Node.js 的 console.log</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019283751\">Node.js 究竟是什么？</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019268920\">30分钟用Node.js构建一个API服务器</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018903274\">Javascript的对象拷贝</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018224157\">程序员30岁前月薪达不到30K，该何去何从</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018646425\">14个最好的 JavaScript 数据可视化库</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018439250\">8 个给前端的顶级 VS Code 扩展插件</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018660861\">Node.js 多线程完全指南</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018701596\">把HTML转成PDF的4个方案及实现</a></li> \n</ul> \n<hr> \n<ul>\n <li><a href=\"http://blog.yidengxuetang.com/\" rel=\"nofollow noreferrer\">更多文章...</a></li>\n</ul>', null, 'http://localhost:8060/tup/2020/4/23/e9098b18cfac470d822afb0503300516.jpg', '1894b118d35d44cb8fe8009529c4154b', '1a7cc9fbc4654cb0afec84e080816ef1', 'd79254c4ca5e45dca9d484307c935281,a4f4fd7a73b84a7298db0174165eeaac,401f1c4dcfbc499e8f7129c091c299f8,d16a93d83052441a90afaa57d69fdc3c', '0', '3', '1', '2020-04-23 10:57:32', '2020-04-23 10:57:32');
INSERT INTO `tb_recommend` VALUES ('587b9caac08d4b3e9adb8c54dd7f9933', 'Linux 问题故障定位，看这一篇就够了', '有时候会遇到一些疑难杂症，并且监控插件并不能一眼立马发现问题的根源。这时候就需要登录服务器进一步深入分析问题的根源。那么分析问题需要有一定的技术经验积累，并且有些问题涉及到的领域非常广，才能定位到...', '<h5>1、 背景</h5> \n<hr> \n<p>有时候会遇到一些疑难杂症，并且监控插件并不能一眼立马发现问题的根源。这时候就需要登录服务器进一步深入分析问题的根源。那么分析问题需要有一定的技术经验积累，并且有些问题涉及到的领域非常广，才能定位到问题。所以，分析问题和踩坑是非常锻炼一个人的成长和提升自我能力。如果我们有一套好的分析工具，那将是事半功倍，能够帮助大家快速定位问题，节省大家很多时间做更深入的事情。</p> \n<p>说明<br>本篇文章主要介绍各种问题定位的工具以及会结合案例分析问题。</p> \n<blockquote>\n 作者：Lucien_168 \n <br>链接：\n <a href=\"https://www.jianshu.com/p/0bbac570fa4c\" rel=\"nofollow noreferrer\">https://www.jianshu.com/p/0bb...</a> \n</blockquote> \n<h5>2、 分析问题的方法论</h5> \n<hr> \n<p>套用5W2H方法，可以提出性能分析的几个问题</p> \n<ul> \n <li>What-现象是什么样的</li> \n <li>When-什么时候发生</li> \n <li>Why-为什么会发生</li> \n <li>Where-哪个地方发生的问题</li> \n <li>How much-耗费了多少资源</li> \n <li>How to do-怎么解决问题</li> \n</ul> \n<h5>3、cpu</h5> \n<hr> \n<p>3.1 说明</p> \n<p>针对应用程序，我们通常关注的是内核CPU调度器功能和性能。</p> \n<p>线程的状态分析主要是分析线程的时间用在什么地方，而线程状态的分类一般分为：</p> \n<p>a. on-CPU：执行中，执行中的时间通常又分为用户态时间user和系统态时间sys。 <br>b. off-CPU：等待下一轮上CPU，或者等待I/O、锁、换页等等，其状态可以细分为可执行、匿名换页、睡眠、锁、空闲等状态。</p> \n<p>如果大量时间花在CPU上，对CPU的剖析能够迅速解释原因；如果系统时间大量处于off-cpu状态，定位问题就会费时很多。但是仍然需要清楚一些概念：</p> \n<ul> \n <li>处理器</li> \n <li>核</li> \n <li>硬件线程</li> \n <li>CPU内存缓存</li> \n <li>时钟频率</li> \n <li>每指令周期数CPI和每周期指令数IPC</li> \n <li>CPU指令</li> \n <li>使用率</li> \n <li>用户时间／内核时间</li> \n <li>调度器</li> \n <li>运行队列</li> \n <li>抢占</li> \n <li>多进程</li> \n <li>多线程</li> \n <li>字长</li> \n</ul> \n<p>3.2 分析工具</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419466\" src=\"http://localhost:8060/tup/2020/4/23/2bc2b4da82d646259e2a6d5983be6115.jpg\" alt=\"\" title=\"\"></span></p> \n<p>说明:</p> \n<ul> \n <li>uptime,vmstat,mpstat,top,pidstat只能查询到cpu及负载的的使用情况。</li> \n <li>perf可以跟着到进程内部具体函数耗时情况，并且可以指定内核函数进行统计，指哪打哪。</li> \n</ul> \n<p>3.3 使用方式</p> \n<pre><code>//查看系统cpu使用情况\ntop\n\n//查看所有cpu核信息\nmpstat -P ALL 1\n\n//查看cpu使用情况以及平均负载\nvmstat 1\n\n//进程cpu的统计信息\npidstat -u 1 -p pid\n\n//跟踪进程内部函数级cpu使用情况\nperf top -p pid -e cpu-clock</code></pre> \n<h5>4、内存</h5> \n<hr> \n<p>4.1 说明</p> \n<p>内存是为提高效率而生，实际分析问题的时候，内存出现问题可能不只是影响性能，而是影响服务或者引起其他问题。同样对于内存有些概念需要清楚：</p> \n<ul> \n <li>主存</li> \n <li>虚拟内存</li> \n <li>常驻内存</li> \n <li>地址空间</li> \n <li>OOM</li> \n <li>页缓存</li> \n <li>缺页</li> \n <li>换页</li> \n <li>交换空间</li> \n <li>交换</li> \n <li>用户分配器libc、glibc、libmalloc和mtmalloc</li> \n <li>LINUX内核级SLUB分配器</li> \n</ul> \n<p>4.2 分析工具</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419465\" src=\"http://localhost:8060/tup/2020/4/23/87de83588c27479abb890710559061a5.jpg\" alt=\"\" title=\"\"></span></p> \n<p>说明：</p> \n<ul> \n <li>free,vmstat,top,pidstat,pmap只能统计内存信息以及进程的内存使用情况。</li> \n <li>valgrind可以分析内存泄漏问题。</li> \n <li>dtrace动态跟踪。需要对内核函数有很深入的了解，通过D语言编写脚本完成跟踪。</li> \n</ul> \n<p>4.3 使用方式</p> \n<pre><code>//查看系统内存使用情况\nfree -m\n\n//虚拟内存统计信息\nvmstat 1\n\n//查看系统内存情况\ntop\n\n//1s采集周期，获取内存的统计信息\npidstat -p pid -r 1\n\n//查看进程的内存映像信息\npmap -d pid\n\n//检测程序内存问题\nvalgrind --tool=memcheck --leak-check=full --log-file=./log.txt &nbsp;./程序名</code></pre> \n<h5>5、 磁盘IO</h5> \n<hr> \n<p>5.1 说明</p> \n<p>磁盘通常是计算机最慢的子系统，也是最容易出现性能瓶颈的地方，因为磁盘离 CPU 距离最远而且 CPU 访问磁盘要涉及到机械操作，比如转轴、寻轨等。访问硬盘和访问内存之间的速度差别是以数量级来计算的，就像1天和1分钟的差别一样。要监测 IO 性能，有必要了解一下基本原理和 Linux 是如何处理硬盘和内存之间的 IO 的。</p> \n<p>在理解磁盘IO之前，同样我们需要理解一些概念，例如：</p> \n<ul> \n <li>文件系统</li> \n <li>VFS</li> \n <li>文件系统缓存</li> \n <li>页缓存page cache</li> \n <li>缓冲区高速缓存buffer cache</li> \n <li>目录缓存</li> \n <li>inode</li> \n <li>inode缓存</li> \n <li>noop调用策略</li> \n</ul> \n<p>5.2 分析工具</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419469\" src=\"http://localhost:8060/tup/2020/4/23/6399055767ca42a1ae9caa08430d0092.jpg\" alt=\"\" title=\"\"></span></p> \n<p>5.3 使用方式</p> \n<pre><code>//查看系统io信息\niotop\n\n//统计io详细信息\niostat -d -x -k 1 10\n\n//查看进程级io的信息\npidstat -d 1 -p &nbsp;pid\n\n//查看系统IO的请求，比如可以在发现系统IO异常时，可以使用该命令进行调查，就能指定到底是什么原因导致的IO异常\nperf record -e block:block_rq_issue -ag^Cperf report</code></pre> \n<h5>6、网络</h5> \n<hr> \n<p>6.1 说明</p> \n<p>网络的监测是所有 Linux 子系统里面最复杂的，有太多的因素在里面，比如：延迟、阻塞、冲突、丢包等，更糟的是与 Linux 主机相连的路由器、交换机、无线信号都会影响到整体网络并且很难判断是因为 Linux 网络子系统的问题还是别的设备的问题，增加了监测和判断的复杂度。现在我们使用的所有网卡都称为自适应网卡，意思是说能根据网络上的不同网络设备导致的不同网络速度和工作模式进行自动调整。</p> \n<p>6.2 分析工具</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419464\" src=\"http://localhost:8060/tup/2020/4/23/090ee1b891ad4136b1062646415a99e2.jpg\" alt=\"\" title=\"\"></span></p> \n<p>6.3 使用方式</p> \n<pre><code>//显示网络统计信息\nnetstat -s\n\n//显示当前UDP连接状况\nnetstat -nu\n\n//显示UDP端口号的使用情况\nnetstat -apu\n\n//统计机器中网络连接各个状态个数\nnetstat -a | awk \'/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}\'\n\n//显示TCP连接\nss -t -a\n\n//显示sockets摘要信息\nss -s\n\n//显示所有udp socketsss -u -a//tcp,etcp状态\nsar -n TCP,ETCP 1\n\n//查看网络\nIOsar -n DEV 1\n\n//抓包以包为单位进行输出\ntcpdump -i eth1 host 192.168.1.1 and port 80 \n\n//抓包以流为单位显示数据内容\ntcpflow -cp host 192.168.1.1</code></pre> \n<h5>7、系统负载</h5> \n<hr> \n<p>7.1 说明</p> \n<p>Load 就是对计算机干活多少的度量（WikiPedia：the system Load is a measure of the amount of work that a compute system is doing）简单的说是进程队列的长度。Load Average 就是一段时间（1分钟、5分钟、15分钟）内平均Load。</p> \n<p>7.2 分析工具</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419467\" src=\"http://localhost:8060/tup/2020/4/23/5b66f30be43b4ecd9fbffef01ad4bf74.jpg\" alt=\"\" title=\"\"></span></p> \n<p>7.3 使用方式</p> \n<pre><code>//查看负载情况\nuptimetopvmstat\n\n//统计系统调用耗时情况\nstrace -c -p pid\n\n//跟踪指定的系统操作例如\nepoll_waitstrace -T -e epoll_wait -p pid\n\n//查看内核日志信息\ndmesg</code></pre> \n<h5>8、 火焰图</h5> \n<hr> \n<p>8.1 说明</p> \n<p>火焰图（Flame Graph是 Bredan Gregg 创建的一种性能分析图表，因为它的样子近似 ?而得名。</p> \n<p>火焰图主要是用来展示 CPU的调用栈。</p> \n<p>y 轴表示调用栈，每一层都是一个函数。调用栈越深，火焰就越高，顶部就是正在执行的函数，下方都是它的父函数。</p> \n<p>x 轴表示抽样数，如果一个函数在 x 轴占据的宽度越宽，就表示它被抽到的次数多，即执行的时间长。注意，x 轴不代表时间，而是所有的调用栈合并后，按字母顺序排列的。</p> \n<p>火焰图就是看顶层的哪个函数占据的宽度最大。只要有”平顶”（plateaus），就表示该函数可能存在性能问题。颜色没有特殊含义，因为火焰图表示的是 CPU 的繁忙程度，所以一般选择暖色调。</p> \n<p>常见的火焰图类型有On-CPU、Off-CPU、Memory、Hot/Cold、Differential等等。</p> \n<p>8.2 安装依赖库</p> \n<pre><code>//安装systemtap，默认系统已安装\nyum install systemtap systemtap-runtime\n\n//内核调试库必须跟内核版本对应，例如：\nuname -r 2.6.18-308.el5kernel-debuginfo-2.6.18-308.el5.x86_64.rpmkernel-devel-2.6.18-308.el5.x86_64.rpmkernel-debuginfo-common-2.6.18-308.el5.x86_64.rpm\n\n//安装内核调试库\ndebuginfo-install --enablerepo=debuginfo search kerneldebuginfo-install --enablerepo=debuginfo &nbsp;search glibc</code></pre> \n<p>8.3 安装</p> \n<pre><code>git clone https://github.com/lidaohang/quick_location.gitcd quick_location</code></pre> \n<p>8.4 CPU级别火焰图</p> \n<p>cpu占用过高，或者使用率提不上来，你能快速定位到代码的哪块有问题吗？ <br>一般的做法可能就是通过日志等方式去确定问题。现在我们有了火焰图，能够非常清晰的发现哪个函数占用cpu过高，或者过低导致的问题。</p> \n<p>8.4.1 on-CPU</p> \n<p>cpu占用过高，执行中的时间通常又分为用户态时间user和系统态时间sys。</p> \n<p>使用方式：</p> \n<pre><code>//on-CPU user\nsh ngx_on_cpu_u.sh pid\n\n//进入结果目录\ncd ngx_on_cpu_u\n\n//on-CPU kernel\nsh ngx_on_cpu_k.sh pid\n\n//进入结果目录\ncd ngx_on_cpu_k\n\n//开一个临时端口8088\npython -m SimpleHTTPServer 8088\n\n//打开浏览器输入地址\n127.0.0.1:8088/pid.svg</code></pre> \n<p>DEMO：</p> \n<pre><code>#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\nvoid foo3()\n{\n}\n\nvoid foo2()\n{ &nbsp;\nint i; &nbsp;\nfor(i=0 ; \ni &lt; 10; i++) &nbsp; &nbsp; &nbsp; \n    foo3();\n}\nvoid foo1(){\nint i; &nbsp;\nfor(i = 0; i&lt; 1000; i++) &nbsp; &nbsp; \n    foo3();\n}\nint main(void){ &nbsp;\nint i; &nbsp;\nfor( i =0; i&lt; 1000000000; i++) {\nfoo1(); &nbsp; &nbsp; &nbsp;\nfoo2();\n}\n}</code></pre> \n<p>DEMO火焰图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419468\" src=\"http://localhost:8060/tup/2020/4/23/583cfc611f79467ca2af728dc0731ded.jpg\" alt=\"\" title=\"\"></span></p> \n<p>8.4.2 off-CPU</p> \n<p>cpu过低，利用率不高。等待下一轮CPU，或者等待I/O、锁、换页等等，其状态可以细分为可执行、匿名换页、睡眠、锁、空闲等状态。</p> \n<p>使用方式：</p> \n<pre><code>// off-CPU user\nsh ngx_off_cpu_u.sh pid\n\n//进入结果目录\ncd ngx_off_cpu_u\n\n//off-CPU kernel\nsh ngx_off_cpu_k.sh pid\n\n//进入结果目录\ncd ngx_off_cpu_k\n\n//开一个临时端口8088\npython -m SimpleHTTPServer 8088\n\n//打开浏览器输入地址\n127.0.0.1:8088/pid.svg</code></pre> \n<p>官网DEMO：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419472\" src=\"http://localhost:8060/tup/2020/4/23/04ca5bc71a9040f797fc6cc0ff23b6a1.jpg\" alt=\"\" title=\"\"></span></p> \n<p>8.5 内存级别火焰图</p> \n<p>如果线上程序出现了内存泄漏，并且只在特定的场景才会出现。这个时候我们怎么办呢？有什么好的方式和工具能快速的发现代码的问题呢？同样内存级别火焰图帮你快速分析问题的根源。</p> \n<p>使用方式：</p> \n<pre><code>sh ngx_on_memory.sh pid\n\n//进入结果目录\ncd ngx_on_memory\n\n//开一个临时端口8088\npython -m SimpleHTTPServer 8088\n\n//打开浏览器输入地址\n127.0.0.1:8088/pid.svg</code></pre> \n<p>官网DEMO：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419470\" src=\"http://localhost:8060/tup/2020/4/23/b3462171a45f4f70bc9c4eb3db5385c4.jpg\" alt=\"\" title=\"\"></span></p> \n<p>8.6 性能回退-红蓝差分火焰图</p> \n<p>你能快速定位CPU性能回退的问题么？ 如果你的工作环境非常复杂且变化快速，那么使用现有的工具是来定位这类问题是很具有挑战性的。当你花掉数周时间把根因找到时，代码已经又变更了好几轮，新的性能问题又冒了出来。主要可以用到每次构建中，每次上线做对比看，如果损失严重可以立马解决修复。</p> \n<p>通过抓取了两张普通的火焰图，然后进行对比，并对差异部分进行标色：红色表示上升，蓝色表示下降。 差分火焰图是以当前（“修改后”）的profile文件作为基准，形状和大小都保持不变。因此你通过色彩的差异就能够很直观的找到差异部分，且可以看出为什么会有这样的差异。</p> \n<p>使用方式：</p> \n<pre><code>cd quick_location\n\n//抓取代码修改前的profile 1文件\nperf record -F 99 -p pid -g -- sleep 30\nperf script &gt; out.stacks1\n\n//抓取代码修改后的profile 2文件\nperf record -F 99 -p pid -g -- sleep 30\nperf script &gt; out.stacks2\n\n//生成差分火焰图:\n./FlameGraph/stackcollapse-perf.pl ../out.stacks1 &gt; out.folded1\n./FlameGraph/stackcollapse-perf.pl ../out.stacks2 &gt; out.folded2\n./FlameGraph/difffolded.pl out.folded1 out.folded2 | ./FlameGraph/flamegraph.pl &gt; diff2.svg</code></pre> \n<p>DEMO：</p> \n<pre><code>//test.c  \n#include &lt;stdio.h&gt;  \n#include &lt;stdlib.h&gt;  \n  \nvoid foo3()  \n{  \n}  \n  \nvoid foo2()  \n{  \n&nbsp;int i;  \n&nbsp;for(i=0 ; i &lt; 10; i++)  \n&nbsp; &nbsp; &nbsp; foo3();  \n}  \n  \nvoid foo1()  \n{  \n&nbsp;int i;  \n&nbsp;for(i = 0; i&lt; 1000; i++)  \n&nbsp; &nbsp; foo3();  \n}  \n  \nint main(void)  \n{  \n&nbsp;int i;  \n&nbsp;for( i =0; i&lt; 1000000000; i++) {  \n&nbsp; &nbsp; &nbsp;foo1();  \n&nbsp; &nbsp; &nbsp;foo2();  \n&nbsp;}  \n}  \n  \n//test1.c  \n#include &lt;stdio.h&gt;  \n#include &lt;stdlib.h&gt;  \n  \nvoid foo3()  \n{  \n}  \n  \nvoid foo2()  \n{  \n&nbsp;int i;  \n&nbsp;for(i=0 ; i &lt; 10; i++)  \n&nbsp; &nbsp; &nbsp; foo3();  \n}  \n  \nvoid foo1()  \n{  \n&nbsp;int i;  \n&nbsp;for(i = 0; i&lt; 1000; i++)  \n&nbsp; &nbsp; foo3();  \n}  \n  \nvoid add()  \n{  \n&nbsp;int i;  \n&nbsp;for(i = 0; i&lt; 10000; i++)  \n&nbsp; &nbsp; foo3();  \n}  \n  \nint main(void)  \n{  \n&nbsp;int i;  \n&nbsp;for( i =0; i&lt; 1000000000; i++) {  \n&nbsp; &nbsp; &nbsp;foo1();  \n&nbsp; &nbsp; &nbsp;foo2();  \n&nbsp; &nbsp; &nbsp;add();  \n&nbsp;}  \n}</code></pre> \n<p>DEMO红蓝差分火焰图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419476\" src=\"http://localhost:8060/tup/2020/4/23/6d106a411ce84e7ca8834fa4bdc21c0e.jpg\" alt=\"\" title=\"\"></span></p> \n<h5>9、.案例分析</h5> \n<hr> \n<p>9.1 接入层nginx集群异常现象</p> \n<p>通过监控插件发现在2017.09.25 19点nginx集群请求流量出现大量的499，5xx状态码。并且发现机器cpu使用率升高，目前一直持续中。</p> \n<p>9.2 分析nginx相关指标</p> \n<p>a)&nbsp;_**_分析nginx请求流量：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419471\" src=\"http://localhost:8060/tup/2020/4/23/3e5122bd66d24a1f99d2c5f2dd34030e.jpg\" alt=\"\" title=\"\"></span></p> \n<p>结论：</p> \n<p>通过上图发现流量并没有突增，反而下降了，跟请求流量突增没关系。</p> \n<p>b)&nbsp;_**_分析nginx响应时间 <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419473\" src=\"http://localhost:8060/tup/2020/4/23/6468fb2a4c154094b875eec732ce2322.jpg\" alt=\"\" title=\"\"></span></p> \n<p>结论：</p> \n<p>通过上图发现nginx的响应时间有增加可能跟nginx自身有关系或者跟后端upstream响应时间有关系。</p> \n<p>c)&nbsp;_**_分析nginx upstream响应时间</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419477\" src=\"http://localhost:8060/tup/2020/4/23/5c3d1b9e8e4d46c088c28688e786b7d8.jpg\" alt=\"\" title=\"\"></span></p> \n<p>结论：</p> \n<p>通过上图发现nginx upstream 响应时间有增加，目前猜测可能后端upstream响应时间拖住nginx，导致nginx出现请求流量异常。</p> \n<p>9.3 分析系统cpu情况</p> \n<p>a)&nbsp;_**_通过top观察系统指标</p> \n<p><code>top</code></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419474\" src=\"http://localhost:8060/tup/2020/4/23/cb3ef01c2efc41119c33bd64425395e0.jpg\" alt=\"\" title=\"\"></span></p> \n<p>结论：</p> \n<p>发现nginx worker cpu比较高</p> \n<p>b)&nbsp;_**_分析nginx进程内部cpu情况</p> \n<p><code>perf top -p pid</code></p> \n<p>结论：</p> \n<p>发现主要开销在free,malloc,json解析上面</p> \n<p>9.4 火焰图分析cpu <br>a)&nbsp;_**_生成用户态cpu火焰图</p> \n<pre><code>//on-CPU user\nsh ngx_on_cpu_u.sh pid\n\n//进入结果目录\nd ngx_on_cpu_u\n\n//开一个临时端口8088\npython -m SimpleHTTPServer 8088\n\n//打开浏览器输入地址\n127.0.0.1:8088/pid.svg</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419475\" src=\"http://localhost:8060/tup/2020/4/23/fb97280c2dcf4046af877add7cf32a15.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>结论：</strong></p> \n<p>发现代码里面有频繁的解析json操作，并且发现这个json库性能不高，占用cpu挺高。</p> \n<p>9.5 案例总结</p> \n<p><strong>a)&nbsp;</strong>分析请求流量异常，得出nginx upstream后端机器响应时间拉长</p> \n<p><strong>b)&nbsp;</strong>分析nginx进程cpu高，得出nginx内部模块代码有耗时的json解析以及内存分配回收操作</p> \n<p>9.5.1 深入分析</p> \n<p>根据以上两点问题分析的结论，我们进一步深入分析。</p> \n<p>后端upstream响应拉长，最多可能影响nginx的处理能力。但是不可能会影响nginx内部模块占用过多的cpu操作。并且当时占用cpu高的模块，是在请求的时候才会走的逻辑。不太可能是upstram后端拖住nginx，从而触发这个cpu的耗时操作。</p> \n<p>9.5.2 解决方式</p> \n<p>遇到这种问题，我们优先解决已知的，并且非常明确的问题。那就是cpu高的问题。解决方式先降级关闭占用cpu过高的模块，然后进行观察。经过降级关闭该模块cpu降下来了，并且nginx请求流量也正常了。之所以会影响upstream时间拉长，因为upstream后端的服务调用的接口可能是个环路再次走回到nginx。</p> \n<h5>10、参考资料</h5> \n<hr> \n<ul> \n <li><a href=\"http://www.brendangregg.com/index.html\" rel=\"nofollow noreferrer\">http://www.brendangregg.com/i...</a></li> \n <li><a href=\"http://www.brendangregg.com/FlameGraphs/cpuflamegraphs.html\" rel=\"nofollow noreferrer\">http://www.brendangregg.com/F...</a></li> \n <li><a href=\"http://www.brendangregg.com/FlameGraphs/memoryflamegraphs.html\" rel=\"nofollow noreferrer\">http://www.brendangregg.com/F...</a></li> \n <li><a href=\"http://www.brendangregg.com/FlameGraphs/offcpuflamegraphs.html\" rel=\"nofollow noreferrer\">http://www.brendangregg.com/F...</a></li> \n <li><a href=\"http://www.brendangregg.com/blog/2014-11-09/differential-flame-graphs.html\" rel=\"nofollow noreferrer\">http://www.brendangregg.com/b...</a></li> \n <li><a href=\"https://github.com/openresty/openresty-systemtap-toolkit\" rel=\"nofollow noreferrer\">https://github.com/openresty/...</a></li> \n <li><a href=\"https://github.com/brendangregg/FlameGraph\" rel=\"nofollow noreferrer\">https://github.com/brendangre...</a></li> \n <li><a href=\"https://www.slideshare.net/brendangregg/blazing-performance-with-flame-graphs\" rel=\"nofollow noreferrer\">https://www.slideshare.net/br...</a></li> \n</ul>', null, 'http://localhost:8060/tup/2020/4/23/c41d27421c8442418f167c0add90484c.jpg', 'c56940aa8b004dab84568e86900b2ee6', '91832bd0c3a244fb88c0bca74c0d404d', '753b5aee3913424e81fe2b5299626d8c,d7416e100af54eb7a4d9274b9a462240,77a7bd638e0a45ec84569ef6b79325c1,55723db96b9f4593bae02bc1e49f1e87,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-23 11:01:15', '2020-04-23 11:01:15');
INSERT INTO `tb_recommend` VALUES ('58f3ca56ede64173be89cb645166dc24', 'xcode高版本启动RN项目常见错误', 'xcode编译报错：\'config.h\' file not found 解决方案 {代码...} 启动报错：Unknown argument type \'__attribute__\' in method -[RCTAppState getCurrentAppState:error:]. Extend RCTConvert to support this typ...', '<h4>xcode编译报错：\'config.h\' file not found</h4> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022317133\" src=\"http://localhost:8060/tup/2020/4/23/df33084f1aa941fdb06347023c2ba855.jpg\" alt=\"image-20200409145441860\" title=\"image-20200409145441860\"></span></p> \n<p>解决方案</p> \n<pre><code class=\"js\">cd node_modules/react-native/third-party/glog-0.3.4\n../../scripts/ios-configure-glog.sh</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022317134\" src=\"http://localhost:8060/tup/2020/4/23/2be0848f8be44f93ad2bdc4372ba07ef.jpg\" alt=\"image-20200409150129405\" title=\"image-20200409150129405\"></span></p> \n<h4>启动报错：Unknown argument type \'__attribute__\' in method -[RCTAppState getCurrentAppState:error:]. Extend RCTConvert to support this type.</h4> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022317135\" src=\"http://localhost:8060/tup/2020/4/23/64a11b36f2404cacb9804a8d43b8accd.jpg\" alt=\"Simulator Screen Shot - iPhone 11 Pro Max - 2020-04-09 at 15.07.23\" title=\"Simulator Screen Shot - iPhone 11 Pro Max - 2020-04-09 at 15.07.23\"></span></p> \n<p>我的xcode版本：Version 11.0 (11A420a) </p> \n<p>Mac系统版本：10.14.6 </p> \n<p><strong>原因</strong>：<code>Xcode11(iOS13)</code>中对未使用的接口选择器的参数<code>unused</code>字符串属性进行了更改成了<code>__unused__</code>，导致<code>ReactNative</code>动态收集接口时不能把声明的接口进行导入，运行时无法查找到该接口导致的错误。</p> \n<p><strong>解决方案</strong>：找到文件<code>/node_modules/react-native/React/Base/RCTModuleMethod.mm</code></p> \n<p>修改方法：</p> \n<pre><code class=\"objc\">static BOOL RCTParseUnused(const char **input)\n{\n  return RCTReadString(input, \"__unused\") ||\n         RCTReadString(input, \"__attribute__((unused))\");\n}</code></pre> \n<p>修改成：</p> \n<pre><code class=\"objc\">static BOOL RCTParseUnused(const char **input)\n{\n\n  return RCTReadString(input, \"attribute((unused))\") ||\n         RCTReadString(input, \"__attribute__((__unused__))\") ||\n         RCTReadString(input, \"__unused\");\n}</code></pre>', null, 'http://localhost:8060/tup/2020/4/23/ec9a4cf19eeb4d29b472e66c85666f51.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', 'a337904dd1d5477b9689d7693be316de', 'df5b4b0986d44f169be91f7496d1dbc5,bc0022273e34499a9bc31681102eb488', '0', '3', '1', '2020-04-23 10:31:34', '2020-04-23 10:31:34');
INSERT INTO `tb_recommend` VALUES ('5948b56905514bd695909fca7deb0f20', '我用php构建了魔兽世界服务器,只为证明php是世界上最好的语言', '作为一个魔兽老玩家，最近看着暴雪开了怀旧服，早已寂灭的心又开始躁动不安了，我正式入坑是网易接替九城那会，号称万年TBC, 对于那个时代，用一句话表达就是“我站在暴风城的广场上，听着港口涛声，幻想着诺森德...', '<p>我用php构建了魔兽世界服务器</p> \n<pre><code>--只为证明php是世界上最好的语言\n</code></pre> \n<p>作为一个魔兽老玩家，最近看着暴雪开了怀旧服，早已寂灭的心又开始躁动不安了，我正式入坑是网易接替九城那会，号称万年TBC, 对于那个时代，用一句话表达就是“我站在暴风城的广场上，听着港口涛声，幻想着诺森德天气多么寒冷…”，你懂的~<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRss?w=500&amp;h=300\" src=\"http://localhost:8060/tup/2020/4/23/c2bc853d0d15419c8b35b78a81c68d41.jpg\" alt=\"0.jpg\" title=\"0.jpg\"></span><br>那时候刚上大学,对于涉世未深的我来说,魔兽的差点让我变成网瘾少年，直到毕业步入社会，才慢慢淡绝了对魔兽的念想，但无论过去多久，那段在网吧通宵鏖战，跟同学朋友在副本、战场度过无数日子的青春一直烙印在心底深处，无法忘怀！</p> \n<p>好了，废话不多说，开始进入正题<br>———————————————————————————————————————<br>大家都知道，php作为一门脚本语言，对于没什么基础的人来说比较容易上手，但是很难精通，随着互联网的逐步兴起，php也火热起来，在这种需求的催动下，大量人员涌入到php的开发中来，多年之后，一度让人认为php只能写写网站、脚本、接口，随后而来的就是语言鄙视链，写汇编语言的工程师都鄙视写C语言的工，写C语言的工程师都鄙视写C++的， C++工程师鄙视写Java的和写C#的， Java工程师和C#工程师则相互鄙视，然而，所有的工程师都鄙视PHP工程师，于是这句著名的自嘲式的“php是世界上最好的语言”在互联网圈子流传开来~~</p> \n<p>SO, 假定“php是世界上最好的语言”这句话为真，那我们用它来构建一个游戏服务端怎么样？<br>“真的吗？”<br>“可以吗”<br>“真的！”<br>“可以！”</p> \n<p>小打小闹的什么页游啊、棋牌啊直接忽视，来个挑战高的，难度大的！那就魔兽世界吧！ 哈哈哈哈哈哈哈哈哈哈~</p> \n<p>但是写游戏服务端我们要做些什么呢，我也不知道，我也不敢问啊，让别人知道你想用php写魔兽世界服务端，会招来各种花式嘲讽的！<br>于是偷偷的装了抓包工具，偷偷的研究起了魔兽世界游戏的逻辑，得出结论，</p> \n<p>1魔兽世界服务端需要一个用户登录(authserver)服务器用来处理用户登录鉴权，客户端与服务端使用TCP协议,端口号为3724</p> \n<p>2需要一个世界(worldserver)服务器来处理游戏逻辑，包含角色的创建，地图的加载，npc和生物的构建及各种眼花缭乱的物品和技能等等~同样是TCP协议，这里的端口号为8085</p> \n<p><strong>第一步： 用php 构建用户登录服务器-AuthServer</strong><br>我这里采用Swoole扩展(不知道的自行百度)创建了TCP服务监听了本机的3724端口</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRsq?w=1083&amp;h=615\" src=\"http://localhost:8060/tup/2020/4/23/95b96bb382d44b1b8b425bcbd3b6c34e.jpg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p>用户登录服务器主要的逻辑是： wow客户端发送账户信息给服务端，服务端验证账户并告知客户端鉴权结果，结果中包含世界服务器的地址及端口。</p> \n<p>偷偷说一句，魔兽的客户端在登录的时候只会发送一些基本信息，并不包含明文密码，而是使用SRP认证<br>SRP简化后的原理是：</p> \n<ol> \n <li>服务器不保存密码或密码的散列值，防止字典攻击， 而只是保存验证因子(verifier)</li> \n <li>客户端和服务器可以各自计算出一个会话秘钥(session key)，其值相同 防止窃听</li> \n</ol> \n<p><strong>第二步 构建世界服务器-WorldServer</strong><br>与上面一样，需要绑定本机的8085端口</p> \n<p>小提示: 3724和8085的TCP/UDP已经被暴雪注册了…简单说，暴雪注册了专有的端口号用于专门的战网通信以及魔兽世界的通信。以前大家（数据包）都从一个门（端口）进进出出，现在暴雪大爷有钱了，弄了个专门的门，以后爷走这个门，你们都不许走。牛逼吧!</p> \n<p>魔兽客户端在用户登录服务器鉴权成功后就会连接到世界服务器，首次接入服务端会向客户端发起鉴权数据包，其中带有服务器随机密钥，客户端收到之后根据密钥和sessionkey计算出client_hash，并发送给服务端，服务端使用相同公式计算出server_hash判断是否一致</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtv?w=1233&amp;h=363\" src=\"http://localhost:8060/tup/2020/4/23/b022839acc0846769f21d4b2ad6b56bb.jpg\" alt=\"2.png\" title=\"2.png\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRty?w=1576&amp;h=825\" src=\"http://localhost:8060/tup/2020/4/23/09276e68dc1f49ab932e044840864395.jpg\" alt=\"3.jpg\" title=\"3.jpg\"></span></p> \n<p>服务端鉴权完成后的所有数据包都将进行加密<br>先使用hash_hmac对sessionkey生成指定的哈希运算规则数据,</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtB?w=731&amp;h=86\" src=\"http://localhost:8060/tup/2020/4/23/6cf1ad61b95b414d87a6880951d0fce0.jpg\" alt=\"4.png\" title=\"4.png\"></span></p> \n<p>然后根据数据包的Opcode生成数据包头，然后发送结果给客户端</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtH?w=718&amp;h=597\" src=\"http://localhost:8060/tup/2020/4/23/c4e08b52e6b445679f09a75574888a69.jpg\" alt=\"5.png\" title=\"5.png\"></span></p> \n<p>客户端收到鉴权成功结果后，会发送获取角色信息的数据包，服务端进行处理，获取角色信息并发送给客户端</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtJ?w=1233&amp;h=867\" src=\"http://localhost:8060/tup/2020/4/23/e71ce184c7014b44b24fcabc9d83a62b.jpg\" alt=\"6.png\" title=\"6.png\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtN?w=1585&amp;h=815\" src=\"http://localhost:8060/tup/2020/4/23/fa71f6b2fa1246f8a9e0ec2fb2e3f63f.jpg\" alt=\"7.jpg\" title=\"7.jpg\"></span></p> \n<p>客户端点击进入魔兽世界后，发送CMSG_PLAYER_LOGIN操作码。服务端接收并处理</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtV?w=840&amp;h=422\" src=\"http://localhost:8060/tup/2020/4/23/ef610d229fb343278b2b8afbfc4a2c25.jpg\" alt=\"8.png\" title=\"8.png\"></span></p> \n<p>还挺多的~就不一一详细写了<br>进入魔兽世界后就是这个样子</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRt2?w=1585&amp;h=823\" src=\"http://localhost:8060/tup/2020/4/23/e8b192df1f4c42359a3b834ee7589940.jpg\" alt=\"9.jpg\" title=\"9.jpg\"></span></p> \n<p>完整运行视频(Swoole创始人韩天峰的微博): <a href=\"https://weibo.com/tv/v/I7Hu7dVxG?fid=1034:4418354417756012\" rel=\"nofollow noreferrer\">https://weibo.com/tv/v/I7Hu7dVxG?fid=1034:4418354417756012</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRup?w=754&amp;h=721\" src=\"http://localhost:8060/tup/2020/4/23/978cbc0b84c94939b2df5aff2498d398.jpg\" alt=\"10.png\" title=\"10.png\"></span></p> \n<p>到此一个简单的魔兽世界服务器就构建完了! 怎么样? 哈哈哈,php是不是世界上最好的语言!</p> \n<p>不过话说回来，我目前做到的也是一些很基础的东西，毕竟魔兽世界那么大，想要一一实现靠一个人或一门语言是不可能的，可以做和不能做完全是两个概念，使用php是比较方便，高效且便捷，但是性能我无法完全保证，不过使用swoole和php7之后，这点就不是我去考虑的了，够用，还可以！</p> \n<p>代码我已经开源，地址是：<a href=\"https://github.com/fan3750060/wpcore\" rel=\"nofollow noreferrer\">https://github.com/fan3750060...</a></p> \n<p>谢谢！来！让我们一起说 ： php是世界上最好的语言!</p>', null, 'http://localhost:8060/tup/2020/4/23/e56ebb1a4f30476f916b0d6d27c27f43.jpg', '3f69fcc9b13843d1910b3dac597f5215', '1a7cc9fbc4654cb0afec84e080816ef1', '9424c753324d4c6198c85fff4f681dd4,6dcac97ec78c41b3a5f265d015ca34f5,6bc7339a27854278b1489eb30425aa1b,6db071127bc8442497d14d9527082793,84e1fca09c4340be87d5c1ef4601b026', '0', '3', '1', '2020-04-23 10:57:39', '2020-04-23 10:57:39');
INSERT INTO `tb_recommend` VALUES ('5a6767091b6949b390e30ce724fcdca3', 'Apache Doris在美团外卖数仓中的应用实践', '美团外卖数据仓库技术团队负责支撑日常业务运营及分析师的日常分析，由于外卖业务特点带来的数据生产成本较高和查询效率偏低的问题，他们通过引入Apache Doris引擎优化生产方案，实现了低成本生产与高效查询的平...', '<h2>序言</h2> \n<p>美团外卖数据仓库技术团队负责支撑日常业务运营及分析师的日常分析，由于外卖业务特点带来的数据生产成本较高和查询效率偏低的问题，他们通过引入Apache Doris引擎优化生产方案，实现了低成本生产与高效查询的平衡。并以此分析不同业务场景下，基于Kylin的MOLAP模式与基于Doris引擎的ROLAP模式的适用性问题。希望能对大家有所启发或者帮助。</p> \n<p>本文侧重于以Doris引擎为“发动机”的数仓生产架构的改进与思考。在开源的大环境下，各种数据引擎百花齐放，但由于业务的复杂性与多样性，目前并没有哪个引擎能够适配所有业务场景，因此希望通过我们的业务实践与思考为大家提供一些经验参考。美团外卖数仓技术团队致力于将数据应用效率最大化，同时兼顾研发、生产与运维成本的最小化，建设持续进步的数仓能力，也欢迎大家多给我们提出建议。</p> \n<h2>数仓交互层引擎的应用现状</h2> \n<p>目前，互联网业务规模变得越来越大，不论是业务生产系统还是日志系统，基本上都是基于Hadoop/Spark分布式大数据技术生态来构建数据仓库，然后对数据进行适当的分层、加工、管理。而在数据应用交互层面，由于时效性的要求，数据最终的展现查询还是需要通过DBMS（MySQL）、MOLAP（Kylin）引擎来进行支撑。如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345427\" src=\"http://localhost:8060/tup/2020/4/23/dec6aff035624d8da64f9bd2ef776848.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>汇总数据的交互</h2> \n<p>业务团队日常经营分析最典型的场景就是各种维度下的自定义查询，面对如此灵活可变、所见即所得的应用场景，美团平台使用Kylin作为公司的主要MOLAP引擎。MOLAP是预计算生产，在增量业务，预设维度分析场景下表现良好，但在变化维的场景下生产成本巨大。例如，如果使用最新商家类型回溯商家近三个月的表现，需要重新计算三个月的Cube，需花费几个小时，来计算近TB的历史数据。另外，应对非预设维度分析，MOLAP模型需要重新进行适配计算，也需要一定的迭代工作。</p> \n<p><strong>明细数据的交互</strong></p> \n<p>业务分析除了宏观数据之外，对明细数据查询也是一种刚需。通常大家会选择MySQL等关系型DB作为明细数据的快速检索查询，但当业务成长较快时，很快就会遇到性能瓶颈，并且运维成本也很高。例如，大数据量的同步、新增字段、历史数据更新等操作，它们的维护成本都非常高。</p> \n<p><strong>外卖运营业务特点</strong></p> \n<p>美团的使命是“帮大家吃得更好，生活更好”。外卖业务为大家提供送餐服务，连接商家与用户，这是一个劳动密集型的业务，外卖业务有上万人的运营团队来服务全国几百万的商家，并以“商圈”为单元，服务于“商圈”内的商家。“商圈”是一个组织机构维度中的最小层级，源于外卖组织的特点，“商圈”及其上层组织机构是一个变化维度，当“商圈”边界发生变化时，就导致在往常日增量的业务生产方式中，历史数据的回溯失去了参考意义。在所有展现组织机构数据的业务场景中，组织机构的变化是一个绕不开的技术问题。此外，商家品类、类型等其它维度也存在变化维的问题。如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345426\" src=\"http://localhost:8060/tup/2020/4/23/4545e0253e524ed882bb8212b3b96dbe.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>数据生产面临的挑战</h2> \n<p>数据爆炸，每日使用最新维度对历史数据进行回溯计算。在Kylin的MOLAP模式下存在如下问题：</p> \n<ul> \n <li>历史数据每日刷新，失去了增量的意义。</li> \n <li>每日回溯历史数据量大，10亿+的历史数据回溯。</li> \n <li>数据计算耗时3小时+，存储1TB+，消耗大量计算存储资源，同时严重影响SLA的稳定性。</li> \n <li>预计算的大量历史数据实际使用率低下，实际工作中对历史的回溯80%集中在近1个月左右，但为了应对所有需求场景，业务要求计算近半年以上的历史。</li> \n <li>不支持明细数据的查询。</li> \n</ul> \n<h2>解决方案：引入MPP引擎，数据现用现算</h2> \n<p>既然变化维的历史数据预计算成本巨大，最好的办法就是现用现算，但现用现算需要强大的并行计算能力。OLAP的实现有MOLAP、ROLAP、HOLAP三种形式，MOLAP以Cube为表现形式，但计算与管理成本较高。ROLAP需要强大的关系型DB引擎支撑。长期以来，由于传统关系型DBMS的数据处理能力有限，所以ROLAP模式受到很大的局限性。随着分布式、并行化技术成熟应用，MPP引擎逐渐表现出强大的高吞吐、低时延计算能力，号称“亿级秒开”的引擎不在少数，ROLAP模式可以得到更好的延伸。单从业务实际应用考虑，性能在千万量级关联查询现场计算秒开的情况下，已经可以覆盖到很多应用场景，具备应用的可能性。例如：日数据量的ROLAP现场计算，周、月趋势的计算，以及明细数据的浏览都可以较好的应对。</p> \n<p>下图是MOLAP模式与ROLAP模式下应用方案的比较：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345425\" src=\"http://localhost:8060/tup/2020/4/23/6e49cdcfaf314e3ca9e59e361a406364.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>MOLAP模式的劣势</strong></p> \n<ol> \n <li>应用层模型复杂，根据业务需要以及Kylin生产需要，还要做较多模型预处理。这样在不同的业务场景中，模型的利用率也比较低。</li> \n <li>Kylin配置过程繁琐，需要配置模型设计，并配合适当的“剪枝”策略，以实现计算成本与查询效率的平衡。</li> \n <li>由于MOLAP不支持明细数据的查询，在“汇总+明细”的应用场景中，明细数据需要同步到DBMS引擎来响应交互，增加了生产的运维成本。</li> \n <li>较多的预处理伴随着较高的生产成本。</li> \n</ol> \n<p><strong>ROLAP模式的优势</strong></p> \n<ol> \n <li>应用层模型设计简化，将数据固定在一个稳定的数据粒度即可。比如商家粒度的星形模型，同时复用率也比较高。</li> \n <li>App层的业务表达可以通过视图进行封装，减少了数据冗余，同时提高了应用的灵活性，降低了运维成本。</li> \n <li>同时支持“汇总+明细”。</li> \n <li>模型轻量标准化，极大的降低了生产成本。</li> \n</ol> \n<p>综上所述，在变化维、非预设维、细粒度统计的应用场景下，使用MPP引擎驱动的ROLAP模式，可以简化模型设计，减少预计算的代价，并通过强大的实时计算能力，可以支撑良好的实时交互体验。</p> \n<h2>双引擎下的应用场景适配问题</h2> \n<p>架构上通过MOLAP+ROLAP双引擎模式来适配不同应用场景，如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345422\" src=\"http://localhost:8060/tup/2020/4/23/1a8fbacbc1014fdf8f4a044b0444b235.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>技术权衡</strong></p> \n<p><strong>MOLAP</strong>：通过预计算，提供稳定的切片数据，实现多次查询一次计算，减轻了查询时的计算压力，保证了查询的稳定性，是“空间换时间”的最佳路径。实现了基于Bitmap的去重算法，支持在不同维度下去重指标的实时统计，效率较高。<br><strong>ROLAP</strong>：基于实时的大规模并行计算，对集群的要求较高。MPP引擎的核心是通过将数据分散，以实现CPU、IO、内存资源的分布，来提升并行计算能力。在当前数据存储以磁盘为主的情况下，数据Scan需要的较大的磁盘IO，以及并行导致的高CPU，仍然是资源的短板。因此，高频的大规模汇总统计，并发能力将面临较大挑战，这取决于集群硬件方面的并行计算能力。传统去重算法需要大量计算资源，实时的大规模去重指标对CPU、内存都是一个巨大挑战。目前Doris最新版本已经支持Bitmap算法，配合预计算可以很好地解决去重应用场景。</p> \n<p><strong>业务模型适配</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345423\" src=\"http://localhost:8060/tup/2020/4/23/14363dd9184a48128439fbfcd0d0db97.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>MOLAP</strong>： 当业务分析维度相对固化，并在可以使用历史状态时，按照时间进行增量生产，加工成本呈线性增长状态，数据加工到更粗的粒度（如组织单元），减少结果数据量，提高交互效率。如上图所示，由A模型预计算到B模型，使用Kylin是一个不错的选择。</p> \n<p><strong>ROLAP</strong>： 当业务分析维度灵活多变或者特定到最新的状态时（如上图A模型中，始终使用最新的商家组织归属查看历史），预计算回溯历史数据成本巨大。在这种场景下，将数据稳定在商家的粒度，通过现场计算进行历史数据的回溯分析，实现现用现算，可以节省掉预计算的巨大成本，并带来较大的应用灵活性。这种情况下适合MPP引擎支撑下的ROLAP生产模式。</p> \n<h2>MPP引擎的选型</h2> \n<p>目前开源的比较受关注的OLAP引擎很多，比如Greenplum、Apache Impala、Presto、Doris、ClickHouse、Druid、TiDB等等，但缺乏实践案例的介绍，所以我们也没有太多的经验可以借鉴。于是，我们就结合自身业务的需求，从引擎建设成本出发，并立足于公司技术生态融合、集成、易用性等维度进行综合考虑，作为选型依据，最终我们平台部门选择了2018年刚进入Apache社区的Doris。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345424\" src=\"http://localhost:8060/tup/2020/4/23/e712a51957334f268bc327ec052e9803.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>Doris简介及特点</h2> \n<p>Doris是基于MPP架构的OLAP引擎，主要整合了Google Mesa（数据模型）、Apache Impala（MPP Query Engine）和Apache ORCFile （存储格式，编码和压缩）的技术。</p> \n<p>Doris的系统架构如下，主要分为FE和BE两个组件，FE主要负责查询的解析、编译、优化、调度和元数据管理；BE主要负责查询的执行和数据存储。关于Doris的更多技术细节，可参考其<a href=\"http://doris.apache.org/documentation/cn/internal/metadata-design.html\" rel=\"nofollow noreferrer\">官方文档</a>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345428\" src=\"http://localhost:8060/tup/2020/4/23/29e8b2c26278492081c587fed6029138.jpg\" alt=\"整体架构\" title=\"整体架构\"></span></p> \n<p><strong>Doris的特点：</strong></p> \n<ul> \n <li>同时支持高并发点查询和高吞吐的Ad-hoc查询。</li> \n <li>同时支持离线批量导入和实时数据导入。</li> \n <li>同时支持明细和聚合查询。</li> \n <li>兼容MySQL协议和标准SQL。</li> \n <li>支持Rollup Table和Rollup Table的智能查询路由。</li> \n <li>支持较好的多表Join策略和灵活的表达式查询。</li> \n <li>支持Schema在线变更。</li> \n <li>支持Range和Hash二级分区。</li> \n</ul> \n<h2>Doris在外卖数仓中的应用效率</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345435\" src=\"http://localhost:8060/tup/2020/4/23/64cc5750d6ea4451b5e0e172f789f0d7.jpg\" alt=\"\" title=\"\"></span></p> \n<p>上图是我们在一个分析项目改造中的评估项目收益，整体在查询效率不变的情况下，生产耗能及存储成本都有较大收益。</p> \n<p>以20台BE+3FE的Doris环境，效率、性能表现情况如下：</p> \n<ul> \n <li>支撑数据分析产品数十个以上，整体响应达到ms级。</li> \n <li>支持百万、千万级大表关联查询，同时进行维表关联的雪花模型，经过Colocate Join特性优化，可以实现秒级响应。</li> \n <li>日级别，基于商家明细现场计算，同时满足汇总及下钻明细查询，查询时效基本都可以控制在秒级。</li> \n <li>7日趋势分析，2~3秒。由于数据量较大，根据集群规模不同查询性能有所区别，但数据量较大时，调动的集群资源较多，因此MPP的并发性能受限于集群的性能。一般原则是并发较高的业务，需要严格控制查询时效（基本在毫秒级），对于并发不高的业务，允许进行较大的查询，但也要考虑集群的承受能力。</li> \n <li>通过一年来的应用以及Doris的不断改进升级，Doris的高可靠、高可用、高可扩展性也得到进一步验证，服务稳定可靠。</li> \n</ul> \n<h2>准实时场景下的应用</h2> \n<p>离线业务分析大多基于T+1的离线数据，但在营销活动场景下，外卖团队往往需要当日的实时数据进行业务变化的监控与分析，通常情况下会采用实时流计算来实现。</p> \n<p>外卖实时业务监控有如下特点：</p> \n<ul> \n <li>避免分钟级的生产波动影响，业务上10、15分钟准实时数据可以满足分析需要。</li> \n <li>实时数据需要与离线数据进行日环比与周同比的比对。</li> \n <li>订单业务需要事件时间，体验业务需要生产时间，业务对齐逻辑复杂。</li> \n <li>不同业务线需求差异大，指标需要良好扩展性。</li> \n</ul> \n<p>由于业务上的复杂性，实时流计算中，需要考虑诸多业务口径的对齐，业务ER模型在合流处理中开发成本较高，资源占用较大，通过设计基于Doris的准实时生产数仓，可以灵活地实现业务微批处理，且开发生产成本都比较低。以下为基于Doris的准实时数仓架构设计，是典型的实时Lambda生产架构：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345437\" src=\"http://localhost:8060/tup/2020/4/23/078068f0249a4beabd3254bd50eb0b45.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>实现准实时计算方案，需要以下能力的支撑：</strong></p> \n<p><strong>实时的写入能力</strong>：目前支持Kafka To Doris秒级延迟。在可靠性、稳定性建设方面仍需进一步提升。<br><strong>引擎建设</strong>：短平快的计算+高效的存储性能。目前Doris引擎性能仍有进步空间，2020年将有较大改进提升，随着后续Page Cache，内存表等能力的上线，IO将不再拖后腿，并发能力将有较大提升。<br><strong>可靠的调度能力</strong>：提供5、10、15、30分钟的调度保障能力。<br><strong>Lambda架构简化</strong>：实时数据与离线数据更好的在Doris中进行融合，灵活支撑应用。<br><strong>高效的OLAP交互</strong>：支撑业务的灵活查询访问，业务层通过视图进行逻辑封装直接复用汇总层多维模型，提高了开发效率，减少了运维成本。</p> \n<p>相比Storm、Flink中的窗口计算，准实时DB微批的优势：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345429\" src=\"http://localhost:8060/tup/2020/4/23/3db68d4779574f4db3e323d1be2296b4.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>Doris引擎在美团的重要改进</h2> \n<p><strong>Join 谓词下推的传递性优化</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345430\" src=\"http://localhost:8060/tup/2020/4/23/92ee835bb33641b7976df6b5554ca7b6.jpg\" alt=\"\" title=\"\"></span></p> \n<p>如上图所示，对于下面的 SQL：</p> \n<pre><code>select * from t1 join t2 on t1.id = t2.id where t1.id = 1</code></pre> \n<p>Doris开源版本默认会对t2表进行全表Scan，这样会导致上面的查询超时，进而导致外卖业务在Doris上的第一批应用无法上线。</p> \n<p>于是我们在Doris中实现了第一个优化：Join谓词下推的传递性优化（MySQL和TiDB中称之为Constant Propagation）。Join谓词下推的传递性优化是指：基于谓词t1.id = t2.id和t1.id = 1, 我们可以推断出新的谓词t2.id = 1，并将谓词t2.id = 1下推到t2的Scan节点。 这样假如t2表有数百个分区的话，查询性能就会有数十倍甚至上百倍的提升，因为t2表参与Scan和Join的数据量会显著减少。</p> \n<p><strong>查询执行多实例并发优化</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345431\" src=\"http://localhost:8060/tup/2020/4/23/5fd1a5200c094b378b4eae95777208e0.jpg\" alt=\"\" title=\"\"></span></p> \n<p>如上图所示，Doris默认在每个节点上为每个算子只会生成1个执行实例。这样的话，如果数据量很大，每个执行实例的算子就需要处理大量的数据，而且无法充分利用集群的CPU、IO、内存等资源。</p> \n<p>一个比较容易想到的优化手段是，我们可以在每个节点上为每个算子生成多个执行实例。这样每个算子只需要处理少量数据，而且多个执行实例可以并行执行。</p> \n<p>下图是并发度设置为5的优化效果，可以看到对于多种类型的查询，会有3到5倍的查询性能提升：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345438\" src=\"http://localhost:8060/tup/2020/4/23/ce52e6db6a724b7abaeece3b11640798.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>Colocate Join</strong></p> \n<p>Colocate Join（Local Join）是和Shuffle Join、Broadcast Join相对的概念，即将两表的数据提前按照Join Key Shard，这样在Join执行时就没有数据网络传输的开销，两表可以直接在本地进行Join。</p> \n<p><strong>整个Colocate Join在Doris中实现的关键点如下：</strong></p> \n<ul> \n <li>数据导入时保证数据本地性。</li> \n <li>查询调度时保证数据本地性。</li> \n <li>数据Balance后保证数据本地性。</li> \n <li>查询Plan的修改。</li> \n <li>Colocate Table元数据的持久化和一致性。</li> \n <li>Hash Join的粒度从Server粒度变为Bucket粒度。</li> \n <li>Colocate Join的条件判定。</li> \n</ul> \n<p>关于Doris Colocate Join的更多实现细节，可以参考《Apache Doris Colocate Join 原理与实践》。</p> \n<p>对于下面的SQL，Doris Colocate Join和Shuffle Join在不同数据量下的性能对比如下：</p> \n<pre><code>select count(*) FROM A t1 INNER JOIN [shuffle] B t5    ON ((t1.dt = t5.dt) AND (t1.id = t5.id)) INNER JOIN [shuffle] C t6    ON ((t1.dt = t6.dt) AND (t1.id = t6.id)) where t1.dt in (xxx days);</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345433\" src=\"http://localhost:8060/tup/2020/4/23/58c12f149e39428a838e62bb80d99459.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>Bitmap 精确去重</strong></p> \n<p>Doris之前实现精确去重的方式是现场计算的，实现方法和Spark、MapReduce类似：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345434\" src=\"http://localhost:8060/tup/2020/4/23/c3e9fe3f3de64ebfb8189b79112de63f.jpg\" alt=\"\" title=\"\"></span></p> \n<p>对于上图计算PV的SQL，Doris在计算时，会按照下图的方式进行计算，先根据page列和user_id列group by，最后再Count：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345436\" src=\"http://localhost:8060/tup/2020/4/23/64150be3aa2f45dca00cdc13914bfb9b.jpg\" alt=\"图中是6行数据在2个BE节点上计算的示意图\" title=\"图中是6行数据在2个BE节点上计算的示意图\"></span></p> \n<p>显然，上面的计算方式，当数据量越来越大，到几十亿几百亿时，使用的IO资源、CPU资源、内存资源、网络资源会变得越来越多，查询也会变得越来越慢。</p> \n<p>于是我们在Doris中新增了一种Bitmap聚合指标，数据导入时，相同维度列的数据会使用Bitmap聚合。有了Bitmap后，Doris中计算精确去重的方式如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345432\" src=\"http://localhost:8060/tup/2020/4/23/d76e8b8ae35c470bad8c344753ef16a7.jpg\" alt=\"\" title=\"\"></span></p> \n<p>可以看到，当使用Bitmap之后，之前的PV计算过程会大幅简化，现场查询时的 IO、CPU、内存，网络资源也会显著减少，并且不再会随着数据规模而线性增加。</p> \n<h2>总结与思考</h2> \n<p>在外卖运营分析的业务实践中，由于业务的复杂及应用场景的不同，没有哪一种数据生产方案能够解决所有业务问题。数据库引擎技术的发展，为我们提供更多手段提升数据建设方案。实践证明，以Doris引擎为驱动的ROLAP模式可以较好地处理汇总与明细、变化维的历史回溯、非预设维的灵活应用、准实时的批处理等场景。而以Kylin为基础的MOLAP模式在处理增量业务分析，固化维度场景，通过预计算以空间换时间方面依然重要。</p> \n<p>业务方面，通过外卖数仓Doris的成功实践以及跨BG的交流，美团已经有更多的团队了解并尝试使用Doris方案。而且在平台同学的共同努力下，引擎性能还有较大提升空间，相信以Doris引擎为驱动的ROLAP模式会为美团的业务团队带来更大的收益。从目前实践效果看，其完全有替代Kylin、Druid、ES等引擎的趋势。</p> \n<p>目前，数据库技术进步飞速，近期柏睿数据发布全内存分布式数据库RapidsDB v4.0支持TB级毫秒响应（处理千亿数据可实现毫秒级响应）。可以预见，数据库技术的进步将大大改善数仓的分层管理与应用支撑效率，业务将变得“定义即可见”，也将极大地提升数据的价值。</p> \n<h2>参考资料</h2> \n<ul> \n <li><a href=\"https://github.com/apache/incubator-doris\" rel=\"nofollow noreferrer\">Doris文档和源码</a></li> \n <li><a href=\"https://blog.bcmeng.com/post/apache-kylin-vs-baidu-palo.html\" rel=\"nofollow noreferrer\">Apache Kylin VS Apache Doris</a></li> \n</ul> \n<h2>作者简介</h2> \n<ul> \n <li>朱良，美团外卖数据仓库工程师。</li> \n <li>凯森，美团大数据工程师，Apache Kylin Committer。</li> \n</ul> \n<h2>招聘信息</h2> \n<p>美团外卖数据智能组长期招聘数据仓库、数据挖掘、机器学习、计算机视觉、搜索推荐算法工程师，坐标北京。欢迎感兴趣的同学发送阅历到：tech@metuan.com（邮件标题注明：外卖数据智能组）</p> \n<p><strong>阅读更多技术文章，请扫码关注微信公众号-美团技术团队！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021702131\" src=\"http://localhost:8060/tup/2020/4/23/0c613a00d4964a02ad37695109e9e335.jpg\" alt=\"\" title=\"\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/0d3946f2ad374eecab63148f09324fa2.jpg', '3f69fcc9b13843d1910b3dac597f5215', '19eb3dd59ef8430d9f637d97449fc417', 'f3eb17e6e5664a97af3e9b1fca12b286,d986ab02dd4345098381ef8b01db7e4d,d1d122dcdca34dceaad794efaef79d56', '0', '3', '1', '2020-04-23 10:59:01', '2020-04-23 10:59:01');
INSERT INTO `tb_recommend` VALUES ('5b5f4c718a3a42bd94909df4d9958d94', 'Mozilla 开源支持项目发起 COVID-19 解决方案基金，接受全球项目申请', 'SegmentFault 思否消息：近日 Mozilla Open Source Support Program (MOSS）发起了COVID-19 Solutions Fund，将向响应疫情的开源技术项目提供最高 5 万美元的资金。MOSS 称它接受硬件、软件以及相关项目的申请。M...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022250952\" src=\"http://localhost:8060/tup/2020/4/23/acc583a0bb134320bc1c3ba26a97c019.jpg\" alt=\"\" title=\"\"></span></p> \n<p>SegmentFault 思否消息：近日 Mozilla Open Source Support Program (MOSS）发起了<a href=\"https://blog.mozilla.org/blog/2020/03/31/moss-launches-covid-19-solutions-fund/\" rel=\"nofollow noreferrer\">COVID-19 Solutions Fund</a>，将向响应疫情的开源技术项目提供最高 5 万美元的资金。MOSS 称它接受硬件、软件以及相关项目的申请。MOSS 是 Mozilla 在 2015 年发起了开源支持计划，向开源项目捐助开发资金，帮助开源项目可持续的发展。</p> \n<p>Mozilla 接受硬件（如开源呼吸机）、软件（如连接医院和能提供 3D 打印机打印开源呼吸机零部件的用户的平台），以及解决因 COVID-19 引起的二次效应的软件（如打击&nbsp;COVID-19 假信息的浏览器插件）等相关项目的申请。</p> \n<p><strong>几个关键细节：</strong></p> \n<ol> \n <li>优先考虑为合理成熟的项目提供资金，早期的想法不太可能获得资金。</li> \n <li>希望获奖者在获奖后三个月内使用所有资金。</li> \n <li>将在法律允许的范围内接受来自世界各地的申请。</li> \n <li>将接受任何类型的法律实体的申请，包括非政府组织、营利性医院或与受影响社区有密切联系的开发商团队。</li> \n <li>申请将被按照顺序轮流接受和审查。</li> \n <li>MOSS委员会将只考虑那些根据 FSF 的自由软件许可证或 OSI 的开源许可证公开发布的项目。未获得开放源代码许可使用许可的项目没有资格获得 MOSS 资助。</li> \n</ol> \n<p>申请地址：<a href=\"https://mozilla.fluxx.io/apply/MOSS\" rel=\"nofollow noreferrer\">https://mozilla.fluxx.io/apply/MOSS</a></p> \n<hr> \n<p>MOSS 官方声明原文：<a href=\"https://blog.mozilla.org/blog/2020/03/31/moss-launches-covid-19-solutions-fund/\" rel=\"nofollow noreferrer\"><strong>MOSS launches COVID-19 Solutions Fund</strong></a></p> \n<p>Mozilla is announcing today the creation of a COVID-19 Solutions Fund as part of the Mozilla Open Source Support Program (MOSS). Through this fund, we will provide awards of up to $50,000 each to open source technology projects which are responding to the COVID-19 pandemic in some way.</p> \n<p>The MOSS Program, created in 2015, broadens access, increases security, and empowers users by providing catalytic funding to open source technologists. We have already seen inspiring examples of open source technology being used to increase the capacity of the world’s healthcare systems to cope with this crisis. For example, just a few days ago, the University of Florida Center for Safety, Simulation, and Advanced Learning Technologies released an<a href=\"https://simulation.health.ufl.edu/technology-development/open-source-ventilator-project/\" rel=\"nofollow noreferrer\">open source ventilator</a>. We believe there are many more life-saving open source technologies in the world.</p> \n<p>As part of the COVID-19 Solutions Fund, we will accept applications that are hardware (e.g., an open source ventilator), software (e.g., a platform that connects hospitals with people who have 3D printers who can print parts for that open source ventilator), as well as software that solves for secondary effects of COVID-19 (e.g., a browser plugin that combats COVID related misinformation).</p> \n<p>A few key details of the program:</p> \n<ul> \n <li>We are generally looking to fund reasonably mature projects that can immediately deploy our funding, early stage ideas are unlikely to receive funding.</li> \n <li>We generally expect awardees to use all funds within three months of receiving the award.</li> \n <li>We will accept applications from anywhere in the world to the extent legally permitted.</li> \n <li>We will accept applications from any type of legal entity, including NGOs, for profit hospitals, or a team of developers with strong ties to an affected community.</li> \n <li>Applications will be accepted and reviewed on a rolling basis.</li> \n <li>The MOSS committee will only consider projects which are released publicly under a license that is either a free software license according to the FSF or an open source license according to the OSI. Projects which are not licensed for use under an open source license are not eligible for MOSS funding.</li> \n</ul> \n<p>To apply, please visit:<a href=\"https://mozilla.fluxx.io/apply/MOSS\" rel=\"nofollow noreferrer\">https://mozilla.fluxx.io/apply/MOSS</a></p> \n<p>For more information about the MOSS program, please visit:<a href=\"https://www.mozilla.org/moss\" rel=\"nofollow noreferrer\">Mozilla.org/moss</a>.</p> \n<p><strong>ABOUT MOSS</strong></p> \n<p><em>The Mozilla Open Source Support (MOSS) awards program, created in 2015, broadens access, increases security, and empowers users by providing catalytic funding to open source technologists. In addition to the COVID-19 Solutions Fund, MOSS has three tracks:</em></p> \n<ul> \n <li><em>Track I – Foundational Technology: supports open source projects that Mozilla relies on, either as an embedded part of our products or as part of our everyday work.</em></li> \n <li><em>Track II – Mission Partners: supports open source projects that significantly advance Mozilla’s mission.</em></li> \n <li><em>Track III – The Secure Open Source Fund: supports security audits for widely used open source software projects as well as any work needed to fix the problems that are found.</em></li> \n</ul> \n<p><em>Tracks I and II and this new COVID-19 Solutions Fund accept applications on a rolling basis. For more information about the MOSS program, please visit:<a href=\"https://www.mozilla.org/moss\" rel=\"nofollow noreferrer\">Mozilla.org/moss</a>.&nbsp;</em></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"http://localhost:8060/tup/2020/4/23/d59dc3312f414bae8c64fc0ac9a14612.jpg\" alt=\"sf.png\" title=\"sf.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/b00dcca664fe45ecbb91864067b806e9.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '19eb3dd59ef8430d9f637d97449fc417', '7415188933514e5ab6d45d3645d83337,f3eb17e6e5664a97af3e9b1fca12b286,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-23 10:59:14', '2020-04-23 10:59:14');
INSERT INTO `tb_recommend` VALUES ('5f2a259b127244868a45e41ef090d2ad', '【拥抱大厂系列】几个面试官常问的垃圾回收器，下次面试就拿这篇文章怼回去！', '先瞎比比一下，上一篇文章已经过去2个多月了，你大概会问我这段时间干什么去了，怎么没有更新文章，那我告诉你，当然是面试去了，经过了一个多月的面试，身经百战，已经拿了几个offer，现在是时候把前段时间的知...', '<blockquote>\n 点个赞，看一看，好习惯！本文 \n <strong>GitHub</strong> \n <a href=\"https://github.com/OUYANGSIHAI/JavaInterview\" rel=\"nofollow noreferrer\">https://github.com/OUYANGSIHAI/JavaInterview</a> 已收录，这是我花了3个月总结的一线大厂Java面试总结，本人已拿腾讯等大厂offer。\n</blockquote> \n<p>先瞎比比一下，上一篇文章已经过去2个多月了，你大概会问我这段时间干什么去了，怎么没有更新文章，那我告诉你，当然是面试去了，经过了一个多月的面试，身经百战，已经拿了几个offer，现在是时候把前段时间的知识储备给大家分享出来了，顺便也换种形式来给大家讲讲相关的知识。</p> \n<p>接下来的每篇文章都会是先给出几个问题，然后再知识点，然后再回答问题这样的形式。</p> \n<h3>1 问题</h3> \n<p>这一段面试的时间面了很多的互联网公司的大厂，也很幸运拿了几个offer，现在也还是面试的过程中，可以说，这么多的面试，Java虚拟机是一个必问的知识点，而垃圾回收器更是重中之重，如果面试官抛出一个垃圾回收器的问题，你一脸懵逼，那估计这个面试是凉了。</p> \n<p>比如，面试官一上来就狠狠的问了这几个问题。</p> \n<ul> \n <li>你可以介绍一下Java虚拟机的垃圾回收器吗？</li> \n <li>你可以介绍一下CMS垃圾回收器的原理吗？</li> \n <li>你可以介绍一下G1垃圾回收器的原理吗，跟CMS有什么区别？</li> \n</ul> \n<p>再来个深一点的问题？</p> \n<ul>\n <li>CMS垃圾回收器哪个阶段最耗时，会不会出现stw的问题呢？</li>\n</ul> \n<p>没有看过这些知识点是不是一脸懵逼。</p> \n<p>好了，接下来我来讲讲这些垃圾回收器都是什么神仙，面试官为什么喜欢死磕这个呢？</p> \n<h3>2 死磕垃圾回收器</h3> \n<p>先上一张图，这张图是Java虚拟机的jdk1.7及以前版本的所有垃圾回收器，也可以说是比较成熟的垃圾回收器，除了这些垃圾回收器，面试的时候最多也就再怼怼G1和ZGC了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"http://image.ouyangsihai.cn/Fh4MDY7P-TO1tQgtUQQJyykjibCZ\" src=\"http://localhost:8060/tup/2020/4/23/1830e439193f46599b849b49fce785c0.jpg\" alt=\"\" title=\"\"></span></p> \n<p>上面的表示是年轻代的垃圾回收器：Serial、ParNew、Parallel Scavenge，下面表示是老年代的垃圾回收器：CMS、Parallel Old、Serial Old，以及不分老年代和年轻代的G1。之间的相互的连线表示可以相互配合使用。</p> \n<p>说完是不是一篇明朗，其实也就是那么回事。</p> \n<h4>2.1 新生代垃圾回收器</h4> \n<h5>2.1.1 Serial</h5> \n<p>Serial（串行）收集器是<strong>最基本、发展历史最悠久</strong>的收集器，它是采用<strong>复制算法</strong>的新生代收集器，曾经（JDK 1.3.1之前）是虚拟机新生代收集的唯一选择。它是一个<strong>单线程收集器</strong>，只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集时，必须暂停其他所有的工作线程，直至Serial收集器收集结束为止（“Stop The World”）。</p> \n<p>其实对于这个垃圾回收器，你只要记住是一个<strong>单线程、采用复制算法的，会进行“Stop The World”</strong> 即可，因为面试官一般不问这个，为什么，因为太简单了，没什么可问的呗。</p> \n<p>好了，再放一张图好吧，说明一下Serial的回收过程，完事。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"http://image.ouyangsihai.cn/FtIw-Pz3PDNJlRp2v89XfIzxJckG\" src=\"http://localhost:8060/tup/2020/4/23/0e5dd45ece2b45139c361f368c7a4f28.jpg\" alt=\"\" title=\"\"></span></p> \n<p>说明：这张图的意思就是<strong>单线程，新生代使用复制算法标记、老年代使用标记整理算法标记</strong>，就是这么简单。</p> \n<h5>2.1.2 ParNew</h5> \n<p><strong>ParNew收集器就是Serial收集器的</strong>多线程<strong>版本</strong>，它也是一个新生代收集器。除了使用多线程进行垃圾收集外，其余行为包括Serial收集器可用的所有控制参数、收集算法（复制算法）、Stop The World、对象分配规则、回收策略等与Serial收集器完全相同。</p> \n<p>需要注意一点是：<strong>除了Serial收集器外，目前只有它能和CMS收集器（Concurrent Mark Sweep）配合工作。</strong></p> \n<p>最后再放一张回收过程图；</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"http://image.ouyangsihai.cn/FvsKnXGzEQd6WYdUmIgLcWoSHG4H\" src=\"http://localhost:8060/tup/2020/4/23/980f07ccc3d54a948d0053340cde58e7.jpg\" alt=\"\" title=\"\"></span></p> \n<p><em>*</em> 是不是很简单，我在这里讲这些知识点并不是为了深入去了解这些原理，基本的知道对于工作已经够了，其实，主要还是应付面试官，哈哈。</p> \n<h5>2.1.3 Parallel Scavenge</h5> \n<p>Parallel Scavenge收集器也是一个<strong>并行</strong>的<strong>多线程</strong>新生代收集器，它也使用<strong>复制算法</strong>。</p> \n<p>Parallel Scavenge收集器的特点是它的关注点与其他收集器不同，CMS等收集器的关注点是尽可能缩短垃圾收集时用户线程的停顿时间。</p> \n<p>这里需要注意的唯一的区别是：Parallel Scavenge收集器的目标是<strong>达到一个可控制的吞吐量（Throughput）</strong>。</p> \n<p>我们知道，停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验。而<strong>高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务</strong>。</p> \n<h4>2.2 老年代垃圾回收器</h4> \n<h5>2.2.1 Serial Old</h5> \n<p>Serial Old 是Serial收集器的老年代版本，它同样是一个<strong>单线程</strong>收集器，使用“<strong>标记-整理</strong>”（Mark-Compact）算法。</p> \n<p>在这里就可以出一个面试题了。</p> \n<ul>\n <li>为什么Serial使用的是<strong>复制算法</strong>，而Serial Old使用是<strong>标记-整理</strong>算法？</li>\n</ul> \n<p>同一个爸爸，儿子长的天差地别，当然也有啊，哈哈。</p> \n<blockquote>\n 其实，看了我前面的文章你可能就知道了，因为在新生代绝大多数的内存都是会被回收的，所以留下来的需要回收的垃圾就很少了，所以复制算法更合适，你可以发现，基本的老年代的都是使用标记整理算法，当然，CMS是个杂种哈。\n</blockquote> \n<p>它的工作流程与Serial收集器相同，下图是Serial/Serial Old配合使用的工作流程图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"http://image.ouyangsihai.cn/FtIw-Pz3PDNJlRp2v89XfIzxJckG\" src=\"http://localhost:8060/tup/2020/4/23/35f934b69f3341bf8c4809997ea68741.jpg\" alt=\"\" title=\"\"></span></p> \n<h5>2.2.2 Parallel Old</h5> \n<p>Parallel Old收集器是Parallel Scavenge收集器的老年代版本，使用<strong>多线程</strong>和“<strong>标记-整理</strong>”算法，是不是前面说的，老年代出了杂种CMS不是“<strong>标记-整理</strong>”算法，其他都是。</p> \n<p>另外，有了Parallel Old垃圾回收器后，就出现了以“<strong>吞吐量优先</strong>”著称的“男女朋友”收集器了，这就是：<strong>Parallel Old和Parallel Scavenge收集器的组合</strong>。</p> \n<p>Parallel Old收集器的工作流程与Parallel Scavenge相同，这里给出Parallel Scavenge/Parallel Old收集器配合使用的流程图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"http://image.ouyangsihai.cn/Fv96fnkSnbV85BS2E6mr_ZFBd9We\" src=\"http://localhost:8060/tup/2020/4/23/98383a57fee140c59a4cf7a0f7ca3a48.jpg\" alt=\"\" title=\"\"></span></p> \n<p>你是不是以为我还要讲CMS和G1，我任性，这几个面试重点还是得死磕它，下回分解哈。</p> \n<h3>3 总结</h3> \n<p>这里把上面的这些垃圾回收器做个总结，看完这个，面试给面试官讲的时候思路就非常清晰了。</p> \n<table> \n <thead>\n  <tr> \n   <th>收集器</th> \n   <th>串行、并行or并发</th> \n   <th>新生代/老年代</th> \n   <th>算法</th> \n   <th>目标</th> \n   <th>适用场景</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td><strong>Serial</strong></td> \n   <td>串行</td> \n   <td>新生代</td> \n   <td>复制算法</td> \n   <td>响应速度优先</td> \n   <td>单CPU环境下的Client模式</td> \n  </tr> \n  <tr> \n   <td><strong>Serial Old</strong></td> \n   <td>串行</td> \n   <td>老年代</td> \n   <td>标记-整理</td> \n   <td>响应速度优先</td> \n   <td>单CPU环境下的Client模式、CMS的后备预案</td> \n  </tr> \n  <tr> \n   <td><strong>ParNew</strong></td> \n   <td>并行</td> \n   <td>新生代</td> \n   <td>复制算法</td> \n   <td>响应速度优先</td> \n   <td>多CPU环境时在Server模式下与CMS配合</td> \n  </tr> \n  <tr> \n   <td><strong>Parallel Scavenge</strong></td> \n   <td>并行</td> \n   <td>新生代</td> \n   <td>复制算法</td> \n   <td>吞吐量优先</td> \n   <td>在后台运算而不需要太多交互的任务</td> \n  </tr> \n  <tr> \n   <td><strong>Parallel Old</strong></td> \n   <td>并行</td> \n   <td>老年代</td> \n   <td>标记-整理</td> \n   <td>吞吐量优先</td> \n   <td>在后台运算而不需要太多交互的任务</td> \n  </tr> \n </tbody> \n</table> \n<p>好了，这回就到这里了，开头的几个问题，你会了吗？</p> \n<p>另外，我花了3个月时间把Java学习和面试的总结整理成了一本电子书！目录如下</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"http://image.ouyangsihai.cn/FsgkJDzTT6xA7Ik84h6zYRg4oW6L\" src=\"http://localhost:8060/tup/2020/4/23/70641f80e5a746b789ef03e4ad1b5817.jpg\" alt=\"\" title=\"\"></span></p> \n<p>现在免费分享大家，在我的公众号<strong>好好学java</strong>回复<strong>Java面试</strong>即可获取。</p> \n<h4>有收获？希望老铁们来个三连击，给更多的人看到这篇文章</h4> \n<p>1、老铁们，关注我的原创微信公众号「<strong>好好学java</strong>」，专注于Java、数据结构和算法、微服务、中间件等技术分享，保证你看完有所收获。</p> \n<p>2、给俺点个赞呗，可以让更多的人看到这篇文章，顺便激励下我继续写作，嘻嘻。</p> \n<p><strong>点赞是对我最大的鼓励</strong><br>↓↓↓↓↓↓</p>', null, null, '61cdf41d1e5e4f229b76f6a042e254b6', 'bb0b7e69ad3e46fcb121baefda8f1f78', '2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-23 10:28:15', '2020-04-23 10:28:15');
INSERT INTO `tb_recommend` VALUES ('609512b8f1424929bf556b798363ee1d', '从零开始的Flutter之旅: StatelessWidget', '小部件是Flutter应用程序的基本构建模块，每一个都是不可变的声明，也是用户界面的一部分。例如button，text，color以及布局所用到的padding等等。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEdtJ\" src=\"http://localhost:8060/tup/2020/4/23/d7f86bdb7fc046779047b52d81dfdaea.jpg\" alt=\"Flutter - Beautiful native apps in record time.png\" title=\"Flutter - Beautiful native apps in record time.png\"></span></p> \n<p>这次要展示的是什么是Flutter的Widget，即小部件；以及如何在Flutter中使用StatelessWidget，即无状态小部件。</p> \n<p>至于Flutter，通俗的讲是开发者可以通一套简单的代码来同时构建Android与IOS应用程序。</p> \n<h2>特性</h2> \n<p>小部件是Flutter应用程序的基本构建模块，每一个都是不可变的声明，也是用户界面的一部分。例如button，text，color以及布局所用到的padding等等。</p> \n<p>下面我们来看<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>中的一个实例。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEdtU\" src=\"http://localhost:8060/tup/2020/4/23/14bc6b57d4274cd6abda6174abaaf5c5.jpg\" alt=\"stateless_widget_1.png\" title=\"stateless_widget_1.png\"></span></p> \n<p>圈选中的item只有两个信息，头像与名称。为了避免代码的重复使用，将其抽离成一个独立的widget，具体代码如下</p> \n<pre><code>class FollowersItemView extends StatelessWidget {\n  final GestureTapCallback tapCallback;\n  final String avatarUrl;\n  final String name;\n \n  const FollowersItemView(\n      {Key key, this.avatarUrl, this.name, this.tapCallback})\n      : super(key: key);\n \n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.symmetric(horizontal: 15.0),\n      child: GestureDetector(\n        behavior: HitTestBehavior.opaque,\n        onTap: tapCallback,\n        child: Column(\n          children: &lt;Widget&gt;[\n            Row(\n              children: &lt;Widget&gt;[\n                FadeInImage.assetNetwork(\n                  placeholder: \'images/app_welcome.png\',\n                  image: avatarUrl,\n                  width: 80.0,\n                  height: 80.0,\n                ),\n                Expanded(\n                  child: Padding(\n                    padding: EdgeInsets.only(left: 15.0),\n                    child: Text(\n                      name,\n                      overflow: TextOverflow.ellipsis,\n                      maxLines: 1,\n                      style: TextStyle(\n                        color: Colors.grey[600],\n                        fontSize: 20.0,\n                        fontWeight: FontWeight.bold,\n                      ),\n                    ),\n                  ),\n                )\n              ],\n            ),\n            Padding(\n              padding: EdgeInsets.symmetric(vertical: 15.0),\n              child: Divider(\n                thickness: 1.0,\n                color: colorEAEAEA,\n                height: 1.0,\n                endIndent: 0.0,\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}</code></pre> \n<p>它继承于StatelessWidget，StatelessWidget的特性是无状态，数据不可变化。这个性质正好符合我们将要抽离的部件。抽离的部件需要做头像与名称的展示，没有任何形式上的交互变化。唯一的一个交互也是点击，但它并没有涉及数据的改变。所以在代码中将这些数据定义成final类型。本质就如Text部件，并没有如输入文本或者带有动画的部件一样随着时间内部属性会有所变化。</p> \n<p>既然没有任何变化，那么我们也可以将其构造函数定义为const类型。</p> \n<p>有了上面的部件抽离，我们就可以直接在ListView中使用该无状态部件</p> \n<pre><code>  @override\n  Widget createContentWidget() {\n    return RefreshIndicator(\n      onRefresh: vm.handlerRefresh,\n      child: Scrollbar(\n        child: ListView.builder(\n            padding: EdgeInsets.only(top: 15.0),\n            itemCount: vm.list?.length ?? 0,\n            itemBuilder: (BuildContext context, int index) {\n              final item = vm.list[index];\n              return FollowersItemView(\n                avatarUrl: item.avatar_url,\n                name: item.login,\n                tapCallback: () {\n                  Navigator.push(context, MaterialPageRoute(builder: (_) {\n                    return WebViewPage(title: item.login, url: item.html_url);\n                  }));\n                },\n              );\n            }),\n      ),\n    );\n  }</code></pre> \n<p>在ListView中引用FollowItemView，并传入不变的数据即可。</p> \n<h2>呈现原理</h2> \n<p>现在StatelessWidget的使用大家都会了，那它是如何调用的呢？</p> \n<p>下面我们来看下它的呈现原理。</p> \n<p>正如开头所说的将小部件作为Flutter应用构建的基础，在Flutter中我们将小部件的构建称作为Widget Tree，即小部件树。它就像是应用程序的蓝图，我们将蓝图创建好，然后内部会通过蓝图去创建对应显示在屏幕上的element元素。它包含了蓝图上对应的小部件的配置信息。所以对应的还有一个Element Tree，即元素树。</p> \n<p>每一个StatelWidget都有一个StatelessElement，内部会通过createElement()方法进行创建其实例</p> \n<pre><code>  @override\n  StatelessElement createElement() =&gt; StatelessElement(this);</code></pre> \n<p>同时在StatelessElement中会通过buid()方法来获取StalessWidget中所构建的蓝图Widget，并将元素显示到屏幕上。</p> \n<p>Widget Tree与Element Tree之间的交互如下</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEdtW\" src=\"http://localhost:8060/tup/2020/4/23/61e4900bb26c4d9ab24752008aee894b.jpg\" alt=\"stateless_widget_2.png\" title=\"stateless_widget_2.png\"></span></p> \n<p>FollowerItemView中的StatelessElement会调用build方法来获取它是否有子部件，如果有的话对应的子部件也会创建它们自己的Element，并把它安装到元素树上。</p> \n<p>所以我们的程序有两颗对应的树，其中一颗代表屏幕上显示的内容Element；另一颗树代表其展示的蓝图Widget，它们由许多的小部件组成。</p> \n<p>而我们开发人员所做的就是将这些不同的小部件构建成我们所需要的应用程序。</p> \n<p>最后，我们再来了解下最初的安装入口。</p> \n<pre><code>void main() {\n  runApp(GithubApp());\n}</code></pre> \n<p>在我们的main文件中，有一个main函数，其中调用了runApp方法，传入的是GithubApp。我们再来看下GithubApp是什么？</p> \n<pre><code>class GithubApp extends StatefulWidget {\n  @override\n  _GithubAppState createState() {\n    return _GithubAppState();\n  }\n}\n \nclass _GithubAppState extends State&lt;GithubApp&gt; {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: \'Flutter Github\',\n      theme: ThemeData.light(),\n      initialRoute: welcomeRoute.routeName,\n      routes: {\n        welcomeRoute.routeName: (BuildContext context) =&gt; WelcomePage(),\n        loginRoute.routeName: (BuildContext context) =&gt; LoginPage(),\n        homeRoute.routeName: (BuildContext context) =&gt; HomePage(),\n        repositoryRoute.routeName: (BuildContext context) =&gt; RepositoryPage(),\n        followersRoute.routeName: (BuildContext context) =&gt;\n            FollowersPage(followersRoute.pageType),\n        followingRoute.routeName: (BuildContext context) =&gt;\n            FollowersPage(followingRoute.pageType),\n        webViewRoute.routeName: (BuildContext context) =&gt; WebViewPage(title: \'\',),\n      },\n    );\n  }\n}</code></pre> \n<p>发现没它其实也是一个Widget，正如文章开头所说的，Flutter是由各个Widget组成。main是程序的入口，而其中的runApp中的Widget是整个程序挂载的起点。它会创建成一个具有与屏幕宽高一致的根元素，并把它装载到屏幕中。</p> \n<p>所以在Flutter中一直都是通过创建Element，然后调用build方法来获取其后续的子Widget，最终构建成我们所看到的程序。</p> \n<p>文中的代码都是来自于<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>，这是一个基于Flutter的Github客户端同时支持Android与IOS，支持账户密码与认证登陆。使用dart语言进行开发，项目架构是基于Model/State/ViewModel的MSVM；使用Navigator进行页面的跳转；网络框架使用了dio。项目正在持续更新中，感兴趣的可以关注一下。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEdtZ\" src=\"http://localhost:8060/tup/2020/4/23/84d708103f274a4d83a2968e981cc1c2.jpg\" alt=\"flutter_github.png\" title=\"flutter_github.png\"></span></p> \n<p>当然如果你想了解Android原生，相信<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>的纯Android版本<a href=\"https://github.com/idisfkj/AwesomeGithub\" rel=\"nofollow noreferrer\">AwesomeGithub</a>是一个不错的选择。</p> \n<h2>下期预告</h2> \n<p><strong>从零开始的Flutter之旅: StatefulWidget</strong></p> \n<p>如果你喜欢我的文章模式，或者对我接下来的文章感兴趣，建议您关注我的微信公众号：【Android补给站】</p> \n<p>或者扫描下方二维码，与我建立有效的沟通，同时更快更准的收到我的更新推送。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbsh4i\" src=\"http://localhost:8060/tup/2020/4/23/784fced5ea194b04bc68bcb9485ab9cb.jpg\" alt=\"Android补给站.jpg\" title=\"Android补给站.jpg\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/e5424850842d4195b1acbd1666b5e34b.jpg', '5ca4567d892841b087fac5246effac40', 'a337904dd1d5477b9689d7693be316de', '8dfc62f227ae4076888ea4872e03cddd,14ab12176ade47da95ba97d7151eb1f9,63c4e1e7ec204b43a62065a3ced4c2ce,85ee959b27f74072b13cc763b9bbf77e,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-23 10:32:00', '2020-04-23 10:32:00');
INSERT INTO `tb_recommend` VALUES ('62a9ba22e1a443c58655a4188814ee7f', '编程语言趋势报告：1200 万开发人员使用 JavaScript，Kotlin 增速最快', '近日，数据分析网站 SlashData 发布了第 18 刊开发者研究报告。该次报告调研从 2019 年 11 月持续到 2020 年 2 月，共调查了 159 个国家的 17000 名开发者。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGgJw\" src=\"http://localhost:8060/tup/2020/4/23/a8da4db36391489fbd05a81094ab607d.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>近日，数据分析网站 SlashData 发布了第 18 刊开发者研究报告。该次报告调研从 2019 年 11 月持续到 2020 年 2 月，共调查了 159 个国家的 17000 名开发者。</p> \n<p>从该报告中，我们可以得出很多已知或者没想到的分析结果，比如：</p> \n<ul> \n <li>JavaScript 是最受欢迎的编程语言，全球有超过 1200 万的开发者在使用它。</li> \n <li>Python 新增了近 220 万开发者，在流行程度上超过了 Java。</li> \n <li>按百分比计算，Kotlin 是增长最快的语言社区。在过去两年中，它的规模几乎翻了一番。</li> \n <li>每 5 个开发者中就有 3 个参与过开源项目献。</li> \n <li>使用 CI/CD 工具的开发人员成为专业开发人员的可能性提高了 20 个百分点。</li> \n <li>从事大数据和深度学习框架的 ML 开发人员更倾向于在混合云和多云上部署代码。</li> \n <li>增强现实(AR)和虚拟现实(VR)的从业者大多是具有不同兴趣和技能的热情爱好者。</li> \n <li>22% 的 AR&amp;VR 非开发者正在学习代码。最受该人群欢迎的语言是 Java、C++ 和 C#。</li> \n <li>大多数开发人员（59%）都在从事 DevOps 工作，其中 27% 的人目前正在从事涉及 DevOps的项目。</li> \n</ul> \n<p>下面，我们针对报告做一些详细分析，完整的报告可以在文末获取。</p> \n<h2>上千万开发者使用 JavaScript</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGgzg\" src=\"http://localhost:8060/tup/2020/4/23/d03f106f01dc4768b5f11e6f20d459fa.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>根据最新的数据统计，全球共有 2040 万活跃的开发者，而根据 SlashData 的报告显示，全球有 1,220 万开发者在使用 JavaScript，像 Google 维护的 AngularJS、Facebook 的 React 和 Vue.js 都享受着 JavaScript 框架的大力扶持。</p> \n<p>据该公司估计，在过去两年中，已经有 300 万开发者加入了 JavaScript 社区。因此开发者分析机构 RedMonk 将 TypeScript 列为第九大最受欢迎的语言，甚至超过了苹果公司的 Swift。</p> \n<h2>Java 和 Python 最受欢迎</h2> \n<p>Java 和 Python 仍然是最受开发者喜欢的语言。据 SlashData 统计，全球约有 840 万 Python 开发者和 820 万 Java 开发者。</p> \n<p>其他拥有超过 100 万用户的语言还包括 C++、C#、Visual tools、Kotlin、Swift、Go、Ruby、Objective C，Rust 的用户为 60 万，Lua 的用户数量也达到了了 50万。</p> \n<p>Python 日益受欢迎的原因之一，就是人工智能在当今科技领域的重要性。据报告显示，大约四分之三的机器学习开发者和数据科学家在使用 Python，只有不到 20% 的比例在使用 R 语言。</p> \n<h2>Kotlin 增速最快</h2> \n<p>Kotlin 是过去两年来增长最快的语言，共新增了 110 万开发者，最大的原因应该是 Google 选择了 Kotlin 作为 Android 开发的首选语言。这一数据与 GitHub 近两年报告当中的数据也是吻合的。</p> \n<p>根据 SlashData 报告中的数据，在过去一年中，使用 Swift 的开发者数量实际上比前一年有所下降，目前为 200 万。与此同时，Objective C 仍然有 120 万开发者在使用，但这个数字也在下降。</p> \n<h2>半数以上开发者参与开源</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGgS6\" src=\"http://localhost:8060/tup/2020/4/23/ac35c712bbfe4d5286f1dc0dc9778af5.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>调查还发现，59% 的开发者参与了开源项目。有一个数据很有意思，在参与开源项目的开发者中，24 岁以下的开发者占了近三分之一。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGgTI\" src=\"http://localhost:8060/tup/2020/4/23/9f7a85730dc34207a060293d5aa0cf27.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>有 29% 的开发者参与开源的原因，是希望提高自己的编程能力；26% 的人相信开源软件可以为开发者和行业带来好处；只有 3% 的开发者在开源项目的实际工作中得到了报酬。</p> \n<hr> \n<p>SlashData 官网：<a href=\"https://www.slashdata.co/\" rel=\"nofollow noreferrer\">https://www.slashdata.co/</a></p> \n<p>不方便自行下载的朋友，可以扫描下方二维码并回复关键词「报告」，获取《State of the developer nation》完整版 PDF。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGgQm\" src=\"http://localhost:8060/tup/2020/4/23/375e144f20b94e389436fd19ae3a38a2.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/3e512e16f18544a5af6405d59c072b5e.jpg', '1894b118d35d44cb8fe8009529c4154b', '819ad72c1efe450f9d7affc135a4b457', 'c239cd5742204caf9461f570ba33e8ae,2294832fe5104d73ace4f14ad9549018,43145b2d806a4c3e8bb30d20ef04d61b,a7e018e203b949f0b51e659db4105653', '0', '3', '1', '2020-04-23 10:34:58', '2020-04-23 10:34:58');
INSERT INTO `tb_recommend` VALUES ('65bce4a1e9ae42f990d674e5cd98227b', '基于 Nginx 的 HTTPS 性能优化实践', '分享一个HTTPS优化案例。随着相关浏览器对HTTP协议的“不安全”、红色页面警告等严格措施的出台，以及向 iOS 应用的 ATS 要求和微信、支付宝小程序强制 HTTPS 需求，以及在合规方面如等级保护对传输安全性的要求都...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419749\" src=\"http://localhost:8060/tup/2020/4/23/676f1c3e8a394e9a80e92cf9fe63f247.jpg\" alt=\"\" title=\"\"></span><br>本文转载自「云栖社区」,作者：妙正灰</p> \n<p><strong>前言</strong></p> \n<p>分享一个HTTPS优化案例。随着相关浏览器对HTTP协议的“不安全”、红色页面警告等严格措施的出台，以及向 iOS 应用的 ATS 要求和微信、支付宝小程序强制 HTTPS 需求，以及在合规方面如等级保护对传输安全性的要求都在推动 HTTPS 的发展。</p> \n<p>虽然 HTTPS 优化了网站访问体验（防劫持）以及让传输更加安全，但是很多网站主赶鸭子上架式的使用了 HTTPS 后往往都会遇到诸如：页面加载速度变慢、服务器负载过高以及证书过期不及时更新等问题。</p> \n<p>所以本文就来探讨一下 HTTPS 的优化实践。</p> \n<p><strong>选型</strong></p> \n<p>其实像 Apache Httpd、LigHttpd、Canddy 等 Web 服务软件都可以设置 HTTPS，但是在相应的扩展生态和更新率上都不如 Nginx。 Nginx 作为大型互联网网站的 Web 入口软件有着广泛的支持率，例如阿里系的 Tengine、CloudFlare 的 cloudflare-nginx、又拍云用的 OpenResty 都是基于 Nginx 而来的，Nginx 是接受过大规模访问验证的。同时大家也将自己开发的组件回馈给 Nginx 社区，让 Nginx 有着非常良好的扩展生态。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419748\" src=\"http://localhost:8060/tup/2020/4/23/c128576f3b2f42c088206db37221f038.jpg\" alt=\"\" title=\"\"></span></p> \n<p>图1-1 Nginx 在全网的使用情况 </p> \n<p>所以说 Nginx 是一款很好的 Web 服务软件，选择 Nginx 在提升性能的同时能极大的降低我们的扩展成本。</p> \n<p><strong>新功能</strong></p> \n<p>围绕 Web 服务已经有非常多的新功能需要我们关注并应用了，这里先罗列相关新功能。</p> \n<p><strong>HTTP/2</strong></p> \n<p>相比廉颇老矣的 HTTP/1.x，HTTP/2 在底层传输做了很大的改动和优化包括有：</p> \n<ol> \n <li>每个服务器只用一个连接，节省多次建立连接的时间，在TLS上效果尤为明显</li> \n <li>加速 TLS 交付，HTTP/2 只耗时一次 TLS 握手，通过一个连接上的多路利用实现最佳性能</li> \n <li>更安全，通过减少 TLS 的性能损失，让更多应用使用 TLS，从而让用户信息更安全</li> \n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419751\" src=\"http://localhost:8060/tup/2020/4/23/fd75cce342234469b25fc5b5990ce726.jpg\" alt=\"\" title=\"\"></span></p> \n<p>在 Akamai 的 HTTP/2 DEMO中，加载300张图片，HTTP/2 的优越性极大的显现了出来，在 HTTP/1.X 需要 14.8s 的操作中，HTTP/2 仅需不到1s。</p> \n<p>HTTP/2 现在已经获得了绝大多数的现代浏览器的支持。只要我们保证 Nginx 版本大于 1.9.5 即可。当然建议保持最新的 Nginx 稳定版本以便更新相关补丁。同时 HTTP/2 在现代浏览器的支持上还需要 OpenSSL 版本大于 1.0.2。</p> \n<p><strong>TLS 1.3</strong></p> \n<p>和 HTTP/1.x 一样，目前受到主流支持的 TLS 协议版本是 1.1 和 1.2，分别发布于 2006年和2008年，也都已经落后于时代的需求了。在2018年8月份，IETF终于宣布TLS 1.3规范正式发布了，标准规范（Standards Track）定义在 rfc8446。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419750\" src=\"http://localhost:8060/tup/2020/4/23/98e28ba68e314c29b0215f5ea2ecb6eb.jpg\" alt=\"\" title=\"\"></span></p> \n<p>TLS 1.3 相较之前版本的优化内容有：</p> \n<ol> \n <li> <strong>握手时间</strong>：同等情况下，TLSv1.3 比 TLSv1.2 少一个 RTT</li> \n <li> <strong>应用数据</strong>：在会话复用场景下，支持 0-RTT 发送应用数据</li> \n <li> <strong>握手消息</strong>：从 ServerHello 之后都是密文。</li> \n <li>会话复用机制：弃用了 Session ID 方式的会话复用，采用 PSK 机制的会话复用。</li> \n <li> <strong>密钥算法</strong>：TLSv1.3 只支持 PFS （即完全前向安全）的密钥交换算法，禁用 RSA 这种密钥交换算法。对称密钥算法只采用 AEAD 类型的加密算法，禁用CBC 模式的 AES、RC4 算法。</li> \n <li> <strong>密钥导出算法</strong>：TLSv1.3 使用新设计的叫做 HKDF 的算法，而 TLSv1.2 是使用PRF算法，稍后我们再来看看这两种算法的差别。</li> \n</ol> \n<p>总结一下就是在更安全的基础上还做到了更快，目前 TLS 1.3 的重要实现是 OpenSSL 1.1.1 开始支持了，并且 1.1.1 还是一个 LTS 版本，未来的 RHEL8、Debian10 &nbsp;都将其作为主要支持版本。在 Nginx 上的实现需要 Nginx &nbsp;1.13+。</p> \n<p><strong>Brotli</strong></p> \n<p>Brotli 是由 Google 于 2015 年 9 月推出的无损压缩算法，它通过用变种的 LZ77 算法，Huffman 编码和二阶文本建模进行数据压缩，是一种压缩比很高的压缩方法。</p> \n<p><strong>根据Google 发布的研究报告，Brotli 具有如下特点：</strong></p> \n<ol> \n <li>针对常见的 Web 资源内容，Brotli 的性能要比 Gzip 好 17-25%；</li> \n <li>Brotli 压缩级别为 1 时，压缩速度是最快的，而且此时压缩率比 gzip 压缩等级为 9（最高）时还要高；</li> \n <li>在处理不同 HTML 文档时，brotli 依然提供了非常高的压缩率；</li> \n</ol> \n<p><strong>在兼容 GZIP 的同时，相较 GZIP：</strong></p> \n<ol> \n <li>JavaScript 上缩小 14%</li> \n <li>HTML上缩小 21%</li> \n <li>CSS上缩小 17%</li> \n</ol> \n<p>Brotli 的支持必须依赖 HTTPS，不过换句话说就是只有在 HTTPS 下才能实现 Brotli。</p> \n<p><strong>ECC 证书</strong></p> \n<p>椭圆曲线密码学（Elliptic curve cryptography，缩写为ECC），一种建立公开金钥加密的算法，基于椭圆曲线数学。椭圆曲线在密码学中的使用是在1985年由Neal Koblitz和Victor Miller分别独立提出的。</p> \n<p>内置 ECDSA 公钥的证书一般被称之为 ECC 证书，内置 RSA 公钥的证书就是 RSA 证书。由于 256 位 ECC Key 在安全性上等同于 3072 位 RSA Key，加上 ECC 运算速度更快，ECDHE 密钥交换 + ECDSA 数字签名无疑是最好的选择。<strong>由于同等安全条件下，ECC 算法所需的 Key 更短，所以 ECC 证书文件体积比 RSA 证书要小一些。</strong></p> \n<p>ECC 证书不仅仅可以用于 HTTPS 场景当中，理论上可以代替所有 RSA 证书的应用场景，如 SSH 密钥登陆、SMTP 的 TLS 发件等。</p> \n<p><strong>不过使用 ECC 证书有两个点需要注意：</strong></p> \n<p>一、 并不是每一个证书类型都支持的，一般商业证书中带增强型字眼的才支持ECC证书的签发。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419752\" src=\"http://localhost:8060/tup/2020/4/23/f7a3f42ecae64966a60df19fd90e6904.jpg\" alt=\"\" title=\"\"></span></p> \n<p>二、 ECC证书在一些场景中可能还不被支持，因为一些产品或者软件可能还不支持 ECC。 这时候就要虚线解决问题了，例如针对部分旧操作系统和浏览器不支持ECC，可以通过ECC+RSA双证书模式来解决问题。</p> \n<p><strong>安装</strong></p> \n<p><strong>下载源码</strong></p> \n<p>综合上述我们要用到的新特性，我们整合一下需求：</p> \n<p>HTTP/2 &nbsp;要求 Nginx 1.9.5+，，OpenSSL 1.0.2+</p> \n<p>TLS 1.3 &nbsp;要求 Nginx 1.13+，OpenSSL 1.1.1+</p> \n<p>Brotli 要求 HTTPS，并在 Nginx 中添加扩展支持</p> \n<p>ECC 双证书 要求 Nginx 1.11+</p> \n<p>这里 Nginx，我个人推荐 1.15+，因为 1.14 虽然已经能支持TLS1.3了，但是一些 TLS1.3 的进阶特性还只在 1.15+ 中提供。</p> \n<p><strong>然后我们定义一下版本号：</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419755\" src=\"http://localhost:8060/tup/2020/4/23/03b0bbcd79824048800506ea1b40c1b3.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>建议去官网随时关注最新版：</strong></p> \n<p><a href=\"http://nginx.org/en/download.html\" rel=\"nofollow noreferrer\">http://nginx.org/en/download....</a></p> \n<p><a href=\"https://www.openssl.org/source/\" rel=\"nofollow noreferrer\">https://www.openssl.org/source/</a></p> \n<p><a href=\"https://github.com/eustas/ngx\" rel=\"nofollow noreferrer\">https://github.com/eustas/ngx</a>_brotli/releases</p> \n<p><strong>Nginx</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419753\" src=\"http://localhost:8060/tup/2020/4/23/2f6b7a5a34ab4d40b8f78f601f1a3d36.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>OpenSSL</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419754\" src=\"http://localhost:8060/tup/2020/4/23/1922081ca6564fe58b08e5be8e6d5633.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>Brotli</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419756\" src=\"http://localhost:8060/tup/2020/4/23/e7a348280bd2442fb68016dd7289f33a.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>编译</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419757\" src=\"http://localhost:8060/tup/2020/4/23/c9276b59d4b94496827480fdb3254e6e.jpg\" alt=\"\" title=\"\"></span></p> \n<p>后续还有相关变量设置和设置服务、开启启动等步骤，篇幅限制就省略了，这篇文章有介绍在 Ubuntu 下的 Nginx 编译：<a href=\"https://www.mf8.biz/ubuntu-nginx/\" rel=\"nofollow noreferrer\">https://www.mf8.biz/ubuntu-ng...</a> 。</p> \n<p><strong>配置</strong></p> \n<p>接下来我们需要修改配置文件。</p> \n<p><strong>HTTP2</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419758\" src=\"http://localhost:8060/tup/2020/4/23/d7c2cc27035c421b839987a258ebd9d6.jpg\" alt=\"\" title=\"\"></span></p> \n<p>只要在 server{} &nbsp;下的lisen 443 ssl 后添加 &nbsp;http2 即可。而且从 1.15 开始，只要写了这一句话就不需要再写 ssl on 了，很多小伙伴可能用了 1.15+ 以后衍用原配置文件会报错，就是因为这一点。</p> \n<p><strong>TLS 1.3</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419759\" src=\"http://localhost:8060/tup/2020/4/23/8d5f4b9a0d0b4dfe843a166d39958ad6.jpg\" alt=\"\" title=\"\"></span></p> \n<p>如果不打算继续支持 IE8，或者一些合规的要求，可以去掉TLSv1。</p> \n<p>然后我们再修改对应的加密算法，加入TLS1.3引入的新算法：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419760\" src=\"http://localhost:8060/tup/2020/4/23/221208b8849e46b382e3c99765f58672.jpg\" alt=\"\" title=\"\"></span></p> \n<p>如果不打算继续支持 IE8，可以去掉包含 3DES 的 Cipher Suite。</p> \n<p>默认情况下 Nginx 因为安全原因，没有开启 TLS 1.3 0-RTT，可以通过添加 ssl_early_data on; 指令开启 0-RTT的支持。</p> \n<p>————</p> \n<p><strong>实验性尝试</strong></p> \n<p>众所周知，TLS1.3 由于更新了很久，很多浏览器的旧版本依旧只支持 Draft 版本，如 23 26 28 分别在 Chrome、FirFox 上有支持，反而正式版由于草案出来很久，导致TLS1.3在浏览器上兼容性不少太好。</p> \n<p>可以使用 <a href=\"https://github.com/hakasenyang/openssl-patch/\" rel=\"nofollow noreferrer\">https://github.com/hakasenyan...</a> 提供的 OpenSSL Patch 让 OpenSSL 1.1.1 同时支持草案23,26,28和正式版输出。 不过由于不是官方脚本，稳定性和安全性有待考量。</p> \n<p><strong>ECC双证书</strong></p> \n<p>双证书配置的很简单了，保证域名的证书有RSA和ECC各一份即可。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419761\" src=\"http://localhost:8060/tup/2020/4/23/ffe6bc26e6ed4faea4e3357a39910078.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>Brotli</strong></p> \n<p>需要在对应配置文件中，添加下面代码即可：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419762\" src=\"http://localhost:8060/tup/2020/4/23/447f0b540db645ae8493a8b0d26d84a7.jpg\" alt=\"\" title=\"\"></span></p> \n<p>为了防止大家看糊涂了，放一个完整的 server{}供大家参考：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419763\" src=\"http://localhost:8060/tup/2020/4/23/36162d94c5be4e44b0fc2f2a9eed0de2.jpg\" alt=\"\" title=\"\"></span></p> \n<p>先验证一下配置文件是否有误：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419764\" src=\"http://localhost:8060/tup/2020/4/23/b27fb5528b0646d2aaa878c119b8403d.jpg\" alt=\"\" title=\"\"></span></p> \n<p>如果反馈的是：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419765\" src=\"http://localhost:8060/tup/2020/4/23/dd8e289441674d91bb00fd556b061c96.jpg\" alt=\"\" title=\"\"></span></p> \n<p>就可以重启 Nginx ，然后到对应网站中去查看效果了。</p> \n<p><strong>验证</strong></p> \n<p><strong>HTTP/2</strong></p> \n<p>通过浏览器的开发者工具，我们可以在 Network 栏目中看到 Protocol 中显示 h2 有无来判断。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419766\" src=\"http://localhost:8060/tup/2020/4/23/bcde67a2c10a497faa9f0514d8789d02.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>TLS 1.3</strong></p> \n<p>老地方，我们可以通过浏览器的开发者工具 中的 Security 栏目看到 Connection 栏目下是否有显示 TLS 1.3</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419768\" src=\"http://localhost:8060/tup/2020/4/23/49142bf966b1452680d755f51890c38c.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>ECC 双证书</strong></p> \n<p>ECC 双证书配置了以后无非就是在旧浏览器设别上的验证了。这里用足够老的上古XP虚拟机来给大家证明一波。</p> \n<p>XP系统上：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419767\" src=\"http://localhost:8060/tup/2020/4/23/314950c278b64e118018e64e826fb9ce.jpg\" alt=\"\" title=\"\"></span></p> \n<p>现代操作系统上的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419769\" src=\"http://localhost:8060/tup/2020/4/23/c6a4593c18bd482aac0069abb9ca625c.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>Brotli</strong></p> \n<p>通过浏览器的开发者工具，我们可以在 Network 栏目中，打开具体页面的头信息，看到 accept-encoding 中有 br 字眼就行。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022419770\" src=\"http://localhost:8060/tup/2020/4/23/b79d4428653842ed92c173687e5c1714.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>总结</strong></p> \n<p>通过上述手段应该可以让 HTTPS 访问的体验优化不少，而且会比没做 HTTPS 的网站访问可能更快。</p> \n<p>这样的模式比较适合云服务器单机或者简单集群上搭建，如果有应用 SLB 七层代理、WAF、CDN 这样的产品可能会让我们的这些操作都白费。 我们的这几项操作都是自建的 Web 七层服务，如果有设置 SLB 七层代理、WAF、CDN 这样设置在云服务器之前就会被覆盖掉。</p> \n<p>由于 SLB 七层和CDN这样的产品会更加追求广泛的兼容性和稳定性并不会第一时间就用上上述的这些新特性（HTTP/2 是普遍有的），但是他们都配备了阿里云的 Tengine 的外部专用算法加速硬件如 Intel® QuickAssist Technology(QAT) 加速器可以显著提高SSL/TLS握手阶段性能。 所有 HTTPS 的加密解密都在 SLB 或 CDN 上完成，而不会落到ECS上，可以显著降低 ECS 的负载压力，并且提升访问体验。</p> \n<p>目前云上的网络产品中能支持四层的都是可以继续兼容我们这套设计的，例如：SLB 的四层转发（TCP UDP）、DDOS高防的四层转发。</p>', null, 'http://localhost:8060/tup/2020/4/23/e14e5b12d01c4789adf61a626145d6f9.jpg', '1894b118d35d44cb8fe8009529c4154b', '91832bd0c3a244fb88c0bca74c0d404d', 'bad2e32fdd944a439f9b2d3890ef749c,d7416e100af54eb7a4d9274b9a462240,753b5aee3913424e81fe2b5299626d8c,55723db96b9f4593bae02bc1e49f1e87,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-23 11:01:07', '2020-04-23 11:01:07');
INSERT INTO `tb_recommend` VALUES ('665899b592c447198f4e359fab42f4ec', '今天晒：9 年前我述职的工作总结', '9 年前，我刚入行，从 9 月份开始工作到 过完年，刚好有半年，完成了职场新人礼。那时候汇报自己的工作，我所在的团队还不流行做 PPT，通常是邮件或者是当面聊，我选用邮件做了如下的半年总结：', '<blockquote>\n 著作权归作者所有。商业转载请联系 Scott 获得授权，非商业转载请注明出处[务必保留全文，勿做删减]。\n</blockquote> \n<blockquote>\n 所谓成长，就是不断认为昨天自己是 SB 的过程。\n</blockquote> \n<p><br>9 年前，我刚入行，从 9 月份开始工作到 过完年，刚好有半年，完成了职场新人礼。<br>那时候汇报自己的工作，我所在的团队还不流行做 PPT，通常是邮件或者是当面聊，我选用邮件做了如下的半年总结：<br></p> \n<p><a></a></p> \n<h4>一、钻石展位：日常功能维护与 2.0 新功能迁移</h4> \n<p><br>1、计划消耗；<br>2、bannermaker 接入；<br>3、账户诊断；<br>4、群体投放；<br>5、定价投放；<br></p> \n<p><a></a></p> \n<h4>二、明星店铺：主站搜索与店铺搜索</h4> \n<p><br>1、第一期改版上线主搜；<br>2、第二期改版上线主搜与店铺搜；<br></p> \n<p><a></a></p> \n<h4>三、MiniSite：</h4> \n<p><br>1、万塘书院从 minisite 中独立出来，成为子站点；<br>2、超级麦霸，钻石展位，第三方服务平台；<br></p> \n<p><a></a></p> \n<h4>四、TMS：淘宝联盟、E淘、促销活动，频道页面制作；</h4> \n<p><a></a></p> \n<h4>五、BP 后台：后台邮件，站内信兼容版本开发；</h4> \n<p><a></a></p> \n<h4>六、直通车论坛：论坛帖子，活动页面制作；</h4> \n<p><a></a></p> \n<h4>七、Sinba 后台：拖曳模块，树形结构，以及整站改版；</h4> \n<p><a></a></p> \n<h4>八、外投广告牌：对北京外投广告牌的支持，多尺寸广告牌的制作修改（针对yahoo，优酷，搜狐等主要门户网站），特殊版本（</h4> \n<p>凤凰网，新浪网投放要求）的开发；<br><a></a></p> \n<h4>九、无线商搜的手机页面制作；</h4> \n<p><a></a></p> \n<p><a></a></p> \n<h4>团队建设方面：</h4> \n<p><br>公司的团队生活与建设方面：带领球队共16 位队友，进行了 25 场次的训练与比赛，包括杭州师范学院，杭网俱乐部，杭州尤文图斯，淘宝球队，淘宝商城球队等进行过多次的联谊球赛；<br><a></a></p> \n<p><a></a></p> \n<h5>半年出现的问题：</h5> \n<p><br>一、项目进度的把握程度：作为前端UED，对项目的把控能力还不够强势；<br>二、与多部门协调的能力：协调力度不够，成熟度欠缺；<br>三、对产品诞生过程中的影响力：影响力范围及力度不够；<br>四、技术层面的成熟度（既定时长内，需求价值，应用场景，开发周长，技术实现，维护性与扩展性，以及上线反响所综合考虑的最优折衷度）：特殊场景下的需求PK与处理娴熟度不够；<br></p> \n<blockquote>\n 今天的自己看那个时候的总结，显然是稚嫩的不值一提，毕竟是用今天的标准裁定。\n</blockquote> \n<p><br>述职做汇报，本质是在做三件事情：<br></p> \n<ol> \n <li>让衡量你绩效的人（通常是主管，也可能跨级老板和 HR 参与），对你的工作付出和工作价值有一个更清晰的看见，与他脑子里的做对照，补全残缺和偏移。</li> \n <li>在做的所有事情里面，以各种数字案例佐证自己综合能力有成长，尤其是逻辑能力，也就是自己的总结归纳所反映出来的结构化梳理、体系化思考和直击内心的表达能力</li> \n <li>透过工作内容和自己的沉淀总结，以及自己的成长诉求，让老板更有弹性的来因应你的诉求，结合你的兴趣和特长，重新定位你在团队中的位置以及潜在的位置，在适当的时候将你放到更能让你历练和成长的一个场景下。</li> \n</ol> \n<p>述职总结很重要，是因为第一点影响到你的绩效裁定，是关于过去的你，第二点是影响你的能力衡定，是关于当下的你，第三点是影响你的潜力发掘，是关于将来的你，而最重要的是现在的你，尤其是将来的你，所以述职的重点不在于过去，而在于当下和未来，无论绩效结果如何，我们坦然接受，然后立足当下和聚焦未来。<br><br>但是如果遇到的老板是不靠谱的，也是灾难，可是如何知道老板是不靠谱的，或者如何知道自己认为老板是全不靠谱不公正的这个观点本身是不成立的呢，我们下次再聊，在车上手机码字好累..<br><br><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2020/png/87555/1579310196778-f6a4d391-17ef-4d9d-b7c6-b6515b966061.png#align=left&amp;display=inline&amp;height=810&amp;name=image.png&amp;originHeight=810&amp;originWidth=1080&amp;size=1582418&amp;status=done&amp;style=none&amp;width=1080\" src=\"http://localhost:8060/tup/2020/4/23/9c7b69b4133f4d4b906582a6539f4778.jpg\" alt=\"image.png\" title=\"image.png\"></span><br></p> \n<blockquote>\n 上次去深圳，发现地铁有商务座，真是活久见...\n</blockquote> \n<blockquote>\n Scott 近两年无论是面试还是线下线上的技术分享，遇到许许多多前端同学，由于团队原因，个人原因，职业成长，技术方向，甚至家庭等等原因，在理想国与现实之间，在放弃与坚守之间，摇摆不停，心酸硬扛，大家可以找我聊聊南聊聊北，对工程师的宿命有更多的了解，有更多的看见与听见，Scott 微信： codingdream，也可以来\n <a href=\"https://www.yuque.com/iscott\" rel=\"nofollow noreferrer\">关注 Scott 语雀跟进最新动态</a>，本文未经许可不许转载，获得许可请联系 Scott，否则在公众号上直接转载，尤其是裁剪内容后转载，我都会直接进行投诉处理。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882754189-781488ce-b345-45cf-a3b7-cb5309e9caa6.png#align=left&amp;display=inline&amp;height=399&amp;name=2.png&amp;originHeight=600&amp;originWidth=600&amp;size=158647&amp;status=done&amp;style=none&amp;width=399\" src=\"http://localhost:8060/tup/2020/4/23/610f33692faf4382b79d7d327ff313cb.jpg\" alt=\"2.png\" title=\"2.png\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882773713-309efa88-e1fc-481f-865b-3c0cb0d3ec43.png#align=left&amp;display=inline&amp;height=398&amp;name=1.png&amp;originHeight=600&amp;originWidth=600&amp;size=134434&amp;status=done&amp;style=none&amp;width=398\" src=\"http://localhost:8060/tup/2020/4/23/4aa143f5365e44ad9ef377c087703929.jpg\" alt=\"1.png\" title=\"1.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/60ee1b591a9d485d855e98aab32b0be8.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '049b3bd76c1e49ccbe48b36197e77f76', 'ab4f466a6a72457aaa22b3d483e4a681,363e175974654a1da390fd600fdecbc5,63c4e1e7ec204b43a62065a3ced4c2ce', '0', '3', '1', '2020-04-23 10:26:06', '2020-04-23 10:26:06');
INSERT INTO `tb_recommend` VALUES ('69db26b386f2412eadc6b57f5cca07a9', '《Flappy Bird》开发者：游戏爆红之后，觉得“这个世界突然疯了”...', '从默默无闻到一夜爆红，《Flappy BIrd》在当年创造手机游戏的一个奇迹，iOS 免费游戏下载榜单第一名、2014年\"美国及中国 iTunes 最受欢迎免费应用软件\"、被Cnet 评为“21世纪初全球最具影响力的 25 个 App 之一”。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbALB3\" src=\"http://localhost:8060/tup/2020/4/23/be9f4772f6dd42d5a52c6d6cb616acdd.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>从默默无闻到一夜爆红，《Flappy BIrd》在当年创造手机游戏的一个奇迹，iOS 免费游戏下载榜单第一名、2014年\"美国及中国 iTunes 最受欢迎免费应用软件\"、被Cnet 评为“21世纪初全球最具影响力的 25 个 App 之一”。</p> \n<p>但就在爆火几天之后，开发者阮河东撂下一句：<strong>“他摧毁了我的生活，我恨他”。</strong>然后把游戏永久下架。</p> \n<p>这在我们看来不可思议，为他带来巨额收益和名气的作品，说放下就放下，这其中肯定有很多只有他自己才知道的隐情和感受。</p> \n<p>就在前不久，阮河东出现在母校越南河内理工大学，分享了他当时和现在的心路历程。</p> \n<h2>Flappy Bird 一战封神</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbALCa\" src=\"http://localhost:8060/tup/2020/4/23/33fe8143b556427da57fca594dc8b613.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>阮河东在一个名为万福的越南小村庄长大，在《Flappy Bird》爆火之前，只是一个普普通通的、和父母一起居住的、看起来安静甚至有些腼腆的年轻人。他从没想过自己有朝一日会成为一个世界知名的游戏开发者。</p> \n<p><strong>16 岁那年，阮河东通过自学在电脑上编写了自己的第一个程序 —— 一个国际象棋游戏。</strong>这也燃起了他对编程开发的兴趣与信心。在报考大学时选择了河内的一所大学学习计算机专业，并加入了河内唯一的一家游戏公司实习。</p> \n<p>阮河东表示，在《Flappy Bird》之前，他本来打算成为一名工程师，但后来决定改变自己的职业，为移动设备做手游。</p> \n<p>在 2013 年的时候，App Store 里最热门的游戏的《糖果传奇》和《愤怒的小鸟》等作品，<strong>但这些游戏大部分都是为了满足玩家「长期服务式娱乐」的需求，具有丰富的玩法和内容，但阮河东想做的是一款「一分钟就能结束的游戏」。</strong></p> \n<p>做这个决定的另一个原因是，当时他并没有足够的决心完成一款游戏，除正常的工作外，他一没有太多的业余时间，二没有自己的团队，三是也没有什么预算。为了完成这个游戏，他必须把项目限制的尽可能小，功能尽可能的简单，才有可能完成。</p> \n<p>于是他就给自己想做的游戏设定了一个核心法则：<strong>他希望游戏是可爱的，要足以吸引年轻人，而且要让没有多少时间玩的人们易于上手。</strong></p> \n<p>做完决定之后，他用了 2 至 3 天开发《Flappy Bird》，结果我们大家都知道，他和他的鸟，一战成名。</p> \n<p>游戏一经推出，很快就登上了 iOS 免费游戏下载榜单的第一名，并在 2014 年初被评为“美国及中国 iTunes 最受欢迎免费应用软件”。</p> \n<p>在 2014 年 2 月，《Flappy Bird》玩家游戏次数超过 200 亿次，在 App Store 和 Google Play 单月下载了破 9000 万次。当时最高单日广告收入 5 万美元。</p> \n<p>这个结果让阮河东很意外，《Flappy Bird》完全是他一个人用业余时间开发制作，并且就这样的一个像素级作品，竟然能够登顶全球下载榜。</p> \n<h2>“他摧毁了我的生活，我恨他”</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbALCf\" src=\"http://localhost:8060/tup/2020/4/23/be67b9916c814a4eaccf5d8c99349ac8.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>在游戏爆火之后，除了名声与收入，也给他带来了很多的麻烦以及社会压力：</p> \n<p>《赫芬顿邮报》指出这款游戏是一个“疯狂地恼人、困难和令人沮丧的游戏”，且“结合了超陡峭的难度曲线、差劣无聊的画质和生硬的动作”。</p> \n<p>这款游戏的难度也导致不少玩家感到愤怒，其中一位玩家更指出他自己用了半小时才能获得 5 分...</p> \n<p>还有人指责他在 App Store 排名作弊，而且抄袭了《马里奥》游戏...</p> \n<p>但最让阮河东担忧的是，是他在社交网站上收到的几条评论信息：</p> \n<p>一个妈妈声称阮河东的游戏「让孩子沉迷」，另一个人则感叹：“在我的学校里已经有13个孩子因为你的游戏而摔了他们的手机，他们简直对这上了瘾。”</p> \n<p>阮河东在采访中还提及到，有人因为玩这个游戏而丢了工作，有的孩子沉迷于游戏不再愿意和母亲交流。</p> \n<p><strong>“一开始我以为他们只是在开玩笑，直到我发现他们真的伤害到了自己。”</strong>阮河东这才了解到这件事情的严重性。</p> \n<p>为了知道这个爆款游戏和开发者的最新动态，当地的狗仔队围在他家门口，严重影响了他和家人的生活。“我无法入睡。（我感觉）生活不像以前那样轻松舒适了。”</p> \n<p><strong>那时他才 28 岁，只有一个想法就是“这个世界突然疯了。”</strong></p> \n<p>虽然比起从游戏中得到的收入，这样的代价似乎很小，但阮河东依然觉得媒体的关注让他感到窒息。心理和生理上的嘈杂烦恼，让他只想要平静的一个人待一会儿。</p> \n<p>“设计 Flapp Bird 的初衷是希望人们能在放松的时候玩上几分钟。但不巧的是，它现在成为了一款让人上瘾的产品。我觉得，这已经成为了一个问题了。为了解决这个问题，最好的办法就是让 Flappy Bird 下架。现在它永远不会再回来了。”</p> \n<p>2014 年 2 月 8 日，阮河东在 twitter 上发了一篇推文，公布他将把游戏永久下架。</p> \n<p>多年之后，阮河东回忆到：<strong>“虽然在《Flappy Bird》成功之后根本没时间享受其中的喜悦，但对于该游戏登顶 App Store ，还是感到过自豪。”</strong></p> \n<h2>消失五年，归来恰似少年</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbALCr\" src=\"http://localhost:8060/tup/2020/4/23/2d23a503bc594895b2e6fa44c493dc43.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>五年后，开发者阮河东出现在母校越南河内理工大学，分享当时和现在的心路历程。</p> \n<p>在分享会中，有现场的学生问他是否后悔把游戏下架，从而失去巨额的收入来源？</p> \n<p>但阮河东没有直接回答这个问题，而是说了下他目前理解的「收入和工作」的关系。</p> \n<blockquote>\n “在美国，人们用一百万美元衡量一个人，有了一百万美元就意味着这个人不用工作了 ——\n <br>我曾经以为我有了一百万美元就会退休……后来我很多次达成了这个目标，但是我仍然无法退休。\n <p>各人有各人的选择……<strong>我当年（成功）的代价就是自己的成长。但不要牺牲自己的成长来换取短期的成功。</strong>”</p> \n</blockquote> \n<p>不过现在的他，看到的更多的是事情积极的一面。</p> \n<p>Flappy Bird 的成功让他变得很有信心，「我可以自由地去做任何我想做的事情。」</p> \n<p>除了 Flappy Bird，阮河东还开发了 Super Ball Juggling 和 Shuriken Block 两款游戏，目前它们在 App Store 分别排名第 6 和第 8。</p> \n<p>阮河东说，如果这两款游戏如果能够和《Flappy Bird》一样让人沉迷，那么这次他将毫不犹豫的将他们下架。</p> \n<p>这大概就是属于一个技术至上者的理想主义，引用一句话：</p> \n<blockquote>\n 无论是深重的痛苦还是巨大的利益，无论是恶意的攻击抑或盲目的追捧，他都只信奉技术为真理，他依仗技术，因技术而骄傲，为守护心中的技术梦想而自豪。\n</blockquote> \n<h2>后话：开发者的技术理想</h2> \n<p>作为开发者，作为一名互联网社会的「搭建者」，我们的初心一定是想通过技术实现我们的价值，通过技术去做一些可以影响世界或者让社会变得更好的事情。</p> \n<p>这可能就是根植于纯粹技术人心中，纯粹的技术理想吧。</p> \n<p>Respect。</p> \n<blockquote>\n 太阳下山明早依旧爬上来\n <br>花儿谢了明天还是一样的开\n <br>我的青春一去无影踪\n <br>我的青春小鸟一去不回来\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbAuMz\" src=\"http://localhost:8060/tup/2020/4/23/c9349381914a4cd0a8c74a9f200c62b6.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/f8ae1fd7f69a488385399bf0cf46e0c0.jpg', '692c6787030d4b8882077b2ab9279c52', '1a7cc9fbc4654cb0afec84e080816ef1', '66d1b6953b664c409cf7283cdb6c6566,a4f4fd7a73b84a7298db0174165eeaac,9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-23 10:57:24', '2020-04-23 10:57:24');
INSERT INTO `tb_recommend` VALUES ('6c0c14fa337b426e83bfae866ac2229e', '想进美团不知道选哪个技术岗位？这里有一份通关秘籍！', '随着互联网的高速发展，技术岗位在不断地细分，比如软件开发不仅分为前端和后端，前端会分为Web、iOS和Android三个方向，后端又分为后台、系统、数据等。现在异常火爆的AI方向更是让人「眼花缭乱」，深度学习、数...', '<p>春暖花开，美团春招已经启动，针对校招和社招开放了几千个职位，其中很大部分都是技术岗位。</p> \n<p>随着互联网的高速发展，技术岗位在不断地细分，比如软件开发不仅分为前端和后端，前端会分为Web、iOS和Android三个方向，后端又分为后台、系统、数据等。现在异常火爆的AI方向更是让人「眼花缭乱」，深度学习、数据挖掘、NLP、人脸识别、知识图谱等等。那么，我们应该如何更好地选择适合自己的技术岗位呢？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159819\" src=\"http://localhost:8060/tup/2020/4/23/032ad1dc1e3d4c0d80ccf6e335feeeaf.jpg\" alt=\"\" title=\"\"></span></p> \n<p>今天我们就逐一介绍各个技术岗位的区别以及对应的岗位要求，然后再解读一下美团面试官会考核的基本能力和软素质，最后我们还附上了来自美团学长学姐的建议，希望这份「通关秘籍」能帮助大家对号入座，找到自己理想的工作。</p> \n<h2>一、美团技术团队分哪些专业方向？</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159822\" src=\"http://localhost:8060/tup/2020/4/23/c2dd1182951d42a7afc99e02e7a5da4a.jpg\" alt=\"\" title=\"\"></span></p> \n<p>经过多年耕耘和沉淀，美团技术团队已经建成了比较完备的技术体系，有基于主流开源技术加自研的大数据、基础架构、复杂业务系统平台，以及比较完备的运维、安全、风控系统。目前，美团技术团队主要分成前端、后台、系统、数据、测试、运维、算法等技术方向（内部称为通道），每个方向下面又可能包括几种岗位。</p> \n<p>特别要提醒大家注意的是，各个方向和岗位的竞争激烈程度每年是不一样的。今年的推荐算法和嵌入式系统、计算机视觉竞争比较激烈，而前端尤其是移动客户端开发、测试、硬件、安全、数据领域则相对平和。以下是2020年春季美团技术团队部分岗位（实习生）的投递录用比（已经收到的简历数：拟招聘的岗位数），供大家参考：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159821\" src=\"http://localhost:8060/tup/2020/4/23/8e158264683d44008a2dfab97ee326d5.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>前端开发工程师</h3> \n<p>前端也称为大前端，分为Web前端和终端两大方向。作为连接用户和企业的技术工种，前端涉及的领域越来越广泛，已经不再局限于桌面、手机等环境。在目前大前端融合、5G的趋势下，想象空间越来越大，给前端工程师带来广阔的成长发展前景。</p> \n<p><strong>选择前端的7大理由：</strong></p> \n<ul> \n <li>前端是最接近用户的技术团队，能够第一时间了解用户的需求，是那些对用户体验、交互感兴趣的同学的最佳选择。</li> \n <li>前端是最容易成为全栈工程师及技术「多面手」的岗位。前端能快速实现原型、快速给用户推出新产品或者新的用户体验，很容易获得职业层面的成就感。</li> \n <li>前端技术发展迅速，这里特别欢迎有创造力、有想法的同学，技术栈广，有众多的岗位选择和发展空间。</li> \n <li>前端是美团技术团队中交流最广泛、交流渠道最多、交流氛围最好的团队，在这里你能够认识足够多的技术大牛，也提供足够大的舞台让有想法的同学去展现自己的风采。</li> \n <li>相比有些学习曲线比较陡峭的技术岗位，前端的学习成长曲线相对平滑。因为绝大多数高校都不开设前端开发的相关课程，而且前端技术还在不断发展和更迭，前端开发领域对所有的新入门同学都比较友好，这是一片蓝海，等待有梦想的你去不断开拓。</li> \n <li>前端是代码和视觉的结合，是技术和艺术的交融，前端能带给用户最简单直接、最炫酷的视觉享受和用户体验。</li> \n <li>前端开发是目前互联网领域最炙手可热的技术方向之一，各个公司都高薪争夺前端领域的技术人才，未来可期。</li> \n</ul> \n<p><strong>Web前端</strong></p> \n<blockquote>\n 对应岗位名称：前端开发，Web前端开发。\n</blockquote> \n<p><strong>美团对前端工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ol> \n <li> <strong>专业背景</strong>：专业技能主要覆盖计算机专业的基础课程，包括数据结构、计算机组成原理、计算机网络、操作系统、数据库、软件工程、C++或Java编程语言等。此外，现在前端对算法的要求越来越高，在算法方面理解深刻的同学，会有加分。</li> \n <li> <strong>专业知识</strong>：扎实的6项基础知识：HTML、CSS、JavaScript、移动Web开发、调试、HTTP网络知识。</li> \n <li> <strong>技术能力</strong>：前端工程能力，构建和持续集成。特别是Coding能力，能够准确地理解需求，并快速实现高质量的代码。</li> \n <li> <strong>加分项</strong>：掌握Web安全基础知识、浏览器组成及原理方面的基础知识，熟练使用常用的前端框架（React/Vue等）并对其原理有一定的认识。</li> \n</ol> \n<p><strong>终端</strong></p> \n<blockquote>\n 对应岗位名称：iOS开发，Android开发，移动端开发，客户端开发。\n</blockquote> \n<p>目前，终端也称移动端、客户端，主要按两大平台分为Android开发和iOS开发。这个方向的优点是对同学们的经验要求较少，只要有较好的编程基础和比较扎实的计算机基础知识，都欢迎加入。</p> \n<p><strong>Android开发工程师</strong></p> \n<p>在过去十年中，Android已经成为和iOS并驾齐驱的移动开放平台。未来十年，Android必将在万物互联的生态中占据更加重要的位置，未来可期。虽然「移动端」的概念被提及的次数越来减少，但目前手机的应用市场中每天仍有几百万量级的App在活跃，而这都需要移动端工程师去开发完成。</p> \n<p>此外，App是企业和用户交互的桥梁，直接影响用户体验以及用户对公司品牌的感受，其重要性不言而喻。在美团Android开发团队，你写的代码可以影响到数亿用户，你可以把一个个创新的想法，在亲人和朋友的手机上变成实实在在、可以看得见摸得着的界面，相信这一定会让你收获满满的成就感。</p> \n<p><strong>美团对Android工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ol> \n <li> <strong>专业背景</strong>：了解计算机基础知识，包括计算机原理、操作系统、网络、算法等；</li> \n <li> <strong>技术知识</strong>：重点强调Java，其次是C/C++和数据结构，这些是最基本的要求，然后是Android开发的基础知识；</li> \n <li> <strong>编码能力</strong>：具备一定的编码能力，包括边界条件、编码风格等。</li> \n</ol> \n<p><strong>iOS开发工程师</strong></p> \n<p>如果你希望自己的工作成果被亿万人直接使用，那么就来做客户端吧！如果你觉得iPhone真香，那么就来做iOS开发工程师吧！在这里，你可以感受技术与体验的完美结合，在成就用户的同时成就自己。在美团，iOS工程师有着明确的培养路径，美团技术学院提供了丰富的技术文档和课程来帮助大家成长。值得一提的是，校招候选人不要求有iOS开发经验，只要具备良好的CS基础便可以。加入美团，我们会帮你快速成长为一名优秀的iOS工程师。</p> \n<p>在美团技术团队，iOS工程师主要责任就是打造美团和大众点评等超级App，为它「添砖加瓦」。我们追求更高的代码质量，让Bug远离用户；我们追求更高的编程效率，可以让新功能更快地交付给用户。当然，在做完业务需求之余，你可以投身研究一些OC语言的特性、App的性能优化、Hybrid技术等等。你也可以探索一些工程层面的奥义，比如组件化、平台化、插件化、动态化、自动化，任君遨游。</p> \n<p>目前，大家纷纷涌向人工智能、机器学习、图像识别等比较热门的技术领域，千军万马挤独木桥，其难度可想而知。殊不知iOS领域因近些年人才过度稀缺，市场发展前景非常好。更重要的是，当你成为一名iOS工程师以后，你将常年接触iOS与Mac系统，杜绝工作环境中的脏、乱、差，体验优雅、高效、丝滑的开发流程，这也将直接影响到你的生活习惯，让你变成一个有追求、有审美、有品位的「攻城狮」。</p> \n<p><strong>美团对iOS工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ol> \n <li> <strong>专业背景</strong>：了解计算机基础知识，包括计算机原理、操作系统、网络等，这是客户端开发的通用技能；</li> \n <li> <strong>技术能力</strong>：基本数据结构与算法，Coding能力；</li> \n <li> <strong>加分项</strong>：对OC语言特性能够熟练掌握，了解跨端技术，有一定的技术广度。</li> \n</ol> \n<p>技术细节请参考美团前端方向的技术文章：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html\" rel=\"nofollow noreferrer\">Flutter的原理及美团的实践</a></li> \n <li><a href=\"https://tech.meituan.com/2019/12/19/meituan-mrn-practice.html\" rel=\"nofollow noreferrer\">React Native在美团外卖客户端的实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/11/01/swift-compile-performance-optimization.html\" rel=\"nofollow noreferrer\">深入剖析Swift性能优化</a></li> \n <li><a href=\"https://tech.meituan.com/2018/03/16/front-end-web-architecture.html\" rel=\"nofollow noreferrer\">美团点评金融平台Web前端技术体系</a></li> \n <li><a href=\"https://tech.meituan.com/2019/10/17/android-java-8.html\" rel=\"nofollow noreferrer\">Android 兼容 Java 8 语法特性的原理分析</a></li> \n</ul> \n<h3>后台/系统开发工程师</h3> \n<blockquote>\n 对应岗位名称：Java开发，后端开发，系统开发，服务端开发。\n</blockquote> \n<p>后端在美团又分为后台和系统两个方向。这是最体现以互联网技术改造实体经济的方向。</p> \n<p>后台方向总体偏to C（消费者）的产品系统及其依赖的基础平台的研发，包括但不限于：Web API、商品/库存/价格系统、交易系统、促销引擎、支付系统、评价系统、存储系统、消息队列、OCTO、计算平台、检索架构等等。比如我们每一次点外卖时的交易履约都是由后台系统来提供服务的。</p> \n<p>后台方向承担了美团基础架构以及各条业务线工程系统的建设，为美团的业务提供了云端保障，包括功能开发、平台建设、基础架构升级等工作，在巨大流量下，为用户提供高性能、高扩展、高并发、高可用、高效率的服务，支撑美团各业务提升运营效率、决策效率，提供良好的用户和商家体验。后台通道也是美团内部最大的一个技术通道。</p> \n<p>系统方向偏商户端和公司内部的核心系统的研发，通过技术手段不断提升供给侧效率，降低成本，提升用户体验，促进业务目标达成。随着业务在不断发展变化，美团的新业务在不断涌现，系统方向面临着更复杂、更新鲜的业务场景，也有更多的业务挑战等待着你来解决。</p> \n<p>加入美团系统通道，你能够接触线上线下复杂业务，并通过技术手段为业务赋能，进而快速成长为一名懂业务的技术专家。对业务的深刻理解和实践经验会让你身价翻倍，在未来长期的职业发展上有更多选择。美团系统通道牛人多，学习机会多，个人成长快，可以帮你全方位进行提升。值得一提的是，系统通道的成长路径后半段是比较广阔的，离业务更近，能更好地理解公司的商业模式。对于那些有野心的、未来想去创业的同学来说，系统通道是比较合适的方向。</p> \n<p><strong>选择后台方向的5大理由：</strong></p> \n<ul> \n <li>互联网已经从「黄金时代」走到「青铜时代」，精细化运营对面向用户的后台业务系统提出更高的要求，业务场景复杂多变，后台/系统开发工程师面临更大的挑战，且招聘需求量也非常大。</li> \n <li>后台/系统是支持业务最核心的一环，技术体系广且深，对特别优秀的候选人来说，未来可以选择做业务，也可以选择做技术。发展空间几乎没有上限，只要你足够努力。</li> \n <li>在美团后台/系统通道，行业大牛众多，直接解决复杂业务系统架构设计，面向全社会的用户和商家，可以参与最前沿技术的研究与实践。</li> \n <li>美团后台/系统通道采用导师制，一对一培养。能帮助候选人提升分布式架构设计能力，在丰富的一线实践中，快速成长为优秀的互联网后台开发者。</li> \n <li>喜欢逻辑实现，喜欢高并发、高可用、高性能业务场景技术挑战同学比较适合选择后台/系统通道。</li> \n</ul> \n<p>这里是亿级用户规模的平台，这里有持续快速增长的业务，而后台/系统工程师能够负责驱动并引领业务的发展，这就是我们的价值。期待优秀的你加入我们！</p> \n<p><strong>美团对系统/后台开发工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ul> \n <li>计算机基础扎实，熟悉计算机相关的知识包括数据结构、算法、操作系统、计算机网络、面向对象编程、设计模式、多线程等等。</li> \n <li>Coding能力，掌握至少一门开发语言（Java/C++等）。</li> \n <li>了解常见的后台/系统开发技术，最好阅读过一些项目的源码。</li> \n</ul> \n<p>技术细节请参考美团后台/系统方向的技术文章：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html\" rel=\"nofollow noreferrer\">字节码增强技术探索</a></li> \n <li><a href=\"https://tech.meituan.com/2018/11/15/java-lock.html\" rel=\"nofollow noreferrer\">不可不说的Java“锁”事</a></li> \n <li><a href=\"https://tech.meituan.com/2017/12/22/ddd-in-practice.html\" rel=\"nofollow noreferrer\">领域驱动设计在互联网业务开发中的实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/11/15/docker-architecture-and-evolution-practice.html\" rel=\"nofollow noreferrer\">美团容器平台架构及容器技术实践</a></li> \n <li><a href=\"https://tech.meituan.com/2016/02/04/high-availability-systems-dianping.html\" rel=\"nofollow noreferrer\">高可用性系统在大众点评的实践与经验</a></li> \n</ul> \n<h3>数据开发工程师</h3> \n<blockquote>\n 对应岗位名称：数据开发，数据仓库工程师，大数据工程师。\n</blockquote> \n<p>小数字成就小人生，大数据创造大未来。数据是DT时代的「石油」已经成为业内共识。数据技术是企业业务发展的根基，小到一个功能模块的设计优化、产品精细化运营、用户精准化营销，中到C端千人千面的产品体验、B端数字化赋能，大到公司战略定制和决策、创新业务人工智能的突破，数据的应用已经是面面俱到。而且大数据已经成为各个公司的基础设施，伴随着AI技术浪潮的到来，大数据也会变得越发重要。</p> \n<p>数据通道主要涵盖两大技术方向，一个是数据研发方向，涵盖面向数据资产的数据清洗、加工、整合、挖掘、管理、运营等技术领域，主要包括批处理和实时数据仓库的建设、数据管理、数据价值落地的同学，以及做数据运营的同学。另一个是数据系统研发方向，涵盖批处理、实时数仓开发工具链、BI系统、数据管理系统等数据系统研发同学。数据开发通道希望通过数仓建设、数据系统建设，来提升公司数据质量、数据效率、数据安全，以数据驱动的方式帮助美团完成业务目标，持续提高公司的运营效率和核心竞争力。</p> \n<p>美团数据通道负责上游系统数据的集成、建模、应用数据和系统的研发，支持和赋能业务、商分和产研等部门在业务运营、管理、策略迭代方面的决策。数据不是单纯的数字，我们已经通过对数据进行集成、处理、分析和管理，逐步将数据打造成为美团最为重要的资产。此外，数据通道还为美团提供基于大数据体系的基础数据平台、数仓平台和商业分析平台，为美团的数字化运营提供了提供高质量、高效率的数据服务。</p> \n<p><strong>选择美团数据通道的5大理由：</strong></p> \n<ul> \n <li>数据是一个非常综合的领域，同学们将有机会得到多种技能的训练和培养。数据通道同学可以选择大数据平台搭建、数据资产构建、数据分析、数据挖掘和数据服务化等不同方向，可学习的开发技能包括系统开发技能、数据建模技能、数据应用开发技能等不同方面。在美团，数据人才的发展会有更多的可能性。</li> \n <li>数据是与业务贴近程度最高的技术门类之一，同学们在为业务提供数据解决方案的过程中，将会得到商业思维和业务管理能力的训练。</li> \n <li>数据相关技术和技能「浩如烟海」，非常适合对技术追求长期有耐心的同学。而且任何行业和领域的工作都需要数据能力的直接支撑。未来数据人才培养难度较高，市场需求也非常旺盛。</li> \n <li>美团拥有本地生活领域海量的数据资源、丰富的数据应用场景以及极具挑战性的工作。在美团数据通道，你将有机会参与到PB级数据项目实践，参与业界一流的分析平台建设，应用到业界最先进的技术和知识，接触到吃喝玩乐住行的全链条数据。</li> \n <li>美团的数据体系属于国内顶尖级别，数据通道通过精准、专业的组织建设，为公司的数据开发者带来归属感，提供了专业学习交流机制以及职业晋升指导和渠道。特别是对校招生来说，美团还为大家提供贴心的技术学习和职业发展指导，能够帮助大家迅速成长为一名合格的大数据专业人才。</li> \n</ul> \n<p><strong>美团对数据开发工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ul> \n <li>计算机基础以及大数据通用技术的底层原理，包括数据结构与算法、操作系统、计算机网络、数据库原理、统计分析与概率、数学分析以及SQL语言等等；</li> \n <li>Coding的能力，掌握至少一门编程语言（Java/Python/C等）；</li> \n <li>加分项：有一定的数据逻辑能力，对大数据开源框架有认知，了解分布式计算、消息队列、KV存储等等，了解数据挖掘与机器学习基本理论和方法。</li> \n</ul> \n<p>细节可以通过美团数据方向的技术文章来体验：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2020/03/12/delivery-data-governance.html\" rel=\"nofollow noreferrer\">美团配送数据治理实践</a></li> \n <li><a href=\"https://tech.meituan.com/2017/08/25/dataplat-coalesce.html\" rel=\"nofollow noreferrer\">美团数据平台融合实践</a></li> \n <li><a href=\"https://tech.meituan.com/2013/12/05/meituan-datawarehouse-evolution.html\" rel=\"nofollow noreferrer\">美团数据仓库的演进</a></li> \n <li><a href=\"https://tech.meituan.com/2018/05/20/kerberos-big-data-platform.html\" rel=\"nofollow noreferrer\">美团数据平台Kerberos优化实战</a></li> \n <li><a href=\"https://tech.meituan.com/2018/03/20/user-funnel-analysis-design-build.html\" rel=\"nofollow noreferrer\">每天数百亿用户行为数据，美团点评怎么实现秒级转化分析？</a></li> \n</ul> \n<h3>测试工程师</h3> \n<blockquote>\n 对应岗位名称：测试开发，测试工程师，QA工程师。\n</blockquote> \n<p>互联网已逐步成为人们生活和工作中不可或缺的部分，相应的，用户对互联网产品的用户体验和质量要求随之「水涨船高」，质量低、体验差的产品也将越来越难以留在赛道上。这样的背景下，测试工程师的岗位面临着新的挑战和机遇。美团对测试工程师的期待远不止是传说中「点点点」式的「黑盒」功能测试，而是需要与产品、研发、业务团队密切协作，以专业能力保证数亿消费者的用户体验，支撑数百万商家的线上化运营。</p> \n<p>守住质量底线，交付用户价值。美团测试工程师的岗位职责除了基于对用户需求和被测系统的理解、设计并执行完备高效的测试用例从而保证交付质量外，还需要不断推动被测系统改进可测性设计、探索高效测试方法、持续提升自动化测试水平。在此过程中不断完善的测试工具、持续交付基础设施将使得我们的研发过程日趋高效，全过程、多维度的研发过程数据将驱动我们的技术团队持续进化。一个业务需求从发起到最终交付用户使用，测试工程师的角色无处不在，全方位的为稳定的交付质量和良好的用户体验保驾护航。</p> \n<p>美团测试通道能力模型全面且立体，测试工程师的成长路径涵盖测试技术专家、业务方向质量顾问、测试工具与基础设施开发者等不同诉求。针对上述细分领域，美团测试通道精心准备了适用于初、中、高阶的培训课程。目前培训课程已经过多轮评审和迭代，课程讲师均是公司内各个领域的佼佼者。期待有朝一日你也成为光荣的讲师团成员！</p> \n<p><strong>选择美团测试通道的4大理由：</strong></p> \n<ul> \n <li>适于不同类型人才发挥的空间，无论是热衷技术还是长于协作，热情洋溢或是冷静心细，都能找到展现个人精彩的舞台；</li> \n <li>有利于锻炼综合能力，从业务理解到技术架构，从沟通协作到效率提升，相较于「固守一隅」的开发人员拥有更为广阔的视角；</li> \n <li>测试通道拥有清晰的人才模型、健全的职级体系、多样化的成长路径，资深导师辅导、开放的技术氛围帮助每位同学成长；</li> \n <li>立足完整的测试理论基础和技术体系，面临万物互联和智能化时代伟大挑战，有机会与我们一同探索测试领域全新的未来。</li> \n</ul> \n<p>当然，在面对多种多样的被测系统时，测试工程师需要对它们的技术原理和实现方法有基本的了解，才能有针对性的进行更深入的测试。在遇到各式各样的可测性难题时，测试工程师需要打破边界、发散思维，从别的领域寻求启发，以突破本领域的思维定势。当然最重要的一点是学习能力，业务领域和技术领域的知识浩渺如大海，扎实的基础知识是成长的基石，而良好的学习习惯，快速的学习能力，以及驱动自己不断探索未知领域的好奇心才是成长的持续动力。</p> \n<p><strong>美团对测试工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ul> \n <li>计算机技术基础，包括网络、数据结构、数据库、操作系统、编程语言、软件测试/软件工程等等；对校招生不要求有丰富的工作经验，更注重技术基础能力是否扎实。</li> \n <li>了解经典的软件测试理论，熟悉基本的测试设计方法；对质量度量、流程把控、客户端专项、性能工具的使用较为熟悉；且具备一定的编码能力；</li> \n <li>加分项：测试工程师的岗位需要候选人有比较广泛的知识面，最好对计算机各个领域的知识均有涉猎，不求样样精通，但求能融会贯通。</li> \n</ul> \n<p>细节可以通过美团测试方向的技术文章来体验：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2018/05/11/quality-operation-in-zcm.html\" rel=\"nofollow noreferrer\">质量运营在智能支付业务测试中的初步实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/04/27/ruby-autotest.html\" rel=\"nofollow noreferrer\">“小众”之美——Ruby在QA自动化中的应用</a></li> \n <li><a href=\"https://tech.meituan.com/2018/03/11/dianping-shortvideo-battery-testcase.html\" rel=\"nofollow noreferrer\">大众点评App的短视频耗电量优化实战</a></li> \n <li><a href=\"https://tech.meituan.com/2018/01/09/lego-api-test.html\" rel=\"nofollow noreferrer\">Lego-美团接口自动化测试实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/12/13/smart-payment.html\" rel=\"nofollow noreferrer\">智能支付稳定性测试实战</a></li> \n</ul> \n<h3>运维工程师</h3> \n<blockquote>\n 对应岗位名称：运维开发，SRE，DevOps，DBA，网络工程师，安全工程师。\n</blockquote> \n<p>在美团做运维工程师，主要分为SRE、系统网络工程师和DBA三个方向，以及安全领域。鉴于安全的特殊地位，我们会将安全工程师，单独拿出来进行说明，本部分先介绍前三个方向。</p> \n<p>SRE会以「上帝视角」来运维全公司的业务系统，每一个操作都关乎亿万用户的使用，每一项优化都能帮助公司降低成本，增加效率。公司业务的持续发展离不开卓越的运营，稳定性保障领域还有很多难题需要我们去突破，SRE有很大的机会成长为优秀的架构师、管理者。</p> \n<p>系统网络工程师的主要职责是维护和保障美团基础设施的稳定，包括数据中心、网络、服务器等设施，及维护设施所需的运维平台建设与运维。这是涉及基础科学，垂直技术领域最多的一个通道，通过技术与运营相结合，为公司业务提供稳定、高效、低成本的基础设施资源。如果你成为一名系统工程师，就有机会接触大规模的基础设施资源，能够以软硬件结合的方式，系统性的参与到大规模的基础设施的运营。</p> \n<p>DBA团队负责保障美团数据库服务的稳定和安全，致力于为公司提供稳定、可靠、高效的在线存储服务。从传统的运维DBA起步，DBA团队在短时间内经历了脚本化、工具化、平台化、自动化的快速迭代，并开始了在智能运维领域的探索和实践。展望未来，我们将着力于应用AI技术推进数据库运维自动化与智能化的交叠演进，并借助NewSQL、容器化、软硬件一体化技术促进OLTP与OLAP更好的融合。如果你有志于服务万亿级的高并发、大流量、多租户的应用场景，欢迎加入美团DBA团队。</p> \n<ol> \n <li> <strong>SRE</strong>：扎实的计算机系统基础知识，丰富的网络知识，掌握常用算法，具备脚本编程能力；具备Linux操作系统的运维实操经验，具备小型网站的搭建能力；</li> \n <li> <strong>系统网络工程师</strong>：扎实的计算机系统基础知识，丰富的网络知识，掌握常用算法，具备脚本编程能力；具备Linux操作系统的运维实操经验；能够无障碍阅读英文技术Paper；</li> \n <li> <strong>DBA</strong>：能够掌握各种数据结构，如数组、链表、队列和栈，以及树、哈希表等；掌握数据库的基础知识，如范式、表结构设计，常用SQL语句，聚合函数的用法等；掌握Linux系统下的常用Shell命令；掌握简单的正则表达式和文本处理方法；掌握操作系统的基础知识；多参与实际的项目，在项目中积累编码经验，增强动手能力。</li> \n</ol> \n<p>细节可以通过美团运维方向的技术文章来体验：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2018/12/13/intelligent-operation-practice-in-meituan.html\" rel=\"nofollow noreferrer\">数据库智能运维探索与实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html\" rel=\"nofollow noreferrer\">SQL解析在美团的应用</a></li> \n <li><a href=\"https://tech.meituan.com/2017/08/03/meituanyun-sre.html\" rel=\"nofollow noreferrer\">云端的SRE发展与实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html\" rel=\"nofollow noreferrer\">Redis 高负载下的中断优化</a></li> \n <li><a href=\"https://tech.meituan.com/2017/06/29/database-availability-architecture.html\" rel=\"nofollow noreferrer\">美团数据库高可用架构的演进与设想</a></li> \n <li><a href=\"https://tech.meituan.com/2016/09/18/the-construction-of-database-automation-system.html\" rel=\"nofollow noreferrer\">美团数据库运维自动化系统构建之路</a></li> \n</ul> \n<p><strong>安全工程师</strong></p> \n<p>在当今社会，企业的信息安全越来越重要，它关系到亿万用户的数据安全和隐私保护，关系到国计民生的基础设施可靠性，甚至可能还关系到国家安全。只有安全上不发生颠覆性的风险，用户和业务才能岁月静好。</p> \n<p>美团安全团队是一群有使命感的「守夜人」，他们用卓越的本领和超强的责任心守卫着美团数亿用户的数据和隐私。如果你也热爱安全攻防，愿意在网络空间里「除暴安良」、「保家卫国」，当一位「侠之大者」，欢迎加入美团安全团队！当你选择了信息安全，你会发现不仅是选择了一个行业，更是选择了一种责任。</p> \n<p>面对日益复杂的攻防对抗形式和海量数据场景，美团安全团队也在不断提升自己的标准，致力于成为追求卓越、业界领先的安全团队，并落地更多业界认可的实践安全项目。目前，美团安全团队人才济济，大多数核心成员拥有多年互联网以及不同安全领域实践经验，均参与过大型互联网公司的安全体系建设，其中不乏具备百万级IDC规模攻防对抗的经验的全球化安全人才、CVE挖掘圣手、业务全流程风控专家、国际顶级会议演讲者、以及知名媒体大V等。值得一提的是，美团安全团队的氛围非常的轻松和谐。我们不止有「格子衫文化」，更会吃喝玩乐，是一群热爱生活，并且享受生活的年轻人。</p> \n<ol> \n <li> <strong>专业背景</strong>：优先信息安全、计算机科学、统计学、数学等相关学历及专业背景的同学；</li> \n <li> <strong>技术技能</strong>：至少熟悉Python、Java、Go、C++等主流语言中的一门，有过至少一门语言的开发实践；了解行业政策与动向，关注最新安全漏洞，能分析漏洞原理和实现PoC编写；能够无障碍阅读英文技术Paper；</li> \n <li> <strong>覆盖领域</strong>：对网络安全、应用安全、数据安全、业务安全、移动安全、AI安全、IoT安全、内容风控、攻防对抗、安全算法等任意领域有实操经验，或有着一定的见解，并对此研究方向抱有热情；</li> \n <li> <strong>加分项</strong>：如果你是挖洞能手，有独立挖掘过知名开源应用/大型厂商高危漏洞经历，或在相关领域获奖、发表过Paper、做过分享；或者曾经在大型互联网公司有过相关实习经验；或者了解AI主流算法适用场景和调参，有相关的实践经验，都是加分项哦~</li> \n</ol> \n<p>细节可以通过美团安全领域的技术文章来体验：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2018/05/24/data-security-system-construction.html\" rel=\"nofollow noreferrer\">互联网企业数据安全体系建设</a></li> \n <li><a href=\"https://tech.meituan.com/2020/03/12/cloud-native-security.html\" rel=\"nofollow noreferrer\">云原生之容器安全实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/11/08/intrusion-detection-security-meituan.html\" rel=\"nofollow noreferrer\">浅谈大型互联网企业入侵检测及防护策略</a></li> \n <li><a href=\"https://tech.meituan.com/2018/01/26/network-isolation-access-control.html\" rel=\"nofollow noreferrer\">初探下一代网络隔离与访问控制</a></li> \n <li><a href=\"https://tech.meituan.com/2017/10/27/security-port-monitor.html\" rel=\"nofollow noreferrer\">互联网企业安全之端口监控</a></li> \n <li><a href=\"https://tech.meituan.com/2017/04/07/google-security-ayazero.html\" rel=\"nofollow noreferrer\">从Google白皮书看企业安全最佳实践</a></li> \n</ul> \n<h3>硬件开发工程师</h3> \n<blockquote>\n 对应岗位名称：硬件开发，嵌入式系统工程师。\n</blockquote> \n<p>硬件涉及面很广，这里不仅仅有硬件的设计和开发工作，同时包括了嵌入式软件方向、机械与结构方向、硬件质量管理等技术方向。这是一个需要能够「上通业务，下晓硬件」的技术领域，在这里工作的同学都是软硬结合的多面手。他们为美团的智能硬件平台提供最佳的解决方案，帮助美团拓展在IoT领域的战略布局。</p> \n<p>「硬件」的价值，看得见，摸得着。硬件是软件系统的载体，软件基于稳定可靠的硬件特性基础而扩展，硬件帮助软件技术价值触达用户。如果你是一位喜欢精雕细琢的「工匠」，欢迎加入我们，一起铸造精品！</p> \n<ol> \n <li>机械和电子专业技术知识，质量及项目管理专业技能，以及发现和解决问题能力。</li> \n <li>其中嵌入式软件方向：需要了解计算机体系结构，C/C++程序设计语言，数据结构，常用的网络通信结构，操作系统等基础知识。</li> \n</ol> \n<h3>算法工程师</h3> \n<blockquote>\n 对应岗位名称：算法工程师。\n</blockquote> \n<p>美团算法团队希望通过人工智能技术为业务创造价值。要求候选人能够在深入理解美团业务的基础上，进行有效场景的抽象和建模，并使用数据和算法优化上述模型；同时要求候选人能够从海量数据中总结规律，通过规则、模型、自适应学习系统等方式进行有效知识沉淀，通过数据驱动的方式帮助公司提升业务运营全链条的效率、效果。</p> \n<p>美团拥有丰富的算法应用场景、海量的数据、以及强大的算力平台。美团算法团队正在构建的AI相关技术，囊括了语音、视觉、自然语言处理、机器学习、知识图谱、搜索推荐、运筹优化、运动控制等领域；美团因为涉及线上和线下经济结合的众多业务，有丰富的应用场景，包括美团点评App内搜索推荐、面向外卖配送的定价和调度、无人配送的自动驾驶、无人机的飞行控制、智能耳机里的语音识别、人脸识别、智能语音客服系统、金融体系和供应链系统中的庞大知识图谱等。同时，美团的巨大的用户和商户以及订单体量，产生了PB量级的真实数据，例如海量的用户评价、商家经营数据、商场监控数据、餐馆菜单、无人车感知数据等，这些真实的数据对于算法研究人员是一个巨大的宝藏和修炼场。美团拥有数万高性能服务器以及数千张GPU卡，给模型训练提供了充足的算力。</p> \n<p>目前，美团算法团队比较急缺的岗位包括机器学习/数据挖掘算法工程师、运筹优化研发工程师、语音算法工程师、自然语言处理开发工程师、推荐算法工程师、计算机视觉工程师、无人车和无人机的感知/规划控制工程师等。</p> \n<p><strong>美团对算法工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ol> \n <li>专业背景：算法基础知识与工程基础知识，包括数据结构、数学、机器学习理论等。</li> \n <li>专业知识：细分领域知识，包括数据挖掘、运筹优化、深度学习等基础知识，NLP、图像、3D空间定位、点云、运动规划控制等。</li> \n <li>专业能力：要求具备一定的文献阅读和调研能力，以及算法策略的实现能力。</li> \n</ol> \n<p>划重点：美团算法岗位的竞争非常激烈。如果你在算法方面不是特别自信的话，建议多考虑一下美团的工程方向。</p> \n<p>细节可以通过美团算法方向的技术文章来体验：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2019/11/14/nlp-bert-practice.html\" rel=\"nofollow noreferrer\">美团BERT的探索和实践</a></li> \n <li><a href=\"https://tech.meituan.com/2015/01/22/mt-recommend-practice.html\" rel=\"nofollow noreferrer\">美团推荐算法实践</a></li> \n <li><a href=\"https://tech.meituan.com/2019/01/10/deep-learning-in-meituan-hotel-search-engine.html\" rel=\"nofollow noreferrer\">深度学习在搜索业务中的探索与实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/03/29/herenqing-ai-con.html\" rel=\"nofollow noreferrer\">美团外卖骑手背后的AI技术</a></li> \n <li><a href=\"https://tech.meituan.com/2017/07/28/dl.html\" rel=\"nofollow noreferrer\">深度学习在美团推荐平台排序中的运用</a></li> \n <li><a href=\"https://tech.meituan.com/2017/05/05/machine-learning-model-optimization.html\" rel=\"nofollow noreferrer\">机器学习中模型优化不得不思考的几个问题</a></li> \n <li><a href=\"https://tech.meituan.com/2019/02/21/meituan-delivery-eta-estimation-in-the-practice-of-deep-learning.html\" rel=\"nofollow noreferrer\">深度学习在美团配送ETA预估中的探索与实践</a></li> \n</ul> \n<p>以上就是美团技术团队岗位整体介绍以及对岗位的要求，如果大家想了解更多的招聘信息和岗位信息，欢迎关注「美团技术团队」、「美团点评招聘」微信公众号。</p> \n<h2>二、哪些软素质最受面试官的认可？</h2> \n<p><strong>基本能力</strong></p> \n<ul> \n <li> <strong>聆听的能力</strong>：希望你能够迅速Get到面试官的提出的问题核心以及前提条件，避免在未清晰获取到问题或者没有思考清晰的情况下，直接就回答面试官提出的问题。</li> \n <li> <strong>沟通表达的能力</strong>：口头和书面表达逻辑清晰，能够有条理地进行思考，清楚、有力地表达自身想法和观点。在美团的日常工作中，编写技术文档和发送邮件的情况非常普遍，希望你具备清晰的逻辑思考能力和优秀的写作能力。</li> \n <li> <strong>学习能力</strong>：美团有句经典老话：我不会但我可以学。我们希望你能够主动发现自己的短板，并有规划地为自身能力打补丁，更主动地了解行业相关信息，同时愿意主动学习新技术，包括但不限于经典的技术书籍、网络博客、教学视频等。鼓励大家在大学时尽可能参与一些开源项目，或者参加过一些编程相关的竞技比赛。</li> \n</ul> \n<p><strong>工作能力</strong></p> \n<ul> \n <li> <strong>协作能力</strong>：一个人可以走的更快，一群人可以走的更远。美团业务线比较多，经常涉及跨部门合作，希望你具备一定的团队协作能力。</li> \n <li> <strong>执行力</strong>：较好的计划制定和落地能力，较好的风险把控和应对能力，较好的应变和调整能力。</li> \n <li> <strong>管理能力</strong>：在时间管理方面，能够合理安排工作，以确保自己不被Deadline牵制；在自身管理能力方面，知道时间用在什么地方，重视对外界的贡献，善于发挥自身长处，集中精力于重要领域，善于做出有效决策。</li> \n</ul> \n<p><strong>个人素质</strong></p> \n<ul> \n <li> <strong>技术自驱力</strong>：我们希望你是真正发自心底的热爱技术，能够对技术保持好奇心，做到「知其然也知其所以然」，且喜欢动手实践。</li> \n <li> <strong>韧性</strong>：美团提倡「长期有耐心」，希望你在遇到挫折和失败时，不会轻言放弃。从学校到社会的过渡阶段，必然会面临很多挑战和困难，坚韧可以帮助战胜困难。</li> \n <li> <strong>积极开放的心态</strong>：希望你拥有较强的求知欲和好奇心，对新鲜技术充满探索欲，能够积极拓展圈内外的人际资源，跟大家一起交流、分享。同时能够不自我设限，不断突破自我。</li> \n</ul> \n<h2>三、学长有话对你说：</h2> \n<h3>潘魏增学长 | 南开大学 | 前端技术专家，2010年加入美团点评</h3> \n<p>第一，练好技术基本功，勿在浮沙筑高台。大家要把计算机基础理论、互联网基础知识以及前端开发的基本原理弄明白，这点对刚走上工作岗位的应届生来说尤为重要。第二，不要去追潮流，不要去做技术投机，看到人工智能、算法领域比较火爆，就一窝蜂冲上去，往往容易「折戟沉沙」。而且工程领域发展前景并不输于算法等领域。第三，主动了解所在公司所在部门最需要什么，了解影响业务成功的各种要素，在做好本职工作之外向前多走一步，成为懂业务、懂商业的技术多面手。最重要的一点，持续努力，不要懈怠。不要因为获得一点点成绩而沾沾自喜，千万不要把运气当做自己的能力。</p> \n<h3>王晓飞学长 | 北京邮电大学 | Android技术专家，2015年加入美团点评</h3> \n<p>首先建议学弟学妹，最好在大学期间就能认认真真地去完成一个App的设计、开发、上线的完整流程；第二，必要的面试笔试基本功不能丢（上面写的很详细呦）；第三，多一点耐心，多一点坚持；第四点，要有自己的想法，不要因为大家都去追逐一些新名词就随波逐流，找到适合自己的才是最重要的。</p> \n<h3>董尚先学长 | iOS技术专家，2015年4月加入美团点评</h3> \n<p>计算机知识体系很庞大，但是技术基础上都具备相通性，牢固的知识基础有助于在后续的学习中举一反三。作为一名iOS工程师，不代表你不能学习其他的技术栈。移动端的知识相对来说学习曲线比较平缓，对新同学来说比较友好的，非常适合作为互联网的入门行业。 当感觉到得心应手的时候，一定要及时走出舒适圈，严格要求自己，LLVM、跨端技术、持续集成、动态化、端智能技术等都是可以深入的学习方向。美团技术团队也提供了非常大的一个舞台，内部有无数的「活水」机会，大家可以去不同的业务线、不同的技术线去挑战自我。</p> \n<h3>刘铮学长 | 西安电子科技大学 | 后台技术专家，2017年加入美团点评</h3> \n<p>后台和系统相关的技术体系很庞大，一开始避免陷入细节，可以先从广度入手，了解各种技术的特性及使用场景，然后结合自己的事情或兴趣，进行某个领域的深入钻研。机会与能力同等重要。作为初出茅庐的毕业生，应该选择一个蓬勃发展的行业，在丰富的实践中快速成长。</p> \n<h3>陈彧学长 | 清华大学 | 数据技术专家，2015年加入美团点评</h3> \n<p>如果你想成为一名优秀的数据工程师，那么你需要知道，数据非常看重实战经验的长期积累。同学们需要具有稳健的职业发展观。在数据领域，毕业后3~5年的时期非常关键，就业的选择要重视未来经验的积累和视野的拓展。建议大家要重视基本功，认知好自己的兴趣和专长。时间若是足够的话，可在美团这样的大型互联网公司找到一份相关的实习工作，提前了解一下行业的实践。</p> \n<h3>陈阳学长 | 东北石油大学 | 测试技术专家，2019年加入美团点评</h3> \n<p>测试方向入门容易做精难，想在某一个方向做深入需要比研发工程师更广的知识面，也需要比产品更敏锐的需求提炼和转化能力。从工具的设计、开发再到运营，从技术规划到版本规划再到项目实施，考验的是全面协调以及解决问题的能力。此外，高段位的测试工程师还要根据不同项目的成熟度模型，引入规范的流程、敏捷开发模式、数据版本的管理、代码版本的管理、组件化服务化的升级等等，都需要对业务的深度理解，更需要多年的经验积累来确保软件的质量。建议学弟学妹们要重视知识的广度，夯实基础，在某一个方向持续深入学习，锻炼沟通能力和解决问题的能力。</p> \n<h3>赵应钢学长 | 华中科技大学 | 数据库专家，2015年8月加入美团点评</h3> \n<p>首先，尽量寻找到在大型互联网公司实习的机会，在实际工作中提升自己，做到理论实践相结合。通过实际工作，更能了解到企业的实际需要。其次，可以多参加一些认证考试，在考证的过程中掌握整个知识体系，形成全局视野。最后一点，多关注顶级企业对人才的招聘要求，提前储备相关技能。</p> \n<h3>赵弼政学长 | 武汉理工大学 | 安全技术专家，2018年加入美团点评</h3> \n<p>安全攻防是在计算机基本功之上的灵活运用，深刻理解原理才能化腐朽为神奇，所以首先建议大家注意打好基本功（编译原理、操作系统、网络、数据库等）。另一方面，安全领域的大多数前辈都是兴趣驱动的，在实践中培养自信、加深理解、融会贯通。所以一定要多动手，不能仅仅满足于老师和课本上提到的知识。无论是挖漏洞、渗透测试、打CTF比赛、写自动化工具还是做算法参数调优等，尽量把经典的场景都亲手反复实践过，有了这些实践，还要擅长总结（验证对计算机基本知识的理解深度），试着写一些文章或者Blog分享。做好这些技术储备的同时，要坚守初心，不碰黑产。</p> \n<h3>景华学长 | 北京航空航天大学 | 嵌入式软件技术专家，2018年加入美团点评</h3> \n<p>当与面试官讨论问题的时候，请用数据来征服TA。在这个领域，美团硬件通道不允许用召回率来表达，一个算法也许完成了90%就可以落地了，但是美团需要的是达到99.9999%的设计标准。所以数据是打开这个通道的大门，且对应的数字一定要准确。在这个通道，基本功尤其重要，任何出现在你简历中的内容，一定要解释的明明白白。</p> \n<h3>段航学长 | 比利时鲁汶大学 | 算法专家，2015年加入美团点评</h3> \n<p>写好简历，客观地陈述个人的经历，有针对性；做好准备，重视每一次的面试机会，心态平和；积极主动，关注目标企业招聘信息，踊跃申请。</p> \n<h2>四、欢迎加入美团技术团队：重要是跟什么样的人在一起做什么样的事情！</h2> \n<p>人是美团最重要的资产，美团技术团队以浓厚的学习和分享氛围享誉业界。</p> \n<ol>\n <li> <strong>完善的技术培训体系</strong>：美团技术学院开设几百门技术专业课程。从MRN介绍到Java并发编程，从系统复杂性问题方法论到机器学习算法，从后台用例设计到运维开发初体验......</li>\n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159824\" src=\"http://localhost:8060/tup/2020/4/23/389db38345c1487c9d3fc2de6caf9b97.jpg\" alt=\"\" title=\"\"></span></p> \n<ol> \n <li> <strong>丰富的技术图书资源</strong>：美团点评图书馆藏13000多册纸质书（90%以上为技术图书），306本电子书，并有O\'Reilly Safari英文电子书库（四万多计算机技术和管理图书！）、ACM Library、知网、极客时间等多种电子资源。</li> \n <li> <strong>浓厚的工程师文化</strong>：美团技术团队内部社区为技术同学提供一站式技术信息查询服务，内外部技术博客承载技术团队优质内容沉淀，TopTalk不定期邀请国内外技术大咖来公司做分享，1024程序员节狂欢、29个技术俱乐部聚集志同道合的小伙伴，各种学习路径帮助你每天前进30公里。</li> \n</ol> \n<h2>内推福利</h2> \n<p>送给大家一个小福利。下面这个是美团技术岗位<strong>社招</strong>官方内推码，微信扫码即可投递简历：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159820\" src=\"http://localhost:8060/tup/2020/4/23/49949421110a48f483d01f0a016cb454.jpg\" alt=\"\" title=\"\"></span></p> \n<p>参加<strong>校招</strong>的同学，可以使用微信扫描下面的内推码：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159823\" src=\"http://localhost:8060/tup/2020/4/23/409954038eb24c15bd546eb1365413dd.jpg\" alt=\"\" title=\"\"></span></p> \n<p>欢迎大家踊跃投递简历噢~ ~</p> \n<p>在帮大家「吃得更好，生活更好」的背后，有一群工程师小哥哥、小姐姐们在默默努力、默默付出。我们也希望优秀的你也能加入我们，用一行行代码，创造出美好的亿万生活！</p>', null, 'http://localhost:8060/tup/2020/4/23/db259f1f057b4aae8e90bbf6ab40b2fe.jpg', '692c6787030d4b8882077b2ab9279c52', 'a337904dd1d5477b9689d7693be316de', '81a4561c1c294e0cae32c9fe6b5dc397,63c4e1e7ec204b43a62065a3ced4c2ce,55723db96b9f4593bae02bc1e49f1e87,8dfc62f227ae4076888ea4872e03cddd,85ee959b27f74072b13cc763b9bbf77e', '0', '3', '1', '2020-04-23 10:31:40', '2020-04-23 10:31:40');
INSERT INTO `tb_recommend` VALUES ('6e0ac89167ef4a2dbee0e2063403ac99', '新冠疫情在阻止全球变暖，让地球自愈？你可拉倒吧！', '内容概要：受新冠疫情影响，经济环境急剧收缩，有机构预测全球今年碳排放将达到历史最高水平，远超二战后，和 08 年金融危机，却仍然不能阻止全球变暖的趋势。', '<blockquote>\n 内容概要：受新冠疫情影响，经济环境急剧收缩，有机构预测全球今年碳排放将达到历史最高水平，远超二战后，和 08 年金融危机，却仍然不能阻止全球变暖的趋势。\n</blockquote> \n<blockquote>\n 关键词：新冠疫情 经济收缩 碳排放\n</blockquote> \n<h2>经济环境收缩 30%，碳排放仅下降 4%</h2> \n<p>新冠疫情的持续，已经对世界范围内所有国家的经济造成了巨大影响。据预测统计，今年第一季度，中国的经济总量收缩 40%，美国的经济总量收缩 30%-50%。</p> \n<p>根据第一财经的报道，他们邀请了我国 20 位首席经济学家进行了预测，所有经济学家均预计 2020 年 GDP 增速放缓已成为不争的事实。</p> \n<p>而且，短期内疫情对经济所受影响更为显著，第一季度 GDP 增速将大幅下滑至负数，预测均值为 -6.48 %。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0AG\" src=\"http://localhost:8060/tup/2020/4/23/31f93337b7c848098d47ee42fcb5bbbd.jpg\" alt=\"b79083a3ed481b76c65802840a8b6ca9.jpg\" title=\"b79083a3ed481b76c65802840a8b6ca9.jpg\"></span></p> \n<p>人们停止了旅行、出门购物，带来经济的大幅收缩，但在碳排放上却没有获得同等的效果。</p> \n<h2>碳排放达最高降幅，仍无法阻止全球变暖</h2> \n<p>英国气候政策网站 Carbon Brief，作为业内权威的能源机构，预测新冠疫情能够减少约 1600Mt 二氧化碳的排放量，这大约是 2019 年全球排放量的 4 ％。</p> \n<p>迄今为止，上一次如此规模的碳排放骤降，还是在第二次世界大战结束时，1944 -1945 年，全球的碳排放量下降了 845 Mt 。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0AO\" src=\"http://localhost:8060/tup/2020/4/23/8a252b294927450386f865720929dd53.jpg\" alt=\"31388add09944566f55e5e095159dabf.jpg\" title=\"31388add09944566f55e5e095159dabf.jpg\"></span></p> \n<ul>\n <li><em>Carbon Brief 对近代碳排放的几次骤降的图示</em></li>\n</ul> \n<p>蓝色分别代表：二战后、1991-1992 世界大萧条、能源危机、西班牙流感、2008 年金融危机，和这些时段减排的二氧化碳量。</p> \n<p>红色分别代表：新冠疫情对印度、美国中国和欧盟的碳排放的预测减排量，和全球石油部门碳排放的预测减排量，总和为世界碳排放的预测减排量。</p> \n<p>在此基础上，前几日，有媒体写出《碳排放急速下降，新冠疫情正在阻止全球变暖》等文章，内容中举例威尼斯的河水变清，动物出没在城市。</p> \n<p>就此得出结论：地球在自愈，全球在减速变暖。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0AS\" src=\"http://localhost:8060/tup/2020/4/23/a206ab9f714a4201b865e3c30b9350bc.jpg\" alt=\"气候变化.jpg\" title=\"气候变化.jpg\"></span></p> \n<p>这些都是很美好的想象。</p> \n<p>经济的报复式增长，是疫情结束后大概率会出现的局面，并不会因为考虑到碳排放而控制。</p> \n<p>在 2008-2009 年金融危机之后，碳排放下降幅度排在历史第五位，为 440 Mt。</p> \n<p>但金融危机的后一年，受到经济增长的刺激，全球碳排放量报复式增长了 1612 Mt。</p> \n<p>而我们遏制全球变暖的理想计划：必须在未来十年中，世界每年需要减少 6 ％的碳排放量，才能使温度下降 1.5 摄氏度。</p> \n<p>换句话说，即使全球经济负增长，即使我们在近几个月里，停止了大部分的环球贸易、旅游。</p> \n<p>但这点减少的排放，和暂时的生态改善，根本不足以动摇全球变暖的局面。</p> \n<h2>停止幻想地球自愈，落实真正的解决方案</h2> \n<p>2019 年 6 月，Yoshua Bengio、吴恩达和 Carla Gomes 联合了 20 多个气候变化人工智能指导委员会和顾问成员，其中包括 DeepMind 创始人 Demis Hassabis。</p> \n<p>共同发表了一篇题为《用机器学习应对气候变化》的论文，其中包含 650 篇参考文献。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0AU\" src=\"http://localhost:8060/tup/2020/4/23/eda19843396c4fa9a9fb49a8ea00f968.jpg\" alt=\"aba5a9543607dff20029a07bea9b2040.jpg\" title=\"aba5a9543607dff20029a07bea9b2040.jpg\"></span></p> \n<p>该论文探讨了机器学习在气候变化中的应用，如预测供需或极端天气事件，以及可提高城市、交通和电力系统效率的预测 AI。</p> \n<h3>应对气候变化：停止口号，停止空想</h3> \n<p>在去年底 NeurIPS 2019 中，由气候变化人工智能组织（Climate Change AI）主办的「气候变化」的分会场中，邀请到了 Yoshua Bengio、吴恩达、Jeff Dean，以及 Carla Gomes 进行交流。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0Bl\" src=\"http://localhost:8060/tup/2020/4/23/19815fde81434985a006c17f65cb85f5.jpg\" alt=\"b4682f837a185ff0dc7f1bd4328f4c36.jpg\" title=\"b4682f837a185ff0dc7f1bd4328f4c36.jpg\"></span>**<br>Yoshua Bengio 表示在 NeurIPS 上讨论减少碳排放的项目，可能会比讨论 GAN 或其他技术进步更有意义。</p> \n<p>吴恩达也认为，与其强调气候问题的严重性，不如做出实际行动——先梳理相关数据集，然后进行实验，最终公布研究结果，或与气候科学家进行对话。</p> \n<h3>下一次正式讨论</h3> \n<p>按照原计划，下一次关于利用 AI 应对气候变化主题论坛将于本月，在埃塞俄比亚的斯亚贝巴举行的 ICLR 2020 中继续。</p> \n<p>但因为新冠疫情，ICLR 2020 将改为 4 月 25 日- 30 日在线上举办网络会议（网址：<a href=\"https://iclr.cc/\" rel=\"nofollow noreferrer\">https://iclr.cc/</a>）。</p> \n<p><em>参考来源：</em><br>1）<a href=\"https://www.technologyreview.com/2020/04/10/999230/we-halted-the-global-economy-and-emissions-still-wont-decline-as-much-as-we-need/\" rel=\"nofollow noreferrer\">https://www.technologyreview....</a><br>2）<a href=\"https://www.carbonbrief.org/analysis-coronavirus-set-to-cause-largest-ever-annual-fall-in-co2-emissions\" rel=\"nofollow noreferrer\">https://www.carbonbrief.org/a...</a><br>3）<a href=\"https://www.leiphone.com/news/201912/37EHy6r7KK54JEFD.html\" rel=\"nofollow noreferrer\">https://www.leiphone.com/news...</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0Dr\" src=\"http://localhost:8060/tup/2020/4/23/9fc708ac05de4ed4b19325b5125f42b0.jpg\" alt=\"截屏2020-04-14 下午12.08.26.png\" title=\"截屏2020-04-14 下午12.08.26.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/721f12fc654c4d6ba8a15faa4f1c0744.jpg', '3f69fcc9b13843d1910b3dac597f5215', 'cbad2058b4014634aec6515f4adbef0d', '13f1211b651544e3a17611b2117e9cec,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-23 10:55:37', '2020-04-23 10:55:37');
INSERT INTO `tb_recommend` VALUES ('6eed1f6214e44412bc60d4b724028acb', '看完这一篇，再也不用担心 Git 的“黑魔法”', '简介：相信大部分开发者对 Git 都不陌生，Git 也已成为大部分开发者日常开发必用的工具。本文分享 Git 使用上的一些基础知识，通俗易懂，非常有用。', '<p><strong>简介：</strong>相信大部分开发者对 Git 都不陌生，Git 也已成为大部分开发者日常开发必用的工具。本文分享 Git 使用上的一些基础知识，通俗易懂，非常有用。</p> \n<h5>更多相关内容：<a href=\"https://developer.aliyun.com/article/754374?utm_content=g_1000111743\" rel=\"nofollow noreferrer\">点击这里</a>​</h5> \n<p>在 Git Rev News #48 期的 LightReading 中有一篇文章（地址：<a href=\"https://hacker-tools.github.io/version-control/\" rel=\"nofollow noreferrer\">https://hacker-tools.github.io/version-control/</a>） 写的不错，不仅干货满满而且还附带了操作视频。其中的内容不仅覆盖了很多 Git 使用上的基础知识，也从使用角度上解答了很多刚接触 Git 的开发者的疑问。为了便于读者理解，我在翻译的同时也添加了一些内容。以下为正文部分。本文内容较长，建议收藏慢慢学习。</p> \n<h3>担忧</h3> \n<p>很多人怕使用 Git，我个人觉得主要可能是两部分的原因：</p> \n<ul> \n <li>没接触过：平时接触的代码还托管在 SVN 或 CVS 等工具上。</li> \n <li>不太熟悉：可能对 Git 的使用还不太熟悉和全面，导致了在使用 git 时步步为营。</li> \n</ul> \n<blockquote>\n Never Be Afraid To Try Something New.\n</blockquote> \n<p>代码对于开发者是劳作成果的结晶，对于公司而言是核心资产，有一些担忧也是正常的。但 Git 也并没有我们想象中的那么复杂，需要让我们每次使用都心有余悸，其实我们只需要稍微花一点时间尝试多多了解它，在很多时候你会发现，非但 Git 不会让你产生担忧，而且会让自己的交付过程更加高效。</p> \n<h3>Version Control</h3> \n<p>谈及 Git 就不得不提到版本控制，我们不妨先来看下版本控制是做什么的，这将有助于后续对 Git 的理解。</p> \n<p>当你在工作中面对的是一些经常变化的文档、代码等交付物的时候，考虑如何去追踪和记录这些 changes 就变得非常重要，原因可能是：对于频繁改动和改进的交付物，非常有必要去记录下每次变更的内容，每次记录的内容汇成了一段修改的历史，有了历史我们才知道我们曾经做了什么。</p> \n<p>记录的历史中必须要包含一些重要的信息，这样追溯才变得有意义，比如：</p> \n<ul> \n <li>Who：是谁执行的变更？</li> \n <li>When：什么时候做出的变更？</li> \n <li>What：这次变更做了什么事情？</li> \n</ul> \n<p>最好可以支持撤销变更，不让某一个提交的严重问题，去污染整个提交历史。</p> \n<p>版本控制系统（VCS: Version Control System），正会为你提供这种记录和追溯变更的能力。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022325226\" src=\"http://localhost:8060/tup/2020/4/23/5cb39d65466d403fa17bb242f70fe046.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>大多数的 VCS 支持在多个使用者之间共享变更的提交历史，这从实质上让团队协同变为了可能，简单说来就是：</p> \n<ul> \n <li>你可以看到我的变更提交。</li> \n <li>我也可以看到你的变更提交。</li> \n <li>如果双方都进行了变更提交，也可以以某种方式方法进行比对和合并，最终作出统一的变更版本。</li> \n</ul> \n<p>VCS 历经多年的发展，目前业界中有许多 VCS 工具可供我们选择。在本文中，我们将会针对目前最流行的 Git 来介绍。</p> \n<h3>Git 是黑魔法么？</h3> \n<p>刚接触 Git 时，Git 确实有让人觉得有点像黑魔法一样神秘，但是又有哪个技术不是这样呢？当我们了解其基本的数据结构结构后，会发现 Git 从使用角度来讲其实并不复杂，我们甚至可以更进一步的学习 Git 的一些优良的软件设计理论，从中获益。首先，让我们先从 commit 说起。</p> \n<h4>git object commit</h4> \n<p>提交对象(git commit object)：每一个提交在 Git 中都通过 git commit object 存储，对象具有一个全局唯一的名称，叫做 revision hash。它的名字是由 SHA-1 算法生成，形如\"<code>998622294a6c520db718867354bf98348ae3c7e2</code>\"，我们通常会取其缩写方便使用，如\"<code>9986222</code>\"。</p> \n<ul> \n <li>对象构成：commit 对象包含了 author + commit message 的基本信息。</li> \n <li>对象存储：git commit object 保存一次变更提交内的所有变更内容，而不是增量变化的数据 delta (很多人都理解错了这一点)，所以 Git 对于每次改动存储的都是全部状态的数据。</li> \n <li>大对象存储：因对于大文件的修改和存储，同样也是存储全部状态的数据，所以可能会影响 Git 使用时的性能(glfs 可以改进这一点）。</li> \n <li>提交树：多个 commit 对象会组成一个提交树，它让我们可以轻松的追溯 commit 的历史，也能对比树上 commit 与 commit 之间的变更差异。</li> \n</ul> \n<h4>git commit 练习</h4> \n<p>让我们通过实战来帮助理解，第一步我们来初始化一个 repository（Git 仓库），默认初始化之后仓库是空的，其中既没有保存任何文本内容也没有附带任何提交：</p> \n<pre><code>$ git init hackers\n$ cd hackers\n$ git status</code></pre> \n<p>第二步，让我们来看下执行过后 Git 给出的输出内容，它会指引我们进行进一步的了解：</p> \n<pre><code>➜  hackers git:(master) git status\nOn branch master\nNo commits yet\nnothing to commit (create/copy files anduse \"git add\" to track)</code></pre> \n<p>1）output 1: On branch master</p> \n<p>对于刚刚创建空仓库来说，master 是我们的默认分支，一个 Git 仓库下可以有很多分支 (branches)，具体某一个分支的命名可以完全由你自己决定，通常会起便于理解的名字，如果用 hash 号的话肯定不是一个好主意。</p> \n<p>branches 是一种引用 (ref)，他们指向了一个确定的 commit hash 号，这样我们就可以明确我们的分支当前的内容。</p> \n<p>除了 branches 引用以外，还有一种引用叫做 tags，相信大家也不会陌生。</p> \n<p>master 通常被我们更加熟知，因为大多数的分支开发模式都是用 master 来指向“最新”的 commit。</p> \n<p>On branch master 代表着我们当前是在 master 分支下操作，所以每次当我们在提交新的 commit 时，Git 会自动将 master 指向我们新的 commit，当工作在其他分支上时，同理。</p> \n<p>有一个很特殊的 ref 名称叫做 \"HEAD\"，它指向我们当前正在操作的 branches 或 tags (正常工作时)，其命名上非常容易理解，表示当前的引用状态。</p> \n<p>通过<code>git branch</code>(或<code>git tag</code>) 命令你可以灵活的操作和修改 branches 或 tags。</p> \n<p>2）output 2：No commits yet</p> \n<p>对于空仓库来说，目前我们还没有进行任意的提交。</p> \n<blockquote>\n nothing to commit (create/copy files anduse \"git add\" to track)\n</blockquote> \n<p>output 中提示我们需要使用<code>git add</code>命令，说到这里就必须要提到暂存或索引 (stage)，那么如何去理解暂存呢？</p> \n<h4>暂存</h4> \n<p>一个文件从改动到提交到 Git 仓库，需要经历三个状态：</p> \n<ul> \n <li>工作区：工作区指的是我们本地工作的目录，比如我们可以在刚才创建的 hackers 目录下新增一个 readme 文件，readme 文件这时只是本地文件系统上的修改，还未存储到 Git。</li> \n <li>暂存(索引)区：暂存实际上是将我们本地文件系统的改动转化为 Git 的对象存储的过程。</li> \n <li>仓库：git commit 后将提交对象存储到 Git 仓库。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022325227\" src=\"http://localhost:8060/tup/2020/4/23/7a0d8708a87c4d5a8bae9598fe13ca8c.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>git add 的帮助文档中很详细的解释了暂存这一过程：</p> \n<blockquote>\n This command updates the index using thecurrent content found in the working tree, to prepare the content stagedfor the next commit.\n</blockquote> \n<p>git add 命令将更新暂存区，为接下来的提交做准备。</p> \n<blockquote>\n It typically adds the current content ofexisting paths as a whole, but with some options it can also be used toadd content with only part of the changes made to the working tree filesapplied, or remove paths that do not exist in the working tree anymore.\n <p>The \"index\" holds a snapshot ofthe content of the working tree, and it is this snapshot that is taken as thecontents of the next commit.</p> \n</blockquote> \n<p>暂存区的 index 保存的是改动的完整文件和目录的快照 (非 delta）。</p> \n<blockquote>\n Thus after making any changes to theworking tree, and before running the commit command, you must use the addcommand to add any new or modified files to the index.\n</blockquote> \n<p>暂存是我们将改动提交到 git 仓库之前必须经历的状态。</p> \n<p>对 Git 暂存有一定了解后，其相关操作的使用其实也非常简单，简要的说明如下：</p> \n<p>1）暂存区操作</p> \n<ul> \n <li>通过<code>git add</code>命令将改动暂存。</li> \n <li>可以使用<code>git add -p</code>来依次暂存每一个文件改动，过程中我们可以灵活选择文件。中的变更内容，从而决定哪些改动暂存。</li> \n <li>如果<code>git add</code>不会暂存被 ignore 的文件改动。</li> \n <li>通过<code>git rm</code>命令，我们可以删除文件的同时将其从暂存区中剔除。</li> \n</ul> \n<p>2）暂存区修正</p> \n<ul> \n <li>通过<code>git reset</code>命令进行修正，可以先将暂存区的内容清空，在使用<code>git add -p</code>命令对改动 review 和暂存。</li> \n <li>这个过程不会对你的文件进行任何修改操作，只是 Git 会认为目前没有改动需要被提交 。</li> \n <li>如果我们想分阶段(or 分文件)进行 reset，可以使用<code>git reset FILE</code>或<code>git reset -p</code>命令。</li> \n</ul> \n<p>3）暂存区状态</p> \n<ul> \n <li>可以用<code>git diff --staged</code>依次检查暂存区内每一个文件的修改。</li> \n <li>用<code>git diff</code>查看剩余的还未暂存内容的修改。</li> \n</ul> \n<h4>Just Commit！</h4> \n<p>当你对需要修改的内容和范围满意时，你就可以将暂存区的内容进行 commit 了，命令为：<code>git commit</code>。</p> \n<p>如果你觉得需要把所有当前工作空间的修改全部 commit，可以执行<code>git commit -a</code>，这相当于先执行<code>git add</code>后执行<code>git commit</code>，将暂存和提交的指令合二为一，这对于一些开发者来说是很高效的，但是如果提交过大这样做通常不合适。</p> \n<p>我们建议一个提交中只做一件事，这在符合单一职责的同时，也可以让我们明确的知道每一个 commit 中做了一件什么事情而不是多个事情。所以通常我们的使用习惯都是执行<code>git add -p</code>来 review 我们将要暂存内容是否合理？是否需要更细的拆分提交？这些优秀的工程实践，将会让代码库中的 commits 更加优雅。</p> \n<p>ok，我们已经在不知不觉中了解了很多内容，我们来回顾下，它们包括了：</p> \n<ul> \n <li>commit 包含的信息？</li> \n <li>commit 是如何表示的？</li> \n <li>暂存区是什么？如何全部添加、一次添加、删除、查询和修正？</li> \n <li>如何将暂存区的改动内容 commit？</li> \n <li>不要做大提交，一个提交只做一件事。</li> \n</ul> \n<p>附带的，在了解 commit 过程中我们知道了从本地改动到提交到 Git 仓库，经历的几个关键的状态：</p> \n<ul> \n <li>工作区 (Working Directory)</li> \n <li>暂存区 (Index)</li> \n <li>Git 仓库 (Git Repo)</li> \n</ul> \n<p>下图为上述过程中各个状态的转换过程：</p> \n<ul> \n <li>本地改动文件时，此时还仅仅是工作区内的改动</li> \n <li>当执行 git add 之后，工作区内的改动被索引在暂存区</li> \n <li>当执行<code>git commit</code>之后，暂存区的内容对象将会存储在 Git 仓库中，并执行更新 HEAD 指向等后续操作，这样就完成了引用与提交、提交与改动快照的——对应了。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022325229\" src=\"http://localhost:8060/tup/2020/4/23/9895d5231f0344a8802c3968e69eb346.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>正是因为 Git 本身对于这几个区域(状态)的设计，为 Git 在本地开发过程带来了灵活的管理空间。我们可以根据自己的情况，自由的选择哪些改动暂存、哪些暂存的改动可以 commit、commit 可以关联到那个引用，从而进一步与其他人进行协同。</p> \n<h3>提交之后</h3> \n<p>我们已经有了一个 commit，现在我们可以围绕 commit 做更多有趣的事情：</p> \n<ul> \n <li>查看 commit 历史：<code>git log</code>(或<code>git log --oneline</code>)。</li> \n <li>在 commit 中查看改动的<code>diff:git log -p</code>。</li> \n <li>查看 ref 与提交的关联关系，如当前 master 指向的 commit: git show master 。</li> \n <li>检出覆盖：<code>git checkout NAME</code>（如果 NAME 是一个具体的提交哈希值时，Git 会认为状态是 “detached (分离的)”，因为<code>git checkout</code>过程中重要的一步是将 HEAD 指向那个分支的最后一次 commit。所以如果这样做，将意味着没有分支在引用此提交，所以若我们这时候进行提交的话，没有人会知道它们的存在）。</li> \n <li>使用<code>git revert NAME</code>来对 commit 进行反转操作。</li> \n <li>使用<code>git diff NAME</code>将旧版本与当前版本进行比较，查看 diff。</li> \n <li>使用<code>git log NAME</code>查看指定区间的提交。</li> \n <li>使用<code>git reset NAME</code>进行提交重置操作。</li> \n <li>使用<code>git reset --hard NAME</code>：将所有文件的状态强制重置为 NAME 的状态，使用上需要小心。</li> \n</ul> \n<h3>引用基本操作</h3> \n<p>引用 (refs) 包含两种分别是 branches 和 tags， 我们接下来简单介绍下相关操作：</p> \n<ul> \n <li> <code>git branch b</code>命令可以让我们创建一个名称为 b 的分支。</li> \n <li>当我们创建了一个 b 分支后，这也相当于意味着 b 的指向就是 HEAD 对应的commit。</li> \n <li>我们可以先在 b 分支上创建一个新的 commit A ，然后假如切回 master 分支上，这时再提交了一个新的 commit B，那么 master 和 HEAD 将会指向了新的commit __B，而 b 分支指向的还是原来的 commit A。</li> \n <li> <code>git checkout b</code>可以切换到b分支上,切换后新的提交都会在b分支上，理所应当。</li> \n <li> <code>git checkout master</code>切换回 master 后，b 分支的提交也不会带回 master 上，分支隔离。</li> \n</ul> \n<p>分支上提交隔离的设计，可以让我们非常轻松的切换我们的修改，非常方便的做各类测试。</p> \n<p>tags 的名称不会改变，而且它们有自己的描述信息 (比如可以作为 release note 以及标记发布的版本号等)。</p> \n<h3>做好你的提交</h3> \n<p>可能很多人的提交历史是长这个样子的：</p> \n<pre><code>commit 14: add feature x – maybe even witha commit message about x!\ncommit 13: forgot to add file\ncommit 12: fix bug \ncommit 11: typo\ncommit 10: typo2\ncommit 9: actually fix\ncommit 8: actually actually fix\ncommit 7: tests pass\ncommit 6: fix example code\ncommit 5: typo\ncommit 4: x\ncommit 3: x\ncommit 2: x\ncommit 1: x</code></pre> \n<p>单就 Git 而言，这看上去是没有问题而且合法的，但对于那些对你修改感兴趣的人（很可能是未来的你!），这样的提交在信息在追溯历史时可能并没有多大帮助。但是如果你的提交已经长成这个样子，我们该怎么办？</p> \n<p>没关系，Git 有办法可以弥补这一些：</p> \n<h4>git commit --amend</h4> \n<p>我们可以将新的改动提交到当前最近的提交上，比如你发现少改了什么，但是又不想多出一个提交时会很有用。</p> \n<p>如果我们认为我们的提交信息写的并不好，我要修改修改，这也是一种办法，但是并不是最好的办法。</p> \n<p>这个操作会更改先前的提交，并为其提供新的 hash 值。</p> \n<h4>git rebase -i HEAD~13</h4> \n<p>这个命令非常强大，可以说是 Git 提交管理的神器，此命令含义是我们可以针对之前的 13 次的提交在 VI 环境中进行重新修改设计：</p> \n<p>操作选项 p 意味着保持原样什么都不做，我们可以通过 vim 中编辑提交的顺序，使其在提交树上生效。</p> \n<p>操作选项 r：我们可以修改提交信息，这种方式比<code>commit --amend</code>要好的多，因为不会新生成一个 commit。</p> \n<p>操作选项 e：我们可以修改 commit，比如新增或者删除某些文件改动。</p> \n<p>操作选项 s：我们可以将这个提交与其上一次的提交进行合并，并重新编辑提交信息。</p> \n<p>操作选项 f：f代表着 \"fixup\"。例如我们如果想针对之前一个老的提交进行 fixup，又不想做一次新的提交破坏提交树的历史的逻辑含义，可以采用这种方式，这种处理方式非常优雅。</p> \n<h3>关于 Git</h3> \n<p>版本控制的一个常见功能是允许多个人对一组文件进行更改，而不会互相影响。或者更确切地说，为了确保如果他们不会踩到彼此的脚趾，不会在提交代码到服务端时偷偷的覆盖彼此的变化。</p> \n<p>在 Git 中我们如何保证这一点呢？</p> \n<p>Git 与 SVN 不同，Git 不存在本地文件存在 lock 的情况，这是一种避免出现写作问题的方式，但是并不方便，而 Git 与 SVN 最大的不同在于它是一个分布式 VCS，这意味着：</p> \n<ul> \n <li>每个人都有整个存储库的本地副本（其中不仅包含了自己的，也包含了其他人的提交到仓库的所有内容）。</li> \n <li>一些 VCS 是集中式的（例如 SVN）：服务器具有所有提交，而客户端只有他们“已检出”的文件。所以基本上在本地我们只有当前文件，每次涉及本地不存在的文件操作时，都需要访问服务端进行进一步交互。</li> \n <li>每一个本地副本都可以当作服务端对外提供 Git 服务。</li> \n <li>我们可以用<code>git push</code>推送本地内容到任意我们有权限的 Git 远端仓库。</li> \n <li>不管是集团的 force、Github、Gitlab 等工具，其实本质上都是提供的 Git 仓库存储的相关服务，在这一点上其实并没有特别之处，针对 Git 本身和其协议上是透明的。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022325228\" src=\"http://localhost:8060/tup/2020/4/23/3e694c17beac47d19bb48bcc1859b8aa.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>SVN，图片出自 git-scm</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022325230\" src=\"http://localhost:8060/tup/2020/4/23/569e198ddc12428889f5f3bf407c3b23.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>Git，图片出自 git-scm</p> \n<h3>Git 冲突解决</h3> \n<p>冲突的产生几乎是不可避免的，当冲突产生时你需要将一个分支中的更改与另一个分支中的更改合并，对应 Git 的命令为<code>git merge NAME</code>，一般过程如下：</p> \n<ul> \n <li>找到 HEAD 和 NAME 的一个共同祖先 (common base)。</li> \n <li>尝试将这些 NAME 到共同祖先之间的修改合并到 HEAD 上。</li> \n <li>新创建一个 merge commit 对象，包含所有的这些变更内容。</li> \n <li>HEAD 指向这个新的 merge commit。</li> \n</ul> \n<p>Git 将会保证这个过程改动不会丢失，另外一个命令你可能会比较熟悉，那就是<code>git pull</code>命令，<code>git pull</code>命令实际上包含了<code>git merge</code>的过程，具体过程为：</p> \n<ul> \n <li><code>git fetch REMOTE</code></li> \n <li><code>git merge REMOTE/BRANCH</code></li> \n <li>和 git push 一样，有的时候需要先设置 \"tracking\"(-u) ，这样可以将本地和远程的分支一一对应。</li> \n</ul> \n<p>如果每次 merge 都如此顺利，那肯定是非常完美的，但有时候你会发现在合并时产生了冲突文件，这时候也不用担心，如何处理冲突的简要介绍如下：</p> \n<ul> \n <li>冲突只是因为 Git 不清楚你最终要合并后的文本是什么样子，这是很正常的情况。</li> \n <li>产生冲突时，Git 会中断合并操作，并指导你解决好所有的冲突文件。</li> \n <li>打开你的冲突文件，找到<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，这是你需要开始处理冲突的地方，然后找到<code>=======</code>，等号上面的内容是 HEAD 到共同祖先之间的改动，等号下面是 NAME 到共同祖先之间的改动。用 git mergetool 通常是比较好的选择，当然现在大多数 IDE 都集成了不错的冲突解决工具。</li> \n <li>当你把冲突全部解决完毕，请用<code>git add.</code>来暂存这些改动吧。</li> \n <li>最后进行<code>git commit</code>，如果你想放弃当前修改重新解决可以使用<code>git merge --abort</code>，非常方便。</li> \n</ul> \n<p>当你完成了以上这些艰巨的任务，最后<code>git push</code>吧！</p> \n<h3>push 失败？</h3> \n<p>排除掉远端的 Git 服务存在问题以外，我们 push 失败的大多数原因都是因为我们在工作的内容其他人也在工作的关系。</p> \n<p>Git 是这样判断的：</p> \n<p>1）会判断 REMOTE 的当前 commit 是不是你当前正在 pushing commit 的祖先。</p> \n<p>2）如果是的话，代表你的提交是相对比较新的，push 是可以成功的 (fast-forwarding)。</p> \n<p>3）否则 push 失败并提示你其他人已经在你 push 之前执行更新 (push is rejected)。</p> \n<p>当发生“push is rejected”后我们的几个处理方法如下:</p> \n<ul> \n <li>使用<code>git pull</code>合并远程的最新更改（<code>git pull</code>相当于<code>git fetch</code>+<code>git merge</code>)。</li> \n <li>使用 --force 强制推送本地变化到远端引用进行覆盖，需要注意的是 这种覆盖操作可能会丢失其他人的提交内容。</li> \n <li>可以使用<code>--force-with-lease</code>参数，这样只有远端的 ref 自上次从 fetch 后没有改变时才会强制进行更改，否则“reject the push”，这样的操作更安全，是一种非常推荐使用的方式。</li> \n <li>如果 rebase 操作了本地的一些提交，而这些提交之前已经 push 过了的话，你可能需要进行 force push 了，可以想象看为什么？</li> \n</ul> \n<p>本文只是选取部分 Git 基本命令进行介绍，目的是抛砖引玉，让大家对 Git 有一个基本的认识。当我们深入挖掘 Git 时，你会发现它本身有着如此多优秀的设计理念，值得我们学习和探究。</p> \n<p>不要让 Git 成为你认知领域的黑魔法，而是让 Git 成为你掌握的魔法。</p>', null, 'http://localhost:8060/tup/2020/4/23/5a3eaaca7a834518b683a96e60314ad7.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', '2a353971222c4aff8e8d3e9c370330cd', 'f4fda25145b9451a9b0d77d6a2a63712', '0', '3', '1', '2020-04-23 11:00:54', '2020-04-23 11:00:54');
INSERT INTO `tb_recommend` VALUES ('70252f924a9c40cb868bec494020c354', 'Javascript 中 cookie 操作方式', '点赞再看，养成习惯本文 GitHub [链接] 上已经收录，更多往期高赞文章的分类，也整理了很多我的文档，和教程资料。欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。', '<blockquote> \n <strong>点赞再看，养成习惯</strong>\n <p><strong>本文 <code>GitHub</code> <a href=\"https://github.com/qq449245884/xiaozhi\" rel=\"nofollow noreferrer\">https://github.com/qq44924588...</a> 上已经收录，更多往期高赞文章的分类，也整理了很多我的文档，和教程资料。欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。</strong></p> \n</blockquote> \n<p><strong>Cookie</strong> 为 Web 应用程序保存用户相关信息提供了一种有用的方法。例如，当用户访问咱们的站点时，可以利用 <strong>Cookie</strong> 保存用户首选项或其他信息，这样，当用户下次再访问咱们的站点时，应用程序就可以检索以前保存的信息。</p> \n<h2>Cookie 是什么鬼</h2> \n<p><strong>Cookie</strong> 是一小段文本信息，伴随着用户请求和页面在 Web 服务器和浏览器之间传递。用户每次访问站点时，Web 应用程序都可以读取 Cookie 包含的信息。</p> \n<p>Cookie的出现是为了解决保存用户信息的问题。例如</p> \n<ul> \n <li>当用户访问网页时，用户的名字可以存储在cookie中。</li> \n <li>下次用户访问页面时，cookie会记住用户名。</li> \n</ul> \n<p><strong>Cookie</strong> 能在所有网页中记住用户的信息。它以字符串的形式包含信息，并键值对的形式保存的，即<code>key=value</code>的格式。各个<code>cookie</code>之间一般是以“<code>;</code>”分隔。</p> \n<pre><code>username = Daisy Green\n</code></pre> \n<h2>Cookie 缺点</h2> \n<ul> \n <li> <code>cookie</code>可能被禁用。当用户非常注重个人隐私保护时，他很可能禁用浏览器的cookie功能；</li> \n <li> <code>cookie</code>是与浏览器相关的。这意味着即使访问的是同一个页面，不同浏览器之间所保存的<code>cookie</code>也是不能互相访问的；</li> \n <li> <code>cookie</code>可能被删除。因为每个<code>cookie</code>都是硬盘上的一个文件，因此很有可能被用户删除；</li> \n <li> <code>cookie</code>安全性不够高。所有的<code>cookie</code>都是以纯文本的形式记录于文件中，因此如果要保存用户名密码等信息时，最好事先经过加密处理。</li> \n</ul> \n<h2>Cooke 工作方式</h2> \n<p>服务器以<code>cookie</code>的形式向访问者的浏览器发送一些数据。如果浏览器允许接受 cookie。 则将其作为纯文本记录存储在访问者的硬盘上。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwTH2\" src=\"http://localhost:8060/tup/2020/4/23/f0af8c3f45a34387b3bbfe92b0e691ce.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>当访问者跳转到另一个页面时，浏览器会将相同的cookie发送到服务器进行检索。一旦检索到它，您的服务器就知道或记得以前存储了什么。</p> \n<h2>Cookie 的组成</h2> \n<p>Cookie 在HTTP的头部<code>Header</code>信息中，HTTP Set-Cookie的<code>Header</code>格式如下：</p> \n<pre><code>Set-Cookie: name=value; [expires=date]; [path=path];\n[domain=domainname]; [secure];\n</code></pre> \n<p>在HTTP代码中一个具体的例子：</p> \n<pre><code>&lt;meta http-equiv=\"set-cookie\" content=\" cookieName = cookieValue;\nexpires=01-Dec-2006 01:14:26 GMT; path=/\" /&gt;\n</code></pre> \n<p>从上面的格式可以看出，Cookie由下面几部分组成。</p> \n<p><strong>Name/Value对</strong></p> \n<p><code>Name/Value</code>由分号分隔，一个<code>Cookie</code>最多有<code>20</code>对，每个网页最多有一个<code>Cookie</code>，<code>Value</code>的长度不超过<code>4K</code>。对于<code>Value</code>值，最好用<code>encodeURIComponent</code>对其编码。</p> \n<p><strong>Domain</strong></p> \n<p><code>Domain</code>域名也是<strong>Cookie</strong>的一部分，默认情况下，用户访问网页的域名会存放在<strong>Cookie</strong>中。如果设置了这个<strong>Cookie</strong>的域名值，那么意味着域名上的所有服务器，而不仅是你正在访问的服务器，都能访问这个<code>Cookie</code>，通常不要这样做。设置域名的格式如下：<code>domain=http://xyz.com</code></p> \n<p><strong>path</strong></p> \n<p>设置对于特定的服务器来说哪个目录中的网页可访问<strong>Cookie</strong>，设置<code>path</code>的格式是：<code>path = /movies</code></p> \n<p><strong>Expires</strong></p> \n<p>设置<code>Cookie</code>存活的时间，默认情况下，用户关闭浏览器则<code>Cookie</code>自动删除，如果没有设置<code>Cookie</code>失效的时间，那么用户关闭浏览器时<code>Cookie</code>也消失。如果设置该项，就能延长<code>Cookie</code>的生命期。设置时间在JS 中用<code>Date</code>对象的<code>GMT</code>形式，格式如下： <code>expires = date.toGMTString()</code></p> \n<p><strong>Secure</strong></p> \n<p>取<code>true</code>或者<code>false</code>值。如果为<code>true</code>，那么必须通过<code>https</code>发送<code>Cookie</code>。</p> \n<h2>JS Cookie</h2> \n<p>在JS中，可以使用<code>Document</code>对象的<code>cookie</code>属性操作<code>cookie</code>。 JS 可以读取，创建，修改和删除当前网页的<code>cookie</code>,，来看看具体的骚操作。</p> \n<h4>创建 Cookie</h4> \n<p>JS可以使用<code>document.cookie</code>属性创建<code>cookie</code>，可以通过以下方式创建<code>cookie</code>：</p> \n<pre><code>document.cookie = \"username=Daisy Green\";\n</code></pre> \n<p>还可以添加有效日期（UTC 时间）。默认情况下，在浏览器关闭时会删除 cookie：</p> \n<pre><code>document.cookie = \"username=Daisy Green; expires=Mon, 26 Aug 2019 12:00:00 UTC\";\n</code></pre> \n<p>通过 path 参数，可以告诉浏览器 <code>cookie</code> 属于什么路径。默认情况下，<code>cookie</code> 属于当前页。</p> \n<pre><code>document.cookie = \"username=Daisy Green; expires=Mon, 26 Aug 2019 12:00:00 UTC\"; path=/\";\n</code></pre> \n<h4>读取 Cookie</h4> \n<p>通过 JS，可以这样读取 cookie：</p> \n<pre><code>var x = document.cookie;\n</code></pre> \n<p><code>document.cookie</code> 会在一条字符串中返回所有 cookie，比如：<code>cookie1=value; cookie2</code></p> \n<p>事例：</p> \n<pre><code>&lt;html&gt;\n   &lt;head&gt;   \n      &lt;script type = \"text/javascript\"&gt;\n         &lt;!--\n            function ReadCookie() {\n               var allcookies = document.cookie;\n               document.write (\"All Cookies : \" + allcookies );\n                \n               // Get all the cookies pairs in an array\n               cookiearray = allcookies.split(\';\');\n                \n               // Now take key value pair out of this array\n               for(var i=0; i&lt;cookiearray.length; i++) {\n                  name = cookiearray[i].split(\'=\')[0];\n                  value = cookiearray[i].split(\'=\')[1];\n                  document.write (\"Key is : \" + name + \" and Value is : \" + value);\n               }\n            }\n         //--&gt;\n      &lt;/script&gt;      \n   &lt;/head&gt;\n    \n   &lt;body&gt;     \n      &lt;form name = \"myform\" action = \"\"&gt;\n         &lt;p&gt; click the Button to View Result:&lt;/p&gt;\n         &lt;input type = \"button\" value = \"Get Cookie\" onclick = \"ReadCookie()\"/&gt;\n      &lt;/form&gt;      \n   &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> \n<p>运行：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwVS5\" src=\"http://localhost:8060/tup/2020/4/23/2ab5777167f84cb691a5352a16e42c8e.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<h4>改变 cookie</h4> \n<p>通过使用 JS，咱们可以像创建 <code>cookie</code> 一样改变它：</p> \n<pre><code>document.cookie = \"username=Steve Jobs; expires=Sun, 31 Dec 2017 12:00:00 UTC; path=/\";\n</code></pre> \n<p>这样旧 <code>cookie</code> 会被覆盖。</p> \n<p>事例：</p> \n<pre><code>&lt;html&gt;\n   &lt;head&gt;   \n      &lt;script type = \"text/javascript\"&gt;\n         &lt;!--\n            function WriteCookie() {\n               var now = new Date();\n               now.setMonth( now.getMonth() + 1 );\n               cookievalue = escape(document.myform.customer.value) + \";\"\n                \n               document.cookie = \"name=\" + cookievalue;\n               document.cookie = \"expires=\" + now.toUTCString() + \";\"\n               document.write (\"Setting Cookies : \" + \"name=\" + cookievalue );\n            }\n         //--&gt;\n      &lt;/script&gt;      \n   &lt;/head&gt;\n    \n   &lt;body&gt;\n      &lt;form name = \"myform\" action = \"\"&gt;\n         Enter name: &lt;input type = \"text\" name = \"customer\"/&gt;\n         &lt;input type = \"button\" value = \"Set Cookie\" onclick = \"WriteCookie()\"/&gt;\n      &lt;/form&gt;      \n   &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> \n<p>运行：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwVT3\" src=\"http://localhost:8060/tup/2020/4/23/5e57a4f0648648fdb39be5fcb53ba9d6.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<h4>删除 cookie</h4> \n<p>删除 <code>cookie</code> 非常简单，不必指定 <code>cookie</code> 值：直接把 <code>expires</code> 参数设置为过去的日期即可：</p> \n<pre><code>document.cookie = \"username=; expires=Thu, 01 Jan 1970 00:00:00 UTC; path=/;\";\n</code></pre> \n<p>应该定义 <code>cookie</code> 路径以确保删除正确的 <code>cookie</code>。如果不指定路径，有些浏览器不会让咱们删除 <code>cookie</code>。</p> \n<p>事例：</p> \n<pre><code>&lt;html&gt;\n   &lt;head&gt;   \n      &lt;script type = \"text/javascript\"&gt;\n         &lt;!--\n            function WriteCookie() {\n               var now = new Date();\n               now.setMonth( now.getMonth() - 1 );\n               cookievalue = escape(document.myform.customer.value) + \";\"\n                \n               document.cookie = \"name=\" + cookievalue;\n               document.cookie = \"expires=\" + now.toUTCString() + \";\"\n               document.write(\"Setting Cookies : \" + \"name=\" + cookievalue );\n            }\n          //--&gt;\n      &lt;/script&gt;      \n   &lt;/head&gt;\n    \n   &lt;body&gt;\n      &lt;form name = \"myform\" action = \"\"&gt;\n         Enter name: &lt;input type = \"text\" name = \"customer\"/&gt;\n         &lt;input type = \"button\" value = \"Set Cookie\" onclick = \"WriteCookie()\"/&gt;\n      &lt;/form&gt;      \n   &lt;/body&gt;\n&lt;/html&gt;\n</code></pre> \n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\" rel=\"nofollow noreferrer\">Fundebug</a>。</strong></p> \n<hr> \n<h2>交流</h2> \n<p>文章每周持续更新，可以微信搜索「 大迁世界 」第一时间阅读和催更（比博客早一到两篇哟），本文 GitHub <a href=\"https://github.com/qq449245884/xiaozhi\" rel=\"nofollow noreferrer\">https://github.com/qq449245884/xiaozhi</a> 已经收录，整理了很多我的文档，欢迎Star和完善，大家面试可以参照考点复习，另外关注公众号，后台回复<strong>福利</strong>，即可看到福利，你懂的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020353567?w=800&amp;h=400\" src=\"http://localhost:8060/tup/2020/4/23/e9ba04412e9d463fadc6ca263890330f.jpg\" alt=\"\" title=\"\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/7965e0ebc54746f0b38152ffd2278adb.jpg', '1c5851dc916d4e70a60f0c957f548876', '049b3bd76c1e49ccbe48b36197e77f76', 'd79254c4ca5e45dca9d484307c935281,63c4e1e7ec204b43a62065a3ced4c2ce,1d0ffae0426e4e6e8add67530ec689b4', '0', '3', '1', '2020-04-23 10:26:04', '2020-04-23 10:26:04');
INSERT INTO `tb_recommend` VALUES ('70276cfba0e643fcbcda3cdfb075bd52', 'Zoom 数万私人视频被公开，被曝加密技术造假', '向华盛顿邮报爆料的是美国国家安全局的前研究员帕特里克·杰克逊（Patrick Jackson），他爆料称在开放的云存储空间中一次性搜到了 15000 个 Zoom 视频。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFCGD\" src=\"http://localhost:8060/tup/2020/4/23/b5dfdfb9074946efb6c027b37310b31e.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>因新冠疫情，视频会议软件使用量激增，其中的代表性产品 Zoom 的日活跃用户，从去年 12 月份的 1000 万人激增到现在的2亿人。</p> \n<p>但近日，华盛顿邮报报道 Zoom 存在的重大安全漏洞，数以万计的私人 Zoom 视频被上传至公开网页，任何人均可在线围观。</p> \n<p>向华盛顿邮报爆料的是美国国家安全局的前研究员帕特里克·杰克逊（Patrick Jackson），他爆料称在开放的云存储空间中一次性搜到了 15000 个 Zoom 视频。</p> \n<p>此外，加拿大多伦多大学公民实验室的研究人员对软件进行了逆向工程，发现该公司在加密方案上有虚假宣传。Zoom 称其会议使用 AES-256 加密，但实际上只在 ECB 模式下使用了简单的 AES-128 密钥，密钥由 Zoom 的服务器产生。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFCGA\" src=\"http://localhost:8060/tup/2020/4/23/cbbd166756db402ea44a864d565a6d2c.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>Zoom 还声称使用端对端加密，但事实上距离真正的端对端加密还比较遥远，该公司对端对端加密的定义与通常的定义有差距。</p> \n<p>种种安全事件频繁发生后，Zoom 受到了全球用户的批评。因此，Zoom 宣布暂停任何新功能的开发，以专注于安全和隐私问题。企业创始人袁征表示，该公司为解决安全疑虑而采取如下的步骤：</p> \n<ul> \n <li>对加密方法进行说明</li> \n <li>删除从 iOS 应用到脸书的共享代码</li> \n <li>发布与 Mac 相关问题的修复程序</li> \n <li>删除与领英网站（LinkedIn）之连接，以防止不必要的数据泄露</li> \n <li>发布如何避免成为「Zoom 轰炸」受害者的说明</li> \n</ul> \n<p>在接下来的 90 天内，该公司又计划：</p> \n<ul> \n <li>暂时冻结新功能开发，以专注于安全和隐私</li> \n <li>与独立专家进行审查，以了解新客户所需的新安全功能</li> \n <li>编写有关数据请求的透明度报告</li> \n <li>扩大其“漏洞赏金”计划</li> \n <li>每周举行一次网络研讨会，以提供隐私和资讯安全更新</li> \n</ul> \n<p>袁征坦言，如果安全问题不解决，甚至会考虑开源 Zoom 代码。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFxVM\" src=\"http://localhost:8060/tup/2020/4/23/942650d4c4144c42ae3ebff3a0f7c6f2.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/ec10e6846338414098d602743086e403.jpg', '3f69fcc9b13843d1910b3dac597f5215', '19eb3dd59ef8430d9f637d97449fc417', '2a81fe886a0a41028a7b13cb4915b40f,f3eb17e6e5664a97af3e9b1fca12b286', '0', '3', '1', '2020-04-23 10:59:11', '2020-04-23 10:59:11');
INSERT INTO `tb_recommend` VALUES ('73ebfb7d319d4972be2d7c6a9bcd747a', '通过语音检测新冠？新方式还有待验证', '近日两所知名的高校，卡内基梅隆大学（CMU）和剑桥大学，不约而同地使用了一种新的方式：通过 AI 系统分析声音信息，来检测被 COVID-19 感染的风险。', '<p>新冠肺炎疫情在海外迎来了爆发之势，而检测手段的繁琐和设备的短缺，也成了疫情防控过程中的拦路虎。</p> \n<p>许多媒体都报道，检测不力是多国无法有效追踪疫情，导致病例迅速激增的一个原因。</p> \n<p>近日两所知名的高校，卡内基梅隆大学（CMU）和剑桥大学，不约而同地使用了一种新的方式：通过 AI 系统分析声音信息，来检测被 COVID-19 感染的风险。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXpf\" src=\"http://localhost:8060/tup/2020/4/23/eb9cb3ceb8e543babf23fb1bc709f2af.jpg\" alt=\"截屏2020-04-02 上午10.48.07.png\" title=\"截屏2020-04-02 上午10.48.07.png\"></span></p> \n<h2>CMU：几分钟就可给出结果</h2> \n<p>在卡内基梅隆大学给出的测试器 COVID Voice Detector 中，需要完成几种声音的录制，仅需几分钟即可得到感染风险的结果。</p> \n<p>进入网站注册后，需要进入个人情况的填写。其中涉及的信息包括人种，年龄，健康状况，是否确诊或确诊过等信息。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrE\" src=\"http://localhost:8060/tup/2020/4/23/e9a1ae91ecd8457981767efbf40e88de.jpg\" alt=\"b8280c86652752577b4e6b1fe53cfd99.jpg\" title=\"b8280c86652752577b4e6b1fe53cfd99.jpg\"></span></p> \n<ul>\n <li><em>需要填入身体健康状况的信息</em></li>\n</ul> \n<p>上述信息填写完毕后，需要录制咳嗽、英文元音的发音，数字和字母表朗读等语音信息。</p> \n<p>而模型经过了确诊者和正常测试者的一些数据的训练，可以对新输入的声音进行分类的匹配。</p> \n<p>最终会返回一个分数，表明所录制的声音，和收集到的 COVID-19 患者数据相比，感染特征相符合的程度。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrK\" src=\"http://localhost:8060/tup/2020/4/23/7c849db9d15c4e61a50904f1011bb11a.jpg\" alt=\"截屏2020-04-02 上午10.49.36.png\" title=\"截屏2020-04-02 上午10.49.36.png\"></span></p> \n<ul>\n <li><em>最终呈现出来的结果</em></li>\n</ul> \n<p>为了让系统的判断尽可能准确，必须拥有足够多的训练数据，而且还要涵盖多元化的信息，研究人员正在倡议更多的志愿者参与进来。</p> \n<p>此外，他们称系统具备可扩展性，如声音来自其他呼吸系统疾病的人，算法就可学到该类疾病的声音特征。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrL\" src=\"http://localhost:8060/tup/2020/4/23/e5701d43c6ca49fea5a46cffcc8a525d.jpg\" alt=\"0003KQXQA9IRA768-C324-F4.jpg\" title=\"0003KQXQA9IRA768-C324-F4.jpg\"></span></p> \n<ul>\n <li><em>新闻报道中的音源也被采用</em></li>\n</ul> \n<p>测试器地址：<br><a href=\"https://cvd.lti.cmu.edu/cvd/\" rel=\"nofollow noreferrer\">https://cvd.lti.cmu.edu/cvd/</a></p> \n<p>发稿前访问该网站，提示因为在更新和维护的原因暂时关闭，相关负责人表示，有望在本周末再次上线。</p> \n<h2>剑桥大学：还仅仅是收集数据</h2> \n<p>和卡内基梅隆大学类似，剑桥大学也推出了用声音检测 COVID-19 的项目。但稍有不同的是，剑桥大学仅仅还是只是收集数据，还不提供检测的结果。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrN\" src=\"http://localhost:8060/tup/2020/4/23/f1ee0492c944421583262559ebd3c13c.jpg\" alt=\"截屏2020-04-09 下午6.15.38.png\" title=\"截屏2020-04-09 下午6.15.38.png\"></span></p> \n<ul>\n <li><em>项目网页的提示：贡献声音，助力科学，保证安全</em></li>\n</ul> \n<p>系统收集数据的方式相差不大，需要填写基本资料和医疗信息，并通过手机麦克风采集语音信息作为训练样本。</p> \n<p>同样地，系统也会调查用户的身体健康情况，比如是否发烧、是否感染过等信息。需录制的项目有呼气声、咳嗽声和阅读文本的声音。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrV\" src=\"http://localhost:8060/tup/2020/4/23/407b5f985e104d2f83abf88826006320.jpg\" alt=\"截屏2020-04-09 下午6.30.50.png\" title=\"截屏2020-04-09 下午6.30.50.png\"></span></p> \n<ul>\n <li><em>需要录制的声音内容</em></li>\n</ul> \n<p>项目负责人 Cecilia Mascolo 教授解释说，由于该项研究的大型数据集非常少，为了提供更好的算法以用于早期检测，需要收集到足够多的数据量。</p> \n<p>他还表示到，数据量累计之后，即便没有足够冠状病毒阳性病例，还可以找到与其他呼吸道疾病有关的信息。</p> \n<p>该项目的最终目标是，开发出可自动检测疾病的机器学习算法，以可推广使用的检测 App 来呈现。</p> \n<p>项目地址：<br><a href=\"https://www.covid-19-sounds.org/zh/index.html\" rel=\"nofollow noreferrer\">https://www.covid-19-sounds.o...</a></p> \n<h2>语音取证，能够精准识别吗？</h2> \n<p>两个项目彼此独立，但使用的方式和原理拥有着一些共性。而对于项目的具体原理，双方却都没有给出太多信息。</p> \n<p>卡内基梅隆大学的研究团队，曾长期致力于语音取证技术。他们认为人的声音，受到器官机构状况和健康程度的影响，能揭示生理，心理甚至医学数据。</p> \n<p>受肺炎病毒感染的患者，肺部会发生一些病变，其呼吸模式等参数会受到影响，导致发出的声音出现一些异常特征，对算法而言是一个能够抓取的特点。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrX\" src=\"http://localhost:8060/tup/2020/4/23/eebc0718ccf0481896f1e8f28dbeb5f0.jpg\" alt=\"farge-004.jpg\" title=\"farge-004.jpg\"></span></p> \n<ul>\n <li><em>医生正在检查肺部 CT </em></li>\n</ul> \n<p>剑桥大学的团队，也是由多位专家、博士组成。在项目介绍中他们表示到，新冠肺炎作为一种呼吸系统疾病，感染疾病的人发出的声音会存在一些特征，包括声音，呼吸间隔和咳嗽声等。</p> \n<p>虽然这种方式很新颖，但两个项目都处于初期阶段，在 BBC 的一篇报道中，还使用了「Teething problems」（出牙痛，指代初期困难）来表明此方案的困难。</p> \n<p>不过在之前的研究中，用声音来诊断疾病的案例中，出现了一些成功的案例。</p> \n<p>比如，成立于 2014 年的 ResApp Health，就专注使用机器学习算法来分析咳嗽声，来诊断和测量各种慢性和急性疾病的严重程度。目前取得了一些成果，可对哮喘，肺炎和毛细支气管炎等疾病进行判断。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrZ\" src=\"http://localhost:8060/tup/2020/4/23/5cfd33d4d2694e96ae6f47fdcc552a8d.jpg\" alt=\"ResApp.png\" title=\"ResApp.png\"></span></p> \n<ul>\n <li><em>目前应用已经成熟并投入了使用</em></li>\n</ul> \n<p>另一个叫 Sonde 的公司，在去年还获得了一项语音诊断的美国专利。他们开发的一个平台，通过感测和分析语音中的细微变化，可从讲话中判断患者的健康状况，辅助医生进行诊断抑郁症、痴呆症等病症。</p> \n<p>用声音诊断 COVID-19 的项目，相比已经成熟的研究，除了时间紧迫之外，关于疾病的声音数据也少之又少，所以难度和挑战也不小。</p> \n<h2>存在争议，是否有效还待验证</h2> \n<p>对于两个项目来说，研究没有经过 FDA 或 CDC 的批准，还不能用于正规的医学诊断。</p> \n<p>现阶段的最大目的在于，呼吁更多人（包括确诊者和正常人）贡献自己的声音数据，以推动该研究项目的进展，进而去帮助对新冠等流行病的控制。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXsj\" src=\"http://localhost:8060/tup/2020/4/23/420c42c5ccd04140b706263b3c907304.jpg\" alt=\"GKkKVJoSiLgonX6eCRZGcB (1).jpeg\" title=\"GKkKVJoSiLgonX6eCRZGcB (1).jpeg\"></span></p> \n<ul>\n <li><em>手机使用检测程序时的界面</em></li>\n</ul> \n<p>关于这些研究，也出现了是否会有效的争议。比如不同地区疫情的程度不同，会不会带来模型的分析偏见。而简单的语音录制，虽然方便但收集的语音信息，是否达到了科学分析的要求。</p> \n<p>现在看来，关于系统的专业性和准确度，还需要等待后续的验证。在此之前，没人知道前方的道路，但另一方面，这正是科学探索的魅力所在。</p>', null, 'http://localhost:8060/tup/2020/4/23/0499aa8463be4bff89f666ef6517eddd.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', 'cbad2058b4014634aec6515f4adbef0d', 'c7913adc87544598962767df48355990,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-23 10:55:48', '2020-04-23 10:55:48');
INSERT INTO `tb_recommend` VALUES ('7407612ca11c4abb924fbc6e83e09add', 'GitHub 屏蔽微软工程师的开源项目，因存在伊朗外部贡献者？', '近日，微软 UX 首席工程师 Rob Eisenberg 在 Twitter 上抱怨，他创建的开源 JS 框架 Aurelia 被 GitHub 禁止访问。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbESA2\" src=\"http://localhost:8060/tup/2020/4/23/62a6db9ccf604e2a92d8522d8b6ef7b8.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>近日，微软 UX 首席工程师 Rob Eisenberg 在 Twitter 上抱怨，他创建的开源 JS 框架 Aurelia 被 GitHub 禁止访问。</p> \n<p>该事件发生后引起全球开发者的广泛关注，一是 GitHub 竟然连自己家的项目都封，还有一个原因就是，此次封禁的原因竞是因为项目包含伊朗的外部贡献者？</p> \n<h2>GitHub 高管回应：这是一次严重失误</h2> \n<p>发现项目被封禁后，该工程师向 GitHub 提起了申诉，并在社交媒体进行曝光抗议：</p> \n<blockquote>\n “因为我们有两名来自伊朗的外部贡献者（非 GH 组织成员），所以 GitHub 自动标记并封禁了账号。”\n</blockquote> \n<p>随着事件的发酵，该账号已被恢复使用，GitHub CEO Nat Friedman 和 COO Erica Brescia 也在社交媒体表示“这是一次严重失误”。</p> \n<p>Friedman 在 HackerNews 上回复表示，他们将进行调查确保不会再次发生。他解释说，如果一家公司在美国有业务，它们都必须遵守美国的贸易制裁规定。这包括了与美国银行基础设施的互动。因此将公司总部设在其它地方并没有帮助。</p> \n<p>根据美国的政策，GitHub 不能向被制裁国家提供商业性质的服务，但 Github 仍然向被制裁的伊朗、叙利亚和古巴等国提供了公开的软件代码库的访问。</p> \n<h2>GitHub：除非真正需要，否则我们不会删除您的任何内容</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbESCg\" src=\"http://localhost:8060/tup/2020/4/23/a434ec46a7144f23852444261f8a96dc.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>就在二月底，GitHub 发布了其 2019 年透明度报告，详细介绍了如何以及向谁披露用户信息，以及基于什么理由删除或阻止了内容。</p> \n<p>GitHub 政策高级经理 Abby Vollmer 表示，该组织赞成在平台上保留尽可能多的内容，而不是删除信息。GitHub 确实相信内容审核会引起自由表达的担忧。</p> \n<p>沃尔默说：“对内容删除政策保持透明，并尽可能严格地限制内容删除，这是联合国言论自由专家对平台的建议，这些平台旨在 促进在线内容审核中的自由表达。”</p> \n<p>“在GitHub，我们都做到了。”</p> \n<p>但从这件事情来说，GitHub 真的做到了么...</p> \n<blockquote>\n 拓展阅读： \n <br>\n <a href=\"https://segmentfault.com/a/1190000021842599\">GitHub：除非真正需要，否则我们不会删除您的任何内容</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCLmI\" src=\"http://localhost:8060/tup/2020/4/23/f48b5a124ccb4c358d5872d9527c3054.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/d4d44340776b4498bebb26be4f25df4d.jpg', '6fbfa4aaad3a43458f21c8acf0038ac5', '19eb3dd59ef8430d9f637d97449fc417', '634b81d655c74cb0adc4d0aa362b8819,9d5eb002705648e2bc3d345fa34a8191,f3eb17e6e5664a97af3e9b1fca12b286', '0', '3', '1', '2020-04-23 10:59:22', '2020-04-23 10:59:22');
INSERT INTO `tb_recommend` VALUES ('783c7711a66a42e5b611ff930a561a55', '用JavaScript 实现酷炫的粒子追踪动画', '你是否曾经想过用花哨的、闪闪发光的粒子动画分吸引你网站用户的注意力，而同时又在后台加载一些数据呢？幸运的是，没有必要用诸如 Three.js 之类的 3D 库进行非常深入的图形编程。相反，你需要的是 CSS 和 JavaS...', '<blockquote>\n 作者：Anna Prenzel\n <p>翻译：疯狂的技术宅</p> \n <p>原文：<a href=\"https://www.smashingmagazine.com/2020/04/particle-trail-animation-javascript/\" rel=\"nofollow noreferrer\">https://www.smashingmagazine....</a></p> \n <p><strong>未经允许严禁转载</strong></p> \n</blockquote> \n<p>你是否曾经想过用花哨的、闪闪发光的粒子动画分吸引你网站用户的注意力，而同时又在后台加载一些数据呢？幸运的是，没有必要用诸如 Three.js 之类的 3D 库进行非常深入的图形编程。相反，你需要的是 CSS 和 JavaScript 的一些基本知识以及轻便的动画库（例如 anime.js）。最后我们应该得到以下<a href=\"https://codepen.io/blaustern_fotografie/pen/vYEwwqx\" rel=\"nofollow noreferrer\">结果</a>：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGjde\" src=\"http://localhost:8060/tup/2020/4/23/dcceabec42f34f6eb46a998b67821806.jpg\" alt=\"4-partical-trail-animation-javascript.gif\" title=\"4-partical-trail-animation-javascript.gif\"></span></p> \n<h3>Anime.Js 的下载和集成</h3> \n<p>你可以从<a href=\"https://github.com/juliangarnier/anime/\" rel=\"nofollow noreferrer\">官方 GitHub</a> 下载 anime.js 库。从<a href=\"https://github.com/juliangarnier/anime/tree/master/lib\" rel=\"nofollow noreferrer\"><code>lib/</code></a>文件夹下载文件<em>anime.js</em> 或 <em>anime.min.js</em>。</p> \n<p>在我的例子中，HTML 部分如下所示：</p> \n<pre><code class=\"html\">&lt;!DOCTYPE html&gt;\n&lt;html lang=\"en\" &gt;\n&lt;head&gt;\n  &lt;meta charset=\"UTF-8\"&gt;\n  &lt;title&gt;Anime.js Particles&lt;/title&gt;\n  &lt;!--or use anime.min.js--&gt;\n  &lt;script src=\"anime.js\"&gt;&lt;/script&gt;\n  &lt;link rel=\"stylesheet\" href=\"style.css\"&gt;\n&lt;/head&gt;\n&lt;body&gt;\n&lt;div class=\"anime-container\"&gt;\n&lt;/div&gt;\n&lt;script src=\"script.js\"&gt;&lt;/script&gt;\n&lt;/body&gt;\n&lt;/html&gt;</code></pre> \n<p>CSS 文件 <em>styles.css</em> 用来定义页面和每个粒子的背景色。位置是必需要设置的，稍后我们可以用 CSS 属性 <code>left</code> 和 <code>top</code> 在页面上自由放置粒子。</p> \n<pre><code class=\"css\">body {\n background-color: hsl(30, 3%, 14%);\n}\n.anime-container {\n  position: relative;\n}\n \n.anime-container .dot{\n  position: absolute;\n  /*draw particles as circles:*/\n  border-radius: 50%;\n  background-color: hsl(60, 100%, 80%);\n}</code></pre> \n<h3>生成粒子</h3> \n<p>顾名思义，粒子动画由许多遵循特定模式在空间中移动的小粒子组成。在动画开始之前，同时生成所有粒子。</p> \n<p><em>对于以下解释，<a href=\"https://animejs.com/documentation/\" rel=\"nofollow noreferrer\">anime.js的官方文档</a> 对你非常有用。</em></p> \n<p>在我的例子中，粒子位于阿基米德螺旋上。屏幕上粒子的 x 和 y 位置（在 CSS 中又称为 <code>left</code> 和 <code>top</code>）是根据其在螺旋上的位置 angle 来计算的：</p> \n<pre><code class=\"css\">x=a*angle*cos(angle)\ny=a*angle*sin⁡(angle)</code></pre> \n<p>角度以及螺旋的长度由参数 <code>l</code> 确定。通过参数 <code>a</code>，你可以控制螺旋线的密度。</p> \n<pre><code class=\"javascript\">var container = document.querySelector(\".anime-container\");\nvar n = 15;\nvar a = 20;\nvar l = 110;\nfor (var i = 0; i &lt;= l; i += 1) {\n  var angle = 0.1 * i;\n  //shift the particles to the center of the window \n  //by adding half of the screen width and screen height\n  var x = (a*angle) * Math.cos(angle) + window.innerWidth / 2;\n  var y = (a*angle) * Math.sin(angle) + window.innerHeight / 2;\n  var dot = document.createElement(\"div\");\n  dot.classList.add(\"dot\");\n  container.appendChild(dot);\n  var size = 5;\n  dot.style.width = size + \"px\";\n  dot.style.height = size + \"px\";\n  dot.style.left = x + \"px\";\n  dot.style.top = y + \"px\";\n  dot.style.backgroundColor = \"hsl(60, 100%, 80%)\";\n  }\n}</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGjdq\" src=\"http://localhost:8060/tup/2020/4/23/1dbd1a14d98a456aba62b38a4aec899d.jpg\" alt=\"5-partical-trail-animation-javascript.png\" title=\"5-partical-trail-animation-javascript.png\"></span></p> \n<p>这样，我们得到一个螺旋，每个位置只有一个粒子，但是只有在每个位置生成一个以上的粒子时，才能实现真正的拖尾效果。为了使轨迹显得浓密，各个粒子的位置必须略有不同。动画库为此提供了实用的辅助函数：</p> \n<pre><code class=\"markup\">anime.random(minValue, maxValue);</code></pre> \n<p>粒子的大小也随机变化：</p> \n<pre><code class=\"javascript\">for (var i = 0; i &lt;= l; i += 1) {\n  var angle = 0.1 * i;\n  //shift particles to the center of the window \n  //by adding half of the screen width and screen height\n  var x = (a*angle) * Math.cos(angle) + window.innerWidth / 2;\n  var y = (a*angle) * Math.sin(angle) + window.innerHeight / 2;\n  var n = 15;\n  \n  //create n particles for each angle\n  for (var j = 0; j &lt; n; j++) {\n    var dot = document.createElement(\"div\");\n    dot.classList.add(\"dot\");\n    container.appendChild(dot);\n    var size = anime.random(5, 10); \n    dot.style.width = size + \"px\";\n    dot.style.height = size + \"px\";\n    dot.style.left = x + anime.random(-15, 15) + \"px\";\n    dot.style.top = y + anime.random(-15, 15) + \"px\";\n    dot.style.backgroundColor = \"hsl(60, 100%, 80%)\";\n  }\n}</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGjds\" src=\"http://localhost:8060/tup/2020/4/23/02797ab203604e079d3739c9ada94c35.jpg\" alt=\"3-partical-trail-animation-javascript.png\" title=\"3-partical-trail-animation-javascript.png\"></span></p> \n<p>在这里，你可以尝试中间结果：</p> \n<p>请参阅 CodePen 上的 js 粒子动画 wip：<a href=\"https://codepen.io/smashingmag/pen/JjdqBve\" rel=\"nofollow noreferrer\">https://codepen.io/smashingma...</a>。</p> \n<p>在动画开始之前，所有粒子都必须是不可见的。所以我将添加：</p> \n<pre><code class=\"javascript\">dot.style.opacity = \"0\";</code></pre> \n<h3>粒子动画</h3> \n<h4>动画的基本设置</h4> \n<p>我的动画的基本设置如下：</p> \n<ul> \n <li>动画要连续重复（loop:true），</li> \n <li>移动是线性的（但是你可以尝试<a href=\"https://animejs.com/documentation/#linearEasing\" rel=\"nofollow noreferrer\">不同的值</a>），</li> \n <li>目标是所有带有 \"dot\" 类的元素。</li> \n</ul> \n<pre><code class=\"javascript\">anime({\n  loop: true,\n  easing: \"linear\",\n  targets: document.querySelectorAll(\".dot\"),\n});</code></pre> \n<p>在下一步中，我将为目标的各种 CSS 属性设置动画。 CSS 动画的基本步骤可以在 anime.js 文档中<a href=\"https://animejs.com/documentation/#cssProperties\" rel=\"nofollow noreferrer\">属性相关的章节</a>中找到。</p> \n<h4>动画效果</h4> \n<p>这是我们第一个属性动画的样子，其中所有粒子在 50 毫秒内逐渐可见：</p> \n<pre><code class=\"javascript\">anime({\n  loop: true,\n  easing: \"linear\",\n  targets: document.querySelectorAll(\".dot\"),\n  opacity: { value: 1, duration: 50}\n});</code></pre> \n<p>现在，我将揭示导致粒子螺旋运动的技巧！想法是使粒子以一定的时间延迟（例如，以 2 ms 的间隔）可见。首先使螺旋中间的粒子可见，然后从内到外的使所有其他粒子可见。 anime.js 的 <a href=\"https://animejs.com/documentation/#staggeringBasics\" rel=\"nofollow noreferrer\">stagger 函数</a>非常适合此功能。我认为，交错是该库的最大优势之一，它使你可以实现出色的效果。</p> \n<pre><code class=\"javascript\">opacity: { value: 1, duration: 50, delay: anime.stagger(2) }</code></pre> \n<p>为了产生飞行轨迹的错觉，粒子一旦出现就必须开始缓慢消失。幸运的是 anime.js 提供了<a href=\"https://animejs.com/documentation/#propertyKeyframes\" rel=\"nofollow noreferrer\">属性的关键帧符号</a>：</p> \n<pre><code class=\"javascript\">opacity: [\n    { value: 1, duration: 50, delay: anime.stagger(2) },\n    { value: 0, duration: 1200}\n  ],</code></pre> \n<p>在这里，你可以看到中间结果：</p> \n<p>请参阅 CodePen 上的 js 粒子动画 wip 2：<a href=\"https://codepen.io/smashingmag/pen/ZEGNjjv\" rel=\"nofollow noreferrer\">https://codepen.io/smashingma...</a>。</p> \n<h4>动画大小</h4> \n<p>彗星踪迹出现时应该比消失前更大。为此，我让粒子在 500ms 内缩小到 2px 的直径。选择与不透明度动画相同的时间延迟很重要，这样每个粒子只有在出现后才开始收缩：</p> \n<pre><code class=\"javascript\">width: { value: 2, duration: 500, delay: anime.stagger(2) },\nheight: { value: 2, duration: 500, delay: anime.stagger(2) },</code></pre> \n<h4>个体运动</h4> \n<p>粒子动画的典型特征是粒子的独立性、不可预测的行为。最后，我通过沿 <code>x</code> 和 <code>y</code> 方向的运动将粒子带入动画：</p> \n<pre><code class=\"javascript\">translateX: {\n    value: function() {\n      return anime.random(-30, 30);\n    },\n    duration: 1500,\n    delay: anime.stagger(2)\n  },\n\ntranslateY: {\n    value: function() {\n      return anime.random(-30, 30);\n    },\n    duration: 1500,\n    delay: anime.stagger(2)\n  }</code></pre> \n<p>同样，重要的是运动开始的时间应该与粒子的出现有相同的时间延迟。</p> \n<p>另外在这种情况下，绝对有必要用 <code>functions</code> 来计算 <code>translateX</code> 和 <code>translateY</code> 的值。在这里，我们将参数用作<a href=\"https://animejs.com/documentation/#functionBasedParameters\" rel=\"nofollow noreferrer\">基于函数的参数</a>，其<em>值是针对每个目标</em>单所独确定的。否则所有目标移动相同的量都会是相同的（尽管是随机确定的）。</p> \n<h3>最后的想法</h3> \n<p>你可以在此处查看最终结果：</p> \n<p>请参阅查看 CodePen 上的 js 动画粒子：<a href=\"https://codepen.io/smashingmag/pen/yLNWqRP\" rel=\"nofollow noreferrer\">https://codepen.io/smashingma...</a>。</p> \n<p>你可以通过简单地调整这些值来根据自己的喜好修改动画。关于最后的修饰有一个小技巧：现在我们熟悉了基于函数的参数，可以稍微改善动画的透明度：</p> \n<pre><code class=\"javascript\">opacity: [\n    { value: 1, duration: 50, delay: anime.stagger(2) },\n    { value: 0, duration: function(){return anime.random(500,1500);}}\n],</code></pre> \n<p>现在分别为每个粒子设置粒子消失之前的持续时间。这能够使动画在视觉上更加精致。</p> \n<p>我建议你访问 <a href=\"https://codepen.io/collection/XLebem/\" rel=\"nofollow noreferrer\">CodePen</a>，在这里你可以看到更多令人印象深刻的例子。</p>', null, 'http://localhost:8060/tup/2020/4/23/c419927e758646c0bd186e22212b8523.jpg', '692c6787030d4b8882077b2ab9279c52', '049b3bd76c1e49ccbe48b36197e77f76', 'd79254c4ca5e45dca9d484307c935281,63c4e1e7ec204b43a62065a3ced4c2ce,390975aa461b45efb6a730eef605b94e', '0', '3', '1', '2020-04-23 10:25:28', '2020-04-23 10:25:28');
INSERT INTO `tb_recommend` VALUES ('80f3b9cf7d05417bbf27ddc26697c459', '精读《React Error Boundaries》', '精读《React Error Boundaries》', '<p><a href=\"https://github.com/dt-fe/weekly/blob/v2/148.%20%E7%B2%BE%E8%AF%BB%E3%80%8AReact%20Error%20Boundaries%E3%80%8B.md\" rel=\"nofollow noreferrer\">精读《React Error Boundaries》</a></p>', null, null, '1894b118d35d44cb8fe8009529c4154b', '049b3bd76c1e49ccbe48b36197e77f76', 'd79254c4ca5e45dca9d484307c935281,63c4e1e7ec204b43a62065a3ced4c2ce', '0', '3', '1', '2020-04-23 10:26:26', '2020-04-23 10:26:26');
INSERT INTO `tb_recommend` VALUES ('815d69f75464475592aa281538592a8c', '六个好用的前端开发在线工具', '老实说，虽然我做过许多前端开发，但我并不擅长 CSS。当我陷入困境时，[EnjoyCSS] 是我的大救星。EnjoyCSS 提供了一个简单的交互界面，帮助我设计元素，然后自动输出相应的 CSS 代码。', '<p>[Mahdhi Rezvi] 原作，翻译转载自 <a href=\"https://nextfe.com/\" rel=\"nofollow noreferrer\">New Frontend</a> （缩进段落为译者附注）。</p> \n<p>网上可以找到前端开发社区贡献的大量工具，这篇文章列出了我最喜欢的一些工具，这些工具给我的工作带来了许多便利。</p> \n<h2>1. EnjoyCSS</h2> \n<p>老实说，虽然我做过许多前端开发，但我并不擅长 CSS。当我陷入困境时，[EnjoyCSS] 是我的大救星。EnjoyCSS 提供了一个简单的交互界面，帮助我设计元素，然后自动输出相应的 CSS 代码。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhJp\" src=\"http://localhost:8060/tup/2020/4/23/30a6f9feb1e44e7498bff52d4619eaf6.jpg\" alt=\"EnjoyCSS 首页\" title=\"EnjoyCSS 首页\"></span></p> \n<blockquote>\n EnjoyCSS 可以输出 CSS、LESS、SCSS 代码，并支持指定需要支持哪些浏览器及其最低版本。开发简单页面时用起来比较方便，但不太适合复杂一点的前端项目（这类项目往往需要引入 CSS 框架）。\n</blockquote> \n<h2>2. Prettier Playground</h2> \n<p>[Prettier] 是一个代码格式化工具，支持格式化 JavaScript 代码（包括 [ES2017]、[JSX]、[Angular]、[Vue]、[Flow]、[TypeScript] 等）。Prettier 会移除代码原本的样式，替换为遵循最佳实践的标准化、一致的样式。IDE 大多支持 Prettier 工具，不过 Prettier 也有<a href=\"https://prettier.io/playground/\" rel=\"nofollow noreferrer\">在线版本</a>，让你可以在浏览器里格式化代码。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhJG\" src=\"http://localhost:8060/tup/2020/4/23/8b08cd0a27874247b52adbab308fa41a.jpg\" alt=\"Prettier Playground 分左右两栏，左边是原始代码，右边是格式化后的代码\" title=\"Prettier Playground 分左右两栏，左边是原始代码，右边是格式化后的代码\"></span></p> \n<blockquote>\n 如果工作电脑不在手边，使用移动端设备或者临时借用别人的电脑查看代码时，Prettier Playground 非常好用。相比在 IDE 或编辑器下使用 Prettier，个人更推荐通过 \n <a href=\"https://prettier.io/docs/en/precommit.html\" rel=\"nofollow noreferrer\">git pre-commit hook</a> 配置 Prettier：hook 可以保证整个团队使用统一的配置，免去各自分别配置 IDE 或编辑器的麻烦。如果是老项目，hook 还可以设置只格式化有改动的单个文件甚至有改动的代码段，避免在 IDE 或编辑器下使用 Prettier 时不小心格式了大量代码，淹没了 commit 的主要改动，让 review 代码变得十分痛苦。\n</blockquote> \n<h2>3. Postman</h2> \n<p>[Postman] 一直在我的开发工具箱里，测试后端 API 接口时非常好用。GET、POST、DELETE、OPTIONS、PUT 这些方法都支持。毫无疑问，你应该使用这个工具。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhJM\" src=\"http://localhost:8060/tup/2020/4/23/d44a71d36f224818b99a962b5615ec8e.jpg\" alt=\"Postman 界面\" title=\"Postman 界面\"></span></p> \n<blockquote>\n Postman 之外，[Insomnia] 也是很流行的 REST API 测试工具，亮点是支持 [GraphQL]。不过 Postman 从 去年夏天发布的 v7.2 起也支持了 GraphQL。\n</blockquote> \n<h2>4. StackBlitz</h2> \n<p>[Chidume Nnamdi] 盛赞这是每个用户最喜欢的在线 IDE。[StackBlitz] 将大家最喜欢、最常用的 IDE Visual Studio Code 搬进了浏览器。</p> \n<p>StackBlitz 支持一键配置 Angular、[React]、Ionic、TypeScript、RxJS、[Svelte] 等 JavaScript 框架，也就是说，只需几秒你就可以开始写代码了。</p> \n<p>我觉得这个在线 IDE 很有用，特别是可以在线尝试一些样例代码或者库，否则仅仅尝试一些新特性就需要花很多时间在新项目初始化配置上。有了 StackBlitz，无需在本地从头搭建环境，花上几分钟就可以试用一个 NPM 包。很棒，不是吗？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhJS\" src=\"http://localhost:8060/tup/2020/4/23/f5dfd779fe3c4280b41e74e5a3eab319.jpg\" alt=\"StackBlitz 首页\" title=\"StackBlitz 首页\"></span></p> \n<blockquote>\n 微软官方其实也提供了\n <a href=\"https://docs.microsoft.com/en-us/visualstudio/online/overview/what-is-vsonline\" rel=\"nofollow noreferrer\">在线版本的 VSCode</a>，可以在浏览器内使用 VSCode，并且支持开发 Node.js 项目（基于 Azure）。不过 StackBlitz 更专注于优化前端开发体验，界面更加直观一点，也推出了 beta 版本的 Node.js 支持（基于 GCP，需要填表申请）。\n</blockquote> \n<h2>5. Bit.dev</h2> \n<p>软件开发的基本原则之一就是代码复用。代码复用减少了开发量，让你不用从头开发组件。</p> \n<p>这正是 [Bit.dev] 做的事，分享可重用的组件和片段，降低开发量，加速开发进程。</p> \n<p>除了公开分享，它还支持在团队分享，让团队协作更方便。</p> \n<p>正如 Bit.dev 的口号「组件即设计体系。协同开发更好的组件。」所言，Bit.dev 可以用来创建设计体系，允许团队内的开发者和设计师一起协作，从头搭建一套设计体系。</p> \n<p>Bit.dev 目前支持 [React]、Vue、Angular、Node 及其他 JavaScript 框架。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022432007\" src=\"http://localhost:8060/tup/2020/4/23/14b78e4e121a4ff8aca55f27d9f65789.jpg\" alt=\"在 Bit.dev 上搜索时间选择器组件\" title=\"在 Bit.dev 上搜索时间选择器组件\"></span></p> \n<blockquote>\n 在 Bit.dev 上不仅可以搜索组件，还可以直接查看组件的依赖，浏览组件的代码，甚至在线编辑代码并查看预览效果！选好组件后可以通过 Bit.dev 的命令行工具 \n <code>bit</code> 在本地项目引入组件，也可以通过 npm、yarn 引入组件。\n</blockquote> \n<h2>6. CanIUse</h2> \n<p>[CanIUse]是非常好用的在线工具，可以方便地查看各大浏览器对某个特性的支持程度。</p> \n<p>我过去经常碰到自己开发的应用的一些功能在其他浏览器下不支持的情况。比如我的作品集项目使用的某个特性在 Safari 下不支持，直到项目上线几个月后我才意识到。这些经验教训让我意识到需要检查浏览器兼容性。</p> \n<p>我们来看一个例子吧。哪些浏览器支持 WebP 图像格式？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhJ6\" src=\"http://localhost:8060/tup/2020/4/23/0109e5f209d5433db97b2c9afb87df7e.jpg\" alt=\"通过 CanIUse 查看 WebP 的兼容性\" title=\"通过 CanIUse 查看 WebP 的兼容性\"></span></p> \n<p>如你所见，Safari 和 IE 目前不支持 WebP。这意味着需要为不兼容的浏览器提供回退选项，比如：</p> \n<pre><code class=\"html\">&lt;picture&gt;\n    &lt;source srcset=\"img/awesomeWebPImage.webp\" type=\"image/webp\"&gt;\n    &lt;source srcset=\"img/creakyOldJPEG.jpg\" type=\"image/jpeg\"&gt;\n    &lt;img src=\"img/creakyOldJPEG.jpg\" alt=\"Alt Text!\"&gt;\n&lt;/picture&gt;</code></pre> \n<blockquote>\n CanIUse 还可以在命令行下使用，例如，在命令行下查看 WebP 图像格式的浏览器兼容性：\n <code>caniuse webp</code>（运行命令前需要事先通过 \n <code>npm install -g caniuse-cmd</code> 安装命令行工具。\n <p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhKf\" src=\"http://localhost:8060/tup/2020/4/23/5ca88de61347433cba0345cf753c0a12.jpg\" alt=\"codecaniuse webp/code 的命令行输出结果\" title=\"codecaniuse webp/code 的命令行输出结果\"></span></p> \n</blockquote>', null, 'http://localhost:8060/tup/2020/4/23/50eeb6ea6e1044239d5be9d42565f3a1.jpg', 'f53014d680884163a5bd5ce762e90cdf', '049b3bd76c1e49ccbe48b36197e77f76', '63c4e1e7ec204b43a62065a3ced4c2ce,2ab3859eef1a47078a59550cb6f541b2,7b39e36da1f543c995c416f3d2950cf5,17e1a68483b94e4e99ab348cd15d98c5,f9a5763f0e7f47a99e6d6f8f962f1d92', '0', '3', '1', '2020-04-23 10:26:10', '2020-04-23 10:26:10');
INSERT INTO `tb_recommend` VALUES ('83769af7f4a34f8598a93536e7a2e3dc', 'Apache毕业贺礼—Apache ShardingSphere跌宕起伏的开源之路', '潘娟，京东数科高级DBA，Apache ShardingSphere PMC张亮，京东数科数据研发负责人，Apache ShardingSphere VP，Apache Dubbo PMC，人气开源项目Elastic-Job作者', '<p>作者介绍</p> \n<blockquote>\n 潘娟，京东数科高级DBA，Apache ShardingSphere PMC\n <p>张亮，京东数科数据研发负责人，Apache ShardingSphere VP，Apache Dubbo PMC，人气开源项目Elastic-Job作者</p> \n</blockquote> \n<h3>前序</h3> \n<pre><code>从Sharding-JDBC到Apache ShardingSphere；\n从轻量级的分库分表中间件到完整闭环的分布式数据库中间件平台；\n从2016年1月的第一行代码到现今的300K+行代码；\n从寥寥无几的关注到GitHub 10K+的star；\n从无人问津的社区到100+位贡献者；\n从公司内部的应用类库到100+的采用公司列表；\n从寻找mentor到顺利成为Apache顶级项目。\n……</code></pre> \n<p><strong>Apache ShardingSphere团队核心初创人员将讲述这其中的跌宕起伏，并以时间轴为线索为你呈现它开源之路背后的故事。</strong></p> \n<h3>项目介绍</h3> \n<p>Apache ShardingSphere是一套开源的分布式数据库中间件解决方案组成的生态圈，它由3款相互独立，却又能够混合部署配合使用的产品组成。它们均提供标准化的数据分片、分布式事务和数据库治理功能，可适用于如Java同构、异构语言、云原生等各种多样化的应用场景，核心功能如1-1所示。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGgW4\" src=\"http://localhost:8060/tup/2020/4/23/522de20d3b1e40338aeb41ffc23af592.jpg\" alt=\"image.png\" title=\"image.png\"></span><br>1-1 ShardingSphere核心功能架构图</p> \n<p>Apache ShardingSphere由三个子项目组成，形成一个完整的数据库解决方案，合称 J.P.S. 生态系统。</p> \n<p><strong>ShardingSphere-JDBC</strong>：定位为轻量级Java框架，在Java的JDBC层提供额外服务。 它使用客户端直连数据库，以jar包形式提供服务，无需额外部署和依赖，可理解为增强版的JDBC驱动，完全兼容JDBC和各种ORM框架。</p> \n<p><strong>ShardingSphere-Proxy</strong>：定位为透明化的数据库代理端，提供封装了数据库二进制协议的服务端版本，用于完成对异构语言的支持。 目前提供MySQL/PostgreSQL版本，它可以使用任何兼容MySQL/PostgreSQL协议的访问客户端操作数据，对DBA更加友好。</p> \n<p><strong>ShardingSphere-Sidecar（TODO）</strong>：定位为Kubernetes的云原生数据库代理，以Sidecar的形式代理所有对数据库的访问。 通过无中心、零侵入的方案提供与数据库交互的的啮合层，即Database Mesh，又可称数据网格。</p> \n<p><strong>Apache ShardingSphere的亮点主要包括：</strong></p> \n<ol> \n <li>完整的分布式数据库解决方案：提供数据分片、分布式事务、数据弹性迁移、数据库和数据治理等核心能力。</li> \n <li>独立的SQL解析引擎：支持多SQL方言的完全独立化SQL解析引擎，能够脱离ShardingSphere独立使用。</li> \n <li>可插拔微内核：所有的SQL方言、数据库协议和功能都能够通过SPI的可插拔方式加载或卸载，微内核甚至在未来可以运行于无任何功能的空白环境中。</li> \n</ol> \n<h3>为Apache做准备</h3> \n<p>找寻mentor是进入Apache基金的最初且最重要的一步。在了解了Apache基金会的运作方式后，我们便踏上了找寻mentor之旅。参加各种与开源相关的分享会或meetup，借此来认识Apache的member。但是，事情却并不顺利。多次的尝试，多次的接触换来的只是口头的认可。这段时间我们确实倍感压力和焦虑，甚至打算以后再说，一切随缘。</p> \n<p>后来一个契机，我们认识了吴晟和华为的姜宁。吴晟是Apache SkyWalking项目的VP，在开源领域有丰富的经验。他和ShardingSphere的前身Sharding-JDBC很有渊源，Sharding-JDBC项目原型也有他参与设计，因此，他最终作为ShardingSphere的PPMC一同建设社区。在参与ShardingSphere社区建设的这一年多的时间里，他又陆续担任了多个Apache孵化项目的Mentor，并在今年被选举为Apache Member；而姜宁同样是一位热心又有经验的老手，是国内最资深的Apache Member之一，在与他交流的过程中，终于让我们看到一些希望，他也最终成为了我们的mentor。再后来，团队VP张亮又前去上海参加HDC大会，认识了我们的另一位mentor—Craig L Russell，Craig当时是Apache的秘书长，所有的SGA、ICLA等法务文件均由他负责签署。在ShardingSphere孵化的过程中，Craig当选了Apache软件基金会的主席。他友善而和气，给予了我们很多有关社区规范的实用建议，也愿意助我们一臂之力；第三位mentor则是由Apache RocketMQ的核心成员冯嘉担任；最后由Roman Shaposhnik担任项目的Champion，为项目寻找导师之旅画上完美句号。</p> \n<p>至今还记得我们当时的欣喜和激动。之前的无助、徘徊、失落在这一瞬间柳暗花明。每个进入Apache基金会的项目，一定都有自己的故事。尤其对于中国的项目来说，语言与地域的障碍让我们雪上加霜。好在有越来越多的来自于中国的项目进入了Apache基金会，也能看到越来越多的华人活跃在Apache的邮件列表里，还有ALC Beijing的建立让参与门槛不断降低，这对想要参与的国内朋友来说，确实是个good news！</p> \n<h3>进入Apache孵化器</h3> \n<p>为了正式进入Apache孵化器，项目代码、社区、文档等都需要进行一系列的规范和整理。这确实是个琐碎但很重要的事情。</p> \n<p>代码层面，合规操作是首要原则。我们梳理第三方依赖的许可协议， 确保满足Apache软件许可协议（ASL）合规的要求；社区方面，我们开始由中文转变成英文；文档方面则需要我们准备英文文档，并准备相关的proposal。由于项目最开始的目标就是进入Apache基金会，所以在项目初期，依赖就尽可能地简单，社区相对规范，文档在不断翻译。不打无准备之仗，这些提前的准备让这部分工作进展顺利，而项目获得Apache域名的那一刻，大家才真切感受到所有付出得到了最有价值的回报。</p> \n<p>除了学习写规范代码，团队成员也开始学习Apache的规范、运作方式、英文沟通渠道等细节。我们开始了解到如何关注社区，什么是consensus decision，如何用异步方式进行邮件沟通。特别是邮件列表的学习非常重要，你可以在其中找到历史问题记录、合规的解决方案、优秀的案例等。</p> \n<h3>Apache way的探索</h3> \n<p>很多人认为只要代码开放，就叫做开源。但其实，这仅仅只是开源旅程的第一步。如何构建一个活跃的社区，如何理解Apache way，是一个更为重要的话题。ShardingSphere在进入Apache孵化器初期并未能完全理解Apache way，并且由于过度注重代码风格，以至于参与门槛较高、社区活跃度平平。起初，我们并不知道问题出在哪里，迷茫了很长一段时间，直到在跟Apache的member不断交流的过程中才渐渐意识到问题所在，因此社区发起了有关committer bar的讨论，见图1-2。这是社区建设之路的转折点，因为从此community over code的理念开始逐渐渗入人心，并指导我们的行动。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGgXH\" src=\"http://localhost:8060/tup/2020/4/23/4e891a4964a14547ad97c5f68564c736.jpg\" alt=\"image.png\" title=\"image.png\"></span><br>1-2 Committer bar讨论邮件</p> \n<p>仔细阅读Apache way的关注点：<strong>Earned Authority, Community of Peers, Open Communications, Consensus Decision Making, Responsible Oversight。你会发现它一直在强调合规、开放、平等、协作，为的就是建立合规且活跃的项目社区，尽可能地做到让更多的人参与，平等沟通，推动项目发展，促进个人成长。</strong></p> \n<p>秉持这个理念，ShardingSphere开始在多维度进行调整，</p> \n<ul> \n <li>代码：规整代码结构，划分模块功能，提供项目可插拔能力，从而允许用户局部参与某一模块的同时，尽量不破坏整体代码结构。</li> \n <li>心态：开放的心态，编制社区任务，鼓励社区朋友参与，相关PPMC或Committer积极提供指导和帮助。</li> \n <li>规范：梳理文档和代码规范，并提供详细的订阅、参与指南，大范围促进用户自主进行社区贡献。</li> \n <li>交流：鼓励社区尽可能使用邮件和Issue进行讨论从而公开讨论内容，同时针对较为细节的讨论则放在微信群里进行。此外，官方公众号还会介绍社区的进展、Release、刊登技术文章等。</li> \n <li>合作：与其他Apache社区建立联系、增加沟通，从合作交流中进行学习和发展。</li> \n</ul> \n<p>在孵化期间，Apache ShardingSphere先后与Apache SkyWalking、Apache ServiceComb进行项目的合作与集成，不仅彼此的产品功能更加完善，还增加了社区成员之间的交流。此外，还与Apache DolphinScheduler（Incubating）和Apache IoTDB（Incubating）举办了co-meetup，详见图1-3。还与Apach pulsar和Apache APISIX（Incubating）的核心成员们进行了多次交流和探讨。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGgX0\" src=\"http://localhost:8060/tup/2020/4/23/be6fe05cc5d740b1a98e9b6f79620327.jpg\" alt=\"image.png\" title=\"image.png\"></span><br>1-3 co-meetup</p> \n<p>经过时间的积累，社区已有了质的变化。从社区的邮件讨论、GitHub的数据展示中，你会发现ShardingSphere的社区开始真正变得活跃与多元化。图1-4展示了ShardingSphere在Apache孵化器一年多的社区数据变化。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGgYk\" src=\"http://localhost:8060/tup/2020/4/23/2fd50deb6586499bae9b310e4b7aadcd.jpg\" alt=\"image.png\" title=\"image.png\"></span><br>1-4 社区数据变化</p> \n<p>社区与贡献者之间的依赖和互赢也在整个过程中体现的淋漓尽致。对于贡献者来说，他们会在这个开源社区中与其他人交流、协作。而这个持续的过程，将带来以下成果，</p> \n<ul> \n <li>扩大人际交友圈</li> \n <li>不断学习与成长</li> \n <li>提高自己的技术影响力</li> \n <li>拓宽职业渠道</li> \n <li>结合兴趣，享受过程</li> \n</ul> \n<p>而对于社区来说，这个相互帮助和沟通的过程则会，</p> \n<ul> \n <li>拓展项目的功能</li> \n <li>收获活跃多元化的生态圈</li> \n <li>增加项目知名度</li> \n <li>获得社区的可持续发展</li> \n</ul> \n<p>从这个角度来看，不断探索Apache way不也是希望出现这样一种共赢而互助的局面吗？<strong>Please remember community over code。</strong></p> \n<h3>从孵化器毕业</h3> \n<p>所有孵化器的项目最终都希望能走向TLP（Top Level Project）。在mentor的指导、PPMC的探索、committer和contributor的支持与付出下，ShardingSphere开始筹备Apache孵化器毕业。依据Apache的成熟度评估模型图1-5，在以下几个方面评估社区和项目是否成熟。其实在Apache项目社区的初建阶段，我们建议大家就在这几个方面发力，因为这是官方给予的毕业标准及指导方针。以此为方向，探索属于各自项目的独特社区运作方式，也可谓是百花齐放。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGgYt\" src=\"http://localhost:8060/tup/2020/4/23/f06e8caea5f04a28bb4d4ca57177c211.jpg\" alt=\"image.png\" title=\"image.png\"></span><br>1-5 Apache项目成熟度评估模型</p> \n<p>经历Release、社区建设、Apache member的指导、meetup举办等一系列事件，ShardingSphere终于在社区发起了毕业讨论，开始接受Apache member及所有Apache成员的指导和评估。虽然最终以10 +1 binding votes，6 +1 non-binding votes和 no -1 or +/-0 votes通过毕业投票，但过程也是一波三折。</p> \n<p>即便是经过1年多的社区建设，项目基本成熟，但面对毕业还是有很多工作要合乎毕业规范。例如确认商标是否可使用、完成项目官网有关Apache brand和trademark的陈述、网站符合Apache way等。在这个投票期间，由于官网存在fork me on github的slogan，而这一问题一直频繁出现并且没有结论，所以其他Apache成员借此单独开辟了thread来讨论这一问题，查看<a href=\"https://lists.apache.org/api/source.lua/r84959a94322697b6b21cc003d4abb5a9a5b4e43e8ebeea223a0ccdfb@%3Cgeneral.incubator.apache.org%3E\" rel=\"nofollow noreferrer\">Email List</a>了解详情。虽说这一举让ShardingSphere被成功推到前台，间接提高了项目的曝光，却也能看出Apache对于第三方独立、禁止参与商业行为的重视和严苛。<strong>可喜可贺的是，2020年4月16日，Apache ShardingSphere最终通过基金会董事会决议，加入了TLP行业！</strong></p> \n<h3>未来的路</h3> \n<p>从Apache孵化器毕业成为TLP，对ShardingSphere来说，并不是一个结束，而是另一个开始。在产品功能上，ShardingSphere将继续在分布式数据库中间件平台上深耕，打磨出以“分布式”为核心的数据库中间件生态圈，从而提供完整的解决方案，如图1-6所示。从社区角度讲，ShardingSphere仍将继续活跃社区，鼓励更多朋友成为社区的committer和contributor。所以，我们欢迎大家关注ShardingSphere，并加入到社区来，与更多知己结伴前行。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGgYv\" src=\"http://localhost:8060/tup/2020/4/23/2cac821b3fa54724a503ab68635ca31f.jpg\" alt=\"image.png\" title=\"image.png\"></span><br>1-6 Apache ShardingSphere生态圈</p> \n<p><strong>未来之路不可预测，但立足当下，眺望未来，初心未改，即便亦步亦趋，也愿一苇以航！</strong></p> \n<h3>Apache ShardingSphere committer列表</h3> \n<h4>Mentor</h4> \n<p>Craig L Russell<br>冯嘉，阿里巴巴<br>姜宁，华为</p> \n<h4>PMC</h4> \n<p>张亮，京东数科<br>潘娟，京东数科<br>赵俊，京东数科<br>张永伦，京东数科<br>陈清阳，翼支付<br>曹昊，海南新软<br>马晓光<br>杜红军，领创智信<br>杨翊，京东数科<br>吴晟，tetrate.io<br>高洪涛，tetrate.io</p> \n<h4>Committer</h4> \n<p>李亚，九个小海豹<br>颜志一，DaoCloud<br>董宗磊，京东零售<br>孙海生，瓜子<br>王奇，京东零售<br>欧阳文，一卡易<br>蒋晓峰，阿里巴巴<br>王光远<br>秦金卫，京东数科<br>岳令<br>赵亚楠</p> \n<blockquote>\n 官网：\n <a href=\"https://shardingsphere.apache.org/\" rel=\"nofollow noreferrer\">https://shardingsphere.apache.org/</a> \n</blockquote>', null, 'http://localhost:8060/tup/2020/4/23/2cb74a8a6aa94674b42c95676b737928.jpg', '1c5851dc916d4e70a60f0c957f548876', '19eb3dd59ef8430d9f637d97449fc417', 'f3eb17e6e5664a97af3e9b1fca12b286,fb364499fe3f4b5bb7f0442e2fe0df82,d900360696e74d06b4c4ae08198d3c11,83f62facb3b943ffa8e46abd1ebc64d9,2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-23 10:58:54', '2020-04-23 10:58:54');
INSERT INTO `tb_recommend` VALUES ('86ad9e82611e496db66c9ab9becda5ef', '2017-2020历年字节跳动Android面试真题解析', '早在2017年我们就建了第一个字节跳动的面试群给大家讨论面试的东西。期间累计有1825个群友分享了自己的Android面试真经，并提供了参考答案。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990298\" src=\"http://localhost:8060/tup/2020/4/23/f5bb919c232442a885d11749172cd655.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>大家好！给大家介绍一下，这是我们持续更新整理的2017-2020字节跳动历年Android面试真题解析！</strong></p> \n<p>早在2017年我们就建了第一个字节跳动的面试群给大家讨论面试的东西。期间累计有1825个群友分享了自己的Android面试真经，并提供了参考答案。</p> \n<p>这其中就有很多成员已经斩获今日头条、抖音等岗位的offer。有很多成员面试虽然失败了，但也分享了很多失败的经验教训。在这里一并对他们表示感谢！正是因为大家的奉献和支持，让我们的这份面试真题解析已经累计<strong>下载1082万次！</strong></p> \n<hr> \n<p><strong>字节跳动Android面试真题解析目录如下：</strong></p> \n<p><strong>第一章 计算机基础面试题</strong> </p> \n<p>1、网络面试题 1</p> \n<p>2、操作系统面试题 （⭐⭐⭐） 21</p> \n<p>3、数据库面试题 （⭐） 23</p> \n<p><strong>第二章 数据结构和算法面试题</strong></p> \n<p>数据结构与算法 25</p> \n<p><strong>第三章 Java面试题</strong></p> \n<p>1、Java基础面试题 33</p> \n<p>2、Java并发面试题 81</p> \n<p>3、Java虚拟机面试题 （⭐⭐⭐） 121</p> \n<p><strong>第四章 Android面试题</strong></p> \n<p>1、Android基础面试题 （⭐⭐⭐） 140</p> \n<p>2、Android高级面试题 （⭐⭐⭐） 208</p> \n<p><strong>第五章 其他扩展面试题</strong></p> \n<p>1、Kotlin （⭐⭐） 346</p> \n<p>2、大前端 （⭐⭐） 346</p> \n<p>3、脚本语言 （⭐⭐） 349</p> \n<p><strong>第六章 非技术面试题</strong></p> \n<p>1、高频题集 （⭐⭐⭐） 350</p> \n<p>2、次高频题集 （⭐⭐） 352</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990300\" src=\"http://localhost:8060/tup/2020/4/23/8ee8b4aa57b64733af5e7b3d51ea15ed.jpg\" alt=\"\" title=\"\"></span></p> \n<p>字节跳动Android面试真题解析目录</p> \n<p>每个问题我们都附上1个标准参考答案，都是我们反复摸索消化（真心花了很多时间），觉得写的比较好的文章作为答案。这样就可以节省大家自己去搜索的时间，把时间用在正确的东西上。</p> \n<p>其实我们也可以直接以简易的、群友分享的答案写出来，但是这并帮助不了同学们去深刻理解，三思之下还是采用标准答案作为参考。不明白或者想通俗了解的，可<strong>加入我们字节跳动面试交流q群</strong>一起讨论，加入我们字节跳动Android面试群给大家讨论长篇or精简的答案，希望大家理解。下面是我们每章知识点的概述：</p> \n<p><strong>第一章 计算机基础面试题</strong></p> \n<p>字节跳动面试也会考察计算机基础，主要考察我们是否系统的学习了操作系统和计算机组成原理，因为只有我们看完操作系统后才能系统的认识计算机的原理。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990297\" src=\"http://localhost:8060/tup/2020/4/23/53d5ef8041b54e288ef3b443a1c3fe65.jpg\" alt=\"\" title=\"\"></span></p> \n<p>第一章 计算机基础面试题</p> \n<p><strong>第二章 数据结构和算法面试题</strong></p> \n<p>对于算法面试准备，无疑就是刷《剑指Offer》+ LeetCode 效果最佳。刷《剑指Offer》是为了建立全面的算法面试思维，打下坚实的基础，刷LeetCode则是为了不断强化与开阔我们自己的算法思想。这两块 CS-Notes 中已经实现地很完美了，建议大家将《剑指Offer》刷完，然后再至少刷100道LeetCode题目以上。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990299\" src=\"http://localhost:8060/tup/2020/4/23/95ccec40b0864c1faaed595f5e676030.jpg\" alt=\"\" title=\"\"></span><br>《剑指Offer》</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990301\" src=\"http://localhost:8060/tup/2020/4/23/4f15481916594f3183676f8e69291781.jpg\" alt=\"\" title=\"\"></span><br>LeetCode中文版</p> \n<p><strong>第三章 Java面试题</strong></p> \n<p>Java 是 Android App 开发默认的语言, Android Framework 也是默认使用 Java 语言，熟练掌握 Java 语言是 Android 开发者的必备技能。当然也是我们字节跳动青睐的考题选择方向！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990302\" src=\"http://localhost:8060/tup/2020/4/23/ad180451847740e1b2b3f03dca9812ad.jpg\" alt=\"\" title=\"\"></span></p> \n<p>第三章 Java面试题</p> \n<p><strong>第四章 Android面试题</strong></p> \n<p>Android面试分为基础面试题+高级面试题两个部分。其中高级面试题部分的性能优化、Framework、三方源码属于我们考察的重点、难点方向！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990303\" src=\"http://localhost:8060/tup/2020/4/23/ab0f459fbd084b2c9a6a3245f1ca8453.jpg\" alt=\"\" title=\"\"></span></p> \n<p>第四章 Android面试题</p> \n<p><strong>第五章、第六章 其他扩展面试题+非技术面试题</strong></p> \n<p>Google 几年前就开始走“Kotlin First”的路线，目前很多官方的文档和 Demo 都是使用 Kotlin 语言作为默认，Kotlin 的重要性不言而喻。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990305\" src=\"http://localhost:8060/tup/2020/4/23/887c3c15ac784c41b0548844ba07d07c.jpg\" alt=\"\" title=\"\"></span></p> \n<p>第五章、第六章 其他扩展面试题+非技术面试题</p> \n<p><strong>简历制作+春招困惑解答+经典HR面试解析</strong></p> \n<p>以上是我们整理总结字节跳动Android面试遇到的历年真题解析，希望对大家有帮助；同时我们经常也会遇到很多关于简历制作，职业困惑、HR经典面试问题回答等有关面试的问题。同样的我们搜集整理了全套简历制作、春招困惑、HR面试等问题解析，我们在q群中，都提供了专业的解答（群号码：936903570）。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990307\" src=\"http://localhost:8060/tup/2020/4/23/0d2a4a4f66ec480f9605beb6c783325f.jpg\" alt=\"img\" title=\"img\"></span></p> \n<h5><strong>如何做好面试突击，规划学习方向？</strong></h5> \n<p>面试题集可以帮助你查漏补缺，有方向有针对性的学习，为之后进大厂做准备。但是如果你仅仅是看一遍，而不去学习和深究。那么这份面试题对你的帮助会很有限。最终还是要靠资深技术水平说话。</p> \n<p>网上学习 Android的资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。建议先制定学习计划，根据学习计划把知识点关联起来，形成一个系统化的知识体系。</p> \n<p>学习方向很容易规划，但是如果只通过碎片化的学习，对自己的提升是很慢的。</p> \n<p>我们搜集整理过这几年字节跳动，以及腾讯，阿里，华为，小米等公司的面试题，把面试的要求和技术点梳理成一份大而全的“ Android架构师”面试 Xmind（实际上比预期多花了不少精力），包含知识脉络 + 分支细节。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990306\" src=\"http://localhost:8060/tup/2020/4/23/75fb470e08194ab3bf5652b9efdf945c.jpg\" alt=\"\" title=\"\"></span></p> \n<p>我们在搭建这些技术框架的时候，还整理了系统的高级进阶教程，会比自己碎片化学习效果强太多；</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990304\" src=\"http://localhost:8060/tup/2020/4/23/233ada593db744b4907a55ad68aad935.jpg\" alt=\"\" title=\"\"></span></p> \n<h4> <strong>上述所有资料！均可免费分享！</strong><a href=\"http://wpa.qq.com/msgrd?v=3&amp;uin=2677509374&amp;site=qq&amp;menu=yes\" rel=\"nofollow noreferrer\">点击我</a> 领取</h4> \n<p><strong>扫码进群！联系管理员免费获取！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990308\" src=\"http://localhost:8060/tup/2020/4/23/b2ce4f3615574c25b8984b9567c43d3d.jpg\" alt=\"img\" title=\"img\"></span></p> \n<p>qq群号码：<strong>936903570</strong></p>', null, 'http://localhost:8060/tup/2020/4/23/cc226f49c7d74a2eb491bc89f1b0a2c4.jpg', '1894b118d35d44cb8fe8009529c4154b', '819ad72c1efe450f9d7affc135a4b457', '8dfc62f227ae4076888ea4872e03cddd,2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-23 10:37:01', '2020-04-23 10:37:01');
INSERT INTO `tb_recommend` VALUES ('871730714a234a26b5da4a4ac13ba43a', '开发导致的内存泄露问题，这样排查不背锅！', '前些日子小组内安排值班，轮流看顾我们的服务，主要做一些报警邮件处理、Bug排查、运营issue处理的事。工作日还好，无论干什么都要上班的，若是轮到周末，那这一天算是毁了。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1587279210548&amp;di=6e80b971c8e87bd50c54e3cb0f18ed8d&amp;imgtype=0&amp;src=http%3A%2F%2Fphotogallery.oss-cn-hangzhou.aliyuncs.com%2Fphoto%2F1257842289342004%2F31298367648c343e946438fabf54e8f47f3d9.png\" src=\"http://localhost:8060/tup/2020/4/23/227f41bfe29d449d8244ece6a427dd46.jpg\" alt=\"\" title=\"\"></span><br>作者：枕边书<br>来源：<a href=\"https://zhenbianshu.github.io\" rel=\"nofollow noreferrer\">https://zhenbianshu.github.io</a></p> \n<p>前些日子小组内安排值班，轮流看顾我们的服务，主要做一些报警邮件处理、Bug排查、运营issue处理的事。工作日还好，无论干什么都要上班的，若是轮到周末，那这一天算是毁了。</p> \n<p>不知道是公司网络广了就这样还是网络运维组不给力，网络总有问题，不是这边交换机脱网了，就是那边路由器坏了，还偶发地各种超时，而我们灵敏地服务探测服务总能准确地抓住偶现的小问题，给美好的工作加点料。</p> \n<p>好几次值班组的小伙伴们一起吐槽，商量着怎么避过服务保活机制，偷偷停了探测服务而不让人发现（虽然也并不敢）。</p> \n<p>前些天我就在周末处理了一次探测服务的锅。本文会持续修订，大家可以继续关注。</p> \n<p><strong>一、问题</strong></p> \n<p><strong>网络问题？</strong></p> \n<p>晚上七点多开始，我就开始不停地收到报警邮件，邮件显示探测的几个接口有超时情况。 多数执行栈都在：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtIRDs0nRLnvnPlj8Vn03m2hXLEdP0WSVpfF2x49Sdb4b3vw1CncE5W07To1NJFRtPictkXvdZYhibQ/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"http://localhost:8060/tup/2020/4/23/aaf7f32f9840427abc0f4301de1e47b1.jpg\" alt=\"\" title=\"\"></span></p> \n<p>这个线程栈的报错我见得多了，我们设置的HTTP DNS超时是1s，connect超时是2s，read超时是3s，这种报错都是探测服务正常发送了HTTP请求，服务器也在收到请求正常处理后正常响应了，但数据包在网络层层转发中丢失了，所以请求线程的执行栈会停留在获取接口响应的地方。</p> \n<p>这种情况的典型特征就是能在服务器上查找到对应的日志记录。而且日志会显示服务器响应完全正常。与它相对的还有线程栈停留在Socket connect处的，这是在建连时就失败了，服务端完全无感知。</p> \n<p>我注意到其中一个接口报错更频繁一些，这个接口需要上传一个4M的文件到服务器，然后经过一连串的业务逻辑处理，再返回2M的文本数据，而其他的接口则是简单的业务逻辑，我猜测可能是需要上传下载的数据太多，所以超时导致丢包的概率也更大吧。</p> \n<p>根据这个猜想，群登上服务器，使用请求的request_id在近期服务日志中搜索一下，果不其然，就是网络丢包问题导致的接口超时了。</p> \n<p>当然这样leader是不会满意的，这个结论还得有人接锅才行。于是赶紧联系运维和网络组，向他们确认一下当时的网络状态。网络组同学回复说是我们探测服务所在机房的交换机老旧，存在未知的转发瓶颈，正在优化，这让我更放心了，于是在部门群里简单交待一下，算是完成任务。</p> \n<p><strong>问题爆发</strong></p> \n<p>本以为这次值班就起这么一个小波浪，结果在晚上八点多，各种接口的报警邮件蜂拥而至，打得准备收拾东西过周日单休的我措手不及。</p> \n<p>这次几乎所有的接口都在超时，而我们那个大量网络I/O的接口则是每次探测必超时，难道是整个机房故障了么？</p> \n<p>我再次通过服务器和监控看到各个接口的指标都很正常，自己测试了下接口也完全OK，既然不影响线上服务，我准备先通过探测服务的接口把探测任务停掉再慢慢排查。</p> \n<p>结果给暂停探测任务的接口发请求好久也没有响应，这时候我才知道没这么简单。</p> \n<p><strong>二、解决</strong></p> \n<p><strong>内存泄漏</strong></p> \n<p>于是赶快登陆探测服务器，首先是top free df三连，结果还真发现了些异常。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtIRDs0nRLnvnPlj8Vn03m2s6Z2l402QuSYCBxXktgCeDDJwhJo77ic41I2icVFU9VZq6MZ5mgkyN7A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"http://localhost:8060/tup/2020/4/23/ccc626e86a5c4c238412c94c05e6cb08.jpg\" alt=\"\" title=\"\"></span></p> \n<p>我们的探测进程CPU占用率特别高，达到了900%。</p> \n<p>我们的Java进程，并不做大量CPU运算，正常情况下，CPU应该在100~200%之间，出现这种CPU飙升的情况，要么走到了死循环，要么就是在做大量的GC。</p> \n<p>使用jstat -gc pid [interval]命令查看了java进程的GC状态，果然，FULL GC达到了每秒一次。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtIRDs0nRLnvnPlj8Vn03m217j4BOTocRpY1X5sGVTQnn29Ls1c6FDDUxLgibsoAy3RXDjtRlW8iaNg/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"http://localhost:8060/tup/2020/4/23/4690ebf9e1b64272b49c103acaff4887.jpg\" alt=\"\" title=\"\"></span></p> \n<p>这么多的FULL GC，应该是内存泄漏没跑了，于是使用jstack pid &gt; jstack.log保存了线程栈的现场，使用jmap -dump:format=b,file=heap.log pid保存了堆现场，然后重启了探测服务，报警邮件终于停止了。</p> \n<p><strong>jstat</strong></p> \n<p>jstat是一个非常强大的JVM监控工具，一般用法是：jstat [-options] pid interval</p> \n<p>它支持的查看项有：</p> \n<ul> \n <li>class查看类加载信息</li> \n <li>compile编译统计信息</li> \n <li>gc垃圾回收信息</li> \n <li>gcXXX各区域GC的详细信息，如-gcold</li> \n</ul> \n<p>使用它，对定位JVM的内存问题很有帮助。</p> \n<p><strong>三、排查</strong></p> \n<p>问题虽然解决了，但为了防止它再次发生，还是要把根源揪出来。</p> \n<p><strong>分析栈</strong></p> \n<p>栈的分析很简单，看一下线程数是不是过多，多数栈都在干嘛。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtIRDs0nRLnvnPlj8Vn03m2XvfLNqfWucYHxCaKOfhVPuvzUvRDbnxuFyPDCWvYiccicZDibejvCj9jA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"http://localhost:8060/tup/2020/4/23/d89cae5a537449a4aee66a6a3eca0024.jpg\" alt=\"\" title=\"\"></span></p> \n<p>才四百多线程，并无异常。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtIRDs0nRLnvnPlj8Vn03m2qiaNnhYe6JLJp6X2pTUVQZc7XuzE8hyGxU670122Z7Gh5iaoB92Qu4aw/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"http://localhost:8060/tup/2020/4/23/070957e10e6e41c3b7f3d6d28d906886.jpg\" alt=\"\" title=\"\"></span></p> \n<p>线程状态好像也无异常，接下来分析堆文件。</p> \n<p><strong>下载堆dump文件</strong></p> \n<p>堆文件都是一些二进制数据，在命令行查看非常麻烦，Java为我们提供的工具都是可视化的，Linux服务器上又没法查看，那么首先要把文件下载到本地。</p> \n<p>由于我们设置的堆内存为4G，所以dump出来的堆文件也很大，下载它确实非常费事，不过我们可以先对它进行一次压缩。</p> \n<p>gzip是个功能很强大的压缩命令，特别是我们可以设置-1~-9来指定它的压缩级别，数据越大压缩比率越大，耗时也就越长，推荐使用-6~7，-9实在是太慢了，且收益不大，有这个压缩的时间，多出来的文件也下载好了。</p> \n<p><strong>使用MAT分析jvm heap</strong></p> \n<p>MAT是分析Java堆内存的利器，使用它打开我们的堆文件（将文件后缀改为 .hprof）, 它会提示我们要分析的种类，对于这次分析，果断选择memory leak suspect。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtIRDs0nRLnvnPlj8Vn03m2TiaA993ECLqfuV0fXgrvDMiaUBhab2BlIn05IUgibW4BS1QxPv7icHPxPA/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"http://localhost:8060/tup/2020/4/23/4d2acb3b400241a6a69b40f90bbd9cd6.jpg\" alt=\"\" title=\"\"></span></p> \n<p>从上面的饼图中可以看出，绝大多数堆内存都被同一个内存占用了，再查看堆内存详情，向上层追溯，很快就发现了罪魁祸首。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtIRDs0nRLnvnPlj8Vn03m2QicFvajPEODfFhJq2vdia8EV3IBodOHy5w3aBMBoabCUXgiaKgmST8V5A/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"http://localhost:8060/tup/2020/4/23/4d6a998bc7654c4f99cedae18618c6b7.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>分析代码</strong></p> \n<p>找到内存泄漏的对象了，在项目里全局搜索对象名，它是一个Bean对象，然后定位到它的一个类型为Map的属性。</p> \n<p>这个Map根据类型用ArrayList存储了每次探测接口响应的结果，每次探测完都塞到ArrayList里去分析，由于Bean对象不会被回收，这个属性又没有清除逻辑，所以在服务十来天没有上线重启的情况下，这个Map越来越大，直至将内存占满。</p> \n<p>内存满了之后，无法再给HTTP响应结果分配内存了，所以一直卡在readLine那。而我们那个大量I/O的接口报警次数特别多，估计跟响应太大需要更多内存有关。</p> \n<p>给代码owner提了PR，问题圆满解决。</p> \n<p><strong>四、小结</strong></p> \n<p>其实还是要反省一下自己的，一开始报警邮件里还有这样的线程栈：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/tibrg3AoIJTtIRDs0nRLnvnPlj8Vn03m2c4wm2KickuBea1jA5VwBnwoDU9PzK4Cn0vDLl937qW14hLuxrrjiaf5g/640?wx_fmt=png&amp;tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"http://localhost:8060/tup/2020/4/23/47a50881c9ca4418869048fd1c605dc4.jpg\" alt=\"\" title=\"\"></span></p> \n<p>看到这种报错线程栈却没有细想，要知道TCP是能保证消息完整性的，况且消息没有接收完也不会把值赋给变量，这种很明显的是内部错误，如果留意后细查是能提前查出问题所在的，查问题真是差了哪一环都不行啊。</p>', null, 'http://localhost:8060/tup/2020/4/23/a8ba6b1cf3524bab940ebeb419fa5618.jpg', '692c6787030d4b8882077b2ab9279c52', '91832bd0c3a244fb88c0bca74c0d404d', '55723db96b9f4593bae02bc1e49f1e87,d7416e100af54eb7a4d9274b9a462240,753b5aee3913424e81fe2b5299626d8c,77a7bd638e0a45ec84569ef6b79325c1,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-23 11:01:15', '2020-04-23 11:01:15');
INSERT INTO `tb_recommend` VALUES ('8c9da1745dca4d8daaefb35305e19792', '克隆一个自己的 AI 来上网课', '场景描述：在全球都开启远程办公、远程上课之际，一位外国工程师受不了每天的视频会议，于是用 AI 技术「克隆」了一个自己，替他去开会。而这项技术如果被学生们所用，那么后果……', '<blockquote> \n <strong>场景描述：</strong>在全球都开启远程办公、远程上课之际，一位外国工程师受不了每天的视频会议，于是用 AI 技术「克隆」了一个自己，替他去开会。而这项技术如果被学生们所用，那么后果……\n</blockquote> \n<blockquote> \n <strong>关键词：</strong>远程办公 视频会议&nbsp; AI 克隆\n</blockquote> \n<p>这场席卷全球的疫情，各个公司改为远程办公，各大高校也相继关闭校园，转为在线网课。</p> \n<p>改变了全球的工作方式，也改变了广大学生上课、答辩甚至毕业方式。</p> \n<p>但远程办公、网课的局限性，让一些人借机想出了五花八门的「开小差」手段，比如以下两位优秀的同学：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022403252\" src=\"http://localhost:8060/tup/2020/4/23/f5244ac04ff543f99a60a7d53c0df756.jpg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li><em>假装上课方案 1：录制记笔记视频</em></li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022403253\" src=\"http://localhost:8060/tup/2020/4/23/1a412298a344424a97a2d1f28274db46.jpg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li><em>假装上课方案 2：照片代替本人出镜</em></li>\n</ul> \n<p>不过，这些「小聪明」比起国外一位工程师的高阶翘班方式，还是显得稍微弱了一些。</p> \n<h2>克隆一个自己的 AI，替我开会</h2> \n<p>视频会议并不是适合所有人，Twitter 上有人吐槽现在是活在 Zoom 的世界。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022403254\" src=\"http://localhost:8060/tup/2020/4/23/b812930f358a48b4879b4e8ea7288465.jpg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li><em>一位公司 CEO 在推特吐槽现在每天都活在 Zoom 的世界里</em></li>\n</ul> \n<p>微软 Teams 仅一周就新增 1200 万用户，从 3200 万增长到 4400 万（3 月11 日至 3 月 18 日），单日会议时长突破了 27 亿分钟。</p> \n<p>Zoom 更是在短短两个多月，用户量翻了 20 倍，到达了 2 亿。</p> \n<p>不过，一位外国工程师**&nbsp;Matt Reed近日也发表文章称，无法忍受开不完的 Zoom 会议.</p> \n<p>所以，他脑洞大开，建立了一个AI 驱动的克隆项目 Zoombot，可以克隆一个自己的虚拟形象，参加视频会议。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGagM\" src=\"http://localhost:8060/tup/2020/4/23/a992e4e9fe264b39a4705d42e02475f9.jpg\" alt=\"截屏2020-04-17 上午11.17.30.png\" title=\"截屏2020-04-17 上午11.17.30.png\"></span></p> \n<p>这个虚拟形象，使用最新的 AI 语音识别和文本语音转换，代替他参加 Zoom 会议，不仅可以显示自己的形象，还能回答问题。</p> \n<p>一开始，大家都很难发现出现在会议窗口的这位 Reed 是个「克隆人」，不过，后面他说话生硬的语气瞬间翻了车。</p> \n<p>如果技术再精进一点，恐怕真能蒙混过关。</p> \n<h2>照片、语音识别库、虚拟摄像头，搞定！</h2> \n<p>据 Reed 介绍，这个看起来很高级的「替身项目」，具体实现起来并不难。他还贴心地给出了教程，发表在 GitHub：</p> \n<p><strong><a href=\"https://github.com/mcreed/zoombot\" rel=\"nofollow noreferrer\">https://github.com/mcreed/zoo...</a>&nbsp;</strong></p> \n<p>他写道，事实证明，克隆自己比《西部世界》里的克隆大脑简单多了。</p> \n<p>首先，他打开 Quicktime 并执行 File-&gt; New Movie Recording，在这里他截取了一些自己的视频图像；</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022403255\" src=\"http://localhost:8060/tup/2020/4/23/94ff1e206dbb4c15a3b1c9d794da150e.jpg\" alt=\"\" title=\"\"></span></p> \n<p><em>Reed 分别截取了自己微笑、讲话、思考的图像</em></p> \n<p>接着，基于<strong>Artyom.js 开源库</strong>（一个语音识别 JavaScript 库），构建了一个简单的 Web 应用程序，对其进行扩展开发，以便可以听懂并回复一些简单的对话，比如：</p> \n<pre><code>人类：「你好吗？」\n\nAI：「我很好，谢谢你的问候。」\n\n人类：「你明白了吗？」\n\nAI：「我听不清你的声音。」\n\n人类：「再见。」\n\nAI：「以后再和大家聊。注意安全。」\n</code></pre> \n<p>设置好诸如此类简单的对话后，再使用一个叫做 ManyCam 的软件，以 webapp 为源，建立一个虚拟摄像头，将 Zoom 网络摄像头设置为虚拟摄像头。</p> \n<p>到此为止，万事俱备，只需打开扬声器，启动 Zoombot，然后就可以开心地去做自己喜（mo）欢（yu）的事情。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022403257\" src=\"http://localhost:8060/tup/2020/4/23/c6849ee1a40a465b9ebf53e6895a8e90.jpg\" alt=\"\" title=\"\"></span></p> \n<p>据介绍，Zoombot 项目一共只花费了大约四个小时来构建，而 Reed 又花了大约四个小时进行 Zoom 会议并记录同事们的真实反应（在试用之前并未告知同事）。</p> \n<p>作者 Reed 提醒道：「用替身的诀窍是，在聊完之前就离开会议室，因为一旦进入『我听不清，可以重复一遍吗？』的死循环中，那可就麻烦了。」</p> \n<p>此外，Reed 还指出这个项目的一个优点，就是不必给它一个像「Hey，Siri」这样的唤醒词，就可以开始使用。</p> \n<p>只要外界有语音触发就可以响应，然后配合脸部的动作给出答复。</p> \n<p>不得不说，这位工程师为了摸鱼也是很用心了。</p> \n<h2>不想上网课？克隆一个自己替你上</h2> \n<p>看到这里，有位同学不禁想到：这招完全可以用在网课上啊！（此处手动机智.gif）</p> \n<p>很多学生党深有体会，从寒假就开始陷入被网课支配的恐惧中。因为抵触网课，大家还报复性集体地去各大应用商店给某钉打了一星。</p> \n<p>但不管打几星，网课依然得上。为了逃避网课，不少学生使出了十八般武艺（可回顾前文动图）。甚至有人在小破站上传了网课翘课技巧指南。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022403256\" src=\"http://localhost:8060/tup/2020/4/23/1bfd2b02ce8641b2a21a28fb675b42d8.jpg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li><em>提醒：非专业人士，请勿模仿</em></li>\n</ul> \n<p>不过现在，有了 AI 克隆技术，逃网课也可以变得很高级。</p> \n<p>根据 Reed 提供的「克隆」指南，<strong>只需要 7 步，就能轻轻松松制造虚拟的自己。</strong></p> \n<p>1. 替换 Zoombot 项目里 img 文件夹中的照片；</p> \n<p>2. 将所有这些文件放在运行 https：// 的服务器上，否则 Chrome 会引发安全错误，并且无法访问你的麦克风；</p> \n<p>3. 在 Chrome 中访问你的 Zoombot https：// URL；</p> \n<p>4. 使用左上方的按钮打开 Zoombot，它将开始收听所有这些关键短语； </p> \n<p>5. 使用 Chrome 作为源，创建虚拟网络摄像头。（作者使用 ManyCam 来做到这一点）；</p> \n<p>6. 将你的 Zoom 摄像头设置为「ManyCam 虚拟网络摄像头」；</p> \n<p>7. 打开扬声器，让你的 Zoombot 开始工作吧！**</p> \n<p>如果你能在课前准备本节课的知识点问答数据，交给 Zoombot，就不用担心老师突如其来的提问，背诵课文、拼写单词可能都将不在话下。</p> \n<p>而你就可以睡觉追剧打游戏……那么，要试试吗？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022403258\" src=\"http://localhost:8060/tup/2020/4/23/71ddea4577494895aa1c56893a711b33.jpg\" alt=\"\" title=\"\"></span></p> \n<p>但是，话说回来，最后考试的还是自己，有花这些心思的时间，还是专心听课为好。</p> \n<p>不然，到时候考试留下的泪，就是自己逃课划的水……</p>', null, 'http://localhost:8060/tup/2020/4/23/b3a9be8031d54c389ad0df9219edf684.jpg', 'c56940aa8b004dab84568e86900b2ee6', 'cbad2058b4014634aec6515f4adbef0d', '2a09bf1afefd4d659606f43445741ee3,6bca597168fa41528a5ce2da7f309f13', '0', '3', '1', '2020-04-23 10:55:09', '2020-04-23 10:55:09');
INSERT INTO `tb_recommend` VALUES ('917227d457314974a3a23e02c6a3d8b1', '[宝宝也能看懂的活动篇][30-Day LeetCoding Challenge] 第十二天', '每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：', '<h1>最后一块石头的重量</h1> \n<p>Hi 大家好，我是张小猪。欢迎来到『宝宝也能看懂』系列特别篇 - 官方小活动 『30-Day LeetCoding Challenge』。</p> \n<p>这里是 4 月 12 号的题，也是题目列表中的第 1046 题 -- 『最后一块石头的重量』</p> \n<h2>题目描述</h2> \n<p>有一堆石头，每块石头的重量都是正整数。</p> \n<p>每一回合，从中选出两块 <strong>最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为&nbsp;<code>x</code> 和&nbsp;<code>y</code>，且&nbsp;<code>x</code> &lt;= <code>y</code>。那么粉碎的可能结果如下：</p> \n<ul> \n <li>如果&nbsp;<code>x == y</code>，那么两块石头都会被完全粉碎；</li> \n <li>如果&nbsp;<code>x != y</code>，那么重量为&nbsp;<code>x</code>&nbsp;的石头将会完全粉碎，而重量为&nbsp;<code>y</code>&nbsp;的石头新重量为&nbsp;<code>y-x</code>。</li> \n</ul> \n<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p> \n<p>示例：</p> \n<pre><code class=\"shell\">输入：[2,7,4,1,8,1]\n输出：1\n解释：\n先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，\n再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，\n接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，\n最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。</code></pre> \n<p>提示：</p> \n<ul> \n <li><code>1 &lt;= stones.length &lt;= 30</code></li> \n <li><code>1 &lt;= stones[i] &lt;= 1000</code></li> \n</ul> \n<h2>官方难度</h2> \n<p>EASY</p> \n<h2>解决思路</h2> \n<p>看起来描述挺长，但其实就是一个大值依次互相抵消求最后剩余的小游戏。小猪没有想到什么数学方式，所以就正常的根据游戏流程来求最终结果吧。</p> \n<h3>直接方案</h3> \n<p>由于数字是无序的，所以我们先进行一个排序。然后按照游戏流程，把两个最大值进行抵消，如果存在余量则通过插入排序的方式放入合适的位置。这样直到最后剩余 0 个或者 1 个数字，便得到了结果。</p> \n<p>具体代码如下：</p> \n<pre><code class=\"js\">const lastStoneWeight = stones =&gt; {\n  stones.sort((a, b) =&gt; a - b);\n  while (stones.length &gt; 1) {\n    const x = stones.pop();\n    const y = stones.pop();\n    if (x === y) continue;\n    const d = Math.abs(x - y);\n    let idx = stones.length;\n    while (idx &gt; 0) {\n      if (stones[idx - 1] &lt;= d) break;\n      stones[idx] = stones[idx - 1];\n      --idx;\n    }\n    stones[idx] = d;\n  }\n  return stones.length === 1 ? stones[0] : 0;\n};</code></pre> \n<h3>优化</h3> \n<p>上面的方案最开始使用了一个全局的排序，随后在遍历中也对余量使用了一次基于遍历的插入行为。那么这里优化方案非常明显，我们可以优化排序的方式，从而简化整个流程。</p> \n<p>由于输入数据的范围是 <code>[1, 1000]</code>，所以我们可以非常轻松的用桶排序来完成最初的排序，并且后续的余量处理也会变得更加容易。具体代码如下：</p> \n<pre><code class=\"js\">const lastStoneWeight = stones =&gt; {\n  const buckets = new Uint8Array(1001);\n  let t = 0;\n  for (const val of stones) ++buckets[val];\n  for (let i = 1000; i &gt; 0; --i) {\n    if (!buckets[i]) continue;\n    if (!t) { buckets[i] % 2 &amp;&amp; (t = i); continue; }\n    const d = Math.abs(t - i);\n    t = d &gt;= i ? d : (++buckets[d], 0);\n    --buckets[i++];\n  }\n  return t;\n};</code></pre> \n<h2>总结</h2> \n<p>又是一个基于桶排序完成的优化，在特定的场景下还是『真香』的。希望能帮助到有需要的小伙伴。</p> \n<p>如果觉得不错的话，记得『三连』哦。小猪爱你们哟~</p> \n<h2>相关链接</h2> \n<ul> \n <li><a href=\"https://github.com/poppinlp/leetcode#30-day-leetcoding-challenge\" rel=\"nofollow noreferrer\">活动题目列表</a></li> \n <li><a href=\"https://github.com/poppinlp/leetcode\" rel=\"nofollow noreferrer\">leetcode 题解 repo</a></li> \n <li><a href=\"https://segmentfault.com/blog/zxzfbz\">我的 segmentfault 专栏</a></li> \n <li><a href=\"https://zhuanlan.zhihu.com/zxzfbz\" rel=\"nofollow noreferrer\">我的知乎专栏</a></li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCAAa\" src=\"http://localhost:8060/tup/2020/4/23/56551004c203405c91fcddeb15d93569.jpg\" alt=\"qrcode_green.jpeg\" title=\"qrcode_green.jpeg\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/9daaa83c1ee344c0b9003d9c26a16712.jpg', 'c56940aa8b004dab84568e86900b2ee6', 'cbad2058b4014634aec6515f4adbef0d', '3921afbb134d45f6aa368b52d2670e7b,faf36da502544b51be926ab85450c40d,789898341cc64d45a1f44e26daab183f,63c4e1e7ec204b43a62065a3ced4c2ce,55723db96b9f4593bae02bc1e49f1e87', '0', '3', '1', '2020-04-23 10:55:33', '2020-04-23 10:55:33');
INSERT INTO `tb_recommend` VALUES ('9271ff5a4fd84d99bf300d65eaab9131', 'Proxy 封装微信小程序的异步调用', '上回写到： 没看上回的同学，在这里：在微信小程序中使用 async/await {代码...} {代码...} 这不已经封装过了吗？ 这回写的是不一样的封装。因为，一个小程序里要写好多个 toAsync 调用，真的很烦呐！ 能不能一次...', '<p>上回写到：</p> \n<blockquote>\n 没看上回的同学，在这里：\n <a href=\"https://segmentfault.com/a/1190000021966277\">在微信小程序中使用 async/await</a> \n</blockquote> \n<pre><code class=\"js\">// utils/async.js\n\nfunction wxPromisify(fn) {\n    return async function(args) {\n        return new Promise((resolve, reject) =&gt; {\n            fn({\n                ...(args || {}),\n                success: res =&gt; resolve(res),\n                fail: err =&gt; reject(err)\n            });\n        });\n    };\n}\n\nexport function toAsync(names) {\n    return (names || [])\n        .map(name =&gt; (\n            {\n                name,\n                member: wx[name]\n            }\n        ))\n        .filter(t =&gt; typeof t.member === \"function\")\n        .reduce((r, t) =&gt; {\n            r[t.name] = wxPromisify(wx[t.name]);\n            return r;\n        }, {});\n}</code></pre> \n<pre><code class=\"js\">// pages/somepage/somepage.js\n\nimport { toAsync } = require(\"../../utils/async\");\n\n// ...\n\nconst awx = toAsync([\"login\", \"request\"]);\nawait awx.login();\nawait awx.request({...});</code></pre> \n<p>这不已经封装过了吗？</p> \n<p>这回写的是不一样的封装。因为，一个小程序里要写好多个 <code>toAsync</code> 调用，真的很烦呐！</p> \n<hr> \n<p>能不能一次封装，到处调用？能！把所有用到的方法都在初始化的时候封装起来。可是，难免会有遗漏。</p> \n<p>能不能一次封装，到处调用，还不需要初始化？</p> \n<p>能！祭出 Proxy 大神：</p> \n<pre><code class=\"js\">// utils/asyncjs\n\nfunction wxPromisify(fn) { ... }    // 前面已经定义过了\n\nexport function asyncProxy(target) {\n    return new Proxy(target, {\n        cache: {},\n        get(it, prop) {\n            const aFn = this.cache[prop];\n            if (aFn) { return aFn; }\n            const v = it[prop];\n            if (typeof v !== \"function\") {\n                return v;\n            }\n            return this.cache[prop] = wxPromisify(v);\n        }\n    });\n}</code></pre> \n<pre><code class=\"js\">// app.js\nimport { asyncProxy } from \"./utils/async\";\n\nApp({\n    onLaunch: function() {\n        wx.awx = asyncProxy(wx);\n        // ....\n    }\n})</code></pre> \n<pre><code class=\"js\">// pages/somepage/somepage\n// ...\nconst { awx } = wx;\nawait awx.login();\nawait awx.request({...});</code></pre> \n<hr> \n<p>解释：</p> \n<p>因为 <code>awx</code> 是代理的 <code>wx</code> 对象，调用 <code>awx.login()</code> 的时候，实际是先调用代理的 <code>get(wx, \"login\")</code>，找到用来代替 <code>wx.login</code> 的东西。</p> \n<p>根据上面代码里的逻辑，先从 <code>cache</code> 里找使用 <code>wxPromisify()</code> 封装的结果，若有，直接返回；若没有，先封装成 Promise 网络的函数，存入 <code>cache</code>，再返回。</p> \n<p>直观一点描述，大概是这样：</p> \n<pre><code>awx.login();\n   ^^^^^^\n   get(wx, \"login\")</code></pre> \n<hr> \n<p>请关注公众号<strong>边城客栈</strong>⇗</p> \n<p>看完了先别走，点个赞啊 ⇓，赞赏 ⇘ 也行！</p>', null, null, '3f69fcc9b13843d1910b3dac597f5215', '7b3e40f8b9cc4b7780dc39a71d7f580e', '3b375646301546259a8fb29d74ae4447,631c6273e6474a3d858ca44050a4bc8b,499b6d4decaa4985b8272adc258273fc,6e98a760af6d411d8e06b244853c67e9', '0', '3', '1', '2020-04-23 10:30:06', '2020-04-23 10:30:06');
INSERT INTO `tb_recommend` VALUES ('929c1cd3fcdd42aab7c063cf65eabe59', '小程序跨端图表组件，开箱即用（基于Antv F2）', '因为AntV F2官方实现只有微信原生和支付宝原生，刚好我需要使用跨端小程序组件，于是我就基于AntV F2封装了一个，基于该组件的支付宝小程序已上线，可以扫码体验下。', '<blockquote>\n <a href=\"https://ext.dcloud.net.cn/plugin?id=1659\" rel=\"nofollow noreferrer\">https://ext.dcloud.net.cn/plu...</a>\n</blockquote> \n<h2>组件说明</h2> \n<p>因为AntV F2官方实现只有微信原生和支付宝原生，刚好我需要使用跨端小程序组件，于是我就基于AntV F2封装了一个，基于该组件的支付宝小程序已上线，可以扫码体验下。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391766\" src=\"http://localhost:8060/tup/2020/4/23/cb19f5c5739749e9b9ee5c42b10f91bf.jpg\" alt=\"支付宝小程序码\" title=\"支付宝小程序码\"></span></p> \n<h3>效果图</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391767\" src=\"http://localhost:8060/tup/2020/4/23/0c10e655b37d428a83c1637843e0425e.jpg\" alt=\"效果图\" title=\"效果图\"></span></p> \n<h2>使用说明</h2> \n<blockquote>\n 因为防止不少人踩小程序npm的坑，我已经把最新的f2、f2-context打包进js_sdk（持续更新），开箱即用。\n</blockquote> \n<h3>使用范例</h3> \n<p>使用图表只需要一行代码 <code>&lt;f2 :init=\"initChart\" /&gt;</code></p> \n<pre><code class=\"vue\">&lt;template&gt;\n    &lt;view class=\"container\"&gt;\n        &lt;f2 :init=\"initChart\" /&gt;\n    &lt;/view&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    // 引入组件\n    import f2 from \'@/components/i-uni-f2/f2.vue\'\n    export default {\n        components: {\n            f2\n        },\n        methods: {\n            initChart(F2, config) {\n                // 实例化chart\n                const chart = new F2.Chart(config)\n                // 这里按照F2的调用方式正常使用即可，支持所有图表，以下是DEMO\n                const data = [\n                    { genre: \'Sports\', sold: 275 },\n                    { genre: \'Strategy\', sold: 115 },\n                    { genre: \'Action\', sold: 120 },\n                    { genre: \'Shooter\', sold: 350 },\n                    { genre: \'Other\', sold: 150 }\n                ]\n                chart.source(data);\n                chart.interval()\n                    .position(\'genre*sold\')\n                    .color(\'genre\')\n                // 渲染，然后返回chart\n                chart.render()\n                return chart\n            }\n        }\n    }\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n    .container {\n        width: 100vw;\n        height: 800rpx;\n    }\n&lt;/style&gt;</code></pre> \n<p>关于更多图表实例请查看：<a href=\"https://antv-f2.gitee.io/zh\" rel=\"nofollow noreferrer\">官网文档</a></p> \n<h3>需要注意的点（重要）</h3> \n<ol> \n <li>支付宝小程序需要开启component2编译（在开发者工具点击详情，勾上component2编译，这里主要是因为props：Function的绑定问题，下个版本考虑使用事件+回调方式处理下，近期更新）；</li> \n <li>官方未对微信、支付宝外的小程序平台进行单独的兼容处理，目前其他小程序我使用的是针对微信的兼容方案。</li> \n</ol> \n<h3>有问题可以在下面评论或者联系我</h3> \n<p>邮箱: i@tech.top</p>', null, 'http://localhost:8060/tup/2020/4/23/d6ac8a62fb82465d84381b88ec45aff7.jpg', '5ca4567d892841b087fac5246effac40', '7b3e40f8b9cc4b7780dc39a71d7f580e', '3b375646301546259a8fb29d74ae4447,63c4e1e7ec204b43a62065a3ced4c2ce,754a84ad28ed43fea93a468acd8f727b,d79254c4ca5e45dca9d484307c935281,b350d9c92c524bb4b9feedd40e5eebcd', '0', '3', '1', '2020-04-23 10:29:52', '2020-04-23 10:29:52');
INSERT INTO `tb_recommend` VALUES ('92da0377e7724f939f8e58423fa5a3ba', '超 50 万 ZOOM 账户在暗网上售卖，单价仅为 0.002 美分', '视频会议软件 Zoom 最近的日子真的是不好过。从被曝出重大安全漏洞之后，到被各企业机构封杀，再到被个人股东发起集体诉讼。近日又被曝出，在暗网和黑客论坛上，有超过 50 万个 Zoom 账户正在以不到每个一分钱（0...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZO5\" src=\"http://localhost:8060/tup/2020/4/23/803fa96a290d488aa2663b0e5c77df38.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>视频会议软件 Zoom 最近的日子真的是不好过。从被曝出重大安全漏洞之后，到被各企业机构封杀，再到被个人股东发起集体诉讼。近日又被曝出，在暗网和黑客论坛上，有超过 50 万个 Zoom 账户正在以不到每个一分钱（0.002美分）的价格出售，甚至还可以被免费赠送。</p> \n<h2>黑客为名不图财</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZOL\" src=\"http://localhost:8060/tup/2020/4/23/e51b959bb7bd4e88a9f2a4064c230dc7.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>据网络安全情报公司 cyble 透露，黑客提供这些免费账户是为了在黑客社区中获得更高的声誉。</p> \n<p>这些帐户是通过文本共享网站共享的，包括受害者的电子邮件地址、密码、个人会议 URL 及其主机密钥。根据透露的资料显示，有包含佛蒙特大学、科罗拉多大学、达特茅斯大学、拉斐特大学、佛罗里达大学等 290 所学校的相关帐户被免费发布出来。</p> \n<p>国外媒体已试图联系了这些列表中显示的随机电子邮件地址，并确认某些信息是正确的。但一位被出售信息的用户表示列表中的密码是旧密码，这表明其中一些凭证可能来自较旧的凭证填充攻击。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZOT\" src=\"http://localhost:8060/tup/2020/4/23/b71afaa7fdb44de59cbda28d257b4b5c.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>在看到卖家发布售卖信息后，Cyble 公司希望大量购买被出售的账号信息，以便来通知并警告相关客户可能出现的漏洞。</p> \n<p>据悉，Cyble 已经以每个账户 0.002 美分的价格购买了超过 53 万个 Zoom 账号信息，购买的信息包括电子邮件地址、密码、个人会议 URL 和他们的主机秘钥。经测试，这 53 万的账号信息中还包含摩根大通、花旗银行和很多知名教育机构的帐户。</p> \n<h2>建议更改密码</h2> \n<p>由于这些账户可能是利用旧有的数据漏洞所收集到的凭证填充攻击，为了安全起见，如果您的 Zoom 密码和其他网站的密码相同，建议不仅要尽快修改 Zoom 的密码，还要将其他平台的密码进行更换。</p> \n<blockquote>\n 相关阅读：\n <p><a href=\"https://segmentfault.com/a/1190000022310248\">Zoom 再遭谷歌封杀，个人股东发起集体诉讼</a> <br><a href=\"https://segmentfault.com/a/1190000022274150\">《Zoom 数万私人视频被公开，被曝加密技术造假》</a> <br><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3NTQ2NDIyOQ==&amp;mid=2247492246&amp;idx=1&amp;sn=52ce6baee03a454332c6423c6f7d8774&amp;chksm=fd2014dcca579dca8a13b52efc1f3cf8d2772b45cd74fdf5c03acbfe46bf6b382df9a067f238&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1586391238777&amp;sharer_shareid=25f66f2583339eda80990afae77dc8d4&amp;rd2werd=1#wechat_redirect\" rel=\"nofollow noreferrer\">《雪上加霜！股东向 Zoom 发起集体诉讼，索赔高额补偿》</a></p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyR0\" src=\"http://localhost:8060/tup/2020/4/23/549ff9d0052e4510b5e50b6f453f7d38.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/93b57ba4274b48d0a1fbf8004e26ac95.jpg', 'f53014d680884163a5bd5ce762e90cdf', '04547238127a4676b504cc4496865d7b', 'e75baefb206a4efe959a99aad77632a3,7871a3acb3374d36b738a36c95c3f8ea', '0', '3', '1', '2020-04-23 10:58:33', '2020-04-23 10:58:33');
INSERT INTO `tb_recommend` VALUES ('9444e237cd7a4781a89d3bbdfc5c78d0', '为啥国人喜欢Mybatis，而老外偏爱 Hibernate/JPA 呢？', '关于SQL 和 ORM 的争论，永远都不会终止，我也一直在思考这个问题。昨天又跟群里的小伙伴进行了一番讨论，感触还是有一些，于是就有了今天这篇文。', '<p>这是一篇很不错的文章，长见识，文章有点长，大家可以慢慢读。会有所收获的。 </p> \n<p>关于SQL 和 ORM 的争论，永远都不会终止，我也一直在思考这个问题。昨天又跟群里的小伙伴进行了一番讨论，感触还是有一些，于是就有了今天这篇文。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhI5\" src=\"http://localhost:8060/tup/2020/4/23/327f86d4c9bd49efa5b37a7e1b5ced5a.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>声明：</strong></p> \n<p>本文不会下关于 Mybatis 和 JPA 两个持久层框架哪个更好这样的结论。只是摆事实，讲道理，所以，请各位看官勿喷。</p> \n<h2>一、事件起因</h2> \n<p>关于 Mybatis 和 JPA 孰优孰劣的问题，争论已经很多年了。一直也没有结论，毕竟每个人的喜好和习惯是大不相同的。</p> \n<p>我也看过知乎上一些问答，各有各的理由，感觉都挺有道理。如果让我不带感情色彩地去分辨，其实我也是懵的，因为真的是公说公有理婆说婆有理。</p> \n<p>而在国内，不得不承认，用 Mybatis 的公司确实是要比用 JPA 的多，但是在 2015 年以前，用 Hibernate 的公司确实也是很多的。</p> \n<p>为什么在国内，会有这样的现象发生？而在国外，<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247490088&amp;idx=2&amp;sn=c05c3c383a812f9523f471ccd867f33c&amp;chksm=eb539f1edc241608ad3a03db3df4283854979b34a85476f32d5e71f417ffb47c349ba6105712&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\"><strong>老外会一如既往地使用 JPA 呢？</strong></a>我们来分析分析。</p> \n<h2>二、目前生态</h2> \n<p>在最近（2018）的 JVM 生态报告中（<a href=\"https://snyk.io/blog/jvm-ecosystem-report-2018-platform-application/\" rel=\"nofollow noreferrer\">https://snyk.io/blog/jvm-ecos...</a>），Mybatis是使用率是很低的。可以看图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhI6\" src=\"http://localhost:8060/tup/2020/4/23/a0a1db6f2d18499fa37c6357a19a53c8.jpg\" alt=\"\" title=\"\"></span></p> \n<p>可以看出，Mybatis 的占比只有可怜的 6%，大家看到这个统计结果应该会很吃惊，你会觉得，不对啊，我公司以及我很多朋友都在用 Mybatis 啊，好像没听说过有人用 JPA 的，这个统计结果是错的吧？</p> \n<p>再从下面这个对比来看，MyBatis 的关注主要集中在中日韩。知道日韩为啥也高吗，猜中有奖哦，哈哈！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhI7\" src=\"http://localhost:8060/tup/2020/4/23/e5e199391e4f4d598e6648f6c2ecc0d6.jpg\" alt=\"\" title=\"\"></span></p> \n<p>首先，必须指出，对于青年程序员，其实都会质疑这个图的可信度。</p> \n<p>中老年程序员都在感叹国外其实更注重开发效率和面向对象的分析和设计。但我可以非常负责任地告诉你，这图是真的。那么，造成这种现象的原因是？</p> \n<h2>三、国人喜欢 Mybatis 的原因</h2> \n<p>总结起来，有如下原因：</p> \n<p><strong>1.大厂带节奏</strong></p> \n<p>国内做互联网的 Java 程序很多都是拷贝阿里的，阿里一开始用例 iBatis，大量的老系统都是基于 iBatis/MyBatis 的，市场上对 MyBatis 熟悉的人才更多，招聘和培训更容易，有的青年程序员以为“<strong>MyBatis 早已统一全球了</strong>”就是一个很好的证明。</p> \n<p><strong>2.简单，学习成本低</strong></p> \n<p>小公司需要大量入门级的程序员，像大神甚至一个都请不起，请问大神们那些牛 b 框架哪个更快让菜鸟们上手，降低公司学习成本。注意这个成本会一直跟随公司，想必大神们创业直接前后端分离了，毕竟钱嘛多的是。</p> \n<p><strong>3.对于复杂性需求的灵活性高</strong></p> \n<p>国内绝大部分项目都是面向表结构编程的，把 java 对象仅当成数据容器，查询和模型变更都设计在一张表上，所谓业务逻辑就是一堆增删改查的 sql 集合，当然用 mybatis 方便。</p> \n<p>在逻辑不复杂，或者你判断软件生命周期不会超过一年的时候，直接用表结构编程是最方便快捷的。</p> \n<p>国内普遍都是分布式，流量和性能决定了需要经常进行优化，而是用 Mybatis 对复杂需求的优化很方便。</p> \n<p><strong>4.公司环境</strong></p> \n<p>国内好多项目都是应付领导的某些奇葩需求。需要面向领导编程。一大半时间其实都是在解决领导的需求。</p> \n<p>国内项目需要大量报表统计，需要提供给领导作为决策。看到这里，各位领导不要骂我 ，真的不是黑领导的。</p> \n<p><strong>5.Hibernate学习成本高</strong> </p> \n<p>虽然，实际上 SpringDataJPA 是非常简单的，但是，但是，JPA/Hibernate 后期调试跟踪问题很麻烦，改起来也麻烦。别忘了，牛逼如你的人全公司甚至一个都没。</p> \n<p>还有什么缓存什么 Criteria 什么 Lazy，虽然这些你学了也不见得能用上，但一个框架，你不学还是不行的。</p> \n<p>推荐阅读：<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247490255&amp;idx=3&amp;sn=af2ddafda67b294dc6374b9764dba22b&amp;chksm=eb539ff9dc2416ef5b31b2efbd273a80d4f6b9f882dcd91e388a7b8518afa2f7f9e23fb57c5e&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">JPA、Hibernate、Spring Data JPA 的关系</a></p> \n<p>而且，JPA 对于增删改很方便，复杂查询却是软肋，有同学会说，JPA 也能写 SQL 语句啊，我想说的是，既然都用 orm 了，你再写 sql，那不就失去了 oop 的内涵了吗？不优雅好吧。</p> \n<h2>四、老外喜欢 JPA 的原因</h2> \n<p><strong>1.很多老外对 Mybatis 的认知还停留在 iBatis 阶段</strong></p> \n<p>实际上在 Mybatis 的应用场景里面，开发者要的就是自动封装，把 sql 查询结果转化为指定的 java 对象。</p> \n<p>这个在 iBatis 阶段，需要开发者自己定义大量的 xml 配置，去指定数据库表字段与 Java 实体类之间的关系。并且，对于每一条 sql，都需要在 xml 中写相应的语句，虽然有代码生成器，带开发量还是不小的。</p> \n<p>但 Mybatis 发展到今天，已经非常完美地做好了自动封装数据对象这件事，支持的插件也比较丰富。对于常见的增删改查，也不需要自己写一行代码，这已经无限接近于 Hibernate 的能力了。</p> \n<p>推荐阅读：<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247490088&amp;idx=2&amp;sn=c05c3c383a812f9523f471ccd867f33c&amp;chksm=eb539f1edc241608ad3a03db3df4283854979b34a85476f32d5e71f417ffb47c349ba6105712&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">为什么老外都不愿意用MyBatis？</a></p> \n<p><strong>2.喜欢 OOP、DDD</strong></p> \n<p>认为写 SQL 不优雅，用 jpa 的核心是让我们关注对象建模，而不是关心底层数据库映射。只有你在考虑数据和行为在一起的充血模型、贴身职责，聚合根状态变迁，值对象不变性的情况下，你才会发现 jpa 给你提供了很多便利，根本不需要关注底层存储模型。</p> \n<p>在复杂的逻辑、超长的软件生命周期。使用 DDD 的设计方法是目前看比较合理的选择，维护的成本比较低。</p> \n<p>DDD 全称是（Domain-Driven Design)这是 2004 年就出来的理论，复杂逻辑的应对之道。DDD 大会在欧洲等地办了一届又一届，CQRS、Event Sourcing 等探索层出不穷，这也是为什么国外比较流行 JPA 原因。</p> \n<p>不过，国内主要是随着这两年随着微服务火爆也有人谈起来 DDD 了。但其实 DDD 也不是银弹，需要大拿能把控全局，国内缺的就是这种大拿，搬砖的太多。</p> \n<p><strong>3.有些老外在技术选型时，不会考虑除 Spring 这种知名框架外的其他技术，无他，唯手熟尔。</strong></p> \n<p>Spring确实很强，我也写了&nbsp;N 篇最新 Spring&nbsp;教程，关注微信公众号：Java技术栈，在后台回复：spring，可以获取，都是干货。</p> \n<p>国外一个项目，做了几年十几年都是很正常的。我以前接触过一个国外的的电商项目，做了十几年，也跑的好好的，这就是证据。</p> \n<p>使用技术也是有惯性的。</p> \n<p><strong>4.数据体量和种类没有达到</strong></p> \n<p>个人感觉，也咨询了国际友人。老外的项目，在数据体量和种类上完全达不到国内的水平。</p> \n<p>所以，他们对于性能上的渴求度没有那么高。追求的是稳定，可维护性好。国内一个双 11，如果用 hibernate，那只能死掉了。</p> \n<p>推荐阅读：<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247491125&amp;idx=3&amp;sn=297115e2620d048a1aecdf387ab6febb&amp;chksm=eb539b03dc241215b255e4fed99f076625c2139b4244e28c34e3c2f7b19c5bdbe428cc7d2681&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">淘宝千万并发，14 次架构演进…</a></p> \n<p>也说明，老外的需求主要是在业务上，技术层面较少考虑。</p> \n<h2>五、一点感悟</h2> \n<p>整个状况，和对 OOAD 的重视有很大关系，我在做 DDD 技术落地的时候，用 MyBatis 非常蹩脚，用 JPA/Hibernate 会好很多。</p> \n<p>JPA/Hibernate 比较复杂，团队中要有人 Hold 住它，否则及其容易踩坑；另外，真要使用，建议使用它的一个功能子集，不要所有功能都用。也可以尝试使用更简单 EBean ORM。</p> \n<p>JPA/Hibernate 对分库分表的支持有一下坑。虽然，使用 Shareding-JDBC 或 MyCat 等技术，可以不关心<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247490648&amp;idx=1&amp;sn=c14804d5414911b9cd91c165b5add9d3&amp;chksm=eb53996edc2410784e801ce2e58641e21c13e9477ac56da52b9ef66b6c616830620e1ffc4986&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">分库分表</a>，但是，JPA/Hibernate 在某些情况下（比如加载子集合的时候）可能会不带分区键。国外分库分表的少，国内几乎是标配。</p> \n<h2>六、Mybatis 和 JPA 大比较</h2> \n<p>最后，从多维度对这两个知名框架做些比较：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhI8\" src=\"http://localhost:8060/tup/2020/4/23/035313916a394bc9b201c9420cdb5ea1.jpg\" alt=\"\" title=\"\"></span></p> \n<p>最后的最后，欢迎在评论区留下你最宝贵的意见 ，勿喷哦！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhI9\" src=\"http://localhost:8060/tup/2020/4/23/3a2c58d5b2d54299a474e59703522be7.jpg\" alt=\"\" title=\"\"></span></p> \n<p>最后的最后，关于这个话题，你怎么看待的？欢迎在底部留言！</p> \n<blockquote>\n 参考：zhihu.com/question/50729231/answer/549761974\n <br>来源：blog.csdn.net/m0_37609579/article/details/102961765\n</blockquote> \n<p><strong>推荐去我的博客阅读更多：</strong></p> \n<p>1.<a href=\"http://www.javastack.cn/categories/Java/\" rel=\"nofollow noreferrer\">Java JVM、集合、多线程、新特性系列教程</a></p> \n<p>2.<a href=\"http://www.javastack.cn/categories/Spring/\" rel=\"nofollow noreferrer\">Spring MVC、Spring Boot、Spring Cloud 系列教程</a></p> \n<p>3.<a href=\"http://www.javastack.cn/categories/%E5%B7%A5%E5%85%B7/\" rel=\"nofollow noreferrer\">Maven、Git、Eclipse、Intellij IDEA 系列工具教程</a></p> \n<p>4.<a href=\"http://www.javastack.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/\" rel=\"nofollow noreferrer\">Java、后端、架构、阿里巴巴等大厂最新面试题</a></p> \n<p>觉得不错，别忘了点赞+转发哦！</p>', null, 'http://localhost:8060/tup/2020/4/23/6682cd9d10544981a3fc025d57c2e79f.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', 'bb0b7e69ad3e46fcb121baefda8f1f78', '2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-23 10:28:26', '2020-04-23 10:28:26');
INSERT INTO `tb_recommend` VALUES ('95395fceadf542d68b784dc7cf81b1bd', 'AFNetworking源码解析与面试考点延伸', '最近重读了AFNetworking 3.x的源码，算是温故而知新吧。也梳理了一些优秀的代码细节和面试考点，罗列下来，发现这个库小而精致，简直初学者的宝藏库。', '<p>最近重读了AFNetworking 3.x的源码，算是温故而知新吧。也梳理了一些优秀的代码细节和面试考点，罗列下来，发现这个库小而精致，简直初学者的宝藏库。</p> \n<h2>开源库怎么看？</h2> \n<p>先说个题外话，阅读优质的开源代码库，绝对是程序员们快速提升自我的有效途径，而怎样高效率的去阅读源码同样也是一个问题，不知道有没有人和我之前一样，碰到过读倒是读了，但总感觉收获不大的情况。</p> \n<p>这里分享一下我的一些读码经验：</p> \n<ol> \n <li> <p>多思考，多抛出问题，比如说</p> \n  <ul> \n   <li>整体的代码结构是怎样的？类与类之间的关系是怎样的？为什么要这么设计？</li> \n   <li>代码有没有涉及到多线程，其线程模型是怎样的？哪类问题可以适用这种多线程的方案？</li> \n   <li>代码中使用了哪些设计模式？具体是怎么实现的？</li> \n  </ul> </li> \n <li>也可以关注代码细节，遇到不熟悉的用法不要放过，多刨根究底才能夯实基础<p>关于<code>AFNetworking</code>的一些优秀代码细节，我这里也整理了一部分，可以查阅后文</p> </li> \n <li>一定要记笔记和总结，能分享更好。<p>参考费曼学习法，我认为这一点是最好的加深理解和强化记忆的手段。随着年龄的增大，记忆力会有所衰退，有个笔记能够回顾，能节约大把再次记忆的时间。此外，多与人分享还能够提升自己的影响力，与人交流验证，也能够为自己查缺补漏。</p> </li> \n</ol> \n<h2>AFNetworking 3.x的代码结构</h2> \n<p>还是说回到<code>AFNetworking</code>这里，AF的代码结构大部分人应该都了解，这里我简单介绍下。<code>AFNetworking 3.x</code>的代码结构比2.x要简单许多，主要也得益于苹果优化了网络相关的api，整体代码有这么几部分：</p> \n<ul> \n <li> <strong>AFURLSessionManager/AFHTTPSessionManager</strong> <p>这里就是AF代码的核心了，主要负责网络请求的发起，回调处理，是在系统网络相关API上的一层封装。大部分逻辑是在<code>AFURLSessionManager</code>里面处理的，<code>AFHTTPSessionManager</code>则是专为HTTP请求提供了一些便利方法。如果需要扩展其他协议的功能（比如FTP协议），可以考虑从<code>AFURLSessionManager</code>创建一个子类。</p> </li> \n <li> <strong>AFURLRequestSerialization/AFURLResponseSerialization</strong><p>这两兄弟主要处理一些参数序列化相关的工作。<code>AFURLRequestSerialization</code>是将传入的参数构造成<code>NSURLRequest</code>，比如自定义的header，一些post或者get参数等等。 <code>AFURLResponseSerialization</code>主要是将系统返回的<code>NSURLResponse</code>处理成我们需要的responseObject，比如json、xml、image等等</p> </li> \n <li> <strong>AFSecurityPolicy</strong><p>处理https相关的公钥和验证逻辑。目前由于苹果ATS的开启，基本HTTPS已经成为标配。虽然通常直接使用CA来验证服务器公钥的情况下，不需要我们额外做什么配置。但是从这里出发，顺便考察一下HTTPS相关的知识点，感觉也比较常见，具体面试题可看下文</p> </li> \n <li> <strong>AFNetworkReachabilityManager</strong><p>这个其实是比较独立的一个模块了，提供获取当前网络状态的功能。</p> </li> \n <li> <strong>UIKit+AFNetworking</strong><p>这里主要是通过Category来提供了一下UIkit的便利方法</p> </li> \n</ul> \n<h2>AF的一些优质代码细节</h2> \n<p>仔细瞅瞅代码之后，发现常见的OC基础知识在AF里面都有具体应用，挺多还是面试题考点，这里也是做个记录和梳理。</p> \n<ul>\n <li><strong>单例的创建方法</strong></li>\n</ul> \n<pre><code class=\"objc\">+ (instancetype)defaultInstance {\n    static AFImageDownloader *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}</code></pre> \n<p>必知必会，通过dispatch_once来保证多线程调用时，只有一个实例被创建。</p> \n<ul>\n <li><strong>dispatch_sync与dispatch_barrier_sync配合解决并行读串行写问题</strong></li>\n</ul> \n<pre><code class=\"objc\">// 注意是并行队列\nself.requestHeaderModificationQueue = dispatch_queue_create(\"requestHeaderModificationQueue\", DISPATCH_QUEUE_CONCURRENT);\n\n// 串行写，注意barrier block的具体执行时机\ndispatch_barrier_sync(self.requestHeaderModificationQueue, ^{\n    [self.mutableHTTPRequestHeaders setValue:value forKey:field];\n});\n\n// 并行读，注意和上面写操作同时执行时的执行顺序\nNSDictionary __block *value;\ndispatch_sync(self.requestHeaderModificationQueue, ^{\n    value = [NSDictionary dictionaryWithDictionary:self.mutableHTTPRequestHeaders];\n});\n</code></pre> \n<p>必知必会，GCD使用barrier来处理并行读串行写问题的具体用法</p> \n<ul>\n <li><strong>weakSelf与strongSelf的用法</strong></li>\n</ul> \n<pre><code class=\"objc\">__weak __typeof(self)weakSelf = self;\nAFNetworkReachabilityStatusCallback callback = ^(AFNetworkReachabilityStatus status) {\n    __strong __typeof(weakSelf)strongSelf = weakSelf;\n\n    strongSelf.networkReachabilityStatus = status;\n    if (strongSelf.networkReachabilityStatusBlock) {\n        strongSelf.networkReachabilityStatusBlock(status);\n    }\n\n    return strongSelf;\n};</code></pre> \n<p>必知必会，weakSelf避免循环引用，strongSelf保证block内部执行过程中self不会被释放</p> \n<ul>\n <li> <strong>其他用法</strong><p>NSSecureCoding、kvo、swizzle、NSStream、NSProgress、代码注释、pragma mark等等</p> </li>\n</ul> \n<h2>AFNetworking的可能面试考点</h2> \n<p>前面提到阅读开源库时，要多思考多提问题，这里也结合一些面试考题来梳理下</p> \n<h3>AFNetworking 2.x怎么开启常驻子线程？为何需要常驻子线程？</h3> \n<p>这个知识点应该是AF2.x版本面试官比较喜欢问的了，AF2.x版本有个细节，通过runloop开启了一个常驻子线程，具体代码是这样的：</p> \n<pre><code class=\"objc\">+ (void)networkRequestThreadEntryPoint:(id)__unused object {\n    @autoreleasepool {\n        [[NSThread currentThread] setName:@\"AFNetworking\"];\n\n        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n        [runLoop run];\n    }\n}\n\n+ (NSThread *)networkRequestThread {\n    static NSThread *_networkRequestThread = nil;\n    static dispatch_once_t oncePredicate;\n    dispatch_once(&amp;oncePredicate, ^{\n        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n        [_networkRequestThread start];\n    });\n\n    return _networkRequestThread;\n}</code></pre> \n<p>首先，我们要了解为何要开启<strong>常驻</strong>子线程？</p> \n<p><code>NSURLConnection</code>的接口是异步的，然后会在发起的线程回调。而一个子线程，在同步代码执行完成之后，一般情况下，线程就退出了。那么想要接收到<code>NSURLConnection</code>的回调，就必须让子线程至少存活到回调的时机。而AF让线程常驻的原因是，当发起多个http请求的时候，会统一在这个子线程进行回调的处理，所以干脆就让其一直存活下来。</p> \n<p>上面说的一般情况，子线程执行完任务就会退出，那么什么情况下，子线程能够继续存活呢？这就涉及到第二个问题了，AF是如何开启常驻线程的，这里实际上考察的是runloop的基础知识。</p> \n<p>关于runloop，推荐看下<a href=\"https://blog.ibireme.com/2015/05/18/runloop/\" rel=\"nofollow noreferrer\">《深入理解RunLoop》</a>，个人觉得讲得非常详尽。这里简单来说，当runloop发现还有source/timer/observer的时候，runloop就不会退出。所以AF这里就通过给当前runloop添加一个NSMachPort，这个port实际上相对于添加了一个source事件源，这样子线程的runloop就会一直处于循环状态，等待别的线程向这个port发送消息，而实际上AF这里是没有消息发送到这个port的。</p> \n<p>除了AF的这种处理方式，实际上苹果也提供了回调线程的解决方案：</p> \n<pre><code class=\"objc\">// NSURLConnection\n- (void)setDelegateQueue:(nullable NSOperationQueue*) queue\n\n// NSURLSession\n+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue;</code></pre> \n<p>苹果提供了接口，可以让你制定一个operationQueue供回调执行。所以AF3.x的时候，就直接创建了一个并发度为1的队列，来处理回调。</p> \n<p><strong>扩展问题：</strong></p> \n<p>既然提到了runloop，可以考虑一下runloop的扩展问题：</p> \n<ul> \n <li>子线程默认有runloop吗？runloop创建和销毁的时机又是什么时候呢？</li> \n <li>runloop有哪些mode呢？滑动时发现定时器没有回调，是因为什么原因呢？</li> \n <li>除了上面这种addPort来保活线程的方法，有无其他方法呢？</li> \n</ul> \n<h3>AFURLSessionManager与NSURLSession的关系，每次都需要新建mananger吗？</h3> \n<p>我们如果仔细查看代码，应该就能得出这样的结论：manager与session是1对1的关系，AF会在manager初始化的时候创建对应的NSURLSession。同样，AF也在注释中写明了可以提供一个配置好的manager单例来全局复用。</p> \n<p>那么复用manager实际上就是复用了session，而复用session可以带来什么好处呢？</p> \n<p>其实iOS9之后，session就开始支持http2.0。而http2.0的一个特点就是多路复用（可参考<a href=\"https://juejin.im/post/5d70848df265da03d871de9c\" rel=\"nofollow noreferrer\">《Http系列(二) Http2中的多路复用》</a>）。所以这里复用session其实就是在利用http2.0的多路复用特点，减少访问同一个服务器时，重新建立tcp连接的耗时和资源。</p> \n<p>官方文档也推荐在不同的功能场景下，使用不同的session。比如：一个session处理普通的请求，一个session处理background请求；1个session处理浏览器公开的请求，一个session专门处理隐私请求等等场景。</p> \n<h3>AFSecurityPolicy如何避免中间人攻击？</h3> \n<p>现在，由于苹果ATS的策略，基本都切到HTTPS了，HTTPS的基本原理还是需要了解一下的，这里不做介绍，需要的可以google查阅一下相关文章。</p> \n<p>通常，首先我们要了解中间人攻击，大体就是黑客通过截获服务器返回的证书，并伪造成自己的证书，通常我们使用的Charles/Fiddler等工具实际上就可以看成中间人攻击。</p> \n<p>解决方案其实也很简单，就是<code>SSL Pinning</code>。<code>AFSecurityPolicy</code>的<code>AFSSLPinningMode</code>就是相关设置项。</p> \n<p><code>SSL Pinning</code>的原理就是需要将服务器的公钥打包到客户端中，tls验证时，会将服务器的证书和本地的证书做一个对比，一致的话才允许验证通过。</p> \n<pre><code class=\"objc\">typedef NS_ENUM(NSUInteger, AFSSLPinningMode) {\n    AFSSLPinningModeNone,\n    AFSSLPinningModePublicKey,    // 只验证证书中的公钥\n    AFSSLPinningModeCertificate,    // 验证证书所有字段，包括有效期之内\n};</code></pre> \n<p>由于数字证书存在有效期，内置到客户端后就存在失效后导致验证失败的问题，所以可以考虑设置为<code>AFSSLPinningModePublicKey</code>的模式，这样的话，只要保证证书续期后，证书中的公钥不变，就能够通过验证了。</p> \n<p><strong>扩展：</strong></p> \n<p>用了<code>SSL Pinning</code>就安全了吗?</p> \n<p>参考文章：</p> \n<p><a href=\"https://www.jianshu.com/p/b5c27669e2c1\" rel=\"nofollow noreferrer\">AFNetworking3.0后为什么不再需要常驻线程？</a></p> \n<p><a href=\"https://www.jianshu.com/p/5969bbb4af9f\" rel=\"nofollow noreferrer\">别说你会AFNetworking3.0/NSURLSession</a></p> \n<p><a href=\"https://segmentfault.com/a/1190000009199444\">AFNetWorking源码之AFSecurityPolicy</a></p> \n<p><a href=\"http://nelson.logdown.com/posts/2015/04/29/how-to-properly-setup-afnetworking-security-connection\" rel=\"nofollow noreferrer\">如何正確設定 AFNetworking 的安全連線</a></p> \n<hr> \n<p>原文链接： <a href=\"http://www.luoyibu.cn/posts/3247/\" rel=\"nofollow noreferrer\">http://www.luoyibu.cn/posts/3...</a> </p> \n<p>欢迎扫码关注我的微信公众号<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022119997\" src=\"http://localhost:8060/tup/2020/4/23/aed7e35e4b9f464abd3570b82084483d.jpg\" alt=\"image\" title=\"image\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/e1e52bce62a7475fa9aad221c6c4c723.jpg', 'f53014d680884163a5bd5ce762e90cdf', 'a337904dd1d5477b9689d7693be316de', '85ee959b27f74072b13cc763b9bbf77e,ccaaa3888a50432ebcbc469fa62c40b5,f2fb7d236fec4c138cacd9162eb4488c,e2937a6cc53645a0909a3904d8b4517d', '0', '3', '1', '2020-04-23 10:31:46', '2020-04-23 10:31:46');
INSERT INTO `tb_recommend` VALUES ('98c0a31bfae94b848e95bab779be519d', '跨端开发框架深度横评之2020版', '对应小程序开发领域，这一年也发生了巨大变化。开发框架从单纯的微信小程序开发，过渡到多端框架成为标配，进一步提升开发效率成为开发者的强烈需求。', '<p>又是一年四月天，距离上次发布<a href=\"https://segmentfault.com/a/1190000018738455\">跨端开发框架深度横评</a>已过去整整一年。</p> \n<p>这一年，小程序在用户规模及商业化方面都取得了极大的成功。微信小程序日活超过3亿，支付宝、百度、字节跳动小程序的月活也纷纷超过3亿。</p> \n<p>对应小程序开发领域，这一年也发生了巨大变化。开发框架从单纯的微信小程序开发，过渡到多端框架成为标配，进一步提升开发效率成为开发者的强烈需求。</p> \n<p>这一年 <code>mpvue</code> 停止更新，<code>Taro</code>开始探索 <code>taro next</code>，<code>uni-app</code> 产品和生态持续完善，微信新推出了支持H5和微信小程序的 <code>kbone</code> 框架...</p> \n<p>去年的深度横评中很多老将已经退出江湖，一些新秀吸引眼球，因此，是时候来一波2020版的新横评了。</p> \n<h2>评测目标筛选</h2> \n<p>跨端框架是一个重投入工作，在各框架的1年多的比拼中，很多框架因为投入不足而逐渐被开发者放弃，<code>uni-app</code>和<code>taro</code>依靠持续的大力度投入，成为了市场主流。</p> \n<p><code>taro</code> 在稳定版的基础之上，最近也推出了 <code>taro next</code>，这2个版本差异较大，本次会分别评测。</p> \n<p><code>kbone</code> 框架虽面世不久，但毕竟是微信官方发布，关注的人不少，故本次将 <code>kbone</code> 加入评测目标。</p> \n<p>所以，本次评测的对象（按发布时间排序）：</p> \n<ul> \n <li>微信原生开发</li> \n <li>taro，京东凹凸实验室出品，官网地址：<a href=\"https://taro.jd.com/\" rel=\"nofollow noreferrer\">https://taro.jd.com/</a> </li> \n <li>uni-app，DCloud出品，官网地址：<a href=\"https://uniapp.dcloud.net.cn\" rel=\"nofollow noreferrer\">https://uniapp.dcloud.net.cn</a> </li> \n <li>kbone，腾讯微信团队出品，官网地址：<a href=\"https://wechat-miniprogram.github.io/kbone/docs/\" rel=\"nofollow noreferrer\">https://wechat-miniprogram.github.io/kbone/docs/</a> </li> \n</ul> \n<p>本次评测除了运行性能等实测数据外，尽可能得通过框架官网及github、掘金、腾讯课堂等三方社区公开采集数据，希望给大家一个综合全面的评估依据。</p> \n<h2>功能实现</h2> \n<p><code>taro</code> 和 <code>uni-app</code> 是比较典型的多端框架，发布到各个端均可。而 <code>kbone</code> 只支持微信小程序和H5。</p> \n<p><code>taro</code> 和 <code>uni-app</code> 均将常用接口及组件封装了成了跨端API和跨端组件，组件规范沿用微信小程序的规范，部分平台特有API，这两个框架亦有应对方案：</p> \n<ul> \n <li>taro：支持<a href=\"https://nervjs.github.io/taro/docs/hybrid.html\" rel=\"nofollow noreferrer\">与小程序代码混写</a>，可通过混写的方式调用框架尚未封装的小程序新增API</li> \n <li>uni-app：支持<a href=\"https://uniapp.dcloud.io/platform\" rel=\"nofollow noreferrer\">条件编译</a>，可在条件编译代码块中，随意调用各个平台新增的API及组件</li> \n</ul> \n<p><code>taro</code> 和 <code>uni-app</code> 可以不受限的调用各家小程序平台所有的API及组件。</p> \n<p><code>kbone</code> 沿用<code>web</code>的开发习惯，使用<code>html</code>标签及<code>js api</code>；涉及微信特有api时，可通过<code>process.env.isMiniprogram</code>判断环境，然后编写微信原生代码。对于<code>html</code>中没有标签可替代的微信内置组件（如<code>swiper</code>），需要使用 <code>wx-component</code> 标签或者使用 <code>wx-</code> 前缀，这样的内置组件会被包裹一层自定义组件，带来相应的性能开销。</p> \n<p>除了接口、组件之外，我们以微信小程序为例，找几个典型能力对比框架支持度：</p> \n<table> \n <thead>\n  <tr> \n   <th align=\"center\">框架</th> \n   <th align=\"center\">taro</th> \n   <th align=\"center\">uni-app</th> \n   <th align=\"center\">kbone</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td align=\"center\">微信自定义组件</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n  <tr> \n   <td align=\"center\">三方插件</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">❌</td> \n  </tr> \n  <tr> \n   <td align=\"center\">分包加载</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n  <tr> \n   <td align=\"center\">sitemap</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n  <tr> \n   <td align=\"center\">wxs</td> \n   <td align=\"center\">❌</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">❌</td> \n  </tr> \n  <tr> \n   <td align=\"center\">云开发</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n </tbody> \n</table> \n<p>补充说明：</p> \n<ul> \n <li>如果在 Taro 项目引用了小程序原生的第三方组件，那么该项目将不再具备多端转换的能力，例如，如果使用了微信小程序的第三方组件，那么项目只能转换成微信小程序，转义成其他平台会失效，详见<a href=\"https://taro-docs.jd.com/taro/docs/mini-third-party.html\" rel=\"nofollow noreferrer\">taro官网</a> </li> \n <li>uni-app 中使用微信自定义组件的话，支持编译发行到App/H5/微信小程序/QQ小程序4个平台，详见<a href=\"https://uniapp.dcloud.net.cn/frame?id=%e5%b0%8f%e7%a8%8b%e5%ba%8f%e7%bb%84%e4%bb%b6%e6%94%af%e6%8c%81\" rel=\"nofollow noreferrer\">uni-app官网</a> </li> \n <li>taro 不支持 wxs 的依据：<a href=\"https://github.com/NervJS/taro/issues/2959\" rel=\"nofollow noreferrer\">#2959</a> </li> \n <li>kbone 不支持微信三方插件的依据：<a href=\"https://github.com/Tencent/kbone/issues/58\" rel=\"nofollow noreferrer\">#58</a>；不支持wxs的依据：<a href=\"https://github.com/Tencent/kbone/issues/129\" rel=\"nofollow noreferrer\">#129</a> </li> \n <li>云开发在微信平台，三个框架都支持，但 taro/kbone仅支持微信小程序平台，uni-app支持<code>App/H5/小程序</code>所有平台使用云开发，详见下方 <code>serverless/云开发</code> 章节。</li> \n</ul> \n<p><code>wxs</code>是提升性能体验的重要利器，除了微信小程序的<code>wxs</code>外，还有支付宝的<code>SJS</code>、百度的<code>Filter</code>，这些高级技术 <code>uni-app</code> 均完善支持。参考：<a href=\"https://juejin.im/post/5d7f366b6fb9a06af8250bc4\" rel=\"nofollow noreferrer\">谜之wxs，uni-app如何用它大幅提升性能</a></p> \n<p>从如上功能对比来看：微信原生 ~ uni-app &gt; taro &gt; kbone</p> \n<h2>运行性能</h2> \n<p>我们继续沿用去年的测试模型，看看一年来，各家小程序开发框架的性能是否有提升。详细如下：</p> \n<ul> \n <li>开发内容：开发一个仿微博小程序首页的复杂长列表，支持下拉刷新、上拉翻页、点赞。</li> \n <li>界面如下：</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326485\" src=\"http://localhost:8060/tup/2020/4/23/d1f627fde34447e182188463ae69fed3.jpg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li>开发版本：一共开发了5个版本，包括微信原生版、taro版、uni-app版、kbone版，按照官网指引通过<code>cli</code>方式默认安装。</li> \n <li>taro 目前稳定版本是2.0版，但近期在宣传跨框架的taro next，故我们基于同样的 react代码，同时测试了taro 2.0 和 taro next 两个版本的数据。</li> \n <li>测试代码开源（<a href=\"https://github.com/dcloudio/test-framework\" rel=\"nofollow noreferrer\">Github仓库地址：https://github.com/dcloudio/test-framework</a>），</li> \n</ul> \n<p><em>Tips:若有同学觉得测试代码写法欠妥，欢迎提交 PR 或 <a href=\"https://github.com/dcloudio/test-framework/issues\" rel=\"nofollow noreferrer\">Issus</a></em></p> \n<ul> \n <li>测试机型：红米 Redmi 6 Pro、MIUI 11.0.5 稳定版（最新版）、微信版本 7.0.12（最新版）</li> \n <li>测试环境：每个框架开始测试前，杀掉各App进程、清空内存，保证测试机环境基本一致；每次从本地读取静态数据，屏蔽网络差异。</li> \n</ul> \n<p>我们以上述仿微博小程序为例，测试2个容易出性能问题的点：长列表加载、大量点赞组件的响应。</p> \n<h3>长列表加载</h3> \n<p>仿微博的列表是一个包含很多组件的列表，这种复杂列表对性能的压力更大，很适合做性能测试。</p> \n<p>从触发上拉加载到数据更新、页面渲染完成，需要准确计时。人眼视觉计时肯定不行，我们采用程序埋点的方式，制定了如下计时时机：</p> \n<ul> \n <li>计时开始时机：交互事件触发，框架赋值之前，如：上拉加载（onReachBottom）函数开头</li> \n <li>计时结束时机：页面渲染完毕(微信setData回调函数开头)</li> \n</ul> \n<p>Tips：<code>setData</code>回调函数开头可认为是页面渲染完成的时间，是因为微信<code>setData</code>定义如下(<a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html?search-key=Page.prototype.setData\" rel=\"nofollow noreferrer\">微信规范</a>)：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326486\" src=\"http://localhost:8060/tup/2020/4/23/48cd3a4f6b4d40b4b555397f9b1430a6.jpg\" alt=\"\" title=\"\"></span></p> \n<p>测试方式：从页面空列表开始，通过程序自动触发上拉加载，每次新增20条列表，记录单次耗时；固定间隔连续触发 N 次上拉加载，使得页面达到 20*N 条列表，计算这 N 次触发上拉到渲染完成的平均耗时。</p> \n<p>测试结果如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326487\" src=\"http://localhost:8060/tup/2020/4/23/1dbf832013c241569e82eaf3a84a0567.jpg\" alt=\"\" title=\"\"></span></p> \n<p>说明：以400条微博列表为例，从页面空列表开始，每隔1秒触发一次上拉加载（新增20条微博），记录单次耗时，触发20次后停止（页面达到400条微博），计算这20次的平均耗时，结果微信原生在这20次 <code>触发上拉 -&gt; 渲染完成</code> 的平均耗时为538毫秒，最快的<code>uni-app</code>是446毫秒，最慢的<code>kbone</code>是4057毫秒</p> \n<p>大家初看这个数据，可能比较疑惑，别急，下方有详细说明</p> \n<p><strong>说明1：为何 taro next/kbone 测试数据不完整?</strong></p> \n<p>因为 <code>taro next</code> 和<code>kbone</code> 采用的是动态渲染方案，这类方案在页面复杂、组件较多时，会大量增加页面 <code>dom</code> 节点数量，甚至超出微信的 <code>dom</code> 节点数限制（如下告警信息）。我们在 红米手机（Redmi 6 Pro）上实测，页面组件超过600个时，<code>taro next</code>、<code>kbone</code> 实现的仿微博App就会报出运行异常，并停止渲染（页面白屏），故这两个测试框架在组件较多时，测试数据不完整。这也就意味着，当页面组件太多时，无法使用这2个框架。</p> \n<blockquote>\n dom limit exceeded please check if there\'s any mistake you\'ve made\n</blockquote> \n<p>另外，kbone官网有如下介绍：</p> \n<blockquote>\n kbone 是使用一定的性能损耗来换取更为全面的 Web 端特性支持。\n</blockquote> \n<p>故<code>taro next</code>、<code>kbone</code>的测试数据，明显和<code>taro 2.0</code>、<code>uni-app</code>不是一个量级的。</p> \n<p>如果你的应用是长列表场景，那<code>taro next</code>、<code>kbone</code>就明显不太合适。</p> \n<p><strong>说明2：为什么测试数据显示uni-app 会比微信原生框架的性能略好呢？</strong></p> \n<p>这个问题在去年的测评中，已解释过。为了避免新同学迷惑，这里再次说明一下。</p> \n<p>微信原生框架耗时主要在<code>setData</code>调用上，开发者若不单独优化，则每次都会传递大量数据；而 <code>uni-app</code>、<code>taro</code> 都在调用<code>setData</code>之前自动做<code>diff</code>计算，每次仅传递变动的数据。</p> \n<p>例如当前页面有20条数据，触发上拉加载时，会新加载20条数据，此时原生框架通过如下代码测试时，<code>setData</code>会传输40条数据</p> \n<pre><code>data: {\n    listData: []\n},\nonReachBottom() { //上拉加载\n    let listData = this.data.listData;\n    listData.push(...Api.getNews());//新增数据\n    this.setData({\n        listData\n    }) //全量数据，发送数据到视图层\n}</code></pre> \n<p>开发者使用微信原生框架，完全可以自己优化，精简传递数据（每次仅传递变化的20条数据），比如修改如下：</p> \n<pre><code class=\"javascript\">data: {\n    listData: []\n},\nonReachBottom() { //上拉加载\n    // 通过长度获取下一次渲染的索引\n    let index = this.data.listData.length;\n    let newData = {}; //新变更数据\n    Api.getNews().forEach((item) =&gt; {\n        newData[\'listData[\' + (index++) + \']\'] = item //赋值，索引递增\n    }) \n    this.setData(newData) //增量数据，发送数据到视图层\n}</code></pre> \n<p>经过如上优化修改后，再次测试，微信原生框架性能数据如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326489\" src=\"http://localhost:8060/tup/2020/4/23/72f67fc85a4443f5a1972b21b7f44614.jpg\" alt=\"\" title=\"\"></span></p> \n<p>从测试结果可看出：</p> \n<ul> \n <li>经过开发者手动优化，微信原生框架可达到更好的性能；</li> \n <li> <code>uni-app</code>相比微信原生，性能接近，算是一个数量级；并且随着数据量增加，性能消耗增加不明显，从438到454，只有16毫秒的变化</li> \n <li> <code>taro 2.0</code>随着数据量越大，性能损耗随着增大，从595到790，有将近200毫秒的变化；</li> \n <li> <code>taro next</code>和<code>kbone</code>相比之下，差距就比较大了。</li> \n</ul> \n<p>这个结果，和<code>web</code>开发类似，<code>web</code>开发也有原生js开发、<code>vue</code>、<code>react</code>框架等情况。如果不做特殊优化，原生js写的网页，性能经常还不如<code>vue</code>、<code>react</code>框架的性能。</p> \n<p>也恰恰是因为<code>Vue</code>、<code>react</code>框架的优秀，性能好，开发体验好，所以原生js开发已经逐渐减少使用了。</p> \n<p><strong>说明3：为何今年的性能测试数据和去年的不同？</strong></p> \n<p>细心的同学会发现，同样的测试手机，同样的测试代码，为何今年的性能数据会比<a href=\"https://juejin.im/post/5ca1736af265da30ae314248#heading-3\" rel=\"nofollow noreferrer\">去年的数据</a>有大幅提升？</p> \n<ul> \n <li>taro、uni-app及微信原生，三个框架的数据都有大幅提升，400条记录时，至少都有300毫秒的优化</li> \n <li>uni-app及优化后的微信原生，随着数据量的增加，耗时数据变化并不明显，但去年是很明显的线性增长</li> \n</ul> \n<p>其实，通过微信原生工程的数据对比，就能得出结论：2019年，微信针对小程序运行时做了大幅性能优化。</p> \n<p>这对开发者来说应该是个<strong>好消息</strong>，小程序性能体验更佳，可承载更好的用户业务。</p> \n<p>复杂长列表加载下一页评测结论：微信原生开发(手动优化) ~ <code>uni-app</code> &gt; 微信原生开发(未手动优化) ~ <code>taro 2.0</code> &gt; <code>taro next</code> &gt; <code>kbone</code></p> \n<h3>点赞组件响应速度</h3> \n<p>长列表中的某个组件，比如点赞组件，点击时是否能及时的修改未赞和已赞状态？是这项测试的评测点。</p> \n<p>测试方式：</p> \n<ul> \n <li>选中某微博，点击“点赞”按钮，实现点赞状态状态切换（已赞高亮、未赞灰色），</li> \n <li>点赞按钮 <code>onclick</code>函数开头开始计时，<code>setData</code>回调函数开头结束计时；</li> \n</ul> \n<p>在红米手机（Redmi 6 Pro）上进行多次测试，求其平均值，结果如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326488\" src=\"http://localhost:8060/tup/2020/4/23/6567035c057b4b00a3f81e73f72e1637.jpg\" alt=\"\" title=\"\"></span></p> \n<p>说明：也就是在列表数量为400时，微信原生开发的应用，点赞按钮从点击到状态变化需要26毫秒。</p> \n<p>测试结果数据说明：</p> \n<ul> \n <li>taro next/kbone 测试数据不完整的原因同上，在组件较多时，页面已经不再渲染了</li> \n <li>taro 2.0版本、uni-app和微信原生在点赞组件上的性能体验接近，但taro next和kbone有较大的性能差距，这个也是因为动态运行时框架导致的。</li> \n</ul> \n<p>组件数据更新性能测评：<code>uni-app</code> ~ <code>taro 2.0</code> &gt; <code>taro next</code> &gt; <code>kbone</code></p> \n<p>综上，本性能测试做了2个测试，长列表加载和组件状态更新，综合2个实验，结论如下：</p> \n<p>微信原生开发(手动优化) ~ <code>uni-app</code> &gt; 微信原生开发(未手动优化) ~ <code>taro 2.0</code> &gt; <code>taro next</code> &gt; <code>kbone</code></p> \n<h2>跨端支持</h2> \n<p>这三个框架都是为了解决平台同构问题，跨端的比较是必需的。</p> \n<p><code>taro</code> 和 <code>uni-app</code> 相对比较成熟，支持主流的所有平台。kbone 只支持微信小程序和 Web 端。我们重点比较一下 <code>taro</code> 和 <code>uni-app</code>。</p> \n<h3>小程序平台</h3> \n<p><code>taro</code> 和 <code>uni-app</code> 均支持微信、支付宝、百度、字节跳动小程序，功能基本可以拉齐。</p> \n<p>双方都有不少大厂案例，<code>taro</code>有京东、货拉拉、淘票票等公司小程序案例，<code>uni-app</code>有腾讯、华为、vivo、联想、中华英才网等公司小程序案例。</p> \n<h3>App平台</h3> \n<ul>\n <li>能力方面</li>\n</ul> \n<p><code>taro</code>与微信小程序引擎拉齐度较低，很多功能需要开发者分别在iOS和Android上做原生开发才能实现。比如App端很常见的三方登录、支付、分享等能力，<code>taro</code>并未封装。</p> \n<p><code>uni-app</code>则在基础引擎层面提供了丰富的能力，还提供了丰富的插件市场，可切实提升开发者的效率。</p> \n<ul>\n <li>性能方面</li>\n</ul> \n<p><code>taro</code>在App端使用了<code>react native</code>的渲染引擎，虽然渲染层ui是原生的，但在实时交互和高响应要求的UI操作方面表现一直不佳，js层和视图层的通信损耗让很多开发者深感无力。</p> \n<p><code>uni-app</code>的App引擎同时给开发者提供了原生渲染引擎和小程序引擎的双选方案，并且由于发明了renderjs技术，以及支持wxs、bindingx等技术，解决了js层和视图层的通信损耗问题，在高响应要求的UI操作方面有更好的性能表现。比如这类canvas动画：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326491\" src=\"http://localhost:8060/tup/2020/4/23/156e580b3eb3483580cd0eb888992547.jpg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li>开发体验方面</li>\n</ul> \n<p>taro的开发者需自行搭建iOS/Android开发环境，比较繁琐，（<a href=\"https://taro-docs.jd.com/taro/docs/react-native.html#%E6%90%AD%E5%BB%BA-android-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83\" rel=\"nofollow noreferrer\">官方原文地址</a>）：</p> \n<p><code>uni-app</code>可以做到让前端开发者不依赖原生工程师独立完成App。其开发的小程序，可以更平滑的变成可商用的App。</p> \n<p>使用跨平台开发的核心诉求在于提升效率，如果一个App的开发由前端、iOS、Android等3拨工程师协作完成，其实效率反而非常低。</p> \n<p>另外，<code>uni-app</code>还提供了uni小程序sdk，这个工具可以帮助原生App快速搭建自己的小程序平台。这是其他框架所未提供的。</p> \n<h3>H5平台</h3> \n<p>taro的H5平台在一年来的进步较多，可用性大幅提升。但相比于<code>uni-app</code>，目前仍然缺失对wxs和小程序组件的支持。</p> \n<h3>快应用</h3> \n<p><code>taro</code>支持快应用的时间比<code>uni-app</code>早。</p> \n<p>但快应用发展到2020年有了一些变化，<code>uni-app</code>针对新的形势，提供了2个发行到快应用的方案（当前两个版本都处于社区维护状态）：</p> \n<ul> \n <li>quickapp-vue版：<a href=\"https://doc.quickapp.cn/tutorial/others/vue.html\" rel=\"nofollow noreferrer\">使用 Vue开发快应用</a>。此方案由小米主导，但华为快应用暂不支持。</li> \n <li>quickapp-light版：基于小程序架构的快应用（Light版），详见<a href=\"https://www.hellohub.cn\" rel=\"nofollow noreferrer\">https://www.hellohub.cn</a>。此方案由华为主导，但小米快应用暂不支持。</li> \n</ul> \n<h3>跨端灵活性</h3> \n<p>跨端开发，离不开条件编译。因为不能用统一来抹杀各个平台的特色。</p> \n<p>优良的条件编译能力对各端开发的灵活度至关重要，可以让开发者在共享和个性化之间游刃有余。</p> \n<p><code>taro</code> 、<code>uni-app</code>和 <code>kbone</code> 均支持在<code>js</code>代码通过<code>process.env</code>判断平台，然后编写平台特有代码。</p> \n<p><code>taro</code>额外支持统一接口的多端文件编码方式，以及在样式文件中使用<code>ifdef</code>条件编译。</p> \n<p><code>uni-app</code>是全面可条件编译的，目录、文件、配置、组件、js、css，所有一切均可通过<code>ifdef</code>条件编译。</p> \n<p>跨端支持小结结论：<code>uni-app</code> &gt; <code>taro</code> &gt; <code>kbone</code></p> \n<h2>开发体验</h2> \n<p><code>taro</code>、<code>uni-app</code>、<code>kbone</code>均支持<code>cli</code>模式，可以在主流前端工具中开发，且基本都带有d.ts的语法提示库。三个框架均支持主流的<code>vue</code>或<code>react</code>语法，配套的ide工具链较丰富，着色、校验、格式化完善。</p> \n<p>相比微信原生，这三个开发框架的开发体验都更为优秀。</p> \n<p>但在开发工具维度上，明显高出一截的框架是<code>uni-app</code>，其出品公司同时也是HBuilderX的出品公司<a href=\"https://dcloud.net.cn/\" rel=\"nofollow noreferrer\">DCloud.io</a>，HBuilderX为<code>uni-app</code>做了很多优化，代码提示、转到定义、easycom、运行调试...故<code>uni-app</code>的开发效率、易用性非其他框架可及。</p> \n<p>开发体验维度，对比结果：<code>uni-app</code> &gt; <code>taro</code>,<code>kbone</code></p> \n<h2>serverless/云开发</h2> \n<p>serverless是目前炙手可热的一个概念，被称为下一代的云技术，是真正的”云“。</p> \n<p>微信率先将 serverless 技术引入小程序开发领域，即<a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html\" rel=\"nofollow noreferrer\">云开发</a>，帮助开发者云端一体的完成业务。随后，支付宝、百度都上线了自己的云开发。根据微信公开的数据，已经有50万开发者在使用微信云开发了。</p> \n<p>不过小程序厂家主导的云开发存在一个天然限制，就是和平台绑定过紧，无法和其它平台共享数据。</p> \n<p>我们以微信云开发为例，如果你仅开发微信小程序，数据独家存在微信平台，那没问题；但如果你同时还有App或其他家小程序，此时微信小程序的数据存储在微信平台，其它平台的数据存储在开发者自己的服务器上，此时就出现了数据割裂。假设一个用户先使用小程序，个人数据存储在微信平台；有了粘性后升级到App，此时App端无法读取微信平台的数据，则用户就无法查看之前在小程序上的历史数据，甚至在App平台需要重新注册。这种情况对开发者是不利的。</p> \n<p>因此，跨端的 serverless 方案才是开发者的最优解。</p> \n<p>目前主流框架对云开发的支持情况：</p> \n<ul> \n <li>Taro：仅支持微信小程序，详见<a href=\"https://taro-docs.jd.com/taro/docs/wxcloudbase.html\" rel=\"nofollow noreferrer\">小程序云开发模板</a> </li> \n <li>uni-app：DCloud 联合阿里云、腾讯云，提供基于 serverless 模式和 js 编程的云开发平台，支持App/H5/小程序所有平台，详见<a href=\"https://uniapp.dcloud.net.cn/uniCloud/README\" rel=\"nofollow noreferrer\">uniCloud</a> </li> \n <li>kbone：仅支持微信小程序，详见<a href=\"https://wechat-miniprogram.github.io/kbone/docs/guide/advanced.html#%E4%BA%91%E5%BC%80%E5%8F%91\" rel=\"nofollow noreferrer\">云开发</a> </li> \n</ul> \n<p>serverless 维度上，<code>uni-app</code>大幅领先其它框架。</p> \n<h2>插件市场</h2> \n<p>一个开发框架能否成功，除了框架自身的高度产品化外，开发者生态的构建也至关重要。</p> \n<p><code>uni-app</code> 于2018年底率先推出<a href=\"https://ext.dcloud.net.cn\" rel=\"nofollow noreferrer\">插件市场</a>，支持前端组件、js sdk、页面模板、项目模板、原生插件等多种类型，且提供了赞赏、付费购买等手段，刺激轮子作者的创作激情。目前市场上已发布插件接近1500个，众多插件下载量都在万次以上。</p> \n<p><code>Taro</code> 于 2019年5月上线<a href=\"http://taro-ext.jd.com/\" rel=\"nofollow noreferrer\">物料市场</a>，目前市场上已发布物料90个；从热门榜单来看，下载量并不大，下载最多的也就数百。</p> \n<p><code>kbone</code>目前还没有插件市场。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326490\" src=\"http://localhost:8060/tup/2020/4/23/fa649df0f3544eeaa0763af01101d285.jpg\" alt=\"\" title=\"\"></span></p> \n<p>Tips:</p> \n<ul>\n <li>插件数量及下载量数据采集时间为 2020.04.03 16：00</li>\n</ul> \n<p>插件市场维度，<code>uni-app</code>独领风骚。</p> \n<h2>学习资源</h2> \n<p>除了各大框架官网外，开发者通常还会通过视频教程、社区博客等方式系统学习。</p> \n<p>相关学习资源的丰富程度，也能侧面反映一个框架的受欢迎程度，故我们采集了几个三方站点的数据。</p> \n<p><strong>视频教程</strong></p> \n<table> \n <thead>\n  <tr> \n   <th>框架</th> \n   <th>腾讯课堂</th> \n   <th>网易云课堂</th> \n   <th>慕课网</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>taro</td> \n   <td>4</td> \n   <td>1</td> \n   <td>2</td> \n  </tr> \n  <tr> \n   <td>uni-app</td> \n   <td>16</td> \n   <td>16</td> \n   <td>1</td> \n  </tr> \n </tbody> \n</table> \n<p>Tips：</p> \n<ul>\n <li>视频教程数据采集时间为2020.04.05 22:00</li>\n</ul> \n<h2>开发交流</h2> \n<p>除了入门的学习资源，开发期的交流也很重要，这个我们主要看官方组织的社区和交流群。</p> \n<h3>社区论坛</h3> \n<p><code>uni-app</code> 的<a href=\"https://ask.dcloud.net.cn\" rel=\"nofollow noreferrer\">问答社区</a>，帖子丰富，沉淀较多；目前已沉淀2万多相关帖子，每日更新帖子数百篇，月uv百万。</p> \n<p>对于习惯使用 github issue反馈问题的用户，<code>uni-app</code>同样支持，目前累计有1391个issues。</p> \n<p>Taro 早期基于github issue进行产品Bug管理，目前累计已有近4898个issue；后于2019年5月上线<a href=\"http://taro-club.jd.com/\" rel=\"nofollow noreferrer\">开发者社区</a>，和物料市场上线时间相同，目前沉淀1300+帖子，每日更新帖子在10个左右，相关数据计算方法如下：</p> \n<ul> \n <li>帖子总数：Taro 社区顶部选择<code>板块</code>，计算每个板块下所有主题总数，如下图。</li> \n <li>每日更新帖子数：根据帖子列表中的最后回复时间，计算24小时内有回复或评论的主题总数</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326492\" src=\"http://localhost:8060/tup/2020/4/23/13604e81fa7b4cae83edd3699a746715.jpg\" alt=\"\" title=\"\"></span></p> \n<p>kbone 在微信开放社区中新增了一个<a href=\"https://developers.weixin.qq.com/community/minihome/mixflow/1213301129006825473\" rel=\"nofollow noreferrer\">Kbone官方框架</a>的专区，因产品发布较晚，目前只有一百多个帖子。</p> \n<p>总结一下社区帖子及issue数据，情况如下（采集时间为 2020.04.03 23：00）：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326493\" src=\"http://localhost:8060/tup/2020/4/23/ad5069e5384a4f768d964a7cf2d616ec.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>交流群</h3> \n<table> \n <thead>\n  <tr> \n   <th>框架</th> \n   <th>微信群</th> \n   <th>QQ群</th> \n   <th>交流群开发者（预估）</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>taro</td> \n   <td>16</td> \n   <td>-</td> \n   <td>8k</td> \n  </tr> \n  <tr> \n   <td>uni-app</td> \n   <td>20</td> \n   <td>40+</td> \n   <td>90k</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>-</td> \n   <td>1</td> \n   <td>0.5k</td> \n  </tr> \n </tbody> \n</table> \n<p>Tips:</p> \n<ul> \n <li>Taro 有16个微信群是根据 Taro 官网上显示<code>Taro 开发交流 15 群 已满</code>推论而出，每个微信群500人，交流群人数： 500*16 = 8000人</li> \n <li>uni-app 官网 QQ群有35个，微信群20个，还有十几个专项QQ群，其中有30个QQ群达到2000人，交流群人数： 30 <em> 2000 + 5</em> 1000 + 20*500 + 5000 = 90000人</li> \n <li>kbone 在 github 的 readme中有一个qq交流群，申请加入时显示500人已满</li> \n</ul> \n<p>除了交流群外，DCloud对外公布的<code>uni-app</code>的开发者数量达到百万人，暂未看到<code>taro</code>和<code>kbone</code>公布此类数据。</p> \n<p>总体而言，开发交流维度比较结果如下：<code>uni-app</code> &gt; <code>taro</code> &gt; <code>kbone</code></p> \n<h2>其它指标</h2> \n<h3>github</h3> \n<table> \n <thead>\n  <tr> \n   <th>框架</th> \n   <th>star</th> \n   <th>贡献者</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>taro</td> \n   <td>24.6k</td> \n   <td>122</td> \n  </tr> \n  <tr> \n   <td>uni-app</td> \n   <td>19.7k</td> \n   <td>72</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>2.7k</td> \n   <td>7</td> \n  </tr> \n </tbody> \n</table> \n<p>在开源社区方面，<code>Taro</code>做的还是非常成功的，它吸引了更多开发者为其贡献代码、文档。</p> \n<h3>百度指数</h3> \n<p>通过<a>index.baidu.com</a>，可查看主流框架的搜索指数，它代表了网友的搜索量和相关文章的收录量。目前<code>kbone</code>尚未收录到百度指数中，如下是近期 <code>uni-app</code> 和 <code>taro</code>的百度指数对比图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326494\" src=\"http://localhost:8060/tup/2020/4/23/14a806efc99e44f1b6451b58d5318212.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>结语</h2> \n<p>所有的评测都只是提供决策依据，最后的结果还是要依赖开发者的团队技术栈、业务诉求、未来规划等。</p> \n<p>不过作为一篇评测文章的结语，我们还是要给出自己的建议：</p> \n<ul> \n <li>如果你熟悉React，不懂Vue.js，推荐Taro；</li> \n <li>如果你熟悉Vue.js，则推荐 uni-app；</li> \n <li>如果你已经有H5代码，只想增加微信小程序平台，并且对性能要求不高，可以考虑kbone；</li> \n <li>如果你的业务涉及多端，更推荐 uni-app；</li> \n <li>如果你希望通过 serverless 方案快速上线业务，推荐 uni-app。</li> \n</ul> \n<p>如有读者认为本文中任何评测失真，欢迎在这里报 <a href=\"https://github.com/dcloudio/test-framework/issues\" rel=\"nofollow noreferrer\">issuse</a>。</p>', null, 'http://localhost:8060/tup/2020/4/23/84b58ee0253d496dad2792859df6b211.jpg', '1894b118d35d44cb8fe8009529c4154b', '7b3e40f8b9cc4b7780dc39a71d7f580e', '15ef803612034600809b3e6c99cb32ab,7506700dea5a42298b9ecb0ac0aaab41,3b375646301546259a8fb29d74ae4447', '0', '3', '1', '2020-04-23 10:30:02', '2020-04-23 10:30:02');
INSERT INTO `tb_recommend` VALUES ('a11e54ac7d3345eaadb149819432d9f4', '推荐4个chrome浏览器插件，顺溜浏览github', 'octotree 以IDE的形式展示github文件 wide github 将github页面变宽，更符合IDE的排版 github dark theme github秒变dark模式，喜欢暗黑模式的我们必须中意的颜色 下载完上述插件后，刷新chrome浏览器，github项...', '<ul>\n <li><a href=\"https://chrome.google.com/webstore/detail/octotree/bkhaagjahfmjljalopjnoealnfndnagc?hl=en-US\" rel=\"nofollow noreferrer\">octotree</a></li>\n</ul> \n<p>以IDE的形式展示github文件</p> \n<ul>\n <li><a href=\"https://chrome.google.com/webstore/detail/wide-github/kaalofacklcidaampbokdplbklpeldpj?hl=en\" rel=\"nofollow noreferrer\">wide github</a></li>\n</ul> \n<p>将github页面变宽，更符合IDE的排版</p> \n<ul>\n <li><a href=\"https://chrome.google.com/webstore/detail/github-dark-theme/odkdlljoangmamjilkamahebpkgpeacp?hl=en-US\" rel=\"nofollow noreferrer\">github dark theme</a></li>\n</ul> \n<p>github秒变dark模式，喜欢暗黑模式的我们必须中意的颜色</p> \n<p>下载完上述插件后，刷新chrome浏览器，github项目查看最终结果</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGiyb\" src=\"http://localhost:8060/tup/2020/4/23/5cd14e22c5e94d68be7d4cb018415f5b.jpg\" alt=\"demo.JPG\" title=\"demo.JPG\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/26a49482e842453195e0cde61e0a5210.jpg', '5ca4567d892841b087fac5246effac40', '2a353971222c4aff8e8d3e9c370330cd', '634b81d655c74cb0adc4d0aa362b8819,4bbfbe8b4f0e4788a82ceac3f3c96168', '0', '3', '1', '2020-04-23 10:59:27', '2020-04-23 10:59:27');
INSERT INTO `tb_recommend` VALUES ('a335f071256f44e79a82039d8f167d5b', '译文丨为什么做程序员会让我成为一个更好的医生？', 'Stanford Medicine Unplugged 是一个为学生提供的论坛，记录他们在医学院的经历。学生们撰写的文章在学年期间每周在Scope上发表一次；整个系列博客可以在Stanford Medicine Unplugged分类中找到。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQQO\" src=\"http://localhost:8060/tup/2020/4/23/26bcd0f5193f474e999c929dda472737.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>Stanford Medicine Unplugged 是一个为学生提供的论坛，记录他们在医学院的经历。学生们撰写的文章在学年期间每周在Scope上发表一次；整个系列博客可以在Stanford Medicine Unplugged分类中找到。</p> \n<p>原文链接：<a href=\"https://scopeblog.stanford.edu/2020/03/18/why-being-a-programmer-will-make-me-a-better-doctor/\" rel=\"nofollow noreferrer\">https://scopeblog.stanford.ed...</a></p> \n<hr> \n<blockquote>\n Tim Keyes Published on March 18, 2020\n</blockquote> \n<p>作为一名医学博士生，我的研究方向更多的是机器学习和算法开发，而不是生物学，我花了大量的时间来思考我所需要的研究技能和作为一名未来的医生提供良好的临床护理所需要的技能之间的脱节。</p> \n<p>我的研究重点是建立小儿癌症治疗反应和复发的预测模型，所以我的大部分时间都是在写 R 和 Python 代码，用来整理、可视化和建模从患者那里收集的数据。然而，尽管我把大部分时间都花在了编程上，但我知道，在临床环境中，编码并不是护理病人所需的前 20 名（.........或者说前 100 名）的技能。</p> \n<p>不过，几年来在这两种环境下的经验告诉我，我从做程序员的过程中学到的一些教训，可以很好地应用到我作为一名医学生的生活中--这也是我未来平衡这两个世界的好兆头。</p> \n<p>以下是我的一些感悟。</p> \n<h2>将问题分解成子问题</h2> \n<p>对于任何数据科学或编程项目来说，将你的总体目标分解成一系列更小、更易管理的目标，每次都能处理好的目标是至关重要的。例如，如果你要实现一个有三个不同步骤的算法，一个最佳的策略通常是先写出分别实现每个步骤的代码，然后再写出一个将它们结合在一起的函数。通过这样做，你可以让你的代码保持有条理、高效和易懂。</p> \n<p>我发现自己在医学上也应用了同样的原则。例如，在记录病史时，将对话分成几个独立的步骤，即 「现在的病史」、「过去的病史」、「社会史」等，每一个步骤都对应着病人的背景和需求的一小部分。这样一来，我就能可靠地获得我所需要的所有信息，不会遗漏任何重要的信息。</p> \n<h2>备忘录式记忆法</h2> \n<p>在计算机科学中，「备忘录化」是一种编码技术，可以通过重用之前已经解决过的问题的答案来加快算法的速度。换句话说，「备忘录化」的算法只需要花时间从头开始解决一个问题一次 —— 以后每次遇到同样的问题，它就会简单地查找旧的解决方案（就像备忘一样），而不是第二次从头开始重新解决问题。这意味着，算法第一次解决问题的速度会比较慢，但在以后解决同样的问题时，效率会提高很多。</p> \n<p>从很多方面来说，我觉得做医学生就像上了一堂记忆力的大师课。很多东西刚开始学的时候都会让人应接不暇，必须要掌握好小的步骤，才能向大的方向发展。比如说，在医学院的第一个季度，我在听诊器上挣扎着要通过听诊器听出任何心脏的声音，我和同学们练习了好几遍才终于成功。他们向我展示了他们的听诊器放置方法，如果对我也有效，我就把它作为我的过程的一部分。</p> \n<p>一年后，全面的心脏检查 -- 包括听杂音、摩擦和心跳加速--成为我的反射性工作，以至于我几乎不需要考虑。尽管一开始很慢，但我最终还是掌握了每一个步骤，并结合过去对我（或我的同学们）有效的方法，形成了一套完全「备忘录式记忆」的方法。</p> \n<h2>经常检查边缘案例</h2> \n<p>在编程中，「边缘案例」指的是你通常不会想到的情况。例如，在一个计算机程序中，比较两个数字并告诉你哪一个大，「边缘情况」可能是指当两个数字完全相同时发生的情况（因为从技术上讲，两个数字都不比另一个大）。一般来说，思考和测试边缘案例对于确保你的代码不会在看到一些意料之外的东西时崩溃是很重要的 -- 这可能会导致灾难性的结果！</p> \n<p>在医学中，对边缘案例的核算需要对边缘案例进行核算，这就要求我们在编写代码时，要考虑到边缘案例的重要性。</p> \n<p>在医学上对边缘案例进行核算，需要和编程中一样的创造力和前瞻性思维。通常情况下，医生们必须进行「如果」的思考，以考虑到多种诊断的可能性，即使看起来只有一两个可能性。例如，我和我的顾问有一个病例，一个病人在开始化疗前一天就出现了流鼻涕。基于病人过去的季节性过敏史和那天的高花粉量，大多数迹象似乎表明没有什么可担心的。但是，为了排除病人感染了急性病毒性感染的可能性不大，当他的免疫系统被化疗压制后可能会变得严重的「边缘情况」，我的顾问在开始治疗前一定要做一些常见的虫子的测试。</p> \n<p>尽管计算机科学和医学看似不同，但我已经开始欣赏他们的许多相似的思维方式。其中包括对创造力、深思熟虑和高效解决问题的共同承诺。基于这些原因以及更多的原因，我希望 —— 尽管我不太可能在病房里直接使用我的编码技能 —— 但作为一名程序员最终会让我成为一名更好的医生。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFxVM\" src=\"http://localhost:8060/tup/2020/4/23/f85c615ccd6e4ed399a46ac646427568.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/6aea015e5a724695b5899550ab9adc27.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '2a353971222c4aff8e8d3e9c370330cd', '81a4561c1c294e0cae32c9fe6b5dc397,78b2eb8f68e34e6e8e8863c0ed281b45,db6b58ae709645f2b64166fd73f2f705', '0', '3', '1', '2020-04-23 11:00:52', '2020-04-23 11:00:52');
INSERT INTO `tb_recommend` VALUES ('a7f2252c154049d191a49b768b8c32f0', '云开发之实时数据推送：打造在线对战五子棋', '本次「云开发」公开课，将通过实战「在线对战五子棋」，一步步带领大家，在不借助后端的情况下，利用「小程序 ✖ 云开发」，独立完成一款微信小游戏的开发与上线。', '<blockquote>\n 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：\n <br>「微信公众号：\n <strong>心谭博客</strong>」| \n <a href=\"https://xin-tan.com/\" rel=\"nofollow noreferrer\">xin-tan.com</a> | \n <a href=\"https://github.com/dongyuanxin/blog\" rel=\"nofollow noreferrer\">GitHub</a> \n</blockquote> \n<h2>1 项目概述</h2> \n<p>游戏开发，尤其是微信小游戏开发，是最近几年比较热门的话题。</p> \n<p>本次「云开发」公开课，将通过实战「在线对战五子棋」，一步步带领大家，在不借助后端的情况下，利用「小程序 ✖ 云开发」，独立完成一款微信小游戏的开发与上线。</p> \n<h2>2 任务目标</h2> \n<p>根据项目初始框架，阅读教程的同时，逐步完成棋盘绘制、音乐播放、玩家对战、输赢判定等功能，最终实现一个可以快乐玩耍的在线对战五子棋。</p> \n<p>在这个过程中，会了解到 Serverless 的一些概念，并且实际应用它们，比如：<strong>云数据库</strong>、<strong>云存储</strong>、<strong>云函数</strong>、<strong>增值能力</strong>。除了这些基本功能，还准备了更多的硬核概念与落地实践，比如：<strong>实时数据库</strong>、<strong>聚合搜索</strong>、<strong>权限控制</strong>。</p> \n<p>完成开发后，上传并且设置为体验版，欢迎邀请更多人来体验。</p> \n<h2>3 准备工作</h2> \n<p>从 <a href=\"https://github.com/TencentCloudBase/tcb-game-gomoku\" rel=\"nofollow noreferrer\">TencentCloudBase/tcb-game-gomoku</a> 中下载代码到本地：</p> \n<pre><code class=\"bash\">git clone https://github.com/TencentCloudBase/tcb-game-gomoku.git\ncd tcb-game-gomoku/</code></pre> \n<p>切换课程专用的 <code>minigame-study</code> 分支：</p> \n<pre><code class=\"bash\">git checkout minigame-study</code></pre> \n<p>⚠️<code>minigame</code>分支保存着「小游戏版」的完整代码，<code>miniprogram</code>分支保存着「小程序版」的完整代码。</p> \n<h2>4 游戏流程图</h2> \n<p>小游戏版本的核心放在了实时对战上，中间穿插应用了云开发的各个方面。如果想体验完整的流程与交互，请前往<a href=\"https://github.com/TencentCloudBase/tcb-game-gomoku/tree/miniprogram\" rel=\"nofollow noreferrer\"><code>miniprogram</code>分支</a>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218520?w=888&amp;h=1049\" src=\"http://localhost:8060/tup/2020/4/23/e95a29c9d0d04c9bb4a37415764796cc.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>5 实战任务</h2> \n<h3>5.1 创建云开发与小游戏环境</h3> \n<p>1、打开微信 IDE，点击左侧的小游戏，选择右侧的导入项目，导入之前下载的「在线对战五子棋」的目录，AppID 修改为你已经注册好的小游戏 AppID。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218521?w=1628&amp;h=1104\" src=\"http://localhost:8060/tup/2020/4/23/08da14958c9446e78e8c34cb12d8ad3f.jpg\" alt=\"\" title=\"\"></span></p> \n<p>2、进入后，点击上方的云开发按钮。如果之前没有开通过云开发，需要开通云开发，新开通的话需要等待 10 ～ 20 分钟。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218522?w=1168&amp;h=174\" src=\"http://localhost:8060/tup/2020/4/23/3eea4a26998f408d8639a0be5ea7c710.jpg\" alt=\"\" title=\"\"></span></p> \n<p>3、进入「云开发/数据库」，创建新的集合，新集合的名称是<code>rooms</code>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218524?w=2072&amp;h=662\" src=\"http://localhost:8060/tup/2020/4/23/69e56971ff8b455f8e7dc999ecee2b0c.jpg\" alt=\"\" title=\"\"></span></p> \n<p>4、进入「云开发/存储」，点击“上传文件”。上传的内容是<code>/static/</code>下的<code>bgm.mp3</code> 和 <code>fall.mp3</code>。之后的代码中会通过云存储的接口，请求文件的临时 url，这样做的目的是<strong>减少用户首次进入游戏加载的静态资源</strong>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304018\" src=\"http://localhost:8060/tup/2020/4/23/d7b5a262adbd4e23af706e743982a832.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>5.2 准备配置文件</h3> \n<p>创建配置文件：</p> \n<pre><code class=\"bash\">cp miniprogram/shared/config.example.js miniprogram/shared/config.js</code></pre> \n<p>将关键字段的信息，换成自己账号的信息即可：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304019\" src=\"http://localhost:8060/tup/2020/4/23/55dc462c321e4504ae103a06b0e4a2c3.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>5.3 创建云开发接口</h3> \n<p>打开 <code>miniprogram/shared/cloud.js</code>，在里面初始化云开发能力，并且对外暴露云数据库以及聚合搜索的 API。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218527?w=1512&amp;h=1358\" src=\"http://localhost:8060/tup/2020/4/23/c3daa987d69f4d7d943a09db608deb3e.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>5.4 获取云存储资源的链接</h3> \n<p>为了减少用户首屏加载的静态资源，音乐资源并没有放在<code>miniprogram</code>目录下，而是放在了云存储中，通过调用云存储的 api 接口，来返回静态资源的临时链接。</p> \n<p>在 <code>miniprogram/modules/music.js</code>中，会调用资源接口，获取资源链接：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218528?w=1638&amp;h=1476\" src=\"http://localhost:8060/tup/2020/4/23/4c604c9ee7ea457cb57e33bd65c753a7.jpg\" alt=\"\" title=\"\"></span></p> \n<p><code>getTempFileURL</code>函数属于云开发相关，因此放在了 <code>miniprogram/shared/cloud.js</code>中。这里只需要临时链接<code>tempFileURL</code>属性，其它返回值直接过滤调即可。</p> \n<p>为了方便外面调用，promise 内部不再用 reject 抛错。对于错误异常，返回空字符串。这样，加载失败的资源不会影响正常资源的加载和 Promise.all 中逻辑进行。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304020\" src=\"http://localhost:8060/tup/2020/4/23/8cb8c4e163a1438e840bf3f5a204038f.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>5.5 游戏进入与身份判断</h3> \n<p>根据前面的流程图我们可以看到，游戏玩家的身份是分为 owner 与 player。它们的含义如下：</p> \n<ul> \n <li>owner：玩家进入游戏后，查找是否有空闲房间，如果不存在空闲房间，那么就会主动创建新的空闲房间。那么对于新创建的房间，玩家就是 owner。</li> \n <li>player：玩家进入游戏后，查找是否有空闲房间，如果存在空闲房间，那么就加入空闲房间。那么对于空闲房间，玩家就是 player。</li> \n</ul> \n<p>判断的依据就是 <code>judgeIdentity</code> 方法中，读取云数据库集合中的 rooms 的记录。如果存在多个空闲房间，需要选取创建时间最近的一个房间。因此，这里需要用到「聚合搜索」的逻辑。</p> \n<p>聚合搜索的条件，在这里有 3 个：</p> \n<ol> \n <li>标记人数的字段，是否为 1</li> \n <li>创建时间倒叙排序</li> \n <li>只选择 1 个</li> \n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304021\" src=\"http://localhost:8060/tup/2020/4/23/235988f6cd534fb79cb33bef82572a18.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>5.6 创建新房间</h3> \n<p>在上述的身份判断函数逻辑中，如果聚合搜索查询的结果为空，说明没有空闲房间，玩家需要作为 owner 来创建新的房间，等待其它玩家加入。</p> \n<p>创建房间的逻辑就是将约定好的字段，放进云数据库的记录中。这些字段有：</p> \n<ul> \n <li>roomid&lt;<code>String</code>&gt;: 6 位房间号，<strong>唯一</strong> </li> \n <li>nextcolor&lt;<code>\"white\" | \"black\"</code>&gt;: 下一步是白棋/黑棋走</li> \n <li>chessmen&lt;<code>String</code>&gt;: 编码后的棋盘数据</li> \n <li>createTimestamp&lt;<code>String</code>&gt;: 记录创建时间戳，精确到 ms</li> \n <li>people&lt;<code>Number</code>&gt;: 房间人数</li> \n</ul> \n<p>是的，你可能注意到了，这里需要保证 roomid 是不重复的。因此本地生成的随机 roomid，需要先调用云数据库的查询接口，检测是否存在。如果存在，那么递归调用，重新生成随机字符串。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218531?w=1812&amp;h=1306\" src=\"http://localhost:8060/tup/2020/4/23/97e384b6a45b46d98cf9072ac974315b.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>5.7 监听玩家进入</h3> \n<p>对于 owner 身份来说，除了要创建新房间，还需要在创建后监听 player 身份的玩家进入游戏。</p> \n<p>对于 player 身份的玩家进入游戏后，会更新记录中的 people 字段（1 =&gt; 2）。这时候就需要利用「实时数据库」的功能，监听远程记录的 people 字段变化。</p> \n<p>代码实现上，调用<code>watch</code>方法，并且传递<code>onChange</code>函数参数。一旦有任何风吹草动，都可以在<code>onChange</code>回调函数中获得。对于传递给回调函数的参数，有两个比较重要：</p> \n<ul> \n <li>docChanges&lt;<code>Array</code>&gt;: 数组中的每一项对应每条记录的变化类型，变化类型有 init、update、delete 等。</li> \n <li>docs&lt;<code>Array</code>&gt;: 数组中的每一项对应每条记录的当前数据。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218532?w=2022&amp;h=1326\" src=\"http://localhost:8060/tup/2020/4/23/8a77ce0f463c4ec29eb57bee8bc2e10a.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>5.8 越权更新字段</h3> \n<p>对于 player 身份来说，进入房间后，既不需要「创建新房间」，也不需要「监听玩家进入」。但需要更新记录的 people 字段。由于记录是由 owner 身份的玩家创建的，而云数据库只有以下 4 种权限：</p> \n<ul> \n <li>所有用户可读，仅创建者可读写</li> \n <li>仅创建者可读写</li> \n <li>所有用户可读</li> \n <li>所有用户不可读写</li> \n</ul> \n<p>以上 4 种权限，并没有「所有用户可读写」。因此，对于越权读写的情况，需要通过调用云函数来以“管理员”的权限实现。在 <code>cloudfunction</code> 中创建 <code>updateDoc</code> 云函数，接收前端传来的 collection、docid、data 字段。对于 data 字段来说，就是数据记录的最新更新数据。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304022\" src=\"http://localhost:8060/tup/2020/4/23/ee95345fa94e4012b14c390d54c2e2b5.jpg\" alt=\"\" title=\"\"></span></p> \n<p>在小游戏中，通过<code>wx.cloud.callFunction</code>来调用云函数。传入的 data 字段指明被调用的云函数，传入的 data 字段可以在云函数的回调函数的 event 参数中访问到（如上图所示）。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304023\" src=\"http://localhost:8060/tup/2020/4/23/a5c6eafbb99b4cd9b077e901db37e059.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>5.9 落子更新逻辑</h3> \n<p>不论对于 player 还是 owner 身份，都需要处理落子的逻辑。落子逻辑中，下面的两种情况是属于无效落子：</p> \n<ol> \n <li>点击位置已经有棋子</li> \n <li>对方还未落子，目前依然处于等待情况</li> \n</ol> \n<p>对于以上两种情况，处理的逻辑分别是：</p> \n<ol> \n <li>棋盘状态保存在内部类中，调用落子的函数，会返回是否成功的字段标识</li> \n <li>只有监听到远程棋盘更新后，才会打开本地的锁，允许落子；落子后，会重新上锁</li> \n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218535?w=2284&amp;h=1088\" src=\"http://localhost:8060/tup/2020/4/23/af65e9afa8064d248f1b142e51903f26.jpg\" alt=\"\" title=\"\"></span></p> \n<p>落子成功后，要在本地判断是否胜利。如果胜利，需要调用退出的逻辑。但无论是否胜利，都要将本地的最新状态更新到云端。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304024\" src=\"http://localhost:8060/tup/2020/4/23/24c12f8ef8914005b38473b86fbeba1b.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>5.10 监听远程棋盘更新</h3> \n<p>不论对于 player 还是 owner 身份的玩家，都需要监听远程棋盘的更新逻辑。当远程棋盘字段更新时，本地根据最新的棋盘状态，重绘整个棋盘。并且进行输赢判定，如果可以判定输赢，则退出游戏；否则，打开本地的锁，玩家可以落子。</p> \n<p><strong>因为不同身份均需要监听，因此这一块的监听逻辑可以复用</strong>。<strong>不同的是，两种身份的监听启动时间不一样</strong>。owner 身份需要等待 player 身份玩家进入游戏后才开启棋盘监听；player 身份是更新了 people 字段后，开启棋盘监听。</p> \n<p>在监听逻辑中，需要判断远程更新的字段是否是 chessmen，这是通过前面提及的 dataType 来实现的。还徐哟啊判断记录中的 nextcolor 字段是否和本地的 color 一样，来决定是否打开本地的锁。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218537?w=2100&amp;h=1054\" src=\"http://localhost:8060/tup/2020/4/23/7f5ca87a09e1495784e8bdfabda7ed19.jpg\" alt=\"\" title=\"\"></span></p> \n<p>如果上述的两个条件均满足，则执行更新本地棋盘、判定输赢、打开本地锁的逻辑。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304025\" src=\"http://localhost:8060/tup/2020/4/23/c9448270f5be43908c95b42a9c5537ad.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>5.11 游戏结束与退出</h3> \n<p>每次需要判定输赢的地方，如果可以判定输赢，那么都会走到游戏退出逻辑。退出的逻辑分为 2 个部分，第 1 个是给用户提示，第 2 个是调用云函数清空记录。</p> \n<p>第 1 个逻辑中用户提示，需要判定用户胜负状态：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218539?w=1226&amp;h=1030\" src=\"http://localhost:8060/tup/2020/4/23/762aa5b474fd457288af44e689cb9f89.jpg\" alt=\"\" title=\"\"></span></p> \n<p>第 2 个逻辑中清除记录的原因是为了方便调试，对于真正的业务场景，一般不会删除历史数据，方便问题定位。同时，这也是一个越权操作，需要调用云函数来实现。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218540?w=1240&amp;h=966\" src=\"http://localhost:8060/tup/2020/4/23/6981e49257b14ffeb6f76ec2ec67f24c.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>6. 课程源码</h2> \n<ul> \n <li><a href=\"https://github.com/TencentCloudBase/tcb-game-gomoku/tree/minigame-study\" rel=\"nofollow noreferrer\">小游戏版·教程</a></li> \n <li><a href=\"https://github.com/TencentCloudBase/tcb-game-gomoku\" rel=\"nofollow noreferrer\">小游戏版本</a></li> \n <li><a href=\"https://github.com/TencentCloudBase/tcb-game-gomoku/tree/miniprogram\" rel=\"nofollow noreferrer\">小程序版本</a></li> \n</ul> \n<h2>7. 更多</h2> \n<blockquote>\n 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)\n <br>\n <span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304002\" src=\"http://localhost:8060/tup/2020/4/23/fcf368a99b61445e850509bcbd5304c7.jpg\" alt=\"\" title=\"\"></span> \n</blockquote>', null, 'http://localhost:8060/tup/2020/4/23/2660659ed56d4842ba8b3f766b79ce81.jpg', '3f69fcc9b13843d1910b3dac597f5215', '1a7cc9fbc4654cb0afec84e080816ef1', 'd79254c4ca5e45dca9d484307c935281,b84d5a3e64644516915697f2c8409437,15941dc0af92453481b8a0626f963283,9424c753324d4c6198c85fff4f681dd4,83f62facb3b943ffa8e46abd1ebc64d9', '0', '3', '1', '2020-04-23 10:57:55', '2020-04-23 10:57:55');
INSERT INTO `tb_recommend` VALUES ('a94dbf495ade46688c4acf8fd3d11e81', 'Google 即将推出可自行迭代的 AI，让机器创造算法避免人为偏见', '科幻小说作家 Vernor Vinge 曾经说过，人类最后一项伟大的发明将是第一台可以自我复制的机器，而谷歌 AutoML 团队的科学家们就正在做类似的尝试。他们正在测试如何让 AI 从零开始创建一套机器学习算法，并根据数...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF8nV\" src=\"http://localhost:8060/tup/2020/4/23/61da01b844b04e188ee969107f4963f0.jpg\" alt=\"google AutoML.png\" title=\"google AutoML.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>科幻小说作家 Vernor Vinge 曾经说过，人类最后一项伟大的发明将是第一台可以自我复制的机器，而谷歌 AutoML 团队的科学家们就正在做类似的尝试。他们正在测试如何让 AI 从零开始创建一套机器学习算法，并根据数学原理自动演化迭代。</p> \n<p>他们认为「AutoML Zero」有可能会创造出“完全未知的算法，同时还能减少数据输入过程中人类的偏见”。</p> \n<p>据悉，谷歌正在为「AutoML」进行一些重大升级，根据几位内部研究人员撰写的一篇论文显示，「AutoML Zero」即将到来。</p> \n<h2>充满可能性的「AutoML Zero」</h2> \n<p>AutoML 是谷歌发布的一个开源工具，它可以非常简单的自动完成机器学习算法的开发过程。并且谷歌大脑团队一直在对这个工具进行开发迭代。</p> \n<p>在当前的迭代版本中，AutoML 仍存在一个比较大的问题，就是仍然需要手动的创建和调试几个初始的算法模型，虽然用户可以通过使用谷歌与之的算法包来解决这个问题，但毕竟还是被人类进行了干预。</p> \n<p>此次谷歌团队发表的论文，最大的亮点就是将这一部分也实现了 AI 自动化。</p> \n<p>根据论文所述，谷歌引入了一个全新的框架来搭建一个通用的搜索空间，进而只需使用基本的数学运算作为构件，就可以自动实现完整的机器学习算法。</p> \n<p>尽管这个搜索空间范围非常广，但仍然可以发现通过反向传播训练的二层神经网络来进行传播进化。构建很简单，但该框架设计来很多顶级的算法技术，比如双线相互作用、归一化梯度和权重平均等。</p> \n<p>换句话说，谷歌已经想出了如何只是用基本的数学概念，来为 AutoML 挖掘进化算法。开发者们只需创建一个简单的学习范式，在这个范式中，机器会吐出 100 个随机生成的算法，然后工作，看看哪些算法表现最好。</p> \n<p>经过几代之后，这些算法会越来越好，直到机器找到一个表现足够好的算法进行进一步的迭代。为了生成能够解决新问题的新颖算法，在进化过程中存活下来的算法会被用来测试各种标准的人工智能问题，比如计算机视觉等。</p> \n<p>据研究人员称，「AutoML Zero」已经优于其前辈和类似的最先进的机器学习生成工具。未来的研究将涉及到为人工智能设定一个更窄的范围，并使用混合方法，利用「AutoML Zero」的自我发现技术和人类创建的启动库相结合的算法，看看它在更多特定情况下的表现如何。</p> \n<h2>实现强人工智能的最快途径就是让其自行发展？</h2> \n<p>正如开头所说，「AutoML Zero」的另一大特点就是可以减少「人类的偏见」。如果我们不事先为算法设定固定的起点或者发展路径，那么 AI 更可能创造出一些我们意想不到的东西。</p> \n<p>如果我们想要让 AI 像人类一样思考，我们就不能给他们预置答案。好奇心和探索力才是人类智力的两个关键组成部分，而目前的深度学习根本不具备这两大特点。</p> \n<p>在《Quanta》杂志最近的一篇文章中，作家 Matthew Hutson 写到：</p> \n<blockquote>\n 生物进化是唯一能产生人类智能的系统，这也是许多人工智能研究者的终极梦想。由于生物进化的轨迹，Stanley 和其他人都认为，如果我们想要算法能够像人类一样轻松地驾驭物理世界和社会世界，或者说做的更好，我们就需要模仿自然界的算法和策略。\n <p>他们认为，与其硬性地给出编码规则，或者让机器学习在某些特定的性能指标上获得高评分，不如发现更多不同的解决方案。让算法优先考虑新奇性或者趣味性，而不是走路或者说话的能力。这种思路可能比直接寻求结果具有更大的价值。</p> \n</blockquote> \n<p>标准的深度学习模型一般就类似于一个黑匣子，提供一组权重和参数，由机器来进行调整和计算，从而得出相关的数据与结论。但理论上来说，这属于人为的预判，而不是机器的智能。</p> \n<p>如果人工智能能够演化出自己的解决方案，并将这些参数与深度学习相结合，那么它将更接近于模仿人类解决问题的方式。</p> \n<p>从本质上说，今天我们所说的「AutoML Zero」并不是让 AI 去解决问题，而是让 AI 开发出算法，并不断扩展发现自己的能力。</p> \n<p>Uber的AI实验室有一位计算机领域的大佬叫 Kenneth Stanley，感兴趣的可以搜一搜他发布的论文和公开的研究成果。他在「神经进化」领域做出了开拓性的贡献，首创了无目的的探索和创新性的 AI 模型。</p> \n<p>在一项测试中，他和团队的科研人员一起将一个虚拟的轮式机器人放在迷宫中，并控制它们进行算法优化，从而找到一条通往出口的路径。传统的 AI 模型在 40 次尝试中只成功了 3 次，而无目的的创新 AI 模型则成功了 39 次。这当中的区别就是创新的 AI 模型为了对迷宫进行更多的探索，并没有计算离出口的距离，没有试图寻找出口，而是避开了所有的死胡同。</p> \n<h2>进化算法，来日方长</h2> \n<p>进化算法其实并不是一个新鲜的概念，但之所以发展缓慢是因为其研究成本过高，且没有直接的应用场景来盈利或者获得相应的回报。</p> \n<p>市面上大部分的深度学习技术都是针对具体的场景解决具体的问题，但对这种「随心所欲」的算法来说，有多大的可能性就存在着多大的风险。</p> \n<p>此次谷歌推出「AutoML Zero」，很大程度上降低了进化算法的研发成本，相信也能让这一充满可能性的技术路线，更快的发挥价值。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF8nX\" src=\"http://localhost:8060/tup/2020/4/23/f0cb368f2f5446efb57ee109891cd596.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/ac7eac2a1535489193cc18fab6ec91d9.jpg', 'f53014d680884163a5bd5ce762e90cdf', 'cbad2058b4014634aec6515f4adbef0d', '6224a68b52f54990a07d51854b320f32,2a09bf1afefd4d659606f43445741ee3,efd45535a5504d5595fba4d1dbbc489c', '0', '3', '1', '2020-04-23 10:55:30', '2020-04-23 10:55:30');
INSERT INTO `tb_recommend` VALUES ('a9c8cb93240d4f3896e153648a5d67c2', '支持联机对战的五子棋小游戏', '原文链接 [链接] 效果展示 原理简介 每次都写单机游戏自嗨好像没啥意思，这次我们来写个支持联机对战的游戏吧，省的有人在issue里说： 好吧，联机和对手比赛输了总不能怪我了吧 OK，跑题了，这明明是一个学习用的...', '<h2>原文链接</h2> \n<p><a href=\"https://mp.weixin.qq.com/s/79aBuK_EytVAbDp5hY8cHA\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/79...</a></p> \n<h2>效果展示</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbDlWK\" src=\"http://localhost:8060/tup/2020/4/23/5b098ad4912a445583524b4fe39e4727.jpg\" alt=\"1.png\" title=\"1.png\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbDlWL\" src=\"http://localhost:8060/tup/2020/4/23/aa2793793d704c18bd9c261a8e946e38.jpg\" alt=\"2.png\" title=\"2.png\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbDlWN\" src=\"http://localhost:8060/tup/2020/4/23/c71e5bd4785043b0a2d287445519667f.jpg\" alt=\"3.png\" title=\"3.png\"></span></p> \n<h2>原理简介</h2> \n<p>每次都写单机游戏自嗨好像没啥意思，这次我们来写个支持联机对战的游戏吧，省的有人在issue里说：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733166\" src=\"http://localhost:8060/tup/2020/4/23/0448ade48a2142d89b1da45d8f5d8abb.jpg\" alt=\"\" title=\"\"></span></p> \n<p>好吧，联机和对手比赛输了总不能怪我了吧</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733165\" src=\"http://localhost:8060/tup/2020/4/23/44ff25cbd92e40b3b4b3741ce2770f2d.jpg\" alt=\"\" title=\"\"></span></p> \n<p>OK，跑题了，这明明是一个学习用的公众号。因为我之前也没写过可以联机对战的游戏，所以先整个简单的游戏试试吧，支持局域网联机对战的五子棋小游戏。废话不多说，让我们愉快地开始吧~</p> \n<p>这里简单介绍下原理吧，代码主要用PyQt5写的，pygame只用来播放一些音效。首先，设计并实现个游戏主界面：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733164\" src=\"http://localhost:8060/tup/2020/4/23/0117986fb19d4828b602776039cdbca3.jpg\" alt=\"\" title=\"\"></span></p> \n<p>代码实现如下：</p> \n<pre><code class=\"text\">\'\'\'游戏开始界面\'\'\'\nclass gameStartUI(QWidget):\n  def __init__(self, parent=None, **kwargs):\n    super(gameStartUI, self).__init__(parent)\n    self.setFixedSize(760, 650)\n    self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘\')\n    self.setWindowIcon(QIcon(cfg.ICON_FILEPATH))\n    # 背景图片\n    palette = QPalette()\n    palette.setBrush(self.backgroundRole(), QBrush(QPixmap(cfg.BACKGROUND_IMAGEPATHS.get(\'bg_start\'))))\n    self.setPalette(palette)\n    # 按钮\n    # --人机对战\n    self.ai_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'ai\'), self)\n    self.ai_button.move(250, 200)\n    self.ai_button.show()\n    self.ai_button.click_signal.connect(self.playWithAI)\n    # --联机对战\n    self.online_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'online\'), self)\n    self.online_button.move(250, 350)\n    self.online_button.show()\n    self.online_button.click_signal.connect(self.playOnline)\n  \'\'\'人机对战\'\'\'\n  def playWithAI(self):\n    self.close()\n    self.gaming_ui = playWithAIUI(cfg)\n    self.gaming_ui.exit_signal.connect(lambda: sys.exit())\n    self.gaming_ui.back_signal.connect(self.show)\n    self.gaming_ui.show()\n  \'\'\'联机对战\'\'\'\n  def playOnline(self):\n    self.close()\n    self.gaming_ui = playOnlineUI(cfg, self)\n    self.gaming_ui.show()</code></pre> \n<p>会pyqt5的应该都可以写出这样的界面，没啥特别的，记得把人机对战和联机对战两个按钮触发后的信号分别绑定到人机对战和联机对战的函数上就行。</p> \n<p>然后分别来实现人机对战和联机对战就行了。这里人机对战的算法抄的公众号之前发的那篇AI五子棋的文章里用的算法，所以只要花点心思用PyQt5重新写个游戏界面就行了，效果大概是这样的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733168\" src=\"http://localhost:8060/tup/2020/4/23/1af03a5b7e4b44dbadad98cc817616f2.jpg\" alt=\"\" title=\"\"></span></p> \n<p>主要的代码实现如下：</p> \n<pre><code class=\"text\">\'\'\'人机对战\'\'\'\nclass playWithAIUI(QWidget):\n    back_signal = pyqtSignal()\n    exit_signal = pyqtSignal()\n    send_back_signal = False\n    def __init__(self, cfg, parent=None, **kwargs):\n        super(playWithAIUI, self).__init__(parent)\n        self.cfg = cfg\n        self.setFixedSize(760, 650)\n        self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘\')\n        self.setWindowIcon(QIcon(cfg.ICON_FILEPATH))\n        # 背景图片\n        palette = QPalette()\n        palette.setBrush(self.backgroundRole(), QBrush(QPixmap(cfg.BACKGROUND_IMAGEPATHS.get(\'bg_game\'))))\n        self.setPalette(palette)\n        # 按钮\n        self.home_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'home\'), self)\n        self.home_button.click_signal.connect(self.goHome)\n        self.home_button.move(680, 10)\n        self.startgame_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'startgame\'), self)\n        self.startgame_button.click_signal.connect(self.startgame)\n        self.startgame_button.move(640, 240)\n        self.regret_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'regret\'), self)\n        self.regret_button.click_signal.connect(self.regret)\n        self.regret_button.move(640, 310)\n        self.givein_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'givein\'), self)\n        self.givein_button.click_signal.connect(self.givein)\n        self.givein_button.move(640, 380)\n        # 落子标志\n        self.chessman_sign = QLabel(self)\n        sign = QPixmap(cfg.CHESSMAN_IMAGEPATHS.get(\'sign\'))\n        self.chessman_sign.setPixmap(sign)\n        self.chessman_sign.setFixedSize(sign.size())\n        self.chessman_sign.show()\n        self.chessman_sign.hide()\n        # 棋盘(19*19矩阵)\n        self.chessboard = [[None for i in range(19)] for _ in range(19)]\n        # 历史记录(悔棋用)\n        self.history_record = []\n        # 是否在游戏中\n        self.is_gaming = True\n        # 胜利方\n        self.winner = None\n        self.winner_info_label = None\n        # 颜色分配and目前轮到谁落子\n        self.player_color = \'white\'\n        self.ai_color = \'black\'\n        self.whoseround = self.player_color\n        # 实例化ai\n        self.ai_player = aiGobang(self.ai_color, self.player_color)\n        # 落子声音加载\n        pygame.mixer.init()\n        self.drop_sound = pygame.mixer.Sound(cfg.SOUNDS_PATHS.get(\'drop\'))\n    \'\'\'鼠标左键点击事件-玩家回合\'\'\'\n    def mousePressEvent(self, event):\n        if (event.buttons() != QtCore.Qt.LeftButton) or (self.winner is not None) or (self.whoseround != self.player_color) or (not self.is_gaming):\n            return\n        # 保证只在棋盘范围内响应\n        if event.x() &gt;= 50 and event.x() &lt;= 50 + 30 * 18 + 14 and event.y() &gt;= 50 and event.y() &lt;= 50 + 30 * 18 + 14:\n            pos = Pixel2Chesspos(event)\n            # 保证落子的地方本来没有人落子\n            if self.chessboard[pos[0]][pos[1]]:\n                return\n            # 实例化一个棋子并显示\n            c = Chessman(self.cfg.CHESSMAN_IMAGEPATHS.get(self.whoseround), self)\n            c.move(event.pos())\n            c.show()\n            self.chessboard[pos[0]][pos[1]] = c\n            # 落子声音响起\n            self.drop_sound.play()\n            # 最后落子位置标志对落子位置进行跟随\n            self.chessman_sign.show()\n            self.chessman_sign.move(c.pos())\n            self.chessman_sign.raise_()\n            # 记录这次落子\n            self.history_record.append([*pos, self.whoseround])\n            # 是否胜利了\n            self.winner = checkWin(self.chessboard)\n            if self.winner:\n                self.showGameEndInfo()\n                return\n            # 切换回合方(其实就是改颜色)\n            self.nextRound()\n    \'\'\'鼠标左键释放操作-调用电脑回合\'\'\'\n    def mouseReleaseEvent(self, event):\n        if (self.winner is not None) or (self.whoseround != self.ai_color) or (not self.is_gaming):\n            return\n        self.aiAct()\n    \'\'\'电脑自动下-AI回合\'\'\'\n    def aiAct(self):\n        if (self.winner is not None) or (self.whoseround == self.player_color) or (not self.is_gaming):\n            return\n        next_pos = self.ai_player.act(self.history_record)\n        # 实例化一个棋子并显示\n        c = Chessman(self.cfg.CHESSMAN_IMAGEPATHS.get(self.whoseround), self)\n        c.move(QPoint(*Chesspos2Pixel(next_pos)))\n        c.show()\n        self.chessboard[next_pos[0]][next_pos[1]] = c\n        # 落子声音响起\n        self.drop_sound.play()\n        # 最后落子位置标志对落子位置进行跟随\n        self.chessman_sign.show()\n        self.chessman_sign.move(c.pos())\n        self.chessman_sign.raise_()\n        # 记录这次落子\n        self.history_record.append([*next_pos, self.whoseround])\n        # 是否胜利了\n        self.winner = checkWin(self.chessboard)\n        if self.winner:\n            self.showGameEndInfo()\n            return\n        # 切换回合方(其实就是改颜色)\n        self.nextRound()\n    \'\'\'改变落子方\'\'\'\n    def nextRound(self):\n        self.whoseround = self.player_color if self.whoseround == self.ai_color else self.ai_color\n    \'\'\'显示游戏结束结果\'\'\'\n    def showGameEndInfo(self):\n        self.is_gaming = False\n        info_img = QPixmap(self.cfg.WIN_IMAGEPATHS.get(self.winner))\n        self.winner_info_label = QLabel(self)\n        self.winner_info_label.setPixmap(info_img)\n        self.winner_info_label.resize(info_img.size())\n        self.winner_info_label.move(50, 50)\n        self.winner_info_label.show()\n    \'\'\'认输\'\'\'\n    def givein(self):\n        if self.is_gaming and (self.winner is None) and (self.whoseround == self.player_color):\n            self.winner = self.ai_color\n            self.showGameEndInfo()\n    \'\'\'悔棋-只有我方回合的时候可以悔棋\'\'\'\n    def regret(self):\n        if (self.winner is not None) or (len(self.history_record) == 0) or (not self.is_gaming) and (self.whoseround != self.player_color):\n            return\n        for _ in range(2):\n            pre_round = self.history_record.pop(-1)\n            self.chessboard[pre_round[0]][pre_round[1]].close()\n            self.chessboard[pre_round[0]][pre_round[1]] = None\n        self.chessman_sign.hide()\n    \'\'\'开始游戏-之前的对弈必须已经结束才行\'\'\'\n    def startgame(self):\n        if self.is_gaming:\n            return\n        self.is_gaming = True\n        self.whoseround = self.player_color\n        for i, j in product(range(19), range(19)):\n            if self.chessboard[i][j]:\n                self.chessboard[i][j].close()\n                self.chessboard[i][j] = None\n        self.winner = None\n        self.winner_info_label.close()\n        self.winner_info_label = None\n        self.history_record.clear()\n        self.chessman_sign.hide()\n    \'\'\'关闭窗口事件\'\'\'\n    def closeEvent(self, event):\n        if not self.send_back_signal:\n            self.exit_signal.emit()\n    \'\'\'返回游戏主页面\'\'\'\n    def goHome(self):\n        self.send_back_signal = True\n        self.close()\n        self.back_signal.emit()</code></pre> \n<p>整个逻辑是这样的：</p> \n<p>设计并实现游戏的基本界面之后，先默认永远是玩家先手(白子)，电脑后手(黑子)。然后，当监听到玩家鼠标左键点击到棋盘网格所在的范围内的时候，捕获该位置，若该位置之前没有人落子过，则玩家成功落子，否则重新等待玩家鼠标左键点击事件。玩家成功落子后，判断是否因为玩家落子而导致游戏结束(即棋盘上有5颗同色子相连了)，若游戏结束，则显示游戏结束界面，否则轮到AI落子。AI落子和玩家落子的逻辑类似，然后又轮到玩家落子，以此类推。</p> \n<p>需要注意的是：为保证响应的实时性，AI落子算法应当写到鼠标左键点击后释放事件的响应中(感兴趣的小伙伴可以试试写到鼠标点击事件的响应中，这样会导致必须在AI计算结束并落子后，才能显示玩家上一次的落子和AI此次的落子结果)。</p> \n<p>开始按钮就是重置游戏，没啥可说的，这里为了避免有些人喜欢耍赖，我实现的时候代码写的是必须完成当前对弈才能重置游戏(毕竟小伙子小姑娘们要学会有耐心地下完一盘棋呀)。</p> \n<p>因为是和AI下，所以悔棋按钮直接悔两步，从历史记录列表里pop最后两次落子然后从棋盘对应位置取下这两次落子就OK了，并且保证只有我方回合可以悔棋以避免出现意料之外的逻辑出错。</p> \n<p>认输按钮也没啥可说的，就是认输然后提前结束游戏。</p> \n<p>接下来我们来实现一下联机对战，这里我们选择使用TCP/IP协议进行联机通信从而实现联机对战。先启动游戏的一方作为服务器端：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733167\" src=\"http://localhost:8060/tup/2020/4/23/45cf2ba1112845f584a71fedc60b78ba.jpg\" alt=\"\" title=\"\"></span></p> \n<p>通过新开一个线程来实现监听：</p> \n<pre><code class=\"text\">threading.Thread(target=self.startListen).start()\n\'\'\'开始监听客户端的连接\'\'\'\ndef startListen(self):\n    while True:\n       self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘 ——&gt; 服务器端启动成功, 等待客户端连接中\')\n       self.tcp_socket, self.client_ipport = self.tcp_server.accept()\n       self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘 ——&gt; 客户端已连接, 点击开始按钮进行游戏\')</code></pre> \n<p>后启动方作为客户端连接服务器端并发送客户端玩家的基本信息：</p> \n<pre><code class=\"text\">self.tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nself.tcp_socket.connect(self.server_ipport)\ndata = {\'type\': \'nickname\', \'data\': self.nickname}\nself.tcp_socket.sendall(packSocketData(data))\nself.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘 ——&gt; 已经成功连接服务器, 点击开始按钮进行游戏\')</code></pre> \n<p>当客户端连接到服务器端时，服务器端也发送服务器端的玩家基本信息给客户端：</p> \n<pre><code class=\"text\">data = {\'type\': \'nickname\', \'data\': self.nickname}\nself.tcp_socket.sendall(packSocketData(data))</code></pre> \n<p>然后客户端和服务器端都利用新开的线程来实现网络数据监听接收：</p> \n<pre><code class=\"text\">\'\'\'接收客户端数据\'\'\'\ndef receiveClientData(self):\n    while True:\n        data = receiveAndReadSocketData(self.tcp_socket)\n        self.receive_signal.emit(data)\n\'\'\'接收服务器端数据\'\'\'\ndef receiveServerData(self):\n    while True:\n        data = receiveAndReadSocketData(self.tcp_socket)\n        self.receive_signal.emit(data)</code></pre> \n<p>并根据接收到的不同数据在主进程中做成对应的响应：</p> \n<pre><code class=\"text\">\'\'\'响应接收到的数据\'\'\'\ndef responseForReceiveData(self, data):\n    if data[\'type\'] == \'action\' and data[\'detail\'] == \'exit\':\n        QMessageBox.information(self, \'提示\', \'您的对手已退出游戏, 游戏将自动返回主界面\')\n        self.goHome()\n    elif data[\'type\'] == \'action\' and data[\'detail\'] == \'startgame\':\n        self.opponent_player_color, self.player_color = data[\'data\']\n        self.whoseround = \'white\'\n        self.whoseround2nickname_dict = {self.player_color: self.nickname, self.opponent_player_color: self.opponent_nickname}\n        res = QMessageBox.information(self, \'提示\', \'对方请求(重新)开始游戏, 您为%s, 您是否同意?\' % {\'white\': \'白子\', \'black\': \'黑子\'}.get(self.player_color), QMessageBox.Yes | QMessageBox.No)\n        if res == QMessageBox.Yes:\n            data = {\'type\': \'reply\', \'detail\': \'startgame\', \'data\': True}\n            self.tcp_socket.sendall(packSocketData(data))\n            self.is_gaming = True\n            self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘 ——&gt; %s走棋\' % self.whoseround2nickname_dict.get(self.whoseround))\n            for i, j in product(range(19), range(19)):\n                if self.chessboard[i][j]:\n                    self.chessboard[i][j].close()\n                    self.chessboard[i][j] = None\n            self.history_record.clear()\n            self.winner = None\n            if self.winner_info_label:\n                self.winner_info_label.close()\n            self.winner_info_label = None\n            self.chessman_sign.hide()\n        else:\n            data = {\'type\': \'reply\', \'detail\': \'startgame\', \'data\': False}\n            self.tcp_socket.sendall(packSocketData(data))\n    elif data[\'type\'] == \'action\' and data[\'detail\'] == \'drop\':\n        pos = data[\'data\']\n        # 实例化一个棋子并显示\n        c = Chessman(self.cfg.CHESSMAN_IMAGEPATHS.get(self.whoseround), self)\n        c.move(QPoint(*Chesspos2Pixel(pos)))\n        c.show()\n        self.chessboard[pos[0]][pos[1]] = c\n        # 落子声音响起\n        self.drop_sound.play()\n        # 最后落子位置标志对落子位置进行跟随\n        self.chessman_sign.show()\n        self.chessman_sign.move(c.pos())\n        self.chessman_sign.raise_()\n        # 记录这次落子\n        self.history_record.append([*pos, self.whoseround])\n        # 是否胜利了\n        self.winner = checkWin(self.chessboard)\n        if self.winner:\n            self.showGameEndInfo()\n            return\n        # 切换回合方(其实就是改颜色)\n        self.nextRound()\n    elif data[\'type\'] == \'action\' and data[\'detail\'] == \'givein\':\n        self.winner = self.player_color\n        self.showGameEndInfo()\n    elif data[\'type\'] == \'action\' and data[\'detail\'] == \'urge\':\n        self.urge_sound.play()\n    elif data[\'type\'] == \'action\' and data[\'detail\'] == \'regret\':\n        res = QMessageBox.information(self, \'提示\', \'对方请求悔棋, 您是否同意?\', QMessageBox.Yes | QMessageBox.No)\n        if res == QMessageBox.Yes:\n            pre_round = self.history_record.pop(-1)\n            self.chessboard[pre_round[0]][pre_round[1]].close()\n            self.chessboard[pre_round[0]][pre_round[1]] = None\n            self.chessman_sign.hide()\n            self.nextRound()\n            data = {\'type\': \'reply\', \'detail\': \'regret\', \'data\': True}\n            self.tcp_socket.sendall(packSocketData(data))\n        else:\n            data = {\'type\': \'reply\', \'detail\': \'regret\', \'data\': False}\n            self.tcp_socket.sendall(packSocketData(data))\n    elif data[\'type\'] == \'reply\' and data[\'detail\'] == \'startgame\':\n        if data[\'data\']:\n            self.is_gaming = True\n            self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘 ——&gt; %s走棋\' % self.whoseround2nickname_dict.get(self.whoseround))\n            for i, j in product(range(19), range(19)):\n                if self.chessboard[i][j]:\n                    self.chessboard[i][j].close()\n                    self.chessboard[i][j] = None\n            self.history_record.clear()\n            self.winner = None\n            if self.winner_info_label:\n                self.winner_info_label.close()\n            self.winner_info_label = None\n            self.chessman_sign.hide()\n            QMessageBox.information(self, \'提示\', \'对方同意开始游戏请求, 您为%s, 执白者先行.\' % {\'white\': \'白子\', \'black\': \'黑子\'}.get(self.player_color))\n        else:\n            QMessageBox.information(self, \'提示\', \'对方拒绝了您开始游戏的请求.\')\n    elif data[\'type\'] == \'reply\' and data[\'detail\'] == \'regret\':\n        if data[\'data\']:\n            pre_round = self.history_record.pop(-1)\n            self.chessboard[pre_round[0]][pre_round[1]].close()\n            self.chessboard[pre_round[0]][pre_round[1]] = None\n            self.nextRound()\n            QMessageBox.information(self, \'提示\', \'对方同意了您的悔棋请求.\')\n        else:\n            QMessageBox.information(self, \'提示\', \'对方拒绝了您的悔棋请求.\')\n    elif data[\'type\'] == \'nickname\':\n        self.opponent_nickname = data[\'data\']</code></pre> \n<p>对战过程实现的基本逻辑和人机对战是一致的，只不过要考虑数据同步问题，所以看起来代码略多了一些。当然对于联机对战，我也做了一些小修改，比如必须点击开始按钮，并经过对方同意之后，才能正式开始对弈，悔棋按钮只有在对方回合才能按，对方同意悔棋后需要记得把落子方切换回自己。然后加了一个催促按钮，同样必须在对方回合才能按。其他好像也没什么特别的改动了。</p> \n<p>All done~完整源代码详见相关文件~</p> \n<h2>相关文件</h2> \n<p><a href=\"https://github.com/CharlesPikachu/Games/tree/master/Game22\" rel=\"nofollow noreferrer\">https://github.com/CharlesPik...</a></p>', null, 'http://localhost:8060/tup/2020/4/23/0547f08f681e4efb937b26b513a53afe.jpg', '5ca4567d892841b087fac5246effac40', '1a7cc9fbc4654cb0afec84e080816ef1', 'faf36da502544b51be926ab85450c40d,43145b2d806a4c3e8bb30d20ef04d61b,a4f4fd7a73b84a7298db0174165eeaac,9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-23 10:57:14', '2020-04-23 10:57:14');
INSERT INTO `tb_recommend` VALUES ('ab6f2a9f6274486fb889e8791b5cb5e3', '[宝宝也能看懂的活动篇][30-Day LeetCoding Challenge] 第十一天', '二叉树的直径 Hi 大家好，我是张小猪。欢迎来到『宝宝也能看懂』系列特别篇 - 官方小活动 『30-Day LeetCoding Challenge』。 这里是 4 月 11 号的题，也是题目列表中的第 543 题 -- 『二叉树的直径』 题目描述 ...', '<h1>二叉树的直径</h1> \n<p>Hi 大家好，我是张小猪。欢迎来到『宝宝也能看懂』系列特别篇 - 官方小活动 『30-Day LeetCoding Challenge』。</p> \n<p>这里是 4 月 11 号的题，也是题目列表中的第 543 题 -- 『二叉树的直径』</p> \n<h2>题目描述</h2> \n<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p> \n<p>示例 :</p> \n<pre><code class=\"shell\">给定二叉树\n\n          1\n         / \\\n        2   3\n       / \\\n      4   5</code></pre> \n<p>返回&nbsp;__3__, 它的长度是路径 [4,2,1,3] 或者&nbsp;[5,2,1,3]。</p> \n<p><strong>注意：</strong> 两结点之间的路径长度是以它们之间边的数目表示。</p> \n<h2>官方难度</h2> \n<p>EASY</p> \n<h2>解决思路</h2> \n<p>题目的需求是求一颗二叉树的直径。第一眼看起来似乎有些不知道如何下手，不过我们尝试把这个问题拆解开来。站在一个节点的视角上看来这个目标，那其实只有两种情况：</p> \n<ul> \n <li>这个最长路径以\"我\"为转折点：那么这个最长路径必然就是以\"我\"为根节点的子树左侧的高度 + 右侧的高度 + 1。</li> \n <li>这个最长路径不以\"我\"为转折点：那么它一定以其他某个节点为转折点，对于\"我\"无需进行后续计算。</li> \n</ul> \n<p>通过这种方式，我们成功的把目标拆解为了比较简单的小目标。然后我们只需要找到方法求出子树的高度即可。</p> \n<h3>直接方案</h3> \n<p>通过深度优先遍历，我们可以轻松的求得某个子树的高度。为了避免大量的重复计算，我们可以用一个 map 把运算的结果进行暂存。最后再结合上面的思路，我们可以得到类似下面的代码：</p> \n<pre><code class=\"js\">const diameterOfBinaryTree = root =&gt; {\n  const cache = new Map();\n  let max = 0;\n  dfs(root);\n  return max;\n\n  function dfs(node) {\n    if (!node) return 0;\n    if (cache.has(node)) return cache.get(node);\n    const r = dfs(node.right);\n    const l = dfs(node.left);\n    if (max &lt; r + l) max = r + l;\n    cache.set(node, Math.max(r, l) + 1);\n    return Math.max(r, l) + 1;\n  }\n};</code></pre> \n<h2>总结</h2> \n<p>分析的过程其实就是尝试把一个大目标拆分成很多的小目标来处理。而对于二叉树，我们常用的经典的遍历方式例如深度优先遍历，再结合 memo 来做一点优化。希望能帮助到有需要的小伙伴。</p> \n<p>如果觉得不错的话，记得『三连』哦。小猪爱你们哟~</p> \n<h2>相关链接</h2> \n<ul> \n <li><a href=\"https://github.com/poppinlp/leetcode#30-day-leetcoding-challenge\" rel=\"nofollow noreferrer\">活动题目列表</a></li> \n <li><a href=\"https://github.com/poppinlp/leetcode\" rel=\"nofollow noreferrer\">leetcode 题解 repo</a></li> \n <li><a href=\"https://segmentfault.com/blog/zxzfbz\">我的 segmentfault 专栏</a></li> \n <li><a href=\"https://zhuanlan.zhihu.com/zxzfbz\" rel=\"nofollow noreferrer\">我的知乎专栏</a></li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCAAa\" src=\"http://localhost:8060/tup/2020/4/23/ae46902b5615467392c610088a5f3e53.jpg\" alt=\"qrcode_green.jpeg\" title=\"qrcode_green.jpeg\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/d71874a5cb4c4306baf8a33471479ef1.jpg', '1c5851dc916d4e70a60f0c957f548876', 'cbad2058b4014634aec6515f4adbef0d', '3921afbb134d45f6aa368b52d2670e7b,faf36da502544b51be926ab85450c40d,789898341cc64d45a1f44e26daab183f,63c4e1e7ec204b43a62065a3ced4c2ce,55723db96b9f4593bae02bc1e49f1e87', '0', '3', '1', '2020-04-23 10:55:35', '2020-04-23 10:55:35');
INSERT INTO `tb_recommend` VALUES ('ab9c6f8213404c2cbdea81a86d3ec9d3', 'OUT 啦！你的 App 还不支持一键登录吗？', '在用户使用 App、网站、产品客户端时，是否对于登陆信息的反复输入感到厌烦？在用户查看信息、打开问卷、收取资源时，是否因为条条框框输入注册信息而放弃使用？在企业上新产品，宣传推广，迎接新用户时，是否面...', '<p>在用户使用 App、网站、产品客户端时，是否对于登陆信息的反复输入感到厌烦？<br>在用户查看信息、打开问卷、收取资源时，是否因为条条框框输入注册信息而放弃使用？<br>在企业上新产品，宣传推广，迎接新用户时，是否面临过因用户烦于注册而流失的情况？<br>个人账号的逐渐增多，实名认证的加强推广让登陆界面频频出现在大家生活中，而操作登陆和注册也成为了使用互联网的一环。</p> \n<h2>常见的登陆/注册方式</h2> \n<p><strong>账号密码模式</strong></p> \n<p>论起最基础也是最常见的登陆注册方式，毫无疑问是账号密码模式了。<br>作为最传统且一直到今天仍在广泛使用的方法，它毫无疑问是简单粗暴且有效的。虽然它也是导致重复输入引起烦躁，从而放弃使用的本源。<br>这个模式的必要点就是账号和密码的记忆，一旦忘记就会导致无法登陆。而且从安全角度看可能会出现为了便于记忆在多个平台使用同一套账号密码，从而降低了安全性。如果有一个平台出现信息泄露，将会威胁到其他平台的内容安全。</p> \n<p><strong>短信验证模式</strong></p> \n<p>在手机实名制后，因为一人一号的基础，衍生出了手机、验证码动态登陆注册模式。相比账号密码模式，它可以有效的避免重复注册，且不再需要记忆账号密码。<br>该模式是在你登陆注册时，输入手机号，然后获取验证码，等待收取验证码后再进行验证码填写。在这个过程中使用者收取验证短信会受到运营商网络的影响，而且验证短信也会面临是否屏蔽等无法接受的情况。更甚至因为丢失手机号，或者更换手机号后会无法登陆。</p> \n<p><strong>一键登录模式</strong></p> \n<p>虽然短信验证模式依然有部分缺陷，但是我们也可以看到这些缺点主要集中在短信验证码的收发上。相比需要记忆账号密码的模式已经无疑有了很大进步。<br>那么有没有一种方法可以去掉或者减少因为运营商网络所导致的收发短信问题，从而使登陆注册更加方便呢？<br>一键登录完全符合了这个需求。</p> \n<h2>一键登录就是这么优秀</h2> \n<p>所谓一键登录，是指在登陆注册时依托运营商的移动数据网络，采用“通信网关取号”及 SIM 卡识别等技术，不需要通过收发验证码，而是App自动获取当前手机的手机号，然后直接使用该号码进行登陆。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022328439\" src=\"http://localhost:8060/tup/2020/4/23/d724b9655d534645bbeda5eba6daef76.jpg\" alt=\"\" title=\"\"></span></p> \n<p>相比传统登陆方式，一键登录有以下 4 个优点：</p> \n<ul> \n <li>帮助用户节省手动输入账号和密码的时间，减少用户操作步骤，提升用户体验；</li> \n <li>取消账号密码，无需记忆，也不用担心密码泄露导致的安全问题</li> \n <li>取消收发及输入验证码过程，节省短信费用，也减少了等待验证码的时间</li> \n <li>3 秒内完成登陆注册流程，有效避免因注册/登陆的繁琐流程而使用户流失</li> \n</ul> \n<h2>快速接入一键登录</h2> \n<p>既然是这么方便的功能，那为什么现在还没有完全推广开来呢？<br>因为使用一键登录需要接入三大运营商，而运营商是否开放相关服务则成了关键。<br>那么现在就有了一个好消息，最近三大运营商有了自己的开放平台，而且还使用了同一套授权程序，只需要接入接口就可以使用了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022328438\" src=\"http://localhost:8060/tup/2020/4/23/c31cfda0353f495dac6aaa86a16f9070.jpg\" alt=\"\" title=\"\"></span></p> \n<p>现在又拍云刚好可以为大家提供一键登录接入功能，依托于又拍云的亿级推送业务技术构架，可以轻松应对高并发。并且封装了完善的SDK，直接调用就可以接入，开启一键登录功能。同时又拍云还贴心地提供了授权界面自定义功能，企业可自定义配置授权页面，保证产品界面的美观统一。<br>一键登录作为一种能够明显减少身份校验带来的麻烦，提升账户安全性，而且更为便捷的登陆注册模式，在今后互联网用户身份认证里肯定能够占据重要地位，值得开发者们在选择身份认证上的考虑！</p> \n<h6>推荐阅读</h6> \n<p><a href=\"https://www.upyun.com/tech/article/536/%E6%97%A0%E9%9C%80%E9%A2%9D%E5%A4%96%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%8F%88%E5%B0%8F%E6%8B%8D%E7%9A%84%E7%AE%80%E5%8D%95%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B.html\" rel=\"nofollow noreferrer\">无需额外工具，又小拍的简单抓包教程</a></p> \n<p><a href=\"https://www.upyun.com/tech/article/526/%E5%A4%A7%E5%AE%B6%E9%83%BD%E5%9C%A8%E8%AF%B4%E7%9A%84%E4%BA%91%E5%AE%89%E5%85%A8%EF%BC%8C%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F.html\" rel=\"nofollow noreferrer\">大家都在说的云安全，到底是怎么回事？</a></p>', null, 'http://localhost:8060/tup/2020/4/23/ab825379b17647caa9eb868e4ae77803.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', 'b299a2a48cd64e77a3431ce958b42055', 'cc944f24ed5e4383a975481674f255e0,60e459d5028e400894856f94e826804c,63c4e1e7ec204b43a62065a3ced4c2ce,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-23 10:55:56', '2020-04-23 10:55:56');
INSERT INTO `tb_recommend` VALUES ('afad8c82e61645b0ab469953aaa1ed44', '华为云回应：目前华为云故障基本修复，部分客户的业务正在配合恢复中', '技术编辑：鸣飞 发自北京 SegmentFault 思否报道 | 公众号：SegmentFault SegmentFault 思否消息：4月10日早，据多位开发者反映，华为云登录、管理后台无法访问，ssh 连接不上。 目前华为云官方在微博上回应：4月...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<hr> \n<p>SegmentFault 思否消息：4月10日早，据多位开发者反映，华为云登录、管理后台无法访问，ssh 连接不上。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQjv\" src=\"http://localhost:8060/tup/2020/4/23/3afd999415564cbd922c329174f9f9c9.jpg\" alt=\"据多位开发者在微博上反映，华为云登录、管理后台无法访问。\" title=\"据多位开发者在微博上反映，华为云登录、管理后台无法访问。\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQjB\" src=\"http://localhost:8060/tup/2020/4/23/d9e87ee967844566916a3e0952e2b863.jpg\" alt=\"华为云.png\" title=\"华为云.png\"></span></p> \n<p><strong>目前华为云官方在微博上回应：</strong>4月10日上午检测到部分主机异常，目前故障基本修复，部分客户的业务正在配合恢复中。感谢您对华为云的支持！ ​​​​</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQjJ\" src=\"http://localhost:8060/tup/2020/4/23/9bfe7e2f377e4367a00a04e72dee4ea5.jpg\" alt=\"华为云在微博上的回应：目前华为云故障基本修复，部分客户的业务正在配合恢复中。\" title=\"华为云在微博上的回应：目前华为云故障基本修复，部分客户的业务正在配合恢复中。\"></span></p> \n<p>至于是什么原因导致此次故障还不清楚，我们也正在与华为云官方沟通，我们会持续跟进最新消息。</p> \n<p>相信华为云团队能解决好这次技术故障问题。</p> \n<hr> \n<p><strong>近年来，云计算的落地一直在推进中，政策红利也不断释放。</strong></p> \n<p>例如，工信部就先后印发了《云计算发展三年行动计划(2017-2019 年)》和《推动企业上云实施指南(2018-2020 年)》(以下简称《实施指南》)，并提出了到 2020 年，全国新增上云企业 100 万家的目标。</p> \n<p>国内云计算市场的整体加速爆发。同时，随着数据电子化的实现、对安全性要求的提高，云计算国产化也是历史的选择，华为云、阿里云、腾讯云等国内企业占据了中国大部分市场。</p> \n<p>根据IDC报告，2019年上半年，从IaaS市场来看，阿里、腾讯、中国电信、AWS、华为位居前五，占据总体75.3%的市场份额；从IaaS+PaaS市场来看，阿里、腾讯、AWS、中国电信、华为共同占据74%的市场份额。</p> \n<p>2019年上半年，华为云在中国公有云IaaS+PaaS市场增速超过350%，在TOP厂商中位列第一；IaaS市场营收增长高达368%，排名跃升至第四。2019年，华为云驶入发展快车道，上半年业务收入同比增长500%，客户数规模同比增长达33倍。</p> \n<p><strong>接下来，巨头间的硬核投资和技术竞争还将持续。</strong></p> \n<p>其次，在历经十多年的发展后，云计算已经下沉到各个行业应用，从互联网领域拓展到政企等非互联网领域，进入第二产业、第三产业当中。这也开启了云计算市场的新角逐，在技术和基础设施外，云服务厂商们开始构筑自家生态体系。从芯片、数据中心，到平台、上层应用，再到市场渠道等等，都在考验厂商的综合能力。</p> \n<p>Gartner的数据显示，目前估值超过10亿美元的云计算公司已近百家，2019年全球公有云服务市场预计增长至2143亿美元，同比2018年增长17.5%。预测到2022年，云服务行业的增长速度将是整个IT行业增长速度的三倍。</p> \n<p>目前来看，每一家云服务商也各有特色，都通过差异化来争夺细分市场。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFmMq\" src=\"http://localhost:8060/tup/2020/4/23/89f8d459a61d4e8bbc1b07d7f3cf90dc.jpg\" alt=\"思否公众号\" title=\"思否公众号\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/5b62a3d6c2eb42269eabd40351c908ab.jpg', '3f69fcc9b13843d1910b3dac597f5215', 'b299a2a48cd64e77a3431ce958b42055', '581c0fef5c3347b8bedbf8c2421d911b,e80d97c3472e428dabdaf417adac7a3c,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-23 10:55:59', '2020-04-23 10:55:59');
INSERT INTO `tb_recommend` VALUES ('b23be6aa8c7b4c9c85d760ec89229f64', '程序员面试指北：面试官视角', '所谓结构化，指的是将各种知识技能做好划分，例如编程语言，操作系统，数据库，网络，算法，工程/架构设计，并通过几个面试官之间的多轮交叉面试来考查掌握程度。', '<h1>结构化面试</h1> \n<p>在字节跳动，我们用结构化面试法来考查应聘者的技能。</p> \n<p>所谓结构化，指的是将各种知识技能做好划分，例如编程语言，操作系统，数据库，网络，算法，工程/架构设计，并通过几个面试官之间的多轮交叉面试来考查掌握程度。</p> \n<p>这样的面试方法，可以避免某个面试官考察太偏，并充分挖掘候选人的亮点。</p> \n<h1>技能</h1> \n<p>在具体的面试中，每一个方向都会由浅入深去考查。</p> \n<p>以编程语言为例，比如某个应聘者常用语言是Python，我会先考查一些语言的基础特性，例如什么是 magic function，<code>__repr__</code> 和 <code>__str__</code> 的区别等。</p> \n<p>确认候选人对语言的使用掌握符合预期后，再考查候选人对python底层实现的理解，例如展开聊聊python的gc相关知识。 </p> \n<p>更进一步，可以结合一些具体的应用场景来考查候选人对语言的综合应用能力，例如使用Python的多线程，需要考虑什么，如何提高某些任务中的效率等。</p> \n<p>通过这样的综合考察，我们成功地避开了所有学过下面这本书的程序员。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGixz\" src=\"http://localhost:8060/tup/2020/4/23/9ebc843890324999a0a246acad0338f7.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<h1>算法</h1> \n<p>值得一提的是算法/数据结构，这是字节跳动面试的一大特点，也是网上各面经都会提(tu)到(cao)的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGixA\" src=\"http://localhost:8060/tup/2020/4/23/1a71f5d64f0f4910bc7b747be4d51e27.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>通常来说每一轮面试都会要求候选人完成一道算法题，现场面试就直接在纸上写，远程面试则是在在线共享编辑的IDE环境里完成。</p> \n<p>可能早期常有面试官让候选人手写红黑树，以至于\"手写红黑树\"已经成为一个内部梗。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGixC\" src=\"http://localhost:8060/tup/2020/4/23/022eab8bb0314c489a59526ce14c3041.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>实际上难度没有太夸张，通常来说15分钟内完成 Leetcode Medium 级别的题目，就能满足面试要求了（划重点）。</p> \n<p>我更倾向于考查操作基础数据结构的题目，关注点放在对代码的掌控力，而不是某个具体的算法。</p> \n<p>不过，对于有ACM经历的同学，面试官可能会尝试用 Hard 级别题目来challenge。比如我内推的某同学被问了manacher\'salgorithm，可能是和面试官八字不合。</p> \n<p>但也不用太担心，毕竟不是谁都像他一样拿了ACM金牌。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGiw4\" src=\"http://localhost:8060/tup/2020/4/23/c46af6a7232944b19738e03685e49900.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<h1>沟通</h1> \n<p>候选人的沟通能力也是考查的重点。</p> \n<p>例如，在面试中的工程设计题通常是开放式问题，题面往往不是精确的，问题的规模，可能存在的问题，或者可以忽略的一些细节，都可以在前期的沟通中确认，然后再开始设计。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGiw5\" src=\"http://localhost:8060/tup/2020/4/23/c4b0ba5fb3974c2193466bea279d29df.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>还有，在面试过程中的知识盲点，要注意避免不懂装懂的强行作答，但利用已有知识做出的合理推测则是加分项。两种行为的边界可能有点模糊，这就考验候选人的沟通技巧了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGiw6\" src=\"http://localhost:8060/tup/2020/4/23/a39481029a3d43e7ae501ef012500143.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<h1>总结</h1> \n<p>我想要招什么样的候选人？概括而言就是：聪明，勤奋，有潜力。</p> \n<p>更具体的，大佬早就讲过了，推荐阅读字节跳动创始人张一鸣的演讲<a href=\"https://www.toutiao.com/i6681549238490366472\" rel=\"nofollow noreferrer\">《我面了两千个年轻人，发现混得好的都有这5种特质》</a>，推荐拜读。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGixb\" src=\"http://localhost:8060/tup/2020/4/23/32e512aaccdc4f7f9fa5584e34309743.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<h1>硬广</h1> \n<p>最后，我目前在字节跳动的网盟广告业务线（穿山甲），由于业务持续高速发展，<strong>长期缺人</strong>，欢迎踊跃投递：</p> \n<p><strong>后端开发(上海)</strong><br><a href=\"https://job.toutiao.com/s/sBAvKe\" rel=\"nofollow noreferrer\">https://job.toutiao.com/s/sBAvKe</a></p> \n<p><strong>后端开发(北京)</strong><br><a href=\"https://job.toutiao.com/s/sBMyxk\" rel=\"nofollow noreferrer\">https://job.toutiao.com/s/sBMyxk</a></p> \n<p><strong>广告策略研发(上海)</strong><br><a href=\"https://job.toutiao.com/s/sBDMAK\" rel=\"nofollow noreferrer\">https://job.toutiao.com/s/sBDMAK</a></p> \n<p><strong>测试开发(上海)</strong><br><a href=\"https://job.toutiao.com/s/sBUKuh\" rel=\"nofollow noreferrer\">https://job.toutiao.com/s/sBUKuh</a></p> \n<p><strong>其他地区、职能线</strong><br><a href=\"https://job.toutiao.com/s/sB9Jqk\" rel=\"nofollow noreferrer\">https://job.toutiao.com/s/sB9Jqk</a></p> \n<h1>欢迎关注</h1> \n<p>微信扫码 <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbGive\" src=\"http://localhost:8060/tup/2020/4/23/9c87f14a50a24f4cb85bc5a77736c5c3.jpg\" alt=\"image.png\" title=\"image.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/0563f93606b04dfeabe0a6eb8adee281.jpg', 'c56940aa8b004dab84568e86900b2ee6', '91832bd0c3a244fb88c0bca74c0d404d', '4ad5ca7a9f33456bbe10fa16bd9e5909,81a4561c1c294e0cae32c9fe6b5dc397,7a403ab9ce724c2b93506c5fde3efb04', '0', '3', '1', '2020-04-23 11:01:00', '2020-04-23 11:01:00');
INSERT INTO `tb_recommend` VALUES ('b2d3ea3221c04fc1bee992de97514ac7', 'Python制作的一些小游戏', 'python制作的一些小游戏，供新手练习使用，源代码都在这(欢迎随手给个stars)：[链接]包括： 坦克大战 塔防游戏 推箱子 滑雪游戏 俄罗斯方块 拼图游戏 乒乓球小游戏 24点 打砖块 Pacman 飞机大战 等等。', '<p>python制作的一些小游戏，供新手练习使用，源代码都在这(欢迎随手给个stars)：<br><a href=\"https://github.com/CharlesPikachu/Games\" rel=\"nofollow noreferrer\">https://github.com/CharlesPikachu/Games</a><br>包括：</p> \n<ul>\n <li>坦克大战</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbBtlI\" src=\"http://localhost:8060/tup/2020/4/23/77dc1c9eef0c4eb89f2d410046694b9e.jpg\" alt=\"1576255389.jpg\" title=\"1576255389.jpg\"></span></p> \n<ul>\n <li>塔防游戏</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzUOE\" src=\"http://localhost:8060/tup/2020/4/23/5df16e3ce24149dd9e3be4cd1a5276e9.jpg\" alt=\"1572940685(1).jpg\" title=\"1572940685(1).jpg\"></span></p> \n<ul>\n <li>推箱子</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzUPN\" src=\"http://localhost:8060/tup/2020/4/23/e65e51be537d4bf4b98c9cb43841d8af.jpg\" alt=\"1572940847.jpg\" title=\"1572940847.jpg\"></span></p> \n<ul> \n <li>滑雪游戏</li> \n <li>俄罗斯方块</li> \n <li>拼图游戏</li> \n <li>乒乓球小游戏</li> \n <li>24点</li> \n <li>打砖块</li> \n <li>Pacman</li> \n <li>飞机大战</li> \n</ul> \n<p>等等。</p>', null, 'http://localhost:8060/tup/2020/4/23/8f7f1d567973472b835a07a48bc20455.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', '1a7cc9fbc4654cb0afec84e080816ef1', '43145b2d806a4c3e8bb30d20ef04d61b,a4f4fd7a73b84a7298db0174165eeaac,9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-23 10:57:29', '2020-04-23 10:57:29');
INSERT INTO `tb_recommend` VALUES ('b6762e48a55b4223bebc85abece2a078', '生鲜 B2B 技术平台的前端团队该如何搭建', '线下越重，线上需要越轻，这个轻指的是轻便轻巧和简洁易用，通过前面几章小菜技术与产品历史介绍，我们了解到 B2B 生鲜领域在线下是如此之重，那么在交易场景线上化的过程中，端的移动化就势在必行，试想一下，让...', '<blockquote>\n 著作权归作者所有。商业转载请联系 Scott 获得授权，非商业转载请注明出处[务必保留全文，勿做删减]。\n</blockquote> \n<p>线下越重，线上需要越轻，这个轻指的是轻便轻巧和简洁易用，通过前面几章小菜技术与产品历史介绍，我们了解到 B2B 生鲜领域在线下是如此之重，那么在交易场景线上化的过程中，端的移动化就势在必行，试想一下，让菜市场摊位老板人手一台笔记本点开网页选购支付，让采购销售抱着电脑去拜访客户，一边聊蔬菜行情，一边打开笔记本进行记录，有没有一种回到世纪初的感觉。</p> \n<p>产品的移动化，这将是我们展开这篇文章的背景，我们会先了解小菜的产品托管在哪些端上，然后感受这些端带来的挑战，最后是我们面对这些挑战所采取的策略，以及整个小菜前端团队历练后的技术成长和沉淀，和我们对于自己的一个评估和对未来的展望，本文将采用最通俗易懂的方式陈述，会略有繁琐，但力求对技术新人也足够友好。</p> \n<p><a></a></p> \n<h3>一、小菜大前端的端有哪些</h3> \n<p>小菜早期围绕着蔬菜销地以客户集单批发的模式摸爬滚打几年，从上游的蔬菜供应商到下游批发市场的摊位老板，在这个长长的链路中，我们诞生了这样几款线上产品来服务于不同的人群和场景，之前文章中也有介绍，这里再汇总一下，共 7 款 App：</p> \n<ul> \n <li>宋小菜 服务于销地批发老板的下单工具</li> \n <li>宋小福 服务于小菜内部销售团队的 CRM 销售管理与客户管理工具</li> \n <li>宋小仓 连接司机-物流-采购-销售的蔬菜在途位置监控工具</li> \n <li>采秘 &nbsp; &nbsp;服务于小菜内部采购团队的蔬菜品类采购工具</li> \n <li>麦大蔬 服务于上游蔬菜供应商的大宗农产品交易平台</li> \n <li>宋大仓 服务于上游囤货配资的进出库管理平台</li> \n <li>行情宝 服务于产销两地的行情采集和预测工具</li> \n</ul> \n<p>前 6 款 App 都是基于 ReactNative 开发的 iOS/Android App，最后一个是微信小程序，它们涵盖了公司几乎所有的协同场景和工作流，其他涉及审核、数据观测和过程管理的部分，则会进入到我们 PC 端产品中，也就是：</p> \n<ul>\n <li>ERP 后台管理系统</li>\n</ul> \n<p>生鲜的 toB 场景，角色众多，链路冗长，这种延伸到产地农民，延伸到小 B 交易的管理系统一定会角色杂，权限多，操作重，业务复杂度所带来的页面复杂度不是一般的小系统可比拟。</p> \n<p>到目前为止，我们已经看到小菜的 7 个移动端 App，以及一个复杂的后台管理系统，这些都跟前端工程师息息相关，除了这些，还有 2 个重要的内部产品，就是：</p> \n<ul> \n <li>大表哥 数据报表系统</li> \n <li>大瓜子 市调模板配置系统</li> \n</ul> \n<p>其中大表哥（谐音：搭 Excel 表格）由前端工程师独立研发和维护的数据报表系统，单拎出来这个系统，是因为在 B2B 公司，尤其涉及到供应链的长链路场景中，真实业务数据的及时反馈对于每一个执行团队都至关重要，没有这些数据抓手，就失去了多维度数据观测，都很难快速的做出正确的运营决策和业务调整，甚至很难发现业务中出现的漏洞和问题，比如不正常的非自助下单（也就是销售帮忙下单）的比例。</p> \n<p>关于报表系统后文还有介绍，我们再为前端增加一个服务的产品场景，就是微信生态内产品，比如公众号或者小程序，它的技术栈和运行环境跟原生 App 和 PC 都不同，虽然小程序可以带来更多的业务可能性，也会对前端带来更大的挑战。</p> \n<p>我们把这些端合并一下，小菜前端要服务的端或场景：</p> \n<ul> \n <li>移动端（iOS/Android App/小程序）</li> \n <li>PC 端（ERP）</li> \n <li>工具端（大表哥数据报表）</li> \n</ul> \n<p>端上全部开花，这也应了我之前在掘金 JTalk 上小菜对于长链路流通交易分享的一个观点：<a href=\"http://www.itdks.com/eventlist/detail/2174\" rel=\"nofollow noreferrer\">链路足够长，每个节点上都可以长出产品</a>。那这些端产品都是与业务有强关联的，还有更多技术基建的和服务于团队内的产品，比如：</p> \n<ul> \n <li>大伯伯（谐音打包包） 实现 App 选仓库选分支选环境配置的自主打包与推包系统</li> \n <li>大表姐（来自饥饿游戏，寓意开工没有回头箭） 实现 6 款 App 解包差分后下发热更新包的发布系统</li> \n <li>姑奶奶 &nbsp;线上异常汇集分析与与 Bug 定级指派系统</li> \n <li>大舅子 向下调用微服务接口向上提供 GraphQL 查询能力的数据聚合服务</li> \n <li>RGB &nbsp; &nbsp;用户使用 App 的 PV/UV，以及业务数据监控相关的可视化平台</li> \n <li>110 &nbsp; &nbsp; 解决端异常收集与报警需求</li> \n <li>堂哥工作台 团队记录资源分配与 redmine 同步的自动化周报系统</li> \n <li>ITms 解决内部 App 安装测试的配置生成和预装服务</li> \n <li>...</li> \n</ul> \n<p>这些是服务于团队内部的工具链，全部由小菜前端自行维护。到这里我们发现，在小菜这样一家创业公司内，前端要服务的端和场景的确较多，但这些产品和工具的背后，整个前端组也就 10 个人而已（我们当然也求才若渴），但是人虽少，效率不能自我妥协，所以我们能服务到这些端，也正是基于端的多样性和数量，我们称自己：宋小菜大前端。</p> \n<p>先上小菜端上若干产品和工具的技术栈图，帮助大家理解我们的技术理念：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1525686896336-0af87fa7-b4e7-4c43-ae22-80a5a86c7746.png#align=left&amp;display=inline&amp;height=545&amp;originHeight=990&amp;originWidth=1358&amp;status=done&amp;style=none&amp;width=747\" src=\"http://localhost:8060/tup/2020/4/23/4f45711e341e439b9d212020fcfb1906.jpg\" alt=\"\" title=\"\"></span></p> \n<p><a></a></p> \n<h3>二、多端带来的挑战</h3> \n<p><a></a></p> \n<h5>1. 【物理现状】移动端的碎片化</h5> \n<p>古典互联网时代，因为要兼容 IE678 而痛苦不堪，Hack 黑魔法经验基本代表前端水平，如今互联网早已移动化，我们理想中的移动端开发，看上去是可以大胆使用新语法特性，只需要做好尺寸兼容就好了，但事实并非如此，不仅在移动端的浏览器不是如此，在移动端开发 RN App 也是如此，这是我们某一款 App 一段时间内，所收集上来的手机厂商分布：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1525342888541-27451bb8-8278-4ba1-9554-f36b79da48f0.png#align=left&amp;display=inline&amp;height=493&amp;originHeight=996&amp;originWidth=1508&amp;status=done&amp;style=none&amp;width=747\" src=\"http://localhost:8060/tup/2020/4/23/5bafd42baf44484d8e8c244f36fb6fc0.jpg\" alt=\"\" title=\"\"></span></p> \n<p>可以发现 Android 的碎片化非常严重，每一个厂商下面有不同时期推出的不同型号的手机，这些手机有着不同版本的操作系统，不同的分辨率和用电策略，不同的后台进程管理方式和用户权限，要让一款 App 在哪怕头部 40% 的手机上兼容，都是一件艰难的事情，这个客观物理现状叠加下面的社区现状，App 质量保证这件事情会变得雪上加霜。</p> \n<p><a></a></p> \n<h5>2. 【社区现状】技术框架的不稳定性</h5> \n<p>回到本文的开头，我们在长链路的 B2B 生鲜场景中，为了更快更轻，开发出 7 款 App，而且将来随着业务场景的拓展会诞生更多独立 App 甚至是集大成的 App，所以技术选型不太可能选择原生的 Java/Object-C 开发，尤其对于创业公司，6 款 App 得需要多少名原生开发工程师才能搞定，高频繁重的业务变化又怎样靠堆人来保证？</p> \n<p>想清楚这些，一开始我们就调研 ReactNative，并最终全部从原生切换到了 RN，通过跑过来的这 3 年来看，使用 RN 为公司节约了大量的人力成本同时，也尽可能的满足到几乎所有的需要快速迭代的业务场景，又快又轻，成为宋小菜大前端团队做事的一个典型特征。</p> \n<p>但换一个角度看，就是带来的问题，又快又轻的背后是 RN 版本的飞速迭代，截止到目前，也就是 2018 年 6 月份，RN 还没有推出一个官方的正式的长期维护的稳定版本，什么意思？就是 RN 目前依然处在不稳定的研发周期内，我们依然站在刀尖起舞，用不稳定的 RN 版本试图开发稳定的应用，三年走过来，我们在 RN 的框架里，多少次面对旧版本局限性和新版本不稳定性都进退不得，旧版本的 Bug 可能会在新版本中修复，新版本引进则会来新版本自己的问题。</p> \n<p>除了 RN 自身版本，还有第二个问题，围绕着 RN 有很多业界优秀的组件，但这些社区组件甚至官方组件，都不一定能及时跟进最新的 RN 版本，同时还能兼容到较老的 RN 版本，所以 RN 升级导致的组件不兼容性，会引发你 Fork 修改组件的冲动，但这样会带来额外的开发成本和版本维护成本，取舍会成为版本升降的终极问题。</p> \n<p>在国内开发，还有第三个问题，就是中文文档缺乏，社区资源匮乏，参考文献陈旧，可拿来主义的开源工程方案甚至社区线上线下会议分享都很缺乏，一个不小心就会踩坑，这就是 RN 社区的现状，我们在刀尖浪花上独步，App 选型背后的技术栈稳定性则成为悬在头上的一把铡刀，你不知道什么时候会咔嚓一声。</p> \n<p><a></a></p> \n<h5>3. 【人才现状】人员能力的长短不齐</h5> \n<p>我们知道有一个词叫做主观能动性，表示没有条件创造条件也可以上，这个词的主体就是人，聊完移动端设备现状和社区现状后，我们来聊聊人的问题。RN 在国内真正开始普及使用，是从 2015 年开始，也就意味着，到 2018 年，一个 RN 工程师也就只有 3 年的工作经验，而 RN 的 “Learn once, write anywhere” 也刺激着一切 Care 人员开支， Care 产品研发投入性价比的公司纷纷跳水研究 RN，争抢 RN 人才，RN 是前端中的移动前端，前端有多抢手，那么 RN 工程师就比它还要抢手。</p> \n<p>这导致基本上 RN 工程师，很难靠外部招聘，只能靠内部培养，这也是小菜前端的成长历程，我们有 &nbsp;2 名资深 RN 工程师，一个是从服务端 Java，一个是从原生 Android 开发转过来的。如果 RN 人手不足，产品支持的力度和速度就一定会遇到瓶颈，这就是我们曾经面临的问题，就是人才现状，外招数量不足，内培速度有限，RN 工程师的数量和能力就时不时成为公司业务扩张的瓶颈。</p> \n<p><a></a></p> \n<h5>4. 【公司现状】高密集业务的交付质量</h5> \n<p>作为工程师，我们有很强的自尊心和不容挑战的代码洁癖，但在一个创业公司里面，甚至大公司的一个创业团队里面，我们需要对接一些关键的业务节点，冲刺一些特定的时间窗口，并且要及时响应多变的业务，和业务背后多变的产品形态，这都会带来非常密集的需求队列。</p> \n<p>这些密集的需求队列对我们的代码实现质量有非常高的挑战，一个组件用 5 分钟思考如何抽象和用 50 分钟思考，实现后的稳定性、兼容性都是不同的，如何保证产品按期交付上线，会是摆在我们面前一个非常关键的命题，而这个难题之外，还有一个更难的命题等着我们，那就是如何保证交付不延期的同时，还能保证交付质量。</p> \n<p>要知道，如果一个项目代码赶的太毛糙，后期维护起来的成本会是巨大的，甚至只能用更高的成本重构重写。本质上，再次重构就一定是公司在为早期的猛冲买单，为这些技术债买单，如何不去买单或者如何用最小的成本买单，这跟我们早期的业务密集程度，交付周期，质量把控有很大的关系。</p> \n<p>综上，移动端碎片化所带来的兼容难度，RN 框架的局限性，版本间差异带来的不稳定性，技术社区资源的匮乏和前端团队技术能力掣肘，再叠加上高密度的业务排期，让前端开发这个本来很酷的事情，变得晴雨不定。</p> \n<p>这些避不开的现实，是绕不过去的坎儿，是搭建团队必须搞定的基础，我们想要把 B2B 生鲜的线上线下场景通过端产品关联起来，想要通过前端团队的用户侧输出从而让这些产品落地，就必须面对这些现实挑战，而应对这些挑战，首先必须搞清楚有哪些挑战，搞清楚挑战以后，我们就会认识到，首当其冲的事情，是去搭建 B2B 生鲜公司的前端技术栈和人才梯队，现在我们进入到本文的重点。</p> \n<p><a></a></p> \n<h3>三、如何应对井喷的挑战</h3> \n<p><a></a></p> \n<h5>1. 前端梯队如何搭建</h5> \n<p>创业公司的技术团队，本质上就是人和事，用合适的人搞定特定的事，人才的瓶颈就是这家公司产品落地速度和上线质量的瓶颈，因此人是第一位的，对于前端团队来说，如何一步步形成有综合战斗力的团队，取决于搭建什么层次的前端梯队，如果所有人一视同仁，培养同样的能力栈，发挥同样的兴趣向，跟进同样的业务线，那么这个梯队的扁平就会带来致命的团队瓶颈：能力可复制但不能互补，能力可递进但很难跨越，不能互补和很难跨越会导致团队内的技术路线过于单一，技术思维趋于固化，至于技术储备的丰富性和技术沟通带来的碰撞就更有限，最终导致人做事越来越机械化，甚至失去最初的技术初心。</p> \n<p>那么小菜前端到底如何搭建，还是要从公司的人员、业务和技术现状出发，由于端的碎片化和技术框架的不稳定性，就必须在质量保障上投入巨大的人力保证产品可用，而人才能力局限性和数量的匮乏，就跟产品的质量保证成为了天然的矛盾，不可协调，代码撺太快，线上天天都是 Bug，代码撺太慢，产品节奏跟不上，至于跟工程师天天宣讲要小心小心再小心，能起到的作用也不大，因为工程师本身的能力也是参差不齐的，所以就必须把团队先拆成两部分，一部分做基建支持，一部分做业务支持，基建支持的同学研发整个团队的工具脚手架、抽象和打磨团队的基础通用组件、长期维护项目的通用架构，这些投入都会反哺到业务支持的同学，业务的同学可以放心大胆的基于基建的成果做上层业务开发，稳定的工程基础有了保障，上层的业务代码做质量保障难度就大大降低了。</p> \n<p>除了分出来人做基建，做业务，还需要有核心的技术骨干，做技术前瞻性的研究，为团队 3 个月后，半年后，甚至 1 年后的技术方向，做必要的调研、测试和实验性开发，因为对于刀耕火种的早期技术团队，从原始人到迈向外太空跨空间作战，这中间还差着很多个关键的技术迭代节点，这些关键的技术迭代节点，一部分是靠外招技术专家和资深的工程师来输血发力，还有一大部分是需要靠团队内部长期的积累沉淀，也就是人才内部培养。</p> \n<p>我们总结一下：</p> \n<ul> \n <li>基建的同学负责输出工具系统、基础组件、流程规范，保证内部效率最大化和质量的有效保障</li> \n <li>架构的同学负责攻克技术底层难点，调研先进技术，升级团队技术架构，沉淀技术方案，锁定和推进团队未来技术方向</li> \n <li>业务的同学负责产品跟进，高频使用基建产品，并通过反馈来优化团队的技术基础设施，同时基于业务来抽象更多的基建需求</li> \n</ul> \n<p>基建、架构、业务这三个角色并不是相互独立，而是互有重合各有侧重，一个业务的同学，可能也同时在负责基建的事情，一个基建的同学，可能也同时在参与架构的设计，在小菜就有同学以架构和基建为主，业务也时不时的参与开发，架构和基建必须依托于业务场景来做，不能脱离了场景，不然会输出畸形的难以落地的技术方案。</p> \n<p>上面是人员的分工，还有三个重要的保障，这里不做引申，只列举一下：</p> \n<ul> \n <li>团队人员的兴趣栈、能力栈和业务要尽量匹配</li> \n <li>团队人员的阶段性目标、长期规划要跟进公司的职业晋升路线和能力模型</li> \n <li>团队要有持续性的内部技术互动分享和对外的技术理念、方法方案分享</li> \n</ul> \n<p>小菜的前端是大前端，对人的要求是：一专多精多能，至少在某个领域内朝着专家方向走，同时要慢慢精通多项技能，最后是具备多个特定技术栈的开发能力，比如 ReactNative，在小菜就是一个必须具备的开发能力，不要求每一个同学都成为 RN 专家或者精通，但要具备业务开发的能力，通俗点描述，就是能用 RN 开发业务产品。</p> \n<p>最后一点，就是资源流转，架构的同学，基建的同学和业务的同学的梯次关系是从下到上，越下越接近技术本质，越上越接近业务结果，越向下需要越好的技术实力，越向上需要越好的业务理解能力，这两个能力都是核心能力，需要让团队成员沿着梯队关系慢慢流动起来，业务中技术能力好的同学可以有机会沉下来做做基建，长期埋头基建的同学可以有机会上去做做业务，业务理解不错技术沉淀又好的同学可以继续沉下去参与架构，这样团队内部的同学都可以有多样性的技术场景和业务场景，一旦有同学请假、陷在别的业务不能抽调，马上就有同学可以补位进来开发，不会影响到产品上线节点。</p> \n<p>关于团队如何搭建，目前小菜是走到了这个算是 v1.0 的阶段，未来还有更多挑战，也会带来更多的基于公司现状的新调整，无论如何变迁，方法论我们先沉下来：</p> \n<ul> \n <li>人才梯队要有层次：基础架构、基建和业务上层等</li> \n <li>人才成长要有规划：兴趣栈、能力栈和公司关系</li> \n <li>人才能力要有扩展：单人能力和互补后的团队能力</li> \n</ul> \n<p>以人为过程，以事为结果，人事之间要有动态的机制形成互惠互补的关系，只有这样，团队才会初心不变，激情常在。</p> \n<p><a></a></p> \n<h5>2. 如何做技术选型</h5> \n<p>技术选型是一个行业老话题了，方法论也有很多，在小菜我们遵循的是：技术方向性预研大踏步，业务基建型开发小碎步，前者尽可能激进，后者尽可能保守，比如 数据报表系统，我们激进的采用 GraphQL 来解决 &nbsp;SQL =&gt; 页面 Dom 的链路问题，在宋小福 App 上面，我们就求稳的采用 v0.48 的 ReactNative 版本，而不是用当时较新的 v50+ 版本。</p> \n<p>在做技术选型之前，还有一些比较重要的基础性问题需要搞定，那就是团队技术动作的一致性，这个一致主要包含两点：</p> \n<ul> \n <li>代码规范共用一套</li> \n <li>仓库合作方式共用一套</li> \n</ul> \n<p>这两点如果不一致，会给技术选型后的落地带来内耗成本，千万不可大意。</p> \n<p>再回到技术选型本身，抛开激进保守的大踏步和小碎步，我们需要回到技术本质和工程师的本质来看待如何选的命题，技术的本质是效率，工程师的本质是兴趣，如果这一套技术选型不能带来效率，如果工程师普遍不感兴趣，那么通常这一个选型我们不会采纳，我觉得这一个主观一些的标准，大家可以参考，但这里面也要权衡好历史包袱、维护成本，上手难度等这些客观现实，如果一个新技术会带来革命性的效率提升，那么即使有上手难度和维护成本，我们也会果断入坑，比如 GraphQL 对于数据报表对于解放前后端有大幅度的提升，我们会果断入坑大力推行，如果一个技术对于团队是锦上添花，那么我们会慎重选用，比如 TypeScript，可以给工程稳定性带来了较大的保障，但我们只选择在热更新这种 RN SDK 和 Server 端的去集成，而不是一下子推广到整个团队项目中铺开用，这里面就会考虑到实际得到的好处，以及历史包袱和上手难度，反复权衡后并没有带来更大的价值，所以这两类场景的推行和不大力推行，就又不会太依赖于工程师的喜好兴趣。</p> \n<p>那么我们技术选型后的结果是如何呢？</p> \n<p>文章最开始的那张图，里面就是我们的技术栈，这里再做一下总结：</p> \n<ul> \n <li>工具类：强依赖 Node，多而杂的其他技术，如：MongoDB/Redis/MySQL/Shell/Python</li> \n <li>业务类：强依赖 React/ReactNative，适度集成其他技术，如： Redux/GraphQL/Apollo</li> \n <li>框架类：除了 React 全家桶会谨慎选择，Node 端框架则相对宽松：Koa/Thinkjs/Eggjs</li> \n</ul> \n<p>这些相对求稳，不求稳的部分，如小程序开发，我们会使用 mpvue，也会用原生，还会集成进去 GraphQL，同时一些涉及到数据爬取和视频图像识别，我们也会集成 Python/C++/TenserFLow 等等，不过这些往往是前瞻性的技术尝试，会让团队的同学适当分配精力持续研究。</p> \n<p><a></a></p> \n<h5>3. RN 的 App 工程如何架构</h5> \n<p>小菜的主要产品类型，尤其是对外的产品，主要是 RN App，而且数量较多，那么 RN 项目的合理架构就变得尤其重要，我们这里探讨下小菜前端在 RN App 上面的沉淀，涉及到原生层面的技术细节太多，这里暂不做讨论。</p> \n<p>首先，我们在构建 RN App 工程时需要关注这几个关键要素：</p> \n<ul> \n <li>配置管理</li> \n <li>静态文件管理</li> \n <li>网络请求</li> \n <li>组件管理</li> \n <li>路由管理</li> \n <li>数据缓存</li> \n <li>App 的热更新</li> \n <li>数据搜集</li> \n</ul> \n<p><strong>配置管理</strong>是指可以灵活合理的管理 App 的内部环境，主要包括：</p> \n<ul> \n <li>App 本身的一些配置</li> \n <li>所使用三方插件的配置</li> \n</ul> \n<p>我们在构建工程时尽量将所有的配置抽象统一放置在一个地方，这样便于查找和修改，但是由于大多数配置都统一放在同一个地方，那么就难免有部分文件要使用某个配置时其引用路径比较长，比如：</p> \n<pre><code class=\"javascript\">import { pluginAConfig } from \'../../../../../config\'</code></pre> \n<p>这样就造成了阅读性很差且代码不美观，因此我们可以使用 Facebook 的 <code>fbjs</code> 模块提供的一个功能<code>providesModule</code> :</p> \n<pre><code class=\"javascript\">//config.js\n/**\n * config for all\n * @providesModule config \n * 使用 providesModule 将 config 暴露出去\n **/\nimport pluginAConfig from \'./plugin_a_config\'\n\nexport default {\n    pluginAConfig\n}\n\n// 然后在其他文件中调用\n// A.js\nimport { pluginAConfig } from \'config\'</code></pre> \n<p>这样就能很方便地在 App 的任意一处使用 config 了，但是我们要避免滥用 <code>providesMoudle</code> ，因为使用了 <code>providesMoudle</code> 进行声明的模块的源码，想要在编辑器中使用跳转到定义的方式去查看比较困难，不利于团队多人合作。</p> \n<p><strong>静态资源</strong>泛指会被多次调用的图片或 icon，我们一般在 RN 使用图片时是直接引用的：</p> \n<pre><code class=\"javascript\">import { Image } from \'react-native\'\n\nrender(){\n &nbsp;return (\n    &lt;Image source={{uri: \'./logo.png\'}} /&gt;\n &nbsp;)\n}</code></pre> \n<p>当图片需要在多处使用时，我们可能会将这些可能会被反复使用的图片统一管理到 <code>assets</code> 文件夹中，统一管理和使用，但是当需要使用图片资源的文件嵌套较深时，引用图片就变得麻烦：</p> \n<pre><code class=\"javascript\">render(){\n &nbsp;return (\n &nbsp; &nbsp;&lt;Image source={{uri: \'../../../../assets/logo.png\'}} /&gt;\n &nbsp;)\n}</code></pre> \n<p>这个问题与配置管理的问题一样，可以首先将图片资源按照类型进行分类，比如 assets 文件夹下有 button/icon/img/splash/svg 等，每一个类型的结构如下：</p> \n<pre><code class=\"javascript\">- icon/\n - asset/\n - index.js</code></pre> \n<p>其中 <code>asset</code> 文件夹保存我们的图片资源，在 <code>index.js</code> 中对图片进行引用并暴露为模块：</p> \n<pre><code class=\"javascript\">// index.js\nexport default {\n   IconAlarmClockOrange: require(\'./asset/icon_alarm_clock_orange.png\'),\n   IconAvatarBlue: require(\'./asset/icon_avatar_blue.png\'),\n   IconArrowLeftBlue: require(\'./asset/icon_arrow_left_blue.png\'),\n   IconArrowUpGreen: require(\'./asset/icon_arrow_up_green.png\')\n}</code></pre> \n<p>然后再在 <code>assets</code> 文件夹下编辑 <code>index.js</code> ，将所有的图片资源作为 <code>assets</code> 模块暴露出去，为了避免和其他模块冲突你可以修改模块名为 <code>xxAssets</code></p> \n<pre><code class=\"javascript\">// assets/index.js\n/**\n * @providesModule myAssets\n **/\n import Splash from \'./splash\'\n import Icon from \'./icon\'\n import Img from \'./img\'\n import Btn from \'./button\'\n import Svg from \'./svg\'\n\n export {\n   Splash,\n   Icon,\n   Img,\n   Btn,\n   Svg\n }\n\n// A.js\nimport { Icon } from \'myAssets\'\n\nrender(){\n &nbsp;return (\n &nbsp; &nbsp;&lt;Image source={Icon.IconAlarmClockOrange} /&gt;\n &nbsp;)\n}</code></pre> \n<p>这样，我们就能很方便地将分散在项目各处的图片资源统一到一个地方进行管理了，使用起来也非常方便。</p> \n<p><strong>网络请求</strong>这块，react-native 使用 <a href=\"https://github.com/facebook/react-native/blob/master/Libraries/Network/fetch.js\" rel=\"nofollow noreferrer\">whatwg-fetch</a>，我们也可以选在其他的三方包如 <a href=\"https://github.com/axios/axios\" rel=\"nofollow noreferrer\">axios</a> 来做网络请求，但有我们在开发中遇到过一个问题，那就是我们明明已经在代码里已经修改了 cookie， 但是每次请求可能还是会带上之前的 cookie 从而造成一些困扰，所以这里推荐一个实用的组件 <code>Networking</code> :</p> \n<pre><code class=\"javascript\">import { NativeModules } from \'react-native\'\nconst { Networking } = NativeModules\n\n// 手动清除已缓存 Cookie，这样就能解决上述的问题了\nNetworking.clearCookies(callBack)</code></pre> \n<p>当然，<code>Networking</code> 的功能不止于此，还有很多其他有趣的功能可以发掘，可以直接用它来包装自己的网络请求工具，还支持 <code>abort</code> ，可以参考 <a href=\"https://github.com/facebook/react-native/blob/master/Libraries/Network/RCTNetworking.ios.js\" rel=\"nofollow noreferrer\">源码</a> 来具体把玩。</p> \n<p>使用 RN 开发 App 本身效率就比较高，如果想要继续进阶就要考虑组件化开发，一旦涉及到组件化开发，就不可避免地会涉及到组件管理的问题，这里的<strong>组件管理</strong>比较宽泛，它实际上应该指的是：</p> \n<ul> \n <li>组件规范</li> \n <li>组件类型划分</li> \n <li>组件开发标准</li> \n</ul> \n<p>组件规范指的是 UI 设计规范，我们可以与设计同学交流规定好一套特定的规范，然后将通用的样式属性（如主题颜色，按钮轮廓，返回按键，Tab 基础样式等）定义出来，便于所有的组件开发者在开发时使用，而不是开发者各自为政在开发时重复写样式文件，这里推荐一个比较好用的用于样式定义的三方插件 <a href=\"https://github.com/vitalets/react-native-extended-stylesheet\" rel=\"nofollow noreferrer\">react-native-extended-stylesheet</a> ，我们可以使用这个插件定义我们的通用属性：</p> \n<pre><code class=\"javascript\">// mystyle\nimport { PixelRatio, Dimensions } from \'react-native\'\nimport EStyleSheet from \'react-native-extended-stylesheet\'\n\nconst { width, height } = Dimensions.get(\'window\')\n\nconst globals = {\n  /** build color **/\n  $Primary: \'#aa66ff\',\n  $Secondary: \'#77aa33\',\n  $slimLine: 1 / PixelRatio.get(),\n  /** dimensions **/\n  $windowWidth: width,\n  $windowHeight: height\n}\n\nEStyleSheet.build(globals)\n\nmodule.exports = {\n  ...EStyleSheet,\n  create: styleObject =&gt; EStyleSheet.create(styleObject),\n  build: (obj) =&gt; {\n    if (!obj) {\n      return\n    }\n    EStyleSheet.build(_.assign(obj, globals))\n  }\n}\n\n// view.js\nimport MyStyleSheet from \'mystyle\'\n\nconst s = MyStyleSheet.create({\n &nbsp;container: {\n &nbsp; &nbsp;backgroundColor: \'$Secondary\',\n &nbsp; &nbsp;width: \'$windowWidth\'\n &nbsp;}\n})\n\nrender....</code></pre> \n<p>这样，我们就能在开发的任意插件或者 App 中直接使用这些基础属性，当某些属性需要修改时只需要更新 <code>mystyle</code> 组件即可，还可以衍生出主题切换等功能，使得开发更加灵活。</p> \n<p>关于组件类型我们会抛开三方组件以及原生组件，因为一旦涉及到这两者，需要写的东西就太多了，我们将组件按使用范围分为通用组件和业务组件两大类。</p> \n<p>首先什么是业务组件？即我们在开发某个业务产品常用到的组件，这个组件绑定了与业务相关的一些特殊属性，除了这个业务开发以外，其他地方都不适用，但是在开发这个业务时多个页面会频繁地使用到，所以我们有必要将其抽象出来，方便使用。</p> \n<p>什么是通用组件？即可以在 App 范围内使用甚至于跨 App 使用的组件，这里可以对这个类别进行细分，我们将能跨 App 使用的组件上传到了自己的搭建的私有 npm &nbsp;仓库，方便我们的 App 开发者使用，同时，具有 App 自己特色的组件则放到工程中统一管理，同样适用 <code>providesModules</code> 暴露出去。</p> \n<p>制定一整套组件开发标准的是很重要的，因为很多组件开发可能是多人维护的，有一套既定的规范就可以降低维护成本，组件使用的说明文档的完善也同样重要。</p> \n<p>开发 App 就不可避免地会遇到如何管理页面以及处理页面跳转等问题，也就是<strong>路由管理</strong>问题，自从 Facebook 取消了 RN 本身自带的 Navigator 以后，许多依赖于这个组件的开发者不得不将目光投向百花齐放的社区三方组件，FB 随后推荐大家使用的是 <a href=\"https://github.com/react-community\" rel=\"nofollow noreferrer\">react-community</a> 推出的 <a href=\"https://github.com/react-navigation\" rel=\"nofollow noreferrer\">react-navigation</a>&nbsp;，现在这个路由组件已经独立出来了。我们在开发时就是使用的这个组件作为路由管理组件，只不过是在其基础上做了一些定制 ，使得使用更加简单，部分跳转动作更加符合我们的产品场景，推荐大家使用这个组件。当然，除去这个组件还有很多其他的组件可供选择：</p> \n<ul> \n <li>基于 <code>react-navigation</code> 进行深度定制的 <a href=\"https://github.com/aksonov/react-native-router-flux\" rel=\"nofollow noreferrer\">react-native-router-flux</a> </li> \n <li>基于原生解决方案的 <a href=\"https://github.com/wix/react-native-navigation\" rel=\"nofollow noreferrer\">react-native-navigation</a> </li> \n <li>airbnb 的 <a href=\"https://github.com/airbnb/native-navigation\" rel=\"nofollow noreferrer\">native-navigation</a> </li> \n</ul> \n<p>路由管理作为整个 App 的骨架，它是这几个部分中最重要的一部分，合理地定制和使用路由管理可以极大地简化我们的开发复杂度。</p> \n<p>一般情况下需要缓存的数据基本上就可能是我们会在 App 很多地方都会使用到的全局数据，如用户信息，App 设置（非应用层面的设置）等，RN 提供一个 <a href=\"https://github.com/facebook/react-native/blob/master/Libraries/Storage/AsyncStorage.js\" rel=\"nofollow noreferrer\">AsyncStorage</a> 存储引擎，通常的使用方式是对这个数据引擎进行包装后暴露出符合我们要求的读写接口。这里推荐另外一种使用方式：</p> \n<p>既然需要缓存的数据可能是会在 App 很多地方使用到的全局数据，那么我们可以将这些全局数据使用 <a href=\"https://github.com/reactjs/redux\" rel=\"nofollow noreferrer\">redux</a> 来进行管理，而利器 <a href=\"https://github.com/rt2zz/redux-persist\" rel=\"nofollow noreferrer\">redux-persist</a> 则能让我们很优雅地读写我们的缓存数据。</p> \n<p>同时，如果对 <code>react-navigation</code> 进行合理的定制，接管其路由管理，那么我们还能实现保存用户退出 App 之前最后浏览的页面的状态，用户在下次打开 App 依然可以从之前浏览的地方继续使用 App，当然，这个功能要谨慎使用！</p> \n<p><strong>App 的版本更新</strong>，RN 除了传统的 App 更新外还有一个热更新的可选项（传统 App 更新也有热更新，其原理就不太一样了），社区大多数人都推荐使用 <a href=\"https://github.com/Microsoft/react-native-code-push\" rel=\"nofollow noreferrer\">codepush</a> 来进行热更新，至于其后端解决方案 貌似已经有了一个 <a href=\"https://github.com/lisong/code-push-server\" rel=\"nofollow noreferrer\">code-push-server</a> ，我们是使用自己的热更新方案，其原理就是在不更新原生代码的基础上更新 JS 代码和静态资源文件。</p> \n<p><strong>搜集的 App 使用数据</strong>(包括异常数据)并对此分析，根据分析来定位问题是保证 App 质量的有效手段之一。你可以选择自己搭建一套数据搜集服务，包括客户端 SDK 和服务端搜集服务，或者选择市场上已有的工具，目前较为成熟的收据搜集工具比较多，如友盟，mixpanel, <a href=\"https://count.ly/\" rel=\"nofollow noreferrer\">countly</a> 等等，在此不作赘述。</p> \n<p>总结一下，一个 RN App 架构应该要保证 App 的运行稳定以及开发的便捷。运行稳定这一方面，除了从 JS 层面（如单元测试，JS 错误上报等）保证之外，很大程度上还要依赖于原生层面的处理，所以团队里面要有同学的精力可以投在原生研究上面，至于开发便捷，我们尽量将复杂重要或者简单繁琐的操作在构建工程时就做掉，这样也可以大幅度提高我们的开发效率，降低开发者之间的合作沟通成本。</p> \n<p><a></a></p> \n<h5>4. 效率协同工具如何打造</h5> \n<p>效率协同往往不分家，效率宽泛一点，就是又快又好，协同宽泛一点，就是顺滑无内耗，而且效率协同在不同的场景下，一定有不同的表现，所以效率协同一定要具体到某一个场景才有意义，比如：</p> \n<p>我们要发布 6 款 RN App 中的若干款，在一周内的若干天发布，由若干人自行打包测试自行发布，那么这里面就有巨大的协同问题，同时还有一些效率问题，如果一个同学进来改了 3 行接口调用代码，他至少要有这几个阶段:</p> \n<ul> \n <li>开发阶段本机切新分支调试</li> \n <li>测试阶段打一个连接测试环境的包测试有效性</li> \n <li>测试完再打一个连接正式环境的本地包测正确性</li> \n <li>最后再打一个连接正式环境的用来热更新的包进行发布</li> \n</ul> \n<p>那么多人之间都各自来做这个发布，就会出现一些发布冲突的协同问题，如果把发布权限全回收到某一个人，协同貌似能解决，但是会带来效率问题，大家要让这个发布人频繁打包，或者打好的包，反复传给发布人，发布人的时间线就被他人的开发进程给打断了，变成了一个打包员，关于这个我专门做了一张图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1525411608024-527ad7a0-2767-4132-91ac-5da2cec086ae.png#align=left&amp;display=inline&amp;height=523&amp;originHeight=1160&amp;originWidth=1658&amp;status=done&amp;style=none&amp;width=747\" src=\"http://localhost:8060/tup/2020/4/23/98cf454439a347319563e8da2a97304d.jpg\" alt=\"\" title=\"\"></span></p> \n<p>这里面的一个圆点，就代表一个编译后的包，比如 A 打出来的不需要 Debug 的连接正式环境的需要热更新的 iOS 的 ipa 包，那么 A 的这个包，跟 B 打出来的不需要 Debug 的连接正式环境的需要热更新的 iOS 的 ipa 包，即便是在同一个仓库的同一个分支，也不能保证 100% 一模一样的包，原因在于，这些本地打的包，还会受到 Node/NPM 版本（语义化），XCode 版本，原生热更新版本控制等等因素影响，导致这个包自身很容易出问题，甚至是一些人肉引发的分支和人工上传等等的影响，也会导致这个包发布出问题，举一个我们真实发生过的故障，A 打完包，把包文件钉钉传给 B，B 在发布的时候，选择本地文件时候选错了一个老版本直接发布上线，导致线上部分用户直接版本回退，我们后来不得已采用紧急回滚，才把影响范围控制住。</p> \n<p>上面大篇幅的介绍打包的这个场景，是小菜前端早期非常痛苦的一个场景，协同方式和规范无论我们如何三令五申总是避免不了人肉的问题，一旦出问题，就是大问题大故障，那么这时候，就必须投入基建的力量来打造一款或者一套流程工具，通过工具一劳永逸的解决这些主要的协同问题，把琐碎人肉的事情交给机器去做，机器比人做的快，也比人做的好。</p> \n<p>我们来总结一下，团队跑一段时间，一定会挤压一些问题，这些问题不可以视而不见，也不可以拿业务支持第一这样的借口来无限期推迟解决问题，而是时不时评估一下，有没有可能通过系统和工具，来约束一些行为，来取代一些人肉工作，进而可以一劳永逸的解决掉一些问题，一旦决定去解决了，那么如何打造协同工具就变得顺水推舟了，因为工程师最擅长的干的事情之一，就是造轮子造工具。</p> \n<p>小菜前端造了哪些轮子哪些工具呢，文章最开始就已经列出来了，这里再陈述和解释一下：</p> \n<ul> \n <li>大伯伯（谐音打包包） 解决人肉打包带来的协同问题</li> \n <li>大表姐（代号 Laurence - 来自饥饿游戏） 解决人肉发布、人工维护版本，问题追溯定位的效率问题</li> \n <li>姑奶奶 解决去多个三方平台查看异常日志和 Bug 反馈指派的人肉效率问题</li> \n <li>大舅子 解决前后端耦合在 Restful/Mock/冗余的接口 的合作效率问题</li> \n <li>RGB &nbsp; &nbsp;解决纯数字报表分析页面访问数据和用户行为的效率问题</li> \n <li>堂哥工作台 解决组员与 Leader 日报周报难回忆带来的书写效率和后期回顾问题</li> \n <li>小菜图书馆 解决小菜书架上面借书还书靠人肉记录维护的效率问题</li> \n <li>...</li> \n</ul> \n<p>其中的大舅子这个单独拿出来说一下，现在前后端常见的合作方式是基于 restful API 的接口合作，前后端经过一轮接口评审，后端再为前端写 Mock 数据，可能还会加上一个 Proxy 服务，最终前端本地的页面上，做 Mock 环境、测试环境和正式环境的切换，这种方式最大的问题有 2 个：</p> \n<ul> \n <li>前端比较依赖于后端的接口定义，后端为前端 Mock 做完后，前端才方便的进行页面中的数据替换和逻辑判断，有等待成本</li> \n <li>前端复杂多变的页面会影响到后端的接口复杂度和体积，页面上的字段增减，都会反映到接口的字段增减，接口本身变得不稳定，会带来很多隐患点，比如接口体积越来越臃肿，或者接口有多个版本，一旦接口文档更新没跟上，会导致后期的同一个接口的不同版本之间，增加调用出错概率等等</li> \n</ul> \n<p>当然业界也有各种各样规避这些问题的策略，可能是文档建设，可能是流程约束，小菜早期，哪怕到现在，也是在使用这种方式合作的，直到现在我们有了大舅子，前后端合作的方式开始进化，大舅子系统架构图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1527817993898-647eb047-03cf-4747-99b4-f31eb6bf2b00.png#align=left&amp;display=inline&amp;height=429&amp;originHeight=927&amp;originWidth=1616&amp;status=done&amp;style=none&amp;width=747\" src=\"http://localhost:8060/tup/2020/4/23/08e2ea77d3f94365a28cb7fb8691ee4b.jpg\" alt=\"\" title=\"\"></span></p> \n<p>大舅子目前的架构是放到网关下面，网关层做一些鉴权和安全的处理，向下把一个 GraphQL 的请求转发给大舅子，大舅子上面根据这个 Query Type 对应的 Resolver 去调用下层的服务接口，下层可能是另外一个 GraphQL 服务，也可能是微服务，也可能是数据库，兼容度很高，无论是哪一种，大舅子的角色扮演就是配置和聚合：配置客户端上页面对应的数据类型，嵌套关系和数据结构，向下连接和聚合不同的数据源。</p> \n<p>内部的开发正式环境关系图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1527818051969-24d27b30-4b7f-4221-a436-9a47a0bc171d.png#align=left&amp;display=inline&amp;height=636&amp;originHeight=1080&amp;originWidth=1268&amp;status=done&amp;style=none&amp;width=747\" src=\"http://localhost:8060/tup/2020/4/23/0cfc6253adf540c7abd09e7db17d98a8.jpg\" alt=\"\" title=\"\"></span></p> \n<p>这个事情并不新鲜，多年前，Nodejs 就在扮演数据聚合层的角色，把多个 API 聚合成一个 API，或者打散一些 API，聚合成新的 API，但本质上依然是向客户端提供 API，这种 API 依然是面向页面，可以看做是页面驱动的 API，大舅子因为整个建模基础是 GraphQL，所以页面和数据结合的权利，交给了客户端自己去做，它需要什么数据，就在客户端声明什么数据结构，带来的好处很多，这里列举两条我认为有价值的：</p> \n<ul> \n <li>前端可以不再局限于接口评审阶段，可以继续往前提到数据库/表结构评审阶段进入开发流程，在表结构评审期就能拿到字段定义与含义，从而再大舅子上提前定义前端自己的 Type 和 Resolver</li> \n <li>后端不再耽误自己的时间为前端提供 Mock，也不再受页面 API 的约束，可以下沉精力专心做下层业务领域能努力的建设，下沉的领域能力多大，那么端上可使用和组合的能力就有多大</li> \n</ul> \n<p>从此，尘归尘，土归土，前后因为页面数据控制权的分离而解耦，也因为数据能力的回收而同时贴近业务，前端也被倒逼去了解业务，不再仅仅是界面和产品交互驱动，现在大舅子还在早期的迭代阶段，关于它的好处和优化的空间还非常非常大，今天不做深入讨论，我们来总结一下：</p> \n<p>小菜前端已经从工具基建中受益，因为工具带来了协同和效率的优化只是结果之一，最重要的收获还有两个：</p> \n<ul> \n <li>解放了小菜前端团队以及技术团队的人肉时间，可以有精力做其他事情</li> \n <li>通过基建工具研发培养了小菜前端分析问题和解决问题的能力，同时沉淀了一些不错的技术方案</li> \n</ul> \n<p>那么小菜的成长和沉淀，我们接下来就可以来总结一下了。</p> \n<p><a></a></p> \n<h3>四、技术成长和沉淀</h3> \n<p>技术成长就是工程师的能力变化，我在 4 月份给大家做了一个 10 个月前后的能力评估，这 10 个月，是小菜前端 3 年来基建密度和团队内调整最大的几个月，也是团队整体战斗力提升最大的几个月，本文的所有分析、策略和实际的解决办法，也都是在这几个月里面进行实施的，挑了几个同学，挑了几个主要的能力维度，我们感受下他们的技术成长，白色的 * 代表 10 个月之前的能力值，2 颗星代表可以熟练的开发，三颗星代表基本精通或擅长，四颗星是比较精通。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1525415185719-d923f471-39a7-4f7c-9970-d76e8b3a3886.png#align=left&amp;display=inline&amp;height=343&amp;originHeight=832&amp;originWidth=1814&amp;status=done&amp;style=none&amp;width=747\" src=\"http://localhost:8060/tup/2020/4/23/b63e21c449fd440f9b9fbba9cb179f3c.jpg\" alt=\"\" title=\"\"></span></p> \n<p>可以看到每个人都有不同程度不同层面的成长，有的全面开花，有的某些领域内快速积累，也要同学技术成长不多，但是协作能力工程能力有很大提升，其实还少了一个维度，就是参与业务拿到的结果或者说业务能力，图上放不下了，稍后会做分析和补充，我们再来看下这些同学做的事情：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1525415536480-e57c2ab2-4c21-47f5-8bd5-15723be9270d.png#align=left&amp;display=inline&amp;height=420&amp;originHeight=998&amp;originWidth=1776&amp;status=done&amp;style=none&amp;width=747\" src=\"http://localhost:8060/tup/2020/4/23/2b713cfd8423432387eccc450a3edc0b.jpg\" alt=\"\" title=\"\"></span></p> \n<p>如果仔细比照一下，我们很容易得出三个结论：</p> \n<ul> \n <li>整个技术团队综合技术能力有大幅度的提升</li> \n <li>承担职责越多的同学能力成长越多越快（如组员 A）</li> \n <li>承担繁重基建和工具开发的同学比承担业务开发的同学技术成长更多（如组员 E）</li> \n</ul> \n<p>业务能力没有放到图上，这是要补充的第四个结论</p> \n<ul>\n <li>承担业务越多的同学，项目管理能力/沟通能力/业务理解能力也越好</li>\n</ul> \n<p>以上是人才成长，那么沉淀下来的内容一共是三部分：</p> \n<ul> \n <li>通用的工具技术解决方案</li> \n <li>通用的技术模块和业务组件库</li> \n <li>团队整体的问题解决套路（分析解决问题的思维方式）</li> \n</ul> \n<p>通用的技术解决方案可以不断的快速复用，比如我们宋小福用新架构前后调整优化有 1 个月，把这同一套架构放到麦大蔬上 2 周就够了，再次迁移到新项目宋大仓里面只需要 1 周就搞定了。</p> \n<p>通用的技术模块和业务组件库，则是我们的组件三步走策略，首先是某个业务产品线下面的组件模板，比如 筛选组件或者列表组件，能在这个业务场景下的产品形态中通用，如果它可以跨产品线，那么就会跃升为 App 内通用组件，如果它还能继续抽象具有可重用性，那么就可以跃升为跨 App 的通用业务组件，比如热更新组件，地理位置定位组件，登录组件，异常提示弹窗组件等等。</p> \n<p>团队整体的问题解决套路，这个是我们最大的收获，再直白一点，就是如何更快更好更有创造性的做事，这种思维方式，解决问题的套路，本质上是可以在团队内不断传承的，无论我们后面遇到什么样的业务和团队问题，我们用这一套场景-技术-长短期投入产出比评估的路子，都能用较轻的方式把问题解决掉，这个对于我们培养新人有很大的帮助。</p> \n<p><a></a></p> \n<h3>五、对未来的展望</h3> \n<p>小菜三年走过来，前端团队从早期的技术和人员不稳定，到现在趋于稳定，站在公司的角度，最大的收获就是培养和磨炼了一批有创业热情，有担当勇气，有技术底蕴的一群人，这一群人抱团在一起，可以在所谓大前端这个框框内玩出更多的花样，支持到更多的业务场景。</p> \n<p>站在今天看明天，虽然有很多东西对我们来说依然是未知的，但我们不再像过去一样临场发怯，手忙脚乱，取而代之的是无论多大多难的业务类型，我们都可以坐下来利用这帮人的智慧汇聚出一个最优选择，胸有成竹的去做技术探索和工程尝试，在跟公司一起成长变大的过程中，站在今天看明天，虽然有很多东西对我们来说依然是未知的，但我们不再像过去一样临场发怯，手忙脚乱，取而代之的是无论多大多难的业务类型，我们都可以坐下来利用这帮人的智慧汇聚出一个最优选择，胸有成竹的去做技术探索和工程尝试，在跟公司一起成长变大的过程中，小菜前端也一定会沉淀出来更有实践价值，更有效率的技术方案，而这些就是我们将来可推广复用的宝贵技术资产，当然除了宝贵的技术资产，最最最重要的还有我们这群人，可以开心有趣有挑战性的 Coding，想进一步了解我们团队的可以<a href=\"https://cnodejs.org/topic/5ad951ec3edb2aff6be85e01\" rel=\"nofollow noreferrer\">移步这里</a>。</p> \n<blockquote>\n Scott 近年面试或线下线上技术分享，遇到太多前端同学，由于团队原因/个人原因/职业成长/技术与管理通道，甚至家庭城市等等原因，在理想国与现实之间，在放弃与坚守之间，摇摆不停，心酸硬扛，大家可以找我聊聊南聊聊北，对工程师的宿命和价值有更多的看见与了解，Scott 微信： codingdream，也可以来\n <a href=\"https://www.yuque.com/iscott\" rel=\"nofollow noreferrer\">关注 Scott 跟进我的动态</a>。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882754189-781488ce-b345-45cf-a3b7-cb5309e9caa6.png#align=left&amp;display=inline&amp;height=399&amp;name=2.png&amp;originHeight=600&amp;originWidth=600&amp;size=158647&amp;status=done&amp;style=none&amp;width=399\" src=\"http://localhost:8060/tup/2020/4/23/f29f3acfc85549bcbed614eeadc07e91.jpg\" alt=\"2.png\" title=\"2.png\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882773713-309efa88-e1fc-481f-865b-3c0cb0d3ec43.png#align=left&amp;display=inline&amp;height=398&amp;name=1.png&amp;originHeight=600&amp;originWidth=600&amp;size=134434&amp;status=done&amp;style=none&amp;width=398\" src=\"http://localhost:8060/tup/2020/4/23/89ab9eb84d9d42138fcacf060ba29856.jpg\" alt=\"1.png\" title=\"1.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/5856709b6bc847c3b93ce5b0aeb05509.jpg', 'c56940aa8b004dab84568e86900b2ee6', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'd16a93d83052441a90afaa57d69fdc3c,12f91faac18b49819869f52fbdbb1960,15941dc0af92453481b8a0626f963283', '0', '3', '1', '2020-04-23 10:30:10', '2020-04-23 10:30:10');
INSERT INTO `tb_recommend` VALUES ('b8c473bef03646b8b96fc009155fa4c4', 'vue权限管理实现流程', '后端返回用户权限，前端根据用户权限处理得到左侧菜单；所有路由在前端定义好，根据后端返回的用户权限筛选出需要挂载的路由，然后使用 addRoutes 动态挂载路由。', '<h2>一、整体思路</h2> \n<p>后端返回用户权限，前端根据用户权限处理得到左侧菜单；所有路由在前端定义好，根据后端返回的用户权限筛选出需要挂载的路由，然后使用 addRoutes 动态挂载路由。</p> \n<h2>二、实现要点</h2> \n<p>（1）路由定义，分为初始路由和动态路由，一般来说初始路由只有 login，其他路由都挂载在 home 路由之下需要动态挂载。<br>（2）用户登录，登录成功之后得到 token，保存在 sessionStorage，跳转到 home，此时会进入路由拦截根据 token 获取用户权限列表。<br>（3）全局路由拦截，根据当前用户有没有 token 和 权限列表进行相应的判断和跳转，当没有 token 时跳到 login，当有 token 而没有权限列表时去发请求获取权限等等逻辑。<br>（4）处理用户权限，在 store.js 定义一个模块 permission.js，专门用于处理用户权限相关的逻辑，用户权限列表、菜单列表都保存在此模块；<br>（5）用户权限列表、菜单列表的处理，前端的路由要和后端返回的权限有一个唯一标识（一般用路由名做标识符），根据此标识筛选出对应的路由。<br>（6）左侧菜单，要和用户信息、用户管理模块使用的菜单信息一致，统一使用保存在 store 中的变量。</p> \n<h2>三、具体实现流程</h2> \n<h3>1、准备工作，路由定义</h3> \n<pre><code>/* router/indes.js */\n/* 初始路由 */\nlet router = new Router({\n    mode: \'history\',\n    routes: [\n        {\n            path: \'/login\',\n            name: \'login\',\n            component: () =&gt; import(\'@/views/login.vue\'),\n        },\n    ]\n});</code></pre> \n<pre><code>/* router/indes.js */\n/* 准备动态添加的路由 */\nexport const dynamicRoutes = [\n    {\n        path: \'/\',\n        name: \'home\',\n        component: () =&gt; import(\'@/views/home.vue\'),\n        meta: {\n            requiresAuth: true,\n        },\n        children: [\n            // 用户信息\n            {\n                path: \'/user-info\',\n                name: \'user-info\',\n                component: () =&gt; import(\'@/views/user-setting/user-info.vue\'),\n            },\n            // 修改密码\n            {\n                path: \'/user-password\',\n                name: \'user-password\',\n                component: () =&gt; import(\'@/views/user-setting/user-password.vue\'),\n            },\n        ]\n    },\n    {\n        path: \'/403\',\n        component: () =&gt; import(\'@/views/error-page/403\'),\n    },\n    {\n        path: \'*\',\n        component: () =&gt; import(\'@/views/error-page/404\'),\n    },\n];</code></pre> \n<p>系统主要页面的路由，后续会将这些路由经过权限筛选，添加到 home 路由的 children 里面</p> \n<pre><code class=\"javascript\">/* router/router.js */\nexport default [\n    // 部署管理\n    {\n        path: \'/deploy-manage\',\n        name: \'deploy-manage\',\n        component: () =&gt; import(\'@/views/sys-admin/deploy-manage/deploy-manage.vue\'),\n        meta: {\n            permitName: \'deploy-manage\',\n        }\n    },\n    // ...\n];</code></pre> \n<h3>2、用户登录</h3> \n<p>用户进入登录页，输入用户名、密码、验证码，点击登录，发送登录请求，登录成功之后，将 token 保存在 sessionStorage，然后跳转到首页 /home ，进入路由拦截的逻辑。</p> \n<pre><code>/* login.vue */\n// 发送登录请求\nvm.$http.login(params, data =&gt; {\n    sessionStorage.token = data.token;\n    // ...\n\n    // 跳转到首页 home。这里会触发全局路由拦截 router.beforeEach\n    vm.$router.push({ name: \'home\' });\n}, err =&gt; {\n    console.log(err);\n});</code></pre> \n<h3>3、全局路由拦截</h3> \n<p>首先从打开本地服务 <a href=\"http://localhost\" rel=\"nofollow noreferrer\">http://localhost</a>:2001 开始，打开后会进入 login 页面，那么判断的依据是什么？<br>首先是 token。没有登录的用户是拿不到 token 的，而登录后的用户我们会将 token 存到 seesionStorage，因此，根据当前有没有 token 即可知道是否登录。</p> \n<pre><code>/* 全局路由拦截 */\nrouter.beforeEach((to, from, next) =&gt; {\n    // 根据有没有token判断是否登录\n    if (!sessionStorage.token) {\n        // 1、当用户打开localhost，to.matched === []，匹配的是空路由，此时需要重定向到login\n        // 2、重定向到login之后，to.matched === [name: \"login\", path: \"/login\"...] 就是上一步的login页面\n        // to.matched.some(item =&gt; item.meta.requiresAuth) 这句的意思是 进入的路由页需要登录认证，取反就是不用登录，直接通过\n        if (to.matched.length &gt; 0 &amp;&amp; !to.matched.some(item =&gt; item.meta.requiresAuth)) {\n            next(); // 跳过，进入下一个导航钩子。比如：在 /login 路由页刷新页面会走到此逻辑\n        } else {\n            next({ path: \'/login\' });\n        }\n    } else {\n        // 现在有token了\n        if (!store.state.permission.permissionList) {\n            // 如果没有 permissionList，发请求获取用户权限列表\n            store.dispatch(\'permission/FETCH_PERMISSION\').then(() =&gt; {\n                next({ path: to.path, query: to.query });\n            });\n        } else {\n            // 现在有 permissionList 了\n            if (to.path !== \'/login\') {\n                if (to.matched.length === 0) {\n                    // 如果匹配到的路由形如 https://172.24.1.117/?id=xxx&amp;name=xxx，表明是关联跳转时没有权限，跳转到403\n                    next({ path: \'/403\' });\n                } else if (queryChange) {\n                    // 跳转之前将路由中查询字符串为空的过滤掉，如 xxx.com?page=&amp;size= 这种\n                    next({ name: to.name, params: to.params, query: to.query });\n                } else if (sessionStorage.isSysLock === \'true\' &amp;&amp; to.path !== \'/sys-lock\') {\n                    next({ path: \'/sys-lock\' });\n                } else {\n                    next();\n                }\n            } else {\n                // 1.如果用户手动在地址栏输入 /login，重定向到之前的路由页\n                // next(from.fullPath);\n\n                // 2.如果用户手动在地址栏输入 /login，清除token并刷新页面，就会去到登录页\n                store.commit(\'goToLogin\');\n            }\n        }\n    }\n});</code></pre> \n<p>（1）当用户打开 localhost，此时还没有 token，匹配的是空路由，我们重定向到登录页 <code>next({ path: \'/login\' });</code><br>（2）用户在登录页刷新页面，也会进入路由拦截，此时匹配的是 login 路由，而 login 路由是不需要登录验证的（requiresAuth 为空或者 false），所以直接跳过执行 <code>next();</code><br>（3）用户在登录页输入了用户名和密码，登录成功，保存了 token，跳转到 /home 路由；<br>（4）此时进入路由拦截，已经有 token了，但是还没有用户权限 permissionList，然后发请求获取用户权限列表，得到权限后 <code>next({ path: to.path, query: to.query });</code> 继续往下走；<br>（5）再次进入路由拦截，此时有 token 和 permissionList 了，就可以根据实际业务进行跳转了。上面的代码是判断当前是不是 login 路由，如果用户登录后手动在地址栏输入 /login，则清除 token 跳转到登录页。其他的逻辑就跟具体业务相关了，就不细讲了。</p> \n<h3>4、处理用户权限</h3> \n<p>处理用户权限，在 store.js 定义一个模块 permission.js，专门用于处理用户权限相关的逻辑，用户权限列表、菜单列表都保存在此模块；<br>来看看 permission.js 主要做了什么：</p> \n<pre><code>/* permission.js */\n/* 由于权限这块逻辑很多，所以在vuex添加了一个permission模块来处理权限相关的逻辑和变量 */\nimport httpRequest from \'@/assets/js/service/http\'; // http请求\nimport handleModule from \'@/assets/js/common/handle-module\'; // 处理路由、侧边栏的公共函数\nimport router, { dynamicRoutes } from \'@/router/index\'; // 默认路由配置，动态路由配置\nimport permissionRouter from \'@/router/router\'; // 需要权限的路由配置\n// ...\nexport default {\n    // ...\n    actions: {\n        async FETCH_PERMISSION({ commit, state }) {\n            // 初始化路由表，注意这里必须写，router.beforeEach 路由拦截时，多次执行 FETCH_PERMISSION\n            commit(\'setPermission\', []);\n\n            // 发请求获取后端返回的用户权限\n            let data = await getUserByToken();\n            let userPopedoms = data.userPopedoms || [];\n\n            // 保存用户的权限模块（去除掉用户管理和登录），用户管理模块可以使用，权限列表\n            let userPopeList = userPopedoms.filter(v =&gt; v.requestMapping !== \'user-manage\' &amp;&amp; v.requestMapping !== \'login\');\n            commit(\'setUserPopedoms\', userPopeList);\n\n            // 根据权限筛选出我们设置好的路由并加入到 path=\'/\' 的children，就是home路由的children下\n            let routes = handleModule.getRouter(userPopedoms, permissionRouter);\n            let homeContainer = dynamicRoutes.find(v =&gt; v.path === \'/\');\n\n            // 使用concat的目的是让 分配给用户的权限处于 children 的第0项\n            homeContainer.children = routes.concat(homeContainer.children);\n            // 设置首页重定向，重定向到用户权限的第0项\n            homeContainer.redirect = homeContainer.children[0].name;\n\n            // 根据权限生成左侧导航菜单\n            let sidebarMenu = handleModule.getSidebarMenu(userPopeList);\n            commit(\'setMenu\', sidebarMenu);\n\n            // 初始路由\n            let initialRoutes = router.options.routes;\n            // 动态添加路由。只有刷新页面才会清空动态添加的路由信息\n            router.addRoutes(dynamicRoutes);\n            // 完整的路由表\n            commit(\'setPermission\', [...initialRoutes, ...dynamicRoutes]);\n        }\n    },\n};</code></pre> \n<p>（1）首先，<code>let data = await getUserByToken();</code> 发请求获取用户权限，得到 data，data.userPopedoms 格式大致如下：</p> \n<pre><code>[\n  {\n    \"moduleGroupId\": 1001,\n    \"moduleGroupName\": \"部署管理\",\n    \"requestMapping\": \"deploy-manage\",\n  },\n  {\n    \"moduleGroupId\": 1100,\n    \"moduleGroupName\": \"系统管理\",\n    \"requestMapping\": \"sys-manage\",\n    \"moduleList\": [\n      {\n        \"moduleId\": 1101,\n        \"moduleName\": \"系统日志\",\n        \"requestMapping\": \"system-log\",\n        \"moduleGroupId\": 1100,\n      },\n      {\n        \"moduleId\": 1102,\n        \"moduleName\": \"系统告警\",\n        \"requestMapping\": \"sys-alert\",\n        \"moduleGroupId\": 1100,\n      },\n    ],\n  }\n]</code></pre> \n<p>（2）然后，根据我们写好的路由数组，进行对比，过滤得到我们要的路由。路由格式在上文“路由定义”的 router/router.js 已经提到。还要根据用户权限处理得到侧边栏菜单。</p> \n<p>为此，我们需要两个处理函数，一个根据用户权限列表和路由数组过滤得到最终路由，另一个根据用户权限处理得到侧边栏菜单。所以另外专门创建了一个文件 handle-module.js 存放这两个函数。</p> \n<pre><code>/* handle-module.js */\nconst handleModule = {\n    /**\n     * 根据后台返回的权限，以及配置好的所有路由，过滤出真实路由\n     * @param  {Array} permissionList 后台返回的用户权限列表\n     * @param  {Array} allRouter  前端配置好的所有动态路由的集合\n     * @return {Array} 过滤后的路由\n     */\n    getRouter(permissionList = [], allRouter = []) {\n        // permissions 的格式为 [\"deploy-manage\", \"system-log\"]\n        let permissions = permissionList.reduce((acc, cur) =&gt; {\n            if (cur.moduleList &amp;&amp; cur.moduleList.length &gt; 0) cur = cur.moduleList;\n            return acc.concat(cur);\n        }, []).map(v =&gt; v.requestMapping);\n\n        return allRouter.filter(item =&gt; permissions.includes(item.meta.permitName));\n    },\n\n    /**\n     * 根据后台返回的权限，生成侧边栏\n     * @param  {Array} permissionList  后台返回的用户权限列表\n     * @return {Array} sidebarMenu  生成的侧边栏数组\n     */\n    getSidebarMenu(permissionList = []) {\n        let sidebarMenu = [];\n        permissionList.forEach(item =&gt; {\n            let menuItem = {\n                name: item.requestMapping,\n                title: item.moduleGroupName,\n            };\n            menuItem.children = (item.moduleList || []).map(child =&gt; ({\n                name: child.requestMapping,\n                title: child.moduleName,\n            }));\n            sidebarMenu.push(menuItem);\n        });\n\n        return sidebarMenu;\n    }\n};\nexport default handleModule;</code></pre> \n<p>（3）上面得到过滤后的路由数组后，加入到 path 为 \'/\' 的 children 下面</p> \n<pre><code>{\n        path: \'/\',\n        name: \'home\',\n        component: () =&gt; import(\'@/views/home.vue\'),\n        meta: {\n            requiresAuth: true,\n        },\n        children: [\n            /* 将上面得到的路由加入到这里 */\n            // 用户信息\n            {\n                path: \'/user-info\',\n                name: \'user-info\',\n                component: () =&gt; import(\'@/views/user-setting/user-info.vue\'),\n            },\n        ]\n}</code></pre> \n<p>（4）上面根据权限生成侧边栏菜单之后，保存在 store 待用。</p> \n<p>（5）上面第三步将动态路由加入到 home 的 children 之后，就可以将 dynamicRoutes 加入到路由中了。<code>router.addRoutes(dynamicRoutes);</code></p> \n<p>（6）到了这里，路由就添加完了，也就是 FETCH_PERMISSION 操作完毕了，就可以在 action.then 里面调用 <code>next({ path: to.path, query: to.query });</code> 进去路由，也就是进入 home。我们上面已经将 home 路由重定向为菜单的第一个路由信息，所以会进入系统菜单的第一个页面。</p> \n<p>刷新页面后，根据 router.beforeEach 的判断，有 token 但是没有 permissionList ，会重新触发 action 去发请求获取用户权限，之前的逻辑会重新走一遍，所以没有问题。</p> \n<p>退出登录后，需要清除 token 并刷新页面。因为是通过 addRoutes 添加路由的，而 vue-router 没有删除路由的 api，所以清除路由、清除 store 中存储的各种信息，刷新页面是最保险的。</p> \n<p>相关文件的目录截图：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGhHX\" src=\"http://localhost:8060/tup/2020/4/23/dac5f7f53abf4c8983a2407817067b1e.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<h2>四、总结</h2> \n<p><strong>缺点：</strong><br>全局路由守卫里，每次路由跳转都要做判断；<br>每次刷新页面，需要重新发请求获取用户权限；<br>退出登录时，需要刷新一次页面将动态添加的路由以及权限信息清空；</p> \n<p><strong>优点：</strong><br>菜单与路由分离，菜单的修改、添加、删除由后端控制，利于后期维护；<br>使用 addRoutes 动态挂载路由，可控制用户不能在 url 输入相关地址进行跳转；</p> \n<p>vue权限管理还有其他实现方式，大家可以根据实际业务考虑做调整，以上的实现方式是比较适合我们现有项目的需求的。以上，有问题欢迎提出交流，喜欢的话点个赞哦~</p>', null, 'http://localhost:8060/tup/2020/4/23/7ccf66fd2b3c474eb068372e3fcf2596.jpg', '692c6787030d4b8882077b2ab9279c52', '049b3bd76c1e49ccbe48b36197e77f76', 'd79254c4ca5e45dca9d484307c935281,b350d9c92c524bb4b9feedd40e5eebcd,158af11aa2cf46f68d722bc26e694541', '0', '3', '1', '2020-04-23 10:26:14', '2020-04-23 10:26:14');
INSERT INTO `tb_recommend` VALUES ('bc7fe0a06e16461da4e607b35e76134e', '聊聊在Go语言里使用继承的翻车经历', 'Go不是面向对象的语言，但是使用组合、嵌套和接口可以支持代码的复用和多态。关于结构体嵌套：外层结构体类型通过匿名嵌套一个已命名的结构体类型后就可以获得匿名成员类型的所有导出成员，而且也获得了该类型导...', '<p><code>Go</code>不是面向对象的语言，但是使用组合、嵌套和接口可以支持代码的复用和多态。关于结构体嵌套：外层结构体类型通过匿名嵌套一个已命名的结构体类型后就可以获得匿名成员类型的所有导出成员，而且也获得了该类型导出的全部的方法。比如下面这个例子：</p> \n<pre><code class=\"go\">type ShapeInterface interface {\n    GetName() string\n}\n\ntype Shape struct {\n    name string\n}\n\nfunc (s *Shape) GetName() string {\n    return s.name\n}\n\ntype Rectangle struct {\n    Shape\n    w, h float64\n}</code></pre> \n<p><code>Shape</code>类型上定义了<code>GetName()</code>方法，而在矩形<code>Rectangle</code>的定义中匿名嵌套了<code>Shape</code>类型从而获得了成员<code>name</code>和成员方法<code>GetName()</code>，同时<code>Rectangle</code>和 <code>Shape</code>一样又都是<code>ShapeInterface</code>接口的实现。</p> \n<p>我一开始以为这和面向对象的继承没有什么区别，把内部结构体看成是父类，通过嵌套一下结构体就能获得父类的方法，而且还能根据需要重写父类的方法，在实际项目编程中我也是这么用的。直到有一天......</p> \n<p>由于我们这很多推广类促销类的需求很多，几乎每月两三次，每季度还有大型推广活动。产品经理也是绞尽脑汁想各种玩法来提高用户活跃和订单量。每次都是前面玩法不一样，但最后都是参与任务得积分啦、分享后抽奖啦。于是乎我就肩负起了设计通用化流程的任务。根据每次需求通用的部分设计了接口和基础的实现类型，同时预留了给子类实现的方法，应对每次不一样的前置条件，这不就是面向对象里经常干的事儿嘛。</p> \n<p>为了好理解我们还是用上面那个<code>ShapeInterface</code>举例子。</p> \n<pre><code class=\"go\">type ShapeInterface interface {\n    Area() float64\n    GetName() string\n    PrintArea()\n}\n\n// 标准形状，它的面积为0.0\ntype Shape struct {\n    name string\n}\n\nfunc (s *Shape) Area() float64 {\n    return 0.0\n}\n\nfunc (s *Shape) GetName() string {\n    return s.name\n}\n\nfunc (s *Shape) PrintArea() {\n    fmt.Printf(\"%s : Area %v\\r\\n\", s.name, s.Area())\n}\n\n// 矩形 : 重新定义了Area方法\ntype Rectangle struct {\n    Shape\n    w, h float64\n}\n\nfunc (r *Rectangle) Area() float64 {\n    return r.w * r.h\n}\n\n// 圆形  : 重新定义 Area 和PrintArea 方法\ntype Circle struct {\n    Shape\n    r float64\n}\n\nfunc (c *Circle) Area() float64 {\n    return c.r * c.r * math.Pi\n}\n\nfunc (c *Circle) PrintArea() {\n    fmt.Printf(\"%s : Area %v\\r\\n\", c.GetName(), c.Area())\n}\n</code></pre> \n<p>我们在<code>ShapeInterface</code>里增加了<code>Area()</code>和<code>PrintArea()</code>方法，因为每种形状计算面积的公式不一样，基础实现类型<code>Shape</code>里的<code>Area</code>只是简单返回了<code>0.0</code>，具体计算面积的任务交给组合<code>Shape</code>类型的<code>Rectange</code>类通过重写<code>Area()</code>方法实现，<code>Rectange</code>通过组合获得了<code>Shape</code>的<code>PrintArea()</code>方法就能打印出它自己的面积来。</p> \n<p>到目前为止，这些还都是我的设想，规划完后自己感觉特兴奋，感觉自己已经掌握了组合（Composition）这种思想的精髓...... 按这个思路我就把整套流程都写完了，单元测试只测了每个子功能，前置条件太复杂加上我还管团队里的其他项目自己的时间不太富余，所以就交付给组里的伙伴们使用了让他们顺便帮我测试下整个流程，然后就现场翻车了......</p> \n<p>我们把上面那个例子运行一下，为了能看出区别，又专门写了一个<code>Circle</code>类型并用这个类型重写了<code>Area()</code>和<code>PrintArea()</code>。</p> \n<pre><code class=\"go\">func main() {\n\n    s := Shape{name: \"Shape\"}\n    c := Circle{Shape: Shape{name: \"Circle\"}, r: 10}\n    r := Rectangle{Shape: Shape{name: \"Rectangle\"}, w: 5, h: 4}\n\n    listshape := []c{&amp;s, &amp;c, &amp;r}\n\n    for _, si := range listshape {\n        si.PrintArea() //!! 猜猜哪个Area()方法会被调用 !! \n    }\n\n}</code></pre> \n<p>运行后的输出结果如下：</p> \n<pre><code>Shape : Area 0\nCircle : Area 314.1592653589793\nRectangle : Area 0</code></pre> \n<p>看出问题来了不，<code>Rectangle</code>通过组合<code>Shape</code>获得的<code>PrintArea()</code>方法并没有去调用<code>Rectangle</code>实现的<code>Area()</code>方法，而是去调用了<code>Shape</code>的<code>Area()</code>方法。<code>Circle</code>是因为自己重写了<code>PrintArea()</code>所以在方法里调用到了自身的<code>Area()</code>。</p> \n<p>在项目里那个类似例子里<code>PrintArea()</code>比这里的复杂很多而且承载着标准化流程的职责，肯定是不能每组合一次自己去实现一遍<code>PrintArea()</code>方法啊，那叫什么设计，而且面子上也说不过去，对吧，好不容易炫一次技，可不能被打脸。</p> \n<p>经过<code>Google</code>上一番搜索后找到了一些详细的解释，上面我们期待的那种行为叫做虚拟方法：期望<code>PrintArea()</code>会去调用重写的<code>Area()</code>。但是在Go语言里没有继承和虚拟方法，<code>Shape.PrintArea()</code>的定义是调用<code>Shape.Area()</code>，<code> Shape</code>不知道它是否被嵌入哪个结构中，因此它无法将方法调用“分派”给虚拟的运行时方法。</p> \n<p><a href=\"http://golang.org/ref/spec#Selectors\" rel=\"nofollow noreferrer\">Go语言规范：选择器</a>里描述了计算<code>x.f</code>表达式（其中<code>f</code>可能是方法）以选择最后要调用的方法时遵循的确切规则。里面的关键点阐述是</p> \n<blockquote>\n <ul> \n  <li>选择器f可以表示类型T的字段或方法f，或者可以引用T的嵌套匿名字段的字段或方法f。遍历到达f的匿名字段的数量称为其在T中的深度。</li> \n  <li>对于类型T或* T的值x（其中T不是指针或接口类型），x.f表示存在f的T中最浅深度的字段或方法。</li> \n </ul>\n</blockquote> \n<p>回到我们的例子中来就是：</p> \n<p>对于<code>Rectangle</code>类型来说<code>si.PrintArea()</code>将调用<code>Shape.PrintArea()</code>因为没有为<code>Rectangle</code>类型定义<code>PrintArea()</code>方法（没有接受者是<code>*Rectangle</code>的<code>PrintArea()</code>方法），而<code>Shape.PrintArea()</code>方法的实现调用的是<code>Shape.Area()</code>而不是<code>Rectangle.Area()</code>-如前面所讨论的，<code>Shape</code>不知道<code>Rectangle</code>的存在。所以会看到输出结果：</p> \n<pre><code>Rectangle : Area 0</code></pre> \n<p>那么既然在<code>Go</code>里不支持继承，如何以组合解决类似的问题呢。我们可以通过定义参数为<code>ShapeInterface</code>接口的方法定义<code>PrintArea</code>。</p> \n<pre><code class=\"go\">func  PrintArea (s ShapeInterface){\n    fmt.Printf(\"Interface =&gt; %s : Area %v\\r\\n\", s.GetName(), s.Area())\n}</code></pre> \n<p>因为并不像例子里的这么简单，后来我的解决方法是定义了一个类似<code>InitShape</code>的方法来完成初始化流程，这里我把<code>ShapeInterface</code>接口和<code>Shape</code>类型做一些调整会更好理解一些。</p> \n<pre><code class=\"go\">type ShapeInterface interface {\n    Area() float64\n    GetName() string\n    SetArea(float64)\n}\ntype Shape struct {\n    name string\n    area float64\n}\n\n...\nfunc (s *Shape) SetArea(area float64) {\n    s.area = area\n}\n\nfunc (s *Shape) PrintArea() {\n    fmt.Printf(\"%s : Area %v\\r\\n\", s.name, s.area)\n}\n...\n\nfunc InitShape(s ShapeInterface) error {\n  area, err := s.Area()\n  if err != nil {\n    return err\n  }\n  s.SetArea(area)\n  ...\n}</code></pre> \n<p>对于<code>Rectangle</code>和<code>Circle</code>这样的组合<code>Shape</code>的类型，只需要按照自己的计算面积的公式实现<code>Area()</code>，<code>SetArea()</code>会把<code>Area()</code>计算出的面积存储在<code>area</code>字段供后面的程序使用。</p> \n<pre><code class=\"go\">type Rectangle struct {\n    Shape\n    w, h float64\n}\n\nfunc (r *Rectangle) Area() float64 {\n    return r.w * r.h\n}\n\nr := &amp;Rectangle {\n    Shape: Shape{name: \"Rectangle\"},\n    w: 5, 4\n}\n\nInitShape(r)\nr.PrintArea()\n</code></pre> \n<p>这个案例也是我使用<code>Go</code>写代码以来第一次研究继承和组合的区别，以及怎么用组合的方式在<code>Go</code>语言里复用代码和提供多态的支持。我觉得很多之前用惯面向对象语言的朋友们或多或少都会遇到同样的问题，毕竟思维定式形成后要靠刻意练习才能打破。由于我不能透漏公司代码的设计，所以以这个简单的例子把这部分的使用经验记录下来分享给大家。读者朋友们在用<code>Go</code>语言设计接口和类型时如果遇到类似问题或者有其他疑问可以在文章下面留言，一起讨论。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbDOyX\" src=\"http://localhost:8060/tup/2020/4/23/22bb2b51a192451c934abc957e1fbfe8.jpg\" alt=\"第1页.png\" title=\"第1页.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/91f8a315bd2d42faa9b722cdd0b9d840.jpg', '692c6787030d4b8882077b2ab9279c52', 'bb0b7e69ad3e46fcb121baefda8f1f78', '50952da4831a49c98a02a58ccc545509,f913584336564c05976ae3797003d1f3,ab8cfc2b4fa94f78beca7b277e36dfd1', '0', '3', '1', '2020-04-23 10:28:35', '2020-04-23 10:28:35');
INSERT INTO `tb_recommend` VALUES ('c39c11cc5a5b4df7a1f32995aacd25c7', '闲鱼Flutter图片框架架构演进（超详细）底部有实战书籍赠送', '图片对一个端侧研发来说是一老生常谈的话题了。闲鱼作为业界在Flutter技术方向上最早一批投入的团队。从使用Flutter之初，图片就是我们核心关注和重点优化的功能。图片算是闲鱼业务场景下最为重要的内容表现形式...', '<p><strong>简介：</strong>flutter图片内存大？加载慢？本地资源利用率低？看这篇就够了</p> \n<p>作者：闲鱼技术-意境</p> \n<h2>1.那些年</h2> \n<p>图片对一个端侧研发来说是一老生常谈的话题了。闲鱼作为业界在Flutter技术方向上最早一批投入的团队。从使用Flutter之初，图片就是我们核心关注和重点优化的功能。图片算是闲鱼业务场景下最为重要的内容表现形式之一。图片展示体验的好坏会对闲鱼用户的使用体验产生巨大影响。你们是否也曾遇到过：</p> \n<ul> \n <li>图片加载内存占用过多？</li> \n <li>使用flutter以后本地资源重复，利用率不高？</li> \n <li>混合方案下Flutter原生图片加载效率不高？</li> \n</ul> \n<p>针对上述问题，从第一版Flutter业务上线开始，闲鱼对图片框架的优化就从未停止。从开始的原生优化，到后面黑科技的外接纹理；从内存占用，到包大小；文本会逐一介绍。希望其中的优化思路和手段，能给大家带去一些启发。</p> \n<h2>2. 原生模式</h2> \n<p>从技术层面看图片加载，其实简单来说，追求的是无非是加载的效率的最大化—用尽可能小的资源成本，尽可能快地加载尽可能多的图片。</p> \n<p>闲鱼图片的第一个版本其实基本上是纯原生的方案。如果你不想魔改很多底层的逻辑，原生方案肯定是最简单和经济的方案。原生方案的功能模块如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312435\" src=\"http://localhost:8060/tup/2020/4/23/e6c14840b412409799da08a27a9e3e79.jpg\" alt=\"原生图片方案的架构图\" title=\"原生图片方案的架构图\"></span></p> \n<p>如果你啥都没做直接上了，那么你可能会发现效果并没有达到你预期的那么美好。那么如果从原生的方案入手，我们有哪些具体的优化手段呢？</p> \n<h3>2.1. 设置图片缓存</h3> \n<p>没错猜对了，是<strong>缓存</strong>。对于图片加载，最能想到的方案就是使用缓存。首先原生Image的组件是支持自定义图片缓存的，具体的实现类是ImageCache。ImageCache的设置维度是两个方向： 1.缓存图片的张数。通过maximumSize设置。默认是1000张。2. 缓存空间的大小。 通过maximumSizeBytes 来设置。默认值100M。相比张数的限制，其实大小的设置方式更加符合我们的最终的预期。</p> \n<p>通过合理设置ImageCache的大小，能充分利用缓存机制加速图片加载。不仅如此，闲鱼在这个点上还做了额外两个重要优化：</p> \n<ol>\n <li>低端手机适配</li>\n</ol> \n<p>在上线以后，我们陆续收到线上舆情的反馈，发现全部机型设置同一个缓存大小的做法并非最优。特别是大缓存设置在低端机器上面，不仅会出现体验变差，甚至还会影响稳定性。基于实际情况，我们实现了一个能从Native侧获取机器基础信息的Flutter 插件。通过获取的信息，我们根据不同手机的配置设置不同的缓存策略。在低端机器上面适当降低图片缓存的大小，同时在高端手机上将其适当放大。这样能在不同配置的手机上获取最优的缓存性能。</p> \n<ol>\n <li>磁盘缓存</li>\n</ol> \n<p>熟悉APP开发的同学都知道，成熟的图片加载框架一般都有多级缓存。除了常见的内存缓存，一般都会配置一个文件缓存。从加载效率上来说，是通过空间换时间，提升加载速度。从稳定性来说，这又不会过分占用宝贵的内存资源，出现OOM。但是可惜的是，Flutter自带的图片加载框架并没有独立的磁盘缓存。所以我们在原生方案的基础上扩展了磁盘缓存能力。</p> \n<p>在具体的架构实现上，我们并没有完全自己撸一个磁盘缓存。我们的策略还是复用现有能力。首先我们将Native图片加载框架的磁盘缓存的功能通过接口暴露出来。然后通过桥接的方式，将Native 磁盘缓存能力嫁接到Flutter层。Flutter侧进行图片加载的时候，如果内存没有命中，就去磁盘缓存中进行二次搜索。如果都没有命中才会走网络请求。</p> \n<p>通过增加磁盘缓存，Flutter图片加载效率进一步提升。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312432\" src=\"http://localhost:8060/tup/2020/4/23/b3ad88fac2a244b5a14c33285622b56a.jpg\" alt=\"多级缓存\" title=\"多级缓存\"></span></p> \n<h3>2.2. 设置CDN优化</h3> \n<p>CDN 优化是另一个非常重要图片优化手段。CDN优化的效率提升主要是：最小化传输图片的大小。常见策略包括：</p> \n<ol>\n <li>根据显示大小裁剪</li>\n</ol> \n<p>简单来说，你要加载图片的真实尺寸，可能会大于你实际展示窗口的大小。那么你就没必要加载完整大图，你只需要加载一个能覆盖窗口大小的图片即可。通过这种方式，裁剪掉不需要的部分，就能最小化传输图片的大小。从端侧角度来说，一来可以提升加载速度，二来可以降低内存占用。</p> \n<ol>\n <li>适当压缩图片大小</li>\n</ol> \n<p>这里主要是根据实际情况增加图片压缩的比例。在不影响显示效果的情况下，通过压缩进一步降低图片的大小。</p> \n<ol>\n <li><strong>图片格式</strong></li>\n</ol> \n<p>建议优先使用webp这样格式，图片资源相对小。Flutter<strong>原生支持webp</strong>（包括动图）。这里特别强调一下webp动图不仅大小要比gif小很多，而且还对<strong>透明效果有更好的支持</strong>。webp动图是gif方案比较理想的一种替代方案。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312434\" src=\"http://localhost:8060/tup/2020/4/23/d86f3dad876a42d9b9a32ca14607a217.jpg\" alt=\"用图演示一下\" title=\"用图演示一下\"></span></p> \n<p>基于上述原因，闲鱼图片框架在Flutter侧实现了一套CDN尺寸匹配的算法。通过该算法，请求图片会根据实际显示的大小，自动匹配到最合适的尺寸上并适当压缩。如果图片格式允许，图片尽可能转化成webp格式下发。这样cdn图片的传输就能尽可能高效。</p> \n<h3>2.3. 其他优化</h3> \n<p>除了上面的策略，Flutter还有一些其他的手段可以优化图片的性能。</p> \n<ol>\n <li><strong>图片预加载</strong></li>\n</ol> \n<p>如果你想在展示的图片的尽可能的快，官方也提供了一套预加载的机制:<strong>precacheImage</strong>。precacheImage能预先将图片加载到内存，真正使用的时候就能秒出了。</p> \n<ol>\n <li><strong>Element复用优化</strong></li>\n</ol> \n<p>其实这个算是一个Flutter通用的优化方案。复写didWidgetUpdate方案，通过比较前后两次widget中针对图片的描述是否一致，来决定是否重新渲染Element。这样能避免同一个图片，不必要的反复渲染。</p> \n<ol>\n <li><strong>长列表优化</strong></li>\n</ol> \n<p>一般情况下，Listview是flutter最为常见的滚动容器。在Listview中的性能好坏，直接影响最终的用户体验。</p> \n<p>Flutter的Listview跟Native的实现思路并不相同。其最大的特点是有一个viewPort的概念。超出viewPort的部分会被强制回收掉。</p> \n<p>基于上述的原理，我们有两点建议：</p> \n<ol>\n <li>cell拆分</li>\n</ol> \n<p>尽量避免大型的cell出现，这样能大幅降低cell频繁创建过程中的性能损耗。其实这里影响的不仅仅是图片加载过程。文字，视频等其他组件也都应该避免cell过于复杂导致的性能问题。</p> \n<ol>\n <li>合理使用缓冲区</li>\n</ol> \n<p>ListView可以通过设置cacheExtent 来设置预先加载的内容大小。通过预先加载可以提升view渲染的速度。但是这个值需要合理设置，并非越大越好。因为预加载缓存越大，对页面整体内存的压力就越大。</p> \n<h3>2.4. 方案的不足</h3> \n<p>这里需要客观指出：如果是一个<strong>纯Flutter APP</strong>，<strong>原生方案是完善，够用的</strong>。但是如果从混合APP的角度来说，有如下两个缺陷：</p> \n<p><strong>1. 无法复用Native图片加载能力</strong></p> \n<p>毫无疑问，原生的图片方案是完全独立的图片加载方案。对于一个混合APP来说，原生方案和Native的图片框架相互独立，能力无法复用。例如CDN裁剪&amp;压缩等能力需要重复建设。特别是Native一些独特的图片解码能力，Flutter就很难使用。这会造成APP范围内的图片格式的支持不统一。</p> \n<p><strong>2. 内存性能不足</strong></p> \n<p>从整个APP的视角来说，采用原生图片方案的情况下，其实我们维护了两个大的缓存池：一个是Native的图片缓存，一个是Flutter侧的图片缓存。<strong>两个缓存无法互通</strong>，这无疑是一个巨大的浪费。特别是对内存的峰值内存性能产生了<strong>非常大的压力</strong>。</p> \n<h2>3. 打通Native</h2> \n<p>经过多轮优化，基于原生的方案已经获得了非常大的性能提升。但是整个APP的内存水位线依然比较高（特别是Ios端）。现实的压力迫使我们继续对图片框架进行更深度的优化。基于上述原生方案缺点的分析，我们有了一个大胆的想法：能否完全复用Native的图片加载能力？</p> \n<h3>3.1. 外接纹理</h3> \n<p>怎样打通Flutter和Native的图片能力？我们想到了外接纹理。外接纹理并非是Flutter自有的技术，他是音视频领域常用的一种性能优化手段。</p> \n<p>这个阶段我们基于shared-Context的方案实现了Flutter和Native的纹理外接。通过该方案，Flutter可以通过共享纹理的方式，拿到Native图片库加载好的图片并展示。为了实现这个纹理共享的通道，我们对engine层做了深度定制。细节过程如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312433\" src=\"http://localhost:8060/tup/2020/4/23/46a9a93515b442189ec2521e7df5c3fc.jpg\" alt=\"\" title=\"\"></span></p> \n<p>该方案不仅打通了Native和Flutter的图片架构，整个过程图片加载的性能也得到了优化。想要了解细节的同学可以继续阅读这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/42566807\" rel=\"nofollow noreferrer\">万万没想到——Flutter外接纹理</a>。</p> \n<p>外接纹理是闲鱼图片方案的一次大跨越。通过该技术，我们不仅实现图片方案的本地能力复用，而且还能实现视频能力的纹理外接。这避免了大量重复的建设，提升了整个APP的性能。</p> \n<h3>3.2. 多页面内存优化</h3> \n<p>这个优化策略是真真被逼出来的。在对线上数据分析以后，我们发现Flutter页面栈有一个非常有意思的特点：</p> \n<p><strong>多页面栈情况下，底层的页面不会被释放</strong>。即便是在内存非常紧张的情况下，也不会执行回收。这样就会导致一个问题：随着页面的增多，内存消耗会线性增长。这里占比最高的就是图片资源的占比了。</p> \n<p>是不是可以在页面处于页面栈底层的时候直接回收掉该页面内的图片呢？</p> \n<p>在这个想法的驱动下，我们对图片架构进行了新一轮的优化。整个图片框架中的图片都会监听页面栈的变化。当方发现自己已经处于非栈顶的时候，就自动回收掉对应的图片纹理释放资源。这种方案能使图片占用的内存大小不会随着页面数的变多呈现持续线性增长。原理如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312437\" src=\"http://localhost:8060/tup/2020/4/23/5ea853e3b1394c27874b2c02107a3a73.jpg\" alt=\"TB1mF0NbZKfxu4jSZPfXXb3dXXa-780-558.png\" title=\"TB1mF0NbZKfxu4jSZPfXXb3dXXa-780-558.png\"></span></p> \n<p>需要注意的是：这个阶段页面判断位置其实是需要页面栈（具体来说就是混合栈）<strong>提供额外的接口</strong>来实现的。系统之间的耦合相对较高。</p> \n<h3>3.3. 意外收获包大小</h3> \n<p>打通Native和Flutter侧图片框架以后，我们发现了一个意外收获: Native和Flutter可以共用本地图片资源了。也就是说，我们不再需要将相同的图片资源在Flutter和Native侧各保留一份了。这样能大幅提升本地资源的复用率，从而降低整体的包大小。基于这个方案，我们实现了一套资源管理的功能，脚本能自动同步不同端的本地图片资源。通过这样提升本地资源利用率，降低包大小。</p> \n<h3>3.4. 其他优化</h3> \n<ol>\n <li><strong>PlaceHolder强化</strong></li>\n</ol> \n<p>原生的Image是没有PlaceHolder功能的。如果想用原生方案的话，需要使用FadeInImage。针对闲鱼的场景我们有很多定制，所以我们自己实现了一套PlaceHolder的机制。</p> \n<p>从核心功能上来说，我们引入了加载状态的概念分为： 1. 未初始化 2. 加载中 3. 加载完成 等。针对不同的状态，可以细粒度的控制PlaceHolder的展示逻辑。</p> \n<h3>3.5. 整体架构</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312436\" src=\"http://localhost:8060/tup/2020/4/23/c0758eeb4186473eada9cb20940aaef3.jpg\" alt=\"\" title=\"\"></span></p> \n<h3>3.6. 方案的不足</h3> \n<ol>\n <li><strong>毕竟改了engine</strong></li>\n</ol> \n<p>随着闲鱼业务的不断推进，engine的升级的成本是我们必须要考虑的事情。能否不改engine实现同样的功能是我们核心的述求。（PS: 我承认我们是贪心的）</p> \n<ol>\n <li><strong>通道性能还有优化空间</strong></li>\n</ol> \n<p>外接纹理的方案需要通过桥的方式跟native的能力做通信。这里包括图片请求的传递和图片加载各种状态的同步。特别是在listview快速滑动的时候，通过桥发送的数据量还是可观的。当前方案每个图片加载时都会单独进行桥的调用。在图片数量比较多的情况下，这显然会是一个瓶颈。</p> \n<ol>\n <li><strong>耦合过多</strong></li>\n</ol> \n<p>在实现图片回收方案的时候，目前方案需要栈提供是否在栈底层的接口。这里就产生方案耦合，很难抽象出一个独立干净的图片加载方案。</p> \n<h2>4. Clean&amp;Efficient</h2> \n<p>时间来到了2020年，随着对Flutter基础能力理解的逐步深入，我们实现了一个整体方案更优的图片框架。</p> \n<h3>4.1. 无侵入外接纹理</h3> \n<p>外接纹理可以不用修改engine么？答案是肯定的。</p> \n<p>其实Flutter是提供了官方的外接纹理方案的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312438\" src=\"http://localhost:8060/tup/2020/4/23/60d7f2a2cbaf4b7586f8551fef581d19.jpg\" alt=\"\" title=\"\"></span></p> \n<p>而且Native操作的texture和Flutter侧显示的texture在底层是同一对象，并<strong>没有产生额外的数据copy</strong>。这样就保证了纹理共享的足够高效。那为什么闲鱼之前会单独基于shared-Context自己实现一套呢？1.12版本之前，官方Ios的外接纹理方案有性能问题。每次渲染的过程中（不管纹理是否有更新）都会频繁获取CVPixelBuffer，造成不必要的性能损耗（过程有加锁损耗）。该问题已经在1.12版本中修复(<a href=\"https://github.com/flutter/flutter/commit/37a4af0ca8148adbda87bcae819ada044c72510d\" rel=\"nofollow noreferrer\">官方commit地址</a>)，这样官方方案也足够满足需求。在这样的背景下，我们重新启用官方方案来实现外接纹理功能。</p> \n<h3>4.2. 独立的内存优化</h3> \n<p>之前提到过，老版本的基于页面栈的图片资源回收需要强依赖栈功能的接口。一方面产生了不必要的依赖，更重要的是，整体方案无法独立成通用方案。为了解决这个问题，我们对Flutter底层进行了深入的研究。我们发现Flutter的layer层可以稳定感知到页面栈的变化。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312439\" src=\"http://localhost:8060/tup/2020/4/23/463e77a24b3c47008768f9b87be9eb33.jpg\" alt=\"TB1bt7AzYr1gK0jSZR0XXbP8XXa-1710-796.png\" title=\"TB1bt7AzYr1gK0jSZR0XXbP8XXa-1710-796.png\"></span></p> \n<p>然后每个页面通过context获取的router对象作为标识对一个页面中的所有的图片对象进行重新组织。所有获取到同一个router对象的标识成同一个页面。这样就能以页面为单位对所有的图片进行管理。整体上通过LRU的算法来模拟虚拟页面栈结构。这样就能对栈底页面的图片资源实现回收了。</p> \n<h3>4.3. 其他优化</h3> \n<p><strong>1. 通道的高度复用</strong></p> \n<p>首先我们以一帧为单位对这一帧中的图片请求进行聚合，然后在一次通道请求中传递给Native的图片加载框架。这样能避免频繁的桥调用。特别在快速滚动等场景下优化效果尤为明显。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312441\" src=\"http://localhost:8060/tup/2020/4/23/29077bf019284514bb836fb6591e8954.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>2. 高效的纹理复用</strong></p> \n<p>使用外接纹理进行图片加载以后，我们发现复用纹理可以进一步提升性能。举一个简单的场景。我们知道电商场景中，商品展示经常会有标签，打底图这样的图片。这类图片往往在不同的商品上会出现大量重复。这时候，可以将已经渲染好的纹理，直接复用给不同的显示组件。这样能进一步优化GPU内存的占用，避免重复创建。为了精确对纹理进行管理，我们引入了引用计数的算法来管理纹理的复用。通过这些方案，我们实现了纹理跨页面高效复用。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312440\" src=\"http://localhost:8060/tup/2020/4/23/db1ca6e2e4a345f4a7a3cd20bc0db3a0.jpg\" alt=\"\" title=\"\"></span></p> \n<p>此外，我们将纹理和请求的映射关系移动到了Flutter侧。这样能在最短路径上完成纹理的复用，进一步减少了桥的通信的压力。</p> \n<h3>4.5. 整体架构</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312442\" src=\"http://localhost:8060/tup/2020/4/23/ec9a9f613e3548a0be0f2ed8d2c34a31.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>5. 优化效果</h2> \n<p>由于最新的版本目前还在灰度，具体数据后续会写文跟大家详细介绍。下属数据主要以<strong>方案二为主</strong>。</p> \n<ul>\n <li> <p>内存优化</p> \n  <ul> \n   <li>通过打通Native，相比于首次上线版本，在显示效果不变的情况下，Ios的abort率<strong>降低25%</strong>，用户体验明显提升。</li> \n   <li>多页面栈内存优化</li> \n  </ul> </li>\n</ul> \n<pre><code>多页面栈的内存优化，在多页面场景下对内存优化作用明显。我们做了一个极限试验效果如下：(**测试环境**，非闲鱼APP)\n\n</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312443\" src=\"http://localhost:8060/tup/2020/4/23/0fe512faffad44f5aa9a74462333e832.jpg\" alt=\"TB1IK58AG61gK0jSZFlXXXDKFXa-868-473.png\" title=\"TB1IK58AG61gK0jSZFlXXXDKFXa-868-473.png\"></span></p> \n<p>​ 可见多页面栈的优化，可以将多Flutter页面的内存占用控制得更好。</p> \n<ul>\n <li>包大小减少</li>\n</ul> \n<p>通过接入外接纹理，本地资源得到了更好的复用，包大小<strong>降低1M</strong>。早期闲鱼接入Flutter，会以改造现有页面为切入点。资源重复情况比较严重，但是随着闲鱼Flutter 新业务越来越多。Flutter和Native的重复资源越来越少。外接纹理对包大小的影响已经逐步变弱。</p> \n<h2>6. 总结</h2> \n<p>本文介绍了闲鱼在Flutter图片框架方向上所做的持续优化。介绍了闲鱼不同时期，典型的图片技术方案的细节。希望可以给到读者一些启发。这是一场没有尽头的旅行，我们对闲鱼图片的优化还会持续。特别是我们最新的方案，受限篇幅，本文只是做了初步介绍。更多技术细节，包括测试数据，我们随后还会专门写文继续给大家做介绍。方案完善以后，我们也会逐步开源。</p> \n<h6> <strong>更多相关内容：</strong><a href=\"https://developer.aliyun.com/article/753993?utm_content=g_1000111457\" rel=\"nofollow noreferrer\"><strong>点击这里</strong></a>​</h6> \n<h5>福利：</h5> \n<h6>1.<a href=\"https://developer.aliyun.com/article/754410?utm\" rel=\"nofollow noreferrer\">点击这里</a>（电子书）</h6> \n<h6>2.<a href=\"https://weibo.com/3089100571/IDqvbue7y?ref=home&amp;type=comment#_rnd1586928793185\" rel=\"nofollow noreferrer\">点击这里</a>（实物书以及闲鱼周边）</h6>', null, 'http://localhost:8060/tup/2020/4/23/2d30820d63d140fbada0ef2020fc60bd.jpg', '692c6787030d4b8882077b2ab9279c52', '7b3e40f8b9cc4b7780dc39a71d7f580e', '85ee959b27f74072b13cc763b9bbf77e,3b375646301546259a8fb29d74ae4447,14ab12176ade47da95ba97d7151eb1f9', '0', '3', '1', '2020-04-23 10:30:06', '2020-04-23 10:30:06');
INSERT INTO `tb_recommend` VALUES ('c4512b7109c542e3a7889bdf43aec570', '如何打造应对超大流量的高性能负载均衡？', '什么是负载均衡呢?用户输入的流量通过负载均衡器按照某种负载均衡算法把流量均匀地分散到后端的多个服务器上，接收到请求的服务器可以独立的响应请求，达到负载分担的目的。从应用场景上来说，常见的负载均衡模型...', '<p><strong>负载均衡</strong></p> \n<p>负载均衡是云计算的基础组件，是网络流量的入口，其重要性不言而喻。</p> \n<p>什么是负载均衡呢?用户输入的流量通过负载均衡器按照某种负载均衡算法把流量均匀地分散到后端的多个服务器上，接收到请求的服务器可以独立的响应请求，达到负载分担的目的。从应用场景上来说，常见的负载均衡模型有全局负载均衡和集群内负载均衡，从产品形态角度来说，又可以分为硬件负载均衡和软件负载均衡。</p> \n<p>全局负载均衡一般通过DNS实现，通过将一个域名解析到不同VIP，来实现不同的region调度能力;硬件负载均衡器常见的有F5、A10、Array，它们的优缺点都比较明显，优点是功能强大，有专门的售后服务团队，性能比较好，缺点是缺少定制的灵活性，维护成本较高;现在的互联网更多的思路是通过软件负载均衡来实现，这样可以满足各种定制化需求，常见的软件负载均衡有LVS、Nginx、Haproxy。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022416047\" src=\"http://localhost:8060/tup/2020/4/23/a3df3556c579465da4cd4dce6a1d4482.jpg\" alt=\"\" title=\"\"></span></p> \n<p>我们的高性能负载均衡使用LVS和Tengine，在一个region区分不同的机房，每个机房都有LVS集群和Tengine集群，对于用户配置的四层监听，LVS后面会直接挂载用户ECS，七层用户监听ECS则挂载在Tengine上，四层监听的流量直接由LVS转发到ECS，而7层监听的流量会经过LVS到Tenigine再到用户ECS。每一个region里都会有多个可用区，达到主备容灾目的，每一个集群里都有多台设备，第一是为了提升性能，第二也是基于容灾考虑。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022416046\" src=\"http://localhost:8060/tup/2020/4/23/49eb3ef979114e62bae50144be1d0f9b.jpg\" alt=\"\" title=\"\"></span></p> \n<p>上图为高性能负载均衡控制管理概要图，SLB产品也有SDN概念，转发和控制是分离的，用户所有配置通过控制台先到控制器，通过集中控制器转换将用户配置推送到不同设备上，每台设备上都有Agent接收控制器下发的需求，通过本地转换成LVS和Tengine能够识别的配置，这个过程支持热配置，不影响用户转发，不需要reload才能使新配置生效。</p> \n<p><strong>LVS</strong></p> \n<p><strong>1. LVS支持的三种模式</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022416048\" src=\"http://localhost:8060/tup/2020/4/23/3c8730fc0db34107b10d510161b9eeb1.jpg\" alt=\"\" title=\"\"></span></p> \n<p>早期LVS支持三种模式，DR模式、TUN模式和NAT模式。</p> \n<p>DR模式经过LVS之后，LVS会将MAC地址更改、封装MAC头，内层IP报文不动，报文经过LVS负载均衡查找到RS之后，将源MAC头改成自己的，目的MAC改成RS地址，MAC寻址是在二层网络里，对网络部署有一定的限定，在大规模分布式集群部署里，这种模式的灵活性没有办法满足需求;</p> \n<p>TUN模式走在LVS之后，LVS会在原有报文基础上封装IP头，到了后端RS之后，RS需要解开IP报文封装，才能拿到原始报文，不管是DR模式还是TUN模式，后端RS都可以看到真实客户源IP，目的IP是自己的VIP，VIP在RS设备上需要配置，这样可以直接绕过LVS返回给用户，TUN模式问题在于需要在后端ECS上配置解封装模块，在Linux上已经支持这种模块，但是windows上还没有提供支持，所以会对用户系统镜像选择有限定。</p> \n<p>NAT模式用户访问的是VIP，LVS查找完后会将目的IP做DNAT转换，选择出RS地址，因为客户端的IP没变，在回包的时候直接向公网真实客户端IP去路由，NAT的约束是因为LVS做了DNAT转换，所以回包需要走LVS，把报文头转换回去，由于ECS看到的是客户端真实的源地址，我们需要在用户ECS上配置路由，将到ECS的默认路由指向LVS上，这对用户场景也做了限制。</p> \n<p><strong>2. LVS基于Netfilter框架实现</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022416049\" src=\"http://localhost:8060/tup/2020/4/23/4df471d0e2a344d1a683c954773db5ee.jpg\" alt=\"\" title=\"\"></span></p> \n<p>Netfilter是Linux提供的网络开放平台，基于平台可以开发自己的业务功能模块，早期好多安全厂商都是基于Netfilter做一些业务模型实现，这种模型比较灵活，但通用模型里更多的是兼容性考虑，路径会非常长;而且通用模型中没办法发挥多核特性，目前CPU的发展更多是向横向扩展，我们经常见到多路服务器，每路上有多少核，早期通用模型对多核支持并不是特别友善，在多核设计上有些欠缺，导致我们在通用模型上做一些应用开发时的扩展性是有限的，随着核的数量越来越多，性能不增反降。</p> \n<p><strong>3. LVS的改进</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022416051\" src=\"http://localhost:8060/tup/2020/4/23/a2b5499cd2764da48fce14803eb36a82.jpg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li>早期模式的各种限制制约了我们的发展，所以我们首先做了FullNAT，相比原来的NAT方式，FullNAT多了SNAT属性，将客户端的原IP地址作了转换;</li> \n <li>其次，我们在并行化上做了处理，充分利用多核实现性能线性提升;</li> \n <li>然后是快速路径，我们在做网络转发模型时很容易想到设计快速路径和慢速路径，慢速路径更多是解决首包如何通过设备问题，可能需要查ACL或路由，需要判断许多和策略相关的东西，后面所有报文都可以通过快速路径转发出去;</li> \n <li>还有指令相关优化，利用因特尔特殊指令提升性能;</li> \n <li>另外针对多核架构，NUMA多节点内存访问，通过访问Local节点内存可能获得更好的延迟表现。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022416050\" src=\"http://localhost:8060/tup/2020/4/23/0e3d6c08e76242a1a02f398858c1b05b.jpg\" alt=\"\" title=\"\"></span></p> \n<p>客户端进来IP首先访问LVS的VIP，原IP是客户端的，目的IP是LVS的VIP，经过FullNAT转换后，原IP变成LVS的Local地址，目的地址是LVS选择出来的RS地址，这样在RS回包时比较容易，只要路由可达，报文一定会交到LVS上，不需要在RS上做特殊的配置。右面就是DNAT+SNAT转换，报文就可以通过LVS转发回客户端，这种方式主要带来应用场景部署灵活性选择。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022416052\" src=\"http://localhost:8060/tup/2020/4/23/e25ff8fc9a95465986d5a99c726b6c72.jpg\" alt=\"\" title=\"\"></span></p> \n<p>通过并行化实现对LVS性能的改善，性能没有办法得到线性提升更多的是因为每条路径都需要访问全局资源，就会不可避免引入锁的开箱，另外，同一条链接上的报文可能分散在不同的核上，大家去访问全局资源时也会导致cache的丢失。</p> \n<p>所以我们通过RSS技术把同一个五源组报文扔到同一个CPU上处理，保证入方向的所有相同连接上的报文都能交给相同CPU处理，每个核在转发出去时都用当前CPU上的Local地址，通过设置一些fdir规则，报文回来时后端RS访问的目的地址就是对应CPU上的local地址，可以交到指定的CPU上去处理，这样一条连接上左右方向报文都可以交给同一个CPU处理，将流在不同的CPU隔离开。</p> \n<p>另外，我们把所有配置资源包括动态缓存资源在每个CPU上作了拷贝， 将资源局部化，这使整个流从进入LVS到转发出去访问的资源都是固定在一个核上的本地资源，使性能达到较大化，实现线性提升。</p> \n<p>经过我们改进之后，LVS的具体表现如下：</p> \n<ul> \n <li>出于对容灾和性能提升的考虑，我们做了集群化部署，每个region有不同机房，每个机房有多个调度单元，每个单元有多台LVS设备;</li> \n <li>每台LVS经过优化后，都能达到更高性能，大容量，单台LVS可以达到4000W PPS，600W CPS、单个group可以到达1亿并发;</li> \n <li>支持region、IDC、集群和应用级的高可用;</li> \n <li>实现了防×××功能，并在原版LVS上提供了更丰富的功能，可以基于各个维度做管理控制，较精确的统计，流量的分析等。</li> \n</ul> \n<p><strong>Tengine</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022416053\" src=\"http://localhost:8060/tup/2020/4/23/86af8924ca5f403c88d176fae51ccb98.jpg\" alt=\"\" title=\"\"></span></p> \n<p>Tengine在应用过程中也遇到了各种问题，最严重的就是性能问题，我们发现随着CPU数量越来越多，QPS值并没有线性提升;Nginx本身是多worker模型，每个worker是单进程模式，多worker架构做CPU亲和，内部基于事件驱动的模型，其本身已经提供了很高的性能，单核Nginx可以跑到1W5～2W QPS。Nginx往下第一层是socket API，socket 往下有一层VFS，再往下是TCP、IP，socket层比较薄，经过量化的分析和评估，性能开销较大的是TCP协议栈和VFS部分，因为同步开销大，我们发现横向扩展不行，对此，我们做了一些优化。</p> \n<p>七层反向代理的路径更长，处理更复杂，所以它的性能比LVS低很多，我们比较关注单机和集群的性能，集群性能可以靠堆设备去解决，单机如果不提升，成本会一直增加，从性能角度来看，有以下的优化思路和方向：</p> \n<ul> \n <li>基于Kernel做开发，比如优化协议栈;</li> \n <li>基于Aliscoket的优化，Alisocket是阿里研发的高性能TCP协议栈平台，底层是DPDK，它将资源做了局部化处理，报文分发不同核处理，性能非常出色;</li> \n <li>HTTPS业务越来越多，流量逐步递增，我们采用硬件加速卡方式做一些加解密的性能提升，还有HTTPS的会话复用;</li> \n <li>基于Web传输层的性能优化。</li> \n</ul> \n<p>从弹性角度看，比如一些公司的应用和用户热点有关，当发生一个社会网络热点后，访问量会急剧变高，我们固有的基于物理机器实现的负载均衡模型在弹性扩展方面是有限制的，对此，我们可以使用VM去做，把反向代理功能放在VM去跑，我们会监控实例负载情况，根据实时需求做弹性扩容缩容;</p> \n<p>除了VM，还有调度单元，我们可以在不同调度单元做平滑切换，根据不同的水位情况，通过切换可以把负载均衡实例调度到不同的单元中去，改善使容量上管理。Tengine本身也做了集群化部署，我们在一个region里有不同的机房，不同的调度单元，每个调度单元有多组设备;LVS到Tengine也有健康检查，如果一台Tengine有问题，可以通过健康检查方式摘除，不会影响用户转发能力;</p> \n<p>Tengine具备灵活的调度能力，可以帮助我们应对更多的复杂情况;另外，Tengine也有很多高级的特性，比如基于cookie的会话保持、基于域名/URL的转发规则、HTTP2、Websocket等功能;目前，我们7层单VIP可以支撑10W规格的HTTPS QPS。</p> \n<p><strong>高可用</strong></p> \n<p><strong>1. Group</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022416055\" src=\"http://localhost:8060/tup/2020/4/23/860e3301d445436383f01542dbca6fd5.jpg\" alt=\"\" title=\"\"></span></p> \n<p>高可用是整个产品很重要的一部分，图为集群内的高可用架构图，可以看到，在网络路径上是全冗余无单点的。具体情况如下：</p> \n<ul> \n <li>双路服务器，每节点双网口上联不同交换机，增加带宽，避免跨节点收包</li> \n <li>VIP路由两边发不同的优先级，不同的VIP，高优先级路由在不同的交换机上</li> \n <li>单机160G转发能力，单VIP 80G带宽，单流 40G带宽</li> \n <li>网卡故障不影响转发，上下游路由自动切换</li> \n <li>ECMP，VIP路由发两边，通过优先级控制从入口</li> \n <li>集群640G转发能力，单vip 320G带宽</li> \n <li>会话同步，多播、包触发同步、定时同步</li> \n <li>单机故障不影响转发</li> \n <li>交换机故障不影响转发，路由秒级切换</li> \n <li>用户无感知的升级变更，部分未及时同步的连接重连即可</li> \n</ul> \n<p><strong>2. AZ</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022416054\" src=\"http://localhost:8060/tup/2020/4/23/93c00ea92f974a8f96b0907ce4212fc8.jpg\" alt=\"\" title=\"\"></span></p> \n<p>每个机房连接两个不同路由器，当一个AZ出现故障之后，我们可以无缝切换到另外一个机房，具体情况如下：</p> \n<ul> \n <li>VIP在不同的AZ发不同优先级的路由(秒级切换、自动切换)</li> \n <li>VIP区分主备AZ，不同的VIP主备AZ不同</li> \n <li>多个AZ的负载通过控制系统分配</li> \n <li>缺省提供VIP多AZ的容灾能力</li> \n <li>不支持跨AZ的session同步，跨AZ切换后，所有连接都需要重连</li> \n</ul> \n<p><strong>3. Region</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022416056\" src=\"http://localhost:8060/tup/2020/4/23/1140530aefc74e229aa5a5e2ccfc047b.jpg\" alt=\"\" title=\"\"></span></p> \n<p>当用户访问域名时，通过DNS解析，可以设定DNS解析到多个regionVIP地址，下沉到某一个Region来看，如果一个机房出现故障，流量可以切换到另一个可用区继续转发，如果流量进到机房发现一台LVS转发设备出现故障后，我们可以切换到另外一台LVS作处理，如果LVS后面挂载的RS出现问题，通过健康检查也可以快速摘掉设备，将流量转换到健康的设备上去。我们从多个维度实现高可用，较大限度地满足用户的需求。</p> \n<p><strong>总结</strong></p> \n<p>目前，高性能负载均衡应用主要在几个方面：</p> \n<ul> \n <li>作为公有云基础组件，为公有云网站、游戏客户、APP提供负载均衡功能，也针对政府、金融等安全性高的客户提供专有云支持;</li> \n <li>为阿里云内部云产品RDS、OSS、高防等提供了负载均衡的功能;</li> \n <li>负载均衡作为电商平台入口，向淘宝、天猫、1688提供VIP统一接入功能;</li> \n <li>交易平台的流量入口也在负载均衡设备上，如支付宝、网上银行。</li> \n</ul> \n<p>未来，我们希望有更好的弹性扩展能力，更高的单机处理能力，我们希望VIP主动探测用户，以及网络全链路监控。</p> \n<p>文章收集整理于网络资料</p>', null, 'http://localhost:8060/tup/2020/4/23/02b68b04abdc44238a9325b9a3f31bc7.jpg', '5ca4567d892841b087fac5246effac40', '91832bd0c3a244fb88c0bca74c0d404d', '55723db96b9f4593bae02bc1e49f1e87,d7416e100af54eb7a4d9274b9a462240,753b5aee3913424e81fe2b5299626d8c,77a7bd638e0a45ec84569ef6b79325c1,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-23 11:01:19', '2020-04-23 11:01:19');
INSERT INTO `tb_recommend` VALUES ('c4ef318262014d6288e3b1cbd75bc722', '惊讶大反转！黑客成功盗取 dFroce 2500 万美元后全部归还', '据外媒消息 dForce 上将近 2500 万美元的资产被盗取，不过随后黑客向dForce 归还了几乎所有资金，除了由于转换费而损失的120万美元。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGixB\" src=\"http://localhost:8060/tup/2020/4/23/36656789c83748e481d320885ddbdb38.jpg\" alt=\"dForce.png\" title=\"dForce.png\"></span></p> \n<p><strong>技术编辑：宗恩丨发自 SiFou NewOffice</strong> <br><strong>SegmentFault 思否报道丨公众号：SegmentFault</strong></p> \n<hr> \n<p>据外媒消息 dForce 上将近 2500 万美元的资产被盗取，不过随后黑客向dForce 归还了几乎所有资金，除了由于转换费而损失的120万美元。</p> \n<p>dForce 是一个基于区块链的去中心化金融（DeFi）和货币协议平台，为开放式金融应用程序提供底层基础设施。支持多资产的活期存款和即时贷款，基于市场供求情况动态调节利息。</p> \n<h2>事件经过</h2> \n<p>dForce 创始人杨民道 4 月 19 日凌晨于 Medium 发文表示，黑客利用 imBTC 的 ERC777 合约漏洞来实现重入攻击，Lendf.Me 损失了大约 2500 万美元。</p> \n<p>4 月 20 日，基于黑客在攻击前后留下的痕迹，安全团队成功确定了准确的黑客画像，并开始与国内外各方资源进行交叉对比，获得突破性线索，离黑客越来越近。</p> \n<p>4 月 21 日 13 点 33 分，黑客在重重压力下，与 dForce 主动沟通，并开始归还部分资产。继续沟通后，所有资产被成功找回。</p> \n<p>22 日更新的博文中，dForce 创始人杨民道写道：</p> \n<p>我欣慰地报告说，通过我们的合作伙伴、执法部门、投资者、社区和团队成员的共同努力，几乎所有被盗资金都被收回。目前相关工作还在进行当中，因此无法提供更多的细节。但我会在未来的帖子中肯定会更新的。</p> \n<p>The Block 研究总监 Larry Cerma k 做了一份黑客归还资产的详细统计：</p> \n<p>57,992个 ETH （约合1011万美元），252.347个imBTC（约合403万美元），425.62 个MKR（约合13.15万美元），5178.2 个LINK（约合1.849万美元），39968.3 个KNC（约合1.843万美元），110383.27个 BAT（约合1.768万美元），1817.7个HT（约合6780美元），38180个 LEND（约合1020美元）以及含USDT、DAI、PAX等在内的稳定币总计946万美元。返还资产总计2380万美元，低于被盗时的约2500万美元，这可能与市场下跌有关。</p>', null, 'http://localhost:8060/tup/2020/4/23/91ed117ac6674fc09e90ef2a95babd76.jpg', '692c6787030d4b8882077b2ab9279c52', '3798854967b444e0b8156e5154f94b97', '7937aecb2ef543908ed511c9d5abceb3', '0', '3', '1', '2020-04-23 10:58:52', '2020-04-23 10:58:52');
INSERT INTO `tb_recommend` VALUES ('c63a6058af9f4e6d9b1e6126b1463485', '第五期：如何通过知晓云生成带参数二维码', '作者：知晓云 - 小程序开发快人一步来源：知晓课堂 许多小程序开发者，都需要获取进入小程序不同页面的二维码：包括常见的四方形「QR 码」和微信推出的「小程序码」。 这时候，我们直接在小程序后台中获取到的二...', '<p>作者：<a href=\"https://cloud.minapp.com/?utm_source=segmentfault&amp;utm_medium=article_footer&amp;utm_term=\" rel=\"nofollow noreferrer\">知晓云</a> - 小程序开发快人一步<br>来源：知晓课堂</p> \n<p>许多小程序开发者，都需要获取进入小程序不同页面的二维码：包括常见的四方形「QR 码」和微信推出的「小程序码」。</p> \n<p>这时候，我们直接在小程序后台中获取到的二维码，就远远无法满足我们以上需求了。贴心的是，<strong>微信提供了「获取小程序二维码」的接口</strong>。</p> \n<p>通过这个接口，<strong>商家和开发者能够制作进入不同页面的小程序二维码，而不会限定扫码进入小程序主页</strong>。</p> \n<p>下面，我们就以某游戏资料库小程序的英雄详情页为例，展示这个接口的使用方法。</p> \n<h3>准备工作</h3> \n<p>首先，<strong>我们需要确保在小程序的</strong><code>app.json</code><strong>代码中，已经注册了相应的页面</strong>。</p> \n<p>在本例的设定中，我们就需要在<code>pages</code>里，将<code>pages/detail/hero/hero</code>这个页面注册进去。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383418\" src=\"http://localhost:8060/tup/2020/4/23/b372447bff2042f2aa18f12bfa17f194.jpg\" alt=\"\" title=\"\"></span></p> \n<p>当然，相应目录下也需要有相应的页面文件，且你的小程序已经有已发布的线上版本。否则，用户扫码后，微信会提示出错。</p> \n<p><strong>接下来，我们需要到微信小程序后台，获取小程序的 AppSecret</strong>（如果已经获取，这一步可以跳过）。</p> \n<p>进入小程序后台，点击左侧「设置」，找到「开发设置」，我们就能找到 AppSecret 一项。点击「获取」或「重置」，扫码之后，网页就会显示新的 AppSecret。需要注意的是，如果你之前生成过新的 AppSecret，那么旧的 AppSecret 会随这个操作而失效。</p> \n<p><strong>开发者也需要记得妥善保管 AppSecret，尽可能保证 AppSecret 不会丢失、泄漏。</strong></p> \n<h3>获取二维码</h3> \n<p>有了小程序的 AppID 和 AppSecret，我们就能利用服务器，获取小程序的二维码了。在本例，我们通过模拟请求的方式，让大家了解这个接口的使用方法和原理。</p> \n<p>首先，<strong>我们要利用 AppID 和 AppSecret，获取 Access Token</strong>。</p> \n<p>这一步，我们请求的地址是<code>https://api.weixin.qq.com/cgi-bin/token</code>，你需要使用<code>GET</code>方法，传递你的 AppID 和 AppSecret。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383421\" src=\"http://localhost:8060/tup/2020/4/23/59eb877b48a94b91ae6dd268eae407e3.jpg\" alt=\"\" title=\"\"></span></p> \n<p>从结果中，我们可以得知：执行这个操作后，微信会给你返回一个 JSON 数据包。<strong>解析这个数据包，我们就可以获得 Access Token。</strong></p> \n<p>有了 Access Token，我们就可以获取不同的小程序二维码了。</p> \n<p><strong>微信提供了两个</strong><code>POST</code><strong>&nbsp;获取小程序二维码的接口。</strong>你可以根据你的业务需求，自由选择任一接口，获取相应的小程序二维码（<code>GET</code>参数中的<code>ACCESS_TOKEN</code>部分填入上一步我们获取到的 Access Token）。</p> \n<ul> \n <li>获取「小程序码」，可以使用这个接口：<p><code>https://api.weixin.qq.com/wxa/getwxacode?access_token=ACCESS_TOKEN</code></p> </li> \n <li>想要经典的「小程序二维码」，可以使用这个接口：<p><code>https://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode?access_token=ACCESS_TOKEN</code></p> </li> \n</ul> \n<p><code>POST</code><strong>请求体中，需要包含小程序的页面地址，以及传入小程序的参数。</strong>记住，这个页面必须要在小程序里的<code>app.json</code>进行注册。</p> \n<p>本例中，JSON 请求体如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383419\" src=\"http://localhost:8060/tup/2020/4/23/95b8512b42d34f468a46e5436dc49725.jpg\" alt=\"\" title=\"\"></span></p> \n<p>发送请求后，微信会直接返回一张制作好的「小程序码」。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383420\" src=\"http://localhost:8060/tup/2020/4/23/513fa83accd34749ba5b07e9a54e5c5e.jpg\" alt=\"\" title=\"\"></span></p> \n<p>现在，长按上图扫一扫，看看是不是到了指定页面了？</p> \n<h3>注意事项</h3> \n<p>除了我们文中举例的接口，微信还开放了另一个与二维码相关的接口，即&nbsp;wxacodeunlimit&nbsp;来获取小程序码。（数量不限；但无法携带参数）</p> \n<p><strong>微信将通过「获取小程序二维码」接口获取的二维码的数量限定在十万个</strong>，并且似乎并没有「注销以前生成的二维码」的功能和机制。</p> \n<p>所以，如果你有非常大量的小程序二维码生成需求，建议使用普通链接小程序的方式生成小程序码。如果需要使用微信提供的二维码生成接口生成<strong>带参数的小程序码</strong>，也要注意不要超过限额。</p> \n<h3>更便捷的方式</h3> \n<p>知晓云 JS SDK 将上面的实现过程进行了封装，一个接口就可以实现上文提到的三种获取方式（知晓云还会帮你存储管理 Access Token）。该接口为：</p> \n<p>wx.BaaS.getWXACode(type, params)</p> \n<p>接口中&nbsp;type&nbsp;的三种类型</p> \n<ul> \n <li>wxacode&nbsp;：获取小程序码，适用于需要的码数量较少的场景，生成的码永久有效，数量有限</li> \n <li>wxacodeunlimit：获取小程序码，适用于需要的码数量极多的业务场景，生成的码永久有效，数量暂无限制</li> \n <li>xaqrcode：获取小程序二维码，该接口生成的码永久有效，数量有限 <br> params 对应了微信获取二维码的参数，详情请查阅知晓云 SDK 文档</li> \n</ul> \n<p>注意，该接口不需要再传入 Access Token，但在调用前需要提前确保：</p> \n<ul> \n <li>在知晓云「设置」-&gt;SDK 页面中开启了 SDK 生成小程序码的权限</li> \n <li>知晓云「设置」-&gt;小程序页面中已经配置好了 AppID 和 AppSecret</li> \n</ul> \n<p><strong>PS：知晓云后台自带二维码生成功能，无需开发也能快速获取进入小程序不同页面的二维码。</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF46a\" src=\"http://localhost:8060/tup/2020/4/23/bcb8db93eea4453fabbcb3db671b29b9.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<blockquote>\n <strong>相关阅读</strong>\n</blockquote> \n<p>第一期：<a href=\"https://segmentfault.com/a/1190000021767822\">快速实现图片爬虫</a><br>第二期：<a href=\"https://segmentfault.com/a/1190000021770283\">快速生成分享海报</a><br>第三期：<a href=\"https://segmentfault.com/a/1190000022146396\">处理微信卡券消息</a><br>第四期：<a href=\"https://segmentfault.com/a/1190000022160584\">自动回复客服消息</a></p> \n<p>关注「知晓云」公众号，点击菜单栏「知晓云」-「知晓课堂」，获取更多开发教程。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022146422\" src=\"http://localhost:8060/tup/2020/4/23/20a91084cf82496d8cd2bdd249000f8a.jpg\" alt=\"\" title=\"\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/0ce2285e819a4dd48556ceb039dec2c1.jpg', '1c5851dc916d4e70a60f0c957f548876', '7b3e40f8b9cc4b7780dc39a71d7f580e', '63c4e1e7ec204b43a62065a3ced4c2ce,3b375646301546259a8fb29d74ae4447,15941dc0af92453481b8a0626f963283,f831bc1c03f94b4b9e49390a3a354a3e', '0', '3', '1', '2020-04-23 10:29:55', '2020-04-23 10:29:55');
INSERT INTO `tb_recommend` VALUES ('c814a79b498c4b8e8004986eb788746c', 'Gartner 发布 2020 年公共云容器报告，阿里云与 AWS 并列成全球容器产品最完善云服务商', '近日，国际知名调研机构 Gartner 发布 2020 年公共云容器报告。该报告评选标准严格，需要在 Serverless 容器、服务网格、安全沙箱容器、混合云和边缘等 10 个产品维度对云厂商进行考核。', '<p>近日，国际知名调研机构 Gartner 发布 2020 年公共云容器报告。该报告评选标准严格，需要在 Serverless 容器、服务网格、安全沙箱容器、混合云和边缘等 10 个产品维度对云厂商进行考核。</p> \n<p>根据此次报告结果显示，阿里云和 AWS 拥有最丰富的产品布局，覆盖了 9 项产品能力，领先谷歌、微软及 IBM 等企业。此外，阿里云也连续两年成为唯一入选的中国企业。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyDn\" src=\"http://localhost:8060/tup/2020/4/23/ef47aa7f6d73457fa79df601e753694a.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>Gartner 报告指出，企业使用容器技术是大势所趋，主流云服务商都在布局无服务化容器、混合云、安全和自动化 DevOps 等容器相关领域。</p> \n<hr> \n<p>阿里云是国内最早布局容器技术的公司之一，其容器服务经历了阿里巴巴集团内部业务场景十余年的淬炼，并衍生了一系列产品服务，已在全球 19 个公共云可用区开服，服务规模增速连续多年超 400%，支撑上万个集群、数百万容器。</p> \n<p>Gartner 分析师认为，“阿里云拥有丰富的容器产品形态，在中国市场表现强劲，并在上述产品领域具备良好的技术发展策略。”</p> \n<p>近日，斯坦福大学公布的 DAWNBench 深度学习榜单中，阿里云同样表现优异，在最新的Image Classification on ImageNet图像识别榜单中，阿里云一举包揽了训练时间、训练成本、推理延迟、推理成本四项第一，打破了Google等保持了一年多的纪录。</p> \n<blockquote> \n <strong>Gartner 报告地址：</strong>\n <br>\n <a href=\"https://www.gartner.com/en/documents/3982527/competitive-landscape-public-cloud-container-services\" rel=\"nofollow noreferrer\">https://www.gartner.com/en/do...</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFxVM\" src=\"http://localhost:8060/tup/2020/4/23/7dc39d5da8a94e2ca19fbb0bcc5287e0.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/81daf0c5649640d7a0ae167ae20394bc.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', 'b299a2a48cd64e77a3431ce958b42055', '69a24148dd3149e49273bc7d178fa7bc,50b1ead18a154fb9a3be3ed4bc61398b,0f2596e8a00f4ed58d2b4e47f674a118,ba16f5b739f24380990a4ccacfe6f833,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-23 10:56:17', '2020-04-23 10:56:17');
INSERT INTO `tb_recommend` VALUES ('c909b53a69ff4f4988c81466a8c78779', 'DBA必备神器！介绍10款最佳的MySQL GUI工具', 'MySQL是最广泛使用和流行的开源数据库之一，围绕它有许多工具，可以让设计，创建和管理数据库的过程变得更加容易和便捷。但是如何选择最适合自己需求的工具，并不容易。这里为大家推荐10款MySQL的GUI工具，它们对...', '<p>MySQL是最广泛使用和流行的开源数据库之一，围绕它有许多工具，可以让设计，创建和管理数据库的过程变得更加容易和便捷。但是如何选择最适合自己需求的工具，并不容易。这里为大家推荐10款MySQL的GUI工具，它们对开发人员和DBA来说都是不错的解决方案。</p> \n<h4>1.dbForge Studio for MySQL</h4> \n<p>==========================</p> \n<p>它是一款多功能的GUI工具，也是一个IDE，其中包含MySQL数据库开发和维护所需的广泛特性。它可以创建和执行查询，开发和调试存储，自动化数据库对象管理，通过直观的界面分析表数据等等。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022440163\" src=\"http://localhost:8060/tup/2020/4/23/24ff3361b7134e6d85937c0059d49749.jpg\" alt=\"\" title=\"\"></span></p> \n<p>dbForge Studio提供丰富的代码格式化功能，可用于创建和修改代码配置文件，以标准化代码并使代码尽可能干净；它支持MariaDB数据库；能够在CRUD生成器的帮助下为SQL文件的SELECT，INSERT，UPDATE和DELETE语句创建结果脚本。</p> \n<h4>2.MySQL Workbench</h4> \n<p>=================</p> \n<p>MySQL Workbench是面向数据库架构师，开发人员和DBA的统一可视工具。它提供了用于设计，开发和管理数据库的各种功能。它有3个版本可用-社区，标准和企业版。社区版是一个免费的开源版本，提供了一组基本功能，其余两个是具有扩展功能的商业版本。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022440162\" src=\"http://localhost:8060/tup/2020/4/23/4099f9f251234d9488455a454a57affe.jpg\" alt=\"\" title=\"\"></span></p> \n<p>MySQL Workbench允许查看服务器状态和运行状况以及服务器日志；由Oracle开发，因此MySQL Workbench与MySQL的所有最新功能兼容；它适用于Windows，Linux和Mac OS X。</p> \n<h4>3.phpMyAdmin</h4> \n<p>============</p> \n<p>phpMyAdmin是一个用PHP编写的基于Web的MySQL管理工具。它是同类工具中最受欢迎的工具之一，主要是因为它使用起来非常容易并且完全免费。它可能缺少其他工具提供的某些高级功能，但是其基本功能足以帮助你创建功能强大的网站，而无需具备MySQL的高级知识。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022440165\" src=\"http://localhost:8060/tup/2020/4/23/2c2e261b71654519962bf5edb0a5d401.jpg\" alt=\"\" title=\"\"></span></p> \n<p>它满足大多数基于Web的计算机都可以轻松访问；易于安装和使用；提供80种语言支持。</p> \n<h4>4.HeidiSQL</h4> \n<p>==========</p> \n<p>HeidiSQL是一款轻量级的免费软件工具，可用于处理数据库，包括浏览或编辑数据，创建和修改表，管理用户权限或其他任务。除了Windows，它还可以与Linux发行版一起使用。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022440164\" src=\"http://localhost:8060/tup/2020/4/23/23c7cb05772741c9ab5a5e1ea3f8c497.jpg\" alt=\"\" title=\"\"></span></p> \n<p>它可以通过SSH隧道连接到MySQL数据库；允许将ASCII和二进制文件批量插入表中；可移植版本中可用，不需要安装或管理权限。</p> \n<h4>5.Toad Edge for MySQL</h4> \n<p>=====================</p> \n<p>Toad Edge for MySQL提供了用于数据库开发和管理的工具集，其功能包括模式比较和同步，SQL查询监控器，强大的数据导入和导出，数据库快照创建，高级JSON编辑器等。Toad Edge适用于 Windows和Mac OSX。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022440169\" src=\"http://localhost:8060/tup/2020/4/23/213a2e7598b142d6bc0e0dd3c2911471.jpg\" alt=\"\" title=\"\"></span></p> \n<p>它具有强大的JSON数据浏览器/编辑器功能；会话查看器，可以跟踪当前会话，终止它们或取消查询；</p> \n<h4>6.SQLyog</h4> \n<p>========</p> \n<p>SQLyog是适用于Windows的MySQL管理解决方案，提供三种付费版本。它还具有免费试用版，可让你在购买许可证之前测试软件。因为具有广泛的功能列表，所以付费试用在所难免。可以同步数据和模式，执行计划的备份，导入外部数据等等。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022440166\" src=\"http://localhost:8060/tup/2020/4/23/0592ac79dc49477ea35164c5ed407eaa.jpg\" alt=\"\" title=\"\"></span></p> \n<p>它具有各种主题的可自定义用户界面；多线程查询执行；允许从架构定义生成SQL DML语句的快捷方式。</p> \n<h4>7.Navicat for MySQL</h4> \n<p>===================</p> \n<p>Navicat for MySQL是数据库开发人员和管理员的一组工具，与MySQL，MariaDB和云数据库兼容。各种各样的功能使你能够简化数据库开发过程，并在执行各种管理任务时提高工作效率。该工具提供三个付费版本，并提供14天的全功能免费试用，以帮助你评估其功能。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022440170\" src=\"http://localhost:8060/tup/2020/4/23/01cc790bc41d4715a743b9d2340a53ea.jpg\" alt=\"\" title=\"\"></span></p> \n<p>它适用于Windows，Mac OS X和Linux；允许将连接设置，模型，查询和虚拟组同步到Navicat Cloud，以便可以随时随地与同事共享。能够在Windows版本中打印计划报告。</p> \n<h4>8.Aqua Data Studio</h4> \n<p>==================</p> \n<p>Aqua Data Studio是用于关系数据库，云数据库和NoSQL数据库的通用IDE，具有强大的可视数据分析功能。它可以直观地构建查询，为实体关系图建模，在Excel样式的网格中编辑数据以及执行其他数据库开发和管理任务。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022440167\" src=\"http://localhost:8060/tup/2020/4/23/70213e91b9a148e288ad5f688f6c2775.jpg\" alt=\"\" title=\"\"></span></p> \n<p>利用该工具强大的可视化分析功能，创建数据可视化并与同事和客户共享；使用一组开放的API在脚本开发环境中开发和调试脚本；查看查询执行计划及其统计信息，以了解如何提高整体服务器性能。</p> \n<h4>9.Valentina Studio</h4> \n<p>==================</p> \n<p>Valentina Studio可以创建和维护数据库，查询，对象关系等。免费版包括基本功能，例如编辑模式和为其创建图表，服务器管理，代码完成等。付费的Pro版本提供了附加功能，例如报表设计器，查询生成器等。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022440171\" src=\"http://localhost:8060/tup/2020/4/23/c1e8f7f0908748f8a9aa8394c3ffadd5.jpg\" alt=\"\" title=\"\"></span></p> \n<p>它提供各种数据库持续集成工具；支持具有独特抽象链接的Valentina数据库，它们使开发人员可以使用API和SQL命令来创建，删除和修改表之间的链接，链接和取消链接记录等；有免费的iOS版本</p> \n<h4>10.Sequel Pro</h4> \n<p>=============</p> \n<p>Sequel Pro是一个免费的MySQL数据库管理工具，它可以执行所有基本任务，例如添加，修改，删除，浏览和过滤数据库，表和记录，运行查询等。Sequel Pro仅可在Mac OS X上运行。该工具是CocoaMySQL数据库管理应用程序的延伸产品。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022440168\" src=\"http://localhost:8060/tup/2020/4/23/a5aed6b669c745f898efd38940954dfc.jpg\" alt=\"\" title=\"\"></span></p> \n<p>它通过TCP/IP协议轻松连接到数据库；支持所有版本的MySQL；轻巧易用。</p>', null, 'http://localhost:8060/tup/2020/4/23/4934dd5afb604389b17f23377e373186.jpg', '3f69fcc9b13843d1910b3dac597f5215', 'bb0b7e69ad3e46fcb121baefda8f1f78', '83f62facb3b943ffa8e46abd1ebc64d9,1a77ff8ac4c54e58b5e6b22210cff64f,55723db96b9f4593bae02bc1e49f1e87,d7416e100af54eb7a4d9274b9a462240,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-23 10:54:40', '2020-04-23 10:54:40');
INSERT INTO `tb_recommend` VALUES ('cdb895d1d1a2472380560b8f5bbb7c53', '为什么 String 是不可变的？', '字符串在 Java 中是不可变的，因为 String 对象缓存在 String 池中。由于缓存的字符串在多个客户之间共享，因此始终存在风险，其中一个客户的操作会影响所有其他客户。', '<blockquote>\n 作者：Yujiaao\n <br>\n <a href=\"https://segmentfault.com/a/1190000019962661\">https://segmentfault.com/a/11...</a> \n</blockquote> \n<p>我最喜欢的 Java 面试问题，不好回答，但同时也非常有用。一些面试者也常问这个问题，为什么 String 在 Java 中是&nbsp;<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247487062&amp;idx=2&amp;sn=00ba05ef2f80488b1860d6d49e8b9557&amp;chksm=eb538b60dc240276fc745eca8b7667364ea6ca86092d8f404b0bde5ec03dbcd81a4bc3a9454d#rd\" rel=\"nofollow noreferrer\"><code>final</code></a>&nbsp;的。</p> \n<p>字符串在 Java 中是不可变的，因为 String 对象缓存在 String 池中。由于缓存的字符串在多个客户之间共享，因此始终存在风险，其中一个客户的操作会影响所有其他客户。</p> \n<p>例如，如果一段代码将 String “Test” 的值更改为 “TEST”，则所有其他客户也将看到该值。由于 String 对象的缓存是性能的重要保证，因此通过使 String 类不可变来避免这种风险。</p> \n<p>同时，String 是 final 的，因此没有人可以通过扩展和覆盖行为来破坏 String 类的不变性、缓存、散列值的计算等。String 类不可变的另一个原因可能是由于&nbsp;<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247492216&amp;idx=2&amp;sn=8d782298916fe6a951888cdd12a87bfd&amp;chksm=eb50674edc27ee5843bc9bd5044ccf39a85a797e2aed19e406855f83048991fa61618922537d#rd\" rel=\"nofollow noreferrer\"><code>HashMap</code></a>。</p> \n<p>由于把字符串作为 HashMap 键很受欢迎。对于键值来说，不可变性是非常的重要，以便用它们检索存储在 HashMap 中的值对象。由于 HashMap 的工作原理是散列，因此需要具有相同的值才能正常运行。如果在插入后修改了 String 的内容，可变的 String 将在插入和检索时生成两个不同的哈希码，可能会丢失 Map 中的值对象。</p> \n<p>字符串是Java 非常特殊的类。我还没有看到一个没有使用 String 编写的 Java 程序。这就是为什么对 String 的充分理解对于 Java 开发人员来说非常重要。关注微信公众号：Java技术栈，在后台回复：Java，可以获取我整理的 N 篇 Java 教程，都是干货。</p> \n<p>String 是数据类型，也传输对象和中间人。这种多重角色的重要性和流行性， 也使这个问题在 Java 面试中很常见。</p> \n<p>为什么 String 在 Java 中是不可变的是 Java 中最常被问到的字符串访问问题之一，它首先讨论了什么是 String，Java 中的 String 如何与 C 和 C++ 中的 String 不同，然后转向在Java中什么是不可变对象，不可变对象有什么好处，为什么要使用它们以及应该使用哪些场景。</p> \n<p>这个问题有时也会问：“为什么 String 在 Java 中是 final 的”。钻个牛角尖，你确定是不变的吗，看这篇：<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247487062&amp;idx=2&amp;sn=00ba05ef2f80488b1860d6d49e8b9557&amp;chksm=eb538b60dc240276fc745eca8b7667364ea6ca86092d8f404b0bde5ec03dbcd81a4bc3a9454d#rd\" rel=\"nofollow noreferrer\">Java&nbsp;中的&nbsp;String&nbsp;真的是不可变的吗？</a>在类似的说明中，如果你正在准备Java 面试，我建议你看看Java编程面试公开书，这是高级和中级Java程序员的优秀资源。它包含来自所有重要 Java 主题的问题，包括多线程，集合，<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247489332&amp;idx=2&amp;sn=65de5886e13b98116c8432d7d10ae4bc&amp;chksm=eb539202dc241b14010f70edf89dc37c7629b5e2b7add50fd3f58070ecf2c14260196bf147d8#rd\" rel=\"nofollow noreferrer\">GC</a>，<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247492884&amp;idx=2&amp;sn=dcf992badf5ab70c22306e8e4331fbf6&amp;chksm=eb506022dc27e934e4945f924be544853267f79b7337b3091b7743ddcde7bce4ae4cf3682d1d#rd\" rel=\"nofollow noreferrer\">JVM</a>内部以及&nbsp;<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247493383&amp;idx=2&amp;sn=883c40b743d496e48dc2f99a083ec5e4&amp;chksm=eb506231dc27eb272437a3dfd2b9a0ae91414c69a83c7e3fe22362cdef909e39122929af9884#rd\" rel=\"nofollow noreferrer\">Spring</a>和 Hibernate 框架等。</p> \n<p>正如我所说，这个问题可能有很多可能的答案，而 String 类的唯一设计者可以放心地回答它。我在 Joshua Bloch 的 Effective Java 书中期待一些线索，但他也没有提到它。我认为以下几点解释了为什么 String 类在 Java 中是不可变的或 final 的：</p> \n<p>1) 想象字符串池没有使字符串不可变，它根本不可能，因为在字符串池的情况下，一个字符串对象/文字，例如 “Test” 已被许多参考变量引用，因此如果其中任何一个更改了值，其他参数将自动受到影响，即假设</p> \n<pre><code>String&nbsp;A=\"Test\";String&nbsp;B=\"Test\";\n</code></pre> \n<p>现在字符串 B 调用&nbsp;<code>\"Test\".toUpperCase()</code>, 将同一个对象改为“TEST”，所以 A 也是 “TEST”，这不是期望的结果。</p> \n<p>下图显示了如何在堆内存和字符串池中创建字符串。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGjl1\" src=\"http://localhost:8060/tup/2020/4/23/83e093de12d44596bdadb77f23bb17c2.jpg\" alt=\"\" title=\"\"></span></p> \n<p>2) 字符串已被广泛用作许多 Java 类的参数，例如，为了打开网络连接，你可以将主机名和端口号作为字符串传递，你可以将数据库 URL 作为字符串传递, 以打开数据库连接，你可以通过将文件名作为参数传递给 File I/O 类来打开 Java 中的任何文件。</p> \n<p>如果 String 不是不可变的，这将导致严重的安全威胁，我的意思是有人可以访问他有权授权的任何文件，然后可以故意或意外地更改文件名并获得对该文件的访问权限。</p> \n<p>由于不变性，你无需担心这种威胁。这个原因也说明了，为什么 String 在 Java 中是最终的，通过使&nbsp;<code>java.lang.String</code>&nbsp;final，Java设计者确保没有人覆盖 String 类的任何行为。</p> \n<p>3) 由于 String 是不可变的，它可以安全地共享许多线程，这对于多线程编程非常重要. 并且避免了 Java 中的同步问题，不变性也使得String 实例在 Java 中是线程安全的，这意味着你不需要从外部同步 String 操作。</p> \n<p>关于 String 的另一个要点是由截取字符串&nbsp;<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484799&amp;idx=1&amp;sn=40572745a062459cd3644740cd0821b3&amp;chksm=eb538049dc24095f1e95f707742c251cc79eb9e1a3ab144be035423d64a25611285be97f478e#rd\" rel=\"nofollow noreferrer\">SubString</a>&nbsp;引起的内存泄漏，这不是与线程相关的问题，但也是需要注意的。</p> \n<p>4) 为什么 String 在 Java 中是不可变的另一个原因是允许 String 缓存其哈希码，Java 中的不可变 String 缓存其哈希码，并且不会在每次调用 String 的 hashcode 方法时重新计算，这使得它在 Java 中的 HashMap 中使用的 HashMap 键非常快。</p> \n<p>简而言之，因为 String 是不可变的，所以没有人可以在创建后更改其内容，这保证了 String 的&nbsp;<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247491299&amp;idx=2&amp;sn=a0f523badfd3a1997bb89296cd78393d&amp;chksm=eb539bd5dc2412c3304e7099328782529122564afff7ba22246df3b33aced5209de7c9df9305#rd\" rel=\"nofollow noreferrer\">hashCode</a>&nbsp;在多次调用时是相同的。</p> \n<p>5) String 不可变的绝对最重要的原因是它被类加载机制使用，因此具有深刻和基本的安全考虑。如果 String 是可变的，加载“java.io.Writer” 的请求可能已被更改为加载 “mil.vogoon.DiskErasingWriter”. 安全性和字符串池是使字符串不可变的主要原因。</p> \n<p>顺便说一句，上面的理由很好回答另一个Java面试问题: “为什么String在Java中是最终的”。要想是不可变的，你必须是最终的，这样你的子类不会破坏不变性。你怎么看？</p> \n<p><strong>推荐去我的博客阅读更多：</strong></p> \n<p>1.<a href=\"http://www.javastack.cn/categories/Java/\" rel=\"nofollow noreferrer\">Java JVM、集合、多线程、新特性系列教程</a></p> \n<p>2.<a href=\"http://www.javastack.cn/categories/Spring/\" rel=\"nofollow noreferrer\">Spring MVC、Spring Boot、Spring Cloud 系列教程</a></p> \n<p>3.<a href=\"http://www.javastack.cn/categories/%E5%B7%A5%E5%85%B7/\" rel=\"nofollow noreferrer\">Maven、Git、Eclipse、Intellij IDEA 系列工具教程</a></p> \n<p>4.<a href=\"http://www.javastack.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/\" rel=\"nofollow noreferrer\">Java、后端、架构、阿里巴巴等大厂最新面试题</a></p> \n<p>觉得不错，别忘了点赞+转发哦！</p>', null, 'http://localhost:8060/tup/2020/4/23/bc5b3faf580e4e64ae67ebc58057aa36.jpg', 'c56940aa8b004dab84568e86900b2ee6', 'bb0b7e69ad3e46fcb121baefda8f1f78', '2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-23 10:28:17', '2020-04-23 10:28:17');
INSERT INTO `tb_recommend` VALUES ('cf3b4636013f4eaeb61383360d781e6e', '抽签小程序，妈妈再也不用担心谁洗碗（分配任务）了，so easy', '背景 今天谁炒菜，谁洗碗，谁买菜...啊，Boss说用抽签吧，于是有了下图 这样存在作弊的问题（记住棍子特征，谁先，谁后抽等等）于是有了这个抽签小程序（当然小程序我一个人控制，我想不想作弊看心情了） 简介 扫...', '<h2>背景</h2> \n<p>今天谁炒菜，谁洗碗，谁买菜...啊，Boss说用抽签吧，于是有了下图<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383943\" src=\"http://localhost:8060/tup/2020/4/23/af7a512566994bf58adce459a63da759.jpg\" alt=\"image\" title=\"image\"></span></p> \n<p>这样存在作弊的问题（记住棍子特征，谁先，谁后抽等等）于是有了这个抽签小程序（当然小程序我一个人控制，我想不想作弊看心情了）</p> \n<h2>简介</h2> \n<p>扫码体验</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383942\" src=\"http://localhost:8060/tup/2020/4/23/bf8f71244f4a4abfaf6adf8d6808f6ef.jpg\" alt=\"image\" title=\"image\"></span></p> \n<h2>数据服务，存储</h2> \n<p>本项目使用的是微信云开发，云数据库声明个抽签chouqianList集合即可（云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代）</p> \n<h2>运行前准备</h2> \n<p>(1)<a href=\"https://mp.weixin.qq.com/wxopen/waregister?action=step1\" rel=\"nofollow noreferrer\">注册微信小程序</a>，获取 appid,替换本项目project.config.json里的appid</p> \n<p>(2)<a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/quickstart.html\" rel=\"nofollow noreferrer\">开通小程序的云开发</a></p> \n<h2>具体实现</h2> \n<h3>首页</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383945\" src=\"http://localhost:8060/tup/2020/4/23/f4b2887ed1d04eccbf5ddff247934e4a.jpg\" alt=\"image\" title=\"image\"></span></p> \n<p>首页从上至下有抽签主题，抽签选项，发起抽签，常用抽签，此页面主要功能发起抽签，把抽签内容存到数据库里面。</p> \n<blockquote>\n 微信审核提示\n <br>\n <span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383944\" src=\"http://localhost:8060/tup/2020/4/23/07513dabaa6d46eaa338d137b0a5ec59.jpg\" alt=\"image\" title=\"image\"></span>\n <br>解决这个问题添加的内容调用这个方法（小程序内容安全api，云开发可调用）\n</blockquote> \n<pre><code>  isCheckMsg: function (msg) {\n        return new Promise(function (n, s) {\n            wx.cloud.callFunction({\n                name: \'msg\',\n                data: ({\n                    text: msg\n                })\n            }).then(res =&gt; {\n                if (res.result.errCode === 87014) {\n                    // 没通过\n                    n(false) \n                } else {\n                    // (\"通过\")\n                    n(true)\n                }\n            });\n        });\n    },</code></pre> \n<p>随机抽签</p> \n<pre><code> // 递归随机返回抽签项\n    edchouqian() {\n        let that = this;\n        return new Promise(function (n, s) {\n            const db = wx.cloud.database()\n            // 查询当前用户所有的 chouqianList\n            db.collection(\'chouqianList\').where({\n                _id: that.data.drawlotsId\n            }).get({\n                success: res =&gt; {\n                    that.setData({\n                        detail: res.data[0].detail,\n                    });\n                    let nullDetail = res.data[0].detail.filter(item =&gt; item.openid == \"\");//找出没有抽签的选项\n                    let arrIndex = Math.floor((Math.random() * nullDetail.length));//从没有抽签的选项随机选择一个选项\n                    let objindex = nullDetail[arrIndex].index;\n                    n(objindex)\n                },\n                fail: err =&gt; {\n                    wx.showToast({\n                        icon: \'none\',\n                        title: \'查询记录失败\'\n                    })\n                    console.error(\'[数据库] [查询记录] 失败：\', err);\n                    s(err);\n                }\n            })\n        });\n    },</code></pre> \n<h3>抽签页</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383947\" src=\"http://localhost:8060/tup/2020/4/23/49f89e1ef8d144dc87559a4febadd8c5.jpg\" alt=\"image\" title=\"image\"></span></p> \n<p>抽签页有抽签功能，显示抽签结果，此页面主要功能，从数据库查询是否已经抽签，已抽签显示抽签结果，未抽签随机分配抽签（或者显示抽签次数已用完）。</p> \n<blockquote>\n 重复抽签问题用函数防抖或者节流\n</blockquote> \n<h3>抽签结果页</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383946\" src=\"http://localhost:8060/tup/2020/4/23/6d988f99c7194bdba8f8141cf60275d1.jpg\" alt=\"image\" title=\"image\"></span></p> \n<p>抽签结果页，显示所有抽签人员和结果（结果从数据库根据抽签表的id查询）</p> \n<h4>至此完毕 <a href=\"https://github.com/mgbq/draw\" rel=\"nofollow noreferrer\">源码地址</a> </h4> \n<h3>结语：</h3> \n<p>因为发的时间比较短，页面、功能还需要慢慢完善，发布了的功能也有一些待改进的地方，欢迎同样志同道合的码友们多多指教和交流。ヾ(????)?~</p> \n<p>前端学习大佬群493671066，美女多多。老司机快上车，来不及解释了。</p> \n<h4>作者相关Vue文章</h4> \n<p><a href=\"https://github.com/mgbq/vue-permission\" rel=\"nofollow noreferrer\">基于Vue2.0实现后台系统权限控制</a></p> \n<p><a href=\"https://blog.csdn.net/qq_32340877/article/details/80176987\" rel=\"nofollow noreferrer\">vue2.0-基于elementui换肤（自定义主题）</a></p> \n<p><a href=\"https://github.com/mgbq/front-end-Doc\" rel=\"nofollow noreferrer\">前端文档汇总</a></p> \n<p><a href=\"https://github.com/mgbq/Vue-admin\" rel=\"nofollow noreferrer\">VUE2.0增删改查附编辑添加model(弹框)组件共用</a></p> \n<h2>打赏 衷心的表示感谢</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383948\" src=\"http://localhost:8060/tup/2020/4/23/8ebf4846c3134ba7ac7bc6aeb13aaf8b.jpg\" alt=\"打赏\" title=\"打赏\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/e8777371eb4d45878240488af1951b3a.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', '7b3e40f8b9cc4b7780dc39a71d7f580e', '9eccd82e1d9a4a8cb3a0971df3788f2b,4c3a5a1f039b42a5b26aeb9aca0646bb,15941dc0af92453481b8a0626f963283', '0', '3', '1', '2020-04-23 10:29:54', '2020-04-23 10:29:54');
INSERT INTO `tb_recommend` VALUES ('cf821a8b8c4e40a8ae8e807c4865fc30', '云服务商青云递交招股书，2019 年营收 3.8 亿元，计划融资 11.88 亿元', '青云成立于 2012 年 4 月，是一家平台级混合云 ICT 厂商和服务商，致力于为企业用户提供自主可控、中立可靠、性能卓越、灵活开放的云计算产品与服务。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIHv\" src=\"http://localhost:8060/tup/2020/4/23/b0dbbc6e9faa4113b7a220458a9f7601.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>4 月 7 日 晚，上交所披露了云服务商青云科技的招股说明书，公司计划于科创板上市。据招股书显示，青云计划上市融资 11.88 亿元。</p> \n<p>青云成立于 2012 年 4 月，是一家平台级混合云 ICT 厂商和服务商，致力于为企业用户提供自主可控、中立可靠、性能卓越、灵活开放的云计算产品与服务。</p> \n<p>经过多年发展，青云科技具备了全维度的云产品与云服务交付能力：在技术层次上，自主研发形成跨越智能广域网、IaaS 和 PaaS 的云网一体技术架构体系，拥有全面的 ICT 服务能力；</p> \n<p>在交付形态上，以统一技术架构形成云产品、云服务两大标准化业务模块，根据客户需要满足私有云、公有云和混合云的部署需求，并针对多个行业形成了完善的行业云计算解决方案；</p> \n<p>在场景纵深上，正着力布局发展集云、网、边、端于一体化的综合服务能力，实现更广义的数据互联。</p> \n<p>2019 年，青云营收 3.77 亿元，同比增长 33.7%，扣除非经常损益净亏损为 1.38 亿元，同比扩大 10%。青云在招股书「重大事项提示」中称由于前期固定资产投入及研发支出较大，目前尚未实现盈利，且预计公司经营会持续产生大量开支。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFICz\" src=\"http://localhost:8060/tup/2020/4/23/e70be88c345c4657b2f772bec46e8728.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>青云在招股书中坦言存在以下风险：</p> \n<h2><strong>一、公司目前尚未盈利，且预计短期内无法盈利、未弥补亏损持续存在</strong></h2> \n<p>由于前期固定资产投入及研发支出较大，公司目前尚未实现盈利，且预计公司经营会持续产生大量开支。另外，公司存在金额较大的累计未弥补亏损，公司由有限责任公司整体变更为股份有限公司的基准日未分配利润为负。</p> \n<p>截至本招股说明书签署之日，由于公司新技术与新产品研发投入较大、所处云计算行业尤其是公有云领域竞争较为激烈，该情形尚未消除。</p> \n<p>以下风险将导致公司在未来一段时间内持续亏损且存在累计未弥补亏损的情形：</p> \n<p><strong>1、收入增速不达预期的风险</strong><br><strong>2、固定资产投入及数据中心采购较大的风险</strong><br><strong>3、毛利率波动风险</strong><br><strong>4、研发支出较大的风险</strong><br><strong>5、资金状况、研发投入、业务拓展、人才引进、团队稳定等方面受到限制或影响的风险</strong></p> \n<h2><strong>二、云计算行业尤其是公有云领域竞争激烈，存在竞争风险</strong></h2> \n<p>云计算是信息化时代的重要 IT 基础设施，潜在市场空间巨大，经济效益和社会价值极高。产业各界高度关注云计算市场机会，众多大型知名企业纷纷进军云计算行业，富有活力的中小型云计算创业公司也不断成立。</p> \n<p>公司在云产品业务领域面临着华为、新华三、VMware等大型IT行业龙头的竞争，在云服务业务领域也有着阿里云、腾讯云、AWS等实力雄厚的竞争对手，各大厂商通过降低产品报价、加强营销推广等多种手段，积极争取客户订单，着力抢占市场份额。</p> \n<p>若公司不能在竞争中构筑核心技术壁垒，加速产品更新迭代，拓展销售渠道网络，优化服务质量，从而进一步加强核心竞争能力，提升市场份额，将对公司经营业绩形成不利影响。</p> \n<h2><strong>三、公司研发、运营资金需求持续增加，存在营运资金风险</strong></h2> \n<p>公司业务运营所需资金量较高，2017 年度、2018 年度及 2019 年度，公司经营活动产生的现金流量净额分别为 1,051.19 万元、-6,239.70 万元及 -8,700.04 万元。</p> \n<p>报告期内，公司通过股权融资及债权融资方式获得营运资金、保证较为充裕的现金流；未来，公司为了进一步拓展公司业务规模、丰富产品线、完善销售渠道、提升公司核心技术先进性与市场竞争力，仍需要继续投入持续增加的研发投入、销售投入、固定资产支出和其他日常经营支出。</p> \n<p>若公司无法获得足够的营运资金，公司商业计划及业务发展目标可能会被推迟甚至取消，进而对公司业务造成重大不利影响。</p> \n<h2><strong>四、云计算行业技术演进较快，存在技术研发失败风险</strong></h2> \n<p>由于云计算行业仍处于发展早期，技术迭代较快，创新产品和创新模式不断涌现，推动行业产品和服务的质量不断提升，如计算速度、系统稳定性等核心指标都有了较大提升。云计算作为技术密集型行业，产品性能和可靠性是客户在选择供应商时的核心考量因素。</p> \n<p>若公司不能准确把握行业发展趋势，针对性地研发技术和开发产品，导致产品性能和服务质量落后于竞争对手，可能存在已有客户流失、业务发展迟滞、市场份额下降的风险。</p> \n<h2><strong>五、募投项目可能带来即期收益摊薄风险</strong></h2> \n<p>本次发行完成后，公司的资产规模将大幅增加，但因募投项目实施需要一定周期、募集资金到位当期无法立刻全部投入生产运营，在当期产生的效益可能较低。预计发行完成后公司的每股收益和摊薄每股收益会有所下降，即期回报短期内将被摊薄。</p> \n<hr> \n<p>此前，青云市场副总裁刘靓在某次采访中，曾透露青云在 2020 年的新规划。</p> \n<p>刘靓认为，2020 年的云计算市场将聚焦三个特点：重传统企业数字化转型、重生态能力的提升、IT 服务能力与 AI 深度融合。因此，青云将继续深耕传统行业领域，持续贯彻并积极投身与百行千业合作伙伴的深入合作，并将继续加大研发力度，与人工智能技术深度结合，提高云计算产业链条各环节效率、能力和客户体验，打造出更智能的云。</p> \n<p>扫描下方二维码并回复关键词「招股书」，获取招股书完整版 PDF。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyR0\" src=\"http://localhost:8060/tup/2020/4/23/09957e1a76a6447c8f037d23a919e3c7.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/8b2b1932607943b2842b0f5d56ba33d5.jpg', 'f53014d680884163a5bd5ce762e90cdf', 'b299a2a48cd64e77a3431ce958b42055', '1fb6bf7d213640b28d89fe5a369dc60d,f831bc1c03f94b4b9e49390a3a354a3e,e80d97c3472e428dabdaf417adac7a3c', '0', '3', '1', '2020-04-23 10:56:07', '2020-04-23 10:56:07');
INSERT INTO `tb_recommend` VALUES ('d163a4c824944bf39f25d45c300d4694', '这十个MySQL经典错误，99%的程序员一定遇到过！你呢？', '今天就给大家列举 MySQL 数据库中，最经典的十大错误案例，并附有处理问题的解决思路和方法，希望能给刚入行，或数据库爱好者一些帮助，今后再遇到任何报错，我们都可以很淡定地去处理。学习任何一门技术的同时，...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022431952\" src=\"http://localhost:8060/tup/2020/4/23/aa1c592e971a40708296ed4d8fd594c0.jpg\" alt=\"\" title=\"\"></span><br>原文：<a href=\"http://blog.51cto.com/sumongodb/1949426\" rel=\"nofollow noreferrer\">http://blog.51cto.com/sumongo...</a></p> \n<p>今天就给大家列举 MySQL 数据库中，最经典的十大错误案例，并附有处理问题的解决思路和方法，希望能给刚入行，或数据库爱好者一些帮助，今后再遇到任何报错，我们都可以很淡定地去处理。学习任何一门技术的同时，其实就是自我修炼的过程。沉下心，尝试去拥抱数据的世界！</p> \n<h4>Top &nbsp;1：Too many connections（连接数过多，导致连接不上数据库，业务无法正常进行）</h4> \n<h5>问题还原</h5> \n<pre><code>mysql&gt; show variables like \'%max_connection%\';  \n| Variable_name &nbsp; | Value |  \n| max_connections | 151   |  \n\nmysql&gt; set global max_connections=1;Query OK, 0  rows affected (0.00 sec)  \n\n[root@node4 ~]# mysql -uzs -p123456 -h 192.168.56.132  \nERROR 1040 (00000): Too many connections</code></pre> \n<h6>解决问题的思路：</h6> \n<ul> \n <li>1、首先先要考虑在我们 MySQL 数据库参数文件里面，对应的<code>max_connections 这个参数值是不是设置的太小了</code>，导致客户端连接数超过了数据库所承受的最大值。 <br>● 该值默认大小是151，我们可以根据实际情况进行调整。 <br>● 对应解决办法：set global max_connections=500 <br>但这样调整会有隐患，因为我们无法确认数据库是否可以承担这么大的连接压力，就好比原来一个人只能吃一个馒头，但现在却非要让他吃 10 个，他肯定接受不了。反应到服务器上面，就有可能会出现宕机的可能。 <br>所以这又反应出了，我们在新上线一个业务系统的时候，要做好压力测试。保证后期对数据库进行优化调整。</li> \n <li>2、其次可以<code>限制Innodb 的并发处理数量</code>，如果 innodb_thread_concurrency = 0（这种代表不受限制） 可以先改成 16或是64 看服务器压力。如果非常大，可以先改的小一点让服务器的压力下来之后,然后再慢慢增大,根据自己的业务而定。个人建议可以先调整为 16 即可。 <br>MySQL 随着连接数的增加性能是会下降的，可以让开发配合设置 thread pool，连接复用。在MySQL商业版中加入了thread pool这项功能,另外对于有的监控程序会读取 information_schema 下面的表，可以考虑关闭下面的参数</li> \n</ul> \n<pre><code>innodb_stats_on_metadata=0set global innodb_stats_on_metadata=0</code></pre> \n<h4>Top 2：（主从复制报错类型）</h4> \n<h6>Last_SQL_Errno: 1062 &nbsp;（从库与主库数据冲突）</h6> \n<pre><code>Last_Errno: 1062 &nbsp; \nLast_Error: Could not execute Write_rows event on table test.t;  &nbsp; \nDuplicate entry \'4\' for key \'PRIMARY\',  &nbsp; \nError_code: 1062; handler error HA_ERR_FOUND_DUPP_KEY;  &nbsp; \nthe event\'s master log mysql-bin.000014, end_log_pos 1505</code></pre> \n<p><strong>针对这个报错，我们首先要考虑是不是在<code>从库中误操作导致的</code>。结果发现，我们在从库中进行了一条针对有主键表的 sql 语句的插入，导致主库再插入相同 sql 的时候，主从状态出现异常。发生主键冲突的报错。</strong></p> \n<h6>解决方法：</h6> \n<p>在确保主从数据一致性的前提下，可以在从库进行错误跳过。一般使用 percona-toolkit 中的 pt-slave-restart 进行。 <br><strong>在从库完成如下操作</strong></p> \n<pre><code>[root@zs bin]# ./pt-slave-restart -uroot -proot123\n2017-07-20T14:05:30 p=...,u=root node4-relay-bin.000002 &nbsp; 1506 1062 </code></pre> \n<ul>\n <li>之后最好在从库中开启 read_only 参数，禁止在从库进行写入操作</li>\n</ul> \n<h6>Last_IO_Errno: 1593（server-id冲突）</h6> \n<pre><code> Last_IO_Error:  &nbsp;\n Fatal error: The slave I/O thread stops because master and slave have equal MySQL server ids;  &nbsp;\n these ids must be different for replication to work  &nbsp;(or the --replicate-same-server-id option must be used on slave but this  &nbsp;\n does not always make sense; please check the manual before using it)\n #这个报错出现之后，就看一目了然看到两台机器的 server-id 是一样的。</code></pre> \n<p>在搭建主从复制的过程中，我们要确保两台机器的 server-id 是唯一的。这里再强调一下 server-id 的命名规则（服务器 ip 地址的最后一位+本 MySQL 服务的端口号）</p> \n<h6>解决方法：</h6> \n<p>在主从两台机器上设置不同的 server-id。</p> \n<h6>Last_SQL_Errno: 1032（从库少数据，主库更新的时候，从库报错）</h6> \n<pre><code>Last_SQL_Error:Could not execute Update_rows event on table test.t; Can\'t find record in \'t\', Error_code: 1032; handler error HA_ERR_KEY_NOT_FOUND; the event\'s master log mysql-bin.000014, end_log_pos 1708</code></pre> \n<h6>解决问题的办法：</h6> \n<p>根据报错信息，我们可以获取到报错日志和position号，然后就能找到主库执行的哪条sql，导致的主从报错。 <br>在主库执行：</p> \n<pre><code>/usr/local/mysql/bin/mysqlbinlog --no-defaults -v -v --base64-output=decode-rows /data/mysql/mysql-bin.000014 |grep -A 10 1708 &gt; 1.logcat 1.log\n#170720 14:20:15 server id 3 &nbsp;end_log_pos 1708 CRC32 0x97b6bdec &nbsp; &nbsp; Update_rows: table id 113 flags: STMT_END_F\n### UPDATE `test`.`t`\n### WHERE\n### &nbsp; @1=4 /* INT meta=0 nullable=0 is_null=0 */\n### &nbsp; @2=\'dd\' /* VARSTRING(60) meta=60 nullable=1 is_null=0 */\n### SET\n### &nbsp; @1=4 /* INT meta=0 nullable=0 is_null=0 */\n### &nbsp; @2=\'ddd\' /* VARSTRING(60) meta=60 nullable=1 is_null=0 */\n# at 1708\n#170720 14:20:15 server id 3 &nbsp;end_log_pos 1739 CRC32 0xecaf1922 &nbsp; &nbsp; Xid = 654\nCOMMIT/*!*/;\nDELIMITER ;\n# End of log file\nROLLBACK /* added by mysqlbinlog */;\n/*!50003 SET COMPLETION_TYPE=@OLD_COMPLETION_TYPE*/;\n/*!50530 SET @@SESSION.PSEUDO_SLAVE_MODE=0*/;</code></pre> \n<p>获取到 sql 语句之后，就可以在从库反向执行 sql 语句。把从库缺少的 sql 语句补全，解决报错信息。 <br>在从库依次执行：</p> \n<pre><code>mysql&gt; insert into t (b) values (\'ddd\');\nQuery OK, 1 row affected (0.01 sec)\nmysql&gt; stop slave;\nQuery OK, 0 rows affected (0.00 sec)\nmysql&gt; exit\nBye\n[root@node4 bin]# ./pt-slave-restart -uroot -proot123\n2017-07-20T14:31:37 p=...,u=root node4-relay-bin.000005 &nbsp; &nbsp; &nbsp; &nbsp; 283 1032 </code></pre> \n<h5>Top 3：MySQL安装过程中的报错</h5> \n<pre><code>[root@zs data]# /usr/local/mysql/bin/mysqld_safe --defaults-file=/etc/my.cnf &amp;[1] 3758\n[root@zs data]# 170720 14:41:24 mysqld_safe Logging to \'/data/mysql/error.log\'.\n170720 14:41:24 mysqld_safe Starting mysqld daemon with databases from /data/mysql170720 \n14:41:25 mysqld_safe mysqld from pid file /data/mysql/node4.pid ended\n170720 14:41:24 mysqld_safe Starting mysqld daemon with databases from /data/mysql2017-07-20 \n14:41:25 0 [Warning] TIMESTAMP with implicit DEFAULT value is deprecated. \nPlease use --explicit_defaults_for_timestamp server option (see documentation for more details)./usr/local/mysql/bin/mysqld: \nFile \'/data/mysql/mysql-bin.index\' not found (Errcode: 13 - Permission denied)\n2017-07-20 14:41:25 4388 [ERROR] Aborting</code></pre> \n<h6>解决思路：</h6> \n<p>遇到这样的报错信息，我们要学会时时去关注错误日志 error log 里面的内容。看见了关键的报错点<code>Permission denied。证明当前 MySQL 数据库的数据目录没有权限。</code></p> \n<h6>解决方法：</h6> \n<pre><code>[root@zs data]# chown mysql:mysql -R mysql\n[root@zs data]# /usr/local/mysql/bin/mysqld_safe --defaults-file=/etc/my.cnf &amp;\n[1] 4402\n[root@zs data]# 170720 14:45:56 mysqld_safe Logging to \'/data/mysql/error.log\'.\n170720 14:45:56 mysqld_safe Starting mysqld daemon with databases from /data/mysql\n#启动成功。</code></pre> \n<p><strong>如何避免这类问题，个人建议在安装<code>MySQL初始化的时候，一定加上--user=mysql，</code>这样就可以避免权限问题。</strong></p> \n<pre><code>./mysql_install_db --basedir=/usr/local/mysql/ --datadir=/data/mysql/ --defaults-file=/etc/my.cnf --user=mysql</code></pre> \n<h5>Top 4：数据库密码忘记的问题</h5> \n<pre><code>[root@zs ~]# mysql -uroot -p\nEnter password: \nERROR 1045 (28000): Access denied for user \'root\'@\'localhost\' (using password: YES)\n[root@zs ~]# mysql -uroot -p\nEnter password: \nERROR 1045 (28000): Access denied for user \'root\'@\'localhost\' (using password: YES)\n#我们有可能刚刚接手别人的 MySQL 数据库，而且没有完善的交接文档。root 密码可以丢失或者忘记了。</code></pre> \n<h6>解决思路：</h6> \n<p>目前是进入不了数据库的情况，所以我们要考虑是不是<code>可以跳过权限</code>。因为在数据库中，mysql数据库中user表记录着我们用户的信息。</p> \n<h6>解决方法：</h6> \n<p>启动 MySQL 数据库的过程中，可以这样执行：</p> \n<pre><code>/usr/local/mysql/bin/mysqld_safe --defaults-file=/etc/my.cnf &nbsp;--skip-grant-tables &amp;\n这样启动，就可以不用输入密码，直接进入 mysql 数据库了。然后在修改你自己想要改的root密码即可。\nupdate mysql.user set password=password(\'root123\') where user=\'root\';</code></pre> \n<h4>Top 5：truncate 删除数据，导致自动清空自增ID，前端返回报错 not found。</h4> \n<p>这个问题的出现，就要<code>考虑下truncate 和 delete 的区别了。</code></p> \n<h6>看下实验演练：</h6> \n<pre><code>#首先先创建一张表；  \nCREATE TABLE `t` (  \n`a` int(11) NOT NULL AUTO_INCREMENT,  \n`b` varchar(20) DEFAULT NULL,  \n&nbsp;PRIMARY KEY (`a`),  \nKEY `b` (`b`)  \n) ENGINE=InnoDB AUTO_INCREMENT=300 DEFAULT CHARSET=utf8  \n#插入三条数据：  \nmysql&gt; insert into t (b) values (\'aa\');  \nQuery OK, 1 row affected (0.00 sec)  \nmysql&gt; insert into t (b) values (\'bb\');  \nQuery OK, 1 row affected (0.00 sec)  \nmysql&gt; insert into t (b) values (\'cc\');  \nQuery OK, 1 row affected (0.00 sec)  \nmysql&gt; select * from t;  \n+-----+------+  \n| a &nbsp; | b    |  \n+-----+------+  \n|  300  | aa |  \n| 301   |bb  |  \n|  302  |cc  |  \n+-----+------+  \n3 rows in set (0.00 sec)  \n#先用 delete 进行删除全表信息，再插入新值。</code></pre> \n<p>结果发现truncate把自增初始值重置了，自增属性从1开始记录了。当前端用主键id进行查询时，就会报没有这条数据的错误。 <br>个人建议不要使用truncate对表进行删除操作，虽然可以回收表空间，但是会涉及自增属性问题。这些坑，我们不要轻易钻进去。</p> \n<h5>Top 6：阿里云 MySQL 的配置文件中，需要注意一个参数设置就是：</h5> \n<pre><code>lower_case_table_names = 0;默认情况\nlower_case_table_names = 1;是不区分大小写 . 如果报你小写的表名找不到, 那你就把远端数据库的表名改成小写 , 反之亦然 . 注意 Mybatis 的 Mapper 文件的所有表名也要相应修改</code></pre> \n<h5>Top 7：数据库总会出现中文乱码的情况</h5> \n<h6>解决思路：</h6> \n<p>对于中文乱码的情况，记住老师告诉你的三个统一就可以。还要知道在目前的mysql数据库中字符集编码都是默认的UTF8</p> \n<h6>处理办法：</h6> \n<blockquote>\n 1、数据终端，也就是我们连接数据库的工具设置为 utf8 \n <br>2、操作系统层面；可以通过 cat /etc/sysconfig/i18n 查看；也要设置为 utf8 \n <br>3、数据库层面；在参数文件中的 mysqld 下，加入 character-set-server=utf8。\n</blockquote> \n<p><strong>Emoji 表情符号录入 mysql 数据库中报错。</strong></p> \n<pre><code>Caused by: java.sql.SQLException: Incorrect string value: \'\\xF0\\x9F\\x98\\x97\\xF0\\x9F...\' for column \'CONTENT\' at row 1\nat com.mysql.jdbc.SQLError.createSQLException(SQLError.java:1074)\nat com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:4096)\nat com.mysql.jdbc.MysqlIO.checkErrorPacket(MysqlIO.java:4028)\nat com.mysql.jdbc.MysqlIO.sendCommand(MysqlIO.java:2490)\nat com.mysql.jdbc.MysqlIO.sqlQueryDirect(MysqlIO.java:2651)\nat com.mysql.jdbc.ConnectionImpl.execSQL(ConnectionImpl.java:2734)\nat com.mysql.jdbc.PreparedStatement.executeInternal(PreparedStatement.java:2155)\nat com.mysql.jdbc.PreparedStatement.execute(PreparedStatement.java:1379)</code></pre> \n<p><strong>解决思路：</strong>针对表情插入的问题，一定还是字符集的问题。 <br><strong>处理方法：</strong>我们可以直接在参数文件中，加入</p> \n<pre><code>vim /etc/my.cnf\n[mysqld]\ninit-connect=\'SET NAMES utf8mb4\'\ncharacter-set-server=utf8mb4\n注：utf8mb4 是 utf8 的超集。</code></pre> \n<h5>Top 8：使用 binlog_format=statement 这种格式，跨库操作，导致从库丢失数据，用户访问导致出现错误数据信息。</h5> \n<pre><code>#当前数据库二进制日志的格式为：\nbinlog_format=statement\n在主库设置binlog-do-db=mydb1（只同步mydb1这一个库）\n在主库执行use mydb2；\ninsert into mydb1.t1 values (\'bb\');\n这条语句不会同步到从库。但是这样操作就可以；\nuse mydb1;\ninsert into mydb1.t1 values (\'bb\');\n因为这是在同一个库中完成的操作。\n#在生产环境中建议使用binlog的格式为row，而且慎用binlog-do-db参数。</code></pre> \n<h5>Top 9：MySQL 数据库连接超时的报错&nbsp;</h5> \n<pre><code>org.hibernate.util.JDBCExceptionReporter - SQL Error:0, SQLState: 08S01\norg.hibernate.util.JDBCExceptionReporter - The last packet successfully received from the server was43200 milliseconds ago.The last packet sent successfully to the server was 43200 milliseconds ago, which is longer than the server configured value of \'wait_timeout\'. You should consider either expiring and/or testing connection validity before use in your application, increasing the server configured values for client timeouts, or using the Connector/J connection \'autoReconnect=true\' to avoid this problem.\norg.hibernate.event.def.AbstractFlushingEventListener - Could not synchronize database state with session\norg.hibernate.exception.JDBCConnectionException: Could not execute JDBC batch update\ncom.mysql.jdbc.exceptions.jdbc4.MySQLNonTransientConnectionException: Connection.close() has already been called. Invalid operation in this state.\norg.hibernate.util.JDBCExceptionReporter - SQL Error:0, SQLState: 08003\norg.hibernate.util.JDBCExceptionReporter - No operations allowed after connection closed. Connection was implicitly closed due to underlying exception/error: \n** BEGIN NESTED EXCEPTION **\n#大多数做 DBA 的同学，可能都会被开发人员告知，你们的数据库报了这个错误了。赶紧看看是哪里的问题。</code></pre> \n<p>这个问题是由<code>两个参数影响的，wait_timeout 和 interactive_timeout。</code>数据默认的配置时间是28800（8小时）意味着，超过这个时间之后，MySQL 数据库为了节省资源，就会在数据库端断开这个连接，Mysql服务器端将其断开了，但是我们的程序再次使用这个连接时没有做任何判断，所以就挂了。</p> \n<h6>解决思路：</h6> \n<p>先要了解这两个参数的特性；这两个参数必须同时设置，而且必须要保证值一致才可以。 <br>我们可以适当加大这个值，8小时太长了，不适用于生产环境。因为一个连接长时间不工作，还占用我们的连接数，会消耗我们的系统资源。</p> \n<h6>解决方法：</h6> \n<p>可以适当在程序中做判断；强烈建议在操作结束时更改应用程序逻辑以正确关闭连接；然后设置一个比较合理的timeout的值（根据业务情况来判断）</p> \n<h5><strong>Top 10 ：can\'t open file (errno:24)</strong></h5> \n<p>有的时候，数据库跑得好好的，突然报不能打开数据库文件的错误了。</p> \n<h6>解决思路：</h6> \n<p>首先我们要先查看数据库的error log。然后判断是表损坏，还是权限问题。还有可能磁盘空间不足导致的不能正常访问表；操作系统的限制也要关注下；用 perror 工具查看具体错误！</p> \n<pre><code>linux:/usr/local/mysql/bin # ./perror 24\nOS error code &nbsp;24: &nbsp;Too many open files</code></pre> \n<p>超出最大打开文件数限制！ulimit -n查看系统的最大打开文件数是65535，不可能超出！那必然是数据库的最大打开文件数超出限制！ <br><code>在 MySQL 里查看最大打开文件数限制命令：show variables like \'open_files_limit\';</code> <br>发现该数值过小，改为2048，重启 MySQL，应用正常</p> \n<h5>处理方法：</h5> \n<pre><code>repair table ；\nchown mysql权限\n#清理磁盘中的垃圾数据</code></pre> \n<p><strong>今后还会继续总结 MySQL 中的各种报错处理思路与方法，希望跟各位老铁们，同学们一起努力。多沟通多交流！</strong></p> \n<p><strong>看到这里的各位老司机们，把此文转发出去吧，让更多的人成为老司机。</strong></p>', null, 'http://localhost:8060/tup/2020/4/23/a783454b96c44b7ba02e9b616eff6f78.jpg', '5ca4567d892841b087fac5246effac40', 'bb0b7e69ad3e46fcb121baefda8f1f78', '1a77ff8ac4c54e58b5e6b22210cff64f,83f62facb3b943ffa8e46abd1ebc64d9,d7416e100af54eb7a4d9274b9a462240,55723db96b9f4593bae02bc1e49f1e87,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-23 10:28:25', '2020-04-23 10:28:25');
INSERT INTO `tb_recommend` VALUES ('d2cb8073bc0341f8aedffb24de2740dd', 'DoKit - 滴滴开源的一款功能齐全的客户端（ iOS 、Android ）研发助手', 'SegmentFault 思否消息：滴滴技术团队今天宣布，Dokit 3.0 版本正式发布，DoraemonKit，简称 DoKit，中文名哆啦 A 梦，是滴滴开源的一款功能齐全的客户端（ iOS 、Android ）研发助手。', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p>SegmentFault 思否消息：滴滴技术团队今天宣布，Dokit 3.0 版本正式发布，DoraemonKit，简称 DoKit，中文名哆啦 A 梦，是滴滴开源的一款功能齐全的客户端（ iOS 、Android ）研发助手。</p> \n<p>每一个稍微有点规模的 App，总会自带一些线下的测试功能代码，比如环境切换功能、帧率查看功能等等，这些功能的切换入口往往放在各式各样的入口中，比如一些特殊的手势，双击 statusBar，双击某一个功能区块，或者新建一个 keyWindow 始终至于 App 最上方等等，而且每一个 App 里面的线下附带功能模块很多是相似的，比如帧率查看、内存和 CPU 监控等等，但是现在基本上都是每个 App 都是自己实现了一份，经历了以上的问题之后，DoraemonKit 就有了它存在的意义。</p> \n<p>DoraemonKit 是一个功能平台，能够让每一个 App 快速接入一些常用的或者你没有实现的一些辅助开发工具、测试效率工具、视觉辅助工具，而且能够完美在 Doraemon 面板中接入你已经实现的与业务紧密耦合的一些非通有的辅助工具，并搭配<a href=\"https://www.dokit.cn/\" rel=\"nofollow noreferrer\">dokit</a>平台，让功能得到延伸，接入方便，便于扩展。</p> \n<p><strong>简单总结</strong></p> \n<p>1、DoraemonKit 能够快速让你的业务测试代码能够在这里统一管理，统一收口； <br>2、DoraemonKit 内置很多常用的工具，避免重复实现，一次接入，你将会拥有强大的工具集合。 3、搭配<a href=\"https://www.dokit.cn/\" rel=\"nofollow noreferrer\">dokit</a>平台，方便你进行<strong>数据mock</strong>以及记录你的每一次<strong>健康体检</strong>用例</p> \n<h4>效果演示</h4> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022238554\" src=\"http://localhost:8060/tup/2020/4/23/e2bc1cb3a952471fbc5d69626a95ac55.jpg\" alt=\"DoKit 首页效果演示\" title=\"DoKit 首页效果演示\"></span></p> \n<h3><strong>DoKit 3.0 版本新特性</strong></h3> \n<p><strong>▍</strong><strong>优化点</strong></p> \n<ul> \n <li>DoKit 3.0 相比于上一个版本一共解决了 github 上的 issues 70 多个，合并 PR 30 多个；</li> \n <li>内部架构升级，其中性能和代码的健壮性都得到了显著的提升；</li> \n <li>工具优化用户体验优化。</li> \n</ul> \n<p><strong>Android</strong></p> \n<p>Android 端主要优化了网络拦截、悬浮窗、位置模拟、Aop 解决方案等等：</p> \n<ul> \n <li>网络拦截统一了 okhttp、urlconnection；</li> \n <li>悬浮窗新增了普通模式，不再需要系统悬浮窗权限；</li> \n <li>位置模拟现已支持百度、腾讯、高德、系统原生；</li> \n <li>AOP 的代码插装方案也由一开始的 Aspectj 改成了 ASM 方案，兼容性和性能也都有了明显的提升。</li> \n</ul> \n<p><strong>iOS</strong></p> \n<p>iOS 端主要优化了多个工具的用户体验、加速代码安装速度、减少对于业务方的影响等等：</p> \n<ul> \n <li>NSLog 监控、子线程 UI、CocoaLumberjack 日志日志监控等功能不需要重新启动 App 即可进行开关；</li> \n <li>pod 仓库多地备份（github、gitee、gitlab），解决 pod install 缓慢的问题；</li> \n <li>解决 DoKit 的 window 影响 UIMenuController 的吗，导致业务方在某些机型弹不出来的问题；</li> \n <li>减少代码 hook 对于全局的影响；</li> \n <li>全局支持中英文切换。</li> \n</ul> \n<p><strong>▍</strong><strong>新增工具</strong></p> \n<p>以下新增的大部分 Kit 在 Android 和 iOS 两端是对齐的，有些平台特有的功能会进行标注。</p> \n<p><strong>1）数据&nbsp;Mock</strong></p> \n<p>提供一套基于 App 网络拦截的接口 Mock 方案，无需修改代码即可完成对于接口数据的 Mock。</p> \n<p>了解详情：<a href=\"https://www.dokit.cn/#/index/productCenter\" rel=\"nofollow noreferrer\">https://www.dokit.cn/#/index/productCenter</a></p> \n<p>了解更多可以查看文章《<a href=\"https://mp.weixin.qq.com/s/hXaeH1nVELA2PJDfJqLlvw\" rel=\"nofollow noreferrer\">滴滴正式发布开源客户端研发助手DoKit 3.0，新特性解读</a>》</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFmMq\" src=\"http://localhost:8060/tup/2020/4/23/3d0154020e014c0eb992e3543d5ec92e.jpg\" alt=\"思否公众号\" title=\"思否公众号\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/3ad7b593700a4e589437a445b2338727.jpg', '5ca4567d892841b087fac5246effac40', '19eb3dd59ef8430d9f637d97449fc417', '448959a7e0394148ae465d890ed2bbd2,f3eb17e6e5664a97af3e9b1fca12b286,cf84afe221f24e72b201344b3e15fa85,bb08094058724cb5a595418407aa6c06', '0', '3', '1', '2020-04-23 10:59:15', '2020-04-23 10:59:15');
INSERT INTO `tb_recommend` VALUES ('d47309e0c643487d86338f884f50275a', '硬核干货！QPS、TPS、并发用户数、吞吐量关系', 'QPS Queries Per Second  是每秒查询率 ,是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。', '<h3><strong>1、QPS</strong></h3> \n<hr> \n<p><strong>QPS</strong>&nbsp;<code>Queries Per Second</code>&nbsp; 是每秒查询率 ,是<strong>一台服务器</strong>每秒能够相应的查询次数，是对一个特定的查询服务器<strong>在规定时间内</strong>所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。</p> \n<h3><strong>2、TPS</strong></h3> \n<hr> \n<p><strong>TPS&nbsp;</strong><code>Transactions Per Second</code>也就是事务数/秒。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数， </p> \n<p><strong>3、QPS和TPS区别</strong></p> \n<hr> \n<p>个人理解如下： </p> \n<p>1、Tps即每秒处理事务数，包括了</p> \n<ul> \n <li>用户请求服务器&nbsp;&nbsp;</li> \n <li>服务器自己的内部处理&nbsp;&nbsp;</li> \n <li>服务器返回给用户</li> \n</ul> \n<p>这三个过程，每秒能够完成N个这三个过程，Tps也就是N；</p> \n<p>2、Qps基本类似于Tps，但是不同的是，对于一个页面的一次访问，形成一个Tps；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“Qps”之中。</p> \n<p><strong>例子：</strong></p> \n<blockquote>\n 例如：访问一个页面会请求服务器3次，一次放，产生一个“T”，产生3个“Q”\n <p>例如：一个大胃王一秒能吃10个包子，一个女孩子0.1秒能吃1个包子，那么他们是不是一样的呢？答案是否定的，因为这个女孩子不可能在一秒钟吃下10个包子，她可能要吃很久。这个时候这个大胃王就相当于TPS，而这个女孩子则是QPS。虽然很相似，但其实是不同的。</p> \n</blockquote> \n<p><strong>4、并发数</strong></p> \n<hr> \n<p>并发数（并发度）：指系统同时能处理的请求数量，同样反应了系统的负载能力。这个数值可以分析机器1s内的访问日志数量来得到</p> \n<h3><strong>5、吐吞量</strong></h3> \n<hr> \n<p>吞吐量是指系统在单位时间内处理请求的数量，TPS、QPS都是吞吐量的常用量化指标。 </p> \n<p><strong>系统吞吐量要素</strong></p> \n<p>一个系统的吞吐量（承压能力）与request（请求）对cpu的消耗，外部接口，IO等等紧密关联。</p> \n<p>单个request 对cpu消耗越高，外部系统接口，IO影响速度越慢，系统吞吐能力越低，反之越高。</p> \n<p><strong>重要参数</strong> </p> \n<p>QPS(TPS),并发数，响应时间</p> \n<ul> \n <li>QPS(TPS)：每秒钟request/事务 数量</li> \n <li>并发数：系统同时处理的request/事务数</li> \n <li>响应时间：一般取平均响应时间</li> \n</ul> \n<p><strong>关系</strong></p> \n<p>QPS(TPS)=并发数/平均响应时间 </p> \n<p>一个系统吞吐量通常有QPS(TPS),并发数两个因素决定，每套系统这个两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换，内存等等其他消耗导致系统性能下降。</p> \n<h3><strong>6、PV</strong></h3> \n<hr> \n<p><strong>PV</strong>（Page View）：页面访问量，即页面浏览量或点击量，用户每次刷新即被计算一次。可以统计服务一天的访问日志得到。&nbsp;</p> \n<h3><strong>7、UV&nbsp;</strong></h3> \n<hr> \n<p><strong>UV</strong>（Unique Visitor）：独立访客，统计1天内访问某站点的用户数。可以统计服务一天的访问日志并根据用户的唯一标识去重得到。响应时间（RT）：响应时间是指系统对请求作出响应的时间，一般取平均响应时间。可以通过Nginx、Apache之类的Web Server得到。&nbsp;</p> \n<h3><strong>8、DAU</strong></h3> \n<hr> \n<p><strong>DAU</strong>(Daily Active User)，日活跃用户数量。常用于反映网站、互联网应用或网络游戏的运营情况。DAU通常统计一日（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户），与UV概念相似&nbsp;</p> \n<h3><strong>9、MAU</strong></h3> \n<hr> \n<p><strong>MAU</strong>(Month Active User)：月活跃用户数量，指网站、app等去重后的月活跃用户数量</p> \n<h2><strong>10、系统吞吐量评估</strong></h2> \n<hr> \n<p>我们在做系统设计的时候就需要考虑CPU运算，IO，外部系统响应因素造成的影响以及对系统性能的初步预估。 </p> \n<p>而通常情况下，我们面对需求，我们评估出来的出来QPS，并发数之外，还有另外一个维度：日pv。</p> \n<p>通过观察系统的访问日志发现，在用户量很大的情况下，各个时间周期内的同一时间段的访问流量几乎一样。比如工作日的每天早上。只要能拿到日流量图和QPS我们就可以推算日流量。</p> \n<p>通常的技术方法：</p> \n<p>1、找出系统的最高TPS和日PV，这两个要素有相对比较稳定的关系（除了放假、季节性因素影响之外）</p> \n<p>2、通过压力测试或者经验预估，得出最高TPS，然后跟进1的关系，计算出系统最高的日吞吐量。B2B中文和淘宝面对的客户群不一样，这两个客户群的网络行为不应用，他们之间的TPS和PV关系比例也不一样。</p> \n<h2><strong>11、软件性能测试的基本概念和计算公式</strong></h2> \n<hr> \n<p><strong>软件做性能测试时需要关注哪些性能呢？</strong> </p> \n<p>首先，开发软件的目的是为了让用户使用，我们先站在用户的角度分析一下，用户需要关注哪些性能。</p> \n<p>对于用户来说，当点击一个按钮、链接或发出一条指令开始，到系统把结果已用户感知的形式展现出来为止，这个过程所消耗的时间是用户对这个软件性能的直观印 象。也就是我们所说的响应时间，当相应时间较小时，用户体验是很好的，当然用户体验的响应时间包括个人主观因素和客观响应时间，在设计软件时，我们就需要 考虑到如何更好地结合这两部分达到用户最佳的体验。如：用户在大数据量查询时，我们可以将先提取出来的数据展示给用户，在用户看的过程中继续进行数据检 索，这时用户并不知道我们后台在做什么。</p> \n<p>用户关注的是用户操作的相应时间。</p> \n<p>其次，我们站在管理员的角度考虑需要关注的性能点。</p> \n<p>1、 响应时间 <br>2、 服务器资源使用情况是否合理 <br>3、 应用服务器和数据库资源使用是否合理 <br>4、 系统能否实现扩展 <br>5、 系统最多支持多少用户访问、系统最大业务处理量是多少 <br>6、 系统性能可能存在的瓶颈在哪里 <br>7、 更换那些设备可以提高性能 <br>8、 系统能否支持7×24小时的业务访问</p> \n<p>再次，站在开发（设计）人员角度去考虑。</p> \n<p>1、 架构设计是否合理 <br>2、 数据库设计是否合理 <br>3、 代码是否存在性能方面的问题 <br>4、 系统中是否有不合理的内存使用方式 <br>5、 系统中是否存在不合理的线程同步方式 <br>6、 系统中是否存在不合理的资源竞争</p> \n<blockquote>\n 来源：&nbsp;\n <br>\n <a href=\"https://juejin.im/post/5c2cb5e15188257a937fbfaf?utm_source=gold_browser_extension\" rel=\"nofollow noreferrer\">https://juejin.im/post/5c2cb5...</a> \n</blockquote> \n<p>最新整理的&nbsp;<strong>2TB</strong>&nbsp;技术干货：包括<strong>架构师实战教程、大数据、Docker容器、系统运维、数据库、redis、MogoDB、电子书、Java基础课程、Java实战项目、ELK Stack、机器学习、BAT面试精讲视频</strong>等。只需在<strong>「&nbsp;</strong><strong>民工哥技术之路」</strong>微信公众号对话框回复关键字：<strong>1024</strong>即可获取全部资料。</p>', null, null, '3f69fcc9b13843d1910b3dac597f5215', '04547238127a4676b504cc4496865d7b', 'd7416e100af54eb7a4d9274b9a462240,77a7bd638e0a45ec84569ef6b79325c1,81a4561c1c294e0cae32c9fe6b5dc397,f0e336796bd94b8299ef69b2b2529ec4,f2fb7d236fec4c138cacd9162eb4488c', '0', '3', '1', '2020-04-23 10:58:39', '2020-04-23 10:58:39');
INSERT INTO `tb_recommend` VALUES ('d47729771919465097dcdbcd254e6c34', '基于 HTML5 WebGL 的高炉炼铁厂可视化系统', '在当今 工业4.0 新时代的推动下，不仅迎来了 工业互联网 的发展，还开启了5G时代的新次元。而伴随着带宽的提升，网络信息飞速发展，能源管控上与实时预警在工业互联网中也占着举足轻重的地位，而对于高炉炼铁的发...', '<p><strong>前言</strong></p> \n<p>在当今 <strong>工业4.0</strong> 新时代的推动下，不仅迎来了 <strong>工业互联网</strong> 的发展，还开启了<strong>5G</strong>时代的新次元。而伴随着带宽的提升，网络信息飞速发展，能源管控上与实时预警在工业互联网中也占着举足轻重的地位，而对于高炉炼铁的发展上来看，目前已完成国内260座高炉的数字化和智能化落地，并推动炼铁大数据平台在俄罗斯、越南、伊朗、印尼等“一带一路”国家钢铁企业中应用，充分体现了高炉智能化大屏产业应运而生。我们将使用<strong>Hightopo</strong>（以下简称 HT ）的<strong>HT for Web</strong>产品上的<strong>web</strong>组态跟大家介绍一下通过 2/3D 融合搭建的高炉炼铁厂可视化系统。</p> \n<p>HT 可以快速实现丰富的 <strong>2D 组态</strong>和<strong>3D 组态</strong>效果，可以根据需求发挥自己的想象，玩转很多新奇的功能，并且通过优势互补的作用下，完善出一套完整的可视化系统解决方案。所以在可视化系统的实现上，3D 场景采用以<strong>HT</strong> 轻量化 HTML5/WebGL 建模的方案，实现快速建模、运行时轻量化到甚至手机终端浏览器即可 3D 可视化运维的良好效果；而在对应的 2D 图纸上，使用特有的矢量，在各种比例下不失真，加上布局机制，解决了不同屏幕比例下的展示问题。</p> \n<p>本文将从以下三个方面与大家分享高炉炼铁厂在大屏展示上的实现：</p> \n<p>1、<strong>页面搭建</strong>：介绍基础的 2D 图纸与 3D 场景融合的项目搭建；</p> \n<p>2、<strong>数据对接</strong>：进行面板数据的对接展示；</p> \n<p>3、<strong>动画实现</strong>：铁水罐车运输、传送带运送以及场景漫游的实现；</p> \n<p><strong>界面简介及效果预览</strong></p> \n<p>在整个高炉炼铁厂可视化系统的 2D 面板上，呈现了昨日历史与今日实时的一些重要预警数据，在管控上能起到实时监控的作用，也能与历史数据进行对比，从而使生产与安全达到预期的预警效果；其次 3D 场景通过轻量化的模型呈现出一座高炉炼铁厂的基本运作流程以及铁水罐车运送钢铁的动画，加上环绕的漫游效果，起到全方位的实时监控状态的变化。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022436640\" src=\"http://localhost:8060/tup/2020/4/23/cf5f0dda0b4742c7a2432c770b699050.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>代码实现</strong></p> \n<p><strong>一、页面搭建</strong></p> \n<p>在内容实现上，采用了 HT 轻量化模型以及 web 组态，以 2/3D 结合的方式，通过的 json 反序列化得到 2D 图纸和 3D 场景的完整呈现。首先会通过创建 <strong>ht.graph.GraphView</strong>和<strong>ht.graph3d.Graph3dView</strong>来呈现 2D 和 3D 的内容。 2D 视图组件和 3D 视图组件进行 deserialize() 反序列化对应的 url 寄存的 json 呈现出场景与图纸的内容，两者通过对数据模型 DataModel 里的子元素设置标签来进行数据绑定，实现功能上的展示。</p> \n<pre><code>// 三维拓扑视图\nlet g2d = new ht.graph.GraphView();\nlet g3dDm = g2d.dm();\n// 三维拓扑视图\nlet g3d = new ht.graph3d.Graph3dView();\nlet g3dDm = g3d.dm(); \n// 2D 视图组件和 3D 视图组件进行反序列化\ng2d.deserialize(\'displays/index.json\');\ng3d.deserialize(\'scenes/index.json\');</code></pre> \n<p>在内容呈现上还需要将组件加入到 body 下，一般 2/3D 结合的项目上，都会使用 2D 组件加入到 3D 组件的根 div 下，然后 3D 组件再加入到 body下的方式实现面板与场景的加载。</p> \n<pre><code>// 将 3D 组件加入到 body 下\ng3d.addToDOM();\n// 将 2D 组件加入到 3D 组件的根 div 下，父子 DOM 事件会冒泡，这样不会影响 3D 场景的交互\ng2d.addToDOM(g3d.getView());</code></pre> \n<p>同时，在交互与呈现上改变了一些实现方式。例如，修改了左右键的交互方式，设置左键点击旋转 3D 场景，右键点击为 pan 抓图的场景移动方式。其次，在点击 2D 有点到图元像素时，我们希望不触发 3D 的交互，例如在对 2D 面板表格中用滚轮滑动的时候，会触发 3D 场景的缩放，这里通过监听 moudedown、touchstart 和 wheel 三种交互来进行控制，对于 wheel 的监听方式，为了保证兼容性就通过封装一个 getWheelEventName() 的方法来得到事件名。</p> \n<pre><code>// 修改左右键交互方式\nlet mapInteractor = new ht.graph3d.MapInteractor(this.g3d);\ng3d.setInteractors([mapInteractor]);\n// 设置修改最大仰角为 PI / 2\nmapInteractor.maxPhi = Math.PI / 2;\n\n// 避免 2D 与 3D 交互重叠\nlet div2d = g2d.getView();\nconst handler = e =&gt; {\n    if (g2d.getDataAt(e)) {\n        e.stopPropagation();\n    }\n};\ndiv2d.addEventListener(\'mousedown\', handler);\ndiv2d.addEventListener(\'touchstart\', handler);\ndiv2d.addEventListener(getWheelEventName(div2d), handler);\n\n// 在一个 HTMLElement 上，可能支持下面三个事件的一种或者两种，但实际回调只会回调一种事件，优先回调标准事件，触发标准事件后，不会触发兼容性事件\nfunction getWheelEventName(element) {\n    if (\'onwheel\' in element) {\n// 标准事件\n        return \'wheel\';\n    } else if (document.onmousewheel !== undefined) {\n// 通用旧版事件\n        return \'mousewheel\';\n    } else {\n// 旧版 Firefox 事件\n        return \'DOMMouseScroll\';\n    }\n}</code></pre> \n<p><strong>二、数据对接</strong></p> \n<p>在 2D 面板的呈现上，会有许多的图表数据信息，我们可以通过访问后台数据接口得到数据，然后在 2D 或者 3D 对应的组件上取得相应的数据模型 dataModel，通过对数据模型里设置唯一的标识 tag 的子节点进行对接数据就可以了。例如现在我们要对 2D 面板的数据进行绑定，我们只需要通过 2D 组件的 g2d 得到数据模型，通过 g2d.dm().getDataByTag(tag) 就可以得到设置有唯一标识的 tag 节点，来对接数据或者设置状态展示了。</p> \n<p>对于数据接口的获取，可以运用主流的 jQuery 框架下的<strong>ajax</strong>、基于 promise 的 HTTP 库的<strong>axios</strong> 通过轮询调用接口实时获取数据或者使用 HTML5 提供的一种在单个 TCP 连接上进行全双工通讯的协议<strong>WebSocket</strong>，可以双向进行数据传输，在选择运用上可以匹配自己的实现需求，而本系统是采用通过 axios 调用接口获取实时数据。</p> \n<pre><code>// 昨日利用系数数据对接\naxios.get(\'/yesterdayUse\').then(res =&gt; {\n    setBindingDatasWithAnim(dm, res, undefined, v =&gt; v.toFixed(2));\n});\n// 昨日燃料比数据对接\naxios.get(\'/yesterdayFuel\').then(res =&gt; {\n    setBindingDatasWithAnim(dm, res, undefined, v =&gt; v.toFixed(2));\n});\n// 昨日入炉品位数据对接\naxios.get(\'/yesterdayIn\').then(res =&gt; {\n    setBindingDatasWithAnim(dm, res, undefined, v =&gt; v.toFixed(2));\n});\n// 昨日燃气利用率数据对接\naxios.get(\'/yesterdayCoal\').then(res =&gt; {\n    setBindingDatasWithAnim(dm, res, undefined, v =&gt; v.toFixed(2));\n});\n// 实时警报信息面板表格轮询载入数据进行滚动播放\nthis.addTableRow();\nsetInterval(() =&gt; {\n    this.addTableRow();\n}, 5000);</code></pre> \n<p>通过 axios 轮询调用接口，实时获取安全指数和实时数据信息（风量、风温和富氧量）：</p> \n<pre><code>requestData() {\n    let dm = this.view.dm();\n    // 安全指数数据对接并载入圆环动画\n    axios.get(\'/levelData\').then(res =&gt; {\n        setBindingDatasWithAnim(dm, res, 800, v =&gt; Math.round(v));\n    });\n    // 实时数据(风量、风温和富氧量)数据对接并载入进度条动画\n    axios.post(\'/nature\', [\n        \'windNumber\', \'windTemp\', \'oxygenNumber\'\n    ]).then(res =&gt; {\n        setBindingDatasWithAnim(dm, res, 800, v =&gt; parseFloat(v.toFixed(1)));\n    });\n}</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022436641\" src=\"http://localhost:8060/tup/2020/4/23/b1e345f84a714adc8439b2a1200d6784.jpg\" alt=\"\" title=\"\"></span><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022436642\" src=\"http://localhost:8060/tup/2020/4/23/ff727b3e4200441783bc48e0f962119c.jpg\" alt=\"\" title=\"\"></span></p> \n<p>对接数据后，实现一些圆环或者进度条值的增减动画，其本质上是运用 HT 自带的动画函数 <a href=\"https://www.hightopo.com/guide2/ht/guide/core/beginners/ht-beginners-guide.html?search=startAnim&amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0\" rel=\"nofollow noreferrer\">ht.Default.startAnim()</a>，通过判断数据绑定的属性后，设定新值与旧值差额的范围动画，然后用户定义函数 easing 参数通过数学公式来控制动画的运动的快慢，例如匀速变化、先慢后快等效果。</p> \n<p>这里通过动画函数封装了一个差值的动画效果，参数如下：</p> \n<ul> \n <li> <strong>node</strong>：动画处理的节点；</li> \n <li> <strong>name</strong>：数据绑定的名称；</li> \n <li> <strong>value</strong>：数据绑定的值；</li> \n <li> <strong>format</strong>：绑定数据值的格式规范；</li> \n <li> <strong>accesstype</strong>：数据绑定的属性从属 ；</li> \n <li> <strong>duration</strong>：动画时间；</li> \n</ul> \n<pre><code>    }\n    // 默认通过取值器 getter 得到数据绑定的值\n    else {\n        oldValue = node[ht.Default.getter(name)]();\n    }\n    // 设置新旧值的差额\n    let range = value - oldValue;\n    // 执行动画函数\n    ht.Default.startAnim({\n        duration: duration,\n        easing: function (t) { return 1 - (--t) * t * t * t; },\n        action: (v, t) =&gt; {\n            // 新值增长的动画范围\n            let newValue = oldValue + range * v;\n            // 判断有格式则制定数据格式\n            if (format) {\n                newValue = format(newValue);\n            }\n            // 判断数据绑定为自定义属性 attr 后设定新值\n            if (accesstype === \'a\') {\n                node.a(name, newValue);\n            }\n            // 判断数据绑定为样式属性 style 后设定新值\n            else if (accesstype === \'s\') {\n                node.s(name, newValue);\n            }\n            // 默认通过存值器 setter 设置数据绑定的新值\n            else {\n                node[ht.Default.setter(name)]()(node, newValue);\n            }\n        }\n    });\n}</code></pre> \n<p>我们时常会在公开的预警场合或者宣传场合看见轮播滚动的数据信息，采用这种方法在公示的同时也不会遗漏掉任何一条数据信息，如果搭配上一些例如淡入淡出的过场效果，更会吸引关注的眼球。而对于实时警报信息的面板表格的实现，也是在添加新数据时，实现了一种过渡的 UI 交互上的沉浸感，主要还是运用了 HT 自带的动画函数 <a href=\"https://www.hightopo.com/guide2/ht/guide/core/beginners/ht-beginners-guide.html?search=startAnim&amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0\" rel=\"nofollow noreferrer\">ht.Default.startAnim()</a>，横向通过滚动 100 宽度并数据透明度慢慢浮现，纵向采用向下偏移一行表格行高 54 来添加新的警报信息。</p> \n<pre><code>addTableRow() {\n    // 获取表格节点\n    let table = this.right3;\n    // 通过 axios 的 promise 请求接口数据\n    axios.get(\'getEvent\').then(res =&gt; {\n        // 获取表格节点滚动信息的数据绑定\n        let tableData = table.a(\'dataSource\');\n        // 通过向 unshift() 方法可向滚动信息数组的开头添加一个或更多元素\n        tableData.unshift(res);\n        // 初始化表格的纵向偏移\n        table.a(\'ty\', -54);\n        // 开启表格滚动动画\n        ht.Default.startAnim({\n            duration: 600,\n            // 动画执行函数 action\n            action: (v, t) =&gt; {\n                table.a({\n                    // 通过添加数据后，横向滚动 100\n                    \'firstRowTx\': 100 * (1 - v),\n                    // 第一行行高出现的透明度渐变效果\n                    \'firstRowOpacity\': v,\n                    // 纵向偏移 54 的高度\n                    \'ty\': (v - 1) * 54\n                });\n            }\n        });\n    });\n}</code></pre> \n<p><strong>三、动画实现</strong></p> \n<p>在静态的场景以及面板下，很难直观地去体现一个 2/3D 嵌合的系统的优越性。动画却是赋予生命灵魂的所在，一个恰到好处的 UI 动画设计可以使面板的交互体验鲜活起来，而在 3D 场景中，通过一组简单形象的铁水罐车运输和传送带运送可以让人清晰地明白生产运输的流程，对于模型建筑的管控，利用好视角切入点，我们可以设置全方位的沉浸式漫游巡视。综上，通过轻量模型场景与矢量组件面板的优势叠加，可以呈现出一套灵活的高炉炼铁厂生产预警系统。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022436643\" src=\"http://localhost:8060/tup/2020/4/23/0ff9ce7bed0741a88b7ea9c8fb951326.jpg\" alt=\"\" title=\"\"></span></p> \n<p>在漫游巡视下，为了更全方位地体现场景，我们通过裁剪的方式来显示和隐藏两侧的面板数据，以下以隐藏面板的裁剪动画为例：</p> \n<pre><code>hidePanel() {\n    // 将左侧数据绑定裁剪的子元素存放进一个数组里\n    let leftStartClipIndexs = (() =&gt; {\n        let arr = [];\n        for (let i = 1; i &lt;= 4; i++) arr.push(this[\'left\' + i].s(\'clip.percentage\'));\n        return arr;\n    })();\n    // 将右侧数据绑定裁剪的子元素存放进一个数组里\n    let rightStartClipIndexs = (() =&gt; {\n        let arr = [];\n        for (let i = 1; i &lt;= 3; i++) arr.push(this[\'right\' + i].s(\'clip.percentage\'));\n        return arr;\n    })();\n    // 设置面板裁剪的延迟时间，使得视觉上更有层次感\n    let delayArrays = [400, 800, 1200, 1600];\n    // 动画执行函数\n    let action = (index) =&gt; {\n        ht.Default.startAnim({\n            duration: 700,\n            easing: Easing.swing,\n            action: (v, t) =&gt; {\n                this[\'left\' + index].s(\'clip.percentage\', leftStartClipIndexs[index - 1] + (0 - leftStartClipIndexs[index - 1]) * v);\n                this[\'right\' + index].s(\'clip.percentage\', rightStartClipIndexs[index - 1] + (0 - rightStartClipIndexs[index - 1]) * v);\n            }\n        });\n    };\n    // 通过判定延迟时间数组的长度，回调 action 动画的执行\n    for (let i = 0, l = delayArrays.length; i &lt; l; i++) {\n        ht.Default.callLater(action, this, [i + 1], delayArrays.shift());\n    }\n}</code></pre> \n<p>data.s(\'clip.percentage\') 是 HT 节点自带的样式属性，其本质意义就是可以通过指定的方向进行对于整个矢量图标的裁剪：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022436644\" src=\"http://localhost:8060/tup/2020/4/23/d2df407475d249489c47325a94d93c8a.jpg\" alt=\"\" title=\"\"></span></p> \n<p>一部电影可以通过各种镜头的切换下呈现不尽相同的叙事效果，日剧夕阳下热血跑的急速切换或者幽暗角落下惊恐的淡入淡出，都是一种叙事的处理手段。在 HT 设定的 3D 场景中同样地也存在着许许多多叙述的手法，最为基础的设定就是通过场景中的主观眼睛<strong>eye</strong>和场景中心<strong>center</strong>来搭配各种动画的实现，可以自己设定值的方法函数来修改，也可以通过 HT 自身封装的方法函数来处理，例如<a href=\"https://www.hightopo.com/guide2/ht/guide/core/3d/ht-3d-guide.html?search=flyTo&amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0\" rel=\"nofollow noreferrer\">flyTo()</a>和<a href=\"https://www.hightopo.com/guide2/ht/guide/core/3d/ht-3d-guide.html?search=moveCamera&amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0\" rel=\"nofollow noreferrer\">moveCamera()</a>就是最为基础的相机动画，有兴趣的话可以了解一下，自己动手尝试搭配，肯定能最大地发挥 3D 场景的优势所在。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022436649\" src=\"http://localhost:8060/tup/2020/4/23/69ea1d0a30f749eaa9a8d9fa63b37267.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>漫游动画是为了更好地从不同的视角去巡视场景，只要通过设置几组眼睛视角，运用<strong>HT</strong>的<a href=\"https://www.hightopo.com/guide2/ht/guide/core/3d/ht-3d-guide.html?search=moveCamera&amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0\" rel=\"nofollow noreferrer\">moveCamera()</a>相机视角移动的动画，依次去对应眼睛的视角就可以自动地切换不同视角下场景的效果。</p> \n<pre><code>// 默认设置的眼睛视角数组\nconst ROAM_EYES = [\n    [1683.6555274005063, 939.9999999999993, 742.6554147474625],\n    [1717.1004359371925, 512.9256996098727, -1223.5575465999652],\n    [-181.41773461002046, 245.58303266170844, -2043.6755074222654],\n    [-1695.7113902533574, 790.0214102589537, -877.645744191523],\n    [-1848.1700283399357, 1105.522705042774, 1054.1519814237804],\n    [-108, 940, 1837]\n];\n// 开启相机移动漫游动画\nplayRoam() {\n    // 设置场景眼睛视角\n    let eye = ROAM_EYES[this.roamIndex];\n    // 开启相机视角移动动画 moveCamera\n    this._roamAnim = this.view.moveCamera(eye, [0, 0, 0], {\n        duration: this.roamIndex ? 3000 : 4000,\n        easing: Easing.easeOut,\n        finishFunc: () =&gt; {\n            this.roamIndex ++;\n            let nextEye = ROAM_EYES[this.roamIndex];\n            // 判断是否有下一组眼睛视角，有的话继续执行相机视角移动动画，反之则重置漫游动画\n            if (nextEye) {\n                this.playRoam();\n            }\n            else {\n                // 事件派发执行显示面板动画\n                event.fire(EVENT_SHOW_PANEL);\n                this.resetRoam();\n            }\n        }\n    });\n}</code></pre> \n<p>如果说场景视角漫游是一种大局<strong>整体</strong>观的体现，那么铁水罐车装载与运输以及传送带的运送则是一个高炉炼铁流程的<strong>拼图</strong>。通过一系列动画流程的表达，你会很清晰地发现，特定的 3D 场景下的讲解说明具有完整的故事串联性。</p> \n<p>以下是铁水罐车装载与运输的动画流程：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022436645\" src=\"http://localhost:8060/tup/2020/4/23/b4165ef0c539408cba42d761c55791de.jpg\" alt=\"\" title=\"\"></span></p> \n<p>在 3D 场景中是用 x, y, z 来分别表示三个轴，通过不断修改节点的 3D 坐标就可以实现位移效果 car.setPosition3d(x, y, z)，而对于铁水罐车上的装载标签则使用吸附的功能，使其吸附在铁水罐车上就能跟着一起行驶移动，然后在指定的空间坐标位置上通过 car.s(\'3d.visible\', true | false) 来控制铁水罐车的出现与隐藏的效果。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022436646\" src=\"http://localhost:8060/tup/2020/4/23/489e41609bfd46c1addd0fe74021704d.jpg\" alt=\"\" title=\"\"></span></p> \n<p>而关于传送带上煤块、铁矿的传输和管道气体流通的指示，通过使用 UV 纹理贴图的偏移来实现会方便很多，先来看看效果上的呈现：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022436647\" src=\"http://localhost:8060/tup/2020/4/23/ed6eed7b1e3846f89caa057cf4040479.jpg\" alt=\"\" title=\"\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022436648\" src=\"http://localhost:8060/tup/2020/4/23/7a685f58f3c84083af54baaba57cc97e.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br> 对于三维模型，有两个重要的坐标系统，就是顶点的位置坐标（X、Y、Z）以及 UV 坐标。形象地说，UV 就是贴图影射到模型表面的依据，U 和 V 分别是图片在显示器水平、垂直方向上的坐标，取值一般都是0~1。而传送带以及管道的指示就是用这种方法实现的，HT 的模型节点自带 uv 值的样式属性，我们只需要不断地控制其偏移变化，就能实现传输的效果：</p> \n<pre><code>// 设置初始偏移值\nlet offset1 = 0, trackOffset = 0;\n// 一直调用设置偏移值\nsetInterval(() =&gt; {\n    flows.each(node =&gt; {\n        node.s({\n            \'top.uv.offset\': [-offset1, 0],\n            \'front.uv.offset\': [-offset1, 0],\n        });\n    });\n    track.s(\'shape3d.uv.offset\', [0, -trackOffset]);\n    // 偏移值增加\n    offset1 += 0.1;\n    trackOffset += 0.03;\n}, 100);</code></pre> \n<p><strong>总结</strong></p> \n<p><strong>数字化</strong> 和 <strong>智能化</strong>大屏管控是 <strong>工业互联网</strong> 的发展趋势，在很大程度上解放了人力和劳力，在信息飞速传讯的时代，大数据可视化和智能管控的结合，会演绎出许多惊奇的效果碰撞。对实时数据监管下，预警信息也相当重要，保障生产有序进行的同时，我们也要关注安全问题，所以在大屏上呈现的许多内容，都极其具有行业跟上工业互联网的步伐代表性。</p> \n<p>2019 我们也更新了数百个工业互联网 2D/3D 可视化案例集，在这里你能发现许多新奇的实例，也能发掘出不一样的工业互联网：<a href=\"https://mp.weixin.qq.com/s/ZbhB6LO2kBRPrRIfHlKGQA\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/ZbhB6LO2kBRPrRIfHlKGQA</a></p> \n<p>同时，你也可以查看更多案例及效果：<a href=\"https://www.hightopo.com/demos/index.html\" rel=\"nofollow noreferrer\"><strong>https://www.hightopo.com/demos/index.html</strong></a></p>', null, 'http://localhost:8060/tup/2020/4/23/55e7f73c9e1c4d3d82e1ca755cf58493.jpg', '6fbfa4aaad3a43458f21c8acf0038ac5', '049b3bd76c1e49ccbe48b36197e77f76', 'd79254c4ca5e45dca9d484307c935281,63c4e1e7ec204b43a62065a3ced4c2ce,401f1c4dcfbc499e8f7129c091c299f8,32f02ee5a7a04ecfb8e8f2fb56594929,e75baefb206a4efe959a99aad77632a3', '0', '3', '1', '2020-04-23 10:25:39', '2020-04-23 10:25:39');
INSERT INTO `tb_recommend` VALUES ('d49b31a72e684b4c8672ad5d88a6336e', 'GitHub 宣布向所有团队免费开放核心功能，高级企业功能月费大幅下调', '今天凌晨，GitHub 官方发布公告表示向所有团队免费开放核心功能。无论是个人免费账户还是商业项目团队，都可访问 GitHub 的无限私有存储库。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF3FJ\" src=\"http://localhost:8060/tup/2020/4/23/68305e8745e541e7a951eef705722f20.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>技术编辑：王治治丨发自 SiFou NewOffice <br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>今天凌晨，GitHub 官方发布公告表示向所有团队免费开放核心功能。无论是个人免费账户还是商业项目团队，都可访问 GitHub 的无限私有存储库。</p> \n<p>另外还提供每月 2000 分钟的 GitHub Actions 访问，后者是该公司的自动化和 CI / CD 平台。</p> \n<p>不过如想要使用高级企业功能的项目团队（例如 SAML 支持），仍需付费升级体验。不过当前月费已从 9 美元调整到 4 美元，企业套餐则是 21 美元起步。</p> \n<p>Nat Friedman 表示：“我们正在将 GitHub 从按隐私付费的模式，转向以功能为主的免费增值体验，以希望吸引全球所有开发者和团队”。</p> \n<p>目前 GitHub 已汇聚超过 4000 万开发人员，预计可在 2025 年达到 1 个亿。</p> \n<hr> \n<p>对于此事，SegmentFault 思否社区用户 <a href=\"https://segmentfault.com/u/jysperm\">@王子亭</a>发表了如下观点：</p> \n<blockquote>\n 现在 GitHub 不再有盈利压力，于是扩展了 CI、Package Registry 等业务，收购了 npm，对核心服务进行降价或直接免费。这些举措想必会对其他独立的代码托管平台的商业模式造成很大的影响，破坏整个开发者服务市场的平衡，新的垄断很可能正在形成。\n <p>以后对于开发者服务创业来说，最大的问题可能就是「你们的产品要是被 GitHub 抄了并且免费了，你怎么办？」。要是 GitHub 回头做个 serverless 平台的话 ... 想想就可怕。</p> \n</blockquote> \n<p>原文链接：<a href=\"https://github.blog/2020-04-14-github-is-now-free-for-teams/\" rel=\"nofollow noreferrer\">https://github.blog/2020-04-1...</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFyLB\" src=\"http://localhost:8060/tup/2020/4/23/f533e01d70c841d08471a8efe215e8fb.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/5da9db786521481cb6c52c073ebd91d1.jpg', '1894b118d35d44cb8fe8009529c4154b', '2a353971222c4aff8e8d3e9c370330cd', '634b81d655c74cb0adc4d0aa362b8819,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-23 11:00:46', '2020-04-23 11:00:46');
INSERT INTO `tb_recommend` VALUES ('d87286f52ea049c7a72a931f585e8d23', 'Java 8 函数式编程：Lambda 表达式和方法引用', '在很多其他语言中，函数是一等公民。例如 JavaScript 中，函数（Function）和字符串（String）、数字（Number）、对象（Object）等一样是一种数据类型。可以这样定义函数：', '<h2>背景</h2> \n<p>在很多其他语言中，函数是一等公民。例如 JavaScript 中，函数（Function）和字符串（String）、数字（Number）、对象（Object）等一样是一种数据类型。可以这样定义函数：</p> \n<pre><code class=\"javascript\">var myFunction = function () {\n    doSomething();\n};</code></pre> \n<p>也可以将函数作为参数：</p> \n<pre><code class=\"javascript\">setTimeout(function() { \n    doSomething(); \n}, 1000);</code></pre> \n<p>在 Java 中，函数不是一等公民。如果想要像其他语言一样定义一个函数，只能通过定义一个接口来实现，例如 <code>Runnable</code>。</p> \n<p>在 Java 8 之前，可以通过匿名类的方式来创建 <code>Runnable</code>：</p> \n<pre><code class=\"java\">Thread thread = new Thread(new Runnable() {\n    public void run() {\n        doSomethong();\n    }\n});\nthread.start();</code></pre> \n<p>Java 8 中可以通过 lambda 表达式来创建：</p> \n<pre><code class=\"java\">Thread thread = new Thread(() -&gt; doSomethong());\nthread.start();</code></pre> \n<p>也就是：</p> \n<pre><code class=\"java\">Runnable runnable = new Runnable() {\n    public void run() {\n        doSomethong();\n    }\n};</code></pre> \n<p>简化成了：</p> \n<pre><code class=\"java\">Runnable runnable = () -&gt; doSomethong();</code></pre> \n<p>是不是看起来像 JavaScript 的函数定义：</p> \n<pre><code class=\"javascript\">var myFunction = function () {\n    doSomething();\n};</code></pre> \n<h2>@FunctionalInterface</h2> \n<blockquote>\n An informative annotation type used to indicate that an interface type declaration is intended to be a functional interface as defined by the Java Language Specification. Conceptually, a functional interface has exactly one abstract method.\n</blockquote> \n<p><code>@FunctionalInterface</code> 注解用于表明一个接口是函数式接口（functional interface）。函数式接口必须有且只有一个抽象方法。</p> \n<p>例如 <code>java.lang.Runnable</code> 就是一个函数式接口，有且仅有一个抽象方法 <code>run</code> 。<code>Runnable</code> 源码中就有加上注解 <code>@FunctionalInterface</code> ：</p> \n<pre><code class=\"java\">@FunctionalInterface\npublic interface Runnable {\n    public abstract void run();\n}</code></pre> \n<blockquote>\n Note that instances of functional interfaces can be created with lambda expressions, method references, or constructor references.\n</blockquote> \n<p>函数式接口实例可以通过 lambda 表达式、方法引用（method reference）、构造方法引用（constructor reference）的方式来创建。</p> \n<blockquote>\n However, the compiler will treat any interface meeting the definition of a functional interface as a functional interface regardless of whether or not a FunctionalInterface annotation is present on the interface declaration.\n</blockquote> \n<p>编译器会把满足函数式接口定义（有且只有一个抽象方法）的任何接口视为函数式接口 ，无论有没有 <code>@FunctionalInterface</code> 注解。</p> \n<p>以上两条总结一下：当一个接口符合函数式接口定义（有且只有一个抽象方法），那么就可以通过 lambda 表达式、方法引用的方式来创建，无论该接口有没有加上 <code>@FunctionalInterface</code> 注解。</p> \n<p>下面列出一些 Java 中的函数式接口：</p> \n<ul> \n <li><code>java.lang.Runnable</code></li> \n <li><code>java.util.concurrent.Callable</code></li> \n <li><code>java.util.Comparator</code></li> \n <li> <code>java.util.function</code> 包下的函数式接口，例如 <code>Predicate</code>、<code>Consumer</code>、<code>Function</code>、<code>Supplier</code> 等</li> \n</ul> \n<h2>java.util.function</h2> \n<p>在 <code>java.util.function</code> 包下，定义了大量的函数式接口，每个接口都有且只有一个抽象方法，这些接口的区别在于其中的抽象方法的参数和返回值不同。</p> \n<table> \n <thead>\n  <tr> \n   <th>类型</th> \n   <th>参数个数</th> \n   <th>参数类型</th> \n   <th>返回值类型</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td><code>Function&lt;T,R&gt;</code></td> \n   <td>1</td> \n   <td>T</td> \n   <td>R</td> \n  </tr> \n  <tr> \n   <td><code>IntFunction&lt;R&gt;</code></td> \n   <td>1</td> \n   <td>int</td> \n   <td>R</td> \n  </tr> \n  <tr> \n   <td><code>LongFunction&lt;R&gt;</code></td> \n   <td>1</td> \n   <td>long</td> \n   <td>R</td> \n  </tr> \n  <tr> \n   <td><code>DoubleFunction&lt;R&gt;</code></td> \n   <td>1</td> \n   <td>double</td> \n   <td>R</td> \n  </tr> \n  <tr> \n   <td><code>ToIntFunction&lt;T&gt;</code></td> \n   <td>1</td> \n   <td>T</td> \n   <td>int</td> \n  </tr> \n  <tr> \n   <td><code>ToLongFunction&lt;T&gt;</code></td> \n   <td>1</td> \n   <td>T</td> \n   <td>long</td> \n  </tr> \n  <tr> \n   <td><code>ToDoubleFunction&lt;T&gt;</code></td> \n   <td>1</td> \n   <td>T</td> \n   <td>double</td> \n  </tr> \n  <tr> \n   <td><code>IntToLongFunction</code></td> \n   <td>1</td> \n   <td>int</td> \n   <td>long</td> \n  </tr> \n  <tr> \n   <td><code>IntToDoubleFunction</code></td> \n   <td>1</td> \n   <td>int</td> \n   <td>double</td> \n  </tr> \n  <tr> \n   <td><code>LongToIntFunction</code></td> \n   <td>1</td> \n   <td>long</td> \n   <td>int</td> \n  </tr> \n  <tr> \n   <td><code>LongToDoubleFunction</code></td> \n   <td>1</td> \n   <td>long</td> \n   <td>double</td> \n  </tr> \n  <tr> \n   <td><code>DoubleToIntFunction</code></td> \n   <td>1</td> \n   <td>double</td> \n   <td>int</td> \n  </tr> \n  <tr> \n   <td><code>DoubleToLongFunction</code></td> \n   <td>1</td> \n   <td>double</td> \n   <td>long</td> \n  </tr> \n  <tr> \n   <td><code>BiFunction&lt;T,U,R&gt;</code></td> \n   <td>2</td> \n   <td>T,U</td> \n   <td>R</td> \n  </tr> \n  <tr> \n   <td><code>ToIntBiFunction&lt;T,U&gt;</code></td> \n   <td>2</td> \n   <td>T,U</td> \n   <td>int</td> \n  </tr> \n  <tr> \n   <td><code>ToLongBiFunction&lt;T,U&gt;</code></td> \n   <td>2</td> \n   <td>T,U</td> \n   <td>long</td> \n  </tr> \n  <tr> \n   <td><code>ToDoubleBiFunction&lt;T,U&gt;</code></td> \n   <td>2</td> \n   <td>T,U</td> \n   <td>double</td> \n  </tr> \n  <tr> \n   <td><code>UnaryOperator&lt;T&gt;</code></td> \n   <td>1</td> \n   <td>T</td> \n   <td>T</td> \n  </tr> \n  <tr> \n   <td><code>IntUnaryOperator</code></td> \n   <td>1</td> \n   <td>int</td> \n   <td>int</td> \n  </tr> \n  <tr> \n   <td><code>LongUnaryOperator</code></td> \n   <td>1</td> \n   <td>long</td> \n   <td>long</td> \n  </tr> \n  <tr> \n   <td><code>DoubleUnaryOperator</code></td> \n   <td>1</td> \n   <td>double</td> \n   <td>double</td> \n  </tr> \n  <tr> \n   <td><code>BinaryOperator&lt;T&gt;</code></td> \n   <td>2</td> \n   <td>T,T</td> \n   <td>T</td> \n  </tr> \n  <tr> \n   <td><code>IntBinaryOperator</code></td> \n   <td>2</td> \n   <td>int,int</td> \n   <td>int</td> \n  </tr> \n  <tr> \n   <td><code>LongBinaryOperator</code></td> \n   <td>2</td> \n   <td>long,long</td> \n   <td>long</td> \n  </tr> \n  <tr> \n   <td><code>DoubleBinaryOperator</code></td> \n   <td>2</td> \n   <td>double,double</td> \n   <td>double</td> \n  </tr> \n  <tr> \n   <td><code>Consumer&lt;T&gt;</code></td> \n   <td>1</td> \n   <td>T</td> \n   <td>void</td> \n  </tr> \n  <tr> \n   <td><code>IntConsumer</code></td> \n   <td>1</td> \n   <td>int</td> \n   <td>void</td> \n  </tr> \n  <tr> \n   <td><code>LongConsumer</code></td> \n   <td>1</td> \n   <td>long</td> \n   <td>void</td> \n  </tr> \n  <tr> \n   <td><code>DoubleConsumer</code></td> \n   <td>1</td> \n   <td>double</td> \n   <td>void</td> \n  </tr> \n  <tr> \n   <td><code>BiConsumer&lt;T,U&gt;</code></td> \n   <td>2</td> \n   <td>T,U</td> \n   <td>void</td> \n  </tr> \n  <tr> \n   <td><code>ObjIntConsumer&lt;T&gt;</code></td> \n   <td>2</td> \n   <td>T,int</td> \n   <td>void</td> \n  </tr> \n  <tr> \n   <td><code>ObjLongConsumer&lt;T&gt;</code></td> \n   <td>2</td> \n   <td>T,long</td> \n   <td>void</td> \n  </tr> \n  <tr> \n   <td><code>ObjDoubleConsumer&lt;T&gt;</code></td> \n   <td>2</td> \n   <td>T,double</td> \n   <td>void</td> \n  </tr> \n  <tr> \n   <td><code>Supplier&lt;T&gt;</code></td> \n   <td>0</td> \n   <td>-</td> \n   <td>T</td> \n  </tr> \n  <tr> \n   <td><code>BooleanSupplier</code></td> \n   <td>0</td> \n   <td>-</td> \n   <td>boolean</td> \n  </tr> \n  <tr> \n   <td><code>IntSupplier</code></td> \n   <td>0</td> \n   <td>-</td> \n   <td>int</td> \n  </tr> \n  <tr> \n   <td><code>LongSupplier</code></td> \n   <td>0</td> \n   <td>-</td> \n   <td>long</td> \n  </tr> \n  <tr> \n   <td><code>DoubleSupplier</code></td> \n   <td>0</td> \n   <td>-</td> \n   <td>double</td> \n  </tr> \n  <tr> \n   <td><code>Predicate&lt;T&gt;</code></td> \n   <td>1</td> \n   <td>T</td> \n   <td>boolean</td> \n  </tr> \n  <tr> \n   <td><code>IntPredicate</code></td> \n   <td>1</td> \n   <td>int</td> \n   <td>boolean</td> \n  </tr> \n  <tr> \n   <td><code>LongPredicate</code></td> \n   <td>1</td> \n   <td>long</td> \n   <td>boolean</td> \n  </tr> \n  <tr> \n   <td><code>DoublePredicate</code></td> \n   <td>1</td> \n   <td>double</td> \n   <td>boolean</td> \n  </tr> \n  <tr> \n   <td><code>BiPredicate&lt;T,U&gt;</code></td> \n   <td>2</td> \n   <td>T,U</td> \n   <td>boolean</td> \n  </tr> \n </tbody> \n</table> \n<h2>Lambda 表达式</h2> \n<blockquote>\n One issue with anonymous classes is that if the implementation of your anonymous class is very simple, such as an interface that contains only one method, then the syntax of anonymous classes may seem unwieldy and unclear. In these cases, you\'re usually trying to pass functionality as an argument to another method, such as what action should be taken when someone clicks a button. Lambda expressions enable you to do this, to treat functionality as method argument, or code as data.\n</blockquote> \n<p>当一个接口中只有一个方法时（即满足函数式接口定义），此时通过匿名类的语法来编写代码显得比较笨重。使用 lambda 表达式可以将功能作为参数，将代码作为数据。</p> \n<p>一个 Lambda 表达式分为以下三个部分：</p> \n<ul> \n <li>Argument List ： 参数列表</li> \n <li>Arrow Token ： 箭头符号，即 <code>-&gt;</code> </li> \n <li>Body ： 包含一个表达式或者一整块代码</li> \n</ul> \n<p>下面举几个例子：</p> \n<ol> \n <li> <p>定义一个函数式接口对象，用于求两个 int 之和，包含两个 int 类型参数 <code>x</code> 和 <code>y</code>，返回 <code>x + y</code> 的值：</p> <pre><code class=\"java\">IntBinaryOperator sum = (x, y) -&gt; x + y;</code></pre> </li> \n <li> <p>定义一个函数式接口对象，无参数，返回42：</p> <pre><code class=\"java\">IntSupplier intSupplier = () -&gt; 42;</code></pre> </li> \n <li> <p>定义一个函数式接口对象，用于输出字符串，包含一个 String 类型的参数 <code>s</code>，无返回值：</p> <pre><code class=\"java\">Consumer&lt;String&gt; stringConsumer = s -&gt; {\n    System.out.println(s);\n};</code></pre> </li> \n</ol> \n<h2>方法引用（Method Reference）</h2> \n<blockquote>\n You use lambda expressions to create anonymous methods. Sometimes, however, a lambda expression does nothing but call an existing method. In those cases, it\'s often clearer to refer to the existing method by name. Method references enable you to do this; they are compact, easy-to-read lambda expressions for methods that already have a name.\n</blockquote> \n<p>如果 lambda 表达式只是调用一个已有的方法，那么可以直接使用方法引用。</p> \n<p>例如输出 <code>List</code> 中的元素，用 lambda 表达式：</p> \n<pre><code class=\"java\">List&lt;String&gt; list = Arrays.asList(\"1\", \"22\", \"333\");\nlist.forEach(s -&gt; System.out.println(s));</code></pre> \n<p>改用方法引用更加简洁：</p> \n<pre><code class=\"java\">List&lt;String&gt; list = Arrays.asList(\"1\", \"22\", \"333\");\nlist.forEach(System.out::println);</code></pre> \n<p>也就是：</p> \n<pre><code class=\"java\">Consumer&lt;String&gt; stringConsumer = s -&gt; System.out.println(s);</code></pre> \n<p>简化成了：</p> \n<pre><code class=\"java\">Consumer&lt;String&gt; stringConsumer = System.out::println; // 将一个已有的方法赋值给一个函数式接口对象</code></pre> \n<p>方法引用有以下几种类型：</p> \n<ol> \n <li> <p><code>类名::静态方法名</code> ： 静态方法引用</p> <p>例如定义一个 <code>max</code> 函数式接口对象，用于求两个 int 中的最大值：</p> <pre><code class=\"java\">IntBinaryOperator max = Math::max;</code></pre> <p><code>IntBinaryOperator</code> 表示有两个 int 参数且返回值为 int 的函数，<code>Math.max()</code> 静态方法符合要求。</p> </li> \n <li> <p><code>对象名::非静态方法名</code> ： 对象的方法引用</p> <p>例如定义一个 <code>println</code> 函数式接口对象，用于输出字符串：</p> <pre><code class=\"java\">Consumer&lt;String&gt; println = System.out::println;</code></pre> <p><code>Consumer&lt;String&gt;</code> 表示有一个 String 类型参数且无返回值的函数，<code>System.out.println()</code> 方法符合要求。</p> </li> \n <li> <p><code>类名::new</code> ： 构造方法引用</p> <p>例如定义一个 <code>createHashMap</code> 函数式接口对象，用于创建一个 <code>HashMap</code>：</p> <pre><code class=\"java\">Supplier&lt;HashMap&gt; createHashMap = HashMap::new;</code></pre> <p><code>Supplier&lt;HashMap&gt;</code> 表示有一个无参数且返回值为 HashMap 的函数，<code>HashMap</code> 的构造函数符合要求。</p> </li> \n <li> <p><code>类名::非静态方法名</code> ： 文档中解释为：Reference to an instance method of an arbitrary object of a particular type 。如果不理解的话，下面举个例子来说明一下。</p> <p>定义一个 <code>concat</code> 函数式接口对象，用于拼接两个字符串：</p> <pre><code class=\"java\">BinaryOperator&lt;String&gt; concat = String::concat;</code></pre> <p><code>BinaryOperator&lt;String&gt;</code> 表示有两个 String 类型参数且返回值为 String 的函数。注意 String 类的 <code>concat</code> 不是静态方法，且 <code>String.concat(String str)</code> 只有一个参数，看似不符合要求。实际上它相当于：</p> <pre><code class=\"java\">BinaryOperator&lt;String&gt; concat = (s1, s2) -&gt; s1.concat(s2);</code></pre> <p>即调用第一个参数 <code>s1</code> 的 <code>concat</code> 方法，传入参数 <code>s2</code>。</p> </li> \n</ol> \n<h2>扩展阅读</h2> \n<p><a href=\"https://xxgblog.com/2020/04/17/java-8-stream/\" rel=\"nofollow noreferrer\">Java 8 Stream 总结</a></p> \n<h2>参考文档</h2> \n<ul> \n <li><a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html</a></li> \n <li><a href=\"https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html</a></li> \n <li><a href=\"https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html\" rel=\"nofollow noreferrer\">https://www.oracle.com/webfolder/technetwork/tutorials/obe/java/Lambda-QuickStart/index.html</a></li> \n <li><a href=\"http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html\" rel=\"nofollow noreferrer\">http://cr.openjdk.java.net/~briangoetz/lambda/lambda-state-final.html</a></li> \n <li><a href=\"https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html</a></li> \n <li><a href=\"https://docs.oracle.com/javase/9/docs/api/java/util/function/package-summary.html\" rel=\"nofollow noreferrer\">https://docs.oracle.com/javase/8/docs/api/java/util/function/package-summary.html</a></li> \n</ul> \n<h2>关注我</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbzETc\" src=\"http://localhost:8060/tup/2020/4/23/3fab020f48d142b8b2db610b48acf861.jpg\" alt=\"扫码关注\" title=\"扫码关注\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/4a41b47b41b045808893ea9f3cff9cdc.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', 'bb0b7e69ad3e46fcb121baefda8f1f78', '2294832fe5104d73ace4f14ad9549018,18a3a500bd184162ac1dc6fc9372c2f8,46aef9d1ce7343688d2eeba3bf10f911,49f4dbb3a7b24819950d1e3897abf92b', '0', '3', '1', '2020-04-23 10:28:20', '2020-04-23 10:28:20');
INSERT INTO `tb_recommend` VALUES ('d8aff15e1244470bb2611f24c6d62e0b', '以图搜图系统概述及工程实践（上）', '以图搜图系统概述 以图搜图指的是根据图像内容搜索出相似内容的图像。 构建一个以图搜图系统需要解决两个最关键的问题：首先，提取图像特征；其次，特征数据搜索引擎，即特征数据构建成数据库并提供相似性搜索的...', '<h2>以图搜图系统概述</h2> \n<p>以图搜图指的是根据图像内容搜索出相似内容的图像。</p> \n<p>构建一个以图搜图系统需要解决两个最关键的问题：首先，提取图像特征；其次，特征数据搜索引擎，即特征数据构建成数据库并提供相似性搜索的功能。</p> \n<h2>图像特征表示</h2> \n<p>介绍三种方式。</p> \n<p><strong>图像哈希</strong></p> \n<p>图像通过一系列的变换和处理最终得到的一组哈希值称之为图像的哈希值，而中间的变换和处理过程则称之为哈希算法。</p> \n<p>图像的哈希值是对这张图像的整体抽象表示。</p> \n<p>比如 Average Hash 算法的计算过程：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022380654\" src=\"http://localhost:8060/tup/2020/4/23/cb0a8b2899df4dca869a0f57485ee834.jpg\" alt=\"\" title=\"\"></span></p> \n<p>1.Reduce size : 将原图压缩到 8 x 8 即 64 像素大小，忽略细节。</p> \n<p>2.Reduce color : 灰度处理得到 64 级灰度图像。</p> \n<p>3.Average the colors : 计算 64 级灰度均值。</p> \n<p>4.Compute the bits : 二值化处理，将每个像素与上一步均值比较并分别记为 0 或者 1 。</p> \n<p>5.Construct the hash : 根据上一步结果矩阵构成一个 64 bit 整数，比如按照从左到右、从上到下的顺序。最后得到的就是图像的均值哈希值。</p> \n<p>参考：</p> \n<p><a href=\"http://www.hackerfactor.com/blog/?/archives/432-Looks-Like-It.html\" rel=\"nofollow noreferrer\">http://www.hackerfactor.com/b...</a></p> \n<p>图像哈希算法有很多种，包含但不限于:</p> \n<ul> \n <li>AverageHash: 也叫 Different Hash</li> \n <li>PHash: Perceptual</li> \n <li>MarrHildrethHash: Marr-Hildreth Operator Based Hash</li> \n <li>RadialVarianceHash: Image hash based on Radon transform</li> \n <li>BlockMeanHash: Image hash based on block mean</li> \n <li>ColorMomentHash : Image hash based on color moments</li> \n</ul> \n<p>我们最常见可能就是 PHash。</p> \n<p>图像哈希可以对抗一定程度的水印、压缩、噪声等影响，即通过对比图像哈希值的 Hamming distance （汉明距离）可以判断两幅图像的内容是否相似。</p> \n<p>图像的哈希值是对这张图像的整体抽象表示，局限性也很明显，由于是对图像整体进行的处理，一旦我们对整体性进行了破坏，比如在原图加一个黑边就几乎无法判断相似性了。</p> \n<p><strong>传统特征</strong></p> \n<p>在计算机视觉领域早期，创造了很多经典的特征算法，比如 SIFT</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022380653\" src=\"http://localhost:8060/tup/2020/4/23/f3d45a7cc58944c9b7bf6568db8915f5.jpg\" alt=\"\" title=\"\"></span></p> \n<p>如上图所示，通过 SIFT 算法提取出来的一系列的特征点。</p> \n<p>一幅图像提取出来的特征点有多个，且每一个特征点都是一个多维的局部向量，为了进行相似性计算，通常需要先将这一系列特征点融合编码为一个全局特征，也就是局部特征向量融合编码为一个全局特征向量（用这个全局特征向量表示一幅图像），融合编码相关的算法包括但不限于:</p> \n<ul> \n <li>BOW</li> \n <li>Fisher vector</li> \n <li>VLAD</li> \n</ul> \n<p><strong>CNN 特征</strong></p> \n<p>人工智能兴起之后，基于 CNN 卷积神经网络提取图像特征越来越主流。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022380655\" src=\"http://localhost:8060/tup/2020/4/23/66f74d7822d74e6b9e900c0ff8a6234d.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>搜索引擎</h2> \n<p>由于将图像转换为了特征向量，因此搜索引擎所要做的就是其实就是向量检索。</p> \n<p>这里直接推荐 Milvus ( <a href=\"https://www.milvus.io/\" rel=\"nofollow noreferrer\">https://www.milvus.io/</a> )，刚开源不久，可以很方便快捷的使用在工程项目上，具体的相关内容直接查阅官方文档即可。</p> \n<h6>推荐阅读</h6> \n<p><a href=\"https://www.upyun.com/tech/article/537/OUT%20%E5%95%A6%EF%BC%81%E4%BD%A0%E7%9A%84%20App%20%E8%BF%98%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%80%E9%94%AE%E7%99%BB%E5%BD%95%E5%90%97%EF%BC%9F.html\" rel=\"nofollow noreferrer\">OUT 啦！你的 App 还不支持一键登录吗？</a></p> \n<p><a href=\"https://www.upyun.com/tech/article/523/%E4%BA%8C%E7%8B%97%E5%AD%90%20%E3%80%81%E5%88%9D%E6%81%8B%E5%8F%8AHTTPS.html\" rel=\"nofollow noreferrer\">二狗子 、初恋及HTTPS</a></p>', null, 'http://localhost:8060/tup/2020/4/23/36dea1d5633542f788d8213b3211f978.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', 'cbad2058b4014634aec6515f4adbef0d', 'cc944f24ed5e4383a975481674f255e0,f831bc1c03f94b4b9e49390a3a354a3e,60e459d5028e400894856f94e826804c,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-23 10:55:34', '2020-04-23 10:55:34');
INSERT INTO `tb_recommend` VALUES ('dbddbafa318a4a39a1107b44429cc45c', 'Linux 基金会正在扩大 2020 年奖学金计划，以帮助更多有需要的人', 'SegmentFault 思否消息：鉴于 COVID-19 大流行，Linux 基金会发布公告宣布正在扩大今年的奖学金计划（The Linux Foundation Training (LiFT) Scholarship Program），以帮助有需要的人。', '<p><strong>技术编辑：鸣飞 发自北京</strong><br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p>SegmentFault 思否消息：鉴于 COVID-19 大流行，Linux 基金会发布公告宣布正在扩大今年的奖学金计划（The Linux Foundation Training (LiFT) Scholarship Program），以帮助有需要的人。</p> \n<p>Linux 基金会将在今年颁发多达 500 个奖学金，自 2011 年该计划启动以来已经授予了 106 个奖学金。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022292114\" src=\"http://localhost:8060/tup/2020/4/23/3f90069f75704c5380ff3eead1a84315.jpg\" alt=\"The Linux Foundation Training (LiFT) Scholarship Program\" title=\"The Linux Foundation Training (LiFT) Scholarship Program\"></span></p> \n<p>这是 Linux 基金会第九次主办 Linux 基金会培训（LiFT）奖学金计划，旨在为有前途的开发人员和系统管理员提供机会，他们有希望帮助塑造 Linux 和开源软件的未来，但没有其他方面的帮助参加培训课程的能力。</p> \n<p>申请人可以在世界上的任何地方居住，只要他们对这些技术表现出热情，并且对成为开源专业人士有浓厚的兴趣。</p> \n<p>Linux 基金会培训奖学金将涵盖奖学金获得者选择的每位获奖者选择的一门课程的费用，价值数千美元（不包括亲自参加课程的旅行费用）。在完成培训课程之后，所有类别的优胜者也可以选择免费参加Linux 基金会提供的任何认证考试。奖学金由基金会成员提供支持，他们非常重视帮助培训面向未来的开发人员和 IT 专业人员。</p> \n<p>Linux 基金会致力于将更多本地和国际人才带入开源社区。他的目标是增加获得开源培训的机会，扩大技术多样性，并为通向 IT 行业需求最大，利润最高的工作创造一条清晰的途径。</p> \n<p><strong>Linux 基金会奖学金计划将提供以下 10 个类别的奖学金：</strong></p> \n<ul> \n <li>Open Source Newbies</li> \n <li>Teens-in-Training</li> \n <li>Women in Open Source</li> \n <li>Software Developer Do-Gooder</li> \n <li>SysAdmin Super Star</li> \n <li>Blockchain Blockbuster</li> \n <li>Cloud Captain</li> \n <li>Linux Kernel Guru</li> \n <li>Networking Notable</li> \n <li>Web Development Wiz</li> \n</ul> \n<p><strong>申请必须在 2020 年 4 月 30 日美国太平洋时间晚上 11:59 之前提交。</strong></p> \n<p><strong>申请地址</strong>：<a href=\"https://forms.gle/hRJmrB8ytCxW4rUB6\" rel=\"nofollow noreferrer\">https://forms.gle/hRJmrB8ytCx...</a></p> \n<p><strong>技术编辑：鸣飞 | 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"http://localhost:8060/tup/2020/4/23/dae347bc9db54bde9172f4bdb8ddcba4.jpg\" alt=\"SegmentFault思否微信公众号\" title=\"SegmentFault思否微信公众号\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/988bb1cf524c4af4b76664cced31b957.jpg', '5ca4567d892841b087fac5246effac40', '19eb3dd59ef8430d9f637d97449fc417', '753b5aee3913424e81fe2b5299626d8c,f3eb17e6e5664a97af3e9b1fca12b286,81a4561c1c294e0cae32c9fe6b5dc397,aed399344712406e830d6efe028b7fe2', '0', '3', '1', '2020-04-23 10:59:10', '2020-04-23 10:59:10');
INSERT INTO `tb_recommend` VALUES ('dfb3f73626c641cc8d588202046f874f', '疑似国内银行上百万数据泄露，涉及上海银行、兴业银行、浦发银行等', '据社交媒体账号 @Bank Security 发布的消息显示，大量国内银行的数据正在被出售。数据包括上海银行 80 万行客户数据、46 万中国兴业银行信用卡资料、20 万上海理财 VIP 客户数据和 10 万上海浦发银行客户资料。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFWyd\" src=\"http://localhost:8060/tup/2020/4/23/eec7223e52d54e039671c6b850228202.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>据社交媒体账号 @Bank Security 发布的消息显示，大量国内银行的数据正在被出售。数据包括上海银行 80 万行客户数据、46 万中国兴业银行信用卡资料、20 万上海理财 VIP 客户数据和 10 万上海浦发银行客户资料。</p> \n<p>根据网曝图片显示，被泄露的数据包括姓名、地址、电话号码、身份证号、存款金额、所办业务等金融数据。</p> \n<hr> \n<p>据业内人士表示，银行数据泄露有两种来源：一种是技术上从后台数据库导出，一种是业务人员从前台导出。技术层面数据库数据的泄露，有可能是公司技术人员非法拷贝数据库中的数据，也有可能是被黑客攻击导致泄露。</p> \n<p>据业内人士分析，此次疑似又是一起因安全保护措施不当导致的数据库泄露。</p> \n<p>近两年，数据泄露事件频发，网络信息安全已成为不容忽视的问题，希望各厂商、开发者能够重视安全问题，避免造成不必要的损失。</p> \n<p>针对此次泄露事件，相关银行暂未进行回复。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFPkW\" src=\"http://localhost:8060/tup/2020/4/23/7556893a7a1f4cfeb53d53c729d8583e.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/6fd2af4826ce4bc8b3d8736b64ed26f2.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '04547238127a4676b504cc4496865d7b', '83f62facb3b943ffa8e46abd1ebc64d9,e75baefb206a4efe959a99aad77632a3', '0', '3', '1', '2020-04-23 10:58:37', '2020-04-23 10:58:37');
INSERT INTO `tb_recommend` VALUES ('e153375b09c14b1fa1bab5e6467826cf', 'Java 14 来势汹汹，这回让空指针无处遁形！！', '上篇：Java 14 之模式匹配，非常赞的一个新特性！ 相信在坐的每一位 Java 程序员都遇到过空指针异常： NullPointerException（NPE），不甚其烦。 栈长之前也分享几篇避免空指针的文章： 别再写 bug 了，避免空指...', '<p>上篇：<a href=\"https://mp.weixin.qq.com/s/Qfni7MQOicfhCOtCMEpaog\" rel=\"nofollow noreferrer\">Java 14 之模式匹配，非常赞的一个新特性！</a></p> \n<p>相信在坐的每一位 Java 程序员都遇到过空指针异常： <code>NullPointerException（NPE）</code>，不甚其烦。</p> \n<p>栈长之前也分享几篇避免空指针的文章：</p> \n<ul> \n <li><a href=\"https://mp.weixin.qq.com/s/cmkKuhEZl1qx6TXPxvA5pw\" rel=\"nofollow noreferrer\">别再写 bug 了，避免空指针的 5 个案例！</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s/um3UgQbY-u04fqPCiq8U5g\" rel=\"nofollow noreferrer\">没用 Java 8，怎么优雅地避免空指针？</a></li> \n</ul> \n<p>空指针异常神鬼莫测，它几乎可以出现在程序中的任何位置，想尝试捕获处理是不太切实际的。</p> \n<h4>背景</h4> \n<p>我们一般要通过 JVM 异常报告的代码位置去处理，JVM 会打印出导致空指导异常的详细类名、方法名以及行号，如以下异常所示：</p> \n<pre><code>Exception in thread \"main\" java.lang.NullPointerException\n    at Test.main(Test.java:3)</code></pre> \n<p>很显然，Test 类的 main 方法第 3 行发生了空指针异常，如果第 3 行的代码是：</p> \n<blockquote>\n javastack.name = \'栈长\';\n</blockquote> \n<p>这时候我们肯定能判定 javastack 对象为 null，如果是下面这段呢：</p> \n<blockquote>\n javastack.name = params.user.name;\n</blockquote> \n<p>以下这 e 个对象都可能为空：</p> \n<ul> \n <li>javastack</li> \n <li>params</li> \n <li>user</li> \n</ul> \n<p>这时候就无法通过 JVM 报告的位置所判定到底是哪个变量为空了，每一个对象都可能是空指针的入口，只能通过输出日志或者 Debug 调试去跟踪了。</p> \n<p>如果 JVM 可以提供足够明确的信息以显示空指针异常的具体来源，而无需额外的代码、工具来定位，那么这对开发人员、或者线上问题定位都举足轻重。当然，这个在商业 JVM 早就做到了，Java 14，它现在也终于来了。</p> \n<h4>详细的空指针异常信息</h4> \n<p>详细可以看官方这篇介绍：</p> \n<blockquote>\n <a href=\"https://openjdk.java.net/jeps/358\" rel=\"nofollow noreferrer\">https://openjdk.java.net/jeps...</a>\n</blockquote> \n<pre><code>Exception in thread \"main\" java.lang.NullPointerException: \n        Cannot read field \"name\" because \"params.user\" is null\n    at Test.main(Test.java:3)</code></pre> \n<p>如上所示，会给出详细的发生空指针异常变量路径。</p> \n<p>另外，如果是下标式访问的赋值语句，如 <code>a[i][j][k] = 2020; </code> 抛出空指针，那会是这样的：</p> \n<pre><code>Exception in thread \"main\" java.lang.NullPointerException:\n        Cannot load from object array because \"a[i][j]\" is null\n    at Test.main(Test.java:18)</code></pre> \n<p>注意：在同一行上显示异常类型、异常消息会导致行很长，所以为了保持可读性，会在第二行显示详细异常信息。</p> \n<p>另外，这个功能在 Java 14 默认情况下是不开启的，可以使用以下 JVM 参数进行切换：</p> \n<blockquote>\n 开启：-XX:+ShowCodeDetailsInExceptionMessages\n <p>关闭：-XX:-ShowCodeDetailsInExceptionMessages</p> \n</blockquote> \n<p><strong>为什么现在默认不开启？</strong></p> \n<p><strong>1）性能</strong></p> \n<p>如果应用程序频繁地抛出并打印异常堆栈消息，势必会带来一定的开销、影响性能，所以应尽量避免这种开销。</p> \n<p><strong>2）安全</strong></p> \n<p>这个会导致更多源代码的暴露，如果这个不能接受，则不应由 JVM 配置应用程序打印，而应捕获并丢弃。</p> \n<p><strong>3）兼容性</strong></p> \n<p>过去的 JDK 都是不打印详细空指针异常信息的，JVM 相关工具要依赖于异常消息的准确格式，有可能会存在兼容性问题。</p> \n<p>所以，这个特性暂时默认是关闭的，在未来不久的版本中会默认开启。</p> \n<p>好了，今天就到这了，关注微信公众号：Java技术栈，新特性实战陆续更新中，公众号第一时间推送。历史 Java 8 - 14 新特性教程可以在公众号回复 java 获取。</p> \n<p>栈长原创和整理不易，觉得文章不错，在看、转发分享给更多的朋友们，总能帮助有需要的人，大家一起流弊~</p> \n<p><strong>推荐去我的博客阅读更多：</strong></p> \n<p>1.<a href=\"http://www.javastack.cn/categories/Java/\" rel=\"nofollow noreferrer\">Java JVM、集合、多线程、新特性系列教程</a></p> \n<p>2.<a href=\"http://www.javastack.cn/categories/Spring/\" rel=\"nofollow noreferrer\">Spring MVC、Spring Boot、Spring Cloud 系列教程</a></p> \n<p>3.<a href=\"http://www.javastack.cn/categories/%E5%B7%A5%E5%85%B7/\" rel=\"nofollow noreferrer\">Maven、Git、Eclipse、Intellij IDEA 系列工具教程</a></p> \n<p>4.<a href=\"http://www.javastack.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/\" rel=\"nofollow noreferrer\">Java、后端、架构、阿里巴巴等大厂最新面试题</a></p> \n<p>觉得不错，别忘了点赞+转发哦！</p>', null, null, 'c56940aa8b004dab84568e86900b2ee6', 'bb0b7e69ad3e46fcb121baefda8f1f78', '2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-23 10:28:18', '2020-04-23 10:28:18');
INSERT INTO `tb_recommend` VALUES ('e65334a55d404ee7af649d9b2a66199a', '译文丨谈论我的时代：开发者的工具是如何改变的', '如果你是 20 世纪 90 年代或 2000 年代的开发者，你的工具集是相当简单的。你可能使用了一个 IDE 和一个调试器，也许你还也有一些基本的测试工具，而这些可能就是你完成工作所需要的所有工具了。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT6K\" src=\"http://localhost:8060/tup/2020/4/23/4f0c59f45d9c4dc895b8a221e0b1d642.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>作者：Christopher Tozzi<br>编译：徐九<br>原文链接：<a href=\"https://www.itprotoday.com/devops-and-software-development/talkin-bout-my-generation-how-programmer-tools-have-changed\" rel=\"nofollow noreferrer\">https://www.itprotoday.com/de...</a></p> \n<hr> \n<p>如果你是 20 世纪 90 年代或 2000 年代的开发者，你的工具集是相当简单的。你可能使用了一个 IDE 和一个调试器，也许你还也有一些基本的测试工具，而这些可能就是你完成工作所需要的所有工具了。</p> \n<p>但今天这一代的开发人员就更难了。现在的开发者需要学习各种不同类型的编程工具。作为一名开发人员，只需要写好代码就可以结束工作的日子已经一去不复返了。</p> \n<p>今天，就让我们来看看那些对今天的开发人员来说是必不可少，但在这一代人之前可能还闻所未闻的编程工具。</p> \n<h2>Git</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT5W\" src=\"http://localhost:8060/tup/2020/4/23/3eebd59b50274e50a493745271346820.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>首先，以 Git 为例，它是一个广泛使用的版本控制工具。Git 发布于 2000 年中期，但它并不是第一个版本控制工具。像 RCS 和 CVS 这样的源代码管理工具早在 1980 年代就已经出现了，但除非是在做一个大型复杂的企业软件项目，否则几乎不会用到它们。</p> \n<p>相比之下，Git 已经成为现在大部分程序员都在使用的源代码管理工具，哪怕是个人开发者都在使用。</p> \n<p>这要归功于基于 Web 的 Git 接口的兴起，尤其是 GitHub，它让编码工作变得更加大众化。任何一个人，只要是编码界的人，都应该拥有一个 GitHub 的账号，并了解如何使用 Git 来分享和管理源代码。</p> \n<p>更重要的是，所谓的 GitOps（一种实现持续交付的模型，它的核心思想是将应用系统的声明性基础架构和应用程序存放在 Git 的版本控制库中。）趋势已经使 Git 不仅仅是一个源代码管理工具，而是一个端到端的项目管理平台。现在，开发者们都希望能够使用 Git 来跟踪任务、简化沟通等等。</p> \n<p>而早期的程序员们使用的源代码管理器都不是这样的。</p> \n<h2>容器</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT53\" src=\"http://localhost:8060/tup/2020/4/23/4f1e642ece19432ebd75fb1fd58809c3.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>容器是另一个例子，这类工具在我们这一代人之前很少有程序员想到过，但现在却随处可见。</p> \n<p>容器的历史悠久，可以追溯到几十年前。然而，直到 2013 年 Docker 的容器平台首次亮相，容器才开始进入主流。</p> \n<p>Docker 早期的卖点之一是，容器可以通过提供一个跨开发管道所有阶段的通用应用托管环境来简化开发流程。早期的容器平台还没有推广这种用例。</p> \n<p>今天，知道如何在容器内打包代码对许多程序员来说是必不可少的。熟悉容器平台（如Kubernetes）也是如此，Kubernetes 提供了一种创建应用程序开发/测试环境的方法，因此它已经变得非常流行。</p> \n<h2>持续集成服务器</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT59\" src=\"http://localhost:8060/tup/2020/4/23/40b4b0b0058e4388af6bd516f7448c7b.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>和容器一样，持续集成（CI）服务器的历史比我们想象的要长。这个概念可以追溯到 20 世纪 90 年代初，但到了 90 年代末，它才在一些开发者圈子里找到了追随者 -- 尤其是极端编程社区。</p> \n<p>但直到 2010 年左右，CI 工具才开始在各种类型的程序员中广泛使用。今天，很少有软件项目不使用像 Jenkins、Ansible、TeamCity 或其他无数 CI 平台的工具来做 CI 的。</p> \n<p>这对今天的程序员来说意味着，熟悉 CI 服务器是至关重要的。</p> \n<h2>APIs</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT6a\" src=\"http://localhost:8060/tup/2020/4/23/51f45928516b4e678fa126c042766948.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>API 也已经以这样或那样的形式存在了几十年了。但直到云时代的到来，API 才成为许多应用架构的一部分。今天，很难找到一个应用程序不以这样或那样的方式依赖 API。</p> \n<p>因此，今天的程序员必须对 API 的工作原理和有哪些不同类型的 API 架构具备深刻的理解。他们还必须经常能够使用 API 测试和模拟工具，这在开发依赖 API 的应用程序时非常重要。</p> \n<h2>公有云</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT6p\" src=\"http://localhost:8060/tup/2020/4/23/8e7f71d47a4d4a01a86d1d7c8d23d16b.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>虽然把云放在了最后，但这不代表它不重要。在 AWS 在 2000 年代中期推出之前，很少有开发者使用类似于今天所谓的公有云的东西。</p> \n<p>然而，快步走到现在，如果你想成为一名开发者，知道如何使用公有云的所有工具是相当重要的。如果你不了解如何在至少一两个主要的公有云平台上使用 IAM、监控、部署和配置工具，你的技术之路估计不会走得很远。</p> \n<h2>结论</h2> \n<p>与前代人相比，现在的开发人员需要掌握更多的编程工具来完成自己的工作。现在开发人员日常使用的许多工具类型其实并不新鲜。但它们已经从某些社区的程序员使用的小众解决方案，变成了几乎每个开发者的必备工具。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyLB\" src=\"http://localhost:8060/tup/2020/4/23/8c2c3106528f406c84a959ad6b1b0f56.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/6a83b8b905af455b8e36d56d6fd745cd.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '2a353971222c4aff8e8d3e9c370330cd', '66d1b6953b664c409cf7283cdb6c6566,db6b58ae709645f2b64166fd73f2f705,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-23 11:00:49', '2020-04-23 11:00:49');
INSERT INTO `tb_recommend` VALUES ('e6ce0e394d6a491c89fcb257091ec610', '滴滴开源企业级监控解决方案：夜莺 Nightingale', 'SegmentFault 思否消息：近日滴滴基础平台联合滴滴云开源了他们研发的企业级监控解决方案：夜莺（Nightingale），Nightingale 是旨在满足云原生时代企业级的监控需求。Nightingale 在产品完成度、系统高可用、以...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p>SegmentFault 思否消息：近日滴滴基础平台联合滴滴云开源了他们研发的企业级监控解决方案：夜莺（Nightingale），Nightingale 是旨在满足云原生时代企业级的监控需求。Nightingale 在产品完成度、系统高可用、以及用户体验方面，达到了企业级的要求，可满足不同规模用户的场景，小到几台机器，大到数十万都可以完美支撑。兼顾云原生和裸金属，支持应用监控和系统监控，插件机制灵活，插件丰富完善，具有高度的灵活性和可扩展性。</p> \n<p><a href=\"https://github.com/didi/nightingale\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022226405\" src=\"http://localhost:8060/tup/2020/4/23/521dcdde054a454389ffa8d6f61660de.jpg\" alt=\"\" title=\"\"></span></a></p> \n<p>Nightingale 在<a href=\"https://github.com/open-falcon\" rel=\"nofollow noreferrer\">Open-Falcon</a>的基础上，结合滴滴内部的最佳实践，在性能、可维护性、易用性方面做了大量的改进，作为滴滴统一的监控解决方案，支撑了滴滴内部数十亿监控指标，覆盖了从系统、容器、到应用等各层面的监控需求。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022226404\" src=\"http://localhost:8060/tup/2020/4/23/c0867bd2f5ef4d0fb51cb21505c7357b.jpg\" alt=\"\" title=\"\"></span></p> \n<p>Nightingale 采用树状节点导航，我们称之为对象树。对象树本质上是一种对监控对象的分组管理机制，方便查找和查看监控对象，以及对监控对象设置监控策略等管理动作。一棵典型的树可从上到下描述为组织架构关系、产品服务模块关系、机房和机器挂载关系，该导航树可根据用户需求自行灵活定制。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022226406\" src=\"http://localhost:8060/tup/2020/4/23/49d595e9e3eb4d42b3a9d48ae40e10ed.jpg\" alt=\"\" title=\"\"></span></p> \n<p>监控策略应用到某个节点后，该节点下的所有子节点挂载的所有的机器都会应用这个策略，任何一台机器触发相关阈值都会产生告警。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022226407\" src=\"http://localhost:8060/tup/2020/4/23/9d32e552bbf64e1eb34961c1ad92fa4d.jpg\" alt=\"\" title=\"\"></span></p> \n<p>监控大盘的定制做了大幅易用性改进，支持了图表阈值，支持了图表分类，新增图表和排序管理都是可见即所得的方式，巡检大盘的定制从此不再是困难。</p> \n<p>Nightingale 是在 Open-Falcon 的基础上衍化发展而来，Open-Falcon 作为国内使用最广泛的监控解决方案之一，为 Nightingale 的设计开发提供了大量的借鉴意义。</p> \n<p><strong>▍</strong><strong>与Open-Falcon的不同点</strong></p> \n<ul> \n <li> <strong>告警引擎重构</strong>：Open-Falcon 的告警策略，在监控数据推送上来的同时会触发策略判断，这种「推」的模式优势是策略的判断时效性非常高，但是不利于更高级的告警策略的支持和扩展，比如多条件的组合报警就很难支持。Nightingale 转为推拉结合模式，通过推模式保证大部分策略判断的效率，通过拉模式支持了与条件告警和nodata告警；</li> \n <li> <strong>引入了导航对象树：</strong>将 Open-Falcon 采用的扁平 HostGroup，转为 Nightingale 的导航对象树，对象树本质上是一种对监控对象的分组管理机制，方便查找和查看监控对象，以及对监控对象设置监控策略等管理动作。同时在 Nightingale 中，去除了告警模板的概念，告警策略直接与树节点绑定，简化设计，大幅提升灵活度和易用性；</li> \n <li> <strong>索引模块升级换代：</strong>Open-Falcon 使用 MySQL 存储 metrics 的索引数据，在扩展性和灵活性上存在瓶颈。Nightingale 根据监控需求，设计开发了全新的内存索引模块 index，查询方式更多样，查询效率更高，避免了原来 MySQL 索引数据达到亿级别时面临的维护优化工作；</li> \n <li> <strong>时序数据库优化：</strong>在 Open-Falcon 存储模块 Graph 的基础上，引入 Facebook 的 Gorilla 压缩方案，近期几个小时的数据采用内存存储，大幅提升数据查询效率，长期数据仍然使用 rrdtool 数据格式存储在硬盘上。同时进一步完善了时序数据库的性能和稳定性；</li> \n <li> <strong>告警引擎高可用改进：</strong>告警引擎 judge 模块通过心跳机制做到了故障自动摘除，再也不用担心单个 judge 宕机导致部分策略失效，需要人工介入的问题，index 模块也是采用类似方式保证可用性；</li> \n <li> <strong>原生内置日志监控功能：</strong>Nightingale 客户端原生内置了日志匹配和指标抽取能力，在 web 控制台页面上支持了日志匹配规则的配置，同时也支持读取目标机器特定目录下的配置文件的方式，让业务指标监控更为易用；</li> \n <li> <strong>可运维性增强：</strong>将 portal(falcon-plus中的api)、uic、dashboard、hbs、alarm 合并为一个模块：monapi，简化了系统整体部署难度，原来的部分模块间调用变成进程内方法调用，性能更高；</li> \n <li> <strong>配置文件中心化：</strong>配置文件做了易用性改造，抽取数据库通用配置到 mysql.yml，抽取端口实例地址等关联配置到 address.yml，大批配置在代码里给了默认值，使得配置文件更清晰，易于维护。</li> \n</ul> \n<p><strong>▍</strong><strong>与Open-Falcon的相同点</strong></p> \n<ul> \n <li>数据模型没有变化，仍然是 metric、endpoint、tags 的组织方式，agent 基本是可以复用的，Nightingale 中的 agent 叫 collector，融合了原来 Open-Falcon 的 agent 和 falcon-log-agent 的逻辑，各种监控插件也都是可以复用的。</li> \n <li>数据流向和整体处理逻辑是类似的，仍然使用灵活的推模型，分为数据存储和告警判断两条链路。</li> \n</ul> \n<p><strong>▍</strong><strong>Nightingale架构</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022226408\" src=\"http://localhost:8060/tup/2020/4/23/5f62dc5aa6ee4206b6dc32931b8b6599.jpg\" alt=\"\" title=\"\"></span></p> \n<p><em>如果想了解更细节的内容，可以参看这个小视频：<a href=\"https://s3-gz01.didistatic.com/n9e-pub/video/n9e-arch-intro.mp4\" rel=\"nofollow noreferrer\">夜莺架构讲解</a></em></p> \n<ul> \n <li>collector 即 agent，可以采集机器常见指标，原生支持日志监控，支持插件机制，支持业务通过接口直接上报数据；</li> \n <li>transfe r提供 rpc 接口接收 collector 上报的数据，然后通过一致性哈希，将数据转发给多台tsdb和多台judge；</li> \n <li>tsdb 即 open-falcon 中的 graph 组件，用于存储历史数据，支持配置为双写模式提升系统容灾能力，tsdb 会把监控数据转发一份给 index 建索引；</li> \n <li>index 是内存索引模块，替换原来的 mysql 方案，在内存里构建索引，便于后续数据检索，在检索的灵活性和检索性能方面大幅提升；</li> \n <li>judge 是告警引擎，从 monapi(portal) 同步监控策略，然后对接收到的数据做告警判断，如满足阈值，则生成告警事件推送到 redis 队列；</li> \n <li>monapi(alarm) 从 redis 队列中读取 judge 生成的事件，进行二次处理，补充一些元信息，生成告警消息，重新推送回 redis 队列；</li> \n <li>各发送组件，比如 mail-sender、sms-sender 等，从 redis 读取告警消息，发送告警，抽象出各类 sender 是为了后续定制方便；</li> \n <li>monapi 集成了原来多个模块的功能，提供接口给 js 调用，api 前缀为 /api/portal，数据查询走 transfer，去除了 open-falcon 中原来的 query 组件，api 前缀为 /api/transfer，索引查询的 api 前缀 /api/index，于是，在前端统一搭建 nginx，即可通过不同 location 将请求转发到不同后端；</li> \n <li>数据库仍然使用 MySQL，主要存储的内容包括：用户信息、团队信息、树节点信息、告警策略、监控大盘、屏蔽策略、采集策略、部分组件心跳信息等。</li> \n</ul> \n<p>项目开发文档地址：<a href=\"https://n9e.didiyun.com/docs/intro/\" rel=\"nofollow noreferrer\">https://n9e.didiyun.com/docs/...</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFmMq\" src=\"http://localhost:8060/tup/2020/4/23/c13b97c2105c408dac71e0bd004b0759.jpg\" alt=\"image.png\" title=\"image.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/ee7ad34adb934e1a87c294ea9155508d.jpg', '6fbfa4aaad3a43458f21c8acf0038ac5', '19eb3dd59ef8430d9f637d97449fc417', '448959a7e0394148ae465d890ed2bbd2,f3eb17e6e5664a97af3e9b1fca12b286,cff4263234c04178b6f716310595544e,db6b58ae709645f2b64166fd73f2f705', '0', '3', '1', '2020-04-23 10:59:16', '2020-04-23 10:59:16');
INSERT INTO `tb_recommend` VALUES ('eaafc514474641d8aa1a2b1165dc6464', 'AI端侧落地，京东AI技术如何部署边缘？', '导语：随着物联网的快速发展，越来越多的用户希望将 AI能力下沉到边缘层，让边缘设备能够自动处理关心的一些数据，再把结果上报到云平台。这样做既节省了资源，又提高了运算效率。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022360719\" src=\"http://localhost:8060/tup/2020/4/23/3e04a51a167943479c4b3fc877d8452d.jpg\" alt=\"Alt\" title=\"Alt\"></span></p> \n<blockquote>\n <strong>导语：随着物联网的快速发展，越来越多的用户希望将 AI能力下沉到边缘层，让边缘设备能够自动处理关心的一些数据，再把结果上报到云平台。这样做既节省了资源，又提高了运算效率。</strong>\n</blockquote> \n<p>随着技术进步，手机等移动设备已成为非常重要的本地深度学习载体，然而日趋异构化的硬件平台和复杂的终端侧的使用状况，让AI技术在端侧的应用能力颇受挑战。端侧模型的推理往往面临着算力和内存的限制，为了能够完整的支持众多硬件架构，并且实现在这些硬件之上人工智能应用性能的优化，不少科技公司开启了深入研究。技术媒体InfoQ上周采访了京东智联云视觉研发部的产品经理张志强，交流了京东AI技术在端侧的应用。</p> \n<p>（以下为采访稿件内整理）</p> \n<h3>AI技术在端侧能解决什么问题？</h3> \n<p>在探讨这个话题之前，我们需要先明确端侧的定义。端侧其实是相对于云中心侧来讲的。云中心侧其实是一种集中式服务，所有采集和感知到的视频、图像数据都通过网络传输到云中心侧进行后续处理。云侧的资源高度集中并且具有很高的通用性，但是随着IoT设备和数据的指数爆发式增长，云侧的集中式计算模型慢慢暴露出了很多不足，比如数据处理的实时性，网络条件制约，数据安全等。</p> \n<p>AI技术用于端侧也就是我们常说的边缘计算，张志强说，这种模式可以更好的支持AIoT场景，具有如下优点：一是AI技术用于端侧可以第一时间对收集的数据进行处理，不需要通过网络上传到云侧的处理中心，极大加快了系统响应也减少了系统处理延迟，5G技术的普及也为端侧处理提供了保证；二是端侧计算可以更高效的处理有价值的关键数据（大约20%），其余的数据（大约80%）只是临时性的，在端侧结合AI能力，不仅可以更及时处理数据，而且减轻网络带宽的限制和缓解对中心侧数据存储的压力；三是在端侧的AI技术可以高效地对用户的源数据进行处理，将一些敏感的数据进行清洗和保护，端侧设备只将AI处理后的结果进行上报。</p> \n<p>总的来说，AI在边缘侧的执行可以实时进行数据处理，实时响应，有效降低因数据传送到云计算中心而导致的延迟。</p> \n<p>目前，主要的应用是物联网的边缘计算，京东对内、对外都有一些落地案例，例如：无人售货机和智能结算台上使用了AI的商品检测技术，包括顾客所选取的商品SKU等，主要采用的是端侧的AI能力；以及在智慧园区里进行基本的人脸结构化、人体结构化、车辆结构化，还有基于视频分析的周界安全检测、物体遗留等场景。某些场景不仅结合了边缘计算的AI能力，同时也使用了云端的AI能力进行二次分析，采用的形式是云端协同。在一些更复杂的场景，比如智慧园区，智慧社区，智慧城市的项目落地中，大多都是采用的端云协同的应用形式。</p> \n<h3>端侧AI的研发难点</h3> \n<p>众所周知，端侧的技术难度是如何在资源有限的硬件环境里满足业务对性能的要求，无论是存储、内存，或者计算资源都比较有限。端侧对AI模型提出了更高的要求，比如对模型生命周期的管理，发布，回滚，灰度，版本管理等，如何方便模型的升级更新需要建立一套完善通用的机制和平台。另外，边缘计算的硬件设备种类很多，在初期对不同硬件架构的学习、适配和模型迁移工作会占用比较长的时间，比如有很多之前自定义的模型算法算子不支持，需要算法侧重新设计和开发，无形中增加了AI在端侧应用的复杂度。</p> \n<p>为此，经过前期积累，京东也针对市面上流行的不同边缘计算硬件产品进行了抽象和平台化，屏蔽底层差异化，统一建设了从算法开发、模型适配、本地测试，部署上线等的一系列CI/CD机制，实现快速交付。</p> \n<p>过往，不少开发者都会遇到离线训练和在线推理结果不一致的问题。对此，京东方面发现训练和推理的结果不会完全一样，但是基本一致。可以从以下三方面考虑：一是在模型设计上尽可能轻量化。在保证模型性能的前提下，使网络参数减少的同时，不损失网络性能，尽可能的降低模型的复杂度以及运算量；二是性能与精度进行权衡，找到平衡点；三是检测两者的预处理与后处理有无差异，可以在网络处理前后进行预判和比较。</p> \n<h3>京东端侧AI技术实践</h3> \n<p>2019年中，京东云与AI视觉研发部开始规划在端侧场景下的AI视频分析平台mVCG-Air，与该版本相呼应的是在云端场景部署的mVCG-Pro，二者统称为mVCG（mega-Video Computing Grid），也就是超大规模的视频计算分析网络。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022360720\" src=\"http://localhost:8060/tup/2020/4/23/1cc888d559e94e0287a0e992eab4a9c7.jpg\" alt=\"Alt\" title=\"Alt\"></span><br><em>【mVCG-Air技术整体架构图】</em></p> \n<p>mVCG-Air是AI视频分析处理能力在端侧应用的典型产品，经过快速迭代mVCG-Air目前已经在不同场景落地。张志强表示，该平台解决了在落地场景中接入的设备多，同时对视频分析的时效性很高，云端处理受网络带宽有滞后影响的问题。</p> \n<p>此外，mVCG-Air结合了目前性能较高的端侧计算设备，同时内部全部使用了京东智联云自研的AI核心技术，所有算法模型针对端侧计算设备进行了全面优化和加速，开发者可以轻松实现定制化、快速交付。</p> \n<h3>有必要统一模型研发流程</h3> \n<p>综合整个实践过程，不难发现 ，拥有统一所有模型的研发流程，使得模型研发之初的特征工程再到模型训练，再到推理上线等做统一的规划是十分必要的。比如，京东同一个模型未来可能会在不同的场景都需要部署落地，有的是基于边缘计算的mVCG-Air部署，有的是基于云中心的mVCG-Pro进行部署，那么就需要有统一的模型训练和转换机制。同时，同一个模型有可能会在不同的边缘硬件上进行部署，在模型设计之初就需要考虑后续的一致性等问题。京东内部已经沉淀了一套完整的模型研发测试流程，使得一个模型可以轻松同时落地不同的异构硬件设备上。</p> \n<h3>资源调度设计</h3> \n<p>关于资源调度，其实包括边缘侧mVCG-Air和中心侧mVCG-Pro的调度，也包括mVCG-Air管理的设备之间的调度。张志强表示，在mVCG内部有个很重要的模块组件，就是模型仓库，与其相关联的有算力调度，任务调度等。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022360721\" src=\"http://localhost:8060/tup/2020/4/23/e0546d6163f148dda60ebf273a58804f.jpg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><em>【算法仓库体系架构图】</em></p> \n<p>算法仓库体系架构使得智能分析能力不再固化在mVCG的产品中，实现“一套平台，多种算法”，具有系统高可用、资源高利用率、算法灵活开放等优势。基于算法仓库可以对mVCG所有算法模型进行统一高效管理，包括模型管理、模型灰度部署、模型发布、模型升级、模型算法版本管理。每个模型都有自己的画像Model Profile，通过分布式组件，根据模型画像和当前业务负载实现模型算力的灵活分配和调度，所有模型算法是基于插件机制实现灵活部署、自动分配、快速加载、高效运行和无感知版本更新。</p> \n<h3>硬件选型</h3> \n<p>事实上，软件层面的定制优化永无止境，这包括模型加速推理，模型量化剪枝，让模型体积更小，占用资源小同时又不失精度。当然，软件层面的优化工作也需要取决于边缘侧设备的开放程度。</p> \n<p>除了软件层面的能力，AI所需的超强算力必须有合适的硬件与之相匹配。张志强表示，京东云与AI视觉研发部mVCG-Air在研发过程中使用了ARM架构的CPU+NPU，现在不断有更新、更快的硬件加速卡或者是端侧产品推出，选取性价比最高，同时最适合业务场景的才是最好的。</p> \n<p>未来，mVCG-Air也将继续赋能感知设备以智能，并融合云端物联网和信息网的数据，实现对人（人脸、人体）、车、物体、场景、行为的全息感知，同时深入挖掘多维数据的潜在价值。应用的重点包括京东内部的很多重要场景，也包括对外的场景，比如智慧园区，智慧城市，智慧车站，智慧警务等。</p> \n<h3>未来规划</h3> \n<p>边缘计算作为传统云计算的重要补充，各自发挥特长，随着端侧设备处理能力的大幅度提升，基于AI的智能设备正在发挥越来越重要的作用。</p> \n<p>AI和端侧的结合其实属于AIoT的一部分，因为智能物联网AIoT是在2018年兴起的概念，目前各类AI公司、芯片公司都处在百家争鸣的阶段，市场空间非常大，包括端侧人工智能在建筑人居、工业制造、智慧城市等不同产业领域的瞭望，都充满了期待。</p> \n<p>2020年，AIoT正在发生的一个趋势是人工智能和设备的加速融合。大多数情况下，端侧人工智能计算和云侧计算将会长期共存，甚至采用混合的方式，一部分由设备自身的AI能力及时执行运算，另一部分通过统一云中心完成。现在，业界对于端侧人工智能讨论比较多的还是软硬件选型、动态调度和垂类落地的问题。作为云计算的下沉计算模型，端侧的人工智能发展还需要一些时间和耐心。</p> \n<p><strong>欢迎点击“<a href=\"https://www.jdcloud.com/cn/?utm_source=PMM_Segmentfault&amp;utm_medium=ReadMore_220&amp;utm_campaign=ReadMore&amp;utm_term=NA\" rel=\"nofollow noreferrer\">更多</a>”了解京东智联云！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022360722\" src=\"http://localhost:8060/tup/2020/4/23/fbd3b47d0ceb447d85a94fa25efc8b77.jpg\" alt=\"Alt\" title=\"Alt\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022360723\" src=\"http://localhost:8060/tup/2020/4/23/418e618b5e2243799692993b934e57f6.jpg\" alt=\"Alt\" title=\"Alt\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/b29e8bfe20784184af8588b595d949ca.jpg', '3f69fcc9b13843d1910b3dac597f5215', 'cbad2058b4014634aec6515f4adbef0d', '2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-23 10:55:44', '2020-04-23 10:55:44');
INSERT INTO `tb_recommend` VALUES ('eb583ac97dd54ed2873ae07d5e17fc4f', 'LeanCloud 2019 回顾', '在过去的一年里，数万新用户选择了 LeanCloud，开发者在我们的平台上创建了数万新应用。尽管在 6 月遇到了一些因外部因素带来的困难，2019 年仍然是 LeanCloud 实现整体盈利的第一年。这离不开用户的长期支持，同...', '<p>在过去的一年里，数万新用户选择了 <a href=\"https://www.leancloud.cn\" rel=\"nofollow noreferrer\">LeanCloud</a>，开发者在我们的平台上创建了数万新应用。尽管在 6 月遇到了一些因外部因素带来的困难，2019 年仍然是 LeanCloud 实现整体盈利的第一年。这离不开用户的长期支持，同时健康的财务对于为用户提供持续、稳定、不断改进的服务也是至关重要的。</p> \n<p>在过去一年里我们正式推出了 LeanCloud 国际版，全面支持域名绑定，并为对稳定性、可控性、灵活性有更高要求的用户开发了全新的独立部署方案。多人对战 Client Engine 正式上线，同时为规模较大的游戏提供了独立部署选项。云引擎新增了云队列和 MySQL 支持。其他服务和 SDK 也有大量改进和优化。</p> \n<h2>国际版正式运行</h2> \n<p>为了适应用户的需求变化以及产品下一步的发展，让 LeanCloud 正式成为国际化的产品，我们推出了 LeanCloud 国际版。 国际版使用独立的顶级域名 <a href=\"https://leancloud.app\" rel=\"nofollow noreferrer\">leancloud.app</a> 和账户体系，由 LeanCloud 的境外公司作为主体运营，费用使用美元结算。 我们已经初步完成了网站、控制台、文档的国际化，也提供英语技术支持，让英文环境的开发者也可以使用 LeanCloud。</p> \n<h2>全面支持域名绑定</h2> \n<p>为了确保能长期稳定为开发者提供服务，按照相关法律法规和有关部门的要求，我们推动了使用 LeanCloud 服务的应用<a href=\"https://leancloud.cn/docs/custom-api-domain-guide.html\" rel=\"nofollow noreferrer\">绑定自有域名</a>。 绑定自有域名也有利于从域名层面做好应用隔离，确保业务稳定。 为了保证安全性，API 域名必须启用 SSL（云引擎域名、文件域名推荐启用 SSL），我们也推出了自动管理功能，支持 SSL 证书的自动申请和自动续期。</p> \n<h2>存储服务</h2> \n<h4>全新独立部署方案</h4> \n<p>为了满足众多企业客户对平台稳定性、后端可控性以及功能多样性方面的要求，我们推出了新的独立部署方案，希望减少使用中的限制，给开发者更大的灵活性，同时也提供一个更加稳定可靠的完整后端，满足业务系统的更高要求。</p> \n<p>新的独立部署方案里，我们会使用「独立的存储集群 + 独立的 API 集群 + 独立的扩展服务集群」的模式来构建一个完整的、物理隔离的公有云系统，供单个用户和应用独享使用。 这里的「扩展服务」是指基于存储到云端的结构化数据，解决特定业务需求的垂直服务，例如并行计算（原离线分析功能）、全文检索（原应用内搜索功能）等。</p> \n<p>新的 API Server 是完全重新开发的，我们针对单应用独立部署的使用场景进行了功能裁剪和架构优化，取消了共享集群方式下的一些请求限制（例如数据导入导出、并发线程上限等），增加了更多数据处理接口（例如提供了索引操作和聚合查询的 REST API），同时还有更好的并发处理性能和弹性伸缩能力。</p> \n<h2>云引擎</h2> \n<h4>云队列</h4> \n<p>我们推出了<a href=\"https://leancloud.cn/docs/leanengine_cloudqueue.html\" rel=\"nofollow noreferrer\">云队列</a>服务。云队列提供了一种在云引擎之外调度云函数的能力，它基于云引擎已有的「云函数」这个概念实现了重试、去重、结果查询、延时任务、定时任务等功能，是对云函数功能的一个补充。尚未运行的任务会以一种可靠的方式暂存在云队列，即使你的云引擎因部署、过载、崩溃而重启，任务也不会丢失，云队列会等待你的云引擎实例恢复正常后继续运行它们。我们也基于云队列重新实现了定时任务，它兼容之前的绝大部分用法，并支持以 JSON 形式向云函数传递自定义的参数，以及配置在超时情况下的行为（重试或放弃）。对了，我们还移除了定时任务的个数限制。</p> \n<h4>MySQL</h4> \n<p>我们在华北节点推出了高可用、高性价比的 <a href=\"https://leancloud.cn/docs/leandb_mysql_guide.html\" rel=\"nofollow noreferrer\">MySQL 数据库托管方案</a>。 <br>开发者可以在云引擎中使用通用的 MySQL 客户端类库，访问完整的 MySQL 功能。</p> \n<h4>其他</h4> \n<p>云引擎统计结果展示也进行了优化，现在开发者可以在控制台按照总览、网站托管请求以及单个云函数来分别查看请求数（按分钟聚合）和响应时间的变化趋势，还可以看到整体的 CPU、内存以及流量消耗，希望在程序运行状况和代码优化上给大家提供更多参考信息。</p> \n<p>云引擎命令行工具也发布了 0.21.0 版，修复了一些 bug，也支持指定 <code>--prod</code> 参数直接部署到生产环境，以及本地调试静态网站项目。</p> \n<p>云引擎 Java 环境支持指定 Java 版本，开发者可以选用 Java 8、11、12、13、14 来开发项目。</p> \n<p>云引擎 Node.js 环境新增了 <code>internal</code> 选项，用来禁止在客户端调用云函数。 <br>我们还推出了一个<a href=\"https://github.com/leancloud/leanengine-nodejs-demos\" rel=\"nofollow noreferrer\">常用功能和示例汇总代码仓库</a>，其中包括推荐的最佳实践和常用的代码片段，每个文件中都有较为详细的注释，适合云引擎的开发者阅读、参考，也可以将代码片段复制到你的项目中使用。</p> \n<h2>推送和即时通讯</h2> \n<p>Android 混合推送现已支持 <a href=\"https://leancloud.cn/docs/android_mixpush_guide.html#hash-29032758\" rel=\"nofollow noreferrer\">vivo</a>、<a href=\"https://leancloud.cn/docs/android_mixpush_guide.html#hash825173590\" rel=\"nofollow noreferrer\">oppo</a>、<a href=\"https://leancloud.cn/docs/android_mixpush_guide.html#hash1469908874\" rel=\"nofollow noreferrer\">小米推送国际版</a>，可以覆盖更多终端用户。</p> \n<p>我们还对即时通讯和推送服务做了一些其他改进和优化，以便为开发者提供更稳定的服务、更灵活的功能：</p> \n<ul> \n <li>即时通讯新增了<a href=\"https://leancloud.cn/docs/realtime-guide-systemconv.html#hash-2017196884\" rel=\"nofollow noreferrer\">客户端上下线 hook</a> 支持，在客户端登录成功、登出成功、意外下线后调用。</li> \n <li>通过 SDK 新建对话默认启用 <code>unique</code> 参数，更贴合大多数应用的使用场景。</li> \n <li>通过 REST API 发送消息现在也支持提醒用户（<code>mention_all</code> 和 <code>mention_client_ids</code> 参数）了。</li> \n <li>即时通讯的离线推送记录现在也加入到推送历史记录里面，可以在控制台一并查看。</li> \n <li>推送服务现在支持<a href=\"https://leancloud.cn/docs/push_guide.html#hash1858126366\" rel=\"nofollow noreferrer\">直接指定设备 ID 进行推送</a>，比<a href=\"https://leancloud.cn/docs/push_guide.html#hash-1836721397\" rel=\"nofollow noreferrer\">通过查询条件推送</a>更快，延迟更低。</li> \n <li>开发者现在能对<a href=\"https://leancloud.cn/docs/push_guide.html#hash137424715\" rel=\"nofollow noreferrer\">推送时间</a>和推送速度（<code>flow_control</code> 参数）进行更精细的控制。</li> \n</ul> \n<h2>游戏解决方案</h2> \n<p>为了更好服务较大规模的游戏开发者，我们推出了<a href=\"https://leancloud.cn/docs/multiplayer-server.html\" rel=\"nofollow noreferrer\">多人对战 GameServer 的独立部署版本</a>。独立部署的后端服务节点（集群），让业务完全独享所有的物理资源，以便给开发者带来更好的稳定性和灵活度。 </p> \n<p>相比于共享集群模式，独立部署的 GameServer 有如下优势：</p> \n<ul> \n <li>支持通过 <a href=\"https://leancloud.cn/docs/multiplayer-server-guide-java.html#hash290606338\" rel=\"nofollow noreferrer\">hook 函数</a> 的方式来编写服务端逻辑，业务扩展代码与 GameServer 在同一个进程内运行，与 Client Engine 方式相比在实时性上有显著提升。</li> \n <li>取消了部分使用限制，例如房间最大人数、最大消息下发频率、消息体大小限制等，在硬件能力许可范围内尽可能满足业务需求。</li> \n <li>对资源独占使用，支持自动扩容。</li> \n</ul> \n<p>此外，游戏解决方案迎来了以下改进：</p> \n<ul> \n <li>Client Engine 在完善底层架构、使用框架、文档之后，发布了正式版。</li> \n <li>排行榜增强了防作弊的策略，只放行可信环境的数据更新请求，避免被恶意刷榜。</li> \n <li>优化了游戏 SDK，简化了进入游戏大厅的逻辑，并且将消息序列化协议全部切换到 Protocol Buffers，进一步降低客户端的网络流量和传输延时。</li> \n</ul> \n<h2>控制台和官网</h2> \n<p>我们对控制台进行了改版，目前存储服务部分已经完成并上线。新版本的控制台，我们将存储相关的功能（如 LiveQuery、离线分析和应用内搜索）合并到了一起，对普通的结构化数据存储、文件、用户系统进行了拆分，并且将数据展示与权限设置、索引和性能优化等内容集中起来，希望控制台逻辑更清晰，可以给开发者带来便利。上文提到的云引擎统计结果展示界面的改进，就是基于新版控制台重新实现的。</p> \n<p>此外，控制台新增了激活归档应用和注销账号功能，个人实名认证也切换到了基于支付宝客户端的方案。我们也重新设计了<a href=\"https://www.leancloud.cn/pricing/\" rel=\"nofollow noreferrer\">官网的价格页面</a>，更加清晰、全面地展示各项服务的价格方案。</p> \n<h2>SDK</h2> \n<p>2019 年各 SDK 也发布了不少新版本，除了跟进上文提到的各服务的新功能外，主要还有以下改进：</p> \n<h4>Java</h4> \n<p>新推出的<a href=\"https://github.com/leancloud/java-unified-sdk\" rel=\"nofollow noreferrer\">统一的 Java SDK</a> 正式取代旧版的 Java SDK 和 Android SDK。 <br>新版的 SDK 全面采用了 Reactive 编程风格，同时也兼容老的 Callback 方式。在 Android 平台上，新版 SDK 切换到了 AndroidX。</p> \n<p>对于开发者担心的 Android 应用在客户端暴露 appKey 可能带来的潜在风险，我们现在允许应用程序<a href=\"https://leancloud.cn/docs/sdk_setup_android_securely.html\" rel=\"nofollow noreferrer\">只通过 appId 来完成 LeanCloud 服务初始化</a>，从而避免了暴露应用核心配置信息的风险。</p> \n<p>有些只使用推送服务的客户希望优化产品移动端体验，我们为此专门推出了<a href=\"https://github.com/leancloud/java-unified-sdk/tree/master/android-sdk/leancloud-push-lite\" rel=\"nofollow noreferrer\">精简版推送 SDK</a>，显著优化了安装包大小（1.2 MB -&gt; 180 KB）和启动时间（59 ms -&gt; 5 ms）。</p> \n<h4>Swift &amp; Objective C</h4> \n<p>Swift SDK 增加了对即时通讯、推送、云函数调用的支持，并完善了结构化存储方面的功能，在功能上基本对齐了 Android、Web 平台的 SDK。 <br>有许多 iOS 平台的开发者已经从 Objective C SDK 迁移到 Swift SDK， 还有一些新应用直接基于 Swift SDK 开发。</p> \n<p>Swift 语言的演进十分迅捷（swift），Swift SDK 同样如此，现已支持 Swift 5 和 Swift Package Manager。</p> \n<p>Objective C SDK 也增加了一些功能，修复了许多 bug。</p> \n<p>另外，为了精简代码和集中资源，Swift SDK 不再支持 iOS 10 之前的系统，Objective C SDK 不再支持 iOS 8 之前的系统。</p> \n<h4>JavaScript</h4> \n<p>JavaScript SDK 的主要改进有：</p> \n<ul> \n <li>小程序用户系统增加了 UnionId 支持。</li> \n <li>增加了手动启用、停用调试模式的开关：<code>debug.enable()</code> 和 <code>debug.disable()</code>。</li> \n <li> <code>AV.File#save</code> 方法增加了 <code>keepFileName</code> 参数允许保留文件的文件名。</li> \n <li>增加了 <code>AV.Object#revert</code> 方法撤销部分或全部修改了但未保存（save）的改动。</li> \n <li> <code>MESSAGE_UPDATE</code> 与 <code>MESSAGE_RECALL</code> 事件现在会额外返回一个 reason 参数来指示修改、撤回的原因（如果有的话）。</li> \n <li>修复和完善了大量 TypeScript 定义。</li> \n</ul> \n<h4>C Sharp</h4> \n<p>C# SDK 的主要改进有：</p> \n<ul> \n <li>简化、统一 portable 和 Unity 初始化方式，现在只需要在代码中初始化，不需要在 Unity Editor 拖拽和设置。</li> \n <li>增加消息撤回/修改功能。</li> \n</ul> \n<h2>结语</h2> \n<p>在这一年里，许多用户通过工单、论坛、邮件等各种渠道向我们反馈问题和意见，也有用户向我们开源的 SDK 提交代码。上面提到的很多新功能、改进、优化都源于用户的反馈。感谢大家的帮助和信赖，我们期待在新的一年里为用户提供更好的产品和服务。</p> \n<blockquote>\n 本文参与了 \n <a href=\"https://segmentfault.com/a/1190000021354599\">SegmentFault思否征文「2019 总结」</a>，欢迎正在阅读的你也加入。\n</blockquote>', null, null, '692c6787030d4b8882077b2ab9279c52', '1a7cc9fbc4654cb0afec84e080816ef1', 'd684aaace0484f8dbc17e1e28457d432,ed28022185f44ae4ba91f8f8b36dc265,c825aa5f765543a1a8c96368462f9371,a0ac07cb5e6b446f8d1b9034d86fd880,9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-23 10:57:19', '2020-04-23 10:57:19');
INSERT INTO `tb_recommend` VALUES ('ecf98dfb158f4050aa5b2fa7140b30fc', 'iOS SpringBoard tweak插件，双击图标快速启动debugserver', 'debugserver+lldb很好用，但启动起来太麻烦？我们开发了一款iOS SpringBoard tweak小插件，简化debugserver启动过程。老铁，请双击！', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326917\" src=\"http://localhost:8060/tup/2020/4/23/0bc8efd9587148b18d2b5b75a2fc7153.jpg\" alt=\"\" title=\"\"></span></p> \n<p>debugserver+lldb很好用，但启动起来太麻烦？我们开发了一款iOS SpringBoard tweak小插件，简化debugserver启动过程。老铁，请双击！</p> \n<h2>0x00 懒是第一生产力</h2> \n<p>我们经常要通过debugserver对App进行调试，有<a href=\"https://book.douban.com/subject/25826902/\" rel=\"nofollow noreferrer\">书籍</a>和<a href=\"http://bbs.iosre.com/t/debugserver-lldb-gdb/65\" rel=\"nofollow noreferrer\">论坛</a>对相关的技术和实践进行了说明，但实际应用起来还是有些麻烦。先要重签拷贝，再要启动终端ssh到iPhone启动debugserver，各种ls加grep找到想调试的应用，敲命令启动debugserver，然后Mac本地终端启动lldb。这样折腾下来，至少要开两个终端，有的时候甚至更多。GitHub上有个<a href=\"https://github.com/4ch12dy/issh\" rel=\"nofollow noreferrer\">issh工具</a>对上述操作有封装和优化，但是还是需要敲命令找App，再运行debugserver。</p> \n<p>所以做个tweak提升一下生产力。只需<strong>双击应用图标，即可一键启动debugserver</strong>。</p> \n<p><strong>代码见：Github</strong></p> \n<p><em><a href=\"https://github.com/TalkingData/tap2debug\" rel=\"nofollow noreferrer\">https://github.com/TalkingDat...</a></em></p> \n<p><strong>运行界面</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326916\" src=\"http://localhost:8060/tup/2020/4/23/b7f11baf93db4ec683f8bf50797b1b79.jpg\" alt=\"\" title=\"\"></span></p> \n<p>我们所用的开发环境是iOS 13.3，但是并没有用到特殊版本的API，低版本手机应该也OK。</p> \n<p>下面简单分享开发过程：</p> \n<h2>0x01 通过图标找到应用执行路径</h2> \n<p>从界面找逻辑，逆向发现SpringBoard的图标是<strong>SBIconView</strong>。并且有一个叫属性 <strong>applicationBundleIdentifierForShortcuts</strong> 返回的是图标对应的App的Bundle ID。通过Bundle ID构造<strong>LSApplicationProxy</strong>对象，并且获得<strong>canonicalExecutablePath</strong>属性，也就是应用的可执行文件路径。</p> \n<pre><code>Class LSApplicationProxy_class = objc_getClass(\"LSApplicationProxy\");NSObject* proxyObj = [LSApplicationProxy_class performSelector:@selector(applicationProxyForIdentifier:) withObject:bundle];NSString * canonicalExecutablePath = [proxyObj performSelector:@selector(canonicalExecutablePath)];复制代码</code></pre> \n<h2>0x02 寻找注入点添加扩展</h2> \n<p>接续看<strong>SBIconView</strong>，图标上有两个手势对象：</p> \n<ul> \n <li>单击，用来启动App。</li> \n <li>长按，进入编辑状态，执行删除和排列图标等操作。</li> \n</ul> \n<p>所以，我们来给图标交互加个双击扩展。</p> \n<p>%hook SBIconView</p> \n<pre><code>- (void)didMoveToWindow{    %orig;    UITapGestureRecognizer *doubleTap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(handleDoubleClick:)];    [doubleTap setNumberOfTapsRequired:2];    [self addGestureRecognizer:doubleTap];    NSArray * ges = self.gestureRecognizers;    for(UITapGestureRecognizer * each in ges){        if([each isKindOfClass:[UITapGestureRecognizer class]]){            [each requireGestureRecognizerToFail: doubleTap];        }    }}复制代码</code></pre> \n<p>这里额外说一句，[each requireGestureRecognizerToFail: doubleTap]添加了双击手势指挥，由于iOS内部维护了手势的状态机，我们进行单击操作的时候，其实产生了两种Possible State。第一种是识别为单击，然后结束。第二种是识别为双击的第一下并等待第二下的发生，然后根据两次点击之时间间隔阈值来判断是不是合法的双击。</p> \n<p>所以我们手动增加了约束，相当于指定了识别的优先级，只有双击失败了，才继续执行单击回调。这种操作会带来一点几乎无感的瑕疵：单击后等待双击识别失败的延迟，延迟的值就是双击识别执行的阈值（大约零点几秒）。</p> \n<h2>0x03 debugserver启动和关闭</h2> \n<p>debugserver是一个二进制文件，狗神的教程里有如何重签，issh把这些过程给简化了。先看一下debugserver的权限： <br><strong>-rwxr-xr-x 1 root admin 9876848 Jan 19 11:28 /iOSRE/tools/debugserver*</strong></p> \n<p>再来看一下SpringBoard的权限: <br><strong>-rwxr-xr-x 1 root wheel 71264 Dec 5 13:15 SpringBoard*</strong></p> \n<p>属主用户都是root，没毛病。找个函数调用一下：</p> \n<ol> \n <li>system函数</li> \n <li>posix_spawn函数</li> \n <li>NSTask ，面向对象方便管理，异步执行，不会block UI，就用它了。</li> \n</ol> \n<p>代码如下：</p> \n<pre><code>task = [[NSTask alloc]init];[task setLaunchPath:bin_serverpath];[task setArguments:args];[task launch];复制代码</code></pre> \n<p>每次server在launch之前，要把之前的task结束掉。</p> \n<pre><code>- (void)interrupt; // Not always possible. Sends SIGINT.复制代码</code></pre> \n<pre><code>- (void)terminate; // Not always possible. Sends SIGTERM.复制代码</code></pre> \n<p><strong>NSTask</strong>头文件里竟然告诉我 <strong>Not always possible</strong>。事实上，在调用的时候，还真的不怎么possible，实际测试第一次server正常启动，后续由于没成功关闭，所以第二次就没法启动了。</p> \n<p>所以还是换种方式关闭吧。简单粗暴的 kill 函数：</p> \n<pre><code>NSTask * task = [TaskManager sharedManager].runningTask;if(task){    kill(task.processIdentifier,SIGKILL);    task = nil;}复制代码</code></pre> \n<h2>0x04 添加UI交互</h2> \n<p>直接用Alert，又有按钮又有输入框，不过UIAlertView已经被废弃掉了，需要用UIAlertController。由于弹出Controller需要父Controller，通过View找到当前的Controller，做正向的应该都写过这段代码吧：</p> \n<pre><code>@implementation UIView(find)-(UIViewController*)findViewController{    UIResponder* target= self;    while (target) {        target = target.nextResponder;        if ([target isKindOfClass:[UIViewController class]]) {            break;        }    }    return (UIViewController*)target;}@end复制代码</code></pre> \n<h2>0x05 优化一下用户体验</h2> \n<p>输入框里的IP和debugserver的path，每个人都不一样，所以在第一次输入完成之后，把这些值用NSUserDefault持久化存储起来，下次直接读取填充。</p> \n<h2>0x06后记</h2> \n<p>之前在相关技术论坛读到讨论用Root身份运行App的帖子，学习完帖子里的技巧，增强对操作系统的理解以及实践之后，发现如果真的想RootApp运行，其实SpringBoard本身就是一个RootApp，我们把SpringBoard当做RootViewController，很容易把一些系统工具做出界面，从而提升生产力。比如砸壳、重签、拷贝App等。</p> \n<p>**<br>作者：TalkingData小张同学</p> \n<p>本文版权归TalkingData所有，如需转载请注明来源**</p>', null, 'http://localhost:8060/tup/2020/4/23/155a5b88c9cc42548a8b604253641b8e.jpg', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', 'a337904dd1d5477b9689d7693be316de', '84564b2b178141059e2bf061053de54b,85ee959b27f74072b13cc763b9bbf77e,c0d2479bf6564cf5aa35b1b40604f199', '0', '3', '1', '2020-04-23 10:31:33', '2020-04-23 10:31:33');
INSERT INTO `tb_recommend` VALUES ('ed264c4cad6a411c99eefe11102d3b05', '2020年面向前端开发人员的10个很棒的 JS 库', '点赞再看，养成习惯本文 GitHub [链接] 上已经收录，更多往期高赞文章的分类，也整理了很多我的文档，和教程资料。欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。', '<blockquote>\n 作者：Simon Holdorf\n <br>译者：前端小智\n <br>来源：medium\n</blockquote> \n<blockquote> \n <strong>点赞再看，养成习惯</strong>\n <p><strong>本文 <code>GitHub</code> <a href=\"https://github.com/qq449245884/xiaozhi\" rel=\"nofollow noreferrer\">https://github.com/qq44924588...</a> 上已经收录，更多往期高赞文章的分类，也整理了很多我的文档，和教程资料。欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。</strong></p> \n</blockquote> \n<p>虽然JavaScript本身很棒，但有它对应生态圈也很重要，这些圈会让 JS 更好。开发人员在开始一个新的中等项目时经常喜欢重新写轮子，这是一个糟糕的策略，使用第三方库是有意义的。因为这样的库有明确的用途，有更长生成的迭代，如果遇到问题更容易找到解决方法，最主要的一点是提高开发效率，缩短开发周期。</p> \n<p>这里并不是说我们每个项目都要使用第三方库。 在我们的职业生涯初期，最好自己能编写代码以进行学习。 但是在许多项目中，在有意义的地方使用库是一个不错的策略。</p> \n<p>这里推荐 <code>10</code> 个 JS 库，这些库都有很好的文档，也非常流行，并一直在维护中。</p> \n<h2>1. Ramda</h2> \n<p><strong>github:</strong><a href=\"https://github.com/ramda/ramda\" rel=\"nofollow noreferrer\">https://github.com/ramda/ramda</a></p> \n<p><strong>文档：</strong><a href=\"https://ramdajs.com/docs/\" rel=\"nofollow noreferrer\">https://ramdajs.com/docs/</a></p> \n<p><code>Ramda</code> 是一个用于函数式编程的很酷的 JS 库，目前在GitHub上有<code>18000</code>个星星。JS 的一个优点是开发人员可以选择函数式编程还是面向对象编程。这两种方法各有利弊，但是如果你喜欢函数式编程，那么一定要看看<code>Ramda</code>。</p> \n<p>主要功能是：</p> \n<ul> \n <li>不变性和无副作用的函数</li> \n <li>几乎所有的函数都是自动柯里化的</li> \n <li>参数设置为Ramda函数，便于进行柯里化</li> \n</ul> \n<h2>2. Lodash</h2> \n<p><strong>github:</strong> <a href=\"https://github.com/lodash/lodash\" rel=\"nofollow noreferrer\">https://github.com/lodash/lodash</a></p> \n<p><strong>文档：</strong> <a href=\"https://lodash.com/\" rel=\"nofollow noreferrer\">https://lodash.com/</a></p> \n<p><strong>Lodash</strong>仍然是最流行和最有用的 JS 库之一。它免去了处理字符串、数组、对象等的麻烦。目前它在GitHub上有<code>43000</code>颗星星。</p> \n<p>有用的功能：</p> \n<ul> \n <li>遍历字符串，对象和数组</li> \n <li>创建复合函数</li> \n <li>操作和测试值</li> \n</ul> \n<h2>3. Moment</h2> \n<p><strong>github:</strong> <a href=\"https://github.com/moment/moment\" rel=\"nofollow noreferrer\">https://github.com/moment/moment</a></p> \n<p><strong>文档：</strong> <a href=\"https://momentjs.com/\" rel=\"nofollow noreferrer\">https://momentjs.com/</a></p> \n<p>如果必须处理日期的操作、验证、解析或格式化，<code>Moment</code>可能是最好的 JS 库。它很轻，很完善，在GitHub上有<code>43000</code>多颗星，它可以在浏览器和<code>Node.js</code>中工作。</p> \n<p>以下是一些有关<strong>Moment</strong>的示例：</p> \n<pre><code>moment().startOf(\'day\').fromNow(); //8 hours ago\nmoment(\'2019-15-11\').isValid() //false\nmoment(\'2019-02-21\').isValid() //true</code></pre> \n<p><strong>大家都说简历没项目写，我就帮大家找了一个项目，还附赠<a href=\"https://github.com/qq449245884/xiaozhi/issues/210\" rel=\"nofollow noreferrer\">【搭建教程】</a>。</strong></p> \n<h2>4. Highlight.js</h2> \n<p><strong>github:</strong> <a href=\"https://github.com/highlightjs/highlight.js\" rel=\"nofollow noreferrer\">https://github.com/highlightj...</a></p> \n<p><strong>文档：</strong> <a href=\"https://highlightjs.org/\" rel=\"nofollow noreferrer\">https://highlightjs.org/</a></p> \n<p><strong>Highlight.js</strong> 是一个用于语法高亮显示的库，可在浏览器和服务器上使用。 它几乎可以与任何Markdown一起使用，并具有自动语言检测功能。</p> \n<p><code>Highlight.js</code>将在<code>&lt;pre&gt; &lt;code&gt;</code>标记之间搜索编程代码，尝试自动检测语言并突出显示语法。 它还支持不同的配色方案。</p> \n<p>下面是一个用 JS 编写的代码片段和来自代码编辑器的公共主题的示例</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEDmq\" src=\"http://localhost:8060/tup/2020/4/23/bbae2f88d8e145d58224e6d766c06c0c.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<h2>5. D3</h2> \n<p><strong>github:</strong> <a href=\"https://github.com/d3/d3\" rel=\"nofollow noreferrer\">https://github.com/d3/d3</a></p> \n<p><strong>文档：</strong> <a href=\"https://d3js.org/\" rel=\"nofollow noreferrer\">https://d3js.org/</a></p> \n<p><strong>D3</strong>是最流行的数据可视化库，目前在GitHub上有<code>89,500</code>星。 它使用Web标准，并利用现代浏览器的强大功能，使数据栩栩如生。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEDmt\" src=\"http://localhost:8060/tup/2020/4/23/847aac6ec5a242889392b8278c635298.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<h2>6. Three.js</h2> \n<p><strong>github:</strong> <a href=\"https://github.com/mrdoob/three.js\" rel=\"nofollow noreferrer\">https://github.com/mrdoob/thr...</a></p> \n<p><strong>文档：</strong> <a href=\"https://threejs.org/\" rel=\"nofollow noreferrer\">https://threejs.org/</a></p> \n<p><strong>Three.js</strong>是出色的JS 3D库，它使用 WebGL 作为主要渲染器，但也支持其他渲染器，例如<code>Canvas 2D</code>，<code>SVG</code>和<code>CSS3D</code>。 它在GitHub上有<code>58,000</code>个Star，我们可以用它创建非常酷的东西。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEDnI\" src=\"http://localhost:8060/tup/2020/4/23/2f0d374c4280414d98d789dbec762bcd.jpg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<h2>7. Voca</h2> \n<p><strong>github:</strong> <a href=\"https://github.com/panzerdp/voca\" rel=\"nofollow noreferrer\">https://github.com/panzerdp/voca</a></p> \n<p><strong>文档：</strong> <a href=\"https://vocajs.com/\" rel=\"nofollow noreferrer\">https://vocajs.com/</a></p> \n<p><code>Voca</code>是一个用于处理字符串的优秀 JS 库。目前在GitHub上有<code>2,800</code>颗星。我们可以使用它来操作字符串，如更改大小写、修剪、pad、slugify、latinise、截断、转义等。</p> \n<p>其他功能包括：</p> \n<ul> \n <li>完整的函数集，可操纵，chop，格式化，转义和查询字符串</li> \n <li>易于阅读和搜索的文档</li> \n <li>支持多种环境，例如 Chrome，Firefox，Node.js</li> \n <li>100％的代码覆盖率，没有依赖性</li> \n</ul> \n<h2>8. Immutable.js</h2> \n<p><strong>github:</strong> <a href=\"https://github.com/immutable-js/immutable-js\" rel=\"nofollow noreferrer\">https://github.com/immutable-...</a></p> \n<p><strong>文档：</strong> <a href=\"https://immutable-js.github.io/immutable-js/\" rel=\"nofollow noreferrer\">https://immutable-js.github.i...</a></p> \n<p>使用不可变数据结构具有一些主要优点，例如简化了应用程序开发，无防御性拷贝以及高级缓存概念。</p> \n<p><code>Immutable.js</code>供了不变的数据结构，如列表，堆栈，映射，集合等。</p> \n<h2>9. Hammer.js</h2> \n<p><strong>github:</strong> <a href=\"https://github.com/hammerjs/hammer.js\" rel=\"nofollow noreferrer\">https://github.com/hammerjs/h...</a></p> \n<p><strong>文档：</strong> <a href=\"http://hammerjs.github.io/\" rel=\"nofollow noreferrer\">http://hammerjs.github.io/</a></p> \n<p><code>Hammer.js</code>是一个 JS 库，具有<code>20,900</code>个GitHub Stars，可为Web应用程序带来多点触摸手势。 它很小，没有任何依赖性，并且可以识别由触摸，鼠标或指针事件产生的手势。 默认情况下，它会添加用于点击，双击，滑动，按下等的识别器，但是您可以定义自己的此类识别器集。</p> \n<h2>10. Leaflet</h2> \n<p><strong>github:</strong> <a href=\"https://github.com/Leaflet/Leaflet\" rel=\"nofollow noreferrer\">https://github.com/Leaflet/Le...</a></p> \n<p><strong>文档：</strong> <a href=\"https://leafletjs.com/\" rel=\"nofollow noreferrer\">https://leafletjs.com/</a></p> \n<p>在创建移动友好的交互式地图时，<code>Leaflet</code> 是一个很棒的 JS 库。它是开源的，在GitHub上有<code>26700</code>个星星，非常轻量，并且拥有大多数开发人员需要的所有特性。</p> \n<p>它可以在所有主流的移动和桌面平台上开箱即用，可以通过插件进行扩展，并且有一个文档良好的、简单的API。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEDoU\" src=\"http://localhost:8060/tup/2020/4/23/a95cc6bccfa2433b983bf478fa68aefe.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<hr> \n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\" rel=\"nofollow noreferrer\">Fundebug</a>。</strong></p> \n<p>原文：<a href=\"https://hackr.io/blog/best-javascript-frameworks\" rel=\"nofollow noreferrer\">https://hackr.io/blog/best-ja...</a></p> \n<hr> \n<h2>交流</h2> \n<p>文章每周持续更新，可以微信搜索「 大迁世界 」第一时间阅读和催更（比博客早一到两篇哟），本文 GitHub <a href=\"https://github.com/qq449245884/xiaozhi\" rel=\"nofollow noreferrer\">https://github.com/qq449245884/xiaozhi</a> 已经收录，整理了很多我的文档，欢迎Star和完善，大家面试可以参照考点复习，另外关注公众号，后台回复<strong>福利</strong>，即可看到福利，你懂的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020353567?w=800&amp;h=400\" src=\"http://localhost:8060/tup/2020/4/23/1c8e1a699cf04eab89604b706cc8bcff.jpg\" alt=\"\" title=\"\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/4b94b930d70e4fe2b2ce1b912e391908.jpg', '1894b118d35d44cb8fe8009529c4154b', '049b3bd76c1e49ccbe48b36197e77f76', 'd79254c4ca5e45dca9d484307c935281,63c4e1e7ec204b43a62065a3ced4c2ce,1d0ffae0426e4e6e8add67530ec689b4', '0', '3', '1', '2020-04-23 10:25:35', '2020-04-23 10:25:35');
INSERT INTO `tb_recommend` VALUES ('edbe49dc32df449faf22c025333cbecb', 'Transformer 在美团搜索排序中的实践', '美团搜索是美团 App 连接用户与商家的一种重要方式，而排序策略则是搜索链路的关键环节，对搜索展示效果起着至关重要的效果。目前，美团的搜索排序流程为多层排序，分别是粗排、精排、异构排序等，多层排序的流程...', '<h2>引言</h2> \n<p>美团搜索是美团 App 连接用户与商家的一种重要方式，而排序策略则是搜索链路的关键环节，对搜索展示效果起着至关重要的效果。目前，美团的搜索排序流程为多层排序，分别是粗排、精排、异构排序等，多层排序的流程主要是为了平衡效果和性能。其中搜索核心精排策略是 DNN 模型，美团搜索始终贴近业务，并且结合先进技术，从特征、模型结构、优化目标角度对排序效果进行了全面的优化。</p> \n<p>近些年，基于 Transformer[1] 的一些 NLP 模型大放光彩，比如 BERT[2] 等等，将 Transformer 结构应用于搜索推荐系统也成为业界的一个潮流。比如应用于对 CTR 预估模型进行特征组合的 AutoInt[3]、行为序列建模的 BST[4] 以及重排序模型 PRM[5]，这些工作都证明了 Transformer 引入搜索推荐领域能取得不错的效果，所以美团搜索核心排序也在 Transformer 上进行了相关的探索。</p> \n<p>本文旨在分享 Transformer 在美团搜索排序上的实践经验。内容会分为以下三个部分：第一部分对 Transformer 进行简单介绍，第二部分会介绍 Transfomer 在美团搜索排序上的应用以及实践经验，最后一部分是总结与展望。希望能对大家有所帮助和启发。</p> \n<h2>Transformer 简介</h2> \n<p>Transformer 是谷歌在论文《Attention is all you need》[1] 中提出来解决 Sequence to Sequence 问题的模型，其本质上是一个编解码（Encoder-Decoder ）结构，编码器 Encoder 由 6 个编码 block 组成，Encoder 中的每个 block 包含 Multi-Head Attention 和 FFN（Feed-Forward Network）；同样解码器 Decoder 也是 6 个解码 block 组成，每个 block 包含 Multi-Head Attention、Encoder-Decoder Attention 和 FFN。具体结构如图 1 所示，其详细的介绍可参考文献[1,6]。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022398549\" src=\"http://localhost:8060/tup/2020/4/23/b29d65a3fa06431fb2210a5c9666ce44.jpg\" alt=\"\" title=\"\"></span></p> \n<p>考虑到后续内容出现的 Transformer Layer 就是 Transformer 的编码层，这里先对它做简单的介绍。它主要由以下两部分组成：</p> \n<p><strong>Multi-Head Attention</strong></p> \n<p>Multi-Head Attention 实际上是 h 个 Self-Attention 的集成， h 代表头的个数。其中 Self-Attention 的计算公式如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022398551\" src=\"http://localhost:8060/tup/2020/4/23/d19fa7e0d03942f5ad33721f387c1e9e.jpg\" alt=\"\" title=\"\"></span></p> \n<p>其中，Q代表查询，K代表键，V代表数值。</p> \n<p>在我们的应用实践中，原始输入是一系列 Embedding 向量构成的矩阵 E<br>，矩阵 E 首先通过线性投影：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022398552\" src=\"http://localhost:8060/tup/2020/4/23/8f51da7b09a1479c865afb34ed947a78.jpg\" alt=\"\" title=\"\"></span></p> \n<p>得到三个矩阵：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022398550\" src=\"http://localhost:8060/tup/2020/4/23/852fd694a737493c81fcaac324f007d9.jpg\" alt=\"\" title=\"\"></span></p> \n<p>然后将投影后的矩阵输入到 Multi-Head Attention。计算公式如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022398553\" src=\"http://localhost:8060/tup/2020/4/23/99c1b3c093d64d6b9fb89f36873fd7d1.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>Point-wise Feed-Forward Networks</strong></p> \n<p>该模块是为了提高模型的非线性能力提出来的，它就是全连接神经网络结构，计算公式如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022398555\" src=\"http://localhost:8060/tup/2020/4/23/11e6573505ee4c3e803381811a7b5378.jpg\" alt=\"\" title=\"\"></span></p> \n<p>Transformer Layer 就是通过这种自注意力机制层和普通非线性层来实现对输入信号的编码，得到信号的表示。</p> \n<h2>美团搜索排序Transformer实践经验</h2> \n<p>Transformer 在美团搜索排序上的实践主要分以下三个部分：第一部分是特征工程，第二部分是行为序列建模，第三部分是重排序。下面会逐一进行详细介绍。</p> \n<h3>特征工程</h3> \n<p>在搜索排序系统中，模型的输入特征维度高但稀疏性很强，而准确的交叉特征对模型的效果又至关重要。所以寻找一种高效的特征提取方式就变得十分重要，我们借鉴 AutoInt[3] 的方法，采用 Transformer Layer 进行特征的高阶组合。</p> \n<h3>模型结构</h3> \n<p>我们的模型结构参考 AutoInt[3] 结构，但在实践中，根据美团搜索的数据特点，我们对模型结构做了一些调整，如下图 2 所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022398554\" src=\"http://localhost:8060/tup/2020/4/23/fd338e3f52814dbaa1d88d40c06a0cb2.jpg\" alt=\"\" title=\"\"></span></p> \n<p>相比 AutoInt[3]，该结构有以下不同：</p> \n<ul> \n <li>保留将稠密特征和离散特征的 Embedding 送入到 MLP 网络，以隐式的方式学习其非线性表达。</li> \n <li>Transformer Layer 部分，不是送入所有特征的 Embedding，而是基于人工经验选择了部分特征的 Embedding，第一点是因为美团搜索场景特征的维度高，全输入进去会提高模型的复杂度，导致训练和预测都很慢；第二点是，所有特征的 Embedding 维度不完全相同，也不适合一起输入到 Transformer Layer 。</li> \n</ul> \n<p><strong>Embedding Layer 部分</strong>：众所周知在 CTR 预估中，除了大规模稀疏 ID 特征，稠密类型的统计特征也是非常有用的特征，所以这部分将所有的稠密特征和稀疏 ID 特征都转换成 Embedding 表示。</p> \n<p><strong>Transformer 部分</strong>：针对用户行为序列、商户 、品类 、地理位置等 Embedding 表示，使用 Transformer Layer 来显示学习这些特征的交叉关系。</p> \n<p><strong>MLP 部分</strong>：考虑到 MLP 具有很强的隐式交叉能力，将所有特征的 Embedding 表示 concat 一起输入到 MLP。</p> \n<p><strong>实践效果及经验</strong></p> \n<p><strong>效果</strong>：离线效果提升，线上 QV_CTR 效果波动。</p> \n<p><strong>经验：</strong></p> \n<ul> \n <li>三层 Transformer 编码层效果比较好。</li> \n <li>调节多头注意力的“头”数对效果影响不大 。</li> \n <li>Transformer 编码层输出的 Embedding 大小对结果影响不大。</li> \n <li>Transformer 和 MLP 融合的时候，最后结果融合和先 concat 再接一个全连接层效果差不多。</li> \n</ul> \n<h3>行为序列建模</h3> \n<p>理解用户是搜索排序中一个非常重要的问题。过去，我们对训练数据研究发现，在训练数据量很大的情况下，item 的大部分信息都可以被 ID 的 Embedding 向量进行表示，但是用户 ID 在训练数据中是十分稀疏的，用户 ID 很容易导致模型过拟合，所以需要大量的泛化特征来较好的表达用户。这些泛化特征可以分为两类：一类是偏静态的特征，例如用户的基本属性（年龄、性别、职业等等）特征、长期偏好（品类、价格等等）特征；另一类是动态变化的特征，例如刻画用户兴趣的实时行为序列特征。而用户实时行为特征能够明显加强不同样本之间的区分度，所以在模型中优化用户行为序列建模是让模型更好理解用户的关键环节。</p> \n<p>目前，主流方法是采用对用户行为序列中的 item 进行 Sum-pooling 或者 Mean-pooling 后的结果来表达用户的兴趣，这种假设所有行为内的 item 对用户的兴趣都是等价的，因而会引入一些噪声。尤其是在美团搜索这种交互场景，这种假设往往是不能很好地进行建模来表达用户兴趣。</p> \n<p>近年来，在搜索推荐算法领域，针对用户行为序列建模取得了重要的进展：DIN 引入注意力机制，考虑行为序列中不同 item 对当前预测 item 有不同的影响[7]；而 DIEN 的提出，解决 DIN 无法捕捉用户兴趣动态变化的缺点[8]。DSIN 针对 DIN 和 DIEN 没有考虑用户历史行为中的 Session 信息，因为每个 Session 中的行为是相近的，而在不同 Session 之间的差别很大，它在 Session 层面上对用户的行为序列进行建模[9]；BST 模型通过 Transformer 模型来捕捉用户历史行为序列中的各个 item 的关联特征，与此同时，加入待预测的 item 来达到抽取行为序列中的商品与待推荐商品之间的相关性[4]。这些已经发表过的工作都具有很大的价值。接下来，我们主要从美团搜索的实践业务角度出发，来介绍 Transformer 在用户行为序列建模上的实践。</p> \n<h3>模型结构</h3> \n<p>在 Transformer 行为序列建模中，我们迭代了三个版本的模型结构，下面会依次进行介绍。</p> \n<p>模型主要构成：所有特征（user 维度、item 维度、query 维度、上下文维度、交叉维度）经过底层 Embedding Layer 得到对应的 Embedding 表示；建模用户行为序列得到用户的 Embedding 表示；所有 Embedding concat 一起送入到三层的 MLP 网络。</p> \n<p><strong>第一个版本</strong>：因为原来的 Sum-pooling 建模方式没有考虑行为序列内部各行为的关系，而 Transformer 又被证明能够很好地建模序列内部之间的关系，所以我们尝试直接将行为序列输入到 Transformer Layer，其模型结构如图3 所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022398556\" src=\"http://localhost:8060/tup/2020/4/23/e4191653fc21426991d6d84b2a353c80.jpg\" alt=\"\" title=\"\"></span></p> \n<p><strong>行为序列建模</strong></p> \n<p><strong>输入部分：</strong></p> \n<ul> \n <li>分为短期行为序列和长期行为序列。</li> \n <li>行为序列内部的每个行为原始表示是由商户 ID，以及一些商户泛化信息的 Embedding 进行 concat 组成。</li> \n <li>每段行为序列的长度固定，不足部分使用零向量进行补齐。</li> \n</ul> \n<p><strong>输出部分</strong>：对 Transformer Layer 输出的向量做 Sum-pooling （这里尝试过Mean-pooling、concat，效果差不多）得到行为序列的最终 Embedding 表示。</p> \n<p>该版本的离线指标相比线上 Base（行为序列 Sum-pooling） 模型持平，尽管该版本没有取得离线提升，但是我们继续尝试优化。</p> \n<p><strong>第二个版本</strong>：第一个版本存在一个问题，对所有的 item 打分的时候，用户的 Embedding 表示都是一样的，所以参考 BST[4]，在第一个版本的基础上引入 Target-item，这样可以学习行为序列内部的 item 与 Target-item 的相关性，这样在对不同的 item 打分时，用户的 Embedding 表示是不一样的，其模型结构如下图4 所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022398557\" src=\"http://localhost:8060/tup/2020/4/23/7122f9ccc1ea489ca7fdd0a83002e556.jpg\" alt=\"\" title=\"\"></span></p> \n<p>该版本的离线指标相比线上 Base（行为序列 Sum-pooling） 模型提升，上线发现效果波动，我们仍然没有灰心，继续迭代优化。</p> \n<p><strong>第三个版本</strong>：和第二个版本一样，同样针对第一个版本存在的对不同 item 打分，用户 Embedding 表示一样的问题，尝试在第一个版本引入 Transformer 的基础上，叠加 DIN[7] 模型里面的 Attention-pooling 机制来解决该问题，其模型结构如图5 所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022398558\" src=\"http://localhost:8060/tup/2020/4/23/171d28f60f5943d7807fe651cc3c9731.jpg\" alt=\"\" title=\"\"></span></p> \n<p>该版本的离线指标相比第二个版本模型有提升，上线效果相比线上 Base（行为序列 Sum-pooling）有稳定提升。</p> \n<p><strong>实践效果及经验</strong></p> \n<p><strong>效果</strong>：第三个版本（Transformer + Attention-pooling）模型的线上 QV_CTR 和 NDCG 提升最为显著。</p> \n<p><strong>经验：</strong></p> \n<ul> \n <li>Transformer 编码为什么有效？Transformer 编码层内部的自注意力机制，能够对序列内 item 的相互关系进行有效的建模来实现更好的表达，并且我们离线实验不加 Transformer 编码层的 Attention-pooling，发现离线 NDCG 下降，从实验上证明了 Transformer 编码有效。</li> \n <li>Transformer 编码为什么优于 GRU ？忽略 GRU 的性能差于 Transformer；我们做过实验将行为序列长度的上限往下调，Transformer 的效果相比 GRU 的效果提升在缩小，但是整体还是行为序列的长度越大越好，所以Transformer 相比 GRU 在长距离时，特征捕获能力更强。</li> \n <li>位置编码（Pos-Encoding）的影响我们试过加 Transformer 里面原生的正余弦以及距当前预测时间的时间间隔的位置编码都无效果，分析应该是我们在处理行为序列的时候，已经将序列切割成不同时间段，一定程度上包含了时序位置信息。为了验证这个想法，我们做了仅使用一个长序列的实验（对照组不加位置编码，实验组加位置编码，离线 NDCG 有提升），这验证了我们的猜测。</li> \n <li>Transformer 编码层不需要太多，层数过多导致模型过于复杂，模型收敛慢效果不好。</li> \n <li>调节多头注意力的“头”数对效果影响不大。</li> \n</ul> \n<h3>重排序</h3> \n<p>在引言中，我们提到美团搜索排序过去做了很多优化工作，但是大部分都是集中在 PointWise 的排序策略上，未能充分利用商户展示列表的上下文信息来优化排序。一种直接利用上下文信息优化排序的方法是对精排的结果进行重排，这可以抽象建模成一个序列（排序序列）生成另一个序列（重排序列）的过程，自然联想到可以使用 NLP 领域常用的 Sequence to Sequence 建模方法进行重排序建模。</p> \n<p>目前业界已有一些重排序的工作，比如使用 RNN 重排序[10-11]、Transformer 重排序[5]。考虑到 Transformer 相比 RNN 有以下两个优势：（1）两个 item 的相关性计算不受距离的影响 （2）Transformer 可以并行计算，处理效率比 RNN 更高；所以我们选择 Transformer 对重排序进行建模。</p> \n<h3>模型结构</h3> \n<p>模型结构参考了 PRM[5]，结合美团搜索实践的情况，重排序模型相比 PRM 做了一些调整。具体结构如图 6 所示，其中 D1，D2，...，Dn 是重排商户集合，最后根据模型的输出 Score(D1)，Score(D2)，...，Score(Dn)按照从大到小进行排序。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022398559\" src=\"http://localhost:8060/tup/2020/4/23/f1ecbeab4fda48f2852a80e51d947f31.jpg\" alt=\"\" title=\"\"></span></p> \n<p>主要由以下几个部分构成：</p> \n<ul> \n <li> <strong>特征向量生成</strong>：由原始特征（user、item、交叉等维度的稠密统计特征）经过一层全连接的输出进行表示。</li> \n <li> <strong>输入层</strong>：其中 X 表示商户的特征向量，P 表示商户的位置编码，将特征向量 X 与位置向量 P 进行 concat 作为最终输入。</li> \n <li> <strong>Transformer编码层</strong>：一层 Multi-Head Attention 和 FFN 的。</li> \n <li> <strong>输出层</strong>：一层全连接网络得到打分输出 Score。</li> \n</ul> \n<p><strong>模型细节：</strong></p> \n<ul> \n <li>特征向量生成部分和重排序模型是一个整体，联合端到端训练。</li> \n <li>训练和预测阶段固定选择 TopK 进行重排，遇到某些请求曝光 item 集不够 TopK 的情况下，在末尾补零向量进行对齐。</li> \n</ul> \n<p><strong>实践效果及经验</strong></p> \n<p><strong>效果</strong>：Transformer 重排序对线上 NDCG 和 QV_CTR 均稳定正向提升。</p> \n<p><strong>经验：</strong></p> \n<ul> \n <li>重排序大小如何选择？考虑到线上性能问题，重排序的候选集不能过大，我们分析数据发现 95% 的用户浏览深度不超过 10，所以我们选择对 Top10 的商户进行重排。</li> \n <li>位置编码向量的重要性：这个在重排序中很重要，需要位置编码向量来刻画位置，更好的让模型学习出上下文信息，离线实验发现去掉位置向量 NDCG@10 下降明显。</li> \n <li>性能优化：最初选择商户全部的精排特征作为输入，发现线上预测时间太慢；后面进行特征重要性评估，筛选出部分重要特征作为输入，使得线上预测性能满足上线要求。</li> \n <li>调节多头注意力的“头”数对效果影响不大。</li> \n</ul> \n<h2>总结和展望</h2> \n<p>2019 年底，美团搜索对 Transformer 在排序中的应用进行了一些探索，既取得了一些技术沉淀也在线上指标上取得比较明显的收益，不过未来还有很多的技术可以探索。</p> \n<ul> \n <li>在特征工程上，引入 Transformer 层进行高阶特征组合虽然没有带来收益，但是在这个过程中也再次验证了没有万能的模型对所有场景数据有效。目前搜索团队也在探索在特征层面应用 BERT 对精排模型进行优化。</li> \n <li>在行为序列建模上，目前的工作集中在对已有的用户行为数据进行建模来理解用户，未来要想更加深入全面的认识用户，更加丰富的用户数据必不可少。当有了这些数据后如何进行利用，又是一个可以探索的技术点，比如图神经网络建模等等。</li> \n <li>在重排序建模上，目前引入 Transformer 取得了一些效果，同时随着强化学习的普及，在美团这种用户与系统强交互的场景下，用户的行为反馈蕴含着很大的研究价值，未来利用用户的实时反馈信息进行调序是个值得探索的方向。例如，根据用户上一刻的浏览反馈，对用户下一刻的展示结果进行调序。</li> \n</ul> \n<p>除了上面提到的三点，考虑到美团搜索上承载着多个业务，比如美食、到综、酒店、旅游等等，各个业务之间既有共性也有自己独有的特性，并且除了优化用户体验，也需要满足业务需求。为了更好的对这一块建模优化， 我们也正在探索 Partition Model 和多目标相关的工作，欢迎业界同行一起交流。</p> \n<h2>参考资料</h2> \n<ul> \n <li>[1] Vaswani A, Shazeer N, Parmar N, et al. Attention is all you need[C]//Advances in neural information processing systems. 2017: 5998-6008.</li> \n <li>[2] Devlin J, Chang M W, Lee K, et al. Bert: Pre-training of deep bidirectional transformers for language understanding[J]. arXiv preprint arXiv:1810.04805, 2018.</li> \n <li>[3] Song W, Shi C, Xiao Z, et al. Autoint: Automatic feature interaction learning via self-attentive neural networks[C]//Proceedings of the 28th ACM International Conference on Information and Knowledge Management. 2019: 1161-1170.</li> \n <li>[4] Chen Q, Zhao H, Li W, et al. Behavior sequence transformer for e-commerce recommendation in Alibaba[C]//Proceedings of the 1st International Workshop on Deep Learning Practice for High-Dimensional Sparse Data. 2019: 1-4.</li> \n <li>[5] Pei C, Zhang Y, Zhang Y, et al. Personalized re-ranking for recommendation[C]//Proceedings of the 13th ACM Conference on Recommender Systems. 2019: 3-11.</li> \n <li>[6] <a href=\"http://jalammar.github.io/illustrated-transformer/\" rel=\"nofollow noreferrer\">http://jalammar.github.io/ill...</a> </li> \n <li>[7] Zhou G, Zhu X, Song C, et al. Deep interest network for click-through rate prediction[C]//Proceedings of the 24th ACM SIGKDD International Conference on Knowledge Discovery &amp; Data Mining. ACM, 2018: 1059-1068.</li> \n <li>[8] Zhou G, Mou N, Fan Y, et al. Deep interest evolution network for click-through rate prediction[C]//Proceedings of the AAAI Conference on Artificial Intelligence. 2019, 33: 5941-5948.</li> \n <li>[9] Feng Y, Lv F, Shen W, et al. Deep Session Interest Network for Click-Through Rate Prediction[J]. arXiv preprint arXiv:1905.06482, 2019.</li> \n <li>[10] Zhuang T, Ou W, Wang Z. Globally optimized mutual influence aware ranking in e-commerce search[J]. arXiv preprint arXiv:1805.08524, 2018.</li> \n <li>[11] Ai Q, Bi K, Guo J, et al. Learning a deep listwise context model for ranking refinement[C]//The 41st International ACM SIGIR Conference on Research &amp; Development in Information Retrieval. 2018: 135-144.</li> \n</ul> \n<h2>作者简介</h2> \n<p>肖垚，家琪，周翔，陈胜，云森，永超，仲远，均来自美团 AI 平台搜索与 NLP 部负责人。</p> \n<h2>招聘信息</h2> \n<p>美团搜索核心排序组，长期招聘搜索推荐算法工程师，坐标北京。欢迎感兴趣的同学发送简历到：tech@meituan.com（邮件标题请注明：美团搜索核心排序组）</p> \n<p><strong>阅读更多技术文章，请扫码关注微信公众号-美团技术团队！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021702131\" src=\"http://localhost:8060/tup/2020/4/23/1420a9ec0c9c44d59ba160df30466c8f.jpg\" alt=\"\" title=\"\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/e0b792fcab074b41a162fd9a565c8dd8.jpg', '1c5851dc916d4e70a60f0c957f548876', 'cbad2058b4014634aec6515f4adbef0d', '6808a59932024dceb5e1c0898504a56b,6fd300174477475faf83572ffb5f6579,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-23 10:55:25', '2020-04-23 10:55:25');
INSERT INTO `tb_recommend` VALUES ('edeaf8cb727041af9ba624375f6c1d9a', 'Dart 学习之开发语言概览，带思维导图', '之前在学习flutter，本以为自己可以轻松上手掌握dart，结果发现经常有不懂的语法。所以决定踏踏实实的学习一遍dart。网上有很多相关学习资料.我主要从官网来学习，然后又找了一个视频来补充学习。', '<p>之前在学习flutter，本以为自己可以轻松上手掌握dart，结果发现经常有不懂的语法。所以决定踏踏实实的学习一遍dart。网上有很多相关学习资料.我主要从官网来学习，然后又找了一个视频来补充学习。</p> \n<p>文章中涉及的代码，可以从我的<a href=\"https://github.com/siberiawolf/dart_study\" rel=\"nofollow noreferrer\">Github</a>上找到。</p> \n<ul> \n <li>第一遍先看中文文档。毕竟母语是汉语，有利于快速了解。大概掌握自己哪里是之前就会的知识，哪里是新知识。这一遍只看，不进行代码编写。</li> \n <li>制作思维导图。在看第一遍的时候，可以用思维导图制作一个清晰的脉络图。也不需要太复杂，只需要将每个大标题、小标题添加上就行。等接下来再去补充。</li> \n <li>第二遍就看英文文档。因为第一遍的时候，对文档已经都有印象了，再看英文文档就会比较容易。主要是为了加强自己的英文阅读的能力，这样看得多了，慢慢也就记得多了。</li> \n <li>第二遍的时候，遇到不会的生单词，或者高频的单词，记下来，扩大自己的词汇量。就算现在记不住，也先混个脸熟。</li> \n <li>第二遍还要进行代码的演练。光看文档的话，我可没有那么强的天赋，能全都理解，毕竟文档只是给出了部分代码示例，或者说是<strong>伪代码</strong>。所以这一遍将文档中所涉及的代码全部进行一遍演练。</li> \n <li>第二遍的时候，还要顺手做两件事情。其中一件就是补充之前做的思维导图，将其完整化。另一件就是，整理一下学习笔记，也就是现在写的这篇笔记。笔记的内容主要记录自己的学习内容即可。</li> \n <li>第三遍，观看视频。这最后一遍，就是查漏补缺，有时候文档里面没有的，在视频中还能涉及不少，及时补充。另外视频最重要的一点，就是有些地方看文档、写代码并没有明白，视频中刚好涉及了，稍微一听，也就明白了。当然了，视频比较长，只要是之前学过了，就可以跳步看。</li> \n</ul> \n<p>其实这样学下来的话，是比较耗时间的，但是我想还是扎实一下基础吧，磨刀不误砍柴工。往往有时候做项目的话，遇到一些细节，就会模棱两可，含糊不清。甚至有时候看到一块代码，并没有接触过，然后去百度、查文档，虽然当时有印象了，但知识并不系统。</p> \n<h1>环境搭建</h1> \n<h3>1. 安装Dart SDK</h3> \n<p>我的电脑是Mac系统，所以需要安装<a href=\"https://brew.sh/\" rel=\"nofollow noreferrer\">Homebrew</a>。这里我遇到的问题是始终下载失败。最后是通过科学上网以后才下载成功。</p> \n<p>接着按照<a href=\"http://www.dartdoc.cn/get-dart\" rel=\"nofollow noreferrer\">官网</a>给出的示例，安装dart。</p> \n<p>最后在终端中输入<code>dart --version</code>显示dart版本号就说明安装成功了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022086546\" src=\"http://localhost:8060/tup/2020/4/23/a474b1738a91480fb560dba7b88d8ecc.jpg\" alt=\"dart安装成功\" title=\"dart安装成功\"></span></p> \n<h3>2. 配置编辑器的Dart插件</h3> \n<p>Dart环境我使用的是VS Code，非常简单，只需要安装Dart的插件即可。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022086547\" src=\"http://localhost:8060/tup/2020/4/23/810a2bf02bbd4c269173a66ddeffb2d3.jpg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li>Code Runner: 是在VS Code中运行Dart插件</li> \n <li>Dart:是核心插件</li> \n</ul> \n<p>编写一个测试文件：<strong>test.dart</strong></p> \n<pre><code class=\"dart\">void main(){\n  // dart类似java，需要一个入口main函数\n  print(\'123\');\n}</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022086549\" src=\"http://localhost:8060/tup/2020/4/23/a5d89ddce2b646c4b9237906b85a3a04.jpg\" alt=\"\" title=\"\"></span></p> \n<p>运行结果如上，说明Dart环境已经配置好了。</p> \n<p><strong>注意：</strong></p> \n<ul>\n <li>dart中的文件命名规范是使用下划线分隔符，例如<code>test_hello</code>，而不要使用驼峰命名了。可以去查看官方规范手册。</li>\n</ul> \n<h1>重要概念</h1> \n<ul> \n <li>所有变量引用的都是 对象，每个对象都是一个 类 的实例。数字、函数以及 null 都是对象。所有的类都继承于 Object 类。</li> \n <li>尽管 Dart 是强类型语言，但是在声明变量时指定类型是可选的，因为 Dart 可以进行类型推断。在上述代码中，变量 number 的类型被推断为 int 类型。如果想显式地声明一个不确定的类型，可以使用特殊类型 dynamic。</li> \n <li>Dart 支持泛型，比如 List&lt;int&gt;（表示一组由 int 对象组成的列表）或 List&lt;dynamic&gt;（表示一组由任何类型对象组成的列表）。</li> \n <li>Dart 支持顶级函数（例如 main 方法），同时还支持定义属于类或对象的函数（即 静态 和 实例方法）。你还可以在函数中定义函数（嵌套 或 局部函数）。</li> \n <li>Dart 支持顶级 变量，以及定义属于类或对象的变量（静态和实例变量）。实例变量有时称之为域或属性。</li> \n <li>Dart 没有类似于 Java 那样的 public、protected 和 private 成员访问限定符。如果一个标识符以下划线 (_) 开头则表示该标识符在库内是私有的。可以查阅 库和可见性 获取更多相关信息。</li> \n <li>标识符 可以以字母或者下划线 (_) 开头，其后可跟字符和数字的组合。</li> \n <li>Dart 中 表达式 和 语句 是有区别的，表达式有值而语句没有。比如条件表达式 expression condition ? expr1 : expr2 中含有值 expr1 或 expr2。与 if-else 分支语句相比，if-else 分支语句则没有值。一个语句通常包含一个或多个表达式，但是一个表达式不能只包含一个语句。</li> \n <li>Dart 工具可以显示 警告 和 错误 两种类型的问题。警告表明代码可能有问题但不会阻止其运行。错误分为编译时错误和运行时错误；编译时错误代码无法运行；运行时错误会在代码运行时导致异常。</li> \n</ul> \n<h1>变量</h1> \n<p><strong>变量定义</strong></p> \n<pre><code class=\"dart\">//变量仅存储对象的引用\nvar name = \'Bob\'; \n\n// 未初始化的变量拥有一个默认的初始化值：null。即便数字也是如此，因为在 Dart 中一切皆为对象，数字也不例外。\nint lineCount;\nassert(lineCount == null);\n</code></pre> \n<p><strong>final和const</strong></p> \n<pre><code class=\"dart\">final name = \'Bob\'; // Without a type annotation\nfinal String nickname = \'Bobby\';\n\n// const 关键字不仅仅可以用来定义常量，还可以用来创建 常量值\nvar foo = const [];\nfinal bar = const [];\nconst baz = []; // 相当于 `const []` (Equivalent to `const []`)\n\n// 还可以在变量中使用类型检查\n\n// Valid compile-time constants as of Dart 2.5.\nconst Object i = 3; // Where i is a const Object with an int value...\nconst list = [i as int]; // Use a typecast.\nconst map = {if (i is int) i: \"int\"}; // Use is and collection if.\nconst set = {if (list is List&lt;int&gt;) ...list}; // ...and a spread\n</code></pre> \n<h1>内置类型</h1> \n<h2>Numbers</h2> \n<p>Dart 两种数据类型:<code>int</code>和<code>double</code></p> \n<p>下面是字符串和数字之间转换的方式：</p> \n<pre><code class=\"dart\">// String -&gt; int\nvar one = int.parse(\'1\');\nassert(one == 1);\n\n// String -&gt; double\nvar onePointOne = double.parse(\'1.1\');\nassert(onePointOne == 1.1);\n\n// int -&gt; String\nString oneAsString = 1.toString();\nassert(oneAsString == \'1\');\n\n// double -&gt; String 并且保留了指定的小数\nString piAsString = 3.14159.toStringAsFixed(2);\nassert(piAsString == \'3.14\');</code></pre> \n<h2>Strings</h2> \n<p>使用单引号或双引号定义</p> \n<pre><code class=\"dart\">var s1 = \'Single quotes work well for string literals.\';\nvar s2 = \"Double quotes work just as well.\";\nvar s3 = \'It\\\'s easy to escape the string delimiter.\';\nvar s4 = \"It\'s even easier to use the other delimiter.\";</code></pre> \n<p>字符串拼接可以使用<code>+</code>或者直接挨在一起的方式</p> \n<pre><code class=\"dart\">var s1 = \'String \'\n    \'concatenation\'\n    \" works even over line breaks.\";\n    \nvar s2 = \'The + operator \' + \'works, as well.\';</code></pre> \n<p>可以使用三个单引号或者三个双引号创建多行字符串：</p> \n<pre><code class=\"dart\">var s1 = \'\'\'\n你可以像这样创建多行字符串。\n\'\'\';\n\nvar s2 = \"\"\"这也是一个多行字符串。\"\"\";</code></pre> \n<p>只要是编译时常量都可以作为字符串字面量的插值表达式</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n// These work in a const string.\nconst aConstNum = 0;\nconst aConstBool = true;\nconst aConstString = \'a constant string\';\n\n// These do NOT work in a const string.\nvar aNum = 0;\nvar aBool = true;\nvar aString = \'a string\';\nconst aConstList = [1, 2, 3];\n\nconst validConstString = \'$aConstNum $aConstBool $aConstString\';\nprint(validConstString);\n\n// 非编译时变量，不可以赋值\n// const invalidConstString = \'$aNum $aBool $aString $aConstList\';\n\nvar invalidConstString = \'$aNum $aBool $aString $aConstList\'; // 编译时变量，可以赋值\n\n}</code></pre> \n<p>string常用属性：</p> \n<ul> \n <li>length</li> \n <li>isEmpty</li> \n <li>isNotEmpty</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  String a = \'123\'; \n  print(a.length); // 3\n \n  print(a.isEmpty); // false\n\n  print(a.isNotEmpty);  // true\n}</code></pre> \n<p>string常用属性</p> \n<ul> \n <li>contains</li> \n <li>subString</li> \n <li>startsWith</li> \n <li>endsWith</li> \n <li>indexOf</li> \n <li>lastIndexOf</li> \n <li>toLowerCase</li> \n <li>toUpperCase</li> \n <li>trim</li> \n <li>trimLeft</li> \n <li>trimRight</li> \n <li>split</li> \n <li>replaceXXX</li> \n</ul> \n<h2>Booleans</h2> \n<p>布尔类型只有<code>true</code>和<code>false</code>。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var test;\n\n  // dart中一切皆是对象，所以要显示判断是否为null\n  if(test == null){\n    print(\'test is null\');\n  }\n}</code></pre> \n<h2>List</h2> \n<p>Dart中数组用<code>List</code>对象表示。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 1.可以混合的list\n  var list1 = [1, 2, 3, \'4\'];\n  print(list1);\n\n  // 2.只可以是指定类型的list\n  List&lt;int&gt; list2 = [1, 2, 3];\n  print(list2);\n\n  // 3.用const关键字定义一个编译时数组常量\n  List&lt;int&gt; list3 = const [1, 2, 3];\n  print(list3);\n\n  list3[1] = 4; // 编译时出错，不可以修改\n\n  // 4.通过构造方式创建数组\n\n  List fixedLengthList = new List(3);\n  print(fixedLengthList.length); // 3\n\n}\n</code></pre> \n<p>Dart中数组长度类似JavaScript语法。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var list = [1, 2, 3, 4];\n\n  print(list.length); // true\n\n  print(list[1] == 2);  // true\n\n  list[2] = 4;\n  print(list);  // [1, 2, 4, 4]\n}</code></pre> \n<p>Dart中新增扩展操作符</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var list1 = [1, 2, 3, 4, 5];\n  var nullList;\n  // 使用 ... 扩展list插入到另一个list\n  var list2 = [0, ...list1];\n\n  print(list2); // [0, 1, 2, 3, 4, 5]\n\n  // 使用 ...? 如果nullList为空，则不插入\n  var list3 = [0, ...?nullList];\n\n  print(list3);\n}</code></pre> \n<p>Dart 还可以使用<code>Collection If </code>和<code>Collection for </code>来根据条件创建数组。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n\n  /// 可以根据test条件，动态创建数组\n  var test = true;\n\n  var list = [\n    1, \n    2,\n    3,\n    if(test) 4\n  ];\n\n  print(list);    // [1, 2, 3, 4]\n\n  /// 也可以用循环遍历另一个数组创建一个数组\n  var arrays = [1,2,3,4];\n\n  var location = [\n    \'#0\',\n    for(var i in arrays) \'#$i\'\n  ];\n\n  print(location);    // [#0, #1, #2, #3, #4]\n}</code></pre> \n<p>List常用的操作</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var a = [1, 2, 3];\n  a.add(4);\n  print(a); // [1, 2, 3, 4]\n\n  a.insert(1, 100);\n  print(a);   // [1, 100, 2, 3, 4]\n\n  a.remove(4);\n  print(a);   // [1, 100, 2, 3]\n\n  // 打乱顺序\n  a.shuffle();\n  print(a); // [2, 3, 100, 1]\n\n  print(a.asMap()); // {0: 1, 1: 100, 2: 2, 3: 3}\n\n  // 排序\n  List&lt;String&gt; numbers = [\'two\', \'three\', \'four\'];\n  // Sort from shortest to longest.\n  numbers.sort((a, b) =&gt; a.length.compareTo(b.length));\n  print(numbers);  // [two, four, three]\n  \n  // 截取\n  a.sublist(1);\n  print(a);\n\n  // 可以调用print直接打印，或者自定义其他函数\n  numbers.forEach(print);\n}\n</code></pre> \n<h2>Sets</h2> \n<p>创建sets</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var names = &lt;String&gt;{}; // 类型+{}的形式创建Set。\n  Set&lt;String&gt; names2 = {}; // 声明类型变量的形式创建 Set (This works, too).\n  var names3 = {}; // 这样的形式将创建一个 Map 而不是 Set (Creates a map, not a\n\n  print(names.runtimeType); // _CompactLinkedHashSet&lt;String&gt;\n  print(names3.runtimeType); // _InternalLinkedHashMap&lt;dynamic, dynamic&gt;\n}</code></pre> \n<p><strong>注意：</strong><br>如果忘记在 <code>{}</code> 上注释类型或赋值到一个未声明类型的变量上，那么 Dart 会创建一个类型为 <code>Map&lt;dynamic, dynamic&gt;</code> 的对象。</p> \n<h2>Maps</h2> \n<p>创建Map</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n\n  // 相当于 Map&lt;String, String&gt; test = {}\n  var test = {\n    \'a\': \'1\',\n    \'b\': \'2\',\n    \'c\': \'3\'\n  };\n\n  // 可以不使用关键字New实例化一个对象\n  var gifts = Map();\n  gifts[\'first\'] = \'partridge\';\n  gifts[\'second\'] = \'turtledoves\';\n  gifts[\'fifth\'] = \'golden rings\';\n\n}</code></pre> \n<p>操作Map</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var map = {\'a\': 1, \'b\': 2, \'c\': 3};\n\n  print(map.length); // 3\n\n  print(map.isNotEmpty); // true\n\n  print(map.isEmpty); // false\n\n  print(map.keys); // (a, b, c)\n\n  print(map.values); // (1, 2, 3)\n\n  print(map.containsKey(\'c\')); // true\n\n  print(map.containsValue(4)); // false\n\n  // 移除\n  map.remove(\'a\'); // {b: 2, c: 3}\n  print(map);\n\n  map.forEach((key, value) {\n    print(\'key = $key, value = $value\');\n    // key = b, value = 2\n    // key = c, value = 3\n  });\n}\n</code></pre> \n<h1>运算符</h1> \n<h2>算术运算符</h2> \n<p>以前我没用过取整运算符，这里记一下。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  print(2 + 3 == 5);\n  print(2 - 3 == -1);\n  print(2 * 3 == 6);\n  // 除\n  print(5 / 2 == 2.5); // 结果是一个浮点数\n  // 取整\n  print(5 ~/ 2 == 2); // 结果是一个整数\n  // 取余\n  print(5 % 2 == 1); // 取余\n  \n  print(\'5/2 = ${5 ~/ 2} r ${5 % 2}\' == \'5/2 = 2 r 1\');\n}\n</code></pre> \n<p><strong>自增与自减</strong></p> \n<p>文档中的自增与自减解释很棒。</p> \n<ul> \n <li>++var和--var，先对var变量进行计算，然后再赋值给另一个变量</li> \n <li>var++和var--，先将var变量赋值给另外一个变量，然后再对自身进行操作</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var a, b;\n\n  a = 0;\n  b = ++a; // 在 b 赋值前将 a 增加 1。\n  print(a == b); // 1 == 1  \n\n  a = 0;\n  b = a++; // 在 b 赋值后将 a 增加 1。\n  print(a != b); // 1 != 0, a = 1\n\n  a = 0;\n  b = --a; // 在 b 赋值前将 a 减少 1。\n  print(a == b); // -1 == -1, a = -1\n\n  a = 0;\n  b = a--; // 在 b 赋值后将 a 减少 1。\n  print(a != b); // -1 != 0\n}\n</code></pre> \n<h2>关系运算符</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n\n  \n  print(2 == 2);\n  print(2 != 3);\n  print(3 &gt; 2);\n  print(2 &lt; 3);\n  print(3 &gt;= 3);\n  print(2 &lt;= 3);\n}\n</code></pre> \n<h2>类型判断运算符</h2> \n<p>当且仅当 <code>obj</code> 实现了 <code>T </code>的接口，<code>obj is T</code> 才是 true。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Emp emp = Emp();\n  Person p = Person(\'张三\');\n    \n  print(emp is Person);   // true\n\n}\nclass Person{\n  final _name;\n\n  Person(this._name);\n}\nclass Emp implements Person{\n  // 必须实现\n  get _name =&gt; \'\';\n}\n</code></pre> \n<h2>赋值运算符</h2> \n<ul> \n <li>使用 <code>=</code> 来赋值</li> \n <li> <code>??=</code> 来为值为 null 的变量赋值</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var a;\n  var b;\n\n  a = 1;\n  //  当且仅当 b 为 null 时才赋值\n  b ??= 2;\n\n  print(a); // 1\n  print(b); // 2\n\n\n  var c = 9;\n  c ~/= 2;\n\n  print(c); // 4\n\n}</code></pre> \n<h2>逻辑运算符</h2> \n<p>使用逻辑运算符你可以反转或组合布尔表达式</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var flag = true;\n  const tab = 0;\n\n  if (flag &amp;&amp; (tab == 3 || tab == 0)) {\n    print(\'hello\'); // hello\n  }\n}\n</code></pre> \n<h2>条件表达式</h2> \n<ul> \n <li>如果赋值是根据布尔表达式则考虑使用 <code>?:</code> </li> \n <li>如果赋值是根据判定是否为 null 则考虑使用 <code>??</code> </li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 三目运算符写法 good\n  String playName(String name) =&gt; name != null ? name : \'Tom\';\n\n  // ??写法  best\n  String playName3(String name) =&gt; name ?? \'Tom\';\n\n  // if - else 写法  bad\n  String playName2(String name) {\n    if (name != null) {\n      return name;\n    } else {\n      return \'Tom\';\n    }\n  }\n}\n</code></pre> \n<h2>级联运算符</h2> \n<p>级联运算符<code>（..）</code>可以让你在同一个对象上连续调用多个对象的变量或方法。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 级联运算符严格意义上说并不是一个操作符，而是dart的特殊语法\n  var p = Person()\n  ..name = \'tom\'\n  ..age = 1\n  ..say(); // name = tom, age = 1\n  // 最后直接调用了say方法\n}\n\nclass Person{\n  String name;\n  int age;\n\n  void say(){\n    print(\'name = $name, age = $age\');  \n  }\n}</code></pre> \n<h1>流程控制语句</h1> \n<p>与 JavaScript 不同的是，Dart 的 if 语句中的条件必须是一个布尔值，不能是其它类型</p> \n<h2>if和else</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var bar = false;\n  if (bar ==false){\n    print(\'false\');\n  }else if( bar == true){\n    print(\'true\');\n  }else{\n    print(\'not true or false\');\n  }\n}</code></pre> \n<h2>for 循环</h2> \n<p>Dart在循环中的闭包会自动捕获。下面的例子在JavaScript中就会输出两个2。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n\n  // for 循环中的闭包会自动捕获循环的 索引值 以避免 JavaScript 中一些常见的陷阱\n  var list = [];\n  for(var i =0; i&lt;2; i++){\n    list.add(()=&gt;print(i));\n  }\n  list.forEach((v) =&gt; v());\n}</code></pre> \n<p>不需要数组索引时，使用forEach即可</p> \n<pre><code class=\"dart\">  var prints = [1, 2,3];\n  prints.forEach((v)=&gt;print(v));</code></pre> \n<p>List和Set支持for-in</p> \n<pre><code class=\"dart\">  // List和Set支持for-in\n  var collections = [1, 2, 3, 4];\n  for (var i in collections) {\n    print(\'i = $i\');\n    print(i);\n  }</code></pre> \n<h2>while和do-while</h2> \n<ul> \n <li>while 循环会在执行循环体前先判断条件</li> \n <li>do-while 循环则会先执行一遍循环体 再 判断条件：</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var i = 0;\n  while (true) {\n    ++i;\n    print(i); // 1 2 3\n    if (i == 3) break;\n  }\n  print(\'i = $i\');\n  do {\n    i++;\n    print(i); // 4 5 6\n    if(i == 6)break;\n  } while (true);\n}\n</code></pre> \n<h2>break 和 continue</h2> \n<ul> \n <li>break 跳出循环</li> \n <li>continue 继续循环</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  for(var i = 0; i&lt;3; i++){\n    print(i); // 输出0 1\n    if(i ==1  ){ // 跳出循环\n      break;\n    }\n    print(\'hi 我被执行了\'); // 只输出一次\n  }\n\n  for(var i = 0; i&lt;3; i++){\n    print(i);// 输出 0 1 2\n    if(i ==1  ){ // 继续循环\n      continue;\n    }\n    print(\'hi 我被执行了\'); // 输出2次，第二次被跳过了，循环继续\n  }\n\n  \n\n}</code></pre> \n<h2>switch 和 case</h2> \n<ul> \n <li>Switch 语句在 Dart 中使用 == 来比较整数、字符串或编译时常量，比较的两个对象必须是同一个类型且不能是子类并且没有重写 == 操作符</li> \n <li>每一个非空的 case 子句都必须有一个 break 语句</li> \n <li>当没有 case 语句匹配时，可以使用 default 子句来匹配这种情况</li> \n <li> <code>case</code>如果为空，则采用<code>fall-through</code>形式</li> \n <li> <code>case</code>如果为非空，则采用<code>continue</code>和label标签</li> \n <li>case中的变量为局部变量</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var name = \'annie\';\n  switch (name) {\n    case \'tim\':\n      print(\'tim\');\n      break;\n    case \'peter\':\n      print(\'peter\');\n      break;\n    case \'jack\': // fall-through 形式\n    case \'tom\':\n      print(\'jack and tom\');\n      break;\n    case \'annie\':\n      print(\'annie\');\n      continue ruth; // 继续执行标签为ruth的语句\n\n    ruth:\n    case \'ruth\':\n      print(\'ruth\');\n      break;\n    case \'wilson\':\n      var test = \'test\'; // 局部变量\n      print(test);\n      break;\n  }\n  \n}\n</code></pre> \n<h2>断言</h2> \n<ul> \n <li>在开发环境下，添加断言来打断代码的执行</li> \n <li> <code>assert</code> 是否生效依赖开发工具和使用的框架，在命令行中可以执行<code>dart</code>命令</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var num = 100;\n  // 命令行中执行 dart --enable-asserts 断言.dart \n  // 然后就会报错，后面的所有内容不再执行\n  assert(num &lt; 10);\n\n  // 第二个参数可以指定异常错误信息\n  assert(num &lt; 90,\n    \'异常： ($num) 不小于90\');\n\n    // 如果直接执行 dart 断言.dart 因为是在生产环境，所以不会出现错误\n}</code></pre> \n<h1>函数</h1> \n<h2>函数定义</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n  // 函数最好定义返回值\n  bool isBool(bool flag){\n    var test = false;\n    return test;\n  }\n  \n  // 不写返回值倒是也行\n  isBool2(bool flag){\n    var test = false;\n    return test;\n  }\n\n  // 使用箭头函数\n  isBool3(bool flag) =&gt; flag = false;\n}</code></pre> \n<h2>命名可选参数</h2> \n<p>虽然参数是可选，但是也可以指定某个参数为必传，使用<code>@required</code>。</p> \n<pre><code class=\"dart\">import \'package:meta/meta.dart\';\n\nvoid main(List&lt;String&gt; args) {\n  // 定义一个可选命名参数\n  void saySomething({String name, int age}){\n    print(\'name = $name, age = $age\');\n  }\n\n  // 调用可选命名参数时，不需要写{}\n  saySomething(name: \'tom\', age: 12); // name = tom, age = 12\n  saySomething(name: \'cook\'); // name = cook, age = null\n\n  // time参数必须传递\n  // 使用@required 注解必须导入meta包\n  // 导入meta.dart包，则必须在pubspec.yaml 文件中进行声明\n  void playGame({String name,@required int time}){\n    print(\'name = $name, age = $time\');\n  }\n\n  // 虽然使用了@required 注解，并不会对应用程序报错，而是发出警告\n  playGame(name: \'和平精英\');\n}</code></pre> \n<h2>位置可选参数</h2> \n<p>位置可选参数用 <code>[]</code>表示</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n  void say(String name, int age, [String address]){\n    if(address == null){\n      print(\'name = $name, age = $age\');\n    }else{\n      print(\'name = $name, age = $age, address = $address\');\n    }    \n  }\n  say(\'tom\', 123);  // name = tom, age = 123\n  say(\'tim\', 34, \'北京\');   // name = tim, age = 34, address = 北京\n\n \n}</code></pre> \n<h2>默认值</h2> \n<p>可以使用<code>=</code>给可选参数设置默认值</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  void startEng({bool oil = true, bool state = false}){\n    return print(oil &amp;&amp; state);\n  }\n\n  startEng(); // 默认false\n  startEng(state:true); // true\n  startEng(oil:true,state:true); // true\n\n  // 如果name使用默认值，但是传递 age 呢？\n  String say(String start, String end, [String name = \'jack\', int age]){\n    if(name != null){ // 永远不为null\n      print(\'start = $start, end = $end, name = $name\');\n    }\n    if(age!=null){\n     print(\'start = $start, end = $end, name = $name, age = $age\');\n    }\n  }\n\n  say(\'北京\',\'上海\', \'张三\');\n  say(\'河南\',\'河北\', \'jack\', 22);\n}</code></pre> \n<h2>main函数</h2> \n<ul> \n <li>所有Dart程序都必须有一个入口<code>main</code>函数</li> \n <li>可以在命令行中传递参数</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  print(args);\n\n  // 命令行中没有传递参数时\n  if(args.length == 0)return;\n\n  // 命令行中执行  dart main函数.dart 1 test\n  if(int.parse(args[0]) == 1){\n    print(\'第一个参数为 ${args[0]}\');\n  }\n\n  if(args.length == 2){\n    print(\'参数的个数是 ${args.length}\');\n  }\n}</code></pre> \n<h2>函数作为一级对象</h2> \n<ul> \n <li>将函数作为参数传递给另一个函数</li> \n <li>将函数作为一个变量</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  void say(int num){\n    print(\'hello dart, and num is $num\');\n  }\n\n  List&lt;int&gt; list = const [1,2,3,4];\n\n  // 将函数作为参数传递给另一个函数\n  list.forEach(say);\n\n  // 将函数作为一个变量\n  var printName = (v)=&gt;print(\'you are print $v\');\n  printName(\'jack\');  // you are print jack\n\n  var printName2 = (v){ return print(\'another print name function $v\');};\n  printName2(\'tom\');  // another print name function tom\n}</code></pre> \n<h2>匿名函数</h2> \n<ul> \n <li>匿名函数就是没有函数名称的函数</li> \n <li>函数体只有单行时，可以使用箭头函数</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var list = [1, 2, 3, 4];\n\n  // 匿名函数\n  list.forEach((v) {\n    print(v);\n  });\n  // 箭头函数\n  list.forEach((v) =&gt; print(v));\n\n  List&lt;String&gt; getTime(List list, String times(str)) {\n    List&lt;String&gt; tmp = [];\n    list.forEach((v) {\n      tmp.add(times(v));\n    });\n    return tmp;\n  }\n\n  String times(str) {\n    return str * 3;\n  }\n\n  var list2 = [\'h\', \'e\', \'l\', \'l\', \'o\'];\n  // 这里调用 times 时不需要写()，否则就变成了执行函数了\n  print(getTime(list2, times)); // [hhh, eee, lll, lll, ooo]\n}\n</code></pre> \n<h2>词法作用域</h2> \n<pre><code class=\"dart\">bool topLevel = true;\n\nvoid main() {\n  var insideMain = true;\n\n  void myFunction() {\n    var insideFunction = true;\n\n    // 内部函数可以逐级向上访问外部函数变量\n    void nestedFunction() {\n      var insideNestedFunction = true;\n\n      print(topLevel);\n      print(insideMain);\n      print(insideFunction);\n      print(insideNestedFunction);\n    }\n  }\n\n}</code></pre> \n<h2>闭包</h2> \n<ul> \n <li>函数对象的调用在它原始作用域之外，能够访问在它词法作用域内的变量</li> \n <li>函数可以封闭定义到它作用域内的变量</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 闭包就是一个函数对象\n  // 函数可以封闭它作用域内的变量，即使是函数在外部调用\n  Function sum(int add){ // 注意返回值类型是函数\n    return (i) =&gt; add + i;\n  }\n\n  // 这个1就是add，然后被封闭了起来\n  var sumAll = sum(1); \n\n  print(sumAll(1)); // 2\n\n\n  // 闭包就是在一个函数中返回另一个函数\n  a(){\n\n    var count = 0;\n    void printCount(){\n        print(count ++);\n    }\n    return printCount;\n  }\n\n  var fun = a();\n\n  // 想访问方法中的局部变量时，就使用闭包\n  fun(); // 0\n  fun(); // 1\n}</code></pre> \n<h2>函数相等性测试</h2> \n<ul> \n <li>不同实例的函数之间不相等</li> \n <li>静态方法、顶级函数，都相等</li> \n</ul> \n<pre><code class=\"dart\">void foo() {} // 定义顶层函数 (A top-level function)\n\nclass A {\n  static void bar() {} // 定义静态方法\n  void baz() {} // 定义实例方法\n}\n\nvoid main() {\n  var x;\n\n  // 比较顶层函数是否相等。\n  x = foo;\n  assert(foo == x);\n\n  // 比较静态方法是否相等。\n  x = A.bar;\n  assert(A.bar == x);\n\n  // 比较实例方法是否相等。\n  var v = A(); // A 的实例 #1\n  var w = A(); // A 的实例 #2\n  var y = w;\n  x = w.baz;\n\n  // 这两个闭包引用了相同的实例对象，因此它们相等。\n  assert(y.baz == x);\n\n  // 这两个闭包引用了不同的实例对象，因此它们不相等。\n  assert(v.baz != w.baz);\n}</code></pre> \n<h2>返回值</h2> \n<ul> \n <li>所有函数都有返回值</li> \n <li>如果没有指定就返回null</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 这里没有指定函数返回值\n  // 实际上，如果指定了，编辑器就会报错\n  foo(){}\n\n  var test = foo();\n\n  print(test); // null\n}</code></pre> \n<h1>库和可见性</h1> \n<ul> \n <li>使用<code>import</code>关键字导入</li> \n <li>dart内置库，使用<code>dart:xxxx</code> </li> \n <li>其他库，<code>package:xxxx</code> </li> \n <li>以下划线（_）开头的成员仅在代码库中可见</li> \n <li>每个 Dart 程序都是一个库，即便没有使用关键字 library 指定</li> \n</ul> \n<h2>库前缀</h2> \n<p>如果两个库代码有冲突，可以指定库前缀</p> \n<pre><code class=\"dart\">import \'package:lib1/lib1.dart\';\nimport \'package:lib2/lib2.dart\' as lib2;\n\n// 使用 lib1 的 Element 类。\nElement element1 = Element();\n\n// 使用 lib2 的 Element 类。\nlib2.Element element2 = lib2.Element();</code></pre> \n<h2>导入库的一部分</h2> \n<p>只想使用代码库中的一部分，你可以有选择地导入代码库</p> \n<pre><code class=\"dart\">// 只导入 lib1 中的 foo。(Import only foo).\nimport \'package:lib1/lib1.dart\' show foo;\n\n// 导入 lib2 中除了 foo 外的所有。\nimport \'package:lib2/lib2.dart\' hide foo;</code></pre> \n<h1>注释</h1> \n<h2>单行注释</h2> \n<p>单行注释以 <code>//</code> 开始。所有在 <code>//</code> 和该行结尾之间的内容被编译器忽略。</p> \n<pre><code class=\"dart\">// 单行注释</code></pre> \n<h2>多行注释</h2> \n<ul> \n <li>不会忽略文档注释</li> \n <li>多行注释可以嵌套</li> \n <li>多行注释以 <code>/*</code> 开始，以 <code>*/</code> 结尾。所有在 <code>/*</code> 和 <code>*/</code> 之间的内容被编译器忽略</li> \n</ul> \n<pre><code class=\"dart\">void main() {\n  /*\n   * This is a lot of work. Consider raising chickens.\n\n  Llama larry = Llama();\n  larry.feed();\n  larry.exercise();\n  larry.clean();\n   */\n}</code></pre> \n<h2>文档注释</h2> \n<ul>\n <li>在文档注释中，除非用中括号括起来，否则 Dart 编译器会忽略所有文本。</li>\n</ul> \n<pre><code class=\"dart\">/// A domesticated South American camelid (Lama glama).\n///\n/// Andean cultures have used llamas as meat and pack\n/// animals since pre-Hispanic times.\nclass Llama {\n  String name;\n\n  /// Feeds your llama [Food].\n  ///\n  /// The typical llama eats one bale of hay per week.\n  void feed(Food food) {\n    // ...\n  }\n\n  /// Exercises your llama with an [activity] for\n  /// [timeLimit] minutes.\n  void exercise(Activity activity, int timeLimit) {\n    // ...\n  }\n}</code></pre> \n<p>在生成的文档中，[Food] 会成为一个链接，指向 Food 类的 API 文档。</p> \n<p>也就是说，在生成的文档中[Food]这个标识符就可以显示一个链接。</p> \n<h1>类型定义</h1> \n<ul> \n <li>使用typedef显示保留类型信息</li> \n <li>目前类型定义只能在函数上</li> \n</ul> \n<pre><code class=\"dart\">// 自定义一个类型\ntypedef Compare = int Function(Object a, Object b);\n\n/// 使用类型定义的情况\nclass SortedCollection {\n  Compare compare;  // 自定义类型\n\n  SortedCollection(this.compare);\n}\n\n// 简单的不完整实现。\nint sort(Object a, Object b) =&gt; 0;\n\nvoid main() {\n  SortedCollection coll = SortedCollection(sort);\n  print(coll.compare is Function); // true\n  print(coll.compare is Compare); // true\n}</code></pre> \n<h1>类</h1> \n<h2>声明类</h2> \n<ul> \n <li>使用class声明</li> \n <li>使用new创建一个对象，new可以省略</li> \n <li>所有对象都是一个类的实例</li> \n <li>所有的类都继承自 Object 类</li> \n</ul> \n<h2>使用类成员</h2> \n<ul> \n <li>类的成员包括函数和数据</li> \n <li>使用(.)来访问变量和方法</li> \n <li>使用<code>(?.)</code>避免表达式为null</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Person p = Person();\n  p.name = \'tom\';\n  p.age = 12;\n  print(p.name); // tom\n\n  /// ?. \n  // 因为p2是null，所以无法设置并且打印\n  // 但是使用了?.以后就不会报错了。\n  Person p2;\n  p2?.name = \'jack\';\n  p2?.age = 13;\n  print(p2?.name);  // null\n}\n\nclass Person{\n  String name;\n  int age;\n}</code></pre> \n<h2>使用构造函数</h2> \n<ul> \n <li>使用类名</li> \n <li>使用类名.标识符</li> \n <li>使用identical函数判断两个类的实例是否相等</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 通过 类 创建实例\n  Person p = Person(\'tom\', 12);\n  print(p.name);  // tom\n  print(p.age); // 12\n\n  // 通过 类名.标识符 创建实例\n  Person p2 = Person.fromJson({\'name\': \'jack\', \'age\': 13})  ;\n  print(p2.name); // jack\n  print(p2.age); // 13\n\n  Animal a = const Animal(\'titi\', 2);\n  Animal b  = const Animal(\'titi\', 2);\n  print(a.name);\n  print(a.age);\n\n  print(b.name);\n\n  // 两个实例相等\n  print(identical(a,b));  // true\n\n\n}\n\nclass Person{\n  String name;\n  int age;\n\n  Person(this.name, this.age);\n\n  Person.fromJson(Map&lt;String, dynamic&gt; json){\n    name = json[\'name\'];\n    age = json[\'age\'];\n  }\n}\n\n// 常量构造函数\nclass Animal{\n  final String name;\n  final int age;\n\n  const Animal(this.name, this.age);\n}</code></pre> \n<h2>实例变量</h2> \n<ul> \n <li>所有未初始化的变量均会被设置为null</li> \n <li>所有实例变量均会隐式地声明一个 Getter 方法</li> \n <li>所有 非 final 变量均会隐式声明一个 Setter方法</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Point p = Point();\n  print(p.x); // 调用x的 Getter\n\n  p.y = 1; // 调用y的 Setter\n  print(p.y); // 调用y的 Getter\n}\nclass Point{\n  int x,y;\n}</code></pre> \n<h2>命名式构造函数</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Point p = Point.origin();\n\n  print(p.x); // 0\n  print(p.y); // 1\n}\nclass Point{\n  int x,y;\n  Point(this.x, this.y);\n\n  // 命名式构造函数\n  Point.origin(){\n    x = 0;\n    y = 1;\n  }\n}</code></pre> \n<h2>调用父类非默认构造函数</h2> \n<p>调用顺序</p> \n<ul> \n <li>1.初始化列表</li> \n <li>2.父类的无参数构造函数</li> \n <li>3.当前类的构造函数</li> \n</ul> \n<p>传递给父类构造函数的参数不能使用 this 关键字。</p> \n<p>使用(:)为子类的构造函数指定一个父类的构造函数。</p> \n<pre><code class=\"dart\">class Person {\n  String firstName;\n\n  Person.fromJson(Map data) {\n    print(\'in Person\');\n  }\n}\n\nclass Employee extends Person {.\n  // Person没有默认构造函数\n  // 需要通过 super.fromJson 来显示调用\n  Employee.fromJson(Map data) : super.fromJson(data) {\n    print(\'in Employee\');\n  }\n}\n\nmain() {\n  var emp = new Employee.fromJson({});\n\n  // 打印:\n  // in Person  先执行父类的构造\n  // in Employee\n  if (emp is Person) {  // emp类继承了Person\n    emp.firstName = \'Bob\';\n  }\n  print(emp.firstName); // Bob\n  (emp as Person).firstName = \'Jack\';\n  print(emp.firstName);   // Jack\n}</code></pre> \n<h2>初始化列表</h2> \n<ul> \n <li>在构造函数体执行前初始化变量</li> \n <li>初始化列表用来设置 final 字段是非常好用的</li> \n</ul> \n<pre><code class=\"dart\">class Person {\n  String firstName;\n\n  // 初始化列表 会比 构造函数优先执行\n  Person.fromJson(Map data): firstName = data[\'firstName\'] {\n    print(firstName);\n  }\n}\n\nmain() {\n  Person p = Person.fromJson({ \'firstName\': \'zhangsan\'});\n\n}</code></pre> \n<p>设置final 字段</p> \n<pre><code class=\"dart\">import \'dart:math\';\n\nclass Point {\n  final num x;\n  final num y;\n  final num distanceFromOrigin;\n\n  // 初始化列表设置final属性，非常好用\n  Point(x, y)\n      : x = x,\n        y = y,\n        distanceFromOrigin = sqrt(x * x + y * y);\n}\n\nmain() {\n  var p = new Point(2, 3);\n  print(p.distanceFromOrigin);  // 3.605551275463989\n}</code></pre> \n<h2>重定向构造函数</h2> \n<ul> \n <li>调用自己类中其它的构造函数</li> \n <li>没有函数体</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {}\n\nclass Point {\n  int x, y;\n  Point(this.x, this.y);\n\n  // 重定向构造函数\n  // 在函数中调用另一个构造函数的形式\n  Point.origin(int num) : this(num, 0);\n}\n</code></pre> \n<h2>常量构造函数</h2> \n<ul> \n <li>属性用final定义为常量属性</li> \n <li>构造函数用const定义为常量构造函数</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Point p = const Point(0, 0);\n  Point p2 = const Point(0, 0);\n\n  Point p3 = Point(0, 0);\n\n  // 这两个实例对象是相同的\n  print(identical(p, p2)); // true\n\n  // 如果不使用const声明实例，则不会相等\n  print(identical(p, p3)); // false\n}\n\nclass Point {\n  // 变量必须用final 定义\n  final num x, y;\n  const Point(this.x, this.y); // 构造函数也是常量\n}\n</code></pre> \n<h2>工厂构造函数</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Person p = Person(\'tom\');\n  p.say();    // tom\n\n}\n class Person{\n   String name;\n\n  // 必须static 定义\n  static final Map&lt;String, dynamic&gt; _cach = Map&lt;String, dynamic&gt;();\n\n   factory Person(String name){\n     return _cach.putIfAbsent(name, () =&gt; Person._init(name));\n   } \n\n   Person._init(this.name);\n\n   void say(){\n     print(name);\n   }\n\n }</code></pre> \n<h1>方法</h1> \n<h2>实例方法</h2> \n<p>对象的实例方法可以访问实例变量和<code>this</code> 。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Person p = Person(\'tom\', \'hello title\');\n  p.say();\n}\n\nclass Person{\n  String name;\n  String title;\n\n  Person(this.name, this.title);\n\n  void say(){\n    // 可以访问变量\n    print(\'name is $name\');\n    // 也可以访问this\n    print(this.name);\n  }\n}</code></pre> \n<h2>Getter和Setter</h2> \n<p>你可以使用 get 和 set 关键字为额外的属性添加 Getter 和 Setter 方法</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Point p = Point(1, 2, 3);\n  print(p.point); // 6\n\n  p.point = 0;\n  print(p.point);\n  print(p.z);\n}\n\nclass Point {\n  int x, y, z;\n\n  Point(this.x, this.y, this.z);\n\n  get point =&gt; x + y + z;\n  // TODO： 这里为啥设置point 却返回z的值？\n  set point(int num) =&gt; z = num + x;\n}\n</code></pre> \n<h2>抽象方法</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n}\n// 定义抽象类\nabstract class Person{\n  // 定义抽象方法\n  void doSomething();\n}\n\nclass Zhangsan extends Person{\n  // 实现具体的方法\n  void doSomething(){\n\n  }\n}</code></pre> \n<h2>抽象类</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var me = Me();\n  me.sayHello();\n}\n\nabstract class Person{\n  String name;\n  int age;\n  \n  void sayHello();\n}\n\nclass Me extends Person{\n  void sayHello(){\n    print(\'hello\');\n  }\n}</code></pre> \n<h2>隐式接口</h2> \n<p>一个类可以通过关键字 implements 来实现一个或多个接口并实现每个接口定义的 API。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n\n  print(saySomething(Person(\'张三\')));\n\n  print(saySomething(Man()));\n\n}\n\nString saySomething(Person person) =&gt; person.sayName(\'李四\');\n\nclass Person {\n  String _name;\n\n  Person(this._name);\n\n  String sayName(String name) =&gt; \'$_name，你好。我是$name\';\n}\n\nclass Man implements Person {\n  get _name =&gt; \'谁也不是\';\n\n  set _name(String name) =&gt; \'\'; // 因为存在隐式的setter，所以这个也要定义\n\n  String sayName(String name) =&gt; \'$_name，你好。我是$name\';\n}</code></pre> \n<h2>扩展一个类</h2> \n<ul> \n <li>使用extends来扩展一个类</li> \n <li>使用super来引用一个父类</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Man man = Man();\n  man.sayName();\n}\n\nclass Person{\n\n  void sayName() =&gt; print(\'hello person\');\n}\n\nclass Man extends Person{\n\n  void sayName() =&gt; super.sayName();  // 调用父类方法\n}</code></pre> \n<p><strong>重写类成员</strong></p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Man man = Man();\n  man.sayName();\n}\n\nclass Person{\n\n  void sayName() =&gt; print(\'hello person\');\n}\n\nclass Man extends Person{\n\n  @override\n  void sayName() =&gt; print(\'hello man\'); // 重写实例方法\n}</code></pre> \n<p><strong>重写运算符</strong></p> \n<pre><code class=\"dart\">class Vector {\n  final int x, y;\n\n  Vector(this.x, this.y);\n\n  Vector operator +(Vector v) =&gt; Vector(x + v.x, y + v.y);\n  Vector operator -(Vector v) =&gt; Vector(x - v.x, y - v.y);\n\n  // 运算符 == 和 hashCode 的实现未在这里展示，详情请查看下方说明。\n  // ···\n}\n\nvoid main() {\n  final v = Vector(2, 3);\n  final w = Vector(2, 2);\n\n  assert(v + w == Vector(4, 5));\n  assert(v - w == Vector(0, 1));\n}</code></pre> \n<p><strong>noSuchMethod</strong></p> \n<blockquote>\n 这个地方没有看明白\n</blockquote> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Man man = Man();\n  // man.name;\n  // todo 怎么使用？？\n}\n\nclass Person {\n  void sayName() =&gt; print(\'hello person\');\n}\n\nclass Man extends Person {\n  void sayName() =&gt; super.sayName(); // 调用父类方法\n\n  @override\n  void noSuchMethod(Invocation invocation) {\n    print(\'你尝试使用一个不存在的成员：\' + \'${invocation.memberName}\');\n  }\n}\n</code></pre> \n<h2>枚举</h2> \n<ul> \n <li>使用enmu定义</li> \n <li>每个枚举值都有index</li> \n <li>使用values获取所有枚举</li> \n <li>枚举不能成为子类</li> \n <li>枚举不可以mixin</li> \n <li>不可以实现一个枚举</li> \n <li>不可以显示实例化一个枚举</li> \n</ul> \n<p><strong>使用枚举</strong></p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n  print(Color.blue);  // 获取枚举\n\n  print(Color.red.index);   // 获取枚举下标\n\n  List&lt;Color&gt; colors = Color.values;  // 获取全部枚举\n\n  print(colors[2]);\n\n}\n\nenum Color{ // 定义枚举\n  red, blue, green\n}</code></pre> \n<p><strong>switch枚举</strong></p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var aColor = Color.red;\n  // 如果使用switch 则枚举中的每一个成员都得用case判断\n  // 否则就会发出警告\n  switch (aColor) {\n    case Color.red:\n      print(\'红色\');\n      break;\n    case Color.blue:\n      print(\'蓝色\');\n      break;\n    case Color.green:\n      print(\'绿色\');\n      break;\n  }\n}\n\nenum Color {\n  // 定义枚举\n  red,\n  blue,\n  green\n}\n</code></pre> \n<h2>使用mixin为类添加功能</h2> \n<ul> \n <li>Mixin 是一种在多重继承中复用某个类中代码的方法模式</li> \n <li>使用with关键字</li> \n <li>使用mixin定义</li> \n <li>使用on规定哪个类可以使用</li> \n</ul> \n<p>覆写操作符基本格式：</p> \n<pre><code>返回类型 operator 操作符(参数1，参数2...){\n    实现体...\n    return 返回值\n}</code></pre> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Musical musical = Musical();\n  musical.doSomethin();\n}\nmixin Person {\n  bool canCook = true;\n  bool canSay = false;\n\n  // mixin 模式不可以定义构造函数\n  // Person();\n\n  void doSomethin() {\n    if (canCook == true) {\n      print(\'可以做饭\');\n    } else if (canSay == true) {\n      print(\'可以说话\');\n    }\n  }\n}\nclass Musical with Person{\n  @override\n  void doSomethin() {\n    // TODO: implement doSomethin\n    super.doSomethin();   // 直接调用父类\n    print(\'我是子类哦\');\n  }\n}\n</code></pre> \n<h2>类变量和方法</h2> \n<p><strong>静态变量</strong></p> \n<ul>\n <li>静态变量在其首次被使用的时候才被初始化</li>\n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  print(Person.name); // test static\n}\nclass Person{\n  static final String name = \'test static\';\n\n}</code></pre> \n<p><strong>静态方法</strong></p> \n<ul> \n <li>对于一些通用或常用的静态方法，应该将其定义为顶级函数而非静态方法</li> \n <li>可以将静态方法作为编译时常量</li> \n</ul> \n<pre><code class=\"dart\">import \'dart:math\';\n\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n\n  static num distanceBetween(Point a, Point b) {\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n}\n\nvoid main() {\n  var a = Point(2, 2);\n  var b = Point(4, 4);\n  // 对于一些通用或常用的静态方法，应该将其定义为顶级函数而非静态方法。\n  var distance = Point.distanceBetween(a, b);\n  assert(2.8 &lt; distance &amp;&amp; distance &lt; 2.9);\n  print(distance);\n}</code></pre> \n<h1>泛型</h1> \n<h2>为什么使用泛型</h2> \n<ul> \n <li>通常使用一个字母来代表类型参数，比如E、T、S、K 和 V 等等</li> \n <li>适当地指定泛型可以更好地帮助代码生成</li> \n <li>使用泛型可以减少代码重复</li> \n</ul> \n<p><strong>代码错误提示</strong></p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var names = List&lt;String&gt;(); // 声明为字符串数组，一旦不是则报错\n  names.addAll([\'Seth\', \'Kathy\', \'Lars\']);\n  // 提示报错\n  // names.add(42); // Error\n}\n</code></pre> \n<p><strong>减少重复代码</strong><br>使用泛型声明一个类，让不同类型的缓存实现该类做出不同的具体实现。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {}\n\nabstract class Cache&lt;T&gt; {\n  T getByKey(String key);\n  void setByKey(String key, T value);\n}\n\nclass Acache extends Cache&lt;String&gt; {\n  String getByKey(String key) {\n    // 具体实现时指定\n    return \'hello\';\n  }\n\n  void setByKey(String key, String value) {\n    // 具体实现时指定\n    print(11);\n  }\n}\n</code></pre> \n<h2>使用集合字面量</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  List list = &lt;String&gt;[\'1\', \'2\', \'3\'];  // 字符串集合\n  Set set = &lt;String&gt;{\'1\',\'2\',\'3\'}; // 字符串集合\n  Map map = &lt;String, int&gt;{\'age\': 1, \'size\':12}; // Map\n}</code></pre> \n<h2>使用类型参数化的构造函数</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 与字面量相对应，也可以通过构造函数的方式使用泛型\n  Map map = Map&lt;String, int&gt;();\n}</code></pre> \n<h2>泛型集合以及他们所包含的类型</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  List list = List&lt;String&gt;();\n  // list.addAll([\'1\',\'2\']); \n  // 如果此时使用addAll则会报错\n  list.add(\'1\');\n  list.add(\'2\');\n  print(list is List&lt;String&gt;); // true\n\n  var names = List&lt;String&gt;();\n  names.addAll([\'小芸\', \'小芳\', \'小民\']);\n  print(names is List&lt;String&gt;); // true\n}</code></pre> \n<h2>限制参数化类型</h2> \n<ul> \n <li>指定参数类型</li> \n <li>不指定参数类型，使用默认类型</li> \n <li>错误参数类型，编译报错</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();\n  var extenderFoo = Foo&lt;Extender&gt;();\n\n  print(someBaseClassFoo.toString()); // \'Foo&lt;SomeBaseClass&gt;\' 的实例\n  print(extenderFoo.toString()); // \'Foo&lt;Extender&gt;\' 的实例\n\n  // 如果不指定泛型，默认是SomeBaseClass\n  var foo = Foo();\n  print(foo);\n  // 将非 SomeBaseClass 的类型作为泛型参数则会导致编译错误\n  // var foo = Foo&lt;Object&gt;(); \n}\n\nclass SomeBaseClass {}\n\n// 这里的T，其实可以随意指定。一般是T、E、S、K等\nclass Foo&lt;T extends SomeBaseClass&gt; {\n  // 具体实现……\n  String toString() =&gt; \"\'Foo&lt;$T&gt;\' 的实例\";\n}\n\nclass Extender extends SomeBaseClass {}\n</code></pre> \n<h2>使用泛型方法</h2> \n<ul> \n <li>函数的返回类型&lt;T&gt;</li> \n <li>参数的类型List&lt;T&gt;</li> \n <li>局部变量的类型&lt;T&gt;</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var list = List&lt;String&gt;();\n  list.addAll([\'1\',\'2\']);\n\n  var firstValue = first(list);\n  print(firstValue);  // 1\n}\nT first&lt;T&gt;(List&lt;T&gt; ts) {\n  // 处理一些初始化工作或错误检测……\n  T tmp = ts[0];\n  // 处理一些额外的检查……\n  return tmp;\n}</code></pre> \n<h1>异步支持</h1> \n<h2>处理Future</h2> \n<ul> \n <li>使用 async 和 await 的代码是异步的，但是看起来有点像同步代码</li> \n <li>必须在带有 async 关键字的 异步函数 中使用 await</li> \n <li>使用 try、catch 以及 finally 来处理使用 await 导致的异常</li> \n <li>await 表达式的返回值是一个 Future 对象</li> \n <li>Future 对象代表一个“承诺”，await 表达式会阻塞直到需要的对象返回</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {}\n// async 与 await同时使用\nFuture checkVersion() async {\n  // 通过 try-catch 捕获异常\n  try {\n    var version = await lookUpVersion();\n  } catch (e) {\n    // 无法找到版本时做出的反应\n  }\n}\n\nvoid lookUpVersion() {}\n</code></pre> \n<h2>异步函数</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n}\n// 普通函数直接添加async关键字即可\nFuture&lt;String&gt; lookUpVersion() async =&gt; \'1.0.0\';\n\n</code></pre> \n<h2>处理Stream</h2> \n<ul> \n <li>使用async和await for循环</li> \n <li>使用Stream API</li> \n <li>表达式 的类型必须是 Stream</li> \n <li>使用 break 和 return 语句停止接收 Stream 数据，跳出循环</li> \n <li>1.等待直到 Stream 返回一个数据</li> \n <li>2.使用 1 中 Stream 返回的数据执行循环体</li> \n <li>3.重复 1、2 过程直到 Stream 数据返回完毕</li> \n</ul> \n<h1>可调用类</h1> \n<p>通过实现类的 call() 方法，允许使用类似函数调用的方式来使用该类的实例。</p> \n<pre><code class=\"dart\">// WannabeFunction 类定义了一个 call() 函数，函数接受三个字符串参数，函数体将三个字符串拼接，字符串间用空格分割，并在结尾附加了一个感叹号\n\nclass WannabeFunction {\n  String call(String a, String b, String c) =&gt; \'$a $b $c!\';\n}\n\nvar wf = WannabeFunction();\nvar out = wf(\'Hi\', \'there,\', \'gang\');\n\nmain() =&gt; print(out);\n</code></pre> \n<h1>思维导图</h1> \n<p>制作的思维导图，加深学习印象。如有错误欢迎指正。</p> \n<p>原始图片比较大，为了保证打开速度只上传了一张截图。如果需要高清图片可以在我的<a href=\"https://github.com/siberiawolf/dart_study\" rel=\"nofollow noreferrer\">源码</a>文件中找到。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022088868\" src=\"http://localhost:8060/tup/2020/4/23/8aba7a173eec4f46b0c085650a4ba03d.jpg\" alt=\"思维导图\" title=\"思维导图\"></span></p> \n<hr> \n<p>参考资料：</p> \n<ul> \n <li><a href=\"https://www.jianshu.com/p/9e5f4c81cc7d\" rel=\"nofollow noreferrer\">Dart语法学习</a></li> \n <li><a href=\"http://www.dartdoc.cn/guides/language/language-tour\" rel=\"nofollow noreferrer\">官方文档中文版</a></li> \n <li><a href=\"https://dart.dev/guides/language/language-tour\" rel=\"nofollow noreferrer\">官网文档英文版</a></li> \n <li><a href=\"http://www.shutongye.com/dartapi/index.html\" rel=\"nofollow noreferrer\">Dart SDK API 中文版</a></li> \n <li><a href=\"https://www.imooc.com/learn/1035\" rel=\"nofollow noreferrer\">Flutter开发第一步-Dart编程语言入门</a></li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022061753\" src=\"http://localhost:8060/tup/2020/4/23/632578fa26eb475cbcb4e36a74b9b788.jpg\" alt=\"\" title=\"\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/c895627e3197463287c366258140c631.jpg', '5ca4567d892841b087fac5246effac40', 'a337904dd1d5477b9689d7693be316de', '45a9e20bf502451396f25c51ff9f7972,14ab12176ade47da95ba97d7151eb1f9,8dfc62f227ae4076888ea4872e03cddd,85ee959b27f74072b13cc763b9bbf77e,63c4e1e7ec204b43a62065a3ced4c2ce', '0', '3', '1', '2020-04-23 10:31:48', '2020-04-23 10:31:48');
INSERT INTO `tb_recommend` VALUES ('eedb62e3282c40efaf860bf4d5c7d2f8', '【Flutter工具】可能是Flutter上最简单的本地数据保存方案', 'local_cache_sync是一个非常简单易用的Flutter本地储存库，适用于在本地储存一列轻量数据（例如用户保存在本地的一系列蓝牙设备的配置，或者缓存一系列用户信息）', '<h1>简介</h1> \n<p><code>local_cache_sync</code>是一个非常简单易用的<code>Flutter</code>本地储存库，适用于在本地储存一列轻量数据（例如用户保存在本地的一系列蓝牙设备的配置，或者缓存一系列用户信息）</p> \n<p><code>local_cache_sync</code>的所有方法，包括保存与读取，都是<strong>同步</strong>的，而不是<strong>异步</strong>的。</p> \n<p><strong>同步存取</strong>意味着你不需要使用<code>await</code>就可以获取和保存数据。在<code>flutter</code>中，这可以显著减少<code>StatefulWidget</code>的数量，大量减少代码的复杂度。</p> \n<h1>例子</h1> \n<p>使用<code>local_cache_sync</code>保存与读取参数都是同步的，这意味着赋值即是保存，而且在<code>StatelessWidget</code>中，可以<strong>立即使用数据</strong>，而不是异步请求数据再刷新。</p> \n<p>下面这个<code>Switch</code>组件的值会被缓存到本地，即使重新启动App也会保留：</p> \n<pre><code class=\"dart\">Switch(\n  value: LocalCacheSync.userDefault.getWithKey&lt;bool&gt;(\'switch-A\'),\n  onChanged: (v) {\n    setState(() {\n      LocalCacheSync.userDefault.setWithKey&lt;bool&gt;(\'switch-A\', v);\n    });\n  },\n),</code></pre> \n<h2>安装</h2> \n<p>添加你的pubspec.yaml</p> \n<pre><code class=\"yaml\">  path_provider: ^1.4.5\n  local_cache_sync: ^1.1.0</code></pre> \n<p>初始化设置路径</p> \n<pre><code class=\"dart\">getTemporaryDirectory().then((uri) {\n      LocalCacheSync.instance.setCachePath(uri.path);\n});</code></pre> \n<h1>用户偏好设置缓存</h1> \n<p>使用<code>local_cache_sync</code>实现保存用户自定义设置非常简单，<strong>只需要赋值与取值，无需异步等待</strong>，即可保存参数到本地。 <br>读取参数也是同步的，这意味着你可以在<code>StatelessWidget</code>中立即使用数据。</p> \n<h2>使用函数调用：</h2> \n<p>保存数据</p> \n<pre><code class=\"dart\">LocalCacheSync.userDefault.setWithKey&lt;bool&gt;(\'isDarkMode\',true);\nLocalCacheSync.userDefault.setWithKey&lt;String&gt;(\'token\',\'aabbccdd\');\nLocalCacheSync.userDefault.setWithKey&lt;Map&gt;(\'x-config\',{\'id\':1243});</code></pre> \n<p>读取数据</p> \n<pre><code class=\"dart\">var res = LocalCacheSync.userDefault.getWithKey&lt;bool&gt;(\'isDarkMode\');\nvar res = LocalCacheSync.userDefault.getWithKey&lt;String&gt;(\'token\');\nvar res = LocalCacheSync.userDefault.getWithKey&lt;Map&gt;(\'x-config\');</code></pre> \n<h2>使用操作符:</h2> \n<p>保存数据</p> \n<pre><code class=\"dart\">LocalCacheSync.userDefault[\'isDarkMode\'] = true;\nLocalCacheSync.userDefault[\'token\'] = \'aabbccdd\';\nLocalCacheSync.userDefault[\'x-config\'] = {\'id\':1243};</code></pre> \n<p>读取数据</p> \n<pre><code class=\"dart\">bool res = LocalCacheSync.userDefault[\'isDarkMode\'];\nString res = LocalCacheSync.userDefault[\'token\'];\nMap res = LocalCacheSync.userDefault[\'x-config\'];</code></pre> \n<h1>管理一组数据缓存</h1> \n<p>如果你需要管理一系列值，请使用<code>LocalCacheLoader</code>，只需要一个<code>channel</code>标志，你就可以管理一系列值。</p> \n<h2>懒加载</h2> \n<p><code>LocalCacheLoader</code>在内部实现了懒加载的效果：只有取<code>value</code>属性时数据才真正被加载。 </p> \n<p>在应用中，加入你有1-100号设备显示在Listview.builder中，只有100号设备即将进入屏幕中时，100号设备的缓存参数才会被真正加载。也就是说LocalCacheLoader不会导致长列表卡顿。</p> \n<h2>Model例子</h2> \n<p>我推荐你这样创建你的model:</p> \n<pre><code class=\"dart\">\nclass Device {\n  final String uuid;\n  final String name;\n  final int type;\n\n  Device({\n    this.uuid,\n    this.name,\n    this.type,\n  });\n\n  Device.formJson(Map&lt;String, dynamic&gt; map)\n      : this(\n          uuid: map[\'uuid\'],\n          name: map[\'name\'],\n          type: map[\'type\'],\n        );\n\n  static LocalCacheLoader get _loader =&gt; LocalCacheLoader(\'device\');\n\n  static List&lt;Device&gt; all() {\n    return _loader.all\n        .map&lt;Device&gt;(\n          (cache) =&gt; Device.fromJson(cache),\n        )\n        .toList();\n  }\n\n  LocalCacheObject save() {\n    return Device._loader.saveById(uuid, jsonMap);\n  }\n\n  Map&lt;String, dynamic&gt; get jsonMap =&gt; {\n        \'uuid\': uuid,\n        \'name\': name,\n        \'type\': type,\n      };\n}</code></pre> \n<p>你也可以另外封装loader来读写其他信息，对于轻量级的储存，以上是非常简单易用的。</p> \n<h2>警告</h2> \n<p>不要在io密集型场景使用local_cache_sync，例如即时储存每秒10次的扫描结果。 <br>虽然flutter中阻塞主线程不会导致UI卡顿，但是你仍不应当在io密集型场景使用，这超出了local_cache_sync设计的工作范围。</p> \n<h1>仓库与Pub地址</h1> \n<p>如果有问题，可以在github上issue或者pr。</p> \n<p><a href=\"https://pub.dev/packages/local_cache_sync#-changelog-tab-\" rel=\"nofollow noreferrer\">PUB地址（可以赞一下）</a><br><a href=\"https://github.com/mjl0602/local_cache_sync\" rel=\"nofollow noreferrer\">Github仓库</a></p>', null, null, 'f53014d680884163a5bd5ce762e90cdf', 'a337904dd1d5477b9689d7693be316de', '14ab12176ade47da95ba97d7151eb1f9,63c4e1e7ec204b43a62065a3ced4c2ce,d79254c4ca5e45dca9d484307c935281,85ee959b27f74072b13cc763b9bbf77e,8dfc62f227ae4076888ea4872e03cddd', '0', '3', '1', '2020-04-23 10:31:57', '2020-04-23 10:31:57');
INSERT INTO `tb_recommend` VALUES ('efb30cf5eb7e48fbbff2b9ce16208a82', 'npm 开源项目构建与发布', '引言 公式录入模块，起初采用开源的tinymce-mathjax插件。 使用过程中发现不易于公式录入，期待快捷录入方案。 遂启动了自研插件的计划，在开发的过程中发现，做个开源真难。 特地去Github把组织名改了，I\'m spen...', '<h1>引言</h1> \n<p>公式录入模块，起初采用开源的<code>tinymce-mathjax</code>插件。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGbkw\" src=\"http://localhost:8060/tup/2020/4/23/bc039996a69c41598a43048237ad15f8.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>使用过程中发现不易于公式录入，期待快捷录入方案。</p> \n<p>遂启动了自研插件的计划，在开发的过程中发现，做个开源真难。</p> \n<p>特地去<code>Github</code>把组织名改了，<code>I\'m spent.</code>，我太难了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGboJ\" src=\"http://localhost:8060/tup/2020/4/23/83f4f6ac362e439ca8904868138dd7b6.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<h1>开源</h1> \n<h2>一个好的前端开源项目</h2> \n<p>后端的项目我们一直在移植<code>Spring</code>官方的方式。</p> \n<p>那一个好的前端开源项目长什么样呢？去看看前端老大<code>React</code>吧！<a href=\"https://github.com/facebook/react\" rel=\"nofollow noreferrer\">facebook/react - Github</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGbo2\" src=\"http://localhost:8060/tup/2020/4/23/e83925eaee8e41629297b79fb34705f4.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>除了其他与开发有关的部分，文档方面我只维护了必备的版本变更<code>(CHANGES 或 CHANGELOG)</code>、开源协议<code>(LICENSE)</code>、项目介绍<code>(README)</code>。</p> \n<pre><code>CHANGES # 各版本变动信息\nLICENSE # 开源协议\nREADME  # 项目介绍</code></pre> \n<h2>开发</h2> \n<p>进入开发阶段，因为<code>IE</code>和<code>Firefox</code>的存在，记住不要啥<code>api</code>都用。</p> \n<p>能用<code>ts</code>就别用<code>js</code>，能用类就别<code>any</code>。</p> \n<p>不怪说从切图仔到写框架都是前端，好的项目是真好，次的项目是真次，令人害怕。</p> \n<ol> \n <li>纯<code>js</code>项目，这个<code>startup</code>对象是啥啊？<code>最开始没找到mathjax怎么结合ts</code>。</li> \n <li> <code>ts</code>项目类型错误，这个提示怎么和文档不一样啊？<code>(@type/mathjax)的类型仍然是旧版本的</code>。</li> \n <li>文档写得<code>object</code>，<code>ts</code>是<code>any</code>，这个<code>api</code>应该传个啥啊？</li> \n <li> <code>xxx.min.js</code>第一行报错，点开全是<code>abcd</code>，这怎么整啊？</li> \n</ol> \n<p>经历了重重困难终于开发完成，完成了第一版的功能，仅公式录入。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGbF5\" src=\"http://localhost:8060/tup/2020/4/23/bad20ecf44fa40b091bf5ec1117ff354.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<h2>MathJax</h2> \n<p>说一下在使用<code>mathjax</code>时自己的一些理解，最开始就掉进官方文档的坑里了，官方文档是<code>MathJax.typeset()</code>实现渲染，导致我误认为渲染<code>document</code>就需要引入<code>mathjax</code>文件，在<code>iframe</code>里通过创建<code>script</code>标签的方式动态引入<code>mathjax</code>。</p> \n<p>后来发现完全不必要，这样还给插件的使用者造成负担。</p> \n<p>需要用户提供一个<code>MathJax</code>的环境即可，不需要重复在<code>iframe</code>引入，其实渲染，不过是将符合格式的公式内容渲染为<code>svg</code>矢量图。</p> \n<pre><code class=\"typescript\">const mathJax = MathJaxHolder.getMathJax();\nconst options = mathJax.getMetricsFor(el, true);\nconst node = mathJax.tex2svg(latex, options);</code></pre> \n<h2>发布哪些文件</h2> \n<p>这是发布前需要确定的问题，经测试<code>CHANGES</code>、<code>LICENSE</code>、<code>README.md</code>等这些项目必备的会被<code>npm</code>默认包括进来。</p> \n<p>其他的需要发布的文件，需要在<code>package.json</code>的<code>files</code>中引入。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGbSb\" src=\"http://localhost:8060/tup/2020/4/23/2b7229e3d3364d09942d51c224d7c117.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p><code>ts</code>项目，只发布编译之后的<code>js</code>代码。</p> \n<h2>发布</h2> \n<p>发布有两种方式，一种手工方式，一种自动方式，因手工发布方式较复杂，推荐使用自动化工具<code>np</code>。</p> \n<p><a href=\"https://zellwk.com/blog/publish-to-npm/\" rel=\"nofollow noreferrer\">How to publish packages to npm</a></p> \n<p>发布前的准备：更新版本记录。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGaiC\" src=\"http://localhost:8060/tup/2020/4/23/90248ba5d1f64da6a7c2dad331add143.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>使用<code>np</code>命令开始发布，当前是<code>1.0.5</code>版本，列出从上次发布到现在的所有<code>Git</code>提交。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGai3\" src=\"http://localhost:8060/tup/2020/4/23/89a34964eba24a92a2acd94e761d896e.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>选择本次发布的版本。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGajg\" src=\"http://localhost:8060/tup/2020/4/23/3e952b959f6b471093103e79af6f0740.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>之后会自动执行一系列任务，等待。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGajr\" src=\"http://localhost:8060/tup/2020/4/23/f1aec4457f2a462289d08abfebfae283.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>发布的时候需要输入<code>OTP/One Time Password</code>一次性密码。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGarv\" src=\"http://localhost:8060/tup/2020/4/23/86653d439e4041ca8a874fe3214eed47.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>此处的<code>OTP</code>是使用<code>Authenticator</code>应用扫描<code>npm</code>官方提供的二维码后生成的时效性密码，每<code>30</code>秒变更一次，且密码只能用一次。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGbRB\" src=\"http://localhost:8060/tup/2020/4/23/e53d9f400e4b4af3b3bb146047a72f81.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>大致原理就是扫码，客户端获取到密钥，然后密码是根据密钥和时间戳计算出来的，类似<code>QQ</code>安全中心。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGbRL\" src=\"http://localhost:8060/tup/2020/4/23/be22037dab1b4d39a2a6ff7cb819b01b.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>发布的时候比较慢，受限于网络，耐心等待。出现类似<code>tinymce-latex 1.0.6 published.</code>这种的发布成功的提示语即证明发布成功。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGasd\" src=\"http://localhost:8060/tup/2020/4/23/9f7e5caffbb3458c9a4486c1a781230c.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>发布后，<code>package.json</code>文件中的版本信息工具帮我们自动修改。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGasf\" src=\"http://localhost:8060/tup/2020/4/23/a3b7ec86e35447f2877cd48c15f7490a.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>同时，<code>np</code>自动帮我们发布在<code>Github</code>上发布了一个<code>v1.0.6</code>的<code>RELEASE</code>版本。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGasp\" src=\"http://localhost:8060/tup/2020/4/23/81020a67ec2c454282251ca7e025396f.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>打开<code>npm</code>官网，可以看到新版本已经发布成功。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbGasy\" src=\"http://localhost:8060/tup/2020/4/23/1bed9468481f48128db766d19a0a2425.jpg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<h1>总结</h1> \n<p>在这个文档不健全的前端时代，类型和注释的限制很重要。</p>', null, 'http://localhost:8060/tup/2020/4/23/74f157efa917452a8ef53c5180aab6f3.jpg', '6fbfa4aaad3a43458f21c8acf0038ac5', '19eb3dd59ef8430d9f637d97449fc417', 'acf0403b8ea14effb582f96401d99449,5efa96b48ac5424bafa02fd88f312984,f3eb17e6e5664a97af3e9b1fca12b286', '0', '3', '1', '2020-04-23 10:58:56', '2020-04-23 10:58:56');
INSERT INTO `tb_recommend` VALUES ('f042af1de60e48939d6e66850cda6237', '使用拦截器统一处理通用检查', '那么，如果代码还有其他通用的校验，而且每加一个接口都要加这些校验逻辑，久而久之，代码会显得较臃肿，看起来会有很多重复的代码，那么有没有办法精简这部分代码呢？有！', '<h2>繁琐的检查</h2> \n<p>在平时的业务开发中，相信大家都有很多这样的代码：</p> \n<pre><code class=\"java\">public void login(Parameter parameter) {\n  if (!validateXXX(parameter)) {\n    throw new BizException(ErrCode.PAMRM_ERROR);\n  }\n  \n  // 真正的逻辑代码\n}</code></pre> \n<p>那么，如果代码还有其他通用的校验，而且每加一个接口都要加这些校验逻辑，久而久之，代码会显得较臃肿，看起来会有很多重复的代码，那么有没有办法精简这部分代码呢？有！</p> \n<h2>Spring的HandlerInterceptor</h2> \n<p>先上代码</p> \n<h3>拦截器定义</h3> \n<pre><code class=\"java\">public class CheckXXXHandlerInterceptor extends HandlerInterceptorAdapter {\n\n    final Map&lt;Method, Boolean&gt; methodCache = new IdentityHashMap&lt;&gt;();\n\n    @Override\n    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {\n\n        HandlerMethod handlerMethod = (HandlerMethod) handler;\n\n        /**\n        这个是双重判断锁单例\n        外层的判断，为了避免在实例已经创建好的情况下再次加锁获取，影响性能；\n        里层的判断，考虑在多线程环境下，多个线程同时过掉外层判断，也就是都已经判断变量为空，如果不加一重判断，还是有可能重复创建。\n        */\n        Method method = handlerMethod.getMethod();\n        if (!methodCache.containsKey(method)) {\n            synchronized (methodCache) {\n                if (!methodCache.containsKey(method)) {\n                    boolean check = false;\n                    if (method.isAnnotationPresent(CheckXXX.class)) {\n                        check = method.getAnnotation(CheckXXX.class).value();\n                    } else if (method.getDeclaringClass().isAnnotationPresent(CheckXXX.class)) {\n                        check = method.getDeclaringClass().getAnnotation(CheckXXX.class).value();\n                    }\n                    methodCache.put(method, check);\n                }\n            }\n        }\n        if (methodCache.get(method)) {\n            // do check\n        }\n\n        return true;\n    }\n}</code></pre> \n<h3>注解定义</h3> \n<pre><code class=\"java\">@Retention(RetentionPolicy.RUNTIME)\n@Target({ElementType.TYPE, ElementType.METHOD})\npublic @interface CheckXXX {\n    boolean value() default true;\n}</code></pre> \n<h3>注解使用</h3> \n<pre><code class=\"java\">@CheckXXX\npublic class XXXController {\n\n    public void login(Parameter parameter) {\n      // 真正的逻辑代码\n    }\n}</code></pre> \n<p>这样，就能抽离出通用的逻辑，精简通用的代码。那么，这个拦截器是什么时候执行的呢？它的实现原理是什么？</p> \n<h3>执行时机</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022439406\" src=\"http://localhost:8060/tup/2020/4/23/d9e43939a22544308c5e50474c2d0259.jpg\" alt=\"\" title=\"\"></span></p> \n<p>通过查看自定义拦截器的UML类图关系，可以看出来，其实是实现了HandlerInterceptor的preHandle方法，通过追踪HandlerInterceptor的调用链路，最终是在请求进入分发器，执行<code>doDispatch</code>方法用的，而处理器是在初始化的时候就加载好。</p> \n<p>整体的流程如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022439407\" src=\"http://localhost:8060/tup/2020/4/23/a6ad236be4804f22b0e9ea6b954d252e.jpg\" alt=\"\" title=\"\"></span></p> \n<p>核心代码：</p> \n<pre><code class=\"java\">if (!mappedHandler.applyPreHandle(processedRequest, response)) {\n    return;\n}\n\n\nboolean applyPreHandle(HttpServletRequest request, HttpServletResponse response) throws Exception {\n    HandlerInterceptor[] interceptors = getInterceptors();\n    if (!ObjectUtils.isEmpty(interceptors)) {\n        for (int i = 0; i &lt; interceptors.length; i++) {\n            HandlerInterceptor interceptor = interceptors[i];\n            if (!interceptor.preHandle(request, response, this.handler)) {\n                triggerAfterCompletion(request, response, null);\n                return false;\n            }\n            this.interceptorIndex = i;\n        }\n    }\n    return true;\n}</code></pre> \n<p>拦截器数组interceptors是在Spring容器启动的时候初始化好的，实现原理比较简单，就是取出请求处理器的map，遍历调用注册好的拦截器。</p> \n<h2>实现原理</h2> \n<p>通过拦截器处理通用检查，背后的编程思想其实是AOP，<a href=\"https://zh.wikipedia.org/zh-cn/%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1\" rel=\"nofollow noreferrer\">面向切面编程</a>。</p> \n<blockquote>\n 使用切面的优点：首先，现在每个关注点都集中于一个地 方，而不是分散到多处代码中;其次，服务模块更简洁，因为它们只包含主要关注点(或核 心功能)的代码，而次要关注点的代码被转移到切面中了。----摘自《Spring实战》\n</blockquote> \n<p>关于AOP，网上有很多资料解释，看维基百科的描述也很清晰，，笔者就不多赘述了。</p> \n<p>在这个例子里面，每个接口的核心功能是响应为业务功能提供服务，但是每个接口需要的参数检查、安全检查，都统一交给切面完成。如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022439405\" src=\"http://localhost:8060/tup/2020/4/23/98001e04789d45fd931ca02a89cebe3e.jpg\" alt=\"\" title=\"\"></span></p> \n<h2>总结</h2> \n<p>代码和原理比较简单，但是里面包含的知识点却不少，通过追朔源码，能了解细节之余，还能掌握某一类问题的实现方案。</p> \n<p>原创文章，文笔有限，才疏学浅，文中若有不正之处，万望告知。</p> \n<p>如果本文对你有帮助，请点个赞吧，谢谢^_^</p> \n<p>更多精彩内容，请关注个人公众号。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022439408\" src=\"http://localhost:8060/tup/2020/4/23/90174c22d0264d74ba15e239067e6e22.jpg\" alt=\"\" title=\"\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/c25736da081a4dbab3201c741b3251e6.jpg', '3f69fcc9b13843d1910b3dac597f5215', 'bb0b7e69ad3e46fcb121baefda8f1f78', '2294832fe5104d73ace4f14ad9549018,934e37db9f384f009b12ce399dd89054,7684950d0a9e46f1b8067594e8a0161d', '0', '3', '1', '2020-04-23 10:28:14', '2020-04-23 10:28:14');
INSERT INTO `tb_recommend` VALUES ('f0a08db5ff0846c3ab34f797ef0a26c9', '小程序框架运行时性能大测评', '随着小程序在商业上的巨大成功，小程序开发在国内前端领域越来越受到重视，为了方便广大开发者更好地进行小程序开发，各类小程序框架也层出不穷，呈现出百花齐放的态势。但是到目前为止，业内一直没有出现一份全...', '<blockquote>\n 作者：董宏平(hiyuki)，滴滴出行小程序负责人，mpx框架负责人及核心作者\n</blockquote> \n<p>随着小程序在商业上的巨大成功，小程序开发在国内前端领域越来越受到重视，为了方便广大开发者更好地进行小程序开发，各类小程序框架也层出不穷，呈现出百花齐放的态势。但是到目前为止，业内一直没有出现一份全面、详细、客观、公正的小程序框架测评报告，为小程序开发者在技术选型时提供参考。于是我便筹划推出一系列文章，对业内流行的小程序框架进行一次全方位的、客观公正的测评，本文是系列文章的第一篇——运行时性能篇。</p> \n<p>在本文中，我们会对下列框架进行运行时性能测试(排名不分先后):</p> \n<ul> \n <li>wepy2(<a href=\"https://github.com/Tencent/wepy)\" rel=\"nofollow noreferrer\">https://github.com/Tencent/wepy)</a> @2.0.0-alpha.20</li> \n <li>uniapp(<a href=\"https://github.com/dcloudio/uni-app)\" rel=\"nofollow noreferrer\">https://github.com/dcloudio/u...</a> @2.0.0-26120200226001</li> \n <li>mpx(<a href=\"https://github.com/didi/mpx)\" rel=\"nofollow noreferrer\">https://github.com/didi/mpx)</a> @2.5.3</li> \n <li>chameleon(<a href=\"https://github.com/didi/chameleon)\" rel=\"nofollow noreferrer\">https://github.com/didi/chame...</a> @1.0.5</li> \n <li>mpvue(<a href=\"https://github.com/Meituan-Dianping/mpvue)\" rel=\"nofollow noreferrer\">https://github.com/Meituan-Di...</a> @2.0.6</li> \n <li>kbone(<a href=\"https://github.com/Tencent/kbone)\" rel=\"nofollow noreferrer\">https://github.com/Tencent/kb...</a> @0.8.3</li> \n <li>taro next(<a href=\"https://github.com/NervJS/taro)\" rel=\"nofollow noreferrer\">https://github.com/NervJS/taro)</a> @3.0.0-alpha.5</li> \n</ul> \n<p>其中对于kbone和taro next均以vue作为业务框架进行测试。</p> \n<p>运行时性能的测试内容包括以下几个维度：</p> \n<ul> \n <li>框架运行时体积</li> \n <li>页面渲染耗时</li> \n <li>页面更新耗时</li> \n <li>局部更新耗时</li> \n <li>setData调用次数</li> \n <li>setData发送数据大小</li> \n</ul> \n<p>框架性能测试demo全部存放于<a href=\"https://github.com/hiyuki/mp-framework-benchmark\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a> 中，欢迎广大开发者进行验证纠错及补全；</p> \n<h2>测试方案</h2> \n<p>为了使测试结果真实有效，我基于常见的业务场景构建了两种测试场景，分别是动态测试场景和静态测试场景。</p> \n<h3>动态测试场景</h3> \n<p>动态测试中，视图基于数据动态渲染，静态节点较少，视图更新耗时和setData调用情况是该测试场景中的主要测试点。</p> \n<p>动态测试demo模拟了实际业务中常见的长列表+多tab场景，该demo中存在两份优惠券列表数据，一份为可用券数据，另一份为不可用券数据，其中同一时刻视图中只会渲染展示其中一份数据，可以在上方的操作区模拟对列表数据的各种操作及视图展示切换(切tab)。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022249437\" src=\"http://localhost:8060/tup/2020/4/23/eb698818f6e04d08b0ce85e24b2a436c.jpg\" alt=\"动态测试demo\" title=\"动态测试demo\"></span></p> \n<p><em>动态测试demo</em></p> \n<p>在动态测试中，我在外部通过函数代理的方式在初始化之前将App、Page和Component构造器进行代理，通过mixin的方式在Page的onLoad和Component的created钩子中注入setData拦截逻辑，对所有页面和组件的setData调用进行监听，并统计小程序的视图更新耗时及setData调用情况。该测试方式能够做到对框架代码的零侵入，能够跟踪到小程序全量的setData行为并进行独立的耗时计算，具有很强的普适性，代码具体实现可以查看<a href=\"https://github.com/hiyuki/mp-framework-benchmark/blob/master/utils/proxy.js\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a></p> \n<h3>静态测试场景</h3> \n<p>静态测试模拟业务中静态页面的场景，如运营活动和文章等页面，页面内具备大量的静态节点，而没有数据动态渲染，初始ready耗时是该场景下测试的重心。</p> \n<p>静态测试demo使用了我去年发表的一篇技术文章的html代码进行小程序适配构建，其中包含大量静态节点及文本内容。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022249436\" src=\"http://localhost:8060/tup/2020/4/23/3269ae363a954f7e8ea52fce95fb2362.jpg\" alt=\"静态测试demo\" title=\"静态测试demo\"></span></p> \n<p><em>静态测试demo</em></p> \n<h2>测试流程及数据</h2> \n<blockquote>\n 以下所有耗时类的测试数据均为微信小程序中真机进行5次测试计算平均值得出，单位均为ms。Ios测试环境为手机型号iPhone 11，系统版本13.3.1，微信版本7.0.12，安卓测试环境为手机型号小米9，系统版本Android10，微信版本7.0.12。\n</blockquote> \n<blockquote>\n 为了使数据展示不过于混乱复杂，文章中所列的数据以Ios的测试结果为主，安卓测试结论与Ios相符，整体耗时比Ios高3~4倍左右，所有的原始测试数据存放在\n <a href=\"https://github.com/hiyuki/mp-framework-benchmark/blob/master/rawData.csv\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a> \n</blockquote> \n<blockquote>\n 由于transform-runtime引入的core-js会对框架的运行时体积和运行耗时带来一定影响，且不是所有的框架都会在编译时开启transform-runtime，为了对齐测试环境，下述测试均在transform-runtime关闭时进行。\n</blockquote> \n<h3>框架运行时体积</h3> \n<p>由于不是所有框架都能够使用<code>webpack-bundle-analyzer</code>得到精确的包体积占用，这里我通过将各框架生成的demo项目体积减去native编写的demo项目体积作为框架的运行时体积。</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>demo总体积(KB)</th> \n   <th>框架运行时体积(KB)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>27</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>66</td> \n   <td>39</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>114</td> \n   <td>87</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>78</td> \n   <td>51</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>136</td> \n   <td>109</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>103</td> \n   <td>76</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>395</td> \n   <td>368</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>183</td> \n   <td>156</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native &gt; wepy2 &gt; mpx &gt; mpvue &gt; uniapp &gt; chameleon &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>wepy2和mpx在框架运行时体积上控制得最好；</li> \n <li>taro next和kbone由于动态渲染的特性，在dist中会生成递归渲染模板/组件，所以占用体积较大。</li> \n</ul> \n<h3>页面渲染耗时(动态测试)</h3> \n<p>我们使用<code>刷新页面</code>操作触发页面重新加载，对于大部分框架来说，页面渲染耗时是从触发刷新操作到页面执行onReady的耗时，但是对于像kbone和taro next这样的动态渲染框架，页面执行onReady并不代表视图真正渲染完成，为此，我们设定了一个特殊规则，在页面onReady触发的1000ms内，在没有任何操作的情况下出现setData回调时，以最后触发的setData回调作为页面渲染完成时机来计算真实的页面渲染耗时，测试结果如下：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>页面渲染耗时</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>60.8</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>64</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>56.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>52.6</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>56.4</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>117.8</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>98.6</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>89.6</td> \n  </tr> \n </tbody> \n</table> \n<blockquote>\n 该项测试的耗时并不等同于真实的渲染耗时，由于小程序自身没有提供performance api，真实渲染耗时无法通过js准确测试得出，不过从得出的数据来看该项数据依然具备一定的参考意义。\n</blockquote> \n<p>该项测试的结论为： <br>mpx ≈ chameleon ≈ uniapp ≈ native ≈ wepy2 &gt; taro next ≈ kbone ≈ mpvue</p> \n<p>结论分析：</p> \n<ul>\n <li>由于mpvue全量在页面进行渲染，kbone和taro next采用了动态渲染技术，页面渲染耗时较长，其余框架并无太大区别。</li>\n</ul> \n<h3>页面更新耗时(无后台数据)</h3> \n<p>这里后台数据的定义为data中存在但当前页面渲染中未使用到的数据，在这个demo场景下即为不可用券的数据，当前会在不可用券为0的情况下，对可用券列表进行各种操作，并统计更新耗时。</p> \n<p>更新耗时的计算方式是从数据操作事件触发开始到对应的setData回调完成的耗时</p> \n<blockquote>\n mpvue中使用了当前时间戳(new Date)作为超时依据对setData进行了超时时间为50ms的节流操作，该方式存在严重问题，当vue内单次渲染同步流程执行耗时超过50ms时，后续组件patch触发的setData会突破这个节流限制，以50ms每次的频率对setData进行高频无效调用。在该性能测试demo中，当优惠券数量超过500时，界面就会完全卡死。为了顺利跑完整个测试流程，我对该问题进行了简单修复，使用setTimeout重写了节流部分，确保在vue单次渲染流程同步执行完毕后才会调用setData发送合并数据，之后mpvue的所有性能测试都是基于这个patch版本来进行的，该patch版本存放在\n <a href=\"https://github.com/hiyuki/mp-framework-benchmark/blob/master/frameworks/mpvue/runtime/patch/index.js\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a> \n</blockquote> \n<blockquote>\n 理论上来讲native的性能在进行优化的前提下一定是所有框架的天花板，但是在日常业务开发中我们可能无法对每一次setData都进行优化，以下性能测试中所有的native数据均采用修改数据后全量发送的形式来实现。\n</blockquote> \n<p>第一项测试我们使用<code>新增可用券(100)</code>操作将可用券数量由0逐级递增到1000：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>100</th> \n   <th>200</th> \n   <th>300</th> \n   <th>400</th> \n   <th>500</th> \n   <th>600</th> \n   <th>700</th> \n   <th>800</th> \n   <th>900</th> \n   <th>1000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>84.6</td> \n   <td>69.8</td> \n   <td>71.6</td> \n   <td>75</td> \n   <td>77.2</td> \n   <td>78.8</td> \n   <td>82.8</td> \n   <td>93.2</td> \n   <td>93.4</td> \n   <td>105.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>118.4</td> \n   <td>168.6</td> \n   <td>204.6</td> \n   <td>246.4</td> \n   <td>288.6</td> \n   <td>347.8</td> \n   <td>389.2</td> \n   <td>434.2</td> \n   <td>496</td> \n   <td>539</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>121.2</td> \n   <td>100</td> \n   <td>96</td> \n   <td>98.2</td> \n   <td>97.8</td> \n   <td>99.6</td> \n   <td>104</td> \n   <td>102.4</td> \n   <td>109.4</td> \n   <td>107.6</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>110.4</td> \n   <td>87.2</td> \n   <td>82.2</td> \n   <td>83</td> \n   <td>80.6</td> \n   <td>79.6</td> \n   <td>86.6</td> \n   <td>90.6</td> \n   <td>89.2</td> \n   <td>96.4</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>116.8</td> \n   <td>115.4</td> \n   <td>117</td> \n   <td>119.6</td> \n   <td>122</td> \n   <td>125.2</td> \n   <td>133.8</td> \n   <td>133.2</td> \n   <td>144.8</td> \n   <td>145.6</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>112.8</td> \n   <td>121.2</td> \n   <td>140</td> \n   <td>169</td> \n   <td>198.8</td> \n   <td>234.2</td> \n   <td>278.8</td> \n   <td>318.4</td> \n   <td>361.4</td> \n   <td>408.2</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>556.4</td> \n   <td>762.4</td> \n   <td>991.6</td> \n   <td>1220.6</td> \n   <td>1468.8</td> \n   <td>1689.6</td> \n   <td>1933.2</td> \n   <td>2150.4</td> \n   <td>2389</td> \n   <td>2620.6</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>470</td> \n   <td>604.6</td> \n   <td>759.6</td> \n   <td>902.4</td> \n   <td>1056.2</td> \n   <td>1228</td> \n   <td>1393.4</td> \n   <td>1536.2</td> \n   <td>1707.8</td> \n   <td>1867.2</td> \n  </tr> \n </tbody> \n</table> \n<p>然后我们按顺序逐项点击<code>删除可用券(all)</code> &gt; <code>新增可用券(1000)</code> &gt; <code>更新可用券(1)</code> &gt; <code>更新可用券(all)</code> &gt; <code>删除可用券(1)</code>：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>delete(all)</th> \n   <th>add(1000)</th> \n   <th>update(1)</th> \n   <th>update(all)</th> \n   <th>delete(1)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>32.8</td> \n   <td>295.6</td> \n   <td>92.2</td> \n   <td>92.2</td> \n   <td>83</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>56.8</td> \n   <td>726.4</td> \n   <td>49.2</td> \n   <td>535</td> \n   <td>530.8</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>43.6</td> \n   <td>584.4</td> \n   <td>54.8</td> \n   <td>144.8</td> \n   <td>131.2</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>41.8</td> \n   <td>489.6</td> \n   <td>52.6</td> \n   <td>169.4</td> \n   <td>165.6</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>39</td> \n   <td>765.6</td> \n   <td>95.6</td> \n   <td>237.8</td> \n   <td>144.8</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>103.6</td> \n   <td>669.4</td> \n   <td>404.4</td> \n   <td>414.8</td> \n   <td>433.6</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>120.2</td> \n   <td>4978</td> \n   <td>2356.4</td> \n   <td>2419.4</td> \n   <td>2357</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>126.6</td> \n   <td>3930.6</td> \n   <td>1607.8</td> \n   <td>1788.6</td> \n   <td>2318.2</td> \n  </tr> \n </tbody> \n</table> \n<blockquote>\n 该项测试中初期我update(all)的逻辑是循环对每个列表项进行更新，形如\n <code>listData.forEach((item)=&gt;{item.count++})</code>，发现在chameleon框架中执行界面会完全卡死，追踪发现chameleon框架中没有对setData进行异步合并处理，而是在数据变动时直接同步发送，这样在数据量为1000的场景下用该方式进行更新会高频触发1000次setData，导致界面卡死；对此，我在chameleon框架的测试demo中，将update(all)的逻辑调整为深clone产生一份更新后的listData，再将其整体赋值到this.listData当中，以确保该项测试能够正常进行。\n</blockquote> \n<p>该项测试的结论为： <br>native &gt; mpx ≈ uniapp &gt; chameleon &gt; mpvue &gt; wepy2 &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>mpx和uniapp在框架内部进行了完善的diff优化，随着数据量的增加，两个框架的新增耗时没有显著上升；</li> \n <li>wepy2会在数据变更时对props数据也进行setData，在该场景下造成了大量的无效性能损耗，导致性能表现不佳；</li> \n <li>kbone和taro next采用了动态渲染方案，每次新增更新时会发送大量描述dom结构的数据，与此同时动态递归渲染的耗时也远大于常规的静态模板渲染，使得这两个框架在所有的更新场景下耗时都远大于其他框架。</li> \n</ul> \n<h3>页面更新耗时(有后台数据)</h3> \n<p>刷新页面后我们使用<code>新增不可用券(1000)</code>创建后台数据，观察该操作是否会触发setData并统计耗时</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>back add(1000)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>45.2</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>174.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>89.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>142.6</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>134</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>0</td> \n  </tr> \n </tbody> \n</table> \n<blockquote>\n mpx进行setData优化时inspired by vue，使用了编译时生成的渲染函数跟踪模板数据依赖，在后台数据变更时不会进行setData调用，而kbone和taro next采用了动态渲染技术模拟了web底层环境，在上层完整地运行了vue框架，也达到了同样的效果。\n</blockquote> \n<p>然后我们执行和上面无后台数据时相同的操作进行耗时统计，首先是递增100：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>100</th> \n   <th>200</th> \n   <th>300</th> \n   <th>400</th> \n   <th>500</th> \n   <th>600</th> \n   <th>700</th> \n   <th>800</th> \n   <th>900</th> \n   <th>1000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>88</td> \n   <td>69.8</td> \n   <td>71.2</td> \n   <td>80.8</td> \n   <td>79.4</td> \n   <td>84.4</td> \n   <td>89.8</td> \n   <td>93.2</td> \n   <td>99.6</td> \n   <td>108</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>121</td> \n   <td>173.4</td> \n   <td>213.6</td> \n   <td>250</td> \n   <td>298</td> \n   <td>345.6</td> \n   <td>383</td> \n   <td>434.8</td> \n   <td>476.8</td> \n   <td>535.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>135.4</td> \n   <td>112.4</td> \n   <td>110.6</td> \n   <td>106.4</td> \n   <td>109.6</td> \n   <td>107.2</td> \n   <td>114.4</td> \n   <td>116</td> \n   <td>118.8</td> \n   <td>117.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>112.6</td> \n   <td>86.2</td> \n   <td>84.6</td> \n   <td>86.8</td> \n   <td>90</td> \n   <td>87.2</td> \n   <td>91.2</td> \n   <td>88.8</td> \n   <td>92.4</td> \n   <td>93.4</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>178.4</td> \n   <td>178.2</td> \n   <td>186.4</td> \n   <td>184.6</td> \n   <td>192.6</td> \n   <td>203.8</td> \n   <td>210</td> \n   <td>217.6</td> \n   <td>232.6</td> \n   <td>236.8</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>139</td> \n   <td>151</td> \n   <td>173.4</td> \n   <td>194</td> \n   <td>231.4</td> \n   <td>258.8</td> \n   <td>303.4</td> \n   <td>340.4</td> \n   <td>384.6</td> \n   <td>429.4</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>559.8</td> \n   <td>746.6</td> \n   <td>980.6</td> \n   <td>1226.8</td> \n   <td>1450.6</td> \n   <td>1705.4</td> \n   <td>1927.2</td> \n   <td>2154.8</td> \n   <td>2367.8</td> \n   <td>2617</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>482.6</td> \n   <td>626.2</td> \n   <td>755</td> \n   <td>909.6</td> \n   <td>1085</td> \n   <td>1233.2</td> \n   <td>1384</td> \n   <td>1568.6</td> \n   <td>1740.6</td> \n   <td>1883.8</td> \n  </tr> \n </tbody> \n</table> \n<p>然后按下表操作顺序逐项点击统计</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>delete(all)</th> \n   <th>add(1000)</th> \n   <th>update(1)</th> \n   <th>update(all)</th> \n   <th>delete(1)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>43.4</td> \n   <td>299.8</td> \n   <td>89.2</td> \n   <td>89</td> \n   <td>87.2</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>43.2</td> \n   <td>762.4</td> \n   <td>50</td> \n   <td>533</td> \n   <td>522.4</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>57.8</td> \n   <td>589.8</td> \n   <td>62.6</td> \n   <td>160.6</td> \n   <td>154.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>45.8</td> \n   <td>490.8</td> \n   <td>52.8</td> \n   <td>167</td> \n   <td>166</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>93.8</td> \n   <td>837</td> \n   <td>184.6</td> \n   <td>318</td> \n   <td>220.8</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>124.8</td> \n   <td>696.2</td> \n   <td>423.4</td> \n   <td>419</td> \n   <td>430.6</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>121.4</td> \n   <td>4978.2</td> \n   <td>2331.2</td> \n   <td>2448.4</td> \n   <td>2348</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>129.8</td> \n   <td>3947.2</td> \n   <td>1610.4</td> \n   <td>1813.8</td> \n   <td>2290.2</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native &gt; mpx &gt; uniapp &gt; chameleon &gt; mpvue &gt; wepy2 &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>具备模板数据跟踪能力的三个框架mpx，kbone和taro next在有后台数据场景下耗时并没有显著增加；</li> \n <li>wepy2当中的diff精度不足，耗时也没有产生明显变化；</li> \n <li>其余框架由于每次更新都会对后台数据进行deep diff，耗时都产生了一定提升。</li> \n</ul> \n<h3>页面更新耗时(大数据量场景)</h3> \n<blockquote>\n 由于mpvue和taro next的渲染全部在页面中进行，而kbone的渲染方案会额外新增大量的自定义组件，这三个框架都会在优惠券数量达到2000时崩溃白屏，我们排除了这三个框架对其余框架进行大数据量场景下的页面更新耗时测试\n</blockquote> \n<p>首先还是在无后台数据场景下使用<code>新增可用券(1000)</code>将可用券数量递增至5000：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>1000</th> \n   <th>2000</th> \n   <th>3000</th> \n   <th>4000</th> \n   <th>5000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>332.6</td> \n   <td>350</td> \n   <td>412.6</td> \n   <td>498.2</td> \n   <td>569.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>970.2</td> \n   <td>1531.4</td> \n   <td>2015.2</td> \n   <td>2890.6</td> \n   <td>3364.2</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>655.2</td> \n   <td>593.4</td> \n   <td>655</td> \n   <td>675.6</td> \n   <td>718.8</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>532.2</td> \n   <td>496</td> \n   <td>548.6</td> \n   <td>564</td> \n   <td>601.8</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>805.4</td> \n   <td>839.6</td> \n   <td>952.8</td> \n   <td>1086.6</td> \n   <td>1291.8</td> \n  </tr> \n </tbody> \n</table> \n<p>然后点击<code>新增不可用券(5000)</code>将后台数据量增加至5000，再测试可用券数量递增至5000的耗时：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>back add(5000)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>117.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>511.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>285</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>824</td> \n  </tr> \n </tbody> \n</table> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>1000</th> \n   <th>2000</th> \n   <th>3000</th> \n   <th>4000</th> \n   <th>5000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>349.8</td> \n   <td>348.4</td> \n   <td>430.4</td> \n   <td>497</td> \n   <td>594.8</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>1128</td> \n   <td>1872</td> \n   <td>2470.4</td> \n   <td>3263.4</td> \n   <td>4075.8</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>715</td> \n   <td>666.8</td> \n   <td>709.2</td> \n   <td>755.6</td> \n   <td>810.2</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>538.8</td> \n   <td>501.8</td> \n   <td>562.6</td> \n   <td>573.6</td> \n   <td>595.2</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>1509.2</td> \n   <td>1672.4</td> \n   <td>1951.8</td> \n   <td>2232.4</td> \n   <td>2586.2</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native &gt; mpx &gt; uniapp &gt; chameleon &gt; wepy2</p> \n<p>结论分析：</p> \n<ul>\n <li>在大数据量场景下，框架之间基础性能的差异会变得更加明显，mpx和uniapp依然保持了接近原生的良好性能表现，而chameleon和wepy2则产生了比较显著的性能劣化。</li>\n</ul> \n<h3>局部更新耗时</h3> \n<p>我们在可用券数量为1000的情况下，点击任意一张可用券触发选中状态，以测试局部更新性能</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>toggleSelect(ms)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>2</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>2.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>2.8</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>2.2</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>2</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>289.6</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>2440.8</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>1975</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native ≈ chameleon ≈ mpx ≈ wepy2 ≈ uniapp &gt; mpvue &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>可以看出所有使用了原生自定义组件进行组件化实现的框架局部更新耗时都极低，这足以证明小程序原生自定义组件的优秀性和重要性；</li> \n <li>mpvue由于使用了页面更新，局部更新耗时显著增加；</li> \n <li>kbone和taro next由于递归动态渲染的性能开销巨大，导致局部更新耗时同样巨大。</li> \n</ul> \n<h3>setData调用</h3> \n<p>我们将<code>proxySetData</code>的count和size选项设置为true，开启setData的次数和体积统计，重新构建后按照以下流程执行系列操作，并统计setData的调用次数和发送数据的体积。</p> \n<p>操作流程如下：</p> \n<ol> \n <li>100逐级递增可用券(0-&gt;500)</li> \n <li>切换至不可用券</li> \n <li>新增不可用券(1000)</li> \n <li>100逐级递增可用券(500-&gt;1000)</li> \n <li>更新可用券(all)</li> \n <li>切换至可用券</li> \n</ol> \n<p>操作完成后我们使用<code>getCount</code>和<code>getSize</code>方法获取累积的setData调用次数和数据体积，其中数据体积计算方式为JSON.stringify后按照utf-8编码方式进行体积计算，统计结果为：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>count</th> \n   <th>size(KB)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>14</td> \n   <td>803</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>3514</td> \n   <td>1124</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>16</td> \n   <td>2127</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>14</td> \n   <td>274</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>8</td> \n   <td>261</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>2515</td> \n   <td>319</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>22</td> \n   <td>10572</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>9</td> \n   <td>2321</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>mpx &gt; uniapp &gt; native &gt; chameleon &gt; wepy2 &gt; taro next &gt; mpvue &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>mpx框架成功实现了理论上setData的最优；</li> \n <li>uniapp由于缺失模板追踪能力紧随其后；</li> \n <li>chameleon由于组件每次创建时都会进行一次不必要的setData，产生了大量无效setData调用，但是数据的发送本身经过diff，在数据发送量上表现不错；</li> \n <li>wepy2的组件会在数据更新时调用setData发送已经更新过的props数据，因此也产生了大量无效调用，且diff精度不足，发送的数据量也较大；</li> \n <li>taro next由于上层完全基于vue，在数据发送次数上控制到了9次，但由于需要发送大量的dom描述信息，数据发送量较大；</li> \n <li>mpvue由于使用较长的数据路径描述数据对应的组件，也产生了较大的数据发送量；</li> \n <li>kbone对于setData的调用控制得不是很好，在上层运行vue的情况依然进行了22次数据发送，且发送的数据量巨大，在此流程中达到了惊人的10MB。</li> \n</ul> \n<h3>页面渲染耗时(静态测试)</h3> \n<p>此处的页面渲染耗时与前面描述的动态测试场景中相同，测试结果如下：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>页面渲染耗时</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>70.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>86.6</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>115.2</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>69.6</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>66.6</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>65</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>144.2</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>119.8</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>chameleon ≈ mpx ≈ uniapp ≈ native &gt; wepy2 &gt; mpvue ≈ taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul>\n <li>除了kbone和taro next采用动态渲染耗时增加，mpvue使用页面模板渲染性能稍差，其余框架的静态页面渲染表现都和原生差不多。</li>\n</ul> \n<h2>结论</h2> \n<p>综合上述测试数据，我们得到最终的小程序框架运行时性能排名为： <br>mpx &gt; uniapp &gt; chameleon &gt; wepy2 &gt; mpvue &gt; taro next &gt; kbone</p> \n<h2>一点私货</h2> \n<p>虽然kbone和taro next采用了动态渲染技术在性能表现上并不尽如人意，但是我依然认为这是很棒的技术方案。虽然本文从头到位都在进行性能测试和对比，但性能并不是框架的全部，开发效率和高可用性仍然是框架的重心，开发效率相信是所有框架设计的初衷，但是高可用性却在很大程度被忽视。从这个角度来说，kbone和taro next是非常成功的，不同于过去的转译思路，这种从抹平底层渲染环境的做法能够使上层web框架完整运行，在框架可用性上带来非常大的提升，非常适合于运营类简单小程序的迁移和开发。</p> \n<p>我主导开发的mpx框架(<a href=\"https://github.com/didi/mpx)\" rel=\"nofollow noreferrer\">https://github.com/didi/mpx)</a> 选择了另一条道路解决可用性问题，那就是基于小程序原生语法能力进行增强，这样既能避免转译web框架时带来的不确定性和不稳定性，同时也能带来非常接近于原生的性能表现，对于复杂业务小程序的开发者来说，非常推荐使用。在跨端输出方面，mpx目前能够完善支持业内全部小程序平台和web平台的同构输出，滴滴内部最重要最复杂的小程序——滴滴出行小程序完全基于mpx进行开发，并利用框架提供的跨端能力对微信和支付宝入口进行同步业务迭代，大大提升了业务开发效率。</p>', null, 'http://localhost:8060/tup/2020/4/23/41fa08be2e4f47ffa868f9e4b4647b74.jpg', '1c5851dc916d4e70a60f0c957f548876', '7b3e40f8b9cc4b7780dc39a71d7f580e', '63c4e1e7ec204b43a62065a3ced4c2ce,3b375646301546259a8fb29d74ae4447,2ff36c3d3aec49d8a19cd1d17c6e9a7e,66df11ef95064996ba39f328e25451f5', '0', '3', '1', '2020-04-23 10:30:11', '2020-04-23 10:30:11');
INSERT INTO `tb_recommend` VALUES ('f4128a89f2264a42b80a9a5b1495ec96', 'Taro Next H5 跨框架组件库架构演进与实践', '过去的 Taro 1 与 Taro 2 只能使用 React 语法进行开发，但下一代的 Taro 框架对整体架构进行了升级，支持使用 React、Vue、Nerv 等框架开发多端应用。', '<p>作者：凹凸曼 - JJ<br><a href=\"https://github.com/NervJS/taro\" rel=\"nofollow noreferrer\">Taro</a> 是一款多端开发框架。开发者只需编写一份代码，即可生成各小程序端、H5 以及 React Native 的应用。</p> \n<blockquote> \n <a href=\"http://taro-docs-in.jd.com/taro/next/docs/next/README.html\" rel=\"nofollow noreferrer\">Taro Next</a> 近期已发布 beta 版本，全面完善对小程序以及 H5 的支持，欢迎体验！\n</blockquote> \n<h2>背景</h2> \n<h3>Taro Next 将支持使用多框架开发</h3> \n<p>过去的 Taro 1 与 Taro 2 只能使用 React 语法进行开发，但下一代的 Taro 框架对整体架构进行了<a href=\"https://aotu.io/notes/2020/02/03/taro-next-alpha/\" rel=\"nofollow noreferrer\">升级</a>，支持使用 React、Vue、Nerv 等框架开发多端应用。</p> \n<p>为了支持使用多框架进行开发，Taro 需要对自身的各端适配能力进行改造。本文将重点介绍对 <strong>Taro H5 端组件库</strong>的改造工作。</p> \n<h3>Taro H5</h3> \n<p>Taro 遵循以微信小程序为主，其他小程序为辅的组件与 API 规范。</p> \n<p>但浏览器并没有小程序规范的组件与 API 可供使用，例如我们不能在浏览器上使用小程序的 <code>view</code> 组件和 <code>getSystemInfo</code> API。因此我们需要在 H5 端实现一套基于小程序规范的组件库和 API 库。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFYR3\" src=\"http://localhost:8060/tup/2020/4/23/c6705f0ce40244199424a7ca093fe9e5.jpg\" alt=\"Taro H5 架构图\" title=\"Taro H5 架构图\"></span></p> \n<p>在 Taro 1 和 Taro 2 中，Taro H5 的组件库使用了 React 语法进行开发。但如果开发者在 Taro Next 中使用 Vue 开发 H5 应用，则不能和现有的 H5 组件库兼容。</p> \n<p>所以本文需要面对的核心问题就是：<strong>我们需要在 H5 端实现 React、Vue 等框架都可以使用的组件库</strong>。</p> \n<h3>方案选择</h3> \n<p>我们最先想到的是使用 Vue 再开发一套组件库，这样最为稳妥，工作量也没有特别大。</p> \n<p>但考虑到以下两点，我们遂放弃了此思路：</p> \n<ol> \n <li>组件库的可维护性和拓展性不足。每当有问题需要修复或新功能需要添加，我们需要分别对 React 和 Vue 版本的组件库进行改造。</li> \n <li>Taro Next 的目标是支持使用任意框架开发多端应用。倘若将来支持使用 Angular 等框架进行开发，那么我们需要再开发对应支持 Angular 等框架的组件库。</li> \n</ol> \n<p>那么是否存在着一种方案，使得只用一份代码构建的组件库能兼容所有的 web 开发框架呢？</p> \n<p>答案就是 <strong>Web Components</strong>。</p> \n<p>但在组件库改造为 Web Components 的过程并不是一帆风顺的，我们也遇到了不少的问题，故借此文向大家娓娓道来。</p> \n<h2>Web Components 简介</h2> \n<p><a href=\"https://www.webcomponents.org/introduction\" rel=\"nofollow noreferrer\">Web Components</a> 由一系列的技术规范所组成，它让开发者可以开发出浏览器原生支持的组件。</p> \n<h3>技术规范</h3> \n<p>Web Components 的主要技术规范为：</p> \n<ul> \n <li>Custom Elements</li> \n <li>Shadow DOM</li> \n <li>HTML Template</li> \n</ul> \n<p>Custom Elements 让开发者可以自定义带有特定行为的 HTML 标签。</p> \n<p>Shadow DOM 对标签内的结构和样式进行一层包装。</p> \n<p><code>&lt;template&gt;</code> 标签为 Web Components 提供复用性，还可以配合 <code>&lt;slot&gt;</code> 标签提供灵活性。</p> \n<h3>示例</h3> \n<p>定义模板：</p> \n<pre><code class=\"html\">&lt;template id=\"template\"&gt;\n  &lt;h1&gt;Hello World!&lt;/h1&gt;\n&lt;/template&gt;</code></pre> \n<p>构造 Custom Element：</p> \n<pre><code class=\"js\">class App extends HTMLElement {\n  constructor () {\n    super(...arguments)\n\n    // 开启 Shadow DOM\n    const shadowRoot = this.attachShadow({ mode: \'open\' })\n\n    // 复用 &lt;template&gt; 定义好的结构\n    const template = document.querySelector(\'#template\')\n    const node = template.content.cloneNode(true)\n    shadowRoot.appendChild(node)\n  }\n}\nwindow.customElements.define(\'my-app\', App)</code></pre> \n<p>使用：</p> \n<pre><code class=\"html\">&lt;my-app&gt;&lt;/my-app&gt;</code></pre> \n<h2>Stencil</h2> \n<p>使用原生语法去编写 Web Components 相当繁琐，因此我们需要一个框架帮助我们提高开发效率和开发体验。</p> \n<p>业界已经有很多成熟的 <a href=\"https://www.webcomponents.org/libraries\" rel=\"nofollow noreferrer\">Web Components 框架</a>，一番比较后我们最终选择了 <a href=\"https://stenciljs.com/docs/introduction\" rel=\"nofollow noreferrer\">Stencil</a>，原因有二：</p> \n<ol> \n <li>Stencil 由 Ionic 团队打造，被用于构建 Ionic 的组件库，证明经受过业界考验。</li> \n <li>Stencil 支持 JSX，能减少现有组件库的迁移成本。</li> \n</ol> \n<p>Stencil 是一个可以生成 Web Components 的编译器。它糅合了业界前端框架的一些优秀概念，如支持 Typescript、JSX、虚拟 DOM 等。</p> \n<h3>示例：</h3> \n<p>创建 Stencil Component：</p> \n<pre><code class=\"jsx\">import { Component, Prop, State, h } from \'@stencil/core\'\n\n@Component({\n  tag: \'my-component\'\n})\nexport class MyComponent {\n  @Prop() first = \'\'\n  @State() last = \'JS\'\n\n  componentDidLoad () {\n    console.log(\'load\')\n  }\n\n  render () {\n    return (\n      &lt;div&gt;\n        Hello, my name is {this.first} {this.last}\n      &lt;/div&gt;\n    )\n  }\n}</code></pre> \n<p>使用组件：</p> \n<pre><code class=\"html\">&lt;my-component first=\'Taro\' /&gt;</code></pre> \n<h2>在 React 与 Vue 中使用 Stencil</h2> \n<p>到目前为止一切都那么美好：使用 Stencil 编写出 Web Components，即可以在 React 和 Vue 中直接使用它们。</p> \n<p>但实际使用上却会出现一些问题，<a href=\"https://custom-elements-everywhere.com/\" rel=\"nofollow noreferrer\">Custom Elements Everywhere</a> 通过一系列的测试用例，罗列出业界前端框架对 Web Components 的兼容问题及相关 issues。下面将简单介绍 Taro H5 组件库分别对 React 和 Vue 的兼容工作。</p> \n<h3>兼容 React</h3> \n<h4>1. Props</h4> \n<h5>1.1 问题</h5> \n<p>React 使用 <code>setAttribute</code> 的形式给 Web Components 传递参数。当参数为原始类型时是可以运行的，但是如果参数为对象或数组时，由于 HTML 元素的 attribute 值只能为字符串或 null，最终给 WebComponents 设置的 attribute 会是 <code>attr=\"[object Object]\"</code>。</p> \n<blockquote>\n attribute 与 property \n <a href=\"https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html#answer-6004028\" rel=\"nofollow noreferrer\">区别</a> \n</blockquote> \n<h5>1.2 解决方案</h5> \n<p>采用 <strong>DOM Property</strong> 的方法传参。</p> \n<p>我们可以把 Web Components 包装一层高阶组件，把高阶组件上的 props 设置为 Web Components 的 property：</p> \n<pre><code class=\"js\">const reactifyWebComponent = WC =&gt; {\n  return class extends React.Component {\n    ref = React.createRef()\n\n    update () {\n      Object.entries(this.props).forEach(([prop, val]) =&gt; {\n        if (prop === \'children\' || prop === \'dangerouslySetInnerHTML\') {\n          return\n        }\n        if (prop === \'style\' &amp;&amp; val &amp;&amp; typeof val === \'object\') {\n          for (const key in val) {\n            this.ref.current.style[key] = val[key]\n          }\n          return\n        }\n        this.ref.current[prop] = val\n      })\n    }\n\n    componentDidUpdate () {\n      this.update()\n    }\n\n    componentDidMount () {\n      this.update()\n    }\n\n    render () {\n      const { children, dangerouslySetInnerHTML } = this.props\n      return React.createElement(WC, {\n        ref: this.ref,\n        dangerouslySetInnerHTML\n      }, children)\n    }\n  }\n}\n\nconst MyComponent = reactifyWebComponent(\'my-component\')</code></pre> \n<p>注意：</p> \n<ul> \n <li>children、dangerouslySetInnerHTML 属性需要透传。</li> \n <li>React 中 style 属性值可以接受对象形式，这里需要额外处理。</li> \n</ul> \n<h4>2. Events</h4> \n<h5>2.1 问题</h5> \n<p>因为 React 有一套<a href=\"https://reactjs.org/docs/events.html\" rel=\"nofollow noreferrer\">合成事件系统</a>，所以它不能监听到 Web Components 发出的自定义事件。</p> \n<p>以下 Web Component 的 onLongPress 回调不会被触发：</p> \n<pre><code class=\"html\">&lt;my-view onLongPress={onLongPress}&gt;view&lt;/my-view&gt;</code></pre> \n<h5>2.2 解决方案</h5> \n<p>通过 ref 取得 Web Component 元素，手动 <strong>addEventListener</strong> 绑定事件。</p> \n<p>改造上述的高阶组件：</p> \n<pre><code class=\"js\">const reactifyWebComponent = WC =&gt; {\n  return class Index extends React.Component {\n    ref = React.createRef()\n    eventHandlers = []\n\n    update () {\n      this.clearEventHandlers()\n\n      Object.entries(this.props).forEach(([prop, val]) =&gt; {\n        if (typeof val === \'function\' &amp;&amp; prop.match(/^on[A-Z]/)) {\n          const event = prop.substr(2).toLowerCase()\n          this.eventHandlers.push([event, val])\n          return this.ref.current.addEventListener(event, val)\n        }\n\n        ...\n      })\n    }\n\n    clearEventHandlers () {\n      this.eventHandlers.forEach(([event, handler]) =&gt; {\n        this.ref.current.removeEventListener(event, handler)\n      })\n      this.eventHandlers = []\n    }\n\n    componentWillUnmount () {\n      this.clearEventHandlers()\n    }\n\n    ...\n  }\n}</code></pre> \n<h4>3. Ref</h4> \n<h5>3.1 问题</h5> \n<p>我们为了解决 Props 和 Events 的问题，引入了高阶组件。那么当开发者向高阶组件传入 ref 时，获取到的其实是高阶组件，但我们希望开发者能获取到对应的 Web Component。</p> \n<p>domRef 会获取到 <code>MyComponent</code>，而不是 <code>&lt;my-component&gt;&lt;/my-component&gt;</code></p> \n<pre><code class=\"jsx\">&lt;MyComponent ref={domRef} /&gt;</code></pre> \n<h5>3.2 解决方案</h5> \n<p>使用 <a href=\"https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components\" rel=\"nofollow noreferrer\">forwardRef</a> 传递 ref。</p> \n<p>改造上述的高阶组件为 forwardRef 形式：</p> \n<pre><code class=\"js\">const reactifyWebComponent = WC =&gt; {\n  class Index extends React.Component {\n    ...\n\n    render () {\n      const { children, forwardRef } = this.props\n      return React.createElement(WC, {\n        ref: forwardRef\n      }, children)\n    }\n  }\n  return React.forwardRef((props, ref) =&gt; (\n    React.createElement(Index, { ...props, forwardRef: ref })\n  ))\n}</code></pre> \n<h4>4. Host\'s className</h4> \n<h5>4.1 问题</h5> \n<p>在 Stencil 里我们可以使用 Host 组件为 host element 添加类名。</p> \n<pre><code class=\"js\">import { Component, Host, h } from \'@stencil/core\';\n\n@Component({\n  tag: \'todo-list\'\n})\nexport class TodoList {\n  render () {\n    return (\n      &lt;Host class=\'todo-list\'&gt;\n        &lt;div&gt;todo&lt;/div&gt;\n      &lt;/Host&gt;\n    )\n  }\n}</code></pre> \n<p>然后在使用 <code>&lt;todo-list&gt;</code> 元素时会展示我们内置的类名 “todo-list” 和 Stencil 自动加入的类名 “hydrated”：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFYR4\" src=\"http://localhost:8060/tup/2020/4/23/4d8569f7eee24461a3c4ac97cbc74961.jpg\" alt=\"\" title=\"\"></span></p> \n<p>但如果我们在使用时设置了动态类名，如： <code>&lt;todo-list class={this.state.cls}&gt;</code>。那么在动态类名更新时，则会把内置的类名 “todo-list” 和 “hydrated” 抹除掉。</p> \n<p><strong>关于类名 “hydrated”：</strong></p> \n<p>Stencil 会为所有 Web Components 加上 <code>visibility: hidden;</code> 的样式。然后在各 Web Component 初始化完成后加入类名 “hydrated”，将 <code>visibility</code> 改为 <code>inherit</code>。如果 “hydrated” 被抹除掉，Web Components 将不可见。</p> \n<p>因此我们需要保证在类名更新时不会覆盖 Web Components 的内置类名。</p> \n<h5>4.2 解决方案</h5> \n<p>高阶组件在使用 ref 为 Web Component 设置 className 属性时，对内置 class 进行合并。</p> \n<p>改造上述的高阶组件：</p> \n<pre><code class=\"js\">const reactifyWebComponent = WC =&gt; {\n  class Index extends React.Component {\n    update (prevProps) {\n      Object.entries(this.props).forEach(([prop, val]) =&gt; {\n        if (prop.toLowerCase() === \'classname\') {\n          this.ref.current.className = prevProps\n            // getClassName 在保留内置类名的情况下，返回最新的类名\n            ? getClassName(this.ref.current, prevProps, this.props)\n            : val\n          return\n        }\n\n        ...\n      })\n    }\n\n    componentDidUpdate (prevProps) {\n      this.update(prevProps)\n    }\n\n    componentDidMount () {\n      this.update()\n    }\n\n    ...\n  }\n  return React.forwardRef((props, ref) =&gt; (\n    React.createElement(Index, { ...props, forwardRef: ref })\n  ))\n}</code></pre> \n<h3>兼容 Vue</h3> \n<p>不同于 React，虽然 Vue 在传递参数给 Web Components 时也是采用 <code>setAttribute</code> 的方式，但 v-bind 指令提供了 <a href=\"https://cn.vuejs.org/v2/api/#v-bind\" rel=\"nofollow noreferrer\">.prop</a> 修饰符，它可以将参数作为 DOM property 来绑定。另外 Vue 也能监听 Web Components 发出的自定义事件。</p> \n<p>因此 Vue 在 Props 和 Events 两个问题上都不需要额外处理，但在与 Stencil 的配合上还是有一些兼容问题，接下来将列出主要的三点。</p> \n<h4>1. Host\'s className</h4> \n<h5>1.1 问题</h5> \n<p>同上文兼容 React 第四部分，在 Vue 中更新 host element 的 class，也会覆盖内置 class。</p> \n<h5>1.2 解决方案</h5> \n<p>同样的思路，需要在 Web Components 上包装一层 Vue 的自定义组件。</p> \n<pre><code class=\"js\">function createComponent (name, classNames = []) {\n  return {\n    name,\n    computed: {\n      listeners () {\n        return { ...this.$listeners }\n      }\n    },\n    render (createElement) {\n      return createElement(name, {\n        class: [\'hydrated\', ...classNames],\n        on: this.listeners\n      }, this.$slots.default)\n    }\n  }\n}\n\nVue.component(\'todo-list\', createComponent(\'todo-list\', [\'todo-list\']))</code></pre> \n<p>注意：</p> \n<ul> \n <li>我们在自定义组件中重复声明了 Web Component 该有的内置类名。后续开发者为自定义组件设置类名时，Vue 将会<a href=\"https://cn.vuejs.org/v2/guide/components-props.html#%E6%9B%BF%E6%8D%A2-%E5%90%88%E5%B9%B6%E5%B7%B2%E6%9C%89%E7%9A%84-Attribute\" rel=\"nofollow noreferrer\">自动对类名进行合并</a>。</li> \n <li>需要把自定义组件上绑定的事件通过 <a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#%E5%B0%86%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%88%B0%E7%BB%84%E4%BB%B6\" rel=\"nofollow noreferrer\">&amp;dollar;listeners</a> 透传给 Web Component。</li> \n</ul> \n<h4>2. Ref</h4> \n<h5>2.1 问题</h5> \n<p>为了解决问题 1，我们给 Vue 中的 Web Components 都包装了一层自定义组件。同样地，开发者在使用 ref 时取到的是自定义组件，而不是 Web Component。</p> \n<h5>2.2 解决方案</h5> \n<p>Vue 并没有 forwardRef 的概念，只可简单粗暴地修改 <code>this.$parent.$refs</code>。</p> \n<p>为自定义组件增加一个 mixin：</p> \n<pre><code class=\"js\">export const refs = {\n  mounted () {\n    if (Object.keys(this.$parent.$refs).length) {\n      const refs = this.$parent.$refs\n\n      for (const key in refs) {\n        if (refs[key] === this) {\n          refs[key] = this.$el\n          break\n        }\n      }\n    }\n  },\n  beforeDestroy () {\n    if (Object.keys(this.$parent.$refs).length) {\n      const refs = this.$parent.$refs\n\n      for (const key in refs) {\n        if (refs[key] === this.$el) {\n          refs[key] = null\n          break\n        }\n      }\n    }\n  }\n}</code></pre> \n<p>注意：</p> \n<ul>\n <li>上述代码没有处理循环 ref，循环 ref 还需要另外判断和处理。</li>\n</ul> \n<h4>3. v-model</h4> \n<h5>3.1 问题</h5> \n<p>我们在自定义组件中使用了渲染函数进行渲染，因此对表单组件需要额外处理 <a href=\"https://cn.vuejs.org/v2/guide/render-function.html#v-model\" rel=\"nofollow noreferrer\">v-model</a>。</p> \n<h5>3.2 解决方案</h5> \n<p>使用自定义组件上的 <code>model</code> 选项，定制组件使用 <code>v-model</code> 时的 prop 和 event。</p> \n<p>改造上述的自定义组件：</p> \n<pre><code class=\"js\">export default function createFormsComponent (name, event, modelValue = \'value\', classNames = []) {\n  return {\n    name,\n    computed: {\n      listeners () {\n        return { ...this.$listeners }\n      }\n    },\n    model: {\n      prop: modelValue,\n      event: \'model\'\n    },\n    methods: {\n      input (e) {\n        this.$emit(\'input\', e)\n        this.$emit(\'model\', e.target.value)\n      },\n      change (e) {\n        this.$emit(\'change\', e)\n        this.$emit(\'model\', e.target.value)\n      }\n    },\n    render (createElement) {\n      return createElement(name, {\n        class: [\'hydrated\', ...classNames],\n        on: {\n          ...this.listeners,\n          [event]: this[event]\n        }\n      }, this.$slots.default)\n    }\n  }\n}\n\nconst Input = createFormsComponent(\'taro-input\', \'input\')\nconst Switch = createFormsComponent(\'taro-switch\', \'change\', \'checked\')\nVue.component(\'taro-input\', Input)\nVue.component(\'taro-switch\', Switch)</code></pre> \n<h2>总结</h2> \n<p>当我们希望创建一些不拘泥于框架的组件时，Web Components 会是一个不错的选择。比如跨团队协作，双方的技术栈不同，但又需要公用部分组件时。</p> \n<p>本次对 React 语法组件库进行 Web Components 化改造，工作量不下于重新搭建一个 Vue 组件库。但日后当 Taro 支持使用其他框架编写多端应用时，只需要针对对应框架与 Web Components 和 Stencil 的兼容问题编写一个胶水层即可，总体来看还是值得的。</p> \n<p>关于胶水层，业界兼容 React 的方案颇多，只是兼容 Web Components 可以使用 <a href=\"https://github.com/BBKolton/reactify-wc\" rel=\"nofollow noreferrer\">reactify-wc</a>，配合 Stencil 则可以使用官方提供的插件 <a href=\"https://github.com/ionic-team/stencil-ds-plugins/blob/master/README.md\" rel=\"nofollow noreferrer\">Stencil DS Plugin</a>。倘若 Vue 需要兼容 Stencil，或需要提高兼容时的灵活性，还是建议手工编写一个胶水层。</p> \n<p>本文简单介绍了 Taro Next、Web Components、Stencil 以及基于 Stencil 的组件库改造历程，希望能为读者们带来一些帮助与启迪。</p> \n<hr> \n<p>欢迎关注凹凸实验室博客：<a href=\"https://aotu.io/\" rel=\"nofollow noreferrer\">aotu.io</a></p> \n<p>或者关注凹凸实验室公众号（AOTULabs），不定时推送文章：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbA4t5\" src=\"http://localhost:8060/tup/2020/4/23/718c9e784edf4c63a0ea29f0fddb9fe7.jpg\" alt=\"欢迎关注凹凸实验室公众号\" title=\"欢迎关注凹凸实验室公众号\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/aa7b0902bbe34907b3c19a38db670f0b.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'd79254c4ca5e45dca9d484307c935281,7506700dea5a42298b9ecb0ac0aaab41,3b375646301546259a8fb29d74ae4447', '0', '3', '1', '2020-04-23 10:30:01', '2020-04-23 10:30:01');
INSERT INTO `tb_recommend` VALUES ('f67ec38532e34b84bd32417800b0fc3e', '使用 Springboot 开发电商项目之 IDEA 创建项目 (二)', '本博文是按照how2j.cn教程 Java天猫整站Springboot实战项目学习的，该教程是我目前见过最好、最完整、最系统的Java入门学习到实战的课程，作者列了完整的学习路线图，有大量的实战项目，由浅入深，很容易上手。', '<blockquote>\n 本博文是按照\n <a href=\"https://how2j.cn/k/tmall_springboot/tmall_springboot-1799/1799.html?p=126405\" rel=\"nofollow noreferrer\">how2j.cn</a>教程 Java天猫整站Springboot实战项目学习的，该教程是我目前见过最好、最完整、最系统的Java入门学习到实战的课程，作者列了完整的学习路线图，有大量的实战项目，由浅入深，很容易上手。\n</blockquote> \n<h2>一、开发环境</h2> \n<ul> \n <li>OS MacOS</li> \n <li>JDK 1.8</li> \n <li>SpringBoot 1.5.9</li> \n <li>IDEA IDEA 2019</li> \n</ul> \n<h2>二、新建项目</h2> \n<h3>1、新建项目</h3> \n<p>使用 IDEA 新建项目，点击 Create New Project，选中maven webapp格式，然后next：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022290849\" src=\"http://localhost:8060/tup/2020/4/23/7e35108b8dde40fe9b86282c32bf351a.jpg\" alt=\"file\" title=\"file\"></span></p> \n<h3>2、项目参数</h3> \n<p>GroupId: com.how2java.tmall<br>Artifact: tmall_springboot</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022290850\" src=\"http://localhost:8060/tup/2020/4/23/eeb984370d074e52baa4cc776b5aa2e8.jpg\" alt=\"file\" title=\"file\"></span></p> \n<h3>3、依赖</h3> \n<ul> \n <li>\n  <ol>\n   <li>左边选中 Web</li>\n  </ol></li> \n <li>\n  <ol>\n   <li>右边选中 Web</li>\n  </ol></li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022290853\" src=\"http://localhost:8060/tup/2020/4/23/7dc07ee38a39416aaefcf593ff98d953.jpg\" alt=\"file\" title=\"file\"></span></p> \n<h3>4、项目路径</h3> \n<p>项目路径选择：</p> \n<pre><code>e:\\project\\tmall_springboot</code></pre> \n<h3>5、Maven仓库</h3> \n<p>Maven仓库配置可以参照我们上一篇博文：<br><a href=\"http://digtime.cn/articles/313/shi-yong-springboot-kuang-jia-kai-fa-dian-shang-xiang-mu-zheng-zhan-zhi-kai-fa-huan-jing-da-jian-yi\" rel=\"nofollow noreferrer\">使用 Springboot 开发电商项目之开发环境搭建 (一)</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022289212\" src=\"http://localhost:8060/tup/2020/4/23/96e899ba31804afba4c664354a0795fd.jpg\" alt=\"file\" title=\"file\"></span></p> \n<h3>6、删除默认类</h3> \n<p>首先删除 <code>TmallSpringbootApplication.java</code> 这个自动创建的类，并且把其包也删除掉。</p> \n<h3>7、配置 pom.xml</h3> \n<p>复制如下内容到已经存在的pom里，如图所示，这个过程会导致idea去下载pom里声明的相关jar包，会花一定的时间，视网络和计算机性能而定。<br>此时会弹出如图所示的提醒，为了避免每次修改 pom.xml 都出现这个对话框，点击 \"<code>Enable Auto-Import</code>\"<br>为了确保导入成功，右键点击pom.xml-&gt;Maven-&gt;Reimport</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022290851\" src=\"http://localhost:8060/tup/2020/4/23/9bcca595b09a420b855ab29ff3a60f45.jpg\" alt=\"file\" title=\"file\"></span></p> \n<pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n  &lt;groupId&gt;com.how2java.tmall&lt;/groupId&gt;\n  &lt;artifactId&gt;tmall_springboot&lt;/artifactId&gt;\n  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n  &lt;name&gt;tmall_springboot&lt;/name&gt;\n  &lt;description&gt;tmall_springboot&lt;/description&gt;\n  &lt;packaging&gt;war&lt;/packaging&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;dependencies&gt;\n        &lt;!-- springboot web --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- springboot tomcat 支持 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 热部署 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;       \n        &lt;!-- jpa--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/dependency&gt;        \n        &lt;!-- redis --&gt;      \n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;    \n        &lt;!-- springboot test --&gt; \n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt; \n        &lt;!-- thymeleaf --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- elastic search --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 用了 elasticsearch 就要加这么一个，不然要com.sun.jna.Native 错误 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.sun.jna&lt;/groupId&gt;\n            &lt;artifactId&gt;jna&lt;/artifactId&gt;\n            &lt;version&gt;3.0.9&lt;/version&gt;\n        &lt;/dependency&gt;        \n                 \n        &lt;!-- thymeleaf legacyhtml5 模式支持 --&gt;      \n        &lt;dependency&gt;\n            &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt;\n            &lt;artifactId&gt;nekohtml&lt;/artifactId&gt;\n            &lt;version&gt;1.9.22&lt;/version&gt;\n        &lt;/dependency&gt;        \n        &lt;!-- 测试支持 --&gt;\n        &lt;dependency&gt;\n              &lt;groupId&gt;junit&lt;/groupId&gt;\n              &lt;artifactId&gt;junit&lt;/artifactId&gt;\n              &lt;version&gt;4.12&lt;/version&gt;\n              &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;   \n        &lt;!-- tomcat的支持.--&gt;\n        &lt;dependency&gt;\n               &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;\n               &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;\n               &lt;version&gt;8.5.23&lt;/version&gt;\n        &lt;/dependency&gt;    \n        &lt;!-- mysql--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;5.1.21&lt;/version&gt;\n        &lt;/dependency&gt;\n      \n        &lt;!-- junit --&gt;\n        &lt;dependency&gt;\n          &lt;groupId&gt;junit&lt;/groupId&gt;\n          &lt;artifactId&gt;junit&lt;/artifactId&gt;\n          &lt;version&gt; 4.12&lt;/version&gt;\n        &lt;/dependency&gt;                \n        &lt;!-- commons-lang --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;commons-lang&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;\n            &lt;version&gt;2.6&lt;/version&gt;\n        &lt;/dependency&gt;       \n        &lt;!-- shiro --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\n            &lt;version&gt;1.3.2&lt;/version&gt;\n        &lt;/dependency&gt;        \n        &lt;!-- hsqldb --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;\n            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;\n        &lt;/dependency&gt;    \n    &lt;/dependencies&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;</code></pre> \n<h2>三、后台分类管理</h2> \n<h3>1、实体类</h3> \n<p>Category.java</p> \n<p>首先新建包，菜单 -&gt; File -&gt; Package -&gt; 然后输入</p> \n<pre><code>com.how2java.tmall.pojo</code></pre> \n<p>然后创建类 Category，接下来.讲解这个类。</p> \n<pre><code>@Entity </code></pre> \n<p>表示这是一个实体类</p> \n<pre><code>@Table(name = \"category\") </code></pre> \n<p>表示对应的表名是 category</p> \n<pre><code>@JsonIgnoreProperties({ \"handler\",\"hibernateLazyInitializer\" })</code></pre> \n<p>因为是做前后端分离，而前后端数据交互用的是 json 格式。 那么 Category 对象就会被转换为 json 数据。 而本项目使用 jpa 来做实体类的持久化，jpa 默认会使用 hibernate, 在 jpa 工作过程中，就会创造代理类来继承 Category ，并添加 handler 和 hibernateLazyInitializer 这两个<code>无须 json 化的属性</code>，所以这里需要用 JsonIgnoreProperties 把这两个属性忽略掉。</p> \n<pre><code>package com.how2java.tmall.pojo;\n \nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\nimport javax.persistence.Table;\n \nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n \n@Entity\n@Table(name = \"category\")\n@JsonIgnoreProperties({ \"handler\",\"hibernateLazyInitializer\" })\n \npublic class Category {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")   \n    int id;\n     \n    String name;\n     \n    public int getId() {\n        return id;\n    }\n    public void setId(int id) {\n        this.id = id;\n    }\n     \n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n}</code></pre> \n<h3>2、创建DAO类</h3> \n<p>CategoryDAO.java</p> \n<p>在 Category.java 步骤里已经讲解过了如何创建包，这里就不讲解如何创建包，而是直接给出类了。<br>CategoryDAO 类集成了 JpaRepository，就提供了CRUD和分页 的各种常见功能。 这就是采用 JPA 方便的地方~</p> \n<pre><code>package com.how2java.tmall.dao;\n  \nimport org.springframework.data.jpa.repository.JpaRepository;\n \nimport com.how2java.tmall.pojo.Category;\n \npublic interface CategoryDAO extends JpaRepository&lt;Category,Integer&gt;{\n \n}</code></pre> \n<h3>3、服务类</h3> \n<p>CategoryService.java</p> \n<pre><code>@Service</code></pre> \n<p>标记这个类是 Service类</p> \n<pre><code>@Autowired CategoryDAO categoryDAO;</code></pre> \n<p>自动装配 上个步骤的 CategoryDAO 对象</p> \n<pre><code>   public List&lt;Category&gt; list() {\n       Sort sort = new Sort(Sort.Direction.DESC, \"id\");\n       return categoryDAO.findAll(sort);\n   }</code></pre> \n<p>首先创建一个 Sort 对象，表示通过 id 倒排序， 然后通过 categoryDAO进行查询。</p> \n<blockquote>\n 注： 这里抛弃了 CategoryService 接口 加上 CategoryService 实现类的这种累赘的写法，而是直接使用 CategoryService 作为实现类来做。\n</blockquote> \n<pre><code>package com.how2java.tmall.service;\n \nimport java.util.List;\n \nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.stereotype.Service;\n \nimport com.how2java.tmall.dao.CategoryDAO;\nimport com.how2java.tmall.pojo.Category;\n \n@Service\npublic class CategoryService {\n    @Autowired CategoryDAO categoryDAO;\n \n    public List&lt;Category&gt; list() {\n        Sort sort = new Sort(Sort.Direction.DESC, \"id\");\n        return categoryDAO.findAll(sort);\n    }\n}</code></pre> \n<h3>4、页面控制器类</h3> \n<p><code>AdminPageController.java</code><br>后台管理页面跳转专用控制器。<br>因为是做前后端分离，所以数据是通过 RESTFUL接口来取的，而在业务上，除了 RESTFUL 服务要提供，还要提供页面跳转服务，所以所有的后台页面跳转都放在 AdminPageController 这个控制器里。 而RSTFUL 专门放在 Category 对应的控制器 <code>CategoryController.java</code> 里面。 这样代码更清晰，不会搅起搅起的~</p> \n<pre><code>@Controller</code></pre> \n<p>表示这是一个控制器。</p> \n<pre><code>@GetMapping(value=\"/admin\")\npublic String admin(){\n   return \"redirect:admin_category_list\";\n}</code></pre> \n<p>访问地址 admin,就会客户端跳转到 admin_category_list去。</p> \n<pre><code>@GetMapping(value=\"/admin_category_list\")\npublic String listCategory(){\n    return \"admin/listCategory\";\n}</code></pre> \n<p>访问地址 admin_category_list 就会访问 admin/listCategory.html 文件。</p> \n<pre><code>package com.how2java.tmall.web;\n \nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\n \n@Controller\npublic class AdminPageController {\n    @GetMapping(value=\"/admin\")\n    public String admin(){\n        return \"redirect:admin_category_list\";\n    }\n    @GetMapping(value=\"/admin_category_list\")\n    public String listCategory(){\n        return \"admin/listCategory\";\n    }\n}</code></pre> \n<h3>5、REST服务控制器</h3> \n<p><code>CategoryController.java</code><br>这个就是专门用来提供 RESTFUL 服务器控制器了</p> \n<pre><code>@RestController</code></pre> \n<p>表示这是一个控制器，并且对每个方法的返回值都会直接转换为 json 数据格式。</p> \n<pre><code>@Autowired CategoryService categoryService;</code></pre> \n<p>自动装配 CategoryService</p> \n<pre><code>    @GetMapping(\"/categories\")\n    public List&lt;Category&gt; list() throws Exception {\n        return categoryService.list();\n    }</code></pre> \n<p>对于categories 访问，会获取所有的 Category对象集合，并返回这个集合。 因为是声明为 @RestController， 所以这个集合，又会被自动转换为 JSON数组抛给浏览器。</p> \n<pre><code>package com.how2java.tmall.web;\n \nimport com.how2java.tmall.pojo.Category;\nimport com.how2java.tmall.service.CategoryService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n \nimport java.util.List;\n  \n@RestController\npublic class CategoryController {\n    @Autowired CategoryService categoryService;\n     \n    @GetMapping(\"/categories\")\n    public List&lt;Category&gt; list() throws Exception {\n        return categoryService.list();\n    }\n}</code></pre> \n<h3>6、启动类</h3> \n<p>启动类，代替自动生成的 TmallSpringbootApplication.java</p> \n<pre><code>package com.how2java.tmall;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);    \n    }\n}</code></pre> \n<h3>7、跨域配置类</h3> \n<p>CORSConfiguration.java<br>配置类，用于允许所有的请求都跨域。<br>因为是二次请求，第一次是获取 html 页面， 第二次通过 html 页面上的 js 代码异步获取数据，一旦部署到服务器就容易面临跨域请求问题，所以允许所有访问都跨域，就不会出现通过 ajax 获取数据获取不到的问题了。</p> \n<pre><code>package com.how2java.tmall.config;\n \nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n \n@Configuration\npublic class CORSConfiguration extends WebMvcConfigurerAdapter{\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        //所有请求都允许跨域\n        registry.addMapping(\"/**\")\n                .allowedOrigins(\"*\")\n                .allowedMethods(\"*\")\n                .allowedHeaders(\"*\");\n    }\n}</code></pre> \n<h3>8、异常处理类</h3> \n<p>GloabalExceptionHandler.java<br>异常处理，主要是在处理删除父类信息的时候，因为外键约束的存在，而导致违反约束。</p> \n<pre><code>package com.how2java.tmall.exception;\n \nimport javax.servlet.http.HttpServletRequest;\n \nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestController;\n \n@RestController\n@ControllerAdvice\npublic class GloabalExceptionHandler {\n    @ExceptionHandler(value = Exception.class)\n    public String defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {\n        e.printStackTrace();\n        Class constraintViolationException = Class.forName(\"org.hibernate.exception.ConstraintViolationException\");\n        if(null!=e.getCause()  &amp;&amp; constraintViolationException==e.getCause().getClass()) {\n            return \"违反了约束，多半是外键约束\";\n        }\n        return e.getMessage();\n    }\n \n}</code></pre> \n<h3>9、springboot配置文件</h3> \n<p><code>application.properties </code><br>springboot 配置文件，有些项目会用 application.yml ，站长习惯用 .properties ，觉得更易读。</p> \n<p>下面是配置文件的内容：</p> \n<pre><code>spring.datasource.url=jdbc:mysql://127.0.0.1:3306/tmall_springboot?characterEncoding=UTF-8\nspring.datasource.username=root\nspring.datasource.password=admin\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.hibernate.ddl-auto = none</code></pre> \n<p>分别是数据库访问地址，账号密码，驱动以及表结构自动生成策略(none)。</p> \n<pre><code>spring.thymeleaf.mode=LEGACYHTML5\nspring.thymeleaf.encoding=UTF-8\nspring.thymeleaf.content-type=text/html\nspring.thymeleaf.cache=false</code></pre> \n<p>使用 thymeleaf 作为视图，这个是springboot 官方推荐视图，<code>它的好处是可以是纯 html</code> 。<br>其中LEGACYHTML5表示经典html5模式，即允许非严格的html出现，元素少点什么也可以编译通过， 这个比较符合大家的编写习惯，太过严格的html，写起来累。 <br>cache=false 表示不要缓存，以免在开发过程中因为停留在缓存而给开发人员带来困扰。</p> \n<pre><code>server.context-path=/tmall_springboot</code></pre> \n<p>上下文地址为 tmall_springboot, 所以访问的时候，都要加上这个，比如：</p> \n<pre><code>http://127.0.0.1:8080/tmall_springboot/admin</code></pre> \n<pre><code>spring.http.multipart.maxFileSize=100Mb\nspring.http.multipart.maxRequestSize=100Mb</code></pre> \n<p>设置上传文件大小，默认只有1 m</p> \n<pre><code>spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</code></pre> \n<p>jpa对实体类的默认字段会把驼峰命名的属性，转换为字段名的时候自动加上下划线。 这个配置的作用就是去掉下划线<br>比如属性名称是 createDate, jpa 默认转换为字段名 create_Date。 有了这个配置之后，就会转换为同名字段 createDate</p> \n<pre><code>spring.jpa.show-sql=true</code></pre> \n<p>显示 hibernate 执行的sql语句。 这个在上线之后，应该是关掉的，因为大量的 控制台输出会严重影响系统性能。 但是呢，因为本项目会和 redis 和 es 整合，打印 sql 语句的目的是为了观察 缓存是否起效果。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022290852\" src=\"http://localhost:8060/tup/2020/4/23/c09b6e5bfdaf461da00493f8920401e3.jpg\" alt=\"file\" title=\"file\"></span></p> \n<pre><code>#database\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/tmall_springboot?characterEncoding=UTF-8\nspring.datasource.username=root\nspring.datasource.password=admin\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.hibernate.ddl-auto = none\n \n#thymeleaf\nspring.thymeleaf.mode=LEGACYHTML5\nspring.thymeleaf.encoding=UTF-8\nspring.thymeleaf.content-type=text/html\nspring.thymeleaf.cache=false\n \n#context\nserver.context-path=/tmall_springboot\n \n#设置上传文件大小，默认只有1 m\nspring.http.multipart.maxFileSize=100Mb\nspring.http.multipart.maxRequestSize=100Mb\n \nspring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl\n \n#显示 hibernate运行的 sql 语句\nspring.jpa.show-sql=true</code></pre> \n<h2>四、静态资源</h2> \n<p>接下来是各种静态资源，诸如jquery, bootstrap, css, 图片，公用 html 等，内容稍杂，就不挨个列出来了。</p> \n<ol> \n <li>css,img,js目录是样式，图片脚本等文件</li> \n <li>include/admin目录下是4个HTML 包含关系中讲解到的被包含文件</li> \n</ol> \n<p>静态资源路径：tmall_springboot/src/main/webapp/</p> \n<p>注： 如果目录不存在，比如 webapp目录， templates 目录不存在，请自行创建。<br>注： 静态资源为什么不放在 static 目录下？ 一般说来，在约定里，springboot 的静态资源会在 static 目录下，但是我们是放在 webapp 目录下，为什么会这样呢？ 因为我们还要做上传图片的功能，如果是放在 static 下，上传后的图片就无法被访问，还是放在 webapp 下，上传后，能够立即被访问。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022300723\" src=\"http://localhost:8060/tup/2020/4/23/e39c4ac57e2146ca9488d0168145beca.jpg\" alt=\"file\" title=\"file\"></span></p> \n<h2>五、前端Vue交互</h2> \n<p>listCategory.html </p> \n<p>接着在 templates 下面新建 admin目录，然后新建 listCategory.html 文件。<br>listCategory.html 看着复杂，其实没那么复杂，它其实就了两件事： 获取数据 和 展示数据</p> \n<h3>1. 获取数据</h3> \n<pre><code>$(function(){\n}</code></pre> \n<p>这个是jquery的代码，表示当整个html加载好了之后执行</p> \n<pre><code>var data4Vue = {\n    uri:\'categories\',\n    beans: []\n};</code></pre> \n<p>vue用到的数据， uri表示访问哪个地址去获取数据，这里的值是 categories，和 CategoryController.java 相呼应</p> \n<pre><code>var vue = new Vue({\n   el: \'#workingArea\',\n   data: data4Vue,</code></pre> \n<p>创建Vue对象，el 表示和本页面的 <code>&lt;div id=\"workingArea\" &gt;</code> 元素绑定，data 表示vue 使用上面的data4Vue对象。</p> \n<pre><code>mounted:function(){\n   this.list();\n},</code></pre> \n<p>加载Vue对象成功之后会调用，成功的时候去调用 list() 函数。</p> \n<pre><code>methods: {\n    list:function(){\n        var url =  this.uri;\n        axios.get(url).then(function(response) {\n            vue.beans = response.data;\n        });\n    }\n}</code></pre> \n<p>list 函数使用 data4Vue里的 uri作为地址，然后调用 axios.js 这个 ajax库，进行异步调用。 调用成功之后，把服务端返回的数据，保存在 vue.beans 上。</p> \n<h3>2. 展示数据</h3> \n<pre><code>&lt;tr v-for=\"bean in beans \"&gt;</code></pre> \n<p>使用 v-for进行遍历， 这个 beans 就表示data4Vue里面的beans属性。</p> \n<pre><code>&lt;td&gt;{{bean.id}}&lt;/td&gt;</code></pre> \n<p>bean就是遍历出来的每个id, 这里就是输出每个分类的id.</p> \n<pre><code>&lt;a :href=\"\'admin_property_list?cid=\' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-th-list\"&gt;&lt;/span&gt;&lt;/a&gt;</code></pre> \n<p>在超链里的href里拼接分类id.</p> \n<p>页面HTML路径：<code>tmall_springboot/src/main/resources/templates/admin/</code></p> \n<p>listCategory.html 页面完整代码：</p> \n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n \n    &lt;head th:include=\"include/admin/adminHeader::html(\'分类管理\')\" &gt;&lt;/head&gt;\n    &lt;body&gt;\n        &lt;div th:replace=\"include/admin/adminNavigator::html\" &gt;&lt;/div&gt;\n        &lt;script&gt;\n            $(function(){\n                var data4Vue = {\n                        uri:\'categories\',\n                        beans: []\n                };\n \n                //ViewModel\n                var vue = new Vue({\n                    el: \'#workingArea\',\n                    data: data4Vue,\n                    mounted:function(){ //mounted　表示这个 Vue 对象加载成功了\n                        this.list();\n                    },\n                    methods: {\n                        list:function(){\n                            var url =  this.uri;\n                            axios.get(url).then(function(response) {\n                                vue.beans = response.data;\n                            });\n                        }\n                    }\n                });\n            });\n \n        &lt;/script&gt;\n        &lt;div id=\"workingArea\" &gt;\n            &lt;h1 class=\"label label-info\" &gt;分类管理&lt;/h1&gt;\n            &lt;br&gt;\n            &lt;br&gt;\n            &lt;div class=\"listDataTableDiv\"&gt;\n                &lt;table class=\"table table-striped table-bordered table-hover  table-condensed\"&gt;\n                    &lt;thead&gt;\n                    &lt;tr class=\"success\"&gt;\n                        &lt;th&gt;ID&lt;/th&gt;\n                        &lt;th&gt;图片&lt;/th&gt;\n                        &lt;th&gt;分类名称&lt;/th&gt;\n                        &lt;th&gt;属性管理&lt;/th&gt;\n                        &lt;th&gt;产品管理&lt;/th&gt;\n                        &lt;th&gt;编辑&lt;/th&gt;\n                        &lt;th&gt;删除&lt;/th&gt;\n                    &lt;/tr&gt;\n                    &lt;/thead&gt;\n                    &lt;tbody&gt;\n                        &lt;tr v-for=\"bean in beans \"&gt;\n                            &lt;td&gt;{{bean.id}}&lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;img height=\"40px\"  :src=\"\'img/category/\'+bean.id+\'.jpg\'\"&gt;\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                {{bean.name}}\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;a :href=\"\'admin_property_list?cid=\' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-th-list\"&gt;&lt;/span&gt;&lt;/a&gt;\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;a :href=\"\'admin_product_list?cid=\' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-shopping-cart\"&gt;&lt;/span&gt;&lt;/a&gt;\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;a :href=\"\'admin_category_edit?id=\' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-edit\"&gt;&lt;/span&gt;&lt;/a&gt;\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;a href=\"#nowhere\"  @click=\"deleteBean(bean.id)\"&gt;&lt;span class=\"   glyphicon glyphicon-trash\"&gt;&lt;/span&gt;&lt;/a&gt;\n                            &lt;/td&gt;\n                        &lt;/tr&gt;\n                    &lt;/tbody&gt;\n                &lt;/table&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div th:replace=\"include/admin/adminFooter::html\" &gt;&lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre> \n<h2>六、思路图</h2> \n<ol> \n <li>首先浏览器上访问路径 /admin</li> \n <li>这个路径被 AdminPageController 的admin方法匹配，然后客户端跳转到 admin_category_list</li> \n <li>admin_category_list 被 AdminPageController 的 listCategory 方法匹配，服务端跳转到 admin/listCategory.html</li> \n <li>listCategory.html 这个html页面通过http协议传输到浏览器端</li> \n <li>浏览器根据html 上的js代码，异步调用 categories 这个地址。 CategoryController 获取捕捉到这个请求，到数据库里查出所有的分类数据，并转换为 json数组返回给浏览器。</li> \n <li>浏览器根据这个json数组，通过 vue 的v-for 方式把其遍历到 多个 tr 元素上，用户就看到了表格里的多条数据了。</li> \n</ol> \n<h2>七、项目源代码</h2> \n<p>本项目源代码托管在GitHub上，地址：<a href=\"https://github.com/corwien/tmall_springboot/\" rel=\"nofollow noreferrer\">https://github.com/corwien/tmall_springboot/</a></p> \n<hr> \n<p>Java学习资源推荐：<br><a href=\"https://how2j.cn?p=126405\" rel=\"nofollow noreferrer\">Java 最强学习站 https://how2j.cn?p=126405</a></p>', null, 'http://localhost:8060/tup/2020/4/23/1b1382c25bbc48b98ba96961ebd0d110.jpg', 'f53014d680884163a5bd5ce762e90cdf', '04547238127a4676b504cc4496865d7b', '404982af52c7437280759bb9156099eb,2294832fe5104d73ace4f14ad9549018,1d36446f3db84f4c836556d1513c37f0,ec3409e632664448918190c226301c4b,b350d9c92c524bb4b9feedd40e5eebcd', '0', '3', '1', '2020-04-23 10:58:48', '2020-04-23 10:58:48');
INSERT INTO `tb_recommend` VALUES ('f7ff07b90141499daa5294c85517e1cc', '美国联邦贸易委员会提出 AI 发展建议：不要给消费者带来惊喜', '美国联邦贸易委员会（FTC）下属的消费者保护局局长安德鲁-史密斯（Andrew Smith）本周发布了一篇文章，名为《使用人工智能和算法》。该文章旨在对正在开发和使用消费级人工智能的企业提供一些帮助。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFY5A\" src=\"http://localhost:8060/tup/2020/4/23/6fe2d684ef40410ba54877f73137dfce.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>美国联邦贸易委员会（FTC）下属的消费者保护局局长安德鲁-史密斯（Andrew Smith）本周发布了一篇文章，名为《使用人工智能和算法》。该文章旨在对正在开发和使用消费级人工智能的企业提供一些帮助。</p> \n<p>文章中的经验主要来自于 FTC 过去的执法行动、行业报告以及研讨会，其中一个最重要的信息就是建议企业在开发和使用人工智能时，不要让消费者或者他们自身感到惊讶。</p> \n<hr> \n<p>谨慎对待人工智能，除了有助于避免 FTC 的审查之外，还能带来一些好处。比如还可以帮助避免与消费者和商业伙伴的关系受损。此次 FTC 在文中提出的建议主要分为四大类：</p> \n<ol> \n <li>要透明。</li> \n <li>向消费者解释你的决定；</li> \n <li>确保你的决定是公平的；</li> \n <li>确保你的数据和模型是稳健的、经验性的。</li> \n</ol> \n<p>尽管其中许多信息涉及到 FTC 执行的特定行业法律，如《公平信用报告法》（FCRA）和《平等信用机会法》（ECOA）等，但其实很多建议具有更广泛的适用性。</p> \n<h2>担起企业的责任</h2> \n<p>诸如 FCRA、ECOA 和 1964 年《民权法》第七章等行之已久的法律，他们分别适用于消费者报告、消费信贷、投票、教育和提供公共场所等领域的人工智能使用。要履行这些法律的义务，有赖于承认这些法律是否以及何时适用。</p> \n<p>然而，FTC 的文章中讨论的法律远非详尽无遗。在文章中提到的法律之外，还有一条重要的法律需要补充 —— 健康保险便利和责任法案（HIPAA）。</p> \n<p>该法案制定了一系列安全标准，就保健计划、供应商以及结算中心如何以电子文件的形式来传送、访问和存储受保护的健康信息做出详细的规定。法案规定在确保私密性的情况下保存病人信息档案六年，还详细规定了医疗机构处理病人信息规范，以及违法保密原则、通过电子邮件或未授权的网络注销病人档案的处罚方案。</p> \n<p>虽然通常情况下，当一个企业作为医疗服务提供者、保险人或信息交换中心时，通常是很清楚的，但要确定公司何时成为受保实体的「商业伙伴」可能更具挑战性。</p> \n<p>此次新冠疫情的影响加速了和医疗健康相关的 AI 产业发展，而这些企业在寻求技术突破的同事，更需要了解企业应该担负的责任。</p> \n<h2>全面评估数据和 AI 模型</h2> \n<p>根据文章所述，FTC 已经制定了评估 AI 系统是否存在非法歧视的法律和经济标准。</p> \n<p>具体来说，该机构将查看输入的信息，以确定它们是否包括「基于种族的因素，或此类因素的替代信息」。</p> \n<p>文章中表达了一个强烈的观点，就是 FTC 对通过使用 AI 可能产生的歧视的关注度相当高。\"使用人工智能和算法工具的公司应该考虑是否应该对人工智能结果进行自我测试，以管理这类模型所固有的消费者保护风险\"。</p> \n<p>然而，FTC 并没有为这些评估提供一个框架，也没有更笼统地指出哪些类型的 AI 歧视风险可以被采取行动。尽管如此，企业仍需善意地努力识别和降低此类风险。</p> \n<h2>对供应商进行尽职调查，约束下游用户</h2> \n<p>FTC 的 AI 指南中贯穿着另一个主题：公司应仔细评估 AI 相关数据和分析的上游供应商如何遵守其法律义务，并对其进行适当的约束，以防止自己的客户以不适当或非法的方式使用 AI 服务。</p> \n<p>虽然 FTC 重点关注 FCRA 和 ECOA 下的上游和下游要求，但远离更多的高监管活动才是其意图。</p> \n<p>在签订人工智能相关业务关系之前进行尽职调查，要求在合同条款中写明人工智能系统和数据输入的允许用途，以及监督业务合作伙伴的表现，都是实现这些目的的关键。</p> \n<hr> \n<p>FTC 在监督人工智能在经济领域的使用方面的作用还处于起步阶段，并将继续发展。但不管怎么说，该机构此次发布的文章，对于随着科技发展而新兴的法律和企业对自我监管的思考，都提供了一个有用的资源。</p> \n<blockquote>\n 参考资料：\n <br>\n <a href=\"https://www.adlawaccess.com/2020/04/articles/ftc-guidance-on-ai-dont-surprise-consumers-or-yourself/\" rel=\"nofollow noreferrer\">AD LAW ACCESS</a>\n <br>维基百科：\n <a href=\"https://zh.wikipedia.org/wiki/%E5%81%A5%E5%BA%B7%E4%BF%9D%E9%99%A9%E4%BE%BF%E5%88%A9%E5%92%8C%E8%B4%A3%E4%BB%BB%E6%B3%95%E6%A1%88\" rel=\"nofollow noreferrer\">健康保险便利和责任法案</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyR0\" src=\"http://localhost:8060/tup/2020/4/23/247183ca5442432badb36687f59191c6.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/becb089e3077436faefd28032b6b5c7b.jpg', '1894b118d35d44cb8fe8009529c4154b', 'cbad2058b4014634aec6515f4adbef0d', '2a09bf1afefd4d659606f43445741ee3,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-23 10:55:47', '2020-04-23 10:55:47');
INSERT INTO `tb_recommend` VALUES ('fbf9a1b95151441d87a9790df21f3eac', '烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战', '层叠拼图Plus是一款需要空间想象力和逻辑推理能力完美结合的微信小游戏，偶消奇不消，在简单的游戏规则下却有着无数种可能性，需要你充分发挥想象力去探索，看似简单却具有极大的挑战性和趣味性，这就是其魅力所...', '<blockquote>\n 启逻辑之高妙，因想象而自由\n</blockquote> \n<p><strong>层叠拼图Plus</strong>是一款需要空间想象力和逻辑推理能力完美结合的微信小游戏，偶消奇不消，在简单的游戏规则下却有着无数种可能性，需要你充分发挥想象力去探索，看似简单却具有极大的挑战性和趣味性，这就是其魅力所在！温馨提示，体验后再阅读此文体验更佳哦！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268626?w=258&amp;h=258\" src=\"http://localhost:8060/tup/2020/4/23/0ae5a6ce14b84308933cecdf200a511d.jpg\" alt=\"\" title=\"\"></span></p> \n<p>预览：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020280148\" src=\"http://localhost:8060/tup/2020/4/23/6bccd759211848388047fbe4738973d7.jpg\" alt=\"\" title=\"\"></span></p> \n<blockquote>\n Talk is cheap. Show me the code\n</blockquote> \n<p><strong>层叠拼图Plus</strong>微信小游戏采用<code>js</code>+<code>canvas</code>实现，没有使用任何游戏引擎，对于初学者来说，也比较容易入门。接下来，我将通过以下几个点循序渐进的讲解<strong>层叠拼图Plus</strong>微信小游戏的实现。</p> \n<ul> \n <li><strong>如何解决Canvas绘图模糊？</strong></li> \n <li><strong>如何绘制任意多边形图形？</strong></li> \n <li><strong>1 + 1 = 0，「偶消奇不消」的效果如何实现？</strong></li> \n <li><strong>如何判断一个点是否在任意多边形内部 ？</strong></li> \n <li><strong>如何判断游戏结果是否正确？</strong></li> \n <li><strong>排行榜的展示</strong></li> \n <li><strong>游戏性能优化</strong></li> \n</ul> \n<h2>如何解决Canvas绘图模糊？</h2> \n<blockquote>\n canvas 绘图时，会从两个物理像素的中间位置开始绘制并向两边扩散 0.5 个物理像素。当设备像素比为 1 时，一个 1px 的线条实际上占据了两个物理像素（每个像素实际上只占一半），由于不存在 0.5 个像素，所以这两个像素本来不应该被绘制的部分也被绘制了，于是 1 物理像素的线条变成了 2 物理像素，视觉上就造成了模糊\n</blockquote> \n<p>绘图模糊的原因知道了，在微信小游戏里面又该如何解决呢？</p> \n<pre><code class=\"javascript\">const ratio = wx.getSystemInfoSync().pixelRatio\nlet ctx = canvas.getContext(\'2d\')\ncanvas.width = screenWidth * ratio\ncanvas.height = screenHeight * ratio\n\nctx.fillStyle = \'black\'\nctx.font = `${18 * ratio}px Arial`\nctx.fillText(\'我是清晰的文字\', x * ratio, y * ratio)\n\nctx.fillStyle = \'red\'\nctx.fillRect(x * ratio, y * ratio, width * ratio, height * ratio)</code></pre> \n<p>可以看到，我们先通过 <code>wx.getSystemInfoSync().pixelRatio</code> 获取设备的像素比<code>ratio</code>，然后将在屏 <code>Canvas</code> 的宽度和高度按照所获取的像素比<code>ratio</code>进行放大，在绘制文字、图片的时候，坐标点 <code>x</code>、<code>y</code> 和所要绘制图形的 <code>width</code>、<code>height</code>均需要按照像素比 <code>ratio</code> 进行缩放，这样我们就可以清晰的在高清屏中绘制想要的文字、图片。</p> \n<p>可参考微信官方 <a href=\"https://developers.weixin.qq.com/community/develop/doc/00040c9903023848e0d7bd6205a401?highLine=canvas%2520%25E6%25A8%25A1%25E7%25B3%258A\" rel=\"nofollow noreferrer\">缩放策略调整</a></p> \n<p><strong><em>另外，需要注意的是，这里的 <code>canvas</code> 是由 <a href=\"https://developers.weixin.qq.com/minigame/dev/guide/best-practice/adapter.html\" rel=\"nofollow noreferrer\">weapp-adapter</a> 预先调用 <code>wx.createCanvas()</code> 创建一个上屏 <code>Canvas</code>，并暴露为一个全局变量 <code>canvas</code>。</em></strong></p> \n<h2>如何绘制任意多边形图形？</h2> \n<blockquote>\n 任意一个多边形图形，是由多个平面坐标点所组成的图形区域。\n</blockquote> \n<p>在游戏画布内，我们以左上角为坐标原点 <code>{x: 0, y: 0}</code> ，一个多边形包含多个单位长度的平面坐标点，如：<code>[{ x: 1, y: 3 }, { x: 5, y: 3 }, { x: 3, y: 5 }]</code> 表示为一个三角形的区域，需要注意的是，<code>x</code>、<code>y</code> 并不是真实的平面坐标值，而是通过屏幕宽度计算出来的单位长度，在画布内的真实坐标值则为 <code>{x: x * itemWidth, y: y * itemWidth}</code> 。</p> \n<p>绘制多边形代码实现如下：</p> \n<pre><code class=\"javascript\">/**\n * 绘制多边形\n */\nexport default class Block {\n    constructor() { }\n    init(points, itemWidth, ctx) {\n        this.points = []\n        this.itemWidth = itemWidth // 单位长度\n        this.ctx = ctx\n        for (let i = 0; i &lt; points.length; i++) {\n            let point = points[i]\n            this.points.push({\n                x: point.x * this.itemWidth,\n                y: point.y * this.itemWidth\n            })\n        }\n    }\n\n    draw() {\n        this.ctx.globalCompositeOperation = \'xor\'\n        this.ctx.fillStyle = \'black\'\n        this.ctx.beginPath()\n        this.ctx.moveTo(this.points[0].x, this.points[0].y)\n        for (let i = 1; i &lt; this.points.length; i++) {\n            let point = this.points[i]\n            this.ctx.lineTo(point.x, point.y)\n        }\n        this.ctx.closePath()\n        this.ctx.fill()\n    }\n}</code></pre> \n<p>使用：</p> \n<pre><code class=\"javascript\">let points = [\n    [{ x: 4, y: 5 }, { x: 8, y: 9 }, { x: 4, y: 9 }],\n    [{ x: 10, y: 8 }, { x: 10, y: 12 }, { x: 6, y: 12 }],\n    [{ x: 7, y: 4 }, { x: 11, y: 4 }, { x: 11, y: 8 }]\n]\npoints.map((sub_points) =&gt; {\n    let block = new Block()\n    block.init(sub_points, this.itemWidth, this.ctx)\n    block.draw()\n})</code></pre> \n<p>效果如下图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268627?w=300&amp;h=301\" src=\"http://localhost:8060/tup/2020/4/23/da3971c88b8541ce8f18f28546d0d4d9.jpg\" alt=\"\" title=\"\"></span></p> \n<p><code>CanvasRenderingContext2D</code>其他使用方法可参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D\" rel=\"nofollow noreferrer\">CanvasRenderingContext2D API 列表</a></p> \n<h2>1 + 1 = 0，「偶消奇不消」的效果如何实现？</h2> \n<blockquote>\n 1 + 1 = 0，是\n <strong>层叠拼图Plus</strong>小游戏玩法的精髓所在。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268628?w=300&amp;h=306\" src=\"http://localhost:8060/tup/2020/4/23/9ba6d2c092a04d2ea0177b396492af7f.jpg\" alt=\"\" title=\"\"></span></p> \n<p>有经验的同学，也许一眼就发现了，<code>1 + 1 = 0</code> 刚好符合通过 <code>异或运算</code> 得出的结果。当然，细心的同学也可能已经发现，在 <code>如何绘制任意多边形图形</code> 这一章节内，有一句特殊的代码：<code>this.ctx.globalCompositeOperation = \'xor\'</code>，也正是通过设置 <code>CanvasContext</code> 的 <code>globalCompositeOperation</code> 属性值为 <code>xor</code> 便实现了「偶消奇不消」的神奇效果。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268629?w=1526&amp;h=522\" src=\"http://localhost:8060/tup/2020/4/23/c8accb886a934de2b896b4033bb0e8bd.jpg\" alt=\"globalCompositeOperation\" title=\"globalCompositeOperation\"></span></p> \n<p><code>globalCompositeOperation</code> 是指 <code>在绘制新形状时应用的合成操作的类型</code>，其他效果可参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\" rel=\"nofollow noreferrer\">globalCompositeOperation 示例</a></p> \n<h2>如何判断一个点是否在任意多边形内部？</h2> \n<blockquote>\n 当回转数为 0 时，点在闭合曲线外部。\n</blockquote> \n<p>讲到这里，我们已经知道如何在<code>Canvas</code>画布内绘制出偶消奇不消效果的层叠图形了，接下来我们来看下玩家如何移动选中的图形。我们发现绘制出的图形对象并没有提供点击事件绑定之类的操作，那又如何判断玩家选中了哪个图形呢？这里我们就需要去实现如何判断玩家触摸事件的<code>x</code>，<code>y</code>坐标在哪个多边形图形内部区域，从而判断出玩家选中的是哪一个多边形图形。</p> \n<p>判断一个点是否在任意多边形内部有多种方法，比如：</p> \n<ul> \n <li>射线法</li> \n <li>面积判别法</li> \n <li>叉乘判别法</li> \n <li>回转数法</li> \n <li>...</li> \n</ul> \n<p>在<strong>层叠拼图Plus</strong>小游戏内，采用的是 <code>回转数</code> 法来判断玩家触摸点是否在多边形内部。<code>回转数</code> 是拓扑学中的一个基本概念，具有很重要的性质和用途。当然，展开讨论 <code>回转数</code> 的概念并不在该文的讨论范围内，我们仅需了解一个概念：<strong>当回转数为 0 时，点在闭合曲线外部。</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268631?w=300&amp;h=244\" src=\"http://localhost:8060/tup/2020/4/23/6776e3f614f245dd99acb117932fa418.jpg\" alt=\"\" title=\"\"></span></p> \n<p>上面面这张图动态演示了回转数的概念：图中红色曲线关于点（人所在位置）的回转数为 <code>2</code>。</p> \n<p>对于给定的点和多边形，回转数应该怎么计算呢？</p> \n<ul>\n <li>用线段分别连接点和多边形的全部顶点</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268632?w=500&amp;h=360\" src=\"http://localhost:8060/tup/2020/4/23/404eb3ac46cb4ba1a76c246f1807288c.jpg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li>计算所有点与相邻顶点连线的夹角</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268633?w=500&amp;h=360\" src=\"http://localhost:8060/tup/2020/4/23/6b7f68eee51949369f02b5f85415c049.jpg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li>计算所有夹角和。注意每个夹角都是有方向的，所以有可能是负值</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268634?w=500&amp;h=360\" src=\"http://localhost:8060/tup/2020/4/23/8e763577e40a41edbf3b4e45d5c2df88.jpg\" alt=\"\" title=\"\"></span></p> \n<p>最后根据角度累加值计算回转数。360°（2π）相当于一次回转。</p> \n<p>在使用 <code>JavaScript</code> 实现时，需要注意以下问题：</p> \n<ul> \n <li> <code>JavaScript</code> 的数只有 <code>64</code> 位双精度浮点这一种。对于三角函数产生的无理数，浮点数计算不可避免会造成一些误差，因此在最后计算回转数需要做取整操作。</li> \n <li>通常情况下，平面直角坐标系内一个角的取值范围是 -π 到 π 这个区间，这也是 <code>JavaScript</code> 三角函数 <code>Math.atan2()</code> 返回值的范围。但 <code>JavaScript</code> 并不能直接计算任意两条线的夹角，我们只能先计算两条线与 <code>x</code> 正轴夹角，再取两者差值。这个差值的结果就有可能超出 <code>-π</code> 到 <code>π</code> 这个区间，因此我们还需要处理差值超出取值区间的情况。</li> \n</ul> \n<p>代码实现：</p> \n<pre><code class=\"javascript\">/**\n * 判断点是否在多边形内/边上\n */\nisPointInPolygon(p, poly) {\n    let px = p.x,\n        py = p.y,\n        sum = 0\n\n    for (let i = 0, l = poly.length, j = l - 1; i &lt; l; j = i, i++) {\n        let sx = poly[i].x,\n            sy = poly[i].y,\n            tx = poly[j].x,\n            ty = poly[j].y\n\n        // 点与多边形顶点重合或在多边形的边上\n        if ((sx - px) * (px - tx) &gt;= 0 &amp;&amp;\n            (sy - py) * (py - ty) &gt;= 0 &amp;&amp;\n            (px - sx) * (ty - sy) === (py - sy) * (tx - sx)) {\n            return true\n        }\n\n        // 点与相邻顶点连线的夹角\n        let angle = Math.atan2(sy - py, sx - px) - Math.atan2(ty - py, tx - px)\n\n        // 确保夹角不超出取值范围（-π 到 π）\n        if (angle &gt;= Math.PI) {\n            angle = angle - Math.PI * 2\n        } else if (angle &lt;= -Math.PI) {\n            angle = angle + Math.PI * 2\n        }\n        sum += angle\n    }\n\n    // 计算回转数并判断点和多边形的几何关系\n    return Math.round(sum / Math.PI) === 0 ? false : true\n}</code></pre> \n<p><em>注：该章节内容图片均来自网络，如有侵权，请告知删除。另外有兴趣的同学可以使用其他方法来实现判断一个点是否在任意多边形内部。</em></p> \n<h2>如何判断游戏结果是否正确？</h2> \n<blockquote>\n 探索的过程固然精彩，而结果却更令我们期待\n</blockquote> \n<p>通过前面的介绍我们可以知道，判断游戏结果是否正确其实就是比对玩家组合图形的 <code>xor</code> 结果与目标图形的 <code>xor</code> 结果。那么如何求多个多边形 <code>xor</code> 的结果呢？ <a href=\"https://github.com/mfogel/polygon-clipping\" rel=\"nofollow noreferrer\">polygon-clipping</a> 正是为此而生的。它不仅支持 <code>xor</code> 操作，还有其他的比如：<code>union</code>, <code>intersection</code>, <code>difference</code> 等操作。<br>在<strong>层叠拼图Plus</strong>游戏内通过 <a href=\"https://github.com/mfogel/polygon-clipping\" rel=\"nofollow noreferrer\">polygon-clipping</a> 又是怎样实现游戏结果判断的呢？</p> \n<ul>\n <li>目标图形</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268635?w=300&amp;h=288\" src=\"http://localhost:8060/tup/2020/4/23/a8839789b056439d801474f7ef73c247.jpg\" alt=\"\" title=\"\"></span></p> \n<p>多边形平面坐标点集合：</p> \n<pre><code class=\"javascript\">points = [\n    [{ x: 6, y: 6 }, { x: 10, y: 6 }, { x: 10, y: 10 }, { x: 6, y: 10 }],\n    [{ x: 8, y: 6 }, { x: 10, y: 8 }, { x: 8, y: 10 }, { x: 6, y: 8 }]\n]</code></pre> \n<pre><code class=\"javascript\">/**\n * 获取 多个多边形 xor 结果\n */\nconst polygonClipping = require(\'polygon-clipping\')\n\npolygonXor(points) {\n    let poly = []\n    points.forEach(function (sub_points) {\n        let temp = []\n        sub_points.forEach(function (point) {\n            temp.push([point.x, point.y])\n        })\n        poly.push([temp])\n    })\n\n    let results = polygonClipping.xor(...poly)\n\n    // 找出左上角的点\n    let min_x = 100, min_y = 100\n    results.forEach(function (sub_results) {\n        sub_results.forEach(function (temps) {\n            temps.forEach(function (point) {\n                if (point[0] &lt; min_x) min_x = point[0]\n                if (point[1] &lt; min_y) min_y = point[1]\n            })\n        })\n    })\n\n    // 以左上角为参考点 多边形平移至 原点 {x: 0, y: 0}\n    results.forEach(function (sub_results) {\n        sub_results.forEach(function (temps) {\n            temps.forEach(function (point) {\n                point[0] -= min_x\n                point[1] -= min_y\n            })\n        })\n    })\n}</code></pre> \n<pre><code class=\"javascript\">let result = this.polygonXor(points)</code></pre> \n<p><code>xor</code>结果：</p> \n<pre><code class=\"javascript\">[\n    [[[0, 0], [2, 0], [0, 2], [0, 0]]],\n    [[[0, 2], [2, 4], [0, 4], [0, 2]]],\n    [[[2, 0], [4, 0], [4, 2], [2, 0]]],\n    [[[2, 4], [4, 2], [4, 4], [2, 4]]]\n]</code></pre> \n<p>同理计算出玩家操作图形的<code>xor</code>结果进行比对即可得出答案正确与否。</p> \n<p><strong><em>需要注意的是，获取玩家的 <code>xor</code> 结果并不能直接拿来与目标图形<code>xor</code> 结果进行比较，我们需要将<code>xor</code> 的结果以左上角为参考点将图形平移至原点内，然后再进行比较，如果结果一致，则代表玩家答案正确。</em></strong></p> \n<h2>排行榜的展示</h2> \n<blockquote>\n 有人的地方就有江湖，有江湖的地方就有排行\n</blockquote> \n<p>在看本章节内容之前，建议先浏览一遍排行榜相关的官方文档：<a href=\"https://developers.weixin.qq.com/minigame/dev/guide/open-ability/ranklist.html\" rel=\"nofollow noreferrer\">好友排行榜</a>、<a href=\"https://developers.weixin.qq.com/minigame/dev/guide/open-ability/open-data.html\" rel=\"nofollow noreferrer\">关系链数据</a>，以便对相关内容有个大概的了解。</p> \n<ul>\n <li>开放数据域</li>\n</ul> \n<p><code>开放数据域</code>是一个封闭、独立的 <code>JavaScript</code> 作用域。要让代码运行在开放数据域，需要在 <code>game.json</code> 中添加配置项 <code>openDataContext</code> 指定开放数据域的代码目录。添加该配置项表示小游戏启用了开放数据域，这将会导致一些限制。</p> \n<pre><code class=\"javascript\">// game.json\n{\n  \"openDataContext\": \"src/myOpenDataContext\"\n}</code></pre> \n<ul> \n <li>在游戏内使用 <code>wx.setUserCloudStorage(obj)</code> 对玩家游戏数据进行托管。</li> \n <li>在开放数据域内使用 <code>wx.getFriendCloudStorage(obj)</code>拉取当前用户所有同玩好友的托管数据</li> \n <li>展示关系链数据</li> \n</ul> \n<p>如果想要展示通过关系链 <code>API</code> 获取到的用户数据，如绘制排行榜等业务场景，需要将排行榜绘制到 <code>sharedCanvas</code> 上，再在主域将 <code>sharedCanvas</code> 渲染上屏。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268636?w=620&amp;h=460\" src=\"http://localhost:8060/tup/2020/4/23/c452b96804d6412ca4550ccb08dc4fab.jpg\" alt=\"\" title=\"\"></span></p> \n<pre><code class=\"javascript\">// src/myOpenDataContext/index.js\nlet sharedCanvas = wx.getSharedCanvas()\n\nfunction drawRankList (data) {\n  data.forEach((item, index) =&gt; {\n    // ...\n  })\n}\n\nwx.getFriendCloudStorage({\n  success: res =&gt; {\n    let data = res.data\n    drawRankList(data)\n  }\n})</code></pre> \n<p><code>sharedCanvas</code> 是主域和开放数据域都可以访问的一个离屏画布。在开放数据域调用 <code>wx.getSharedCanvas()</code> 将返回 <code>sharedCanvas</code>。</p> \n<pre><code class=\"javascript\">// src/myOpenDataContext/index.js\nlet sharedCanvas = wx.getSharedCanvas()\nlet context = sharedCanvas.getContext(\'2d\')\ncontext.fillStyle = \'red\'\ncontext.fillRect(0, 0, 100, 100)</code></pre> \n<p>在主域中可以通过开放数据域实例访问 <code>sharedCanvas</code>，通过 <code>drawImage()</code> 方法可以将 <code>sharedCanvas</code> 绘制到上屏画布。</p> \n<pre><code class=\"javascript\">// game.js\nlet openDataContext = wx.getOpenDataContext()\nlet sharedCanvas = openDataContext.canvas\n\nlet canvas = wx.createCanvas()\nlet context = canvas.getContext(\'2d\')\ncontext.drawImage(sharedCanvas, 0, 0)</code></pre> \n<p><code>sharedCanvas</code> 本质上也是一个离屏 <code>Canvas</code>，而重设 <code>Canvas</code> 的宽高会清空 <code>Canvas</code> 上的内容。所以要通知开放数据域去重绘 <code>sharedCanvas</code>。</p> \n<pre><code class=\"javascript\">// game.js\nopenDataContext.postMessage({\n  command: \'render\'\n})\n\n// src/myOpenDataContext/index.js\nopenDataContext.onMessage(data =&gt; {\n  if (data.command === \'render\') {\n    // 重绘 sharedCanvas\n  }\n})</code></pre> \n<p><strong><em>需要注意的是：<code>sharedCanvas</code> 的宽高只能在主域设置，不能在开放数据域中设置。</em></strong></p> \n<h2>游戏性能优化</h2> \n<blockquote>\n 性能优化，简而言之，就是在不影响系统运行正确性的前提下，使之运行地更快，完成特定功能所需的时间更短。\n</blockquote> \n<p>一款能让人心情愉悦的游戏，性能问题必然不能成为绊脚石。那么可以从哪些方面对游戏进行性能优化呢？</p> \n<h3>离屏 <code>Canvas</code> </h3> \n<p>在<strong>层叠拼图Plus</strong>小游戏内，针对需要大量使用且绘图繁复的静态场景，都是使用离屏 <code>Canvas</code>进行绘制的，如首页网格背景、关卡列表、排名列表等。在微信内 <code>wx.createCanvas()</code> 首次调用创建的是显示在屏幕上的画布，之后调用创建的都是离屏画布。初始化时将静态场景绘制完备，需要时直接拷贝离屏<code>Canvas</code>的图像即可。<code>Canvas</code> 绘制本身就是不断的更新帧从而达到动画的效果，通过使用离屏 <code>Canvas</code>，就大大减少了一些静态内容在上屏<code>Canvas</code>的绘制，从而提升了绘制性能。</p> \n<pre><code class=\"javascript\">this.offScreenCanvas = wx.createCanvas()\nthis.offScreenCanvas.width = this.width * ratio\nthis.offScreenCanvas.height = this.height * ratio\n\nthis.ctx.drawImage(this.offScreenCanvas, x * ratio, y * ratio, this.offScreenCanvas.width, this.offScreenCanvas.height)</code></pre> \n<h3>内存优化</h3> \n<p>玩家在游戏过程中拖动方块的移动其实就是不断更新多边形图形的坐标信息，然后不断的清空画布再重新绘制，可以想象，这个绘制是非常频繁的，按照普通的做法就需要不断去创建多个新的 <code>Block</code> 对象。针对游戏中需要频繁更新的对象，我们可以通过使用<code>对象池</code>的方法进行优化，对象池维护一个装着空闲对象的池子，如果需要对象的时候，不是直接<code>new</code>，而是从对象池中取出，如果对象池中没有空闲对象，则新建一个空闲对象，<strong>层叠拼图Plus</strong>小游戏内使用的是官方<code>demo</code>内已经实现的<code>对象池</code>类，实现如下：</p> \n<pre><code class=\"javascript\">const __ = {\n  poolDic: Symbol(\'poolDic\')\n}\n\n/**\n * 简易的对象池实现\n * 用于对象的存贮和重复使用\n * 可以有效减少对象创建开销和避免频繁的垃圾回收\n * 提高游戏性能\n */\nexport default class Pool {\n  constructor() {\n    this[__.poolDic] = {}\n  }\n\n  /**\n   * 根据对象标识符\n   * 获取对应的对象池\n   */\n  getPoolBySign(name) {\n    return this[__.poolDic][name] || ( this[__.poolDic][name] = [] )\n  }\n\n  /**\n   * 根据传入的对象标识符，查询对象池\n   * 对象池为空创建新的类，否则从对象池中取\n   */\n  getItemByClass(name, className) {\n    let pool = this.getPoolBySign(name)\n\n    let result = (  pool.length\n                  ? pool.shift()\n                  : new className()  )\n\n    return result\n  }\n\n  /**\n   * 将对象回收到对象池\n   * 方便后续继续使用\n   */\n  recover(name, instance) {\n    this.getPoolBySign(name).push(instance)\n  }\n}</code></pre> \n<h3>垃圾回收</h3> \n<p>小游戏中，<code>JavaScript</code> 中的每一个 <code>Canvas</code> 或 <code>Image</code> 对象都会有一个客户端层的实际纹理储存，实际纹理储存中存放着 <code>Canvas</code>、<code>Image</code> 的真实纹理，通常会占用相当一部分内存。</p> \n<p>每个客户端实际纹理储存的回收时机依赖于 <code>JavaScript</code> 中的 <code>Canvas</code>、<code>Image</code> 对象回收。在 <code>JavaScript</code> 的 <code>Canvas</code>、<code>Image</code> 对象被回收之前，客户端对应的实际纹理储存不会被回收。通过调用 <code>wx.triggerGC()</code> 方法，可以加快触发 <code>JavaScriptCore Garbage Collection</code>（垃圾回收），从而触发 <code>JavaScript</code> 中没有引用的 <code>Canvas</code>、<code>Image</code> 回收，释放对应的实际纹理储存。</p> \n<p>但 <code>GC</code> 具体触发时机还要取决于 <code>JavaScriptCore</code> 自身机制，并不能保证调用 <code>wx.triggerGC()</code> 能马上触发回收，<strong>层叠拼图Plus</strong>小游戏在每局游戏开始或结束都会触发一下，及时回收内存垃圾，以保证最良好的游戏体验。</p> \n<h3>多线程 Worker</h3> \n<p>对于游戏来说，每帧 <code>16ms</code> 是极其宝贵的，如果有一些可以异步处理的任务，可以放置于 <code>Worker</code> 中运行，待运行结束后，再把结果返回到主线程。<code>Worker</code> 运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法，<code>Worker</code> 也不具备渲染的能力。 <code>Worker</code>与主线程之间的数据传输，双方使用 <code>Worker.postMessage()</code> 来发送数据，<code>Worker.onMessage()</code> 来接收数据，传输的数据并不是直接共享，而是被复制的。</p> \n<pre><code class=\"javascript\">// game.json\n{\n  \"workers\": \"workers\"\n}\n\n// 创建worker线程\nlet worker = worker = wx.createWorker(\'workers/request/index.js\') // 文件名指定 worker 的入口文件路径，绝对路径\n\n// 主线程向 Worker 发送消息\nworker.postMessage({\n  msg: \'hello worker\'\n})\n\n// 主线程监听 Worker 返回消息\nworker.onMessage(function (res) {\n  console.log(res)\n})</code></pre> \n<p><strong><em>需要注意的是：<code>Worker</code> 最大并发数量限制为 <code>1</code> 个，创建下一个前请用 <code>Worker.terminate()</code> 结束当前 <code>Worker</code></em></strong></p> \n<p>其他 <code>Worker</code> 相关的内容请参考微信官方文档：<a href=\"https://developers.weixin.qq.com/minigame/dev/guide/base-ability/worker.html\" rel=\"nofollow noreferrer\">多线程 Worker</a></p> \n<h2>结语</h2> \n<p>短短的一篇文章，定不能将<strong>层叠拼图Plus</strong>小游戏的前前后后讲明白讲透彻，加上文笔有限，有描述不当的地方还望多多海涵。其实最让人心累的还是软著的申请过程，由于各种原因前前后后花了将近三个月的时间，本来也想写一下软著申请相关的内容，最后发现篇幅有点长，无奈作罢，争取后面花点时间整理一下我这边的经验，希望可以帮助到需要的童鞋。</p> \n<p>由于项目结构以及代码还比较混乱，个人觉得，目前暂时还不适合开源。<strong><em>好在，小游戏内的所有核心代码以及游戏实现思想均已呈上</em></strong>，有兴趣的同学如果有相关方面的疑问也可以与我多多交流，大家互相学习，共同进步。</p> \n<p><strong>江湖不远，我们游戏里见！</strong></p>', null, 'http://localhost:8060/tup/2020/4/23/8297d3f91b024281b2a19c2a878e277d.jpg', '5ca4567d892841b087fac5246effac40', '1a7cc9fbc4654cb0afec84e080816ef1', '15941dc0af92453481b8a0626f963283,63c4e1e7ec204b43a62065a3ced4c2ce,9424c753324d4c6198c85fff4f681dd4,a1dff4d6d5dd4ee69cb3d44463606477', '0', '3', '1', '2020-04-23 10:57:47', '2020-04-23 10:57:47');
INSERT INTO `tb_recommend` VALUES ('fce399b2a38f45c28a912f8ef89d0017', 'IINA 播放器开发者称其开源项目，屡次被盗用上架并且收费获利', 'IINA，是一个基于 mpv、契合 macOS 设计风格、力求做到最佳用户体验、轻便且功能强大的视频播放器项目。IINA 以 mpv 为播放核心，所以享受到了 mpv 解码和图像方面的所有优点。IINA 使用了 libmpv 的 C API，来提...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022271502\" src=\"http://localhost:8060/tup/2020/4/23/6d04c4d1124f497e891786f43ddea742.jpg\" alt=\"Feature 1\" title=\"Feature 1\"></span></p> \n<p><a href=\"https://iina.io/\" rel=\"nofollow noreferrer\">IINA</a>，是一个基于 mpv、契合 macOS 设计风格、力求做到最佳用户体验、轻便且功能强大的视频播放器项目。IINA 以 mpv 为播放核心，所以享受到了 mpv 解码和图像方面的所有优点。IINA 使用了 libmpv 的 C API，来提供更加稳定快速的渲染和控制。此外，它使用原始屏幕分辨率渲染，所以比起其他一些播放器画质有显著提高。</p> \n<p>SegmentFault 思否消息：近期 IINA 播放器的开发者发文称，作为一个开源项目，屡次被盗用上架并且收费获利，确实是很无奈的事情，但是有的开发者被发现后主动下架，有的从不回应，现在貌似还有了理直气壮拒不承认的。</p> \n<p>开发者的态度是：作为开源项目，我们无意私藏这些东西，只要遵守许可证，对它进行再发布和出售也无妨；而这位开发者做的是：把所有贡献者的名字抹除掉换成了自己，并试图在这个基础上盈利。这是我无法忍受的。</p> \n<hr> \n<p><strong>针对这个情况，我们也咨询了我们思否合作的律师事务所君合的律师团队，以下是君合团队给出的反馈：</strong></p> \n<p>开源软件是一种开放软件授权使用限制的软件，开源软件的版权持有人通常授予他人自由使用、复制、散布、研究和改进软件的权利，但是其具体授权使用方式需按照相应开源许可证（“开源协议”或“许可证”）执行。一般每一个开源软件都会附有一个许可证，该许可证以格式文本形式的授权许可协议体现，许可证规定了软件使用者的权利和义务，使用者只有同意遵守这个许可证才可合法使用开源软件（或者使用该开源软件即视为同意接受该许可证）。</p> \n<p>我国法律目前对开源软件没有明确的、有针对性的具体规定，但是在法院审判实践中，法院在相关司法判例中引用了一些开源协议（如GPL协议、CC协议等），并认可开源协议在当事人（授权人、被授权人）之间的效力以及对当事人的约束力。</p> \n<p>以GPL协议为例，根据该协议第4条规定，传播未修改的完整源代码需要满足以下条件：（1）显著而适当地在每个副本上发布一个合适的版权声明；（2）附上陈述本协议和任何按照协议第7条加入的非许可的条款的全部、完整的声明；（3）附上全部、完整的免责申明；（4）随程序给所有的接受者（recipients）一份本协议。</p> \n<p>另根据GPL协议（3.0版本）第5条规定，用户可以以源代码的方式传播“基于GPL程序所开发的作品”或从GPL程序中取出一部分，对此部分进行修改而形成修改版，该传播行为必须首先符合第4条的规定（传播未修改的完整源代码的条件），并且符合以下所有条件：（1）作品应包含显著声明，说明用户修改了GPL程序，并指出修改了时间；（2）作品必须包含明确的声明，说明该作品在本协议下发布，并指出任何按照第6款（附加条款）加入的条件；（3）用户应根据本协议授权获取作品副本的使用者使用整个作品，本协议和任何按照第7款（附加条款）加入的条件一起，对整个作品及其所有部分发生法律效力，无论是以何种形式打包的作品；（4）如果作品中有用户界面，则应在界面中显示适当的法律声明；然而如果GPL程序存在用户界面，但该界面没有显示法律声明，则用户由此开发的作品没有必要修改该界面显示。</p> \n<p>因此，如果用户使用开源软件，需遵守开源协议的要求，如果使用者不遵守开源协议，其自由使用开源软件的许可可以被开源软件的著作权人终止，并且，开源软件的著作权人可以主张使用者使用开源软件的行为侵犯其软件著作权。</p> \n<p><strong>各位思否社区的开发者怎么看？欢迎在评论区留言。</strong></p> \n<hr> \n<p>以下是 IINA 播放器的开发者发布的原文：<strong>剽窃别人成果的人一直有，不过今天遇到了格外厉害的</strong></p> \n<p>我是<a href=\"https://github.com/iina/iina\" rel=\"nofollow noreferrer\">IINA</a>的开发者。一直以来 IINA 都面临一个小问题，就是有人用它的代码上架 Mac App Store （ MAS ）。IINA 使用的 GPLv3 许可证和 MAS 的协议是冲突的，这也是 IINA 至今都没有 MAS 版本的原因之一。</p> \n<p>这个问题一直存在。一直以来我的流程是向 MAS 提交 Dispute 。Apple 对这种事情的处理比较懒，会要求对方的开发者和我直接沟通。一小部分开发者可能会主动下架，但大部分都是选择沉默。对方的开发者在提醒两次都不回应的情况下，MAS 会将 App 强制下架，而这整个流程差不多要三个月（也就是对方开发者可以继续销售三个月）。</p> \n<p>这些操作我其实都习惯了（ Notes.app 里都放了一份模板来写 Dispute ）。我毕竟有自己的日常工作，让 Apple 来处理这种事情，虽然慢一点也是最好的选择。不过今天遇到的一位开发者非常厉害。我把他回复的原话复制上来：</p> \n<blockquote>\n 请问我哪里使用了，请告知，谢谢！\n</blockquote> \n<p>这款名叫 MPlayer X Pro 的 App 在港区售价 15 港币，国区应该是 12 元左右。如果你试用一下就会发现，它完全就是 IINA 的复制品。之前见过的复制品有的还会加上一些分享之类的新功能，而这个相比之下显得非常没有诚意。</p> \n<p>当然，仅仅口头上说「用户界面完全一致」也很难作为证据，那我打开稍微看了一下它里面有什么：</p> \n<ul> \n <li>此 App 和 IINA 有完全相同的用户界面，完全相同的 xib 结构。</li> \n <li>反编译后，可以看到绝大部分代码结构都是雷同的。</li> \n <li>此 App 中包含的资源文件，包括文件图标，本地化文件等等和 IINA 中包含的一模一样，SHA 结果相同。</li> \n <li>此 App 包含了没有任何用处的 cli 二进制文件（修改自 iina-cli ）。</li> \n <li>此 App 使用的二进制库和 IINA 使用的完全相同。</li> \n <li>此 App 中的 Translator.json 中有 IINA 所有的翻译者名字和联系方式。这位开发者只把我的联系方式改成了他自己的，连我的名字都留在里面。</li> \n <li>此 App 中包含了 IINA 用于自动更新的公钥文件。噗，你要这个干嘛！</li> \n</ul> \n<p>我实在是吃惊于这位开发者居然能在这样的情况下说出「请问我哪里使用了」这种话来。虽然近期更新缓慢，我们在业余时间也是一直持续开发，IINA 中使用的图标基本上都是我自己画的，现在积累的 20 多种语言的翻译也都是各国译者的努力成果。作为开源项目，我们无意私藏这些东西，只要遵守许可证，对它进行再发布和出售也无妨；而这位开发者做的是：<strong>把所有贡献者的名字抹除掉换成了自己，并试图在这个基础上盈利</strong>。这是我无法忍受的。</p> \n<p>IINA 从 2017 年发布到现在，域名、开发者证书、官网和邮件服务器都是我在出钱（确切地说，0.0.4 的时候短暂地贴了一下支付宝二维码，不过当时没有稳定的下载渠道，买 CDN 很快就用完了）。很多人建议我们开放捐助，不过因为事情太多更新太慢，没有精力也不太好意思（目前打算在插件系统做完后接受捐助，我觉得不会超过几个月；关于捐助的详情到时候会另外写点什么）。</p> \n<p>我相信在 v2 上发帖吐槽并不能解决问题，反而可能还会有人本来没这想法，现在看了也想试试了（不）。更多的是让自己心情好一点吧。</p> \n<blockquote> \n <p>最后放一下这位开发者的信息。这些信息都是可以在 MAS 或是这款 App “MPlayer X Pro” 的资源文件中公开查到的。请注意，我并不希望有人滥用这些信息或者用它获取这位开发者的其他隐私，而是希望如果有人认识这位开发者或者与其有合作，可以考虑敬而远之。</p> \n <ul> \n  <li>邮箱：13728063720@139.com</li> \n  <li>姓名：yuanteng li</li> \n  <li>App 中附带的微信二维码（外链）：<a href=\"https://imgur.com/a/Pnx14rq\" rel=\"nofollow noreferrer\">https://imgur.com/a/Pnx14rq</a> </li> \n </ul> \n <p><strong>事件后续</strong>：感谢大家的回复和支持！看到能引起这么多人的关注很开心。 </p> \n <p>今天对方回复说是「离职员工私自上传」，这个的可信度相信大家都自有判断。目前来看可以先等 Apple 处理了。 </p> \n <p>关于 IINA 的上架问题：我们可以考虑给 MAS 单独用一份许可证发布，不过要先征求贡献者的同意。同时，调用了私有 API 的功能（比如 PIP ）都要在 MAS 版本去掉。不过这些一直没有搞的原因还是太忙了……我觉得是需要想一下上架问题了。 </p> \n <p>关于捐助：可能大家也发现近一年 IINA 更新缓慢，如果一直收到捐助却不干活感觉说不过去，大家也不是为了钱才持续维护的。不过捐助（和大更新）几个月内会有的。 </p> \n <p>发帖之后有群友告诉我还有人在淘宝上卖 IINA 的，去搜了一下笑死了</p> \n <p><strong>对方已经下架了。 </strong> </p> \n <p>现在 App Store 上仍然有其他复制品存在，所以我们已经在考虑 MAS 版本的可行性。MAS 版本也不会收费，毕竟这不是个以营利为目标的项目。 </p> \n <p>有网友通过电话邮件微信等方式直接联系了侵权的开发者，谢谢你们的帮助。这虽然非常有效，但只能说是无奈之举，终究不是正确而且万能的做法。侵权的开发者已经在邮件中道歉，我也不想再去追究对方的销售所得等等，更希望把精力用在 MAS 版本的 IINA 上，以杜绝这种问题的持续出现。希望大家不要再通过以上联系方式骚扰对方了。 </p> \n <p>再次感谢大家的声援。</p> \n</blockquote> \n<p>原文链接：<a href=\"https://www.v2ex.com/t/658387\" rel=\"nofollow noreferrer\">https://www.v2ex.com/t/658387</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"http://localhost:8060/tup/2020/4/23/b0f11b26a9f74b129576904b14a70b23.jpg\" alt=\"sf.png\" title=\"sf.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/dbaaa944af9f407bbce6d46d1c1293f0.jpg', '5ca4567d892841b087fac5246effac40', '19eb3dd59ef8430d9f637d97449fc417', 'f3eb17e6e5664a97af3e9b1fca12b286,81a4561c1c294e0cae32c9fe6b5dc397,1939b672cc5446439db2b7017c7cfa48,6fe04eb419474fd7ad1248f0b1a2a7e6', '0', '3', '1', '2020-04-23 10:59:13', '2020-04-23 10:59:13');
INSERT INTO `tb_recommend` VALUES ('fd1c5653dcd7499fa434c5f3d5572bb2', 'iOS 滑动关后台会影响续航是真的，但并不会损伤你的电池', '对此事，苹果也在官方渠道发布声明表示“确实如此”。并表示 iPhone 电池寿命普遍偏短的原因，就是用户习惯性的手动关闭应用程序，这不仅会缩短电池的使用寿命，也会导致设备的速度变慢。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEkJ6\" src=\"http://localhost:8060/tup/2020/4/23/ee6d2c3a42964e2f8b6b365e4992afeb.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>前不久，#苹果建议不要滑动关闭后台程序#这个话题上了微博的热搜。</p> \n<p>这个话题的源头，是因为英国的《太阳报》的一篇报道中写道“如果您经常关闭应用程序，则 iPhone 会变慢并损耗电池。”</p> \n<p>对此事，苹果也在官方渠道发布声明表示“确实如此”。并表示 iPhone 电池寿命普遍偏短的原因，就是用户习惯性的手动关闭应用程序，这不仅会缩短电池的使用寿命，也会导致设备的速度变慢。</p> \n<p>在此之前，我相信大部分人都和我一样，认为后台的应用程序会占用 CPU、消耗电量，因此会经常性的手动关闭很多应用程序。</p> \n<p>但苹果为什么这么说呢？原理是啥？电池寿命真的是被我们一下一下划没的么？</p> \n<h2>后台的应用程序其实已经被“冻结”</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEkJ9\" src=\"http://localhost:8060/tup/2020/4/23/763998d7ea5149db9b56efa1cb6d47b1.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>这个观念差异的背后，其实是来源于用户和官方的认知差异。</p> \n<p>事实上早在 2016 年，时任苹果软件高级副总裁的 Craig Federighi 就针对用户的邮件进行了回复。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEkKa\" src=\"http://localhost:8060/tup/2020/4/23/61d86dbd906d4f5da439e675b419d109.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>但这个回复在当时并未被大部分人所了解。</p> \n<p>而事实上，iOS 为了让设备减少不必要的系统资源开销，并保持系统的流畅，它的后台更应该叫做「多任务切换界面」。而这得益于 iOS 特殊的「墓碑机制」。</p> \n<blockquote> \n <strong>名词解析：墓碑机制</strong>\n <p>简单来说，墓碑机制就是当 App 进入后台前将以某种形式持久化，然后释放其正在使用的资源（包括内存、CPU等），等待 App 再次被唤醒时，将再将这个保存的状态恢复出来，此时应用跟没有被杀死继续运行了一样。</p> \n <p>实际上 iOS 并不是严格意义上的墓碑机制，其在应用进入后台时可以向系统申请一定时间的后台运行时间（一般不超过10分钟），之后才会被完全挂起。</p> \n</blockquote> \n<p>根据这个机制我们可以知道，我们之前滑动关闭的并非是应用程序，而是类似于应用程序的快捷打开方式。</p> \n<p>而如果想真正的关闭一个应用程序，需要将这个应用从 RAM 中移除（比如重启手机），这时再次启动程序时系统需要重新调动资源，与冻结状态相比，所占用的 CPU 和消耗的电量更高，因此苹果方面建议除非应用程序无响应，否则不要滑动强制退出。</p> \n<p>当然，不排除一些应用程序会有更高的“权限”，在后台时也会占用系统资源，我们可以在「设置」中查看是否有哪些应用在滥用权限。</p> \n<h2>滑动关闭后台应用影响电池寿命？</h2> \n<p>先放结论：并不会。这是以讹传讹。</p> \n<p>我们能在很多媒体报道中看到“滑动关闭后台应用不仅没用，还会影响电池寿命”，这其实是因为翻译不精准导致的错误传言。</p> \n<p>《太阳报》的原文标题是《QUIT IT！Your iPhone gets SLOWER and loses battery life if you always swipe apps closed》，这里面提到的「battery life」被很多人翻译成了「电池寿命」，但实际上这个词一般表示电池的续航时间，英文语境中电池寿命一般会用「battery health」来表示。</p> \n<p>正如我们上文所示，滑动关闭后台应用后，重新启动将会消耗更多的 CPU 和电池电量，因此也会相应的降低电池的续航，和电池的使用寿命并没有关系。</p> \n<p>理论上影响电池寿命的因素目前有四个：</p> \n<ul> \n <li>充/放电速度</li> \n <li>电池温度</li> \n <li>放电深度（DOD）</li> \n <li>电池循环次数</li> \n</ul> \n<p>很多人在买卖二手笔记本的时候都会关注的参数就是「电池循环次数」，因为这个是影响电池寿命和健康程度的关键因素之一。</p> \n<p>如果想要通过健康的手机使用习惯来延长手机的电池寿命，这里有一个建议就是关闭某些应用程序的系统通知（也就是常说的弹窗广告）。</p> \n<h2>安卓手机可以滑动杀后台么？</h2> \n<p>iOS 系统不建议频繁滑动关闭后台的应用程序，那么 Android 系统可以么？</p> \n<p>答案是：可以。</p> \n<p>背后的原因是 iOS 与 Android 的后台机制并不相同。文章开头我们介绍了 iOS 系统的「墓碑机制」，而 Andriod 系统并没有采用这一机制，所以大部分 Android 系统的应用程序切换到后台后，仍然在占用着 CPU。而滑动关闭后台的程序也就真的是把程序给彻底关闭了。</p> \n<p>这也是为什么Andriod 系统的手机容易变卡、发烫。就是因为 Android 的运存总是很大，不过从安卓 5.0 之后，因为各大厂商对系统做的优化和硬件的迭代发展，这种情况现在也是越来越少了。</p> \n<hr> \n<p>总结一下我们今天的文章，大致有以下几个观点：</p> \n<ol> \n <li>对于广大的iPhone用户来说，还是乖乖按照苹果官方的说法操作，没事就别随便做出滑动退出APP这种“骗自己”的行为了；</li> \n <li>滑动关闭后台程序不会影响电池寿命；</li> \n <li>Andriod 系统手机因为后台机制与 iOS 系统不同，因此滑动关闭后台程序确实可以释放 CPU。</li> \n</ol> \n<p>你觉得这两种系统的机制，哪个更好一些？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCJ1M\" src=\"http://localhost:8060/tup/2020/4/23/9b55c4c2306b45e38db786b83ec22060.jpg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', null, 'http://localhost:8060/tup/2020/4/23/880a0cff0343458583a73dd301862b2b.jpg', '3f69fcc9b13843d1910b3dac597f5215', 'a337904dd1d5477b9689d7693be316de', '9276a7fb738f4d38aec0e4c23347fba7,85ee959b27f74072b13cc763b9bbf77e,8dfc62f227ae4076888ea4872e03cddd', '0', '3', '1', '2020-04-23 10:31:58', '2020-04-23 10:31:58');
INSERT INTO `tb_recommend` VALUES ('fec716b383e544b59a50cd48fd2eb86e', '干货！一次 kafka 卡顿故障排查过程', '来源：等你归去来 ，www.cnblogs.com/yougewe/p/8975550.html 由于一次功能上线后，导致某数据量急剧下滑，给我们紧张的呢！排查过程也是个学习过程！抛开结果，方法论可供参考～ 1. 确认问题的真实性？ 被数据部...', '<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;mid=2247492296&amp;idx=1&amp;sn=95e24cec58e9b1ee2f0bb6ca1b4d30c1&amp;chksm=e91887d4de6f0ec22b7ffc2a71f7706df7511cf3095675c4d6c55de543c74be98ab45af3e200&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022327087\" src=\"http://localhost:8060/tup/2020/4/23/c868b2c6e3d34a7c9b4069de17f363ee.jpg\" alt=\"\" title=\"\"></span></a></p> \n<blockquote>\n 来源：等你归去来 ，\n <br>www.cnblogs.com/yougewe/p/8975550.html\n</blockquote> \n<p>由于一次功能上线后，导致某数据量急剧下滑，给我们紧张的呢！排查过程也是个学习过程！抛开结果，方法论可供参考～</p> \n<p><strong>1. 确认问题的真实性？</strong></p> \n<p>被数据部门告知，某数据量下滑严重，当时即知道问题的严重性。且该问题是在我的功能上线后产生，第一反应就是，我代码哪里写错了？但是，还得按流程来，通过各种维度数据对比请求量，实际落地量。确认问题！</p> \n<p>其实该过程中，我们并没有确认自己的数据量下滑。但是这也脱不了数据下滑的干系。只能进行下一步！</p> \n<p><strong>2. 检查代码，找有经验的同学，对比原有功能差异点？</strong></p> \n<p>这个步骤其实，是有点盲目的感觉。因为第一步的排查并没有找到足够的证明说明问题出在我们，但是问题在于期间只有我们上过线，所以只能自我反省了。</p> \n<p>不过幸好，这过程还真有用，果真发现了自己埋的一个坑，此坑确实会导致该数据量的下滑。赶紧修掉呗！</p> \n<p>然后松了一口气，以为搞好了。其实不然，数据量依然上不去。这就尴尬了！</p> \n<p>我已经开始怀疑人生，难道代码没发上去？难道线上和本地某个地方不一样？测试环境反复测试正确无误。我真想直接把测试环境代码弄到线上去，哎，算了吧，很多东西是不会以人的意志为转移的，咱们还是理性点！别谋出路吧！</p> \n<p><strong>3. 直接坐到dba旁边去吧，让我们随时关注数据量？</strong></p> \n<p>自我排查已经救不了自己了，那就上dba那里。麻烦帮我统计下上线后，数据量的变化，结果是没多大差别。心想有可能是时间太短，看不出变化，等会儿再统计吧。依然没有变化！我的神呐，定了锅还在。</p> \n<p>大的数据量不行，那我用自己的账号来测试吧，操作完成后，观察数据，发现有时有有时无！额，说不出啥了。</p> \n<p><strong>4. 本地调试吧？</strong></p> \n<p>原本以为，是线上问题，紧急处理下就好了。然而事实却超出了我的预料，将验证直接交给线上，是对用户的不负责，是对数据的不负责。咱们还是从本地做起吧。</p> \n<p>本地调试要走vpn，有点烦，但不管怎么样，还是跑起来了。没问题啊！这尴尬了。</p> \n<p>然后，引出下一个议题！</p> \n<p><strong>5. 线上环境配置与测试环境不一样？</strong></p> \n<p>然后我们努力找出其中的不同点，哪怕是多了一个文件，某个文件的更改时间点不一致，我们都想去试一下！当然了，为了稳妥起见，我们还是不能直接在线上验证的，除非有足够的证据说明线上的配置是有问题的。当然我们最终并没有找到这样的证据，只是将线上的所有东西都搬到测试环境来验证，结果是畅通无阻！</p> \n<p>还有一个证明此路不通的理由，之前的配置跑得好好的东西，难道会自己坏掉？不可能吧。此路不通！</p> \n<p><strong>6. 实在不行了，只能改代码线上调试？</strong></p> \n<p>调试第一步，各自打日志！把之前请求打印不全的地方，加上完整日志，再发一版吧！有了日志，就有证据，但是真的是急中生错啊，日志居然打得不对，将参数打印为了内存地址也真是够了。</p> \n<p>日志改好后，测试呗，继续用自己的账号。还是一样，有时能能进有时不能（监控手段为dba起一个临时的kafka消费者，然后将数据拉出来看）！那咋整呢？</p> \n<p>难道是有的机器坏了？分配到坏的机器上去的请求就失败，分配到正确机器的上去的请求就正确。然后吭哧吭哧搞了半天的数据验证，曾经以为这是方向，结果又被打回。</p> \n<p><strong>7. 不行咱们就抓包吧？</strong></p> \n<p>tcpdump，一个网络流抓包神器，lsof助攻一下。</p> \n<p>抓包只是为了确认一个问题，客户机器有发送请求到服务端机器，网络流正常运转！然后证明，客户端机器有大量长连接到服务器，数据流发送接收正常（syn）。这至少说明了一点，客户端是没有问题的！那么就还剩一个问题，那就是服务端出问题了！我们坚信，当然要有证据嘛。</p> \n<p>同理，我们在服务端机器上进行反向抓包，然后抓到了来自客户端的包，很流畅嘛！额。。。</p> \n<p><strong>8. 不行，没有思路了，重启机器吧？</strong></p> \n<p>不，我说的是重启服务。最近不是有改动嘛，按理谁改动重启谁。然而这是没有用的，因为之前的几次发布早已重启了n次。那咋整呢。只剩重启服务端，kafka服务了呗，死马当活马医吧！</p> \n<p>重启后，验证呗。结果貌似还是发现有成功，有失败！</p> \n<p><strong>9. 改异步请求为同步请求？</strong></p> \n<p>又没思路了，我不甘心呐，为啥测试环境好好的，到线上就不行了呢？再想想差别在哪里？</p> \n<p>得出的结论是，线上并发大，测试环境量无。然后发现这一块代码是由异步线程做的，会不会是这里有问题？</p> \n<p>不管了，改成同步请求试试吧。再来一版！</p> \n<p>别说，改为同步后，虽然用户请求基本都慢死了，但是发现kafka请求确实存在了。难道真的是因为这个，那我们也不能这么改啊，用户体验是第一位的，为了这事改异步为同步，咱得吃不了兜着走啊。改回来继续其他的吧！</p> \n<p><strong>10. 再回测试环境，压测并发？</strong></p> \n<p>改还原为异步后，又回到当初有成功有失败境地了。</p> \n<p>既然怀疑线上高并发导致，那为什么不在测试环境高并发压测一下呢？用shell脚本快速写了一个循环请求脚本，大量请求到kafka后，并无一丝异常，到此并发问题取消。（for，nohup a.sh &gt; /dev/null 2&amp;&gt;1 &amp;）n 次即模拟n个并发请求</p> \n<p><strong>11. 再来细细检查代码吧？</strong></p> \n<p>都不知道查了几遍了，但是还是要查啊，不然咋整呢，几个人一起看代码呗！</p> \n<p>然而这并没有什么卵用。</p> \n<p><strong>12. 抛开用户行为，直接以命令行形式操作请求？</strong></p> \n<p>虽然用户行为是最真实的验证，但是也是比较麻烦的验证。</p> \n<p>我们就抛开各种中间环节，直接向kafka服务器发起请求！</p> \n<p>分两种方式，1 用现在的代码去请求，2 用kafka自带的请求方式请求。结果得到两个不同的结果，用代码的方式请求的数据，没有成功，用kafka自己的请求方式，则毫秒级响应。哎，这是让我又怀疑代码？</p> \n<p><strong>13. 已走投无路，让我们再看一眼数据吧？</strong></p> \n<p>真的是没有思路了，只能再来看看数据，当打发时间了。</p> \n<p>意外就在你想不到的时候发生了。数据已经恢复正常了！我擦！</p> \n<p>倒推时间，倒推事件，是由于kafka重启，导致数据回升的。</p> \n<p>好吧，问题已经定位，kafka卡顿导致。咱们已经熬不住了，发个结论邮件，就先回去洗洗睡吧！</p> \n<p><strong>14. 为什么kafka会卡顿？</strong></p> \n<p>这才是问题的根本！只是我们当时已经没有力气再往下搞了！</p> \n<p>结论是由于topic请求量过大，而partition过小，导致吞吐量下降。将partition改大之后，终于真正恢复正常！</p> \n<p>额，好像做了很多无用功，没办法 ！</p> \n<p>最新整理的&nbsp;<strong>2TB</strong>&nbsp;技术干货：包括<strong>架构师实战教程、大数据、Docker容器、系统运维、数据库、redis、MogoDB、电子书、Java基础课程、Java实战项目、ELK Stack、机器学习、BAT面试精讲视频</strong>等。只需在<strong>「&nbsp;</strong><strong>民工哥技术之路」</strong>微信公众号对话框回复关键字：<strong>1024</strong>即可获取全部资料。</p>', null, 'http://localhost:8060/tup/2020/4/23/9b40557d86ed4f9189c6247004d5dd26.jpg', '61cdf41d1e5e4f229b76f6a042e254b6', '91832bd0c3a244fb88c0bca74c0d404d', '55723db96b9f4593bae02bc1e49f1e87,d7416e100af54eb7a4d9274b9a462240,753b5aee3913424e81fe2b5299626d8c,81a4561c1c294e0cae32c9fe6b5dc397,c2232afd87094fb88ae1b65a43876011', '0', '3', '1', '2020-04-23 11:01:06', '2020-04-23 11:01:06');
INSERT INTO `tb_recommend` VALUES ('ff9ff876dfa14efe806833c4183a0fd6', '京东小程序开放平台终于来了~', '京东服务覆盖10亿多用户和超过27万第三方商家。如何连接京东和商家生态体系，给C端消费者提供全链路一站式的优质服务体验，是京东高度关注的问题。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435941\" src=\"http://localhost:8060/tup/2020/4/23/5b19497406384817a532d304f909104b.jpg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p>京东服务覆盖10亿多用户和超过27万第三方商家。如何连接京东和商家生态体系，给C端消费者提供全链路一站式的优质服务体验，是京东高度关注的问题。</p> \n<p>因此京东小程序开放平台作为京东战略项目应运而生，4月22号正式对外发布，致力于给消费者带来<strong>新服务、新体验。</strong></p> \n<p>京东小程序平台不仅支持存量自营、POP商家自动开通，还支持新型的<strong>非电商领域商家参与小程序生态</strong>。</p> \n<p>加入京东小程序开放平台的商家，可以利用京东平台完整的营销、交易、支付、会员、物流等能力，更加便捷地构建起自己的特色服务场景。助力商家实现生态场景上的“跃迁”，快速为用户提供一站式服务体验。</p> \n<p><strong>那么京东小程序为用户带来了哪些新体验呢？</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435939\" src=\"http://localhost:8060/tup/2020/4/23/16babeeee08647948faf79c4e6fdb067.jpg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p>智能家居是人们实现美好生活的畅想新助力。</p> \n<p><strong>京东家电品牌商家</strong>，通过智能小程序，实现一键操作全屋家居设备，将京东主站购买服务与智能家居（激活）操控相结合，形成全链路服务闭环。用户购买智能家居产品后，无需下载多个APP，操作更加便捷。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435940\" src=\"http://localhost:8060/tup/2020/4/23/d939a815435642398c110ced5d907fd2.jpg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p>如何在京东上体验到更优质的教育服务？</p> \n<p>京东小程序平台引入<strong>优质教育小程序</strong>，基于课程购买和书籍购买，助力商家拓展能力边界。用户进行购买行为后，在京东内就能享受涵盖15个考试类别10万道题的在线题库，辅助用户报考专硕院校的查询指导等在线教育的功能，让学习之路更加轻松、方便。都学教育、希赛教育等就是首批使用京东小程序平台的优秀教育机构。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435944\" src=\"http://localhost:8060/tup/2020/4/23/5198d15c622043368e9138528fb70d67.jpg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p><strong>“京东店铺购物小程序”</strong>是由京东小程序平台联合羚珑Atom智能设计平台，对京东APP内的店铺阁楼进行的技术全面升级。升级后，用户操作将更流畅，体验将更加沉浸，转化留存也将更好。AR、3D、全景馆、小游戏等高转化类型的店铺营销玩法，也将全面模版化，开放给商家使用。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435942\" src=\"http://localhost:8060/tup/2020/4/23/69005c234bba4db88860714180580ab5.jpg\" alt=\"1.jpg\" title=\"1.jpg\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435943\" src=\"http://localhost:8060/tup/2020/4/23/159ff523301a4970abd9c195b5bedc68.jpg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p><strong>线下店类的小程序</strong>基于LBS定位能力，通过关键词搜索给用户匹配最近的商家小程序，实现极速送货两小时到家。满足消费者即时消费需求，带给顾客全新的购物体验。</p> \n<p>品牌商家以独立小程序形式存在于京东APP中，保证了商家品牌的完整性。结合京东线上购物便利与线下商超门店连锁覆盖的双重优势，解决超市产品运营压力，通过搜索路径最快速触达用户，提升用户购物频次，实现供应链的进一步优化。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435946\" src=\"http://localhost:8060/tup/2020/4/23/436e6877931742b289566e9f1c59008a.jpg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p>疫情的冲击，多流量渠道覆盖成为新的增长点。京东小程序为小微商家提供新机会，<strong>小微商家也能极速上线</strong>。美容、餐饮、美发、休闲娱乐、上门清扫等小程序，让用户足不出户就能在家中找到周边所有的服务。</p> \n<p>京东小程序平台还与<strong>京东PLUS会员能力</strong>深度结合，京东的PLUS会员能享受商家提供的优质服务。例如：PLUS会员在预定酒店时点击授权即可自动匹配酒店会籍，无需跨平台兑换权益，小程序直接下单即可享受超值优惠价格和绝佳酒店服务。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435945\" src=\"http://localhost:8060/tup/2020/4/23/cb67da5f53f549de90c6e4d9c90f648a.jpg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435947\" src=\"http://localhost:8060/tup/2020/4/23/e3db8efe438e4e18836103d059437647.jpg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p><strong>通讯类小程序</strong>向用户提供更优质贴心的服务，让通讯服务和消费购物更紧密的结合。使5G带来的便利生活透过小程序窗口，打通电信和京东的生态体系，让双方的结合做到1+1＞2。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435948\" src=\"http://localhost:8060/tup/2020/4/23/28981f46cd714282955ccef7bc39fea7.jpg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p>出门旅行房费太贵？租车押金过高？</p> \n<p>京东小程序支持京东支付、小白信用等多种金融能力，白条付款能缓解用户资金压力；信用作保用户能享受到免押租赁服务，做到真正的生活旅途无忧。</p> \n<p>同时<strong>京东金融App也拥有小程序能力</strong>，用户无需在不同的金融理财App间来回切换。小程序模式能让用户更快速触达服务入口，将金融服务全面场景化，统一支付方式、降低交易风险，用户随来随走，方便快捷。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435949\" src=\"http://localhost:8060/tup/2020/4/23/89d780c01c8a4a99a5a10f8c57532c11.jpg\" alt=\"2.png\" title=\"2.png\"></span></p> \n<p>加油站排队等太久，突发意外不知道如何解决。&nbsp;</p> \n<p>京东的小程序从4S店售后到汽车线上加油，再到保养、救援、车友会、车载智能，<strong>一站式解决用户的汽车后需要</strong>。小程序可在车载智能屏硬件打开，带动物联网新进程。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435950\" src=\"http://localhost:8060/tup/2020/4/23/52faa31f78964f539717ff8ce556597e.jpg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p>京东小程序平台为行业新产业链商家提供绿色入驻通道，入驻成功后还能享受新产业链的流量扶持。</p> \n<p>&nbsp;<span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022435951\" src=\"http://localhost:8060/tup/2020/4/23/735be48bfa6448b8bb9a02a6d40dc2ce.jpg\" alt=\"1.jpg\" title=\"1.jpg\"></span></p> \n<p><strong>欢迎点击“小程序官方网站”</strong><strong>了解更多详细内容！</strong></p>', null, 'http://localhost:8060/tup/2020/4/23/959a025f093548dd917a9625f640d7f5.jpg', '1c5851dc916d4e70a60f0c957f548876', '7b3e40f8b9cc4b7780dc39a71d7f580e', '3b375646301546259a8fb29d74ae4447,8ef5bc94d5e84e80baab05e02363c9e5', '0', '3', '1', '2020-04-23 10:29:38', '2020-04-23 10:29:38');

-- ----------------------------
-- Table structure for tb_recommend_vote
-- ----------------------------
DROP TABLE IF EXISTS `tb_recommend_vote`;
CREATE TABLE `tb_recommend_vote` (
  `uuid` varchar(50) NOT NULL,
  `recommend_id` varchar(50) DEFAULT NULL COMMENT '文章id/问答id',
  `user_id` varchar(50) DEFAULT NULL COMMENT '用户id',
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='文章、问答点赞表';

-- ----------------------------
-- Records of tb_recommend_vote
-- ----------------------------
INSERT INTO `tb_recommend_vote` VALUES ('03c55003e5d6447ca7c4184de302f100', '1ae15e992d764346af4945cf729d2f4d', 'd6754affc7864ea9b67b61e493d28614');
INSERT INTO `tb_recommend_vote` VALUES ('738fe06a7cbf4203ab6d518a53db0448', '03ab3eb0493e471a8410aaf7325866eb', 'd6754affc7864ea9b67b61e493d28614');

-- ----------------------------
-- Table structure for tb_users
-- ----------------------------
DROP TABLE IF EXISTS `tb_users`;
CREATE TABLE `tb_users` (
  `uuid` varchar(50) NOT NULL,
  `nickname` varchar(10) DEFAULT NULL COMMENT '昵称',
  `password` varchar(50) DEFAULT NULL COMMENT '密码',
  `username` varchar(10) DEFAULT NULL COMMENT '真实姓名',
  `phone` varchar(11) DEFAULT NULL COMMENT '手机号码',
  `website` varchar(50) DEFAULT NULL COMMENT '个人网站',
  `email` varchar(50) DEFAULT NULL COMMENT '邮箱',
  `image_url` varchar(255) DEFAULT NULL COMMENT '头像',
  `location_city` varchar(10) DEFAULT NULL COMMENT '所在城市',
  `address` varchar(50) DEFAULT NULL COMMENT '通讯地址',
  `resume_description` varchar(255) DEFAULT NULL COMMENT '履历说明',
  `good_at_technology` varchar(255) DEFAULT NULL COMMENT '擅长技术（逗号隔开）',
  `description` varchar(255) DEFAULT NULL COMMENT '个人简介',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表';

-- ----------------------------
-- Records of tb_users
-- ----------------------------
INSERT INTO `tb_users` VALUES ('1894b118d35d44cb8fe8009529c4154b', 'kuitos', 'e10adc3949ba59abbe56e057f20f883e', null, '17680697447', null, null, null, null, null, null, null, null, '2020-04-16 16:28:32', '2020-04-16 16:28:32');
INSERT INTO `tb_users` VALUES ('1c5851dc916d4e70a60f0c957f548876', '一点痕寂', 'e10adc3949ba59abbe56e057f20f883e', null, '18588773304', null, null, null, null, null, null, null, null, '2020-04-16 16:20:50', '2020-04-16 16:20:50');
INSERT INTO `tb_users` VALUES ('3f69fcc9b13843d1910b3dac597f5215', 'champyin', 'e10adc3949ba59abbe56e057f20f883e', null, '15581603443', null, null, null, null, null, null, null, null, '2020-04-16 16:28:11', '2020-04-16 16:28:11');
INSERT INTO `tb_users` VALUES ('5ca4567d892841b087fac5246effac40', '疯狂的技术宅', 'e10adc3949ba59abbe56e057f20f883e', null, '13272452662', null, null, null, null, null, null, null, null, '2020-04-16 16:28:48', '2020-04-16 16:28:48');
INSERT INTO `tb_users` VALUES ('61cdf41d1e5e4f229b76f6a042e254b6', '陈东民', 'e10adc3949ba59abbe56e057f20f883e', null, '15974253641', null, null, null, null, null, null, null, null, '2020-04-16 16:21:38', '2020-04-16 16:21:38');
INSERT INTO `tb_users` VALUES ('692c6787030d4b8882077b2ab9279c52', 'ConardLi', 'e10adc3949ba59abbe56e057f20f883e', null, '15575974664', null, null, null, null, null, null, null, null, '2020-04-16 16:29:06', '2020-04-16 16:29:06');
INSERT INTO `tb_users` VALUES ('6fbfa4aaad3a43458f21c8acf0038ac5', '前端小智', 'e10adc3949ba59abbe56e057f20f883e', null, '13036784774', null, null, null, null, null, null, null, null, '2020-04-16 16:29:29', '2020-04-16 16:29:29');
INSERT INTO `tb_users` VALUES ('92fd98d1f9ce496dbe8c80ffd3bb7bdf', '我叫mt', 'e10adc3949ba59abbe56e057f20f883e', null, '13135284774', null, null, null, null, null, null, null, null, '2020-04-16 16:24:10', '2020-04-16 16:24:10');
INSERT INTO `tb_users` VALUES ('c56940aa8b004dab84568e86900b2ee6', '漃寞、誰買單', 'e10adc3949ba59abbe56e057f20f883e', null, '13187014224', null, null, null, null, null, null, null, null, '2020-04-16 16:24:28', '2020-04-16 16:24:28');
INSERT INTO `tb_users` VALUES ('f53014d680884163a5bd5ce762e90cdf', '回忆积累在胸口', 'e10adc3949ba59abbe56e057f20f883e', null, '18525854114', null, null, null, null, null, null, null, null, '2020-04-16 16:24:56', '2020-04-16 16:24:56');

-- ----------------------------
-- Table structure for tb_users_info
-- ----------------------------
DROP TABLE IF EXISTS `tb_users_info`;
CREATE TABLE `tb_users_info` (
  `uuid` varchar(50) NOT NULL,
  `name` varchar(20) DEFAULT NULL COMMENT '名称',
  `name_sub` varchar(20) DEFAULT NULL COMMENT '子标题',
  `start_time` datetime DEFAULT NULL COMMENT '开始时间',
  `end_time` datetime DEFAULT NULL COMMENT '结束时间',
  `is_time` bit(1) DEFAULT NULL COMMENT '判断结束时间是否要填',
  `city` varchar(50) DEFAULT NULL COMMENT '所在城市',
  `label_id` varchar(255) DEFAULT NULL COMMENT '标签id',
  `desc` varchar(255) DEFAULT NULL COMMENT '描述',
  `type` int(1) DEFAULT NULL COMMENT '1、工作经历 2、教育经历 3、开源项目',
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户信息表(工作经历,教育经历,开源项目 & 文章著作)';

-- ----------------------------
-- Records of tb_users_info
-- ----------------------------
