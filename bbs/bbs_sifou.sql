/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50560
Source Host           : localhost:3306
Source Database       : bbs_sifou

Target Server Type    : MYSQL
Target Server Version : 50560
File Encoding         : 65001

Date: 2020-04-14 20:59:41
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for tb_channels
-- ----------------------------
DROP TABLE IF EXISTS `tb_channels`;
CREATE TABLE `tb_channels` (
  `uuid` varchar(50) NOT NULL,
  `name` varchar(10) DEFAULT NULL COMMENT '名称',
  `url` varchar(50) DEFAULT NULL COMMENT '地址',
  `icon_url` varchar(255) DEFAULT NULL COMMENT '图标',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='频道表';

-- ----------------------------
-- Records of tb_channels
-- ----------------------------
INSERT INTO `tb_channels` VALUES ('04547238127a4676b504cc4496865d7b', '安全', 'netsec', '', '2020-04-14 09:23:09', '2020-04-14 09:23:09');
INSERT INTO `tb_channels` VALUES ('049b3bd76c1e49ccbe48b36197e77f76', '前端', 'frontend', '', '2020-04-08 16:42:59', '2020-04-10 11:33:53');
INSERT INTO `tb_channels` VALUES ('19eb3dd59ef8430d9f637d97449fc417', '开源', 'oss', '', '2020-04-14 09:23:41', '2020-04-14 09:23:41');
INSERT INTO `tb_channels` VALUES ('1a7cc9fbc4654cb0afec84e080816ef1', '游戏', 'game', '', '2020-04-14 09:22:59', '2020-04-14 09:22:59');
INSERT INTO `tb_channels` VALUES ('2a353971222c4aff8e8d3e9c370330cd', '工具', 'toolkit', '', '2020-04-14 09:23:54', '2020-04-14 09:23:54');
INSERT INTO `tb_channels` VALUES ('3798854967b444e0b8156e5154f94b97', '区块链', 'bc', '', '2020-04-14 09:23:31', '2020-04-14 09:23:31');
INSERT INTO `tb_channels` VALUES ('7b3e40f8b9cc4b7780dc39a71d7f580e', '小程序', 'miniprogram', '', '2020-04-08 16:43:43', '2020-04-08 16:43:43');
INSERT INTO `tb_channels` VALUES ('819ad72c1efe450f9d7affc135a4b457', 'Android', 'android', '', '2020-04-14 09:22:31', '2020-04-14 09:22:31');
INSERT INTO `tb_channels` VALUES ('91832bd0c3a244fb88c0bca74c0d404d', '程序员', 'programmer', '', '2020-04-14 09:24:04', '2020-04-14 09:24:04');
INSERT INTO `tb_channels` VALUES ('a0ea520851b4484f9cebac9ff7e47bc6', '金融科技', 'fintech', '', '2020-04-14 09:23:17', '2020-04-14 09:23:17');
INSERT INTO `tb_channels` VALUES ('a2718d66a7234b1499ed897ff4df05c8', '行业', 'industry', '', '2020-04-14 09:24:15', '2020-04-14 09:24:15');
INSERT INTO `tb_channels` VALUES ('a337904dd1d5477b9689d7693be316de', 'IOS', 'ios', '', '2020-04-14 09:22:11', '2020-04-14 09:22:11');
INSERT INTO `tb_channels` VALUES ('b299a2a48cd64e77a3431ce958b42055', '云计算', 'cloud', '', '2020-04-14 09:22:49', '2020-04-14 09:22:49');
INSERT INTO `tb_channels` VALUES ('bb0b7e69ad3e46fcb121baefda8f1f78', '后端', 'backend', '', '2020-04-08 16:43:25', '2020-04-08 16:43:25');
INSERT INTO `tb_channels` VALUES ('cbad2058b4014634aec6515f4adbef0d', 'AI', 'ai', '', '2020-04-14 09:22:41', '2020-04-14 09:22:41');

-- ----------------------------
-- Table structure for tb_comment
-- ----------------------------
DROP TABLE IF EXISTS `tb_comment`;
CREATE TABLE `tb_comment` (
  `uuid` varchar(50) NOT NULL,
  `recommend_id` varchar(50) DEFAULT NULL COMMENT '文章id/问答id',
  `user_id` varchar(50) DEFAULT NULL COMMENT '用户id',
  `like_number` int(9) DEFAULT '0' COMMENT '点赞数',
  `content` varchar(255) DEFAULT NULL COMMENT '评论内容',
  `create_time` datetime DEFAULT NULL,
  `parent_id` varchar(50) DEFAULT NULL COMMENT '父级id',
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='评论主表';

-- ----------------------------
-- Records of tb_comment
-- ----------------------------
INSERT INTO `tb_comment` VALUES ('30e30671ffb04f12b5047753bca66f52', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是评论4', '2020-04-14 15:34:51', '');
INSERT INTO `tb_comment` VALUES ('47a7bc7cf5ca481fb9785bac2db8251c', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是评论3', '2020-04-14 15:34:43', '');
INSERT INTO `tb_comment` VALUES ('728a0954563542ae9e38108669de6ccf', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-1', '2020-04-14 15:35:23', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('7615021c3af346e791516fc443b03cc7', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-3', '2020-04-14 15:35:39', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('76d33636d29b4f78a717d148dca1a23e', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-2', '2020-04-14 15:35:35', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('7bef431461844a9da921ad1ab29c41d3', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-4', '2020-04-14 15:35:43', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('f18e7b63ceca4166b65c23451535abaa', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是评论1', '2020-04-14 15:34:08', '');

-- ----------------------------
-- Table structure for tb_follow
-- ----------------------------
DROP TABLE IF EXISTS `tb_follow`;
CREATE TABLE `tb_follow` (
  `uuid` varchar(50) NOT NULL,
  `target_id` varchar(50) DEFAULT NULL COMMENT '文章id/问答id',
  `user_id` varchar(50) DEFAULT NULL COMMENT '用户id',
  `create_time` datetime DEFAULT NULL,
  `type` int(1) DEFAULT NULL COMMENT '1、标签  2、人  3、问答   4、文章  5、专栏',
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='文章、问答关注表';

-- ----------------------------
-- Records of tb_follow
-- ----------------------------

-- ----------------------------
-- Table structure for tb_labels
-- ----------------------------
DROP TABLE IF EXISTS `tb_labels`;
CREATE TABLE `tb_labels` (
  `uuid` varchar(50) NOT NULL,
  `channels_id` varchar(50) DEFAULT NULL COMMENT '频道id',
  `name` varchar(10) DEFAULT NULL COMMENT '标签名称',
  `icon_url` varchar(255) DEFAULT NULL COMMENT '图标',
  `description` varchar(120) DEFAULT NULL COMMENT '描述',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='标签表';

-- ----------------------------
-- Records of tb_labels
-- ----------------------------
INSERT INTO `tb_labels` VALUES ('15941dc0af92453481b8a0626f963283', '7b3e40f8b9cc4b7780dc39a71d7f580e', '微信小程序', '', '', '2020-04-09 19:49:34', '2020-04-09 19:49:34');
INSERT INTO `tb_labels` VALUES ('1d0ffae0426e4e6e8add67530ec689b4', '049b3bd76c1e49ccbe48b36197e77f76', 'html', '', '', '2020-04-09 19:47:46', '2020-04-09 19:47:46');
INSERT INTO `tb_labels` VALUES ('219d7aff8dfe4ffc9c8f368e2987187f', '7b3e40f8b9cc4b7780dc39a71d7f580e', '支付宝小程序', '', '', '2020-04-09 19:49:42', '2020-04-09 19:49:42');
INSERT INTO `tb_labels` VALUES ('3283cc5d6e714f1eb30181e3d83d99af', '7b3e40f8b9cc4b7780dc39a71d7f580e', '百度小程序', '', '', '2020-04-09 19:49:47', '2020-04-09 19:49:47');
INSERT INTO `tb_labels` VALUES ('401f1c4dcfbc499e8f7129c091c299f8', '049b3bd76c1e49ccbe48b36197e77f76', 'html5', '', '', '2020-04-09 19:48:27', '2020-04-09 19:48:27');
INSERT INTO `tb_labels` VALUES ('7b39e36da1f543c995c416f3d2950cf5', '049b3bd76c1e49ccbe48b36197e77f76', 'css', '', '', '2020-04-09 19:48:41', '2020-04-09 19:48:41');
INSERT INTO `tb_labels` VALUES ('7c555cea2dd347e389848f652e8f6ff7', '049b3bd76c1e49ccbe48b36197e77f76', 'bootstrap', '', '', '2020-04-14 20:02:45', '2020-04-14 20:02:45');
INSERT INTO `tb_labels` VALUES ('b350d9c92c524bb4b9feedd40e5eebcd', '049b3bd76c1e49ccbe48b36197e77f76', 'vue.js', '', '', '2020-04-14 20:04:01', '2020-04-14 20:04:01');
INSERT INTO `tb_labels` VALUES ('b3b8c4672aad4d63919b3a05dac79983', '049b3bd76c1e49ccbe48b36197e77f76', 'ecmascript', '', '', '2020-04-14 20:04:12', '2020-04-14 20:04:12');
INSERT INTO `tb_labels` VALUES ('ba43c444c9a0480dae0ea17d7463821b', '049b3bd76c1e49ccbe48b36197e77f76', 'ajax', '', '', '2020-04-14 20:03:15', '2020-04-14 20:03:15');
INSERT INTO `tb_labels` VALUES ('d07dbcd8900c4d34811137be64dd4301', '049b3bd76c1e49ccbe48b36197e77f76', 'css3', '', '', '2020-04-09 19:48:44', '2020-04-09 19:48:44');
INSERT INTO `tb_labels` VALUES ('d16a93d83052441a90afaa57d69fdc3c', '049b3bd76c1e49ccbe48b36197e77f76', 'node.js', '', '', '2020-04-14 20:04:47', '2020-04-14 20:04:47');
INSERT INTO `tb_labels` VALUES ('d79254c4ca5e45dca9d484307c935281', '049b3bd76c1e49ccbe48b36197e77f76', 'javascript', '', '', '2020-04-09 19:49:00', '2020-04-09 19:49:00');
INSERT INTO `tb_labels` VALUES ('e0a1c37357374c5b81385440f46da50d', '049b3bd76c1e49ccbe48b36197e77f76', 'react.js', '', '', '2020-04-14 20:03:42', '2020-04-14 20:03:42');

-- ----------------------------
-- Table structure for tb_recommend
-- ----------------------------
DROP TABLE IF EXISTS `tb_recommend`;
CREATE TABLE `tb_recommend` (
  `uuid` varchar(50) CHARACTER SET utf8 NOT NULL,
  `title` varchar(60) CHARACTER SET utf8 DEFAULT NULL COMMENT '标题',
  `excerpt` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '列表展示字段',
  `content` longtext CHARACTER SET utf8mb4 COMMENT '富文本内容',
  `image_url` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '封面图',
  `user_id` varchar(50) CHARACTER SET utf8 DEFAULT NULL COMMENT '用户id',
  `labels` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '标签id',
  `votes` int(11) DEFAULT NULL COMMENT '投票数',
  `views_word` int(11) DEFAULT NULL COMMENT '阅读数',
  `status` int(1) DEFAULT NULL COMMENT '1、草稿箱  2、审核中 3、推荐',
  `type` int(1) DEFAULT NULL COMMENT '1 文章  2 问答',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=sjis COMMENT='文章、问答表';

-- ----------------------------
-- Records of tb_recommend
-- ----------------------------
INSERT INTO `tb_recommend` VALUES ('004be5f4b1d244ebb407c4abea6f5a4f', '什么是HSTS，为什么要使用它？', '翻译自：What Is HSTS and Why Should I Use It?作者：Tomasz Andrzej Nidecki，一位非常专业的 Technical Content Writer ，目前是 Acunetix 的技术内容撰写人，他是一名拥有 25 年 IT 经验的记者、翻译和技术撰...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316263\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<blockquote>\n 翻译自：\n <a href=\"https://www.acunetix.com/blog/articles/what-is-hsts-why-use-it/\" rel=\"nofollow noreferrer\">What Is HSTS and Why Should I Use It?</a>\n <p>作者：<a href=\"https://www.linkedin.com/in/tonid?originalSubdomain=mt\" rel=\"nofollow noreferrer\">Tomasz Andrzej Nidecki</a>，一位非常专业的 Technical Content Writer ，目前是 <a href=\"https://www.acunetix.com/\" rel=\"nofollow noreferrer\">Acunetix</a> 的技术内容撰写人，他是一名拥有 25 年 IT 经验的记者、翻译和技术撰稿人，Tomasz 早年曾担任《 hakin9 IT Security 》杂志的总编辑，并曾经运营过一个专门针对电子邮件安全的主要技术博客。</p> \n</blockquote> \n<p>HSTS 是 HTTP 严格传输安全（HTTP Strict Transport Security） 的缩写。 这是一种网站用来声明他们只能使用安全连接（HTTPS）访问的方法。 如果一个网站声明了 HSTS 策略，浏览器必须拒绝所有的 HTTP 连接并阻止用户接受不安全的 SSL 证书。 目前大多数主流浏览器都支持 HSTS (只有一些移动浏览器无法使用它)。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316265\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>在 2012 年的 <a href=\"https://tools.ietf.org/html/rfc6797\" rel=\"nofollow noreferrer\">RFC 6797</a> 中，HTTP严格传输安全被定义为网络安全标准。 创建这个标准的主要目的，是为了避免用户遭受使用 SSL stripping（剥离） 的 <a href=\"https://www.acunetix.com/blog/articles/man-in-the-middle-attacks/\" rel=\"nofollow noreferrer\">中间人攻击（man-in-The-middle，MITM）</a>。 SSL stripping 是一种攻击者强迫浏览器使用 HTTP 协议连接到站点的技术，这样他们就可以嗅探数据包，拦截或修改敏感信息。 另外，HSTS 也是一个很好的保护自己免受 cookie 劫持（cookie hijacking）的方法。</p> \n<h2>HSTS 工作原理</h2> \n<p>通常，当您在 Web 浏览器中输入 URL 时，您会跳过协议部分。 例如，你输入的是 <code>www.acunetix.com</code>，而不是 <code>http://www.acunetix.com</code>。 在这种情况下，浏览器假设你想使用 HTTP 协议，所以它在这个阶段发出一个 <a href=\"https://www.acunetix.com/blog/articles/http-security-introduction-to-http-part-1/\" rel=\"nofollow noreferrer\">HTTP 请求</a> 到 <code>www.acunetix.com</code>，同时，Web Server 会返回 301 状态码将请求重定向到 HTTPS 站点。 接下来浏览器使用 HTTPS 连接到 <code>www.acunetix.com</code>。 这时 HSTS 安全策略保护开始使用 HTTP 响应头：</p> \n<pre><code>Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</code></pre> \n<p>响应头的 <code>Strict-Transport-Security</code> 给浏览器提供了详细的说明。 从现在开始，每个连接到该网站及其子域的下一年（31536000秒）从这个头被接收的时刻起必须是一个 HTTPS 连接。 HTTP 连接是完全不允许的。 <strong>如果浏览器接收到使用 HTTP 加载资源的请求，则必须尝试使用 HTTPS 请求替代。 如果 HTTPS 不可用，则必须直接终止连接</strong>。</p> \n<p>此外，如果证书无效，将阻止你建立连接。 通常来说，如果 HTTPS 证书无效（如：过期、自签名、由未知 CA 签名等），浏览器会显示一个可以规避的警告。 <strong>但是，如果站点有 HSTS，浏览器就不会让你绕过警告。 若要访问该站点，必须从浏览器内的 HSTS 列表中删除该站点</strong>。</p> \n<p>响应头的 <code>Strict-Transport-Security</code> 是针对一个特定的网站发送的，并且覆盖一个特定的域名（domain）。 因此，如果你有 HSTS 的 <code>www.acunetix.com</code> ，它不会覆盖 <code>acunetix. com</code>，而只覆盖 <code>www</code> 子域名。 这就是为什么，为了完全的保护，你的网站应该包含一个对 base domain 的调用（在本例中是 acunetix. com） ，并且接收该域名的 <code>Strict-Transport-Security</code> 头和 <code>includeSubDomains</code> 指令。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316264\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<h2>HSTS 是否完全安全？</h2> \n<p>不幸的是，你第一次访问这个网站，你不受 HSTS 的保护。 如果网站向 HTTP 连接添加 HSTS 头，则该报头将被忽略。 这是因为攻击者可以在中间人攻击（man-in-the-middle attack）中删除或添加头部。 HSTS 报头不可信，除非它是通过 HTTPS 传递的。</p> \n<p>你还应该知道，每次您的浏览器读取 header 时，HSTS <code>max-age</code> 都会刷新，最大值为两年。 这意味着保护是永久性的，只要两次访问之间不超过两年。 如果你两年没有访问一个网站，它会被视为一个新网站。 与此同时，如果你提供 <code>max-age</code> 0 的 HSTS header，浏览器将在下一次连接尝试时将该站点视为一个新站点（这对测试非常有用）。</p> \n<p>你可以使用称为 HSTS 预加载列表（HSTS preload list）的附加保护方法。<strong> Chromium 项目维护一个使用 HSTS 的网站列表，该列表通过浏览器发布</strong>。 如果你把你的网站添加到预加载列表中，浏览器会首先检查内部列表，这样你的网站就永远不会通过 HTTP 访问，甚至在第一次连接尝试时也不会。 这个方法不是 HSTS 标准的一部分，但是它被所有主流浏览器(Chrome、 Firefox、 Safari、 Opera、 IE11 和 Edge)使用。</p> \n<p>目前唯一可用于绕过 HSTS 的已知方法是基于 NTP 的攻击。 如果客户端计算机容易受到 <a href=\"https://www.blackhat.com/docs/eu-14/materials/eu-14-Selvi-Bypassing-HTTP-Strict-Transport-Security.pdf\" rel=\"nofollow noreferrer\">NTP 攻击（ NTP-based attack）</a>，它可能会被欺骗，使 HSTS 策略到期，并使用 HTTP 访问站点一次。</p> \n<h2>如何将域名添加到 HSTS 预加载列表？</h2> \n<p>要将域添加到 HSTS 预加载列表，该域的站点必须满足几个要求。 以下是添加域名所需的步骤：</p> \n<ol> \n <li>确保你的网站拥有有效的证书和最新的密码</li> \n <li>如果你的网站可以通过 HTTP 访问，请将所有请求重定向到 HTTPS</li> \n <li>确保以上第 1 点和第 2 点适用于你的所有域名和子域名（根据您的 DNS 记录）</li> \n <li>通过 HTTPS 服务返回 <code>Strict-Transport-Security</code> header ，带上 <code>base domain</code> 和 <code>max-age</code> ，<code>max-age </code> 至少为31536000 (1 年)，另外还有 <code>includeSubDomains</code> 指令和 <code>preload</code> 指令。 可以参考上面的 HSTS header。</li> \n <li>访问 hstspreload.org ，并使用表格提交你的域名。如果符合条件，您的域名将被加入队列。</li> \n</ol> \n<p>为了提高安全性，浏览器不能访问或下载 预加载列表（preload list）。 它作为硬编码资源（hard-coded resource）和新的浏览器版本一起分发。 这意味着结果出现在列表中需要相当长的时间，而域从列表中删除也需要相当长的时间。 <strong>如果你希望将你的站点添加到列表中，则必须确保您能够在较长时间内保持对所有资源的完全 HTTPS 访问。 如果不这样做，你的网站可能会完全无法访问</strong>。</p> \n<p>就像这样：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316266\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<h2>如何从浏览器的 HSTS 缓存中删除域？</h2> \n<p>在设置 HSTS 并测试它时，可能需要清除浏览器中的 HSTS 缓存。 如果你设置 HSTS 不正确，你可能会访问网站出错，除非你清除数据。 下面是几种常用浏览器的方法。 还要注意，如果你的域在 HSTS 预加载列表中，清除 HSTS 缓存将是无效的，并且无法强制进行 HTTP 连接。</p> \n<p>要从 Chrome HSTS 缓存中删除一个域名，请按照以下步骤操作：</p> \n<ol> \n <li>访问 <code>chrome://net-internals/#hsts</code> </li> \n <li>在 <code>Delete domain security policies</code>下的文本框中输入要删除的域</li> \n <li>点击文本框旁边的 Delete 按钮</li> \n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316268\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>之后，你可以检查移除是否成功：</p> \n<ol> \n <li>在 <code>Query HSTS/PKP domain</code> 下的文本框中输入要验证的域</li> \n <li>点击文本框旁边的 Query 按钮</li> \n <li>返回应该是 not found</li> \n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316267\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>Mozilla Firefox 、Safari 和 Microsoft Edge 自行查看原文吧。</p>', 'https://segmentfault.com/img/remote/1460000022316263', null, null, '0', '0', null, '1', '2020-04-14 20:58:18', '2020-04-14 20:58:18');
INSERT INTO `tb_recommend` VALUES ('02a2cd649b3d4f29b8a75f685de1260e', '服务网格平台探索性指南', '开发人员需要确保跨服务的通信是安全的。他们还需要实施分布式跟踪，以告知每次调用需要多长时间。重试，断路器等分布式服务的一些最佳实践为服务带来了弹性。微服务通常是多语言的，并使用不同的库和SDK。编写通...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFq1z\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sm01.jpg\" title=\"sm01.jpg\"></span></p> \n<p>向微服务的转变面临着一系列挑战。如果认为微服务的架构，设计和开发很复杂，那么部署和管理它们也同样复杂。</p> \n<p>开发人员需要确保跨服务的通信是安全的。他们还需要实施分布式跟踪，以告知每次调用需要多长时间。重试，断路器等分布式服务的一些最佳实践为服务带来了弹性。微服务通常是多语言的，并使用不同的库和SDK。编写通用的可重用软件来管理跨HTTP，gRPC和GraphQL等不同协议的服务内通信非常复杂，昂贵且耗时。</p> \n<p>部署基于微服务的应用程序后，上线之后的运维将由DevOps团队执行。他们需要监视服务运行状况，延迟，日志，事件和跟踪。 DevOps团队还有望实施基于策略的路由，以配置蓝/绿部署，金丝雀版本和滚动升级。最后，需要将源自多个微服务的指标，事件，日志和警报进行汇总，并与现有的可观察性和监视技术栈集成。</p> \n<p>服务网格是云原生和微服务世界中的一种新现象，它试图为开发人员和运营商解决这些问题。在容器编排之后，如果有一项技术引起了开发人员和操作员的注意，那么绝对是服务网格。云原生倡导者建议在生产环境中运行微服务时使用服务网格。</p> \n<p>服务网格使开发人员无需构建特定于语言的SDK和工具来管理服务内通信。对于运营商而言，服务网格可提供即用型流量策略，可观察性以及来自堆栈的洞察力。</p> \n<p>服务网格的最好之处在于它是一种“零侵入”软件，不会强制更改代码或配置。通过利用sidecar的模式，服务网格将代理注入到每个服务中，充当主机服务的代理。由于代理会拦截每个入站和出站调用，因此它可以在调用堆栈中获得无与伦比的可见性。与服务相关联的每个代理将从调用堆栈收集的遥测发送到集中式组件，该组件还充当控制平面。运营商配置流量策略时，会将其提交到控制平面，控制平面将该策略推送到代理中以影响流量。软件可靠性工程师（SRE）利用服务网格的可观察性来深入了解应用程序。</p> \n<p>服务网格与现有的API网关或Kubernetes入口控制器集成在一起。 API网关和入口处理南北流量时，服务网格负责东西向流量。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFq3H\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sm02.jpg\" title=\"sm02.jpg\"></span></p> \n<p>总而言之，服务网格是实现安全的服务到服务通信的基础结构层。它依赖于与每个微服务一起部署的轻量级网络代理。集中式控制平面协调代理以管理流量策略，安全性和可观察性。</p> \n<p>即使服务网格主要与打包为容器的微服务一起使用，它也可以与VM甚至物理服务器集成。通过有效利用服务网格的流量策略，可以无缝集成跨多个环境运行的应用程序。这个因素使服务网格成为混合云和多云的关键推动因素之一。</p> \n<p>有多种服务网格可供企业选择。本文试图帮助比较和对比云原生生态系统中可用的一些主流服务网格平台。</p> \n<h3>AWS App Mesh</h3> \n<p>AWS App Mesh在AWS re：Invent 2018上推出，旨在将服务网格的优势带到Amazon Web Services的计算和容器服务中。可以使用Amazon EC2，Amazon ECS，AWS Fargate，Amazon EKS甚至AWS Outposts轻松配置它。</p> \n<p>由于App Mesh可以充当VM和容器的服务网格，因此Amazon基于虚拟服务，虚拟节点，虚拟路由器和虚拟路由创建了一个抽象层。</p> \n<p>虚拟服务代表部署在VM或容器中的实际服务。虚拟服务的每个版本都映射到一个虚拟节点。虚拟服务和虚拟节点之间存在一对多关系。部署新版本的微服务后，只需将其配置为虚拟节点即可。类似于网络路由器，虚拟路由器充当虚拟节点的端点。虚拟路由器具有一条或多条遵循流量策略和重试策略的虚拟路由。网格对象充当所有相关实体和服务的逻辑边界。</p> \n<p>代理与参与网格的每个服务相关联，该代理处理网格内流动的所有流量。</p> \n<p>假设我们在AWS中运行两项服务：servicea.apps.local和serviceb.apps.local。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFq5p\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sm03.png\" title=\"sm03.png\"></span></p> \n<p>我们可以轻松地启用这些服务的网格，而无需修改代码。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFq5C\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sm04.png\" title=\"sm04.png\"></span></p> \n<p>我们注意到，serviceb.apps.local具有虚拟服务，一个虚拟节点，一个具有两个虚拟路由的虚拟路由器，这些虚拟路由决定了发送到微服务的v1和v2的流量的百分比。</p> \n<p>与大多数服务网格平台一样，AWS App Mesh也依赖于开源Envoy代理数据平面。 App Mesh控制平面在构建时考虑了AWS计算服务。亚马逊还定制了Envoy代理以支持此控制平面。</p> \n<p>将AWS App Mesh与Amazon EKS结合使用时，您将获得自动sidecar注入的好处以及在YAML中定义App Mesh实体的能力。亚马逊为EKS构建了CRD，以简化带有标准Kubernetes对象的App Mesh的配置。</p> \n<p>AWS App Mesh生成的遥测可以与Amazon CloudWatch集成。指标可以导出到第三方服务（例如Splunk，Prometheus和Grafana）以及开放式跟踪解决方案（例如Zipkin和LightStep）。</p> \n<p>对于使用AWS计算服务的客户，AWS App Mesh是免费的。 AWS App Mesh不收取任何额外费用。</p> \n<h3>Consul Connect</h3> \n<p>HashiCorp的Consul作为具有内置键/值数据库的服务发现平台而启动。它充当在同一主机或分布式环境中运行的服务的高效，轻量级负载均衡器。Consul公开用于发现注册服务的DNS查询接口。它还对所有注册的服务执行健康检查。</p> \n<p>在容器和Kubernetes成为主流之前就已经创建了Consul。但是微服务和服务网格的兴起促使HashiCorp将Consul扩展为功能完善的服务网格平台。服务网格扩展Consul Connect使用相互传输层安全性（TLS）提供服务到服务的连接授权和加密。</p> \n<p>有关实施Consul的详细说明和分步指南，请参阅我的<a href=\"https://thenewstack.io/implementing-service-discovery-of-microservices-with-consul/\" rel=\"nofollow noreferrer\">Consul Service Discovery</a>和<a href=\"https://thenewstack.io/implement-a-service-mesh-with-consul-connect/\" rel=\"nofollow noreferrer\">Consult Connect教程</a>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFq6I\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sm05.png\" title=\"sm05.png\"></span></p> \n<p>由于sidecar模式是服务网格的首选方法，因此Consul Connect带有自己的代理来处理入站和出站服务连接。基于插件体系结构，Envoy可以用作Consul Connect的替代代理。</p> \n<p>Consul Connect向Consul添加了两个基本功能-安全性和可观察性。</p> \n<p>默认情况下，Consul将TLS证书添加到服务端点以实现相互TLS（mTLS）。这样可以确保始终对服务之间的通信进行加密。安全策略是通过intentions实现的，这些intentions定义了服务的访问控制并用于控制哪些服务可以建立连接。intentions可以拒绝或允许来自特定服务的流量。例如，数据库服务可以拒绝直接来自Web服务的入站流量，但允许通过业务逻辑服务发出的请求。</p> \n<p>当Envoy用作Consul Connect的代理时，它将利用L7的可观察性功能。可以将与Consul Connect集成的Envoy配置为将遥测发送到各种来源，包括statsd，dogstatsd和Prometheus。</p> \n<p>根据上下文，Consul可以充当客户端（代理）或服务器，当与Nomad和Kubernetes等编排器集成时，它支持Sidecar注入。有一张Helm chart可以在Kubernetes中部署Consul Connect。 Consul Connect配置和元数据作为注释添加到提交给Kubernetes的pod规范中。它可以与Ambassador集成，后者是Datawire的入口控制器，用于处理南北向流量。</p> \n<p>Consul缺乏用于实施蓝/绿部署或Canary版本的高级流量路由和拆分功能。与其他服务网格选择相比，它的安全流量策略不是很灵活。通过Envoy的集成，可以配置一些高级路由策略。但是，Consul Connect没有为此提供接口。</p> \n<p>总体而言，Consul和Consul Connect是健壮的服务发现和网格平台，易于管理。</p> \n<h3>Istio</h3> \n<p>Istio是由Google，IBM和Red Hat支持的最受欢迎的开源服务网格平台之一。 </p> \n<p>Istio还是最早使用Envoy作为代理的服务网格技术之一。它遵循与微服务关联的集中式控制平面和分布式数据平面的标准方法。 </p> \n<p>尽管Istio可以与虚拟机一起使用，但是它主要与Kubernetes集成。可以将部署在特定名称空间中的Pod配置为具有自动sidecar注入功能，其中Istio会将数据平面组件附加到Pod。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFq9t\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sm06.jpg\" title=\"sm06.jpg\"></span></p> \n<p>Istio为微服务开发人员和运营商提供了四种主要功能：</p> \n<ul> \n <li> <strong>流量管理</strong>：Istio简化了诸如断路器，超时和重试之类的服务级别属性的配置，并使其易于实现基于百分比的流量拆分的配置，如A/B测试，canary部署和分段式部署。它还提供了开箱即用的故障恢复功能，有助于使您的应用程序更强大，以防止相关服务或网络的故障。 Istio带有自己的Ingress，可处理南北向流量。</li> \n <li> <strong>扩展性</strong>：WebAssembly 是一种沙盒技术，可以用于扩展 Istio 代理（Envoy）的能力。Proxy-Wasm 沙盒 API 取代了 Mixer 作为 Istio 主要的扩展机制。在 Istio 1.6 中将会为 Proxy-Wasm 插件提供一种统一的配置 API。</li> \n <li> <strong>安全</strong>：Istio为服务内通信提供了开箱即用的安全功能。它提供了基础安全通信通道，并大规模管理服务通信的身份验证，授权和加密。借助Istio，默认情况下就可以保护服务通信，从而使开发人员和操作员可以在各种协议和运行时之间一致地执行策略，而无需更改代码或配置。</li> \n <li> <strong>可观察性</strong>：由于Istio的数据平面拦截了入站和出站流量，因此可以了解当前的部署状态。 Istio提供了强大的跟踪，监视和日志记录功能，可深入了解服务网格部署。 Istio带有集成的和预先配置的Prometheus和Grafana仪表板，以提高可观察性。</li> \n</ul> \n<p>Google和IBM将托管的Istio作为其托管Kubernetes平台的一部分提供。 Google将Knative构建为基于Istio的无服务器计算环境。对于Anthos和Cloud Run等Google服务，Istio已成为其核心基础。与其他产品相比，Istio被认为是一个复杂而繁重的服务网格平台。但是可扩展性和丰富的功能使其成为企业的首选平台。</p> \n<h3>Kuma</h3> \n<p>Kuma于2019年9月启动，是服务网格生态系统的最新参与者之一。它是由API网关公司Kong，Inc开发和维护的，该公司以相同的名称Kong来构建开源和商业产品。</p> \n<p>Kuma是对Kong API网关的逻辑扩展。前者处理南北流量，而后者处理东西向流量。</p> \n<p>像大多数服务网格平台一样，Kuma带有单独的数据平面和控制平面组件。控制平面是服务网格的核心支持者，它支持所有服务配置的基本原理，并且可以无限扩展以管理整个组织中的成千上万的服务。 Kuma将快速数据平面与高级控制平面相结合，允许用户通过Kubernetes或REST API中的自定义资源定义（CRD）轻松设置权限，公开指标并设置路由策略。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFrdn\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sm07.png\" title=\"sm07.png\"></span></p> \n<p>Kuma的数据平面与Envoy代理紧密集成，使数据平面可以在Kubernetes中部署的虚拟机或容器中运行。 Kuma有两种部署模式：</p> \n<p>1）通用<br>2）Kubernetes。</p> \n<p>在Kubernetes中运行时，Kuma利用API服务器和etcd数据库存储配置。在通用模式下，它需要外部PostgreSQL作为数据存储。</p> \n<p>控制平面组件Kuma-cp管理一个或多个数据平面组件kuma-dp。在网格上注册的每个微服务都运行kuma-dp的唯一副本。在Kubernetes中，kuma-cp在kuma系统名称空间内作为CRD运行。为kuma注释的名称空间可以将数据平面注入每个pod中。</p> \n<p>Kuma附带了一个GUI，可提供部署概述，包括向控制平面注册的每个数据平面的状态。可以使用相同的界面查看来自附加到微服务的代理的运行状况检查，流量策略，路由和跟踪。</p> \n<p>Kuma服务网格具有内置的CA，用于基于mTLS加密流量。可以基于与微服务关联的标签来配置流量许可。跟踪可以与Zipkin集成，而指标可以重定向到Prometheus。</p> \n<p>Kuma缺少一些先进的弹性功能，例如断路，重试，故障注入和延迟注入。</p> \n<p>Kuma是精心设计的干净的服务网格实现。它与Kong Gateway的集成可能会推动其在现有用户和客户中的采用。</p> \n<h3>Linkerd 2.x</h3> \n<p>Linkerd 2.x是Buoyant专为Kubernetes构建的开源服务网格。它获得了Apache V2的许可，并且是一个Cloud Native Computing Foundation孵化项目。</p> \n<p>Linkerd是一个超轻便，易于安装的服务网格平台。它具有三个组件– 1）CLI和UI，2）控制平面和3）数据平面。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFreL\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sm08.png\" title=\"sm08.png\"></span></p> \n<p>一旦将CLI安装在可以与Kubernetes群集通信的计算机上，就可以使用单个命令安装控制平面。控制平面的所有组件都作为Kubernetes部署安装在linkerd名称空间中。 Web和CLI工具使用控制器的API服务器。目标组件将路由信息告知运行数据平面的代理。注入器是Kubernetes准入控制器，每次创建Pod时都会接收Webhook请求。该服务用于将代理作为sidecar注入到命名空间中启动的每个pod。身份组件负责管理对实现代理之间的mTLS连接至关重要的证书。点击组件从CLI和Web UI接收请求，以实时监视请求和响应。</p> \n<p>Linkerd随附了预配置的Prometheus和Grafana组件，提供了现成的仪表板。</p> \n<p>数据平面具有轻量级代理，可将其作为辅助工具附加到服务。有一个Kubernetes初始化容器来配置iptables来定义流量，并将代理连接到控制平面。</p> \n<p>Linkerd符合服务网格的所有属性-流量路由/拆分，安全性和可观察性。</p> \n<p>有趣的是，Linkerd并未使用Envoy作为代理。相反，它依赖于用Rust编程语言编写的专用轻量级代理。 Linkerd的堆栈中没有内置入口，但可以与入口控制器配合使用。</p> \n<p>在Istio之后，Linkerd是流行的服务网格平台之一。考虑到轻量级且易于使用的服务网格，它吸引了开发人员和运营商的注意力。</p> \n<h3>Maesh</h3> \n<p>Maesh来自于Containous，该公司建立了流行的 ingress Traefik。与Kong，Inc类似，Containous建立了Maesh以补充Traefik。当Maesh处理微服务中的东西向流量时，Traefik则驱动着南北向流量。与Kuma一样，Maesh也可以与其他入口控制器一起使用。</p> \n<p>与其他服务网格平台相比，Maesh采用了不同的方法。它不使用边车模式来操纵流量。相反，它为每个Kubernetes节点部署了一个Pod，以提供定义良好的服务端点。即使部署了Maesh，微服务也可以继续工作。但是，当他们使用Maesh公开的替代终结点时，他们可以利用服务网格功能。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFrfF\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sm09.jpg\" title=\"sm09.jpg\"></span></p> \n<p>Maesh的目标是提供一种非侵入性和非侵入性的基础架构，为开发人员提供选择功能。但这也意味着该平台缺少某些关键功能，例如透明TLS加密。 </p> \n<p>Maesh支持服务网格的基本功能，包括路由和可观察性（安全性除外）。它支持Service Mesh Interface（SMI）项目定义的最新规范。 </p> \n<p>在我在Kubernetes中部署的所有服务网格技术中，我发现Maesh是最简单，最快的平台。</p>', 'https://segmentfault.com/img/bVbFq1z', null, null, '0', '0', null, '1', '2020-04-14 20:58:28', '2020-04-14 20:58:28');
INSERT INTO `tb_recommend` VALUES ('1101b19775fd420094f78e183e3cd2dd', '谷歌十年愚人节，「玩笑」背后是美好生活的企盼', '2010 年愚人节，谷歌宣布公司将更名为托皮卡。谷歌在公司官方博客中称，“美国堪萨斯州首府托皮卡市市长比尔·顿本（Bill Bunten）本月初宣布，托皮卡市要将名称改为谷歌，这令全世界吃惊。我们一直疑惑如何实现这...', '<h3>2010 年：宣布更名为托皮卡公司（Topeka Inc）</h3> \n<p>2010 年愚人节，谷歌宣布公司将更名为托皮卡。谷歌在公司官方博客中称，“美国堪萨斯州首府托皮卡市市长比尔·顿本（Bill Bunten）本月初宣布，托皮卡市要将名称改为谷歌，这令全世界吃惊。我们一直疑惑如何实现这种互换。现在我们高兴地宣布，从 4 月 1 日凌晨 1 点起，谷歌已正式将名称改为托皮卡。”谷歌调侃称，公司更名将带来一些影响，如从现在开始，所有信件都将寄给托皮卡公司而非谷歌。曾经被称为“ Google 员工”的同学，现在会被称为“ Topekers”或“ Topekans”。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022230822\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>2011 年：Google 穿越搜索</h3> \n<p>Google 穿越搜索为谷歌中国 2011 年 4 月 1 日推出的一个网站，声称可以穿越时空，不过这只是一个愚人节笑话。据报道，这次愚人节笑话导致一千六百多万的网友被骗，并不断增加中。</p> \n<p>什么是穿越搜索？谷歌自己解释为“穿越搜索是利用搜索引擎内置的引力场扭曲功能，在关键词超时空渗透技术的基础上，将搜索者的全身电磁表征分解后，降频发送到目标时空重新组合匹配，以实现搜索者思维的跨时空穿越并获取目标时空信息的新一代搜索技术。”</p> \n<p>简单地说，谷歌穿越搜索就是为穿越者在时空的另一头建立了一个 100% 等同的思维克隆体镜像并保持跨时空的实时信息传递。</p> \n<p>谷歌特别指出，用户在进行穿越前，需要保证衣冠整洁，头发光鲜，并“认真做一遍谷歌穿越体操”，否则无法穿越。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022230821\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>穿越到最后，谷歌提示只是愚人节发布的一个笑话，并解释：“物理学迄今还没有为时空机器找到可靠的理论依据。不过，借助谷歌提供的网页搜索、图片搜索、时空隧道等功能，大家的确可以了解不同时间、地点发生的事件，获知更多信息。”</p> \n<h3>2012 年：推出水下搜索体验</h3> \n<p>2012 年愚人节谷歌在浏览器搜索框下方增加了“Google 推出水下搜索，立即体验”字样。点击进入，用户会发现页面下方变成一块水域，鱼儿不停游动。谷歌 Logo、搜索框和搜索按钮都漂浮在水中。更有趣的是，无论用户搜索任何关键词，均会从上方落入水中。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022230824\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"搜索“Apple”，水果纷纷坠入水中\" title=\"搜索“Apple”，水果纷纷坠入水中\"></span></p> \n<p>搜索“Apple”，水果纷纷坠入水中</p> \n<h3>2013 年：Google 嗅觉</h3> \n<p>Google 嗅觉是谷歌于 2013 年愚人节所推出的恶搞，它号称是一个试验计划，由约 1500 万个气字节所建构的香味数据库，通过 Google 街景车记录空气中的气味并创建索引。用户需要到 Google 首页，搜索有关想要闻的东西，点击「试闻」后再点击「开始嗅闻」，就能闻到你所搜索的气味。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022230823\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>2014 年：Google 地图神奇宝贝（宠物小精灵）大挑战</h3> \n<p>Google Maps - Google 地图神奇宝贝（宠物小精灵）是谷歌于 2014 年愚人节所推出的恶搞，可以将虚拟的口袋妖怪附加在实景地图中。当用户在扫描实景时找到妖怪，就可以查看相关的口袋妖怪信息，然后丢出“宠物球”即可进行捕捉。</p> \n<p>捕捉到最多口袋妖怪的精英不仅能够获得“口袋妖怪大师”称号，而且还有机会前往谷歌总部任职！谷歌地图甚至一本正经地标注道：“本次挑战赛的副作用可能包括极度的兴奋感和成就感，在开车和操纵重型机械时请勿操作。”</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022230827\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Google 内部的创业公司 Niantic 后来与任天堂和精灵宝可梦公司合作，在 2016 年推出扩增实境游戏精灵宝可梦 GO（精灵宝可梦为神奇宝贝新官方名称），使得两年前 Google 开的这个玩笑变成了现实。</p> \n<h3>2015 年： Google 地图吃豆人</h3> \n<p>Google 地图把道路变成了经典游戏「吃豆人」的游戏地图，当用户在使用导航时，会看见由豆子组成的路线图，根据地图上显示的情况，避开幽灵标记，以便安全到达目的地。如果用户觉得饿了，还可以吞吃豆子或樱桃。吃豆人地图导航使用起来十分简单，选择地点只需按上、下、左、右即可。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022230825\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>2016 年：Cardboard Plastic</h3> \n<p>Cardboard Plastic 是 Google 为了应 VR 热推出的恶搞，将一块完全就是普通塑料的罩子，一本正经的当做一款性能超强、防水防摔的 VR 眼镜去介绍……甚至还专门为此拍摄了一段视频，为了愚人节真是很拼了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022230830\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>2017 年：Google 火星数据中心</h3> \n<p>火星数据中心是 Google 2017 年推出的恶搞项目之一，据介绍，Google 为了避免地球发生意外时用户存储的备份资料丢失，为大家提供将资料搬上火星的存储方案，并表示将于 2018 年启用火星数据中心 Ziggy Stardust，Google Cloud Storage (GCS) 也将提供新的存储区域 Earth-Mars Multi-Regional。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022230826\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Google 火星数据中心内部实景\" title=\"Google 火星数据中心内部实景\"></span></p> \n<p>Google 火星数据中心内部实景</p> \n<h3>2018 年：Google Maps 推出「Where\'s Wally」小游戏</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022230828\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在愚人节当天，将 Google Maps 换成「Where’s Wally」小游戏，网友只要通过电脑、iOS 及 Android 端应用开启 Google Maps，便会发现图标，按下即可游玩。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022231171\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Google 限时推出的游戏与原书《Where\'s Wally》本质是一样的，就是在人山人海的人群里，找到那个总是躲在奇怪地方的该死威利还有他不明所以的朋友们，和他弄丢的奇怪东西。</p> \n<blockquote>\n 《Where\'s Wally》（也译《威力在哪里？》、《大家一起找沃里？》、《聪明的沃里？》，是一套由英国插画家 Martin Handford 创作的儿童书籍。这本书的目标就是在一张人山人海的图片中找出一个特定的人物——威利。威利穿着红白条纹的衬衫并戴着一个绒球帽，手上拿着木制的手杖，还戴着一副眼镜。他总是会弄丢东西，如书本、野营设备甚至是他的鞋子，而读者也要帮他在图中找出这些东西来。\n</blockquote> \n<h3>2019 年：谷歌 Files 应用可以“从里到外”清理手机</h3> \n<p>谷歌开发的 Files 应用能够清理设备的内存空间，愚人节当天谷歌推出了屏幕清洁功能，能够“冲走污渍、擦亮屏幕”。谷歌表示屏幕清洁功能采用的是“污渍识别器应用程序接口”，利用几何污点模型以及触觉微运动发生器识别屏幕上的污渍。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022230829\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>2020 年：谷歌内部邮件显示，取消今年 4 月 1 日愚人节玩笑传统</h3> \n<p>3 月 30 日消息，谷歌决定取消今年的愚人节玩笑传统，谷歌的内部邮件显示，出于对所有与新冠病毒疫情抗争的人的尊重，今年该公司将停止在各种产品中发布愚人节彩蛋。</p> \n<p>每年的愚人节恶搞已经成为谷歌的传统，很多「玩笑」的背后也是科技公司对未来美好生活的企盼，让我们看到先进科技的运用，未来生活的雏形。</p> \n<blockquote>\n 以上内容整理自网络。\n</blockquote>', 'https://segmentfault.com/img/remote/1460000022230822', null, null, '0', '0', null, '1', '2020-04-14 20:58:28', '2020-04-14 20:58:28');
INSERT INTO `tb_recommend` VALUES ('275a1e3a4c71498899b66aa25e6228b8', '我的本科回忆录：从迷茫自卑到保送华科', '今天看新闻，多地高三终于开学了，看着他们风华正茂的样子，想着他们几个月后就要成为大学校园的一份子，我自己不禁也感慨万千。 说长不长，说短不短，距离我踏入大学本科校园的日子也已经过去快11年了。 我觉得...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022298589\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<hr> \n<p>今天看新闻，多地高三终于开学了，看着他们风华正茂的样子，想着他们几个月后就要成为大学校园的一份子，我自己不禁也感慨万千。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022298588\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>说长不长，说短不短，距离我踏入大学本科校园的日子也已经过去快<code>11</code>年了。</p> \n<p>我觉得我们这代90后年轻人还是蛮累的，毕业之后奔向四方，只顾着不顾一切的往前冲，甚至来不及追忆自己的青春与成长。</p> \n<p>正好趁着这个机会，这会有点上头，就写点文字来分享一下我的本科经历和心路历程吧，对于我个人来说也是一个青春的追忆。</p> \n<p>正好也顺便来聊聊本科阶段该如何度过、有些节奏应该怎么把握、有些事情又该如何取舍，以及一些心态的调整问题，因为总有小伙伴私信说很迷茫，很纠结。</p> \n<hr> \n<h2>01</h2> \n<p>首先，我讲讲我自己本科阶段的实际情况。</p> \n<p>我本科没有参加过任何的协会、社团、学生会。是的，我很想进，但是一个都没进去。不瞒你说，各种尝试去面试，结果全都被刷了。我在自卑、迷茫和焦躁中度过了我的大一。</p> \n<p>记得大一时候的我成绩不是太好，班级117个人，我的排名在四十多的样子。第一学年勉强拿了个三等奖学金，几百块钱，我为此还闷闷不乐很久，心里还想着，觉得自己其实蛮努力的。</p> \n<p>直到多年后我才明白，在大一的美好时光里，可能自己还是迷茫、跟风、目光总是在别人身上，才导致很多事情没有深入的做下去。</p> \n<hr> \n<h2>02</h2> \n<p>大二暑假，我有过一段时间不长的实验室经历，但我基本上啥也没学着。我是怎么进来的，怎么出去的，我没能融入得了那个环境，我放弃了。</p> \n<p>本科阶段我也没有任何大型的比赛经历，大二那时候，电赛（全国大学生电子设计竞赛）的初期参与了，后期没参与，更别说上场比赛了。我恋家，暑假呆了大半个月我跑回去了。</p> \n<hr> \n<h2>03</h2> \n<p>慢慢的，经过了几番折腾尝试之后，我的杂念少了一些，因为我知道其他同学那些繁华的世界和我基本没什么关系了，当然我也承认这跟我的个人性格有关。</p> \n<p>虽然到现在我也不愿意承认，但那时候其实自己也没得选择，所以只能一个劲顾着搞学习，大二、大三真是把自习室的牢板都坐穿了……</p> \n<p>很幸运的是，但到了大三末，经过两年的孤独和努力，专业成绩搞了个全系第一，我竟然拿到了保送华科硕士研究生的资格。我开始变得坦然起来了，觉得自己并不是一无是处。</p> \n<hr> \n<h2>04</h2> \n<p>回首过往，我内心其实知道，本科阶段总体来讲过得<strong>很无聊</strong>，但<strong>不算空虚</strong>吧，我只能这么安慰自己。</p> \n<p>本科阶段，尤其是大一和大二，我作为一个非常孤独的个体，还是非常羡慕那些在社团和学生会混得风生水起，个个都有女朋友的那波人，因为跟他们相比，我觉得自己有些自卑。</p> \n<hr> \n<h2>05</h2> \n<p>所以接下来聊聊我对于本科阶段的一些看法吧，因为咱这里年轻的小伙伴多。</p> \n<p>大一课不多，而且全是认知性的课程，我觉得可以抽出一部分精力来考虑参加社团、学生会，协会等等。可能还是因为我在本科阶段一直没有得到这个，所以一直很羡慕，就算现在阔别校园这么多年也还是很羡慕！因为我觉得这也是同学少年时代的一种独特的经历跟体验。但好在这个不是必选项，如果比较内向或者仅仅是因为跟风的因素而其实内心并不太想参加的，可以不去。</p> \n<hr> \n<h2>06</h2> \n<p>大一、大二尽量把英语四六级给过了吧，尤其四级，不过的话很麻烦，后面不论就业、考研还是保研。</p> \n<hr> \n<h2>07</h2> \n<p>大二下、大三<strong>这一年半</strong>的时间里，一定要开始要逐步地寻找自己的目标。要考研的，就好好学习专业课、复习专业课；对技术有兴趣的，就开始规划好技术路线来学习技术，扎实推进，定一个个小目标慢慢实现，慢慢激励自己；当然，如果对考研、学技术都没有兴趣的，我觉得也没问题，你要是能找到自己内心的寄托那再好不过了。</p> \n<hr> \n<h2>08</h2> \n<p>很多小伙伴问我到底要不要<strong>进实验室</strong>的话题，好像很纠结这个事情，我个人是觉得，这个问题你既然问出来了，我个人感觉其实你内心可能没有那么想去。</p> \n<p>进实验室这个事情千万不要跟风，一定要根据自己的内心兴趣来。我的亲身经历告诉你，如果不进实验室也没有问题，不要有心理包袱。学校的实验室里做的东西，其实也没有那么高深，你仅凭个人之力花精力学，也不会差哪儿去。</p> \n<hr> \n<h2>09</h2> \n<p>大三下的<strong>实习与否</strong>我个人觉得倒还好，没必要因为这个焦虑得睡不着觉。</p> \n<p>我觉得实习这个事情最起码可以为<strong>两件事</strong>让路：第一个是考研的充分准备、第二个则是校招的充分准备，切勿因小失大。</p> \n<p>因为很多找的实习，也没那么有技术含量，对找工作的加分也没有那么大，要是去打酱油那就有点浪费时间了，除非说能拿到一些大厂的实习offer。</p> \n<p>当然，这纯属我个人意见，小伙伴们仅供参考。</p> \n<hr> \n<h2>10</h2> \n<p>最后，还有一些额外的心里话。</p> \n<p>首先，我觉得大学阶段最最重要的还是建立起对专业的认知、以及培养独立思考和独立解决问题的能力，这个比什么都重要；</p> \n<p>本科阶段的成绩其实没有那么没用，大家尽可能还是注意一下为好，后续保研、进研究所、国家机关、事业单位啥的多多少少还是看成绩单的，毕竟都喜欢培养那种根正苗红的学生；</p> \n<p>关于班干部这件事，我觉得其实是可以努力争取一下的，毕竟可以多接触老师，多跟老师交流肯定不是一件坏事；</p> \n<p>大学阶段还是多结交几个志同道合的真心朋友吧，坦诚相待，少一点套路，这可能是你以后整个人生道路上的风景；</p> \n<p>最后，如果能找到心仪的对象，那是最好不过的，也可以努力争取一下；</p> \n<p>最后的最后，我尤其想跟那些本科阶段觉得自己孤独甚至自卑，但骨子里又想做出点什么的小伙伴们说的是：千万不要妄自菲薄，一定找到属于自己内心的寄托，并为此坚定不移地奋斗三年，你一定会变得很坦然的！</p> \n<p>好吧，就聊这么多了。</p> \n<hr> \n<p>每天进步一点点，Peace！</p> \n<p>2020.04.07 晚</p>', 'https://segmentfault.com/img/remote/1460000022298589', null, null, '0', '0', null, '1', '2020-04-14 20:58:18', '2020-04-14 20:58:18');
INSERT INTO `tb_recommend` VALUES ('27d50428c5c1437ebc9c06b4cec1df7e', 'DoKit - 滴滴开源的一款功能齐全的客户端（ iOS 、Android ）研发助手', 'SegmentFault 思否消息：滴滴技术团队今天宣布，Dokit 3.0 版本正式发布，DoraemonKit，简称 DoKit，中文名哆啦 A 梦，是滴滴开源的一款功能齐全的客户端（ iOS 、Android ）研发助手。', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p>SegmentFault 思否消息：滴滴技术团队今天宣布，Dokit 3.0 版本正式发布，DoraemonKit，简称 DoKit，中文名哆啦 A 梦，是滴滴开源的一款功能齐全的客户端（ iOS 、Android ）研发助手。</p> \n<p>每一个稍微有点规模的 App，总会自带一些线下的测试功能代码，比如环境切换功能、帧率查看功能等等，这些功能的切换入口往往放在各式各样的入口中，比如一些特殊的手势，双击 statusBar，双击某一个功能区块，或者新建一个 keyWindow 始终至于 App 最上方等等，而且每一个 App 里面的线下附带功能模块很多是相似的，比如帧率查看、内存和 CPU 监控等等，但是现在基本上都是每个 App 都是自己实现了一份，经历了以上的问题之后，DoraemonKit 就有了它存在的意义。</p> \n<p>DoraemonKit 是一个功能平台，能够让每一个 App 快速接入一些常用的或者你没有实现的一些辅助开发工具、测试效率工具、视觉辅助工具，而且能够完美在 Doraemon 面板中接入你已经实现的与业务紧密耦合的一些非通有的辅助工具，并搭配<a href=\"https://www.dokit.cn/\" rel=\"nofollow noreferrer\">dokit</a>平台，让功能得到延伸，接入方便，便于扩展。</p> \n<p><strong>简单总结</strong></p> \n<p>1、DoraemonKit 能够快速让你的业务测试代码能够在这里统一管理，统一收口； <br>2、DoraemonKit 内置很多常用的工具，避免重复实现，一次接入，你将会拥有强大的工具集合。 3、搭配<a href=\"https://www.dokit.cn/\" rel=\"nofollow noreferrer\">dokit</a>平台，方便你进行<strong>数据mock</strong>以及记录你的每一次<strong>健康体检</strong>用例</p> \n<h4>效果演示</h4> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022238554\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"DoKit 首页效果演示\" title=\"DoKit 首页效果演示\"></span></p> \n<h3><strong>DoKit 3.0 版本新特性</strong></h3> \n<p><strong>▍</strong><strong>优化点</strong></p> \n<ul> \n <li>DoKit 3.0 相比于上一个版本一共解决了 github 上的 issues 70 多个，合并 PR 30 多个；</li> \n <li>内部架构升级，其中性能和代码的健壮性都得到了显著的提升；</li> \n <li>工具优化用户体验优化。</li> \n</ul> \n<p><strong>Android</strong></p> \n<p>Android 端主要优化了网络拦截、悬浮窗、位置模拟、Aop 解决方案等等：</p> \n<ul> \n <li>网络拦截统一了 okhttp、urlconnection；</li> \n <li>悬浮窗新增了普通模式，不再需要系统悬浮窗权限；</li> \n <li>位置模拟现已支持百度、腾讯、高德、系统原生；</li> \n <li>AOP 的代码插装方案也由一开始的 Aspectj 改成了 ASM 方案，兼容性和性能也都有了明显的提升。</li> \n</ul> \n<p><strong>iOS</strong></p> \n<p>iOS 端主要优化了多个工具的用户体验、加速代码安装速度、减少对于业务方的影响等等：</p> \n<ul> \n <li>NSLog 监控、子线程 UI、CocoaLumberjack 日志日志监控等功能不需要重新启动 App 即可进行开关；</li> \n <li>pod 仓库多地备份（github、gitee、gitlab），解决 pod install 缓慢的问题；</li> \n <li>解决 DoKit 的 window 影响 UIMenuController 的吗，导致业务方在某些机型弹不出来的问题；</li> \n <li>减少代码 hook 对于全局的影响；</li> \n <li>全局支持中英文切换。</li> \n</ul> \n<p><strong>▍</strong><strong>新增工具</strong></p> \n<p>以下新增的大部分 Kit 在 Android 和 iOS 两端是对齐的，有些平台特有的功能会进行标注。</p> \n<p><strong>1）数据&nbsp;Mock</strong></p> \n<p>提供一套基于 App 网络拦截的接口 Mock 方案，无需修改代码即可完成对于接口数据的 Mock。</p> \n<p>了解详情：<a href=\"https://www.dokit.cn/#/index/productCenter\" rel=\"nofollow noreferrer\">https://www.dokit.cn/#/index/productCenter</a></p> \n<p>了解更多可以查看文章《<a href=\"https://mp.weixin.qq.com/s/hXaeH1nVELA2PJDfJqLlvw\" rel=\"nofollow noreferrer\">滴滴正式发布开源客户端研发助手DoKit 3.0，新特性解读</a>》</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFmMq\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"思否公众号\" title=\"思否公众号\"></span></p>', 'https://segmentfault.com/img/remote/1460000022238554', null, null, '0', '0', null, '1', '2020-04-14 20:58:27', '2020-04-14 20:58:27');
INSERT INTO `tb_recommend` VALUES ('284b1b6b01f245a8916c2b6dd894b9eb', '好玩、有趣的 Linux 命令学习神器 kmdr！', '所以，大家也会遇到这样的情况，不太懂的命令用法，我们会去查找资料。据不完全统计，Linux系统常见的命令约600+个，一时间想全部掌握太难了，特别对于一个初学者来说，更是难上加难。', '<p><strong>大家好，我是你们的民工哥。</strong> </p> \n<p>所有学习Linux系统的初学者都知道，入门时除了简单的系统知识需要了解之外，其次，最重要的就是学习与理解Linux命令的用法与其应用场景。 </p> \n<p>所以，大家也会遇到这样的情况，不太懂的命令用法，我们会去查找资料。据不完全统计，Linux系统常见的命令约600+个，一时间想全部掌握太难了，特别对于一个初学者来说，更是难上加难。 </p> \n<p>我在公众号的后台、技术交流群，经常看到很多人都会遇到这种苦恼，命令长时间不练，不敲，很快就会全部忘记，等到应用时，再去查看帮助，又有点模糊不清，找不准其使用方法与参数的应用。</p> \n<p>特别是需要多个命令去配合完成一个工作的时候，更难下手去写，有时候，就算群里有人给出了相关的答案，他还是一时很难理解其中的<strong>含义是什么？<strong><em><em>为什么是这样配合使用的？</em></em></strong>为什么需要使用这个参数？</strong>一连串的问题接踵而至，但你这样一问，难免让回复你的人望而却步！ </p> \n<p>如果，这个时候<strong>有一个命令解释器的工具存在，那将是多么的完美！</strong></p> \n<p>那么，今天，民工哥给大家<strong>安利一款实用、好玩的命令学习神器：kmdr。</strong></p> \n<p><strong>传送门：<a href=\"https://github.com/ediardo/kmdr-cli\" rel=\"nofollow noreferrer\">https://github.com/ediardo/km...</a></strong></p> \n<p><strong>kmdr&nbsp;的强大之处在于</strong></p> \n<ul> \n <li>如果您在使用Linux终端命令时遇到困难，Kmdr可以帮助您解密它们。这是一个有用的工具，特别是对于初学者Linux用户。</li> \n <li>它可以帮助您轻松学习CLI命令，而无需离开终端，也无需浏览冗长的手册页。Kmdr不仅提供Linux命令，还提供了许多CLI命令的解释</li> \n</ul> \n<p><strong>支持列表如下</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022226937\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>查看完整的支持列表：</p> \n<p><a href=\"https://github.com/ediardo/kmdr-cli#supported-programs)\" rel=\"nofollow noreferrer\">https://github.com/ediardo/km...</a></p> \n<h5>安装 Kmdr CLI</h5> \n<p>===========</p> \n<p>kmdr 是用&nbsp;Nodejs&nbsp;开发出来免费、开源的工具，所以，对于安装环境要求如下：</p> \n<ul> \n <li>Node.js v8.x及更高版本</li> \n <li>包管理器，例如npm或yarn</li> \n</ul> \n<p>使用npm包安装kmdr的命令如下：</p> \n<pre><code>$&nbsp;npm&nbsp;install kmdr@latest --global</code></pre> \n<p>如果不想安装的话，也可以直接使用在线的kmdr，web地址如下：<strong><a href=\"http://demo.kmdr.sh/\" rel=\"nofollow noreferrer\">http://demo.kmdr.sh/</a></strong></p> \n<h5><strong>macOS安装命令</strong></h5> \n<pre><code>brew&nbsp;install&nbsp;kommandr / tap / kmdr</code></pre> \n<h5><strong>检查安装情况</strong></h5> \n<p>==========</p> \n<p>运行命令kmdr以检查它是否已正确安装在系统上。</p> \n<pre><code>$ kmdr\n\nUsage: kmdr [options] [command]\n\nThe ultimate CLI learning tool&nbsp;for&nbsp;explaining commands from your terminal\n\nkmdr provides&nbsp;command&nbsp;explanations&nbsp;for&nbsp;hundreds of programs including git,docker, kubectl, npm,&nbsp;go&nbsp;and&nbsp;more straight forward programs such&nbsp;as&nbsp;bash builtins.\n\nOptions:&nbsp;&nbsp;\n-v, --version&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output the&nbsp;version&nbsp;number\n-h, --help&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;output usage information\n\nCommands:\nexplain|e&nbsp;[options] Explain&nbsp;a&nbsp;shell&nbsp;command\nupgrade|u          Check&nbsp;for&nbsp;new&nbsp;releases\nfeedback|f&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Send feedback :)</code></pre> \n<h5><strong>kmdr还可以通过容器的方式来运行</strong></h5> \n<p>具体的步骤如下： </p> \n<p>1、构建镜像</p> \n<pre><code>docker&nbsp;build -t kmdr-cli</code></pre> \n<p>2、运行容器</p> \n<pre><code>docker run -it&nbsp;--rm kmdr-cli</code></pre> \n<p><strong>使用 Kmdr 在终端中显示 CLI 命令说明</strong></p> \n<p>下面我们通过一条复杂点的命令作为例子，来看看 kmdr 究竟有多强！</p> \n<pre><code>git&nbsp;commit&nbsp;-am&nbsp;\"Initial commit\"</code></pre> \n<p>首先，运行下面的命令，让 kmdr 进入解释状态：</p> \n<pre><code>$ kmdr&nbsp;explain\n? Enter your command: git&nbsp;commit&nbsp;-am&nbsp;\"Initial commit\"\n\ngit&nbsp;commit&nbsp;-am&nbsp;\"Initial commit\"&nbsp;\n\nEXPLANATION&nbsp;\ngit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The stupid&nbsp;content&nbsp;tracker\ncommit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Record&nbsp;changes&nbsp;to&nbsp;the repository\n-a,&nbsp;--all&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Tell the command&nbsp;to&nbsp;automatically stage files that have been modified&nbsp;and&nbsp;deleted\n-m,&nbsp;--message Initial commit&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Use&nbsp;the given &lt;msg&gt;&nbsp;as&nbsp;the&nbsp;commit&nbsp;message\n\nEXAMPLES\n   git&nbsp;reset&nbsp;HEAD~1\n    Undo&nbsp;the most recent&nbsp;commit, keeping its changes&nbsp;in&nbsp;the filesystem\n    \n    git&nbsp;commit&nbsp;-m&nbsp;\"Initial commit\"\n          Commit&nbsp;staged files&nbsp;to&nbsp;the repository&nbsp;with&nbsp;message&nbsp;\"Initial commit\"&nbsp;\n    \n    git&nbsp;log&nbsp;-n&nbsp;3&nbsp;--oneline&nbsp;\n          Show&nbsp;only&nbsp;the&nbsp;first&nbsp;line&nbsp;of&nbsp;the&nbsp;last&nbsp;three&nbsp;commit&nbsp;messages&nbsp;&nbsp;\n\nRELATED PROGRAMS&nbsp;&nbsp;&nbsp;&nbsp;hg, lsof, systemctl, aria2c, dmesg, make</code></pre> \n<p>从上面的结果可以看出，kmdr的强大之处就在于它会把一个复杂的命令拆分开来，一个个给你解释出来 ，连参数的含义都解释的很清楚，让你一眼就能看出其中的意思。</p> \n<p>通过这个强大的神器kmdr，再难懂的命令都可以通过它解释给你，<strong>哪里不懂，看哪里，</strong>妈妈再也不用担心我们再看不懂命令了！</p> \n<p><strong>参考资料</strong></p> \n<ul> \n <li><a href=\"https://kmdr.sh/\" rel=\"nofollow noreferrer\">官方网站</a></li> \n <li><a href=\"http://twitter.com/kmdr\" rel=\"nofollow noreferrer\">官方Twitter</a></li> \n</ul>', 'https://segmentfault.com/img/remote/1460000022226937', null, null, '0', '0', null, '1', '2020-04-14 20:58:28', '2020-04-14 20:58:28');
INSERT INTO `tb_recommend` VALUES ('4346e1b6666746c9a435c8eb9c763803', '限时0元免费领!!! 8门程序员进阶必修课、机械键盘等多重好礼等你来拿!', '2020开始，一场疫情突然袭来。 企业延迟开工、学校延迟开学、取消考试及比赛等事件打乱了每个人的计划。 很多人待在家浑浑噩噩，但他们不知道有一部分人却在这个时间段疯狂充实自己！ ​ 国内疫情已经基本控制住，...', '<p><strong>2020开始，一场疫情突然袭来。</strong></p> \n<p><strong>企业延迟开工、学校延迟开学、取消考试及比赛等事件打乱了每个人的计划。</strong></p> \n<p><strong>很多人待在家浑浑噩噩，但他们不知道有一部分人却在这个时间段疯狂充实自己！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365419\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span>​</p> \n<p><strong>国内疫情已经基本控制住，各地都在热火朝天的忙复工。你，在干嘛呢？</strong></p> \n<p><strong>疫情让求职市场竞争更加激烈，学习技能和掌握知识才是这个时候最应该做的！</strong></p> \n<p><strong>你是否后悔没有抓住这个宝贵时间好好充实自己？不用担心！思否编程来帮你！</strong></p> \n<p><strong>思否编程提供了8门程序员进阶必修课，掌握它们不仅能充实简历拿到好Offer，学完Python等语言后更能让你从简单重复的工作中脱离出来，感受到自动化办公的愉悦。当然提高薪资也会变成自然而然的事情。</strong></p> \n<p><strong>思否编程为了鼓励大家战胜疫情，精心选择了8门程序员必修课程免费提供给大家之外。还给前来学习的同学提供机械键盘、32G U盘等精美好礼。</strong></p> \n<p><strong>还等什么马上扫描下方海报中的二维码来领取吧！</strong><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0EJ\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"WechatIMG104.jpeg\" title=\"WechatIMG104.jpeg\"></span></p> \n<p><strong>扫描海报二维码 奖品和课程免费领↑↑↑</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365418\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>本次战疫活动的福利解读！</strong></p> \n<h2>福利一：精美礼品轻松拿</h2> \n<p><strong>本次活动给大家带来了两个精美礼品。</strong></p> \n<p><strong>马上来拿价值300元的罗技机械键盘（限量，按排名）</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365417\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>马上来拿价值69元的思否定制U盘（限量，按排名）</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365416\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>福利二：8大进阶课程免费看</h2> \n<h5>跟我学用 Serverless 开发接龙小程序</h5> \n<p><strong>内容介绍：</strong></p> \n<ol> \n <li>Serverless 简介</li> \n <li>小程序简介</li> \n <li>开发接龙小程序</li> \n</ol> \n<p><strong>讲师：</strong>翟路佳 花名“肉山”，全栈工程师，就职于 OpenResty Inc.，关注前端里各种垂直深耕的领域</p> \n<h5>走进互联网应用—从单体应用到微服务</h5> \n<p><strong>内容介绍：</strong>绍目前互联网应用开发的主流框架，包括：Spring、SpringMVC、MyBatis、SpringBoot 以及 SpringCloud，讲解技术更新迭代的过程，以及大型项目的架构设计思想。 <br><strong>讲师：</strong>恒哥 资深Java高级工程师</p> \n<h5>Node.js 代码调试</h5> \n<p><strong>内容介绍：</strong>直播中会对 Node.js 代码调试进行简单的介绍与 ESLint 静态代码检查的展示，并将在直播当中进行打印调试与交互调试的讲解教学。 <br><strong>讲师：</strong>王顶 河北经贸大学讲师、企业研究生导师，微软认证工程师 MCSE、MCP、MCT</p> \n<h5>webpack性能优化-代码分割</h5> \n<p><strong>内容介绍：</strong>详细讲解webpack做代码分割的各种姿势 <br><strong>讲师：</strong>starkwang 资深前端工程师</p> \n<h5>Python最佳实践</h5> \n<p><strong>内容介绍：</strong>本次课程分享如何把Python写得优雅，并且达到工程上的最佳实践。 <br><strong>讲师：</strong>凯威 资深工程师</p> \n<h5>迎接Vue 3.0</h5> \n<p><strong>内容介绍：</strong></p> \n<ul> \n <li>Vue 3.0 的新变化</li> \n <li>开发团队的设计思路（为什么会有这些变化）</li> \n <li>我们应该怎么准备</li> \n</ul> \n<p><strong>讲师：</strong>翟路佳 全栈工程师</p> \n<h5>网络安全之 Kali 渗透入门实战</h5> \n<p><strong>内容介绍：</strong></p> \n<ul> \n <li>Kali 系统的安装与汉化</li> \n <li>使用 nmap 对目标安全扫描</li> \n <li>使用 MSF 对 Windows 渗透</li> \n <li>使用 ettercap 中间人欺骗</li> \n</ul> \n<p><strong>讲师：</strong>汤青松 PHP 高级工程师</p> \n<h5>玩转 CI/CD — 打造高效可靠的软件开发流程</h5> \n<p><strong>内容介绍：</strong></p> \n<ul> \n <li>利用 CI/CD 可以打造高效的开发流程。</li> \n <li>CI/CD 打造的全自动流程让你的软件系统无比可靠。</li> \n <li>CI/CD 本质上是一套方法论，可以用开源系统也可以用脚本实现，框架层面可以说没有难度。这个方法论鼓励你从繁琐的劳动中解放出来，把精力用在系统设计，写优雅的代码和接口，写测试代码，把一切能自动化的操作都交给机器。</li> \n</ul> \n<p><strong>讲师：</strong>凯威 资深工程师 </p> \n<p><strong>强大的师资力量</strong> </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365420\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365421\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>用户的评价</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365422\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365423\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365425\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365424\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>免费领取总计花费上千小时磨练，价格高达上千元的课程。帮助热爱学习的同学高效学习，快速转行，挑战高薪。</strong></p> \n<p><strong>重要提示：</strong></p> \n<blockquote>\n 活动时间：课程限量1000份，限量领完为止\n <p>奖品公告：中奖名单可在排行榜中自行查看 </p> \n <p>如有问题请扫描下方二维码↓↓↓<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFYk8\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"思否小姐姐.png\" title=\"思否小姐姐.png\"></span></p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365426\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>好啦，看到这里估计大家已经迫不及待去领取了，原价上千元的课程，今天大家可以0元领取，不过最后提醒一下大家只有1000个名额哦！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365427\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>扫描上方二维码↑↑↑马上领取好课与精美礼品</strong></p>', 'https://segmentfault.com/img/remote/1460000022365419', null, null, '0', '0', null, '1', '2020-04-14 20:58:15', '2020-04-14 20:58:15');
INSERT INTO `tb_recommend` VALUES ('452db9a216e44135ac5b3e2f7578dbdb', '2020年，一文点破跨平台开发框架现状', '多年来，跨平台移动开发已经获得了最流行软件开发趋势之一的声誉。这并不令人意外，因为采用跨平台开发技术使得软件工程师使用同一代码就能为不同平台构建应用程序，从而节省时间、金钱以及不必要的工作。', '<p>原文出处：<a href=\"https://dzone.com/articles/cross-platform-mobile-development-2020-trends-and\" rel=\"nofollow noreferrer\">https://dzone.com/articles/cr...</a></p> \n<p>多年来，跨平台移动开发已经获得了最流行软件开发趋势之一的声誉。这并不令人意外，因为采用跨平台开发技术使得软件工程师使用同一代码就能为不同平台构建应用程序，从而节省时间、金钱以及不必要的工作。</p> \n<h2>移动市场的现状</h2> \n<p>截至2019年12月，全球活跃网民已超45亿。他们每人平均上网时间为6小时42分钟，相当于每年上网超过100天。 <br>再加上人们越来越渴望从掌上设备中获取海量的信息，也就为之所以移动应用程序会如此受到欢迎提供了合理的解释。截至 2019 年，全球移动应用收入达 4610 亿美元，预计到 2023 年，付费下载和应用内广告的收入预计将超过 9350 亿美元。</p> \n<h2>移动开发的技术选型</h2> \n<p>十年前，老板们必须决定他们的产品将涵盖哪些移动操作系统：Android、iOS、微软、RIM或Symbian。而今天，初创公司的创始人正面临着一个不同的两难抉择，由于Android和iOS占据了移动操作系统市场份额的98%，很显然这两个系统不容忽视，覆盖什么平台不再是问题。但问题是，构建一个在两个平台上都可以使用的应用程序应该采用什么方法？</p> \n<h3>每个操作系统对应一种开发环境</h3> \n<p>顾名思义，用于开发Android用的是Java或Kotlin，用于开发iOS则是Objective-C或SWIFT。作为开发不同应用而使用不同的开发语言，对开发者而言并不是一个好消息。 <br>虽然特定的开发环境对特定的操作系统拥有对资源更高效的调配效率，可防止发生性能问题。但缺点也很显而易见，你的开发人员需要使用不同的开发语言构建两个独立的应用程序，这需要付出更多的时间、金钱和精力。</p> \n<h3>渐进式Web应用程序（PWA）</h3> \n<p>其中一个能解决问题的例子是<a href=\"https://www.merixstudio.com/blog/progressive-apps-taking-over-mobile-industry/\" rel=\"nofollow noreferrer\">渐进式 Web 应用</a>（PWA），它基本上是模仿原生应用程序行为的一个网站（例如，在发送推送通知、脱机工作，或者只是添加到移动设备的主屏幕上)。然而，就像任何其他选项一样，PWA也不是完美无缺的，因为它们消耗更多的电池，并且不能授予应用使用设备的所有功能。</p> \n<h3>跨平台应用程序开发</h3> \n<p>但还好我们还有一个跨平台开发的选项，它允许用一段代码同时为两个操作系统开发应用。它并不固定使用某一种平台的编程语言编写代码。而且，由于直接使用了系统原生控件来呈现界面，它能为用户提供近乎原生平台应用的使用体验。</p> \n<h2>我要不要使用跨平台开发这项技术？</h2> \n<p>下面，我会通过一系列维度来帮助你去评估你是否应该采用跨平台开发这种形式来适配你的业务。</p> \n<h3>平台</h3> \n<p>首先，也是最重要的，您需要决定您的应用程序是需要在一个还是多个操作系统上可用。如果您的目标群是由不同平台的用户组成的，那么跨平台开发将是首选的解决方案。</p> \n<p>另一方面，如果你的用户群体只是Android或iOS的某一支，那么用原生解决方案来开发是你的首选。</p> \n<h3>复杂性</h3> \n<p>此标准涉及你希望与产品走多远。解决此问题的一种方法是你的目标是使用MVP测试你的愿景，或是你准备使用成熟的应用程序开始运行。您需要回答的另一个问题是产品的功能(例如，访问移动设备的硬件或特定于平台的功能)。</p> \n<h3>原生体验</h3> \n<p>你的用户是否需要使用原生或近似原生的体验。使用Material Design(Android)或Human Interface Guidance(iOS)来设计的移动应用程序是移动产品对用户直观且友好的原因所在。在设计移动应用程序时应要考虑这些，但是，你可以使用跨平台框架来实现类似的效果。</p> \n<h3>时间和成本</h3> \n<p>有一点是肯定的，原生开发成本不低、效率也不高。为不同的平台构建不同的应用程序需要雇佣更多的开发人员，这可能会导致初创公司在项目初期就超出紧张的项目预算。同时，如果采用跨平台的方法，你可以将项目外包给一个规模较小但同样专业的团队，这既是一个省时的解决方案，也是一个具有成本效益的解决方案。</p> \n<h2>跨平台移动应用开发的优点（和缺点）</h2> \n<p>假设你已经得出结论，你更倾向于跨平台的移动应用程序开发，但是在下决心之前，你需要对此解决方案的优缺点进行彻底的了解，没关系，下面我逐一为你列举。</p> \n<h3>跨平台移动应用程序开发的好处</h3> \n<h4>更广泛的市场覆盖范围</h4> \n<p>虽然我们每个人都有自己喜欢的移动操作系统，但个人喜好不会妨碍你业务的成功。让Android和iOS用户同时可以使用您的移动应用，能在未来提升更高的收录打下基础。</p> \n<h4>一套代码</h4> \n<p>跨平台开发允许您同时编写包含多个操作系统的代码（有时也会有处理平台差异）。尽管如此，一套代码肯定会影响软件开发过程中的所有阶段，因为它可能为你节省通常花在修复和升级两组独立代码上的成本。</p> \n<h4>更高效的发布流程</h4> \n<p>尽管只需要一套代码，但跨平台应用程序开发仍然需要开发人员考虑处理系统差异的方法，例如发布应用到平台商店的过程。</p> \n<p>这种方法将缩短从设计到发布的时间。换句话讲，这可以为你节省很大一笔初始项目预算。</p> \n<h4>平台一致性</h4> \n<p>毫无疑问，Android和iOS在用户体验和用户界面方面都有很大的不同，这些差异中的大多数部分都能通过跨平台开发框架帮你默认处理，这使得设计和实际表现不一致的情况发生的可能性进一步降低。</p> \n<h3>有什么缺点？</h3> \n<p>尽管有上述各种优点，但它也绝不是一点缺点没有，它的主要缺点包括性能可能较低及略差的用户体验和用户界面等。</p> \n<h2>2020年还有哪些跨平台移动开发框架值得考虑</h2> \n<p>虽然跨平台的移动APP开发有利有弊。但从业务初创的角度来看，优点应该是大于缺点的。而且，随着对跨平台移动应用需求的不断增长，现在可用的工具和框架数量也已经很可观了。</p> \n<p>但选择过多会令人头疼，这就是为什么我们只关注最突出的跨平台移动开发框架的原因：React Native, Flutter, NativeScript, 和Xamarin。</p> \n<p>为了让你更深入地了解是什么使这些工具成为2020年软件开发的可选选项，我们将根据以下标准对它们进行打分：社区支持、基于的编程语言、代码可重用性、性能、界面以及使用它们构建的重要应用程序。</p> \n<h3>React Native</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022237119\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Reaction Native是Facebook于2015年发布的开源、跨平台的应用开发框架。作为2013年举办的一场内部黑客马拉松的产物，它已经成为最受欢迎的原生App开发替代方案之一，拥有2043名GitHub贡献者，获得了超过82900 GitHub标星。不断增长的社区认知度使得找到一支可靠且经验丰富的开发团队来承接你的项目变得相对容易。</p> \n<h4>Learn Once and Write Anywhere</h4> \n<p>基于React.JS，React Native利用JavaScript(根据2019年Stack Overflow的调查，JavaScript成为了最受欢迎的编程语言)，为Android和iOS用户提供真正原生的应用外观和体验。另外，使该框架脱颖而出的是，如果你需要，React Native允许你使用Java、Objective-C或SWIFT编写部分原生模块来顺利处理复杂的操作，如视频播放或图像编辑。</p> \n<p>虽然这些组件不能在不同的平台之间共享，并且需要开发人员做更多的工作，但多达90%的React Native代码是可以重用的。很好地表明该框架的座右铭不是“Write Once, Use&nbsp;Anywhere”，而是“learn once, write anywhere”。</p> \n<p>就GUI而言，React Native可以提供接近原生的用户体验，这要归功于它使用了Android和iOS的本地控制器。它还使用带有UI元素的ReactJS库，这有助于加快UI设计过程。在开发移动应用程序时，使此框架值得考虑的另一个原因是，它可用在不丢失应用程序状态的情况下对UI进行更改。</p> \n<p>另一个使React Native成为2020年跨平台移动开发框架的首选之一，是因为持续的更新，例如近期的版本 0.60 和 0.61&nbsp;：</p> \n<ul> \n <li>多项辅助功能改进。</li> \n <li>更清晰、更人性化的开始屏幕。</li> \n <li>快速刷新，融合了实时和热重新加载，从而显著加快了开发进程。</li> \n</ul> \n<p>如上的Release Note只是React Native适应不断变化的需求其中一个很小的样本。</p> \n<h3>Flutter</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022237118\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>2020年值得考虑的第二个框架是Flutter。它在Google I/O 2017上宣布，并于2018年发布，对于跨平台的世界来说，它现在仍然是一个“新人”。但尽管如此，它已经获得了超过80500 GitHub星标和绝大多数工程师将其称为2019年Stack Overflow调查中最受欢迎的三个框架之一，Flutter无疑是一股不可忽视的力量。</p> \n<h4>Dart是如何使Flutter变得独一无二的</h4> \n<p>Flutter 背后的编程语言是 Dart，谷歌称之为\"客户端优化\"，适合在任何平台上\"快速构建应用程序\"。它于 2011 年推出，是一种响应式面向对象的语言，被开发者认为相对容易学习，其中原因有二：第一，语法上它借鉴了C/C++ 和 Java; 第二，在<a href=\"https://dart.dev/guides\" rel=\"nofollow noreferrer\">官方网站上</a>，您可以找到内容广泛且相当简单的文档。值得一提的是，Dart 附带了大量<a href=\"https://pub.dev/flutter/packages\" rel=\"nofollow noreferrer\">Flutter 兼容软件包</a>的软件包，允许您使应用程序更加复杂。</p> \n<p>Flutter的一个主要优势是，它的性能比本文提到的任何其他跨平台移动开发框架都要好。这归功于Dart的编译器和Flutter拥有自己的一套小部件。结果是它能更快、更直接地与平台直接通信，而不需要JavaScript桥(例如，Reaction Native就是这种情况)。说到小部件：通过Flutter的“UI-as-a-code”方法，它们只用DART编写，这就提高了代码的可重用性。</p> \n<p>效率与用户体验和界面密不可分。如前所述，Flutter不依赖于一组原生组件，而是利用可视化、结构化、平台性和交互式小部件进行UI的设计，所有这些都由框架的图形引擎呈现。更重要的是，Flutter留下了很大的定制空间，如果你想要设计一个很完美的UI，它是个很好的选择。</p> \n<p>说到Flutter的更新，最新的稳定版本是在12月12日发布的，根据官方发布说明，它合并了来自188个贡献者的近2000个pull。例如，版本1.12.13中包括的改进：</p> \n<ul> \n <li>重大的API变动。</li> \n <li>新功能，例如SliverOpacity小部件和SliverAnimatedList。</li> \n <li>修复了崩溃和性能问题。</li> \n <li>Beta版中的Web支持。</li> \n</ul> \n<p>这不是一个完整的清单，因为Flutter的目标是让每年发布的四个版本中的每一个版本都能为框架的可用性提升一个台阶。</p> \n<p>Flutter是一个年轻的跨平台移动应用程序开发框架，所以它没有像React Native受到众多的大公司青睐也是不足为奇的。然而，这并不意味着它不好，截至2019年12月，它也为阿里巴巴、谷歌广告、Groupon等众多公司和业务所采用。</p> \n<h3>NativeScript</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022237120\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>如果你要开始开发你的产品，“React Native”和“Flutter”绝不是唯一的解决方案。在 2020 年初，适合您的企业的替代框架也可能是 NativeScript。</p> \n<p>这个开源框架于2015年3月公开发布，并迅速成为广受欢迎的解决方案。例如，在发布后的短短两个月内，它就获得了3000颗GitHub星标，并在Twitter上吸引了1500多名粉丝的关注。到今天为止，市场上已有超过700个插件可供选择。</p> \n<p>在使用NativeScript构建跨平台应用程序时，开发人员首先用JavaScript及其超集TypeScript编写代码。然后，将代码库编译成各自平台原生的编程语言。</p> \n<p>另外值得一提的是，使用 NativeScript 的开发人员也可以使用第三方库（CocoaPods 和 Android SDK），而无需包装。</p> \n<p>与React Native类似，NativeScript允许访问Android和iOS原生API，这对跨平台应用程序有明显的积极影响。然而，不同之处在于，前者需要构建桥接API，而后者（用Progress首席开发者倡导者TJ VanToll的话说是“将所有iOS和Android API注入JavaScript虚拟机”）。与Facebook框架的另一个相似之处在于代码重用，在这两种情况下都可以达到90%。</p> \n<h3>Xamarin</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022237117\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Xamarin开源框架创建于2011年，这使它成为了这个列表中最“古老“的框架，但直到五年前它被微软收购时，它才获得了发展势头。截至今天，它号称拥有超过6万名贡献者的社区。</p> \n<p>从技术上讲，要用Xamarin构建跨平台的移动应用，需要很好地掌握.NET和C#两种技术，前者是使用多种语言(包括C#编程语言)、编辑器和库的开发平台。Xamarin用一组工具补充了上述平台，这些工具有助于构建跨平台应用程序，例如库、编辑器扩展和XAML。第二种技术是C#，这是一种面向对象的编程语言，它被认为比JavaScript学习起来稍难。Xamarin利用这种编程语言编写整个应用程序，从后端到原生API，再到业务逻辑。</p> \n<h4>Xamarin.Native和Xamarin.Forms</h4> \n<p>Xamarin与其他框架的不同之处在于，它提供了两种编译跨平台移动应用的方式：Xamarin Native(也称为Xamarin.Android/iOS)和Xamarin.Forms。前一种方法优先考虑共享业务逻辑，并通过使用本机接口控件实现近乎本机的性能。</p> \n<p>后者侧重于共享代码，而不是业务原理，这一方面会导致代码重用比例增加(使用Xamarin，开发人员可以重用高达96%的C#代码)，但另一方面这样会降低代码性能。</p> \n<p>您可能已经注意到，跨平台移动应用程序的性能和GUI密切相关，所以如果我说Xamarin构建应用程序的两种方法对界面的最终外观有很大影响，我可能不会感到惊讶。</p> \n<p>Xamarin.Android/iOS允许开发人员使用原生控件和布局，而Xamarin.Forms基于标准UI元素，允许从单个API设计应用程序，但如果你需要更完美的原生UI，则可能还不够。</p> \n<h2>2020年跨平台应用程序开发还值得考虑吗？</h2> \n<p>不论如何，跨平台确实是一个值得考虑和极具前景的方向，特别是我们上面提到的 “React Native”和“Flutter”。</p> \n<p>前者是一个成熟而稳定的框架，利用了最流行的编程语言之一，并拥有成熟的大型开发人员社区。后者是一个快速发展的技术，尽管它比React Native年轻的多，它也已经赢得了世界各地许多开发人员的青睐。</p> \n<p>但无论您选择的是“React Native”、“Flutter”还是任何其他框架，跨平台方法都一定会为您节省时间和金钱，同时能为你最大限度地扩大市场覆盖范围。</p> \n<p>最后，值不值得考虑，最终还是取决于你的业务目标、预算和时限。</p>', 'https://segmentfault.com/img/remote/1460000022237119', null, null, '0', '0', null, '1', '2020-04-14 20:58:27', '2020-04-14 20:58:27');
INSERT INTO `tb_recommend` VALUES ('466da91715eb4b039bc48d157a319e22', '闲鱼Flutter图片框架架构演进（超详细）', '图片对一个端侧研发来说是一老生常谈的话题了。闲鱼作为业界在Flutter技术方向上最早一批投入的团队。从使用Flutter之初，图片就是我们核心关注和重点优化的功能。图片算是闲鱼业务场景下最为重要的内容表现形式...', '<p><strong>简介：</strong>flutter图片内存大？加载慢？本地资源利用率低？看这篇就够了</p> \n<p>作者：闲鱼技术-意境</p> \n<h2>1.那些年</h2> \n<p>图片对一个端侧研发来说是一老生常谈的话题了。闲鱼作为业界在Flutter技术方向上最早一批投入的团队。从使用Flutter之初，图片就是我们核心关注和重点优化的功能。图片算是闲鱼业务场景下最为重要的内容表现形式之一。图片展示体验的好坏会对闲鱼用户的使用体验产生巨大影响。你们是否也曾遇到过：</p> \n<ul> \n <li>图片加载内存占用过多？</li> \n <li>使用flutter以后本地资源重复，利用率不高？</li> \n <li>混合方案下Flutter原生图片加载效率不高？</li> \n</ul> \n<p>针对上述问题，从第一版Flutter业务上线开始，闲鱼对图片框架的优化就从未停止。从开始的原生优化，到后面黑科技的外接纹理；从内存占用，到包大小；文本会逐一介绍。希望其中的优化思路和手段，能给大家带去一些启发。</p> \n<h2>2. 原生模式</h2> \n<p>从技术层面看图片加载，其实简单来说，追求的是无非是加载的效率的最大化—用尽可能小的资源成本，尽可能快地加载尽可能多的图片。</p> \n<p>闲鱼图片的第一个版本其实基本上是纯原生的方案。如果你不想魔改很多底层的逻辑，原生方案肯定是最简单和经济的方案。原生方案的功能模块如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312435\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"原生图片方案的架构图\" title=\"原生图片方案的架构图\"></span></p> \n<p>如果你啥都没做直接上了，那么你可能会发现效果并没有达到你预期的那么美好。那么如果从原生的方案入手，我们有哪些具体的优化手段呢？</p> \n<h3>2.1. 设置图片缓存</h3> \n<p>没错猜对了，是<strong>缓存</strong>。对于图片加载，最能想到的方案就是使用缓存。首先原生Image的组件是支持自定义图片缓存的，具体的实现类是ImageCache。ImageCache的设置维度是两个方向： 1.缓存图片的张数。通过maximumSize设置。默认是1000张。2. 缓存空间的大小。 通过maximumSizeBytes 来设置。默认值100M。相比张数的限制，其实大小的设置方式更加符合我们的最终的预期。</p> \n<p>通过合理设置ImageCache的大小，能充分利用缓存机制加速图片加载。不仅如此，闲鱼在这个点上还做了额外两个重要优化：</p> \n<ol>\n <li>低端手机适配</li>\n</ol> \n<p>在上线以后，我们陆续收到线上舆情的反馈，发现全部机型设置同一个缓存大小的做法并非最优。特别是大缓存设置在低端机器上面，不仅会出现体验变差，甚至还会影响稳定性。基于实际情况，我们实现了一个能从Native侧获取机器基础信息的Flutter 插件。通过获取的信息，我们根据不同手机的配置设置不同的缓存策略。在低端机器上面适当降低图片缓存的大小，同时在高端手机上将其适当放大。这样能在不同配置的手机上获取最优的缓存性能。</p> \n<ol>\n <li>磁盘缓存</li>\n</ol> \n<p>熟悉APP开发的同学都知道，成熟的图片加载框架一般都有多级缓存。除了常见的内存缓存，一般都会配置一个文件缓存。从加载效率上来说，是通过空间换时间，提升加载速度。从稳定性来说，这又不会过分占用宝贵的内存资源，出现OOM。但是可惜的是，Flutter自带的图片加载框架并没有独立的磁盘缓存。所以我们在原生方案的基础上扩展了磁盘缓存能力。</p> \n<p>在具体的架构实现上，我们并没有完全自己撸一个磁盘缓存。我们的策略还是复用现有能力。首先我们将Native图片加载框架的磁盘缓存的功能通过接口暴露出来。然后通过桥接的方式，将Native 磁盘缓存能力嫁接到Flutter层。Flutter侧进行图片加载的时候，如果内存没有命中，就去磁盘缓存中进行二次搜索。如果都没有命中才会走网络请求。</p> \n<p>通过增加磁盘缓存，Flutter图片加载效率进一步提升。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312432\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"多级缓存\" title=\"多级缓存\"></span></p> \n<h3>2.2. 设置CDN优化</h3> \n<p>CDN 优化是另一个非常重要图片优化手段。CDN优化的效率提升主要是：最小化传输图片的大小。常见策略包括：</p> \n<ol>\n <li>根据显示大小裁剪</li>\n</ol> \n<p>简单来说，你要加载图片的真实尺寸，可能会大于你实际展示窗口的大小。那么你就没必要加载完整大图，你只需要加载一个能覆盖窗口大小的图片即可。通过这种方式，裁剪掉不需要的部分，就能最小化传输图片的大小。从端侧角度来说，一来可以提升加载速度，二来可以降低内存占用。</p> \n<ol>\n <li>适当压缩图片大小</li>\n</ol> \n<p>这里主要是根据实际情况增加图片压缩的比例。在不影响显示效果的情况下，通过压缩进一步降低图片的大小。</p> \n<ol>\n <li><strong>图片格式</strong></li>\n</ol> \n<p>建议优先使用webp这样格式，图片资源相对小。Flutter<strong>原生支持webp</strong>（包括动图）。这里特别强调一下webp动图不仅大小要比gif小很多，而且还对<strong>透明效果有更好的支持</strong>。webp动图是gif方案比较理想的一种替代方案。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312434\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"用图演示一下\" title=\"用图演示一下\"></span></p> \n<p>基于上述原因，闲鱼图片框架在Flutter侧实现了一套CDN尺寸匹配的算法。通过该算法，请求图片会根据实际显示的大小，自动匹配到最合适的尺寸上并适当压缩。如果图片格式允许，图片尽可能转化成webp格式下发。这样cdn图片的传输就能尽可能高效。</p> \n<h3>2.3. 其他优化</h3> \n<p>除了上面的策略，Flutter还有一些其他的手段可以优化图片的性能。</p> \n<ol>\n <li><strong>图片预加载</strong></li>\n</ol> \n<p>如果你想在展示的图片的尽可能的快，官方也提供了一套预加载的机制:<strong>precacheImage</strong>。precacheImage能预先将图片加载到内存，真正使用的时候就能秒出了。</p> \n<ol>\n <li><strong>Element复用优化</strong></li>\n</ol> \n<p>其实这个算是一个Flutter通用的优化方案。复写didWidgetUpdate方案，通过比较前后两次widget中针对图片的描述是否一致，来决定是否重新渲染Element。这样能避免同一个图片，不必要的反复渲染。</p> \n<ol>\n <li><strong>长列表优化</strong></li>\n</ol> \n<p>一般情况下，Listview是flutter最为常见的滚动容器。在Listview中的性能好坏，直接影响最终的用户体验。</p> \n<p>Flutter的Listview跟Native的实现思路并不相同。其最大的特点是有一个viewPort的概念。超出viewPort的部分会被强制回收掉。</p> \n<p>基于上述的原理，我们有两点建议：</p> \n<ol>\n <li>cell拆分</li>\n</ol> \n<p>尽量避免大型的cell出现，这样能大幅降低cell频繁创建过程中的性能损耗。其实这里影响的不仅仅是图片加载过程。文字，视频等其他组件也都应该避免cell过于复杂导致的性能问题。</p> \n<ol>\n <li>合理使用缓冲区</li>\n</ol> \n<p>ListView可以通过设置cacheExtent 来设置预先加载的内容大小。通过预先加载可以提升view渲染的速度。但是这个值需要合理设置，并非越大越好。因为预加载缓存越大，对页面整体内存的压力就越大。</p> \n<h3>2.4. 方案的不足</h3> \n<p>这里需要客观指出：如果是一个<strong>纯Flutter APP</strong>，<strong>原生方案是完善，够用的</strong>。但是如果从混合APP的角度来说，有如下两个缺陷：</p> \n<p><strong>1. 无法复用Native图片加载能力</strong></p> \n<p>毫无疑问，原生的图片方案是完全独立的图片加载方案。对于一个混合APP来说，原生方案和Native的图片框架相互独立，能力无法复用。例如CDN裁剪&amp;压缩等能力需要重复建设。特别是Native一些独特的图片解码能力，Flutter就很难使用。这会造成APP范围内的图片格式的支持不统一。</p> \n<p><strong>2. 内存性能不足</strong></p> \n<p>从整个APP的视角来说，采用原生图片方案的情况下，其实我们维护了两个大的缓存池：一个是Native的图片缓存，一个是Flutter侧的图片缓存。<strong>两个缓存无法互通</strong>，这无疑是一个巨大的浪费。特别是对内存的峰值内存性能产生了<strong>非常大的压力</strong>。</p> \n<h2>3. 打通Native</h2> \n<p>经过多轮优化，基于原生的方案已经获得了非常大的性能提升。但是整个APP的内存水位线依然比较高（特别是Ios端）。现实的压力迫使我们继续对图片框架进行更深度的优化。基于上述原生方案缺点的分析，我们有了一个大胆的想法：能否完全复用Native的图片加载能力？</p> \n<h3>3.1. 外接纹理</h3> \n<p>怎样打通Flutter和Native的图片能力？我们想到了外接纹理。外接纹理并非是Flutter自有的技术，他是音视频领域常用的一种性能优化手段。</p> \n<p>这个阶段我们基于shared-Context的方案实现了Flutter和Native的纹理外接。通过该方案，Flutter可以通过共享纹理的方式，拿到Native图片库加载好的图片并展示。为了实现这个纹理共享的通道，我们对engine层做了深度定制。细节过程如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312433\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>该方案不仅打通了Native和Flutter的图片架构，整个过程图片加载的性能也得到了优化。想要了解细节的同学可以继续阅读这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/42566807\" rel=\"nofollow noreferrer\">万万没想到——Flutter外接纹理</a>。</p> \n<p>外接纹理是闲鱼图片方案的一次大跨越。通过该技术，我们不仅实现图片方案的本地能力复用，而且还能实现视频能力的纹理外接。这避免了大量重复的建设，提升了整个APP的性能。</p> \n<h3>3.2. 多页面内存优化</h3> \n<p>这个优化策略是真真被逼出来的。在对线上数据分析以后，我们发现Flutter页面栈有一个非常有意思的特点：</p> \n<p><strong>多页面栈情况下，底层的页面不会被释放</strong>。即便是在内存非常紧张的情况下，也不会执行回收。这样就会导致一个问题：随着页面的增多，内存消耗会线性增长。这里占比最高的就是图片资源的占比了。</p> \n<p>是不是可以在页面处于页面栈底层的时候直接回收掉该页面内的图片呢？</p> \n<p>在这个想法的驱动下，我们对图片架构进行了新一轮的优化。整个图片框架中的图片都会监听页面栈的变化。当方发现自己已经处于非栈顶的时候，就自动回收掉对应的图片纹理释放资源。这种方案能使图片占用的内存大小不会随着页面数的变多呈现持续线性增长。原理如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312437\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"TB1mF0NbZKfxu4jSZPfXXb3dXXa-780-558.png\" title=\"TB1mF0NbZKfxu4jSZPfXXb3dXXa-780-558.png\"></span></p> \n<p>需要注意的是：这个阶段页面判断位置其实是需要页面栈（具体来说就是混合栈）<strong>提供额外的接口</strong>来实现的。系统之间的耦合相对较高。</p> \n<h3>3.3. 意外收获包大小</h3> \n<p>打通Native和Flutter侧图片框架以后，我们发现了一个意外收获: Native和Flutter可以共用本地图片资源了。也就是说，我们不再需要将相同的图片资源在Flutter和Native侧各保留一份了。这样能大幅提升本地资源的复用率，从而降低整体的包大小。基于这个方案，我们实现了一套资源管理的功能，脚本能自动同步不同端的本地图片资源。通过这样提升本地资源利用率，降低包大小。</p> \n<h3>3.4. 其他优化</h3> \n<ol>\n <li><strong>PlaceHolder强化</strong></li>\n</ol> \n<p>原生的Image是没有PlaceHolder功能的。如果想用原生方案的话，需要使用FadeInImage。针对闲鱼的场景我们有很多定制，所以我们自己实现了一套PlaceHolder的机制。</p> \n<p>从核心功能上来说，我们引入了加载状态的概念分为： 1. 未初始化 2. 加载中 3. 加载完成 等。针对不同的状态，可以细粒度的控制PlaceHolder的展示逻辑。</p> \n<h3>3.5. 整体架构</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312436\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>3.6. 方案的不足</h3> \n<ol>\n <li><strong>毕竟改了engine</strong></li>\n</ol> \n<p>随着闲鱼业务的不断推进，engine的升级的成本是我们必须要考虑的事情。能否不改engine实现同样的功能是我们核心的述求。（PS: 我承认我们是贪心的）</p> \n<ol>\n <li><strong>通道性能还有优化空间</strong></li>\n</ol> \n<p>外接纹理的方案需要通过桥的方式跟native的能力做通信。这里包括图片请求的传递和图片加载各种状态的同步。特别是在listview快速滑动的时候，通过桥发送的数据量还是可观的。当前方案每个图片加载时都会单独进行桥的调用。在图片数量比较多的情况下，这显然会是一个瓶颈。</p> \n<ol>\n <li><strong>耦合过多</strong></li>\n</ol> \n<p>在实现图片回收方案的时候，目前方案需要栈提供是否在栈底层的接口。这里就产生方案耦合，很难抽象出一个独立干净的图片加载方案。</p> \n<h2>4. Clean&amp;Efficient</h2> \n<p>时间来到了2020年，随着对Flutter基础能力理解的逐步深入，我们实现了一个整体方案更优的图片框架。</p> \n<h3>4.1. 无侵入外接纹理</h3> \n<p>外接纹理可以不用修改engine么？答案是肯定的。</p> \n<p>其实Flutter是提供了官方的外接纹理方案的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312438\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>而且Native操作的texture和Flutter侧显示的texture在底层是同一对象，并<strong>没有产生额外的数据copy</strong>。这样就保证了纹理共享的足够高效。那为什么闲鱼之前会单独基于shared-Context自己实现一套呢？1.12版本之前，官方Ios的外接纹理方案有性能问题。每次渲染的过程中（不管纹理是否有更新）都会频繁获取CVPixelBuffer，造成不必要的性能损耗（过程有加锁损耗）。该问题已经在1.12版本中修复(<a href=\"https://github.com/flutter/flutter/commit/37a4af0ca8148adbda87bcae819ada044c72510d\" rel=\"nofollow noreferrer\">官方commit地址</a>)，这样官方方案也足够满足需求。在这样的背景下，我们重新启用官方方案来实现外接纹理功能。</p> \n<h3>4.2. 独立的内存优化</h3> \n<p>之前提到过，老版本的基于页面栈的图片资源回收需要强依赖栈功能的接口。一方面产生了不必要的依赖，更重要的是，整体方案无法独立成通用方案。为了解决这个问题，我们对Flutter底层进行了深入的研究。我们发现Flutter的layer层可以稳定感知到页面栈的变化。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312439\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"TB1bt7AzYr1gK0jSZR0XXbP8XXa-1710-796.png\" title=\"TB1bt7AzYr1gK0jSZR0XXbP8XXa-1710-796.png\"></span></p> \n<p>然后每个页面通过context获取的router对象作为标识对一个页面中的所有的图片对象进行重新组织。所有获取到同一个router对象的标识成同一个页面。这样就能以页面为单位对所有的图片进行管理。整体上通过LRU的算法来模拟虚拟页面栈结构。这样就能对栈底页面的图片资源实现回收了。</p> \n<h3>4.3. 其他优化</h3> \n<p><strong>1. 通道的高度复用</strong></p> \n<p>首先我们以一帧为单位对这一帧中的图片请求进行聚合，然后在一次通道请求中传递给Native的图片加载框架。这样能避免频繁的桥调用。特别在快速滚动等场景下优化效果尤为明显。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312441\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>2. 高效的纹理复用</strong></p> \n<p>使用外接纹理进行图片加载以后，我们发现复用纹理可以进一步提升性能。举一个简单的场景。我们知道电商场景中，商品展示经常会有标签，打底图这样的图片。这类图片往往在不同的商品上会出现大量重复。这时候，可以将已经渲染好的纹理，直接复用给不同的显示组件。这样能进一步优化GPU内存的占用，避免重复创建。为了精确对纹理进行管理，我们引入了引用计数的算法来管理纹理的复用。通过这些方案，我们实现了纹理跨页面高效复用。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312440\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>此外，我们将纹理和请求的映射关系移动到了Flutter侧。这样能在最短路径上完成纹理的复用，进一步减少了桥的通信的压力。</p> \n<h3>4.5. 整体架构</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312442\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>5. 优化效果</h2> \n<p>由于最新的版本目前还在灰度，具体数据后续会写文跟大家详细介绍。下属数据主要以<strong>方案二为主</strong>。</p> \n<ul>\n <li> <p>内存优化</p> \n  <ul> \n   <li>通过打通Native，相比于首次上线版本，在显示效果不变的情况下，Ios的abort率<strong>降低25%</strong>，用户体验明显提升。</li> \n   <li>多页面栈内存优化</li> \n  </ul> </li>\n</ul> \n<pre><code>多页面栈的内存优化，在多页面场景下对内存优化作用明显。我们做了一个极限试验效果如下：(**测试环境**，非闲鱼APP)\n\n</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312443\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"TB1IK58AG61gK0jSZFlXXXDKFXa-868-473.png\" title=\"TB1IK58AG61gK0jSZFlXXXDKFXa-868-473.png\"></span></p> \n<p>​ 可见多页面栈的优化，可以将多Flutter页面的内存占用控制得更好。</p> \n<ul>\n <li>包大小减少</li>\n</ul> \n<p>通过接入外接纹理，本地资源得到了更好的复用，包大小<strong>降低1M</strong>。早期闲鱼接入Flutter，会以改造现有页面为切入点。资源重复情况比较严重，但是随着闲鱼Flutter 新业务越来越多。Flutter和Native的重复资源越来越少。外接纹理对包大小的影响已经逐步变弱。</p> \n<h2>6. 总结</h2> \n<p>本文介绍了闲鱼在Flutter图片框架方向上所做的持续优化。介绍了闲鱼不同时期，典型的图片技术方案的细节。希望可以给到读者一些启发。这是一场没有尽头的旅行，我们对闲鱼图片的优化还会持续。特别是我们最新的方案，受限篇幅，本文只是做了初步介绍。更多技术细节，包括测试数据，我们随后还会专门写文继续给大家做介绍。方案完善以后，我们也会逐步开源。</p> \n<h6> <strong>更多相关内容：</strong><a href=\"https://developer.aliyun.com/article/753993?utm_content=g_1000111457\" rel=\"nofollow noreferrer\"><strong>点击这里</strong></a>​</h6>', 'https://segmentfault.com/img/remote/1460000022312435', null, null, '0', '0', null, '1', '2020-04-14 20:58:19', '2020-04-14 20:58:19');
INSERT INTO `tb_recommend` VALUES ('4a991a2e3bc04ed7bc61fb2198a03669', '与国同悲，愿我们用技术改变世界', '与国同悲，SegmentFault 思否技术媒体全线暂停更新一天。 特别专题丨新型肺炎防疫，做好防护，我们整理了一些有价值的内容 如何获取靠谱的新型冠状病毒疫情 肺炎前线的科技公司 广东科技出版社发布《新型冠状病毒...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFzxj\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"稿定设计导出-20200404-113817.png\" title=\"稿定设计导出-20200404-113817.png\"></span></p> \n<p>与国同悲，SegmentFault 思否技术媒体全线暂停更新一天。</p> \n<hr> \n<ol> \n <li><a href=\"https://segmentfault.com/a/1190000021641318\">特别专题丨新型肺炎防疫，做好防护，我们整理了一些有价值的内容</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650218949&amp;idx=1&amp;sn=f2c95723a3eeb065ec1c07cd11999376&amp;chksm=befe21e48989a8f254355ec4c272c11074d4c5fb7eba29b61b982c69b14acdb8594709375ba0&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">如何获取靠谱的新型冠状病毒疫情</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650218952&amp;idx=1&amp;sn=4d1c8982a1832ec294e72453ac84014f&amp;chksm=befe21e98989a8ffd7beaf0a5334a216f39394c8d3c644f27366ec83db9dd372f4c2483c132a&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">肺炎前线的科技公司</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000021648701\">广东科技出版社发布《新型冠状病毒感染防护手册》</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000021649672\">火神山医院面向全国紧急招募 IT 运维志愿者</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000021648500\">湖北科学技术出版社发布《新型冠状病毒肺炎预防手册》</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000021649955\">疫情特殊时期，致 SegmentFault 思否全体员工的一封公开信</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650218975&amp;idx=1&amp;sn=1d387564a96f0072878fe0fe59c867a7&amp;chksm=befe21fe8989a8e867dc6321636cf8a4a113fc6e6ef95add7d7abca908ec76944a3c272f430d&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">疫情面前，中国医院需要什么样的数据中台？</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650218986&amp;idx=1&amp;sn=050944d160685b8344d0ec54c9585095&amp;chksm=befe21cb8989a8dd9ac421aeae52a34b8624d67f13cc93090406bff89e3a9c3800e969522556&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">爬了 8W 条弹幕评论，4000 万人熬夜“监工”，不是无聊是期望……</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650219003&amp;idx=1&amp;sn=a7d7da33d4032f4da1fd34c0af609212&amp;chksm=befe21da8989a8cc088bd7ac925a6f404d6af4250c9407e77631462206cf6b54ef7808d8528d&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">面对突发疫情：信息管理跟“口罩”一样重要</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000021715328\">GitHub 中文趋势榜第一！「2020 新冠肺炎记忆」项目已获4.6K星标！</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650219119&amp;idx=1&amp;sn=553df09051841077983feb65db3cbfc4&amp;chksm=befe224e8989ab58abb246ed4b8108a72cf3184d9f31a2dae6e2498f0dbc45b7b385786e80b9&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">第一轮返工潮，哪些城市疫情传播压力最大</a></li> \n <li><a href=\"https://aijishu.com/a/1060000000091759?aff=sf\" rel=\"nofollow noreferrer\">AIZOO 开源人脸口罩检测数据+模型+代码+在线网页体验，通通都开源了</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022140058\">世界卫生组织（WHO）发起黑客马拉松，携手 Facebook、微软等科技企业应对冠状病毒挑战</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022012855\">受疫情影响，全球各顶尖技术峰会均改为线上举办</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022044368\">全球最大 COVID-19 研究数据集正式开放，加强科技抗疫</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022246736\">为应对呼吸机短缺，MIT 开源学生团队开发的低成本呼吸机</a></li> \n</ol>', 'https://segmentfault.com/img/bVbFzxj', null, null, '0', '0', null, '1', '2020-04-14 20:58:25', '2020-04-14 20:58:25');
INSERT INTO `tb_recommend` VALUES ('6019982f9beb451b9ee53996daeb6c04', '面试问我，创建多少个线程合适？我该怎么说', '你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it well enough', '<p>| <strong>如果好看，请给个赞</strong></p> \n<blockquote>\n <ul> \n  <li>你有一个思想，我有一个思想，我们交换后，一个人就有两个思想</li> \n  <li>If you can NOT explain it simply, you do NOT understand it well enough</li> \n </ul>\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIun\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>为什么要使用多线程？</h2> \n<blockquote>\n 防止并发编程出错最好的办法就是不写并发程序\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuo\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>既然多线程编程容易出错，为什么它还经久不衰呢？</p> \n<p><strong>A：那还用说，肯定在某些方面有特长呗，比如你知道的【它很快，非常快】</strong></p> \n<p>我也很赞同这个答案，但说的不够具体</p> \n<h2>并发编程适用于什么场景？</h2> \n<p>如果问你选择多线程的原因就是一个【快】字，面试也就不会出那么多幺蛾子了。你有没有问过你自己</p> \n<ol> \n <li>并发编程在所有场景下都是快的吗？</li> \n <li>知道它很快，何为快？怎样度量？</li> \n</ol> \n<p>想知道这两个问题的答案，我们需要一个从【定性】到【定量】的分析过程</p> \n<blockquote>\n 使用多线程就是在正确的场景下通过设置正确个数的线程来最大化程序的运行速度（我感觉你还是啥也没说）\n</blockquote> \n<p>将这句话翻译到硬件级别就是要充分的利用 CPU 和 I/O 的利用率</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIup\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>两个正确得到保证，也就能达到最大化利用 CPU 和 I/O的目的了。最关键是，如何做到两个【正确】？</p> \n<p>在聊具体场景的时候，我们必须要拿出我们的专业性来。送你两个名词 buff 加成</p> \n<ul> \n <li>CPU 密集型程序</li> \n <li>I/O 密集型程序</li> \n</ul> \n<h3>CPU 密集型程序</h3> \n<blockquote>\n 一个完整请求，I/O操作可以在很短时间内完成， CPU还有很多运算要处理，也就是说 CPU 计算的比例占很大一部分\n</blockquote> \n<p>假如我们要计算 1+2+....100亿 的总和，很明显，这就是一个 CPU 密集型程序</p> \n<p>在【单核】CPU下，如果我们创建 4 个线程来分段计算，即：</p> \n<ol> \n <li>线程1计算 <code>[1,25亿）</code> </li> \n <li>...... 以此类推</li> \n <li>线程4计算 <code>[75亿，100亿]</code> </li> \n</ol> \n<p>我们来看下图他们会发生什么？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuq\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>由于是单核 CPU，所有线程都在等待 CPU 时间片。按照理想情况来看，四个线程执行的时间总和与一个线程5独自完成是相等的，实际上我们还忽略了四个线程上下文切换的开销</p> \n<p><strong>所以，单核CPU处理CPU密集型程序，这种情况并不太适合使用多线程</strong></p> \n<p>此时如果在 4 核CPU下，同样创建四个线程来分段计算，看看会发生什么？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIur\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>每个线程都有 CPU 来运行，并不会发生等待 CPU 时间片的情况，也没有线程切换的开销。理论情况来看效率提升了 4 倍</p> \n<p><strong>所以，如果是多核CPU 处理 CPU 密集型程序，我们完全可以最大化的利用 CPU 核心数，应用并发编程来提高效率</strong></p> \n<h3>I/O密集型程序</h3> \n<blockquote>\n 与 CPU 密集型程序相对，一个完整请求，CPU运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分\n</blockquote> \n<p>我们都知道在进行 I/O 操作时，CPU是空闲状态，所以我们要最大化的利用 CPU，不能让其是空闲状态</p> \n<p>同样在单核 CPU 的情况下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIus\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>从上图中可以看出，每个线程都执行了相同长度的 CPU 耗时和 I/O 耗时，如果你将上面的图多画几个周期，CPU操作耗时固定，将 I/O 操作耗时变为 CPU 耗时的 3 倍，你会发现，CPU又有空闲了，这时你就可以新建线程 4，来继续最大化的利用 CPU。</p> \n<p>综上两种情况我们可以做出这样的总结：</p> \n<blockquote>\n <strong>线程等待时间所占比例越高，需要越多线程；线程CPU时间所占比例越高，需要越少线程。</strong>\n</blockquote> \n<p>到这里，相信你已经知道第一个【正确】使用多线程的场景了，那创建多少个线程是正确的呢？</p> \n<h2>创建多少个线程合适？</h2> \n<p>面试如果问到这个问题，这可是对你理论和实践的统考。想完全答对，你必须要【精通/精通/精通】<strong>小学算术</strong></p> \n<p>从上面知道，我们有 CPU 密集型和 I/O 密集型两个场景，不同的场景当然需要的线程数也就不一样了</p> \n<h3>CPU 密集型程序创建多少个线程合适？</h3> \n<p>有些同学早已经发现，对于 CPU 密集型来说，理论上 <code>线程数量 = CPU 核数（逻辑）</code> 就可以了，但是实际上，数量一般会设置为 <code>CPU 核数（逻辑）+ 1</code>， 为什么呢？</p> \n<p>《Java并发编程实战》这么说：</p> \n<blockquote>\n 计算密（CPU）集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。\n</blockquote> \n<p>所以对于CPU密集型程序， <code>CPU 核数（逻辑）+ 1</code> 个线程数是比较好的经验值的原因了</p> \n<h3>I/O密集型程序创建多少个线程合适？</h3> \n<p>上面已经让大家按照图多画几个周期（你可以动手将I/O耗时与CPU耗时比例调大，比如6倍或7倍），这样你就会得到一个结论，对于 I/O 密集型程序：</p> \n<blockquote>\n 最佳线程数 = \n <code>(1/CPU利用率)</code> = \n <code>1 + (I/O耗时/CPU耗时)</code> \n</blockquote> \n<p>我这么体贴，当然担心有些同学不理解这个公式，我们将上图的比例手动带入到上面的公式中：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIut\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这是一个CPU核心的最佳线程数，如果多个核心，那么 I/O 密集型程序的最佳线程数就是：</p> \n<blockquote>\n 最佳线程数 = \n <code>CPU核心数</code> \n <em> <code>(1/CPU利用率)</code> = <code>CPU核心数</code> </em> \n <code>1 + (I/O耗时/CPU耗时)</code> \n</blockquote> \n<p>说到这，有些同学可能有疑问了，要计算 I/O 密集型程序，是要知道 CPU 利用率的，如果我不知道这些，那要怎样给出一个初始值呢？</p> \n<p>按照上面公式，假如几乎全是 I/O耗时，所以纯理论你就可以说是 <strong>2N（N=CPU核数），当然也有说 2N + 1的</strong>，（我猜这个 1 也是 backup），没有找到具体的推倒过程，在【并发编程实战-8.2章节】截图在此，大家有兴趣的可以自己看看</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuu\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>理论上来说，理论上来说，理论上来说</strong>，这样就能达到 CPU 100% 的利用率</p> \n<p>如果理论都好用，那就用不着实践了，也就更不会有调优的事出现了。<strong>不过在初始阶段，我们确实可以按照这个理论之作为伪标准， 毕竟差也可能不会差太多，这样调优也会更好一些</strong></p> \n<p>谈完理论，咱们说点实际的，公式我看懂了（定性阶段结束），但是我有两个疑问：</p> \n<ol> \n <li>我怎么知道具体的 I/O耗时和CPU耗时呢？</li> \n <li>怎么查看CPU利用率？</li> \n</ol> \n<p>没错，我们需要定量分析了</p> \n<p>幸运的是，我们并不是第一个吃螃蟹的仔儿，其实有很多 APM （Application Performance Manager）工具可以帮我们得到准确的数据，学会使用这类工具，也就可以结合理论，在调优的过程得到更优的线程个数了。我这里简单列举几个，具体使用哪一个，具体应用还需要你自己去调研选择，受篇幅限制，暂不展开讨论了</p> \n<ol> \n <li>SkyWalking</li> \n <li>CAT</li> \n <li>zipkin</li> \n</ol> \n<p>上面了解了基本的理论知识，那面试有可能问什么？又可能会以怎样的方式提问呢？</p> \n<h2>面试小问</h2> \n<h3>小问一</h3> \n<blockquote>\n 假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s\n</blockquote> \n<p><strong>如何设计线程个数，使得可以在1s内处理完20个Transaction？</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuv\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>但是，但是，这是因为没有考虑到CPU数目。家里又没矿，一般服务器的CPU核数为16或者32，如果有80个线程，那么肯定会带来太多不必要的线程上下文切换开销（希望这句话你可以主动说出来），这就需要调优了，来做到最佳 balance</p> \n<h3>小问二</h3> \n<blockquote>\n 计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？\n</blockquote> \n<p>如果不知道请拿三年级期末考试题重新做（今天晚自习留下来），答案是：</p> \n<p><strong>线程数 = 8 * (1 + 100/5) = 168 (个)</strong></p> \n<blockquote>\n 那如果DB的 QPS（Query Per Second）上限是1000，此时这个线程数又该设置为多大呢？\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuw\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>同样，这是没有考虑 CPU 数目，接下来就又是细节调优的阶段了</p> \n<p>因为一次请求不仅仅包括 CPU 和 I/O操作，具体的调优过程还要考虑内存资源，网络等具体内容</p> \n<h2>增加 CPU 核数一定能解决问题吗？</h2> \n<p>看到这，有些同学可能会认为，即便我算出了理论线程数，但实际CPU核数不够，会带来线程上下文切换的开销，所以下一步就需要增加 CPU 核数，那我们盲目的增加 CPU 核数就一定能解决问题吗？</p> \n<p>在讲互斥锁的内容是，我故意遗留了一个知识:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIux\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>怎么理解这个公式呢？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuy\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这个结论告诉我们，假如我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。</p> \n<p>如何简单粗暴的理解串行百分比（其实都可以通过工具得出这个结果的）呢？来看个小 Tips：</p> \n<blockquote> \n <strong>Tips:</strong> 临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行百分比\n</blockquote> \n<p>现在你应该理解我在讲解 synchronized 关键字时所说的：</p> \n<blockquote>\n 最小化临界区范围，因为临界区的大小往往就是瓶颈问题的所在，不要像乱用try catch那样一锅端\n</blockquote> \n<h2>总结</h2> \n<p>多线程不一定就比但线程高效，比如大名鼎鼎的 Redis （后面会分析），因为它是基于内存操作，这种情况下，单线程可以很高效的利用CPU。而多线程的使用场景一般时存在相当比例的I/O或网络操作</p> \n<p>另外，结合小学数学题，我们已经了解了如何从定性到定量的分析的过程，在开始没有任何数据之前，我们可以使用上文提到的经验值作为一个伪标准，其次就是结合实际来逐步的调优（综合 CPU，内存，硬盘读写速度，网络状况等）了</p> \n<p>最后，盲目的增加 CPU 核数也不一定能解决我们的问题，这就要求我们严格的编写并发程序代码了</p> \n<h2>灵魂追问</h2> \n<ol> \n <li>我们已经知道创建多少个线程合适了，为什么还要搞一个线程池出来？</li> \n <li>创建一个线程都要做哪些事情？为什么说频繁的创建线程开销很大？</li> \n <li>多线程通常要注意共享变量问题，为什么局部变量就没有线程安全问题呢？</li> \n <li>......</li> \n</ol> \n<p>下一篇文章，我们就来说说，你熟悉又陌生的线程池问题</p> \n<h2>参考</h2> \n<p>感谢前辈们总结的精华，自己所写的并发系列好多都参考了以下资料</p> \n<ul> \n <li>Java 并发编程实战</li> \n <li>Java 并发编程之美</li> \n <li>码出高效</li> \n <li>Java 并发编程的艺术</li> \n <li>......</li> \n</ul> \n<p>日拱一兵 ｜ 原创</p>', 'https://segmentfault.com/img/bVbFIun', null, null, '0', '0', null, '1', '2020-04-14 20:58:21', '2020-04-14 20:58:21');
INSERT INTO `tb_recommend` VALUES ('69ea8c4fb7714128a30d5cd874e95b24', '事件驱动及其设计模式', '在GUI编程中，事件是非常常见的。比如，用户在界面点击了按钮，就会发送一个“点击”事件，而相应的会有一个处理“点击”事件的事件处理器会来处理该事件。', '<p>在GUI编程中，事件是非常常见的。比如，用户在界面点击了按钮，就会发送一个“点击”事件，而相应的会有一个处理“点击”事件的事件处理器会来处理该事件。</p> \n<p>因此，所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）。当然事件也不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个事件处理器组成。事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。事件发送器负责将收集器收集到的事件分发到目标对象中。事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。</p> \n<h1>事件驱动编程</h1> \n<p>事件驱动编程通常只是用一个执行过程，CPU之间不是并发的，在处理多任务的时候，事件驱动编程是使用协作式处理任务，而不是多线程的抢占式。事件驱动简洁易用，只需要注册感兴趣的事件，在回调中设计逻辑就可以了。在调用的过程中，事件循环器（Event Loop）在等待事件的发生，跟着调用处理器。事件处理器不是抢占式的，处理器一般只有很短的生命周期。</p> \n<h2>事件驱动编程的优势</h2> \n<p>l 在大部分的应用场景中，事件编程优与多线程编程。</p> \n<p>l 相对与多线程编程来讲，事件驱动编程比较容易，复杂度低，是开发者乐于接受的。</p> \n<p>l 大多数的GUI框架，都是使用事件驱动编程了架构的。每一个事件会绑定一个处理器，这些事件通常是点击按钮，选择菜单，等等。处理器r来实现具体的行为逻辑。</p> \n<p>l 事件驱动经常使用在I/O框架中，可以很好的实现I/O复用。很多高性能的I/O框架都是使用事件驱动模型的，例如：Netty、Mina、Node.js。</p> \n<p>l 易于调试。时间依赖只和事件有关系，而不是内部调度。问题容易暴露。</p> \n<h2>事件驱动编程的劣势</h2> \n<p>l 如果处理器占用时间较长，那会阻塞应用程序的响应。</p> \n<p>l 无法通过时间来维护本地状态，因为处理器必须返回。</p> \n<p>l 通常在单CPU环境下，比多线程编程要快，因为没有锁的因素，没有线程切换的损耗。CPU不是并发的，这样的话就不适合用在一些科学计算的应用中。</p> \n<h1>事件循环器（Event Loop）的实现</h1> \n<p>事件循环器（Event Loop）是一个程序结构，用于等待和发送消息和事件。事件驱动编程的代码核心就是事件循环器，在Linux下推荐使用epoll实现，在其它没有epoll 的系统上可以使用kqueue/ports/poll/select实现。</p> \n<p>下图是事件循环器的工作示例图。事件循环器不断接受来自客户端（Client）的请求，事件循环器把请求转交给注册了某类事件的工作线程（Worker）处理。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022048090\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span>&nbsp;</p> \n<p>根据实现的方式不同，在网络编程中基于事件驱动主要有两种设计模式：Reactor和Proactor。</p> \n<h1>Reactor</h1> \n<p>首先来回想一下普通函数调用的机制：</p> \n<p>l&nbsp; 程序调用某函数-&gt;函数执行</p> \n<p>l&nbsp; 程序等待-&gt;函数将结果</p> \n<p>l&nbsp; 控制权返回给程序-&gt;程序继续处理</p> \n<p>和普通函数调用的不同之处在于：应用程序不是主动的调用某个API完成处理，而是恰恰相反，应用程序需要提供相应的接口并注册到Reactor上，如果相应的事件发生，Reactor将主动调用应用程序注册的接口，这些接口又称为“回调函数”。</p> \n<p>用“好莱坞原则”来形容Reactor再合适不过了：不要打电话给我们，我们会打电话通知你。</p> \n<p>举个例子：你去应聘某xx公司，面试结束后。</p> \n<p>l&nbsp; “普通函数调用机制”公司HR比较懒，不会记你的联系方式，那怎么办呢，你只能面试完后自己打电话去问结果；有没有被录取啊，还是被拒了；</p> \n<p>l&nbsp; “Reactor”公司HR就记下了你的联系方式，结果出来后会主动打电话通知你：有没有被录取啊，还是被拒了；你不用自己打电话去问结果，事实上也不能，因为你没有HR的联系方式。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022048091\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>Reactor模式的优点</h2> \n<p>Reactor模式是编写高性能网络服务器的必备技术之一，它具有如下的优点：</p> \n<p>1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；</p> \n<p>2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；</p> \n<p>3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；</p> \n<p>4）可复用性，Reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；</p> \n<h2>Reactor模式框架</h2> \n<p>使用Reactor模型，必备的几个组件：事件源、Reactor框架、事件多路复用机制和事件处理程序，先来看看Reactor模型的整体框架，接下来再对每个组件做逐一说明。</p> \n<p>1）事件源：Linux上是文件描述符，Windows上就是Socket或者Handle了，这里统一称为“句柄集”；程序在指定的句柄上注册关心的事件，比如I/O事件。</p> \n<p>2）事件多路复用机制：由操作系统提供的I/O多路复用机制，比如select和epoll。程序首先将其关心的句柄（事件源）及其事件注册到多路复用机制上。当有事件到达时，事件多路复用机制会发出通知“在已经注册的句柄集中，一个或多个句柄的事件已经就绪”。程序收到通知后，就可以在非阻塞的情况下对事件进行处理了。</p> \n<p>3） Reactor。是事件管理的接口，内部使用事件多路复用机制注册、注销事件；并运行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。</p> \n<p>4）事件处理程序。事件处理程序提供了一组接口，每个接口对应了一种类型的事件，供Reactor在相应的事件发生时调用，执行相应的事件处理。通常它会绑定一个有效的句柄。</p> \n<p>使用Reactor模式后，事件控制流是什么样子呢？可以参见下面的序列图。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022048092\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>我们分别以读操作和写操作为例来看看Reactor中的具体步骤：</p> \n<p>1) 应用程序注册读就绪事件和相关联的事件处理器；</p> \n<p>2) 事件分离器等待事件的发生；</p> \n<p>3) 当发生读就绪事件的时候，事件分离器调用第一步注册的事件处理器；</p> \n<p>4) 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理。</p> \n<p>写入操作类似于读取操作，只不过第一步注册的是写就绪事件。</p> \n<h1>Proactor</h1> \n<p>我们来看看Proactor模式中读取操作和写入操作的过程：</p> \n<p>1) 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。</p> \n<p>2) 事件分离器等待读取操作完成事件。</p> \n<p>3) 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作（异步I/O都是操作系统负责将数据读写到应用传递进来的缓冲区供应用程序操作），并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点。</p> \n<p>4) 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。</p> \n<p>Proactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。</p> \n<p>从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的I/O设备。</p> \n<h1>参考引用</h1> \n<p>l&nbsp; 《Netty原理解析与开发实战》</p> \n<p>l&nbsp; 《分布式系统常用技术及案例分析（第二版）》</p>', 'https://segmentfault.com/img/remote/1460000022048090', null, null, '0', '0', null, '1', '2020-04-14 20:58:19', '2020-04-14 20:58:19');
INSERT INTO `tb_recommend` VALUES ('6b781167b33848799f3b14e6e041db39', '那些功能逆天，却鲜为人知的pandas骚操作', 'pandas有一种功能非常强大的方法，它就是accessor，可以将它理解为一种属性接口，通过它可以获得额外的方法。其实这样说还是很笼统，下面我们通过代码和实例来理解一下。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022271880\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<blockquote>\n 作者：东哥\n</blockquote> \n<p>pandas有些功能很逆天，但却鲜为人知，本篇给大家盘点一下。</p> \n<h2><strong>一、ACCESSOR</strong></h2> \n<p>pandas有一种功能非常强大的方法，它就是accessor，可以将它理解为一种属性接口，通过它可以获得额外的方法。其实这样说还是很笼统，下面我们通过代码和实例来理解一下。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;pd.Series._accessors  \n{\'cat\',&nbsp;\'str\',&nbsp;\'dt\'}</code></pre> \n<p>对于Series数据结构使用_accessors方法，可以得到了3个对象：cat，str，dt。</p> \n<ul> \n <li> <code>.cat</code>：用于分类数据（Categorical data）</li> \n <li> <code>.str</code>：用于字符数据（String Object data）</li> \n <li> <code>.dt</code>：用于时间数据（datetime-like data）</li> \n</ul> \n<p>下面我们依次看一下这三个对象是如何使用的。</p> \n<p><strong>str对象的使用</strong></p> \n<p>Series数据类型：str字符串</p> \n<h3>&nbsp;定义一个Series序列</h3> \n<pre><code>&gt;&gt;&gt;&nbsp;addr&nbsp;=&nbsp;pd.Series([  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'Washington,&nbsp;D.C.&nbsp;20003\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'Brooklyn,&nbsp;NY&nbsp;11211-1755\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'Omaha,&nbsp;NE&nbsp;68154\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'Pittsburgh,&nbsp;PA&nbsp;15211\'  \n...&nbsp;])&nbsp;  \n  \n&gt;&gt;&gt;&nbsp;addr.str.upper()  \n0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WASHINGTON,&nbsp;D.C.&nbsp;20003  \n1&nbsp;&nbsp;&nbsp;&nbsp;BROOKLYN,&nbsp;NY&nbsp;11211-1755  \n2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OMAHA,&nbsp;NE&nbsp;68154  \n3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PITTSBURGH,&nbsp;PA&nbsp;15211  \ndtype:&nbsp;object  \n  \n&gt;&gt;&gt;&nbsp;addr.str.count(r\'\\d\')&nbsp;  \n0&nbsp;&nbsp;&nbsp;&nbsp;5  \n1&nbsp;&nbsp;&nbsp;&nbsp;9  \n2&nbsp;&nbsp;&nbsp;&nbsp;5  \n3&nbsp;&nbsp;&nbsp;&nbsp;5  \ndtype:&nbsp;int64</code></pre> \n<p>关于以上str对象的2个方法说明：</p> \n<ul> \n <li> <code>Series.str.upper</code>：将Series中所有字符串变为大写</li> \n <li> <code>Series.str.count</code>：对Series中所有字符串的个数进行计数</li> \n</ul> \n<p>其实不难发现，该用法的使用与Python中字符串的操作很相似。没错，在pandas中你一样可以这样简单的操作，而不同的是你操作的是一整列的字符串数据。仍然基于以上数据集，再看它的另一个操作：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;regex&nbsp;=&nbsp;(r\'(?P&lt;city&gt;[A-Za-z&nbsp;]+),&nbsp;\'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;一个或更多字母  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r\'(?P&lt;state&gt;[A-Z]{2})&nbsp;\'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;两个大写字母  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r\'(?P&lt;zip&gt;\\d{5}(?:-\\d{4})?)\')&nbsp;&nbsp;#&nbsp;可选的4个延伸数字  \n...  \n&gt;&gt;&gt;&nbsp;addr.str.replace(\'.\',&nbsp;\'\').str.extract(regex)  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;city&nbsp;state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zip  \n0&nbsp;&nbsp;Washington&nbsp;&nbsp;&nbsp;&nbsp;DC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20003  \n1&nbsp;&nbsp;&nbsp;&nbsp;Brooklyn&nbsp;&nbsp;&nbsp;&nbsp;NY&nbsp;&nbsp;11211-1755  \n2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Omaha&nbsp;&nbsp;&nbsp;&nbsp;NE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;68154  \n3&nbsp;&nbsp;Pittsburgh&nbsp;&nbsp;&nbsp;&nbsp;PA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15211</code></pre> \n<p>关于以上str对象的2个方法说明：</p> \n<ul> \n <li> <code>Series.str.replace</code>：将Series中指定字符串替换</li> \n <li> <code>Series.str.extract</code>：通过正则表达式提取字符串中的数据信息</li> \n</ul> \n<p>这个用法就有点复杂了，因为很明显看到，这是一个链式的用法。通过<code>replace</code>将&nbsp;<code>\" . \"</code> 替换为<code>\"\"</code>，即为空，紧接着又使用了3个正则表达式（分别对应city，state，zip）通过<code>extract</code>对数据进行了提取，并由原来的Series数据结构变为了DataFrame数据结构。</p> \n<p>当然，除了以上用法外，常用的属性和方法还有<code>.rstrip</code>，<code>.contains</code>，<code>split</code>等，我们通过下面代码查看一下<code>str</code>属性的完整列表：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;[i&nbsp;for&nbsp;i&nbsp;in&nbsp;dir(pd.Series.str)&nbsp;if&nbsp;not&nbsp;i.startswith(\'_\')]  \n[\'capitalize\',  \n&nbsp;\'cat\',  \n&nbsp;\'center\',  \n&nbsp;\'contains\',  \n&nbsp;\'count\',  \n&nbsp;\'decode\',  \n&nbsp;\'encode\',  \n&nbsp;\'endswith\',  \n&nbsp;\'extract\',  \n&nbsp;\'extractall\',  \n&nbsp;\'find\',  \n&nbsp;\'findall\',  \n&nbsp;\'get\',  \n&nbsp;\'get_dummies\',  \n&nbsp;\'index\',  \n&nbsp;\'isalnum\',  \n&nbsp;\'isalpha\',  \n&nbsp;\'isdecimal\',  \n&nbsp;\'isdigit\',  \n&nbsp;\'islower\',  \n&nbsp;\'isnumeric\',  \n&nbsp;\'isspace\',  \n&nbsp;\'istitle\',  \n&nbsp;\'isupper\',  \n&nbsp;\'join\',  \n&nbsp;\'len\',  \n&nbsp;\'ljust\',  \n&nbsp;\'lower\',  \n&nbsp;\'lstrip\',  \n&nbsp;\'match\',  \n&nbsp;\'normalize\',  \n&nbsp;\'pad\',  \n&nbsp;\'partition\',  \n&nbsp;\'repeat\',  \n&nbsp;\'replace\',  \n&nbsp;\'rfind\',  \n&nbsp;\'rindex\',  \n&nbsp;\'rjust\',  \n&nbsp;\'rpartition\',  \n&nbsp;\'rsplit\',  \n&nbsp;\'rstrip\',  \n&nbsp;\'slice\',  \n&nbsp;\'slice_replace\',  \n&nbsp;\'split\',  \n&nbsp;\'startswith\',  \n&nbsp;\'strip\',  \n&nbsp;\'swapcase\',  \n&nbsp;\'title\',  \n&nbsp;\'translate\',  \n&nbsp;\'upper\',  \n&nbsp;\'wrap\',  \n&nbsp;\'zfill\']</code></pre> \n<p>属性有很多，对于具体的用法，如果感兴趣可以自己进行摸索练习。</p> \n<p><strong>dt对象的使用</strong></p> \n<p>Series数据类型：datetime</p> \n<p>因为数据需要datetime类型，所以下面使用pandas的date_range()生成了一组日期datetime演示如何进行dt对象操作。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;daterng&nbsp;=&nbsp;pd.Series(pd.date_range(\'2017\',&nbsp;periods=9,&nbsp;freq=\'Q\'))  \n&gt;&gt;&gt;&nbsp;daterng  \n0&nbsp;&nbsp;&nbsp;2017-03-31  \n1&nbsp;&nbsp;&nbsp;2017-06-30  \n2&nbsp;&nbsp;&nbsp;2017-09-30  \n3&nbsp;&nbsp;&nbsp;2017-12-31  \n4&nbsp;&nbsp;&nbsp;2018-03-31  \n5&nbsp;&nbsp;&nbsp;2018-06-30  \n6&nbsp;&nbsp;&nbsp;2018-09-30  \n7&nbsp;&nbsp;&nbsp;2018-12-31  \n8&nbsp;&nbsp;&nbsp;2019-03-31  \ndtype:&nbsp;datetime64[ns]  \n  \n&gt;&gt;&gt;&nbsp;&nbsp;daterng.dt.day_name()  \n0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Friday  \n1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Friday  \n2&nbsp;&nbsp;&nbsp;&nbsp;Saturday  \n3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sunday  \n4&nbsp;&nbsp;&nbsp;&nbsp;Saturday  \n5&nbsp;&nbsp;&nbsp;&nbsp;Saturday  \n6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sunday  \n7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Monday  \n8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sunday  \ndtype:&nbsp;object  \n  \n&gt;&gt;&gt;&nbsp;#&nbsp;查看下半年  \n&gt;&gt;&gt;&nbsp;daterng\\[daterng.dt.quarter&nbsp;&gt;&nbsp;2]  \n2&nbsp;&nbsp;&nbsp;2017-09-30  \n3&nbsp;&nbsp;&nbsp;2017-12-31  \n6&nbsp;&nbsp;&nbsp;2018-09-30  \n7&nbsp;&nbsp;&nbsp;2018-12-31  \ndtype:&nbsp;datetime64[ns]  \n  \n&gt;&gt;&gt;&nbsp;daterng[daterng.dt.is_year_end]  \n3&nbsp;&nbsp;&nbsp;2017-12-31  \n7&nbsp;&nbsp;&nbsp;2018-12-31  \ndtype:&nbsp;datetime64[ns]</code></pre> \n<p>以上关于dt的3种方法说明：</p> \n<ul> \n <li> <code>Series.dt.day_name()</code>：从日期判断出所处星期数</li> \n <li> <code>Series.dt.quarter</code>：从日期判断所处季节</li> \n <li> <code>Series.dt.is_year_end</code>：从日期判断是否处在年底</li> \n</ul> \n<p>其它方法也都是基于datetime的一些变换，并通过变换来查看具体微观或者宏观日期。</p> \n<p><strong>cat对象的使用</strong></p> \n<p>Series数据类型：Category</p> \n<p>在说cat对象的使用前，先说一下<code>Category</code>这个数据类型，它的作用很强大。虽然我们没有经常性的在内存中运行上g的数据，但是我们也总会遇到执行几行代码会等待很久的情况。使用<code>Category</code>数据的一个好处就是：<strong>可以很好的节省在时间和空间的消耗。</strong>下面我们通过几个实例来学习一下。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;colors&nbsp;=&nbsp;pd.Series([  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'periwinkle\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'mint&nbsp;green\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'burnt&nbsp;orange\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'periwinkle\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'burnt&nbsp;orange\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'rose\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'rose\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'mint&nbsp;green\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'rose\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'navy\'  \n...&nbsp;])  \n...  \n&gt;&gt;&gt;&nbsp;import&nbsp;sys  \n&gt;&gt;&gt;&nbsp;colors.apply(sys.getsizeof)  \n0&nbsp;&nbsp;&nbsp;&nbsp;59  \n1&nbsp;&nbsp;&nbsp;&nbsp;59  \n2&nbsp;&nbsp;&nbsp;&nbsp;61  \n3&nbsp;&nbsp;&nbsp;&nbsp;59  \n4&nbsp;&nbsp;&nbsp;&nbsp;61  \n5&nbsp;&nbsp;&nbsp;&nbsp;53  \n6&nbsp;&nbsp;&nbsp;&nbsp;53  \n7&nbsp;&nbsp;&nbsp;&nbsp;59  \n8&nbsp;&nbsp;&nbsp;&nbsp;53  \n9&nbsp;&nbsp;&nbsp;&nbsp;53  \ndtype:&nbsp;int64</code></pre> \n<p>上面我们通过使用<code>sys.getsizeof</code>来显示内存占用的情况，数字代表字节数。还有另一种计算内容占用的方法：<code>memory\\_usage()</code>，后面会使用。</p> \n<p>现在我们将上面<code>colors</code>的不重复值映射为一组整数，然后再看一下占用的内存。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;mapper&nbsp;=&nbsp;{v:&nbsp;k&nbsp;for&nbsp;k,&nbsp;v&nbsp;in&nbsp;enumerate(colors.unique())}  \n&gt;&gt;&gt;&nbsp;mapper  \n{\'periwinkle\':&nbsp;0,&nbsp;\'mint&nbsp;green\':&nbsp;1,&nbsp;\'burnt&nbsp;orange\':&nbsp;2,&nbsp;\'rose\':&nbsp;3,&nbsp;\'navy\':&nbsp;4}  \n  \n&gt;&gt;&gt;&nbsp;as_int&nbsp;=&nbsp;colors.map(mapper)  \n&gt;&gt;&gt;&nbsp;as_int  \n0&nbsp;&nbsp;&nbsp;&nbsp;0  \n1&nbsp;&nbsp;&nbsp;&nbsp;1  \n2&nbsp;&nbsp;&nbsp;&nbsp;2  \n3&nbsp;&nbsp;&nbsp;&nbsp;0  \n4&nbsp;&nbsp;&nbsp;&nbsp;2  \n5&nbsp;&nbsp;&nbsp;&nbsp;3  \n6&nbsp;&nbsp;&nbsp;&nbsp;3  \n7&nbsp;&nbsp;&nbsp;&nbsp;1  \n8&nbsp;&nbsp;&nbsp;&nbsp;3  \n9&nbsp;&nbsp;&nbsp;&nbsp;4  \ndtype:&nbsp;int64  \n  \n&gt;&gt;&gt;&nbsp;as_int.apply(sys.getsizeof)  \n0&nbsp;&nbsp;&nbsp;&nbsp;24  \n1&nbsp;&nbsp;&nbsp;&nbsp;28  \n2&nbsp;&nbsp;&nbsp;&nbsp;28  \n3&nbsp;&nbsp;&nbsp;&nbsp;24  \n4&nbsp;&nbsp;&nbsp;&nbsp;28  \n5&nbsp;&nbsp;&nbsp;&nbsp;28  \n6&nbsp;&nbsp;&nbsp;&nbsp;28  \n7&nbsp;&nbsp;&nbsp;&nbsp;28  \n8&nbsp;&nbsp;&nbsp;&nbsp;28  \n9&nbsp;&nbsp;&nbsp;&nbsp;28  \ndtype:&nbsp;int64</code></pre> \n<blockquote>\n 注：对于以上的整数值映射也可以使用更简单的\n <code>pd.factorize()</code>方法代替。\n</blockquote> \n<p>我们发现上面所占用的内存是使用object类型时的一半。其实，这种情况就类似于<code>Category data</code>类型内部的原理。</p> \n<p><strong>内存占用区别：</strong>Categorical所占用的内存与Categorical分类的数量和数据的长度成正比，相反，object所占用的内存则是一个常数乘以数据的长度。 </p> \n<p>下面是<code>object</code>内存使用和category内存使用的情况对比。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;colors.memory_usage(index=False,&nbsp;deep=True)  \n650  \n&gt;&gt;&gt;&nbsp;colors.astype(\'category\').memory_usage(index=False,&nbsp;deep=True)  \n495</code></pre> \n<p>上面结果是使用<code>object</code>和<code>Category</code>两种情况下内存的占用情况。我们发现效果并没有我们想象中的那么好。但是注意Category内存是成比例的，如果数据集的数据量很大，但不重复分类（unique）值很少的情况下，<strong>那么Category的内存占用可以节省达到10倍以上</strong>，比如下面数据量增大的情况：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;manycolors&nbsp;=&nbsp;colors.repeat(10)  \n&gt;&gt;&gt;&nbsp;len(manycolors)/manycolors.nunique()&nbsp;  \n20.0  \n  \n&gt;&gt;&gt;&nbsp;manycolors.memory_usage(index=False,&nbsp;deep=True)  \n6500  \n&gt;&gt;&gt;&nbsp;manycolors.astype(\'category\').memory_usage(index=False,&nbsp;deep=True)  \n585</code></pre> \n<p>可以看到，在数据量增加10倍以后，使用<code>Category</code>所占内容节省了10倍以上。</p> \n<p><strong>除了占用内存节省外，另一个额外的好处是计算效率有了很大的提升。</strong>因为对于<code>Category</code>类型的<code>Series</code>，str字符的操作发生在<code>.cat.categories</code>的非重复值上，而并非原Series上的所有元素上。也就是说对于每个非重复值都只做一次操作，然后再向与非重复值同类的值映射过去。</p> \n<p>对于<code>Category</code>的数据类型，可以使用<code>accesso</code>r的cat对象，以及相应的属性和方法来操作<code>Category</code>数据。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;ccolors&nbsp;=&nbsp;colors.astype(\'category\')  \n&gt;&gt;&gt;&nbsp;ccolors.cat.categories  \nIndex([\'burnt&nbsp;orange\',&nbsp;\'mint&nbsp;green\',&nbsp;\'navy\',&nbsp;\'periwinkle\',&nbsp;\'rose\'],&nbsp;dtype=\'object\')</code></pre> \n<p>实际上，对于开始的整数类型映射，可以先通过<code>reorder_categories</code>进行重新排序，然后再使用<code>cat.codes</code>来实现对整数的映射，来达到同样的效果。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;ccolors.cat.reorder_categories(mapper).cat.codes  \n0&nbsp;&nbsp;&nbsp;&nbsp;0  \n1&nbsp;&nbsp;&nbsp;&nbsp;1  \n2&nbsp;&nbsp;&nbsp;&nbsp;2  \n3&nbsp;&nbsp;&nbsp;&nbsp;0  \n4&nbsp;&nbsp;&nbsp;&nbsp;2  \n5&nbsp;&nbsp;&nbsp;&nbsp;3  \n6&nbsp;&nbsp;&nbsp;&nbsp;3  \n7&nbsp;&nbsp;&nbsp;&nbsp;1  \n8&nbsp;&nbsp;&nbsp;&nbsp;3  \n9&nbsp;&nbsp;&nbsp;&nbsp;4  \ndtype:&nbsp;int8</code></pre> \n<p>dtype类型是Numpy的<code>int8（-127~128）</code>。可以看出以上只需要一个单字节就可以在内存中包含所有的值。我们开始的做法默认使用了<code>int64</code>类型，然而通过<code>pandas</code>的使用可以很智能的将<code>Category</code>数据类型变为最小的类型。</p> \n<p>让我们来看一下cat还有什么其它的属性和方法可以使用。下面cat的这些属性基本都是关于查看和操作Category数据类型的。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;[i&nbsp;for&nbsp;i&nbsp;in&nbsp;dir(ccolors.cat)&nbsp;if&nbsp;not&nbsp;i.startswith(\'_\')]  \n[\'add_categories\',  \n&nbsp;\'as_ordered\',  \n&nbsp;\'as_unordered\',  \n&nbsp;\'categories\',  \n&nbsp;\'codes\',  \n&nbsp;\'ordered\',  \n&nbsp;\'remove_categories\',  \n&nbsp;\'remove_unused\\_categories\',  \n&nbsp;\'rename_categories\',  \n&nbsp;\'reorder_categories\',  \n&nbsp;\'set_categories\']</code></pre> \n<p>但是Category数据的使用不是很灵活。例如，插入一个之前没有的值，首先需要将这个值添加到.categories的容器中，然后再添加值。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;ccolors.iloc[5]&nbsp;=&nbsp;\'a&nbsp;new&nbsp;color\'  \n#&nbsp;...  \nValueError:&nbsp;Cannot&nbsp;setitem&nbsp;on&nbsp;a&nbsp;Categorical&nbsp;with&nbsp;a&nbsp;new&nbsp;category,  \nset&nbsp;the&nbsp;categories&nbsp;first  \n  \n&gt;&gt;&gt;&nbsp;ccolors&nbsp;=&nbsp;ccolors.cat.add\\_categories([\'a&nbsp;new&nbsp;color\'])  \n&gt;&gt;&gt;&nbsp;ccolors.iloc[5]&nbsp;=&nbsp;\'a&nbsp;new&nbsp;color\'&nbsp;&nbsp;</code></pre> \n<p>如果你想设置值或重塑数据，而非进行新的运算操作，那么Category类型不是那么有用。</p> \n<h2><strong>二、从clipboard剪切板载入数据</strong></h2> \n<p>当我们的数据存在excel表里，或者其它的IDE编辑器中的时候，我们想要通过pandas载入数据。我们通常的做法是先保存再载入，其实这样做起来十分繁琐。一个简单的方法就是使用<code>pd.read\\_clipboard()</code>&nbsp;直接从电脑的剪切板缓存区中提取数据。 </p> \n<p>这样我们就可以直接将结构数据转变为DataFrame或者Series了。excel表中数据是这样的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022271879\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在纯文本文件中，比如txt文件，是这样的：</p> \n<pre><code>a&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d  \n0&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1/1/00  \n2&nbsp;&nbsp;&nbsp;7.389056099&nbsp;N/A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5-Jan-13  \n4&nbsp;&nbsp;&nbsp;54.59815003&nbsp;nan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7/24/18  \n6&nbsp;&nbsp;&nbsp;403.4287935&nbsp;None&nbsp;&nbsp;&nbsp;&nbsp;NaT</code></pre> \n<p>将上面excel或者txt中的数据选中然后复制，然后使用pandas的<code>read_clipboard()</code>即可完成到DataFrame的转换。<code>parse_dates</code>参数设置为\"d\"，可以自动识别日期，并调整为<code>xxxx-xx-xx</code>的格式。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;df&nbsp;=&nbsp;pd.read_clipboard(na_values=[None],&nbsp;parse_dates=[\'d\'])  \n&gt;&gt;&gt;&nbsp;df  \n&nbsp;&nbsp;&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d  \n0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;1.0000&nbsp;&nbsp;inf&nbsp;2000-01-01  \n1&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;7.3891&nbsp;&nbsp;NaN&nbsp;2013-01-05  \n2&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;54.5982&nbsp;&nbsp;NaN&nbsp;2018-07-24  \n3&nbsp;&nbsp;6&nbsp;&nbsp;403.4288&nbsp;&nbsp;NaN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NaT  \n  \n&gt;&gt;&gt;&nbsp;df.dtypes  \na&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int64  \nb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float64  \nc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float64  \nd&nbsp;&nbsp;&nbsp;&nbsp;datetime64[ns]  \ndtype:&nbsp;object</code></pre> \n<h2>三、将pandas对象转换为“压缩”格式</h2> \n<p>在pandas中，我们可以直接将<code>objects</code>打包成为<code>gzip</code>, <code>bz2</code>, <code>zip</code>, or <code>xz</code>等压缩格式，而不必将没压缩的文件放在内存中然后进行转化。来看一个例子如何使用：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;abalone&nbsp;=&nbsp;pd.read_csv(url,&nbsp;usecols=[0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;8],&nbsp;names=cols)  \n  \n&gt;&gt;&gt;&nbsp;abalone  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sex&nbsp;&nbsp;length&nbsp;&nbsp;&nbsp;diam&nbsp;&nbsp;height&nbsp;&nbsp;weight&nbsp;&nbsp;rings  \n0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.455&nbsp;&nbsp;0.365&nbsp;&nbsp;&nbsp;0.095&nbsp;&nbsp;0.5140&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15  \n1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.350&nbsp;&nbsp;0.265&nbsp;&nbsp;&nbsp;0.090&nbsp;&nbsp;0.2255&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7  \n2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;0.530&nbsp;&nbsp;0.420&nbsp;&nbsp;&nbsp;0.135&nbsp;&nbsp;0.6770&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9  \n3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.440&nbsp;&nbsp;0.365&nbsp;&nbsp;&nbsp;0.125&nbsp;&nbsp;0.5160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10  \n4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;0.330&nbsp;&nbsp;0.255&nbsp;&nbsp;&nbsp;0.080&nbsp;&nbsp;0.2050&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7  \n5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;0.425&nbsp;&nbsp;0.300&nbsp;&nbsp;&nbsp;0.095&nbsp;&nbsp;0.3515&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8  \n6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;0.530&nbsp;&nbsp;0.415&nbsp;&nbsp;&nbsp;0.150&nbsp;&nbsp;0.7775&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20  \n...&nbsp;&nbsp;&nbsp;..&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;...  \n4170&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.550&nbsp;&nbsp;0.430&nbsp;&nbsp;&nbsp;0.130&nbsp;&nbsp;0.8395&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10  \n4171&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.560&nbsp;&nbsp;0.430&nbsp;&nbsp;&nbsp;0.155&nbsp;&nbsp;0.8675&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8  \n4172&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;0.565&nbsp;&nbsp;0.450&nbsp;&nbsp;&nbsp;0.165&nbsp;&nbsp;0.8870&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11  \n4173&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.590&nbsp;&nbsp;0.440&nbsp;&nbsp;&nbsp;0.135&nbsp;&nbsp;0.9660&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10  \n4174&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.600&nbsp;&nbsp;0.475&nbsp;&nbsp;&nbsp;0.205&nbsp;&nbsp;1.1760&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9  \n4175&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;0.625&nbsp;&nbsp;0.485&nbsp;&nbsp;&nbsp;0.150&nbsp;&nbsp;1.0945&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10  \n4176&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.710&nbsp;&nbsp;0.555&nbsp;&nbsp;&nbsp;0.195&nbsp;&nbsp;1.9485&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12</code></pre> \n<p>导入文件，读取并存为<code>abalone</code>（DataFrame结构）。当我们要存为压缩的时候，简单的使用&nbsp;<code>to_json()</code>即可轻松完成转化过程。下面通过设置相应参数将<code>abalone</code>存为了<code>.gz</code>格式的压缩文件。</p> \n<pre><code>abalone.to_json(\'df.json.gz\',&nbsp;orient=\'records\',  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lines=True,&nbsp;compression=\'gzip\')</code></pre> \n<p>如果我们想知道储存压缩文件的大小，可以通过内置模块os.path，使用getsize方法来查看文件的字节数。下面是两种格式储存文件的大小对比。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;import&nbsp;os.path  \n&gt;&gt;&gt;&nbsp;abalone.to_json(\'df.json\',&nbsp;orient=\'records\',&nbsp;lines=True)  \n&gt;&gt;&gt;&nbsp;os.path.getsize(\'df.json\')&nbsp;/&nbsp;os.path.getsize(\'df.json.gz\')  \n11.603035760226396</code></pre> \n<h2>四、使用\"测试模块\"制作伪数据</h2> \n<p>在pandas中，有一个测试模块可以帮助我们生成半真实（伪数据），并进行测试，它就是<code>util.testing</code>。下面同我们通过一个简单的例子看一下如何生成数据测试：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;import&nbsp;pandas.util.testing&nbsp;as&nbsp;tm  \n&gt;&gt;&gt;&nbsp;tm.N,&nbsp;tm.K&nbsp;=&nbsp;15,&nbsp;3&nbsp;&nbsp;#&nbsp;默认的行和列  \n  \n&gt;&gt;&gt;&nbsp;import&nbsp;numpy&nbsp;as&nbsp;np  \n&gt;&gt;&gt;&nbsp;np.random.seed(444)  \n  \n&gt;&gt;&gt;&nbsp;tm.makeTimeDataFrame(freq=\'M\').head()  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C  \n2000-01-31&nbsp;&nbsp;0.3574&nbsp;-0.8804&nbsp;&nbsp;0.2669  \n2000-02-29&nbsp;&nbsp;0.3775&nbsp;&nbsp;0.1526&nbsp;-0.4803  \n2000-03-31&nbsp;&nbsp;1.3823&nbsp;&nbsp;0.2503&nbsp;&nbsp;0.3008  \n2000-04-30&nbsp;&nbsp;1.1755&nbsp;&nbsp;0.0785&nbsp;-0.1791  \n2000-05-31&nbsp;-0.9393&nbsp;-0.9039&nbsp;&nbsp;1.1837  \n  \n&gt;&gt;&gt;&nbsp;tm.makeDataFrame().head()  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C  \nnTLGGTiRHF&nbsp;-0.6228&nbsp;&nbsp;0.6459&nbsp;&nbsp;0.1251  \nWPBRn9jtsR&nbsp;-0.3187&nbsp;-0.8091&nbsp;&nbsp;1.1501  \n7B3wWfvuDA&nbsp;-1.9872&nbsp;-1.0795&nbsp;&nbsp;0.2987  \nyJ0BTjehH1&nbsp;&nbsp;0.8802&nbsp;&nbsp;0.7403&nbsp;-1.2154  \n0luaYUYvy1&nbsp;-0.9320&nbsp;&nbsp;1.2912&nbsp;-0.2907</code></pre> \n<p>上面简单的使用了</p> \n<p><code>makeTimeDataFrame</code>&nbsp;和&nbsp;<code>makeDataFrame</code>&nbsp;分别生成了一组时间数据和DataFrame的数据。但这只是其中的两个用法，关于<code>testing</code>中的方法有大概30多个，如果你想全部了解，可以通过查看dir获得：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;[i&nbsp;for&nbsp;i&nbsp;in&nbsp;dir(tm)&nbsp;if&nbsp;i.startswith(\'make\')]  \n[\'makeBoolIndex\',  \n&nbsp;\'makeCategoricalIndex\',  \n&nbsp;\'makeCustomDataframe\',  \n&nbsp;\'makeCustomIndex\',  \n&nbsp;#&nbsp;...,  \n&nbsp;\'makeTimeSeries\',  \n&nbsp;\'makeTimedeltaIndex\',  \n&nbsp;\'makeUIntIndex\',  \n&nbsp;\'makeUnicodeIndex\']</code></pre> \n<h2><strong>五、从列项中创建DatetimeIndex</strong></h2> \n<p>也许我们有的时候会遇到这样的情形（为了说明这种情情况，我使用了product进行交叉迭代的创建了一组关于时间的数据）：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;from&nbsp;itertools&nbsp;import&nbsp;product  \n&gt;&gt;&gt;&nbsp;datecols&nbsp;=&nbsp;[\'year\',&nbsp;\'month\',&nbsp;\'day\']  \n  \n&gt;&gt;&gt;&nbsp;df&nbsp;=&nbsp;pd.DataFrame(list(product([2017,&nbsp;2016],&nbsp;[1,&nbsp;2],&nbsp;[1,&nbsp;2,&nbsp;3])),  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;columns=datecols)  \n&gt;&gt;&gt;&nbsp;df[\'data\']&nbsp;=&nbsp;np.random.randn(len(df))  \n&gt;&gt;&gt;&nbsp;df  \n&nbsp;&nbsp;&nbsp;&nbsp;year&nbsp;&nbsp;month&nbsp;&nbsp;day&nbsp;&nbsp;&nbsp;&nbsp;data  \n0&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-0.0767  \n1&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-1.2798  \n2&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;0.4032  \n3&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;1.2377  \n4&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-0.2060  \n5&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;0.6187  \n6&nbsp;&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;2.3786  \n7&nbsp;&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-0.4730  \n8&nbsp;&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;-2.1505  \n9&nbsp;&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-0.6340  \n10&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;0.7964  \n11&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;0.0005</code></pre> \n<p>明显看到，列项中有year，month，day，它们分别在各个列中，而并非是一个完整日期。那么如何从这些列中将它们组合在一起并设置为新的<code>index</code>呢？ </p> \n<p>通过<code>to_datetime</code>的使用，我们就可以直接将年月日组合为一个完整的日期，然后赋给索引。代码如下：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;df.index&nbsp;=&nbsp;pd.to_datetime(df[datecols])  \n&gt;&gt;&gt;&nbsp;df.head()  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;year&nbsp;&nbsp;month&nbsp;&nbsp;day&nbsp;&nbsp;&nbsp;&nbsp;data  \n2017-01-01&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-0.0767  \n2017-01-02&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-1.2798  \n2017-01-03&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;0.4032  \n2017-02-01&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;1.2377  \n2017-02-02&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-0.2060</code></pre> \n<p>当然，你可以选择将原有的年月日列移除，只保留data数据列，然后<code>squeeze</code>转换为Series结构。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;df&nbsp;=&nbsp;df.drop(datecols,&nbsp;axis=1).squeeze()  \n&gt;&gt;&gt;&nbsp;df.head()  \n2017-01-01&nbsp;&nbsp;&nbsp;-0.0767  \n2017-01-02&nbsp;&nbsp;&nbsp;-1.2798  \n2017-01-03&nbsp;&nbsp;&nbsp;&nbsp;0.4032  \n2017-02-01&nbsp;&nbsp;&nbsp;&nbsp;1.2377  \n2017-02-02&nbsp;&nbsp;&nbsp;-0.2060  \nName:&nbsp;data,&nbsp;dtype:&nbsp;float64  \n  \n&gt;&gt;&gt;&nbsp;df.index.dtype_str  \n\'datetime64[ns]</code></pre> \n<hr> \n<p>更多精彩内容请关注<strong>Python数据科学</strong></p>', 'https://segmentfault.com/img/remote/1460000022271880', null, null, '0', '0', null, '1', '2020-04-14 20:58:22', '2020-04-14 20:58:22');
INSERT INTO `tb_recommend` VALUES ('8493e96a1ab64f8bb84572c5a472b75a', '[Skr-Shop]购物车之架构设计', 'skr shop是一群底层码农，由于被工作中的项目折磨的精神失常，加之由于程序员的自傲：别人设计的系统都是一坨shit，我的设计才是宇宙最牛逼，于是乎决定要做一个只设计不编码的电商设计手册。', '<p>来还债了，希望大家在疫情中都是平安的，回来的时候公司也还在！</p> \n<hr> \n<blockquote>\n skr shop是一群底层码农，由于被工作中的项目折磨的精神失常，加之由于程序员的自傲：别人设计的系统都是一坨shit，我的设计才是宇宙最牛逼，于是乎决定要做一个只设计不编码的电商设计手册。\n</blockquote> \n<p>在上一篇文章 <a href=\"https://dayutalk.cn/2019/12/09/%E8%B4%AD%E7%89%A9%E8%BD%A6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/\" rel=\"nofollow noreferrer\">购物车设计之需求分析</a> 描述了购物车的通用需求。本文重点则在如何实现上进行架构上的设计（业务+系统架构）。</p> \n<h1>说明</h1> \n<p>架构设计可以分为三个层面：</p> \n<ul> \n <li>业务架构</li> \n <li>系统架构</li> \n <li>技术架构</li> \n</ul> \n<p>快速简单的说明下三个架构的意思；当我们拿到购物车需求时，我们说用Golang来实现，存储用Redis；这描述的是技术架构；我们对购物车代码项目进行代码分层，设计规范，以及依赖系统的规划这叫系统架构；</p> \n<p>那业务架构是什么呢？业务架构本质上是对系统架构的文字语言描述；什么意思？我们拿到一个需求首先要跟需求方进行沟通，建立统一的认知。比如：规范名词（购物车中说的商品与商品系统中商品的含义是不同的）；建立大家都能明白的模型，购物车、用户、商品、订单这些实体之间的互动，以及各自具备什么功能。</p> \n<p>在业务架构分析上有很多方法论，比如：领域驱动设计，但是它并不是唯一的业务架构分析方法，也并不是说最好的。适合你的就是最好的。我们常用的实体关系图、UML图也属于业务架构领域；</p> \n<p>这里需要强点一点的是，不管你用什么方式来建模设计，有设计总比没设计强，其次一定要将建模的内容体现到你的代码中去。</p> \n<p>本文在业务架构上的分析借助了 <code>DDD</code> （领域驱动设计）思想；还是那句话<code>适合的就是最好的</code>。</p> \n<h1>业务架构</h1> \n<p>通过前面的需求分析，我们已经明确我们的购物车要干什么了。先来看一下一个典型的用户操作购物车过程。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277102\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"用户旅程\" title=\"用户旅程\"></span></p> \n<p>在这个过程中，用户使用购物车这个载体完成了商品的购买流程；不断流动的数据是商品，购物车这个载体是稳定的。这是我们系统中的稳定点与变化点。</p> \n<p>商品的流动方式可能多种多样，比如从不同地方加入购物车，不同方式加入购物车，生命周期在购物车中也不一样；但是这个流程是稳定的，一定是先让购物车中存在商品，然后才能去结算产生订单。</p> \n<p>商品在购物车中的生命周期如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277103\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"过程\" title=\"过程\"></span></p> \n<p>按照这个过程，我们来看一下每个阶段对应的操作。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277104\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"过程对应的操作\" title=\"过程对应的操作\"></span></p> \n<p>这里注意一点，加车前这个操作其实我们可以放到购物车的添加操作中，但是由于这部分是非常不稳定且多变的。我们将其独立出来，方便后续进行扩展而不影响相对比较稳定的购物车阶段。</p> \n<blockquote>\n 上面这三个阶段，按照DDD中的概念，应该叫做实体，他们整体构成了购物车这个域；今天我们先不讲这些概念，就先略过，后面有机会单独发文讲解。\n</blockquote> \n<h2>加车前</h2> \n<p>通过流程分析，我们总结出了系统需要具备的操作接口，以及这些接口对应的实体，现在我们先来看加车前主要要做些什么；</p> \n<p>加车前其实主要就是对准备加入的购物车商品进行各个纬度的校验，检查是否满足要求。</p> \n<p>在让用户加车前，我们首先解决的是用户从哪里卖，然后进行验证？因为同一个商品从不同渠道购买是存在不同情况的，比如：小米手机，我们是通过秒杀买，还是通过好友众筹买，或者商城直接购买，价格存在差异，但是实际上他是同一个商品；</p> \n<p>第二个问题是是否具备购买资格，还是上面说的，秒杀、众筹这个加车操作，不是谁都可以添加的，得现有资格。那么资格的检查也是放到这里；</p> \n<p>第三个问题是对这个购买的商品进行商品属性上的验证，如是否上下架，有库存，限购数量等等。</p> \n<p>而且大家会发现，这里的验证条件可能是非常多变的。如何构建一个方便扩展的代码呢？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277105\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"加车的验证\" title=\"加车的验证\"></span></p> \n<p>整个加车过程，重要的就是根据来源来区分不同的验证。我们有两种选择方式。</p> \n<p>方式一：通过策略模式+门面模式的方式来搞定。策略就是根据不同的加车来源进行不同的验证，门面就是根据不同的来源封装一个个策略；</p> \n<p>方式二：通过责任链模式，但是这里需要有一个变化，这个链在执行过程中，可以选择跳过某些节点，比如：秒杀不需要库存、也不需要众筹的验证；</p> \n<p>通过综合的分析我选择了责任链的模式。贴一下核心代码</p> \n<pre><code>// 每个验证逻辑要实现的接口\ntype Handler interface {\n    Skipped(in interface{}) bool // 这里判断是否跳过\n    HandleRequest(in interface{}) error // 这里进行各种验证\n}\n\n// 责任链的节点\ntype RequestChain struct {\n    Handler\n    Next *RequestChain\n}\n\n// 设置handler\nfunc (h *RequestChain) SetNextHandler(in *RequestChain) *RequestChain {\n    h.Next = in\n    return in\n}</code></pre> \n<p>关于设计模式，大家可以看我小伙伴的github：<a href=\"https://github.com/TIGERB/easy-tips/tree/master/go/src/patterns\" rel=\"nofollow noreferrer\">https://github.com/TIGERB/eas...</a></p> \n<h2>购物车</h2> \n<p>说完了加车前，现在来看购物车这一部分。我们在之前曾讨论过，购物车可能会有多种形态的，比如：存储多个商品一起结算，某个商品立即结算等。因此购物车一定会根据渠道来进行购物车类型的选择。</p> \n<p>这部分的操作相对是比较稳定的。我们挑几个比较重要的操作来讲一下思路即可。</p> \n<h3>加入购物车</h3> \n<p>通过把条件验证的前置，会发现在进行加车操作时，这部分逻辑已经变得非常的轻量了。要做的主要是下面几个部分的逻辑。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277107\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"加入购物车\" title=\"加入购物车\"></span></p> \n<p>这里有几个取巧的地方，首先是获取商品的逻辑，由于在前面验证的时候也会用到，因此这里前面获取后会通过参数的方式继续往后传递，因此这里不需要在读库或者调用服务来获取；</p> \n<p>其次这里需要把当前用户现有购物车数据获取到，然后将添加的这个商品添加进来。这是一个类似合并操作，原来这个商品是存在，相当于数量加一；需要注意这个商品跟现存的商品有没有父子关系，有没有可能加入后改变了某个活动规则，比如：原来买了2个送1个赠品，现在再添加了一个变成3个，送2个赠品；</p> \n<blockquote>\n 注意：这里的添加并不是在购物车直接改数量，可能就是在列表、详情页直接添加添加。\n</blockquote> \n<p>通过将合并后的购物车数据，通过营销活动检查确认ok后，直接回写到存储中。</p> \n<h3>合并购物车</h3> \n<p>为什么会有合并购物车这个操作？因为一般电商都是准许游客身份进行操作的，因此当用户登录后需要将二者进行合并。</p> \n<p>这里的合并很多部分的逻辑是可以与加入购物车复用的逻辑。比如：合并后的数据都需要检查是否合法，然后覆写回存储中。因此大家可以看到这里的关联性。设计的方法在某种程度上要通用。</p> \n<h3>购物车列表</h3> \n<p>购物车列表这是一个非常重要的接口，原则上购物车接口会提供两种类型，一种简版，一种完全版本；</p> \n<p>简版的列表接口主要是用在类似PC首页右上角之类获取简单信息；完全版本就是在购物车列表中会用到。</p> \n<p>在实际实现中，购物车绝不仅仅是一个读取接口那么简单。因为我们都知道不管是商品信息、活动信息都是在不断的发生变化。因此每次的读取接口必然需要检查当前购物车中数据的合法性，然后发现不一致后需要覆写原存储的数据。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277106\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"购物车列表\" title=\"购物车列表\"></span></p> \n<p>也有一些做法会在每个接口都去检查数据的合法性，我建议为了性能考虑，部分接口可以适当放宽检查，在获取列表时再进行完整的检查。比如添加接口，我只会检测我添加的商品的合法性，绝不会对整个购物车进行检查。因为该操作之后一般都会调用列表操作，那么此时还会进行校验，二者重复操作，因此只取后者。</p> \n<h2>结算</h2> \n<p>结算包括两部分，结算页的详情信息与提交订单。结算页可以说是在购物车列表上的一个包装，因为结算页与列表页最大的不同是需要用户选择配送地址（虚拟商品另说），此时会产生更明确的价格信息，其他基本一致。因此在设计购物车列表接口的时候，一定要考虑充分的通用性。</p> \n<p>这里另外一个需要注意的是：立即购买，我们也会通过结算页接口来实现，但是内部其实还是会调用添加接口，将商品添加到购物车中；有三个需要注意的地方，首先是这个添加操作是服务内部完成的，对于服务调用方是不需要感知这个加入操作的存在；其次是这个购物车在Redis中的Key是独立于普通购物车的，否则二者的商品耦合在一起非常难于操作处理；最后立即购买的购物车要考虑账号多终端登录的时候，彼此数据不能互相影响，这里可以用每个端的uuid来作为购物车的标记避免这种情况。</p> \n<p>购物车的最后一步是生成订单，这一步最要紧的是需要给购物车加锁，避免提交过程中数据被篡改，多说一句，很多人写的Redis分布式锁代码都存在缺陷，大家一定要注意原子性的问题，这类文章网络上很多不再赘述。</p> \n<p>加锁成功之后，我们这里有多种做法，一种是按照DB涉及组织数据开始写表，这适用于业务量要求不大，比如订单每秒下单量不超过2000K的；那如果你的系统并发要求非常高怎么办？</p> \n<p>其实也很简单，高性能的三大法宝之一：异步；我们提交的时候直接将数据快照写入MQ中，然后通过异步的方式进行消费处理，可以通过通过控制消费者的数量来提升处理能力。这种方法虽然性能提升，但是复杂度也会上升，大家需要根据自己的实际情况来选择。</p> \n<p>关于业务架构的设计，到此告一段落，接下来我们来看系统架构。</p> \n<h1>系统架构</h1> \n<p>系统结构主要包含，如何将业务架构映射过来，以及输出对应输入参数、输出参数的说明。由于输入、输出针对各自业务来确定的，而且没有什么难度，我们这里就只说如何将业务架构映射到系统架构，以及系统架构中最核心的Redis数据结构选择以及存储的数据结构设计。</p> \n<h2>代码结构</h2> \n<p>下面的代码目录是按照 <code>Golang</code> 来进行设计的。我们来看看如何将上面的业务架构映射到代码层面来。</p> \n<pre><code class=\"golang\">├── addproducts.go\n├── cartlist.go\n├── mergecart.go\n├── entity\n│&nbsp;&nbsp; ├── cart\n│&nbsp;&nbsp; │&nbsp;&nbsp; ├── add.go\n│&nbsp;&nbsp; │&nbsp;&nbsp; ├── cart.go\n│&nbsp;&nbsp; │&nbsp;&nbsp; └── list.go\n│&nbsp;&nbsp; ├── order\n│&nbsp;&nbsp; │&nbsp;&nbsp; ├── checkout.go\n│&nbsp;&nbsp; │&nbsp;&nbsp; ├── order.go\n│&nbsp;&nbsp; │&nbsp;&nbsp; └── submit.go\n│&nbsp;&nbsp; └── precart\n├── event\n│&nbsp;&nbsp; └── sendorder.go\n├── facade\n│&nbsp;&nbsp; ├── activity.go\n│&nbsp;&nbsp; └── product.go\n└── repo</code></pre> \n<p>外层有 <code>entity</code>、<code>event</code>、<code>facade</code>、<code>repo</code>这四个目录，职责如下：</p> \n<p><strong>entity</strong>: 存放的是我们前面分析的购物领域的三个实体；所有主要的操作都在这三个实体上；</p> \n<p><strong>event</strong>: 这是用来处理产生的事件，比如刚刚说的如果我们提交订单采用异步的方式，那么该目录就该完成的是如何把数据发送到MQ中去；</p> \n<p><strong>facade</strong>: 这儿目录是干嘛的呢？这主要是因为我们的服务还需要依赖像商品、营销活动这些服务，那么我们不应该在实体中直接调用它，因为第三方可能存在变动，或者有增加、减少，我们在这里进行以下简单的封装(设计模式中的门面模式)；</p> \n<p><strong>repo</strong>: 这个目录从某种程度上可以理解为 <code>Model</code>层，在整个领域服务中，如果与持久化打交道，都通过它来完成。</p> \n<p>最后外层的几个文件，就是我们所提供的领域服务，供应用层来进行调用的。</p> \n<blockquote>\n 为了保证内容的紧凑，我这里放弃了对整个微服务的目录介绍，只单独介绍了领域服务，后续会单独成文介绍下微服务的整个系统架构。\n</blockquote> \n<p>通过上面的划分，我们完成了两件事情：</p> \n<ol> \n <li>业务架构分析的结构在系统代码中都有映射，他们彼此体现。这样最大的好处是，保证设计与代码的一致性，看了文档你就知道对应的代码在哪里；</li> \n <li>每个目录各自的关注点都进行了分离，更内聚，更容易开发与维护。</li> \n</ol> \n<h2>Redis存储</h2> \n<p>现在来看，我们选择Redis作为购物商品数据的存储，我们要解决两个问题，一是我们需要存哪些数据？二是我们用什么结构来存？</p> \n<p>网络上很多写购物车的都是只保存一个商品id，真实场景是很难满足需求的。你想想，一个商品id如何记住用户选择的赠品？用户上次选择的活动？以及购买的商品渠道？</p> \n<p>综合比较通用的场景，我给出一个参考结构：</p> \n<pre><code class=\"golang\">// 购物车数据\ntype ShoppingData struct {\n    Item       []*Item `json:\"item\"`\n    UpdateTime int64   `json:\"update_time\"`\n    Version    int32   `json:\"version\"`\n}\n\n// 单个商品item元素\ntype Item struct {\n    ItemId       string          `json:\"item_id\"`\n    ParentItemId string          `json:\"parent_item_id,omitempty\"` // 绑定的父item id\n    OrderId      string          `json:\"order_id,omitempty\"`       // 绑定的订单号\n    Sku          int64           `json:\"sku\"`\n    Spu          int64           `json:\"spu\"`\n    Channel      string          `json:\"channel\"`\n    Num          int32           `json:\"num\"`\n    Status       int32           `json:\"status\"`\n    TTL          int32           `json:\"ttl\"`                     // 有效时间\n    SalePrice    float64         `json:\"sale_price\"`              // 记录加车时候的销售价格\n    SpecialPrice float64         `json:\"special_price,omitempty\"` // 指定价格加购物车\n    PostFree     bool            `json:\"post_free,omitempty\"`     // 是否免邮\n    Activities   []*ItemActivity `json:\"activities,omitempty\"`    // 参加的活动记录\n    AddTime      int64           `json:\"add_time\"`\n    UpdateTime   int64           `json:\"update_time\"`\n}\n\n// 活动\ntype ItemActivity struct {\n    ActID    string `json:\"act_id\"`\n    ActType  string `json:\"act_type\"`\n    ActTitle string `json:\"act_title\"`\n}</code></pre> \n<p>重点说一下 <code>Item</code> 这个结构，<code>item_id</code> 这个字段是标记购物车中某个商品的唯一标记，因为我们之前说过，同一个sku由于渠道不同，那么在购物车中会是两个不同的item；接下来的 <code>parent_item_id</code> 字段是用来标记父子关系的，这里将可能存在的树结构转成了顺序结构，我们不管是父商品还是子商品，都采用顺序存储，然后通过这个字段来进行关联；有些同学可能会奇怪，为什么会存order id这个字段呢？大家关注下自己的日常业务，比如：再来一单、定金预售等，这种一定是与某个订单相关联的，不管是为了资格验证还是数据统计。剩下的字段都是一些非常常规的字段，就不在一一介绍了；</p> \n<blockquote>\n 字段的类型，大家根据自己的需要进行修改。\n</blockquote> \n<p>接下来该说怎么选择Redis的存储结构了，Redis常用的 <code>Hash Table、集合、有序集合、链表、字符串</code> 五种，我们一个个来分析。</p> \n<p>首先购车一定有一个key来标记这个购物车属于哪个用户的，为了简化，我们的key假设是：<code>uid:cart_type</code>。</p> \n<p>我们先来看如果用 <code>Hash Table</code>；我们添加时，需要用到如下命令：<code>HSET uid:cart_type sku ShoppingData</code>；看起来没问题，我们可以根据sku快速定位某个商品然后进行相关的修改等，但是注意，ShoppingData是一个json串，如果用户购物车中有非常多的商品，我们用 <code>HGETALL uid:cart_type</code> 获取到的时间复杂度是O(n)，然后代码中还需要一一反序列化，又是O(n)的复杂度。</p> \n<p>如果用<code>集合</code>，也会遇到类似的问题，每个购物车看做一个集合，集合中的每个元素是 ShoppingData ，取到代码中依然需要逐一反序列化(反序列化是成本)，关于有序集合与链表就不在分析，大家可以按照上面的思路去尝试下问题所在。</p> \n<p>看起来我们没得选，只有使用<code>String</code>，那我们来看一下<code>String</code>的契合度是什么样子。首先<code>SET uid:cart_type ShoppingDataArr</code>；我们把购物车所有的数据序列化成一个字符串存储，每次取出来的时间复杂度是O(1)，序列化、反序列化都只需要一次。看来是非常不错的选择。但是在使用中大家还是有几点需要注意。</p> \n<ol> \n <li>单个Value不能太大，要不然就会出现大key问题，所以一般购物车有上限限制，比如item不能超过多少个；</li> \n <li>对redis的操作性能提升上来了，但是代码的就是修改单个item时的不便，必须每次读取全部然后找到对应的item进行修改；这里我们可以把从redis中的数据读取出来后，在内存中构建一个HashTable，来减少每次遍历的复杂度；</li> \n</ol> \n<p>网上也看到很多Redis数据结构组合使用来保存购物车数据的，但是无疑增加了网络开销，相比起来还是String最经济划算。</p> \n<h1>总结</h1> \n<p>至此对于购物车的实现设计算是完结了，其中关于订单表的设计会单独放到订单模块去讲。</p> \n<p>对于整个购物车服务，虽然没有写的详细到某个具体的接口，但是分析到这一步，我相信大家心中都是有沟壑的，能够结合自己的业务去实现它。</p> \n<p>文中有些很有意思的地方，建议大家动手去做做看，有任何问题，我们随时交流。</p> \n<ul> \n <li>改编版的责任链模式</li> \n <li>Redis的分布式事务锁实现</li> \n</ul> \n<p>接下来终于要到订单部分的设计了，希望大家继续关注我们。</p> \n<p><strong>项目地址：<a href=\"https://github.com/skr-shop/manuals\" rel=\"nofollow noreferrer\">https://github.com/skr-shop/m...</a></strong></p>', 'https://segmentfault.com/img/remote/1460000022277102', null, null, '0', '0', null, '1', '2020-04-14 20:58:23', '2020-04-14 20:58:23');
INSERT INTO `tb_recommend` VALUES ('883ffb9c97404006b894634d53a1b0c3', 'IINA 播放器开发者称其开源项目，屡次被盗用上架并且收费获利', 'IINA，是一个基于 mpv、契合 macOS 设计风格、力求做到最佳用户体验、轻便且功能强大的视频播放器项目。IINA 以 mpv 为播放核心，所以享受到了 mpv 解码和图像方面的所有优点。IINA 使用了 libmpv 的 C API，来提...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022271502\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Feature 1\" title=\"Feature 1\"></span></p> \n<p><a href=\"https://iina.io/\" rel=\"nofollow noreferrer\">IINA</a>，是一个基于 mpv、契合 macOS 设计风格、力求做到最佳用户体验、轻便且功能强大的视频播放器项目。IINA 以 mpv 为播放核心，所以享受到了 mpv 解码和图像方面的所有优点。IINA 使用了 libmpv 的 C API，来提供更加稳定快速的渲染和控制。此外，它使用原始屏幕分辨率渲染，所以比起其他一些播放器画质有显著提高。</p> \n<p>SegmentFault 思否消息：近期 IINA 播放器的开发者发文称，作为一个开源项目，屡次被盗用上架并且收费获利，确实是很无奈的事情，但是有的开发者被发现后主动下架，有的从不回应，现在貌似还有了理直气壮拒不承认的。</p> \n<p>开发者的态度是：作为开源项目，我们无意私藏这些东西，只要遵守许可证，对它进行再发布和出售也无妨；而这位开发者做的是：把所有贡献者的名字抹除掉换成了自己，并试图在这个基础上盈利。这是我无法忍受的。</p> \n<hr> \n<p><strong>针对这个情况，我们也咨询了我们思否合作的律师事务所君合的律师团队，以下是君合团队给出的反馈：</strong></p> \n<p>开源软件是一种开放软件授权使用限制的软件，开源软件的版权持有人通常授予他人自由使用、复制、散布、研究和改进软件的权利，但是其具体授权使用方式需按照相应开源许可证（“开源协议”或“许可证”）执行。一般每一个开源软件都会附有一个许可证，该许可证以格式文本形式的授权许可协议体现，许可证规定了软件使用者的权利和义务，使用者只有同意遵守这个许可证才可合法使用开源软件（或者使用该开源软件即视为同意接受该许可证）。</p> \n<p>我国法律目前对开源软件没有明确的、有针对性的具体规定，但是在法院审判实践中，法院在相关司法判例中引用了一些开源协议（如GPL协议、CC协议等），并认可开源协议在当事人（授权人、被授权人）之间的效力以及对当事人的约束力。</p> \n<p>以GPL协议为例，根据该协议第4条规定，传播未修改的完整源代码需要满足以下条件：（1）显著而适当地在每个副本上发布一个合适的版权声明；（2）附上陈述本协议和任何按照协议第7条加入的非许可的条款的全部、完整的声明；（3）附上全部、完整的免责申明；（4）随程序给所有的接受者（recipients）一份本协议。</p> \n<p>另根据GPL协议（3.0版本）第5条规定，用户可以以源代码的方式传播“基于GPL程序所开发的作品”或从GPL程序中取出一部分，对此部分进行修改而形成修改版，该传播行为必须首先符合第4条的规定（传播未修改的完整源代码的条件），并且符合以下所有条件：（1）作品应包含显著声明，说明用户修改了GPL程序，并指出修改了时间；（2）作品必须包含明确的声明，说明该作品在本协议下发布，并指出任何按照第6款（附加条款）加入的条件；（3）用户应根据本协议授权获取作品副本的使用者使用整个作品，本协议和任何按照第7款（附加条款）加入的条件一起，对整个作品及其所有部分发生法律效力，无论是以何种形式打包的作品；（4）如果作品中有用户界面，则应在界面中显示适当的法律声明；然而如果GPL程序存在用户界面，但该界面没有显示法律声明，则用户由此开发的作品没有必要修改该界面显示。</p> \n<p>因此，如果用户使用开源软件，需遵守开源协议的要求，如果使用者不遵守开源协议，其自由使用开源软件的许可可以被开源软件的著作权人终止，并且，开源软件的著作权人可以主张使用者使用开源软件的行为侵犯其软件著作权。</p> \n<p><strong>各位思否社区的开发者怎么看？欢迎在评论区留言。</strong></p> \n<hr> \n<p>以下是 IINA 播放器的开发者发布的原文：<strong>剽窃别人成果的人一直有，不过今天遇到了格外厉害的</strong></p> \n<p>我是<a href=\"https://github.com/iina/iina\" rel=\"nofollow noreferrer\">IINA</a>的开发者。一直以来 IINA 都面临一个小问题，就是有人用它的代码上架 Mac App Store （ MAS ）。IINA 使用的 GPLv3 许可证和 MAS 的协议是冲突的，这也是 IINA 至今都没有 MAS 版本的原因之一。</p> \n<p>这个问题一直存在。一直以来我的流程是向 MAS 提交 Dispute 。Apple 对这种事情的处理比较懒，会要求对方的开发者和我直接沟通。一小部分开发者可能会主动下架，但大部分都是选择沉默。对方的开发者在提醒两次都不回应的情况下，MAS 会将 App 强制下架，而这整个流程差不多要三个月（也就是对方开发者可以继续销售三个月）。</p> \n<p>这些操作我其实都习惯了（ Notes.app 里都放了一份模板来写 Dispute ）。我毕竟有自己的日常工作，让 Apple 来处理这种事情，虽然慢一点也是最好的选择。不过今天遇到的一位开发者非常厉害。我把他回复的原话复制上来：</p> \n<blockquote>\n 请问我哪里使用了，请告知，谢谢！\n</blockquote> \n<p>这款名叫 MPlayer X Pro 的 App 在港区售价 15 港币，国区应该是 12 元左右。如果你试用一下就会发现，它完全就是 IINA 的复制品。之前见过的复制品有的还会加上一些分享之类的新功能，而这个相比之下显得非常没有诚意。</p> \n<p>当然，仅仅口头上说「用户界面完全一致」也很难作为证据，那我打开稍微看了一下它里面有什么：</p> \n<ul> \n <li>此 App 和 IINA 有完全相同的用户界面，完全相同的 xib 结构。</li> \n <li>反编译后，可以看到绝大部分代码结构都是雷同的。</li> \n <li>此 App 中包含的资源文件，包括文件图标，本地化文件等等和 IINA 中包含的一模一样，SHA 结果相同。</li> \n <li>此 App 包含了没有任何用处的 cli 二进制文件（修改自 iina-cli ）。</li> \n <li>此 App 使用的二进制库和 IINA 使用的完全相同。</li> \n <li>此 App 中的 Translator.json 中有 IINA 所有的翻译者名字和联系方式。这位开发者只把我的联系方式改成了他自己的，连我的名字都留在里面。</li> \n <li>此 App 中包含了 IINA 用于自动更新的公钥文件。噗，你要这个干嘛！</li> \n</ul> \n<p>我实在是吃惊于这位开发者居然能在这样的情况下说出「请问我哪里使用了」这种话来。虽然近期更新缓慢，我们在业余时间也是一直持续开发，IINA 中使用的图标基本上都是我自己画的，现在积累的 20 多种语言的翻译也都是各国译者的努力成果。作为开源项目，我们无意私藏这些东西，只要遵守许可证，对它进行再发布和出售也无妨；而这位开发者做的是：<strong>把所有贡献者的名字抹除掉换成了自己，并试图在这个基础上盈利</strong>。这是我无法忍受的。</p> \n<p>IINA 从 2017 年发布到现在，域名、开发者证书、官网和邮件服务器都是我在出钱（确切地说，0.0.4 的时候短暂地贴了一下支付宝二维码，不过当时没有稳定的下载渠道，买 CDN 很快就用完了）。很多人建议我们开放捐助，不过因为事情太多更新太慢，没有精力也不太好意思（目前打算在插件系统做完后接受捐助，我觉得不会超过几个月；关于捐助的详情到时候会另外写点什么）。</p> \n<p>我相信在 v2 上发帖吐槽并不能解决问题，反而可能还会有人本来没这想法，现在看了也想试试了（不）。更多的是让自己心情好一点吧。</p> \n<blockquote> \n <p>最后放一下这位开发者的信息。这些信息都是可以在 MAS 或是这款 App “MPlayer X Pro” 的资源文件中公开查到的。请注意，我并不希望有人滥用这些信息或者用它获取这位开发者的其他隐私，而是希望如果有人认识这位开发者或者与其有合作，可以考虑敬而远之。</p> \n <ul> \n  <li>邮箱：13728063720@139.com</li> \n  <li>姓名：yuanteng li</li> \n  <li>App 中附带的微信二维码（外链）：<a href=\"https://imgur.com/a/Pnx14rq\" rel=\"nofollow noreferrer\">https://imgur.com/a/Pnx14rq</a> </li> \n </ul> \n <p><strong>事件后续</strong>：感谢大家的回复和支持！看到能引起这么多人的关注很开心。 </p> \n <p>今天对方回复说是「离职员工私自上传」，这个的可信度相信大家都自有判断。目前来看可以先等 Apple 处理了。 </p> \n <p>关于 IINA 的上架问题：我们可以考虑给 MAS 单独用一份许可证发布，不过要先征求贡献者的同意。同时，调用了私有 API 的功能（比如 PIP ）都要在 MAS 版本去掉。不过这些一直没有搞的原因还是太忙了……我觉得是需要想一下上架问题了。 </p> \n <p>关于捐助：可能大家也发现近一年 IINA 更新缓慢，如果一直收到捐助却不干活感觉说不过去，大家也不是为了钱才持续维护的。不过捐助（和大更新）几个月内会有的。 </p> \n <p>发帖之后有群友告诉我还有人在淘宝上卖 IINA 的，去搜了一下笑死了</p> \n <p><strong>对方已经下架了。 </strong> </p> \n <p>现在 App Store 上仍然有其他复制品存在，所以我们已经在考虑 MAS 版本的可行性。MAS 版本也不会收费，毕竟这不是个以营利为目标的项目。 </p> \n <p>有网友通过电话邮件微信等方式直接联系了侵权的开发者，谢谢你们的帮助。这虽然非常有效，但只能说是无奈之举，终究不是正确而且万能的做法。侵权的开发者已经在邮件中道歉，我也不想再去追究对方的销售所得等等，更希望把精力用在 MAS 版本的 IINA 上，以杜绝这种问题的持续出现。希望大家不要再通过以上联系方式骚扰对方了。 </p> \n <p>再次感谢大家的声援。</p> \n</blockquote> \n<p>原文链接：<a href=\"https://www.v2ex.com/t/658387\" rel=\"nofollow noreferrer\">https://www.v2ex.com/t/658387</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sf.png\" title=\"sf.png\"></span></p>', 'https://segmentfault.com/img/remote/1460000022271502', null, null, '0', '0', null, '1', '2020-04-14 20:58:20', '2020-04-14 20:58:20');
INSERT INTO `tb_recommend` VALUES ('884217e6150e4cc6baf9de7d6a6ac14b', '小程序框架运行时性能大测评', '随着小程序在商业上的巨大成功，小程序开发在国内前端领域越来越受到重视，为了方便广大开发者更好地进行小程序开发，各类小程序框架也层出不穷，呈现出百花齐放的态势。但是到目前为止，业内一直没有出现一份全...', '<blockquote>\n 作者：董宏平(hiyuki)，滴滴出行小程序负责人，mpx框架负责人及核心作者\n</blockquote> \n<p>随着小程序在商业上的巨大成功，小程序开发在国内前端领域越来越受到重视，为了方便广大开发者更好地进行小程序开发，各类小程序框架也层出不穷，呈现出百花齐放的态势。但是到目前为止，业内一直没有出现一份全面、详细、客观、公正的小程序框架测评报告，为小程序开发者在技术选型时提供参考。于是我便筹划推出一系列文章，对业内流行的小程序框架进行一次全方位的、客观公正的测评，本文是系列文章的第一篇——运行时性能篇。</p> \n<p>在本文中，我们会对下列框架进行运行时性能测试(排名不分先后):</p> \n<ul> \n <li>wepy2(<a href=\"https://github.com/Tencent/wepy)\" rel=\"nofollow noreferrer\">https://github.com/Tencent/wepy)</a> @2.0.0-alpha.20</li> \n <li>uniapp(<a href=\"https://github.com/dcloudio/uni-app)\" rel=\"nofollow noreferrer\">https://github.com/dcloudio/u...</a> @2.0.0-26120200226001</li> \n <li>mpx(<a href=\"https://github.com/didi/mpx)\" rel=\"nofollow noreferrer\">https://github.com/didi/mpx)</a> @2.5.3</li> \n <li>chameleon(<a href=\"https://github.com/didi/chameleon)\" rel=\"nofollow noreferrer\">https://github.com/didi/chame...</a> @1.0.5</li> \n <li>mpvue(<a href=\"https://github.com/Meituan-Dianping/mpvue)\" rel=\"nofollow noreferrer\">https://github.com/Meituan-Di...</a> @2.0.6</li> \n <li>kbone(<a href=\"https://github.com/Tencent/kbone)\" rel=\"nofollow noreferrer\">https://github.com/Tencent/kb...</a> @0.8.3</li> \n <li>taro next(<a href=\"https://github.com/NervJS/taro)\" rel=\"nofollow noreferrer\">https://github.com/NervJS/taro)</a> @3.0.0-alpha.5</li> \n</ul> \n<p>其中对于kbone和taro next均以vue作为业务框架进行测试。</p> \n<p>运行时性能的测试内容包括以下几个维度：</p> \n<ul> \n <li>框架运行时体积</li> \n <li>页面渲染耗时</li> \n <li>页面更新耗时</li> \n <li>局部更新耗时</li> \n <li>setData调用次数</li> \n <li>setData发送数据大小</li> \n</ul> \n<p>框架性能测试demo全部存放于<a href=\"https://github.com/hiyuki/mp-framework-benchmark\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a> 中，欢迎广大开发者进行验证纠错及补全；</p> \n<h2>测试方案</h2> \n<p>为了使测试结果真实有效，我基于常见的业务场景构建了两种测试场景，分别是动态测试场景和静态测试场景。</p> \n<h3>动态测试场景</h3> \n<p>动态测试中，视图基于数据动态渲染，静态节点较少，视图更新耗时和setData调用情况是该测试场景中的主要测试点。</p> \n<p>动态测试demo模拟了实际业务中常见的长列表+多tab场景，该demo中存在两份优惠券列表数据，一份为可用券数据，另一份为不可用券数据，其中同一时刻视图中只会渲染展示其中一份数据，可以在上方的操作区模拟对列表数据的各种操作及视图展示切换(切tab)。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022249437\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"动态测试demo\" title=\"动态测试demo\"></span></p> \n<p><em>动态测试demo</em></p> \n<p>在动态测试中，我在外部通过函数代理的方式在初始化之前将App、Page和Component构造器进行代理，通过mixin的方式在Page的onLoad和Component的created钩子中注入setData拦截逻辑，对所有页面和组件的setData调用进行监听，并统计小程序的视图更新耗时及setData调用情况。该测试方式能够做到对框架代码的零侵入，能够跟踪到小程序全量的setData行为并进行独立的耗时计算，具有很强的普适性，代码具体实现可以查看<a href=\"https://github.com/hiyuki/mp-framework-benchmark/blob/master/utils/proxy.js\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a></p> \n<h3>静态测试场景</h3> \n<p>静态测试模拟业务中静态页面的场景，如运营活动和文章等页面，页面内具备大量的静态节点，而没有数据动态渲染，初始ready耗时是该场景下测试的重心。</p> \n<p>静态测试demo使用了我去年发表的一篇技术文章的html代码进行小程序适配构建，其中包含大量静态节点及文本内容。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022249436\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"静态测试demo\" title=\"静态测试demo\"></span></p> \n<p><em>静态测试demo</em></p> \n<h2>测试流程及数据</h2> \n<blockquote>\n 以下所有耗时类的测试数据均为微信小程序中真机进行5次测试计算平均值得出，单位均为ms。Ios测试环境为手机型号iPhone 11，系统版本13.3.1，微信版本7.0.12，安卓测试环境为手机型号小米9，系统版本Android10，微信版本7.0.12。\n</blockquote> \n<blockquote>\n 为了使数据展示不过于混乱复杂，文章中所列的数据以Ios的测试结果为主，安卓测试结论与Ios相符，整体耗时比Ios高3~4倍左右，所有的原始测试数据存放在\n <a href=\"https://github.com/hiyuki/mp-framework-benchmark/blob/master/rawData.csv\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a> \n</blockquote> \n<blockquote>\n 由于transform-runtime引入的core-js会对框架的运行时体积和运行耗时带来一定影响，且不是所有的框架都会在编译时开启transform-runtime，为了对齐测试环境，下述测试均在transform-runtime关闭时进行。\n</blockquote> \n<h3>框架运行时体积</h3> \n<p>由于不是所有框架都能够使用<code>webpack-bundle-analyzer</code>得到精确的包体积占用，这里我通过将各框架生成的demo项目体积减去native编写的demo项目体积作为框架的运行时体积。</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>demo总体积(KB)</th> \n   <th>框架运行时体积(KB)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>27</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>66</td> \n   <td>39</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>114</td> \n   <td>87</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>78</td> \n   <td>51</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>136</td> \n   <td>109</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>103</td> \n   <td>76</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>395</td> \n   <td>368</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>183</td> \n   <td>156</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native &gt; wepy2 &gt; mpx &gt; mpvue &gt; uniapp &gt; chameleon &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>wepy2和mpx在框架运行时体积上控制得最好；</li> \n <li>taro next和kbone由于动态渲染的特性，在dist中会生成递归渲染模板/组件，所以占用体积较大。</li> \n</ul> \n<h3>页面渲染耗时(动态测试)</h3> \n<p>我们使用<code>刷新页面</code>操作触发页面重新加载，对于大部分框架来说，页面渲染耗时是从触发刷新操作到页面执行onReady的耗时，但是对于像kbone和taro next这样的动态渲染框架，页面执行onReady并不代表视图真正渲染完成，为此，我们设定了一个特殊规则，在页面onReady触发的1000ms内，在没有任何操作的情况下出现setData回调时，以最后触发的setData回调作为页面渲染完成时机来计算真实的页面渲染耗时，测试结果如下：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>页面渲染耗时</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>60.8</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>64</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>56.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>52.6</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>56.4</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>117.8</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>98.6</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>89.6</td> \n  </tr> \n </tbody> \n</table> \n<blockquote>\n 该项测试的耗时并不等同于真实的渲染耗时，由于小程序自身没有提供performance api，真实渲染耗时无法通过js准确测试得出，不过从得出的数据来看该项数据依然具备一定的参考意义。\n</blockquote> \n<p>该项测试的结论为： <br>mpx ≈ chameleon ≈ uniapp ≈ native ≈ wepy2 &gt; taro next ≈ kbone ≈ mpvue</p> \n<p>结论分析：</p> \n<ul>\n <li>由于mpvue全量在页面进行渲染，kbone和taro next采用了动态渲染技术，页面渲染耗时较长，其余框架并无太大区别。</li>\n</ul> \n<h3>页面更新耗时(无后台数据)</h3> \n<p>这里后台数据的定义为data中存在但当前页面渲染中未使用到的数据，在这个demo场景下即为不可用券的数据，当前会在不可用券为0的情况下，对可用券列表进行各种操作，并统计更新耗时。</p> \n<p>更新耗时的计算方式是从数据操作事件触发开始到对应的setData回调完成的耗时</p> \n<blockquote>\n mpvue中使用了当前时间戳(new Date)作为超时依据对setData进行了超时时间为50ms的节流操作，该方式存在严重问题，当vue内单次渲染同步流程执行耗时超过50ms时，后续组件patch触发的setData会突破这个节流限制，以50ms每次的频率对setData进行高频无效调用。在该性能测试demo中，当优惠券数量超过500时，界面就会完全卡死。为了顺利跑完整个测试流程，我对该问题进行了简单修复，使用setTimeout重写了节流部分，确保在vue单次渲染流程同步执行完毕后才会调用setData发送合并数据，之后mpvue的所有性能测试都是基于这个patch版本来进行的，该patch版本存放在\n <a href=\"https://github.com/hiyuki/mp-framework-benchmark/blob/master/frameworks/mpvue/runtime/patch/index.js\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a> \n</blockquote> \n<blockquote>\n 理论上来讲native的性能在进行优化的前提下一定是所有框架的天花板，但是在日常业务开发中我们可能无法对每一次setData都进行优化，以下性能测试中所有的native数据均采用修改数据后全量发送的形式来实现。\n</blockquote> \n<p>第一项测试我们使用<code>新增可用券(100)</code>操作将可用券数量由0逐级递增到1000：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>100</th> \n   <th>200</th> \n   <th>300</th> \n   <th>400</th> \n   <th>500</th> \n   <th>600</th> \n   <th>700</th> \n   <th>800</th> \n   <th>900</th> \n   <th>1000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>84.6</td> \n   <td>69.8</td> \n   <td>71.6</td> \n   <td>75</td> \n   <td>77.2</td> \n   <td>78.8</td> \n   <td>82.8</td> \n   <td>93.2</td> \n   <td>93.4</td> \n   <td>105.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>118.4</td> \n   <td>168.6</td> \n   <td>204.6</td> \n   <td>246.4</td> \n   <td>288.6</td> \n   <td>347.8</td> \n   <td>389.2</td> \n   <td>434.2</td> \n   <td>496</td> \n   <td>539</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>121.2</td> \n   <td>100</td> \n   <td>96</td> \n   <td>98.2</td> \n   <td>97.8</td> \n   <td>99.6</td> \n   <td>104</td> \n   <td>102.4</td> \n   <td>109.4</td> \n   <td>107.6</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>110.4</td> \n   <td>87.2</td> \n   <td>82.2</td> \n   <td>83</td> \n   <td>80.6</td> \n   <td>79.6</td> \n   <td>86.6</td> \n   <td>90.6</td> \n   <td>89.2</td> \n   <td>96.4</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>116.8</td> \n   <td>115.4</td> \n   <td>117</td> \n   <td>119.6</td> \n   <td>122</td> \n   <td>125.2</td> \n   <td>133.8</td> \n   <td>133.2</td> \n   <td>144.8</td> \n   <td>145.6</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>112.8</td> \n   <td>121.2</td> \n   <td>140</td> \n   <td>169</td> \n   <td>198.8</td> \n   <td>234.2</td> \n   <td>278.8</td> \n   <td>318.4</td> \n   <td>361.4</td> \n   <td>408.2</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>556.4</td> \n   <td>762.4</td> \n   <td>991.6</td> \n   <td>1220.6</td> \n   <td>1468.8</td> \n   <td>1689.6</td> \n   <td>1933.2</td> \n   <td>2150.4</td> \n   <td>2389</td> \n   <td>2620.6</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>470</td> \n   <td>604.6</td> \n   <td>759.6</td> \n   <td>902.4</td> \n   <td>1056.2</td> \n   <td>1228</td> \n   <td>1393.4</td> \n   <td>1536.2</td> \n   <td>1707.8</td> \n   <td>1867.2</td> \n  </tr> \n </tbody> \n</table> \n<p>然后我们按顺序逐项点击<code>删除可用券(all)</code> &gt; <code>新增可用券(1000)</code> &gt; <code>更新可用券(1)</code> &gt; <code>更新可用券(all)</code> &gt; <code>删除可用券(1)</code>：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>delete(all)</th> \n   <th>add(1000)</th> \n   <th>update(1)</th> \n   <th>update(all)</th> \n   <th>delete(1)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>32.8</td> \n   <td>295.6</td> \n   <td>92.2</td> \n   <td>92.2</td> \n   <td>83</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>56.8</td> \n   <td>726.4</td> \n   <td>49.2</td> \n   <td>535</td> \n   <td>530.8</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>43.6</td> \n   <td>584.4</td> \n   <td>54.8</td> \n   <td>144.8</td> \n   <td>131.2</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>41.8</td> \n   <td>489.6</td> \n   <td>52.6</td> \n   <td>169.4</td> \n   <td>165.6</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>39</td> \n   <td>765.6</td> \n   <td>95.6</td> \n   <td>237.8</td> \n   <td>144.8</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>103.6</td> \n   <td>669.4</td> \n   <td>404.4</td> \n   <td>414.8</td> \n   <td>433.6</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>120.2</td> \n   <td>4978</td> \n   <td>2356.4</td> \n   <td>2419.4</td> \n   <td>2357</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>126.6</td> \n   <td>3930.6</td> \n   <td>1607.8</td> \n   <td>1788.6</td> \n   <td>2318.2</td> \n  </tr> \n </tbody> \n</table> \n<blockquote>\n 该项测试中初期我update(all)的逻辑是循环对每个列表项进行更新，形如\n <code>listData.forEach((item)=&gt;{item.count++})</code>，发现在chameleon框架中执行界面会完全卡死，追踪发现chameleon框架中没有对setData进行异步合并处理，而是在数据变动时直接同步发送，这样在数据量为1000的场景下用该方式进行更新会高频触发1000次setData，导致界面卡死；对此，我在chameleon框架的测试demo中，将update(all)的逻辑调整为深clone产生一份更新后的listData，再将其整体赋值到this.listData当中，以确保该项测试能够正常进行。\n</blockquote> \n<p>该项测试的结论为： <br>native &gt; mpx ≈ uniapp &gt; chameleon &gt; mpvue &gt; wepy2 &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>mpx和uniapp在框架内部进行了完善的diff优化，随着数据量的增加，两个框架的新增耗时没有显著上升；</li> \n <li>wepy2会在数据变更时对props数据也进行setData，在该场景下造成了大量的无效性能损耗，导致性能表现不佳；</li> \n <li>kbone和taro next采用了动态渲染方案，每次新增更新时会发送大量描述dom结构的数据，与此同时动态递归渲染的耗时也远大于常规的静态模板渲染，使得这两个框架在所有的更新场景下耗时都远大于其他框架。</li> \n</ul> \n<h3>页面更新耗时(有后台数据)</h3> \n<p>刷新页面后我们使用<code>新增不可用券(1000)</code>创建后台数据，观察该操作是否会触发setData并统计耗时</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>back add(1000)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>45.2</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>174.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>89.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>142.6</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>134</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>0</td> \n  </tr> \n </tbody> \n</table> \n<blockquote>\n mpx进行setData优化时inspired by vue，使用了编译时生成的渲染函数跟踪模板数据依赖，在后台数据变更时不会进行setData调用，而kbone和taro next采用了动态渲染技术模拟了web底层环境，在上层完整地运行了vue框架，也达到了同样的效果。\n</blockquote> \n<p>然后我们执行和上面无后台数据时相同的操作进行耗时统计，首先是递增100：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>100</th> \n   <th>200</th> \n   <th>300</th> \n   <th>400</th> \n   <th>500</th> \n   <th>600</th> \n   <th>700</th> \n   <th>800</th> \n   <th>900</th> \n   <th>1000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>88</td> \n   <td>69.8</td> \n   <td>71.2</td> \n   <td>80.8</td> \n   <td>79.4</td> \n   <td>84.4</td> \n   <td>89.8</td> \n   <td>93.2</td> \n   <td>99.6</td> \n   <td>108</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>121</td> \n   <td>173.4</td> \n   <td>213.6</td> \n   <td>250</td> \n   <td>298</td> \n   <td>345.6</td> \n   <td>383</td> \n   <td>434.8</td> \n   <td>476.8</td> \n   <td>535.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>135.4</td> \n   <td>112.4</td> \n   <td>110.6</td> \n   <td>106.4</td> \n   <td>109.6</td> \n   <td>107.2</td> \n   <td>114.4</td> \n   <td>116</td> \n   <td>118.8</td> \n   <td>117.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>112.6</td> \n   <td>86.2</td> \n   <td>84.6</td> \n   <td>86.8</td> \n   <td>90</td> \n   <td>87.2</td> \n   <td>91.2</td> \n   <td>88.8</td> \n   <td>92.4</td> \n   <td>93.4</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>178.4</td> \n   <td>178.2</td> \n   <td>186.4</td> \n   <td>184.6</td> \n   <td>192.6</td> \n   <td>203.8</td> \n   <td>210</td> \n   <td>217.6</td> \n   <td>232.6</td> \n   <td>236.8</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>139</td> \n   <td>151</td> \n   <td>173.4</td> \n   <td>194</td> \n   <td>231.4</td> \n   <td>258.8</td> \n   <td>303.4</td> \n   <td>340.4</td> \n   <td>384.6</td> \n   <td>429.4</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>559.8</td> \n   <td>746.6</td> \n   <td>980.6</td> \n   <td>1226.8</td> \n   <td>1450.6</td> \n   <td>1705.4</td> \n   <td>1927.2</td> \n   <td>2154.8</td> \n   <td>2367.8</td> \n   <td>2617</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>482.6</td> \n   <td>626.2</td> \n   <td>755</td> \n   <td>909.6</td> \n   <td>1085</td> \n   <td>1233.2</td> \n   <td>1384</td> \n   <td>1568.6</td> \n   <td>1740.6</td> \n   <td>1883.8</td> \n  </tr> \n </tbody> \n</table> \n<p>然后按下表操作顺序逐项点击统计</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>delete(all)</th> \n   <th>add(1000)</th> \n   <th>update(1)</th> \n   <th>update(all)</th> \n   <th>delete(1)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>43.4</td> \n   <td>299.8</td> \n   <td>89.2</td> \n   <td>89</td> \n   <td>87.2</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>43.2</td> \n   <td>762.4</td> \n   <td>50</td> \n   <td>533</td> \n   <td>522.4</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>57.8</td> \n   <td>589.8</td> \n   <td>62.6</td> \n   <td>160.6</td> \n   <td>154.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>45.8</td> \n   <td>490.8</td> \n   <td>52.8</td> \n   <td>167</td> \n   <td>166</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>93.8</td> \n   <td>837</td> \n   <td>184.6</td> \n   <td>318</td> \n   <td>220.8</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>124.8</td> \n   <td>696.2</td> \n   <td>423.4</td> \n   <td>419</td> \n   <td>430.6</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>121.4</td> \n   <td>4978.2</td> \n   <td>2331.2</td> \n   <td>2448.4</td> \n   <td>2348</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>129.8</td> \n   <td>3947.2</td> \n   <td>1610.4</td> \n   <td>1813.8</td> \n   <td>2290.2</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native &gt; mpx &gt; uniapp &gt; chameleon &gt; mpvue &gt; wepy2 &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>具备模板数据跟踪能力的三个框架mpx，kbone和taro next在有后台数据场景下耗时并没有显著增加；</li> \n <li>wepy2当中的diff精度不足，耗时也没有产生明显变化；</li> \n <li>其余框架由于每次更新都会对后台数据进行deep diff，耗时都产生了一定提升。</li> \n</ul> \n<h3>页面更新耗时(大数据量场景)</h3> \n<blockquote>\n 由于mpvue和taro next的渲染全部在页面中进行，而kbone的渲染方案会额外新增大量的自定义组件，这三个框架都会在优惠券数量达到2000时崩溃白屏，我们排除了这三个框架对其余框架进行大数据量场景下的页面更新耗时测试\n</blockquote> \n<p>首先还是在无后台数据场景下使用<code>新增可用券(1000)</code>将可用券数量递增至5000：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>1000</th> \n   <th>2000</th> \n   <th>3000</th> \n   <th>4000</th> \n   <th>5000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>332.6</td> \n   <td>350</td> \n   <td>412.6</td> \n   <td>498.2</td> \n   <td>569.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>970.2</td> \n   <td>1531.4</td> \n   <td>2015.2</td> \n   <td>2890.6</td> \n   <td>3364.2</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>655.2</td> \n   <td>593.4</td> \n   <td>655</td> \n   <td>675.6</td> \n   <td>718.8</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>532.2</td> \n   <td>496</td> \n   <td>548.6</td> \n   <td>564</td> \n   <td>601.8</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>805.4</td> \n   <td>839.6</td> \n   <td>952.8</td> \n   <td>1086.6</td> \n   <td>1291.8</td> \n  </tr> \n </tbody> \n</table> \n<p>然后点击<code>新增不可用券(5000)</code>将后台数据量增加至5000，再测试可用券数量递增至5000的耗时：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>back add(5000)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>117.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>511.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>285</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>824</td> \n  </tr> \n </tbody> \n</table> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>1000</th> \n   <th>2000</th> \n   <th>3000</th> \n   <th>4000</th> \n   <th>5000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>349.8</td> \n   <td>348.4</td> \n   <td>430.4</td> \n   <td>497</td> \n   <td>594.8</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>1128</td> \n   <td>1872</td> \n   <td>2470.4</td> \n   <td>3263.4</td> \n   <td>4075.8</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>715</td> \n   <td>666.8</td> \n   <td>709.2</td> \n   <td>755.6</td> \n   <td>810.2</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>538.8</td> \n   <td>501.8</td> \n   <td>562.6</td> \n   <td>573.6</td> \n   <td>595.2</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>1509.2</td> \n   <td>1672.4</td> \n   <td>1951.8</td> \n   <td>2232.4</td> \n   <td>2586.2</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native &gt; mpx &gt; uniapp &gt; chameleon &gt; wepy2</p> \n<p>结论分析：</p> \n<ul>\n <li>在大数据量场景下，框架之间基础性能的差异会变得更加明显，mpx和uniapp依然保持了接近原生的良好性能表现，而chameleon和wepy2则产生了比较显著的性能劣化。</li>\n</ul> \n<h3>局部更新耗时</h3> \n<p>我们在可用券数量为1000的情况下，点击任意一张可用券触发选中状态，以测试局部更新性能</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>toggleSelect(ms)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>2</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>2.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>2.8</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>2.2</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>2</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>289.6</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>2440.8</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>1975</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native ≈ chameleon ≈ mpx ≈ wepy2 ≈ uniapp &gt; mpvue &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>可以看出所有使用了原生自定义组件进行组件化实现的框架局部更新耗时都极低，这足以证明小程序原生自定义组件的优秀性和重要性；</li> \n <li>mpvue由于使用了页面更新，局部更新耗时显著增加；</li> \n <li>kbone和taro next由于递归动态渲染的性能开销巨大，导致局部更新耗时同样巨大。</li> \n</ul> \n<h3>setData调用</h3> \n<p>我们将<code>proxySetData</code>的count和size选项设置为true，开启setData的次数和体积统计，重新构建后按照以下流程执行系列操作，并统计setData的调用次数和发送数据的体积。</p> \n<p>操作流程如下：</p> \n<ol> \n <li>100逐级递增可用券(0-&gt;500)</li> \n <li>切换至不可用券</li> \n <li>新增不可用券(1000)</li> \n <li>100逐级递增可用券(500-&gt;1000)</li> \n <li>更新可用券(all)</li> \n <li>切换至可用券</li> \n</ol> \n<p>操作完成后我们使用<code>getCount</code>和<code>getSize</code>方法获取累积的setData调用次数和数据体积，其中数据体积计算方式为JSON.stringify后按照utf-8编码方式进行体积计算，统计结果为：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>count</th> \n   <th>size(KB)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>14</td> \n   <td>803</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>3514</td> \n   <td>1124</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>16</td> \n   <td>2127</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>14</td> \n   <td>274</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>8</td> \n   <td>261</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>2515</td> \n   <td>319</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>22</td> \n   <td>10572</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>9</td> \n   <td>2321</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>mpx &gt; uniapp &gt; native &gt; chameleon &gt; wepy2 &gt; taro next &gt; mpvue &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>mpx框架成功实现了理论上setData的最优；</li> \n <li>uniapp由于缺失模板追踪能力紧随其后；</li> \n <li>chameleon由于组件每次创建时都会进行一次不必要的setData，产生了大量无效setData调用，但是数据的发送本身经过diff，在数据发送量上表现不错；</li> \n <li>wepy2的组件会在数据更新时调用setData发送已经更新过的props数据，因此也产生了大量无效调用，且diff精度不足，发送的数据量也较大；</li> \n <li>taro next由于上层完全基于vue，在数据发送次数上控制到了9次，但由于需要发送大量的dom描述信息，数据发送量较大；</li> \n <li>mpvue由于使用较长的数据路径描述数据对应的组件，也产生了较大的数据发送量；</li> \n <li>kbone对于setData的调用控制得不是很好，在上层运行vue的情况依然进行了22次数据发送，且发送的数据量巨大，在此流程中达到了惊人的10MB。</li> \n</ul> \n<h3>页面渲染耗时(静态测试)</h3> \n<p>此处的页面渲染耗时与前面描述的动态测试场景中相同，测试结果如下：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>页面渲染耗时</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>70.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>86.6</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>115.2</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>69.6</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>66.6</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>65</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>144.2</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>119.8</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>chameleon ≈ mpx ≈ uniapp ≈ native &gt; wepy2 &gt; mpvue ≈ taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul>\n <li>除了kbone和taro next采用动态渲染耗时增加，mpvue使用页面模板渲染性能稍差，其余框架的静态页面渲染表现都和原生差不多。</li>\n</ul> \n<h2>结论</h2> \n<p>综合上述测试数据，我们得到最终的小程序框架运行时性能排名为： <br>mpx &gt; uniapp &gt; chameleon &gt; wepy2 &gt; mpvue &gt; taro next &gt; kbone</p> \n<h2>一点私货</h2> \n<p>虽然kbone和taro next采用了动态渲染技术在性能表现上并不尽如人意，但是我依然认为这是很棒的技术方案。虽然本文从头到位都在进行性能测试和对比，但性能并不是框架的全部，开发效率和高可用性仍然是框架的重心，开发效率相信是所有框架设计的初衷，但是高可用性却在很大程度被忽视。从这个角度来说，kbone和taro next是非常成功的，不同于过去的转译思路，这种从抹平底层渲染环境的做法能够使上层web框架完整运行，在框架可用性上带来非常大的提升，非常适合于运营类简单小程序的迁移和开发。</p> \n<p>我主导开发的mpx框架(<a href=\"https://github.com/didi/mpx)\" rel=\"nofollow noreferrer\">https://github.com/didi/mpx)</a> 选择了另一条道路解决可用性问题，那就是基于小程序原生语法能力进行增强，这样既能避免转译web框架时带来的不确定性和不稳定性，同时也能带来非常接近于原生的性能表现，对于复杂业务小程序的开发者来说，非常推荐使用。在跨端输出方面，mpx目前能够完善支持业内全部小程序平台和web平台的同构输出，滴滴内部最重要最复杂的小程序——滴滴出行小程序完全基于mpx进行开发，并利用框架提供的跨端能力对微信和支付宝入口进行同步业务迭代，大大提升了业务开发效率。</p>', 'https://segmentfault.com/img/remote/1460000022249437', null, null, '0', '0', null, '1', '2020-04-14 20:58:26', '2020-04-14 20:58:26');
INSERT INTO `tb_recommend` VALUES ('93759c6affe740628c03b979d6d244ba', 'Redis快速入门，学会这15点，真的够用了！', '     REmote DIctionary Server(Redis)是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并...', '<p><strong>1、Redis简介</strong></p> \n<p><strong>&nbsp; &nbsp; &nbsp;REmote DIctionary Server(Redis)</strong>是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可<strong>基于内存</strong>亦<strong>可持久化</strong>的日志型、<strong>Key-Value</strong>数据库，并提供<strong>多种语言的A</strong>PI。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p> \n<p><strong>大家都知道了redis是基于<strong><em><em>key-value的no sql数据库</em></em></strong>，因此，先来了解一下关于key相关的知识点</strong></p> \n<blockquote>\n 1、任何\n <strong>二进制的序列</strong>都可以作为key使用 \n <br>2、Redis有\n <strong>统一的规则</strong>来设计key \n <br>3、对key-value允许的\n <strong>最大长度是512MB</strong> \n</blockquote> \n<p><strong>2、支持的语言</strong></p> \n<pre><code>ActionScript Bash &nbsp;C &nbsp;C# &nbsp;C++ &nbsp;Clojure Common LispCrystal &nbsp;D &nbsp;Dart &nbsp;Elixir &nbsp;emacs &nbsp;lisp &nbsp;Erlang &nbsp;Fancy &nbsp;gawk &nbsp;GNU Prolog &nbsp;Go &nbsp;Haskell &nbsp;Haxe &nbsp;Io Java &nbsp;Javascript &nbsp;Julia &nbsp;Lua &nbsp;Matlab &nbsp;mruby &nbsp;Nim &nbsp;Node.js &nbsp;Objective-C &nbsp;OCaml Pascal &nbsp;Perl &nbsp;PHP &nbsp;Pure Data &nbsp;Python &nbsp;R &nbsp;Racket &nbsp;Rebol &nbsp;Ruby &nbsp;Rust Scala &nbsp;Scheme &nbsp;Smalltalk &nbsp;Swift &nbsp;Tcl &nbsp;VB &nbsp;VCL</code></pre> \n<p><strong>3、Redis的应用场景到底有哪些？？</strong></p> \n<blockquote>\n 1、最常用的就是\n <strong>会话缓存</strong> \n <br>2、\n <strong>消息队列</strong>，比如支付 \n <br>3、活动\n <strong>排行榜或计数</strong> \n <br>4、\n <strong>发布、订阅</strong>消息(消息通知) \n <br>5、\n <strong>商品列表、评论列表</strong>等\n</blockquote> \n<p><strong>4、Redis安装</strong></p> \n<p><strong>关于redis安装与相关的知识点介绍请参考&nbsp;</strong><a href=\"http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;mid=2247485429&amp;idx=1&amp;sn=a20b8d23aa47efc52ec48ef43c32aea5&amp;chksm=e91b62e9de6cebfff3ebfa2ec84c6e8163c14bf98fba1250261a2a960fe3983ec780fe9dd082&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\"><strong>Nosql数据库服务之redis</strong></a></p> \n<p><strong>安装的大概步骤如下：</strong></p> \n<p>Redis是c语言开发的，安装redis需要c语言的编译环境</p> \n<p>如果没有gcc需要在线安装：yum install gcc-c++</p> \n<blockquote>\n 第一步：获取源码包：wget \n <a href=\"http://download.redis.io/releases/redis-3.0.0.tar.gz\" rel=\"nofollow noreferrer\">http://download.redis.io/rele...</a>\n <p>第二步：解压缩redis：tar zxvf redis-3.0.0.tar.gz</p> \n <p>第三步：编译。进入redis源码目录(cd redis-3.0.0)。执行 make</p> \n <p>第四步：安装。make install PREFIX=/usr/local/redis</p> \n <p>PREFIX参数指定redis的安装目录</p> \n</blockquote> \n<p><strong>5、Redis数据类型</strong></p> \n<p>Redis一共<strong>支持五种</strong>数据类型</p> \n<blockquote>\n 1、\n <strong>string</strong>(字符串) \n <br>2、\n <strong>hash</strong>(哈希) \n <br>3、\n <strong>list</strong>(列表) \n <br>4、\n <strong>set</strong>(集合) \n <br>5、\n <strong>zset</strong>（sorted set 有序集合）\n</blockquote> \n<p><strong>string(字符串)</strong> <br>它是redis最基本的数据类型，<strong>一个key对应一个value</strong>，需要注意是一个键值最大存储512MB。</p> \n<pre><code>127.0.0.1:6379&gt; set key \"hello world\"\nOK\n127.0.0.1:6379&gt; get key\n\"hello world\"\n127.0.0.1:6379&gt; getset key \"nihao\"\n\"hello world\"\n127.0.0.1:6379&gt; mset key1 \"hi\" key2 \"nihao\" key3 \"hello\"\nOK\n127.0.0.1:6379&gt; get key1\n\"hi\"\n127.0.0.1:6379&gt; get key2\n\"nihao\"\n127.0.0.1:6379&gt; get key3\n\"hello\"</code></pre> \n<blockquote> \n <strong>相关命令介绍</strong> \n <br>set 为一个Key设置value（值） \n <br>get 获得某个key对应的value（值） \n <br>getset 为一个Key设置value（值）并返回对应的值 \n <br>mset 为多个key设置value（值）\n</blockquote> \n<p><strong>hash(哈希)</strong> <br>redis hash是一个<strong>键值对的集合</strong>， 是一个string类型的<strong>field和value的映射表</strong>，适合用于存储对象</p> \n<pre><code>127.0.0.1:6379&gt; hset redishash 1 \"001\"\n(integer) 1\n127.0.0.1:6379&gt; hget redishash 1\n\"001\"\n127.0.0.1:6379&gt; hmset redishash 1 \"001\" 2 \"002\"\nOK\n127.0.0.1:6379&gt; hget redishash 1\n\"001\"\n127.0.0.1:6379&gt; hget redishash 2\n\"002\"\n127.0.0.1:6379&gt; hmget redishash 1 2\n1) \"001\"\n2) \"002\"</code></pre> \n<blockquote> \n <strong>相关命令介绍</strong> \n <br>hset 将Key对应的hash中的field配置为value，如果hash不存则自动创建， \n <br>hget 获得某个hash中的field配置的值 \n <br>hmset 批量配置同一个hash中的多个field值 \n <br>hmget 批量获得同一个hash中的多个field值\n</blockquote> \n<p><strong>list(列表)</strong> <br>是redis简单的<strong>字符串列表</strong>，它按插入顺序排序</p> \n<pre><code>127.0.0.1:6379&gt; lpush word &nbsp;hi\n(integer) 1\n127.0.0.1:6379&gt; lpush word &nbsp;hello\n(integer) 2\n127.0.0.1:6379&gt; rpush word &nbsp;world\n(integer) 3\n127.0.0.1:6379&gt; lrange word 0 2\n1) \"hello\"\n2) \"hi\"\n3) \"world\"\n127.0.0.1:6379&gt; llen word\n(integer) 3</code></pre> \n<blockquote> \n <strong>相关命令介绍</strong> \n <br>lpush 向指定的列表左侧插入元素，返回插入后列表的长度 \n <br>rpush 向指定的列表右侧插入元素，返回插入后列表的长度 \n <br>llen &nbsp;返回指定列表的长度 \n <br>lrange 返回指定列表中指定范围的元素值\n</blockquote> \n<p><strong>set(集合)</strong> <br>是string类型的<strong>无序集合</strong>，也<strong>不可重复</strong></p> \n<pre><code>127.0.0.1:6379&gt; sadd redis redisset\n(integer) 1\n127.0.0.1:6379&gt; sadd redis redisset1\n(integer) 1\n127.0.0.1:6379&gt; sadd redis redisset2\n(integer) 1\n127.0.0.1:6379&gt; smembers redis\n1) \"redisset1\"\n2) \"redisset\"\n3) \"redisset2\"\n127.0.0.1:6379&gt; sadd redis redisset2\n(integer) 0\n127.0.0.1:6379&gt; smembers redis\n1) \"redisset1\"\n2) \"redisset\"\n3) \"redisset2\"\n127.0.0.1:6379&gt; smembers redis\n1) \"redisset1\"\n2) \"redisset3\"\n3) \"redisset\"\n4) \"redisset2\"\n127.0.0.1:6379&gt; srem redis redisset\n(integer) 1\n127.0.0.1:6379&gt; smembers redis\n1) \"redisset1\"\n2) \"redisset3\"\n3) \"redisset2\"</code></pre> \n<blockquote> \n <strong>相关命令介绍</strong> \n <br>sadd 添加一个string元素到key对应的set集合中，成功返回1，如果元素存在返回0 \n <br>smembers 返回指定的集合中所有的元素 \n <br>srem 删除指定集合的某个元素\n</blockquote> \n<p><strong>zset（sorted set 有序集合）</strong> <br>是string类型的<strong>有序集合，也不可重复</strong> <br>sorted set中的每个元素都需要指定一个分数，根据分数对元素进行升序排序，如果多个元素有相同的分数，则以字典序进行升序排序，sorted set 因此非常适合实现排名</p> \n<pre><code>127.0.0.1:6379&gt; zadd nosql 0 001\n(integer) 1\n127.0.0.1:6379&gt; zadd nosql 0 002\n(integer) 1\n127.0.0.1:6379&gt; zadd nosql 0 003\n(integer) 1\n127.0.0.1:6379&gt; zcount nosql 0 0 \n(integer) 3\n127.0.0.1:6379&gt; zcount nosql 0 3\n(integer) 3\n127.0.0.1:6379&gt; zrem nosql 002\n(integer) 1\n127.0.0.1:6379&gt; zcount nosql 0 3\n(integer) 2\n127.0.0.1:6379&gt; zscore nosql 003\n\"0\"\n127.0.0.1:6379&gt; zrangebyscore nosql 0 10\n1) \"001\"\n2) \"003\"\n127.0.0.1:6379&gt; zadd nosql 1 003\n(integer) 0\n127.0.0.1:6379&gt; zadd nosql 1 004\n(integer) 1\n127.0.0.1:6379&gt; zrangebyscore nosql 0 10\n1) \"001\"\n2) \"003\"\n3) \"004\"\n127.0.0.1:6379&gt; zadd nosql 3 005\n(integer) 1\n127.0.0.1:6379&gt; zadd nosql 2 006\n(integer) 1\n127.0.0.1:6379&gt; zrangebyscore nosql 0 10\n1) \"001\"\n2) \"003\"\n3) \"004\"\n4) \"006\"\n5) \"005\"</code></pre> \n<blockquote> \n <strong>相关命令介绍</strong> \n <br>zadd &nbsp;向指定的sorteset中添加1个或多个元素 \n <br>zrem &nbsp;从指定的sorteset中删除1个或多个元素 \n <br>zcount 查看指定的sorteset中指定分数范围内的元素数量 \n <br>zscore 查看指定的sorteset中指定分数的元素 \n <br>zrangebyscore 查看指定的sorteset中指定分数范围内的所有元素\n</blockquote> \n<p><strong>6、键值相关的命令</strong></p> \n<pre><code>127.0.0.1:6379&gt; exists key\n(integer) 1\n127.0.0.1:6379&gt; exists key1\n(integer) 1\n127.0.0.1:6379&gt; exists key100\n(integer) 0\n127.0.0.1:6379&gt; get key\n\"nihao,hello\"\n127.0.0.1:6379&gt; get key1\n\"hi\"\n127.0.0.1:6379&gt; del key1\n(integer) 1\n127.0.0.1:6379&gt; get key1\n(nil)\n127.0.0.1:6379&gt; rename key key0\nOK\n127.0.0.1:6379&gt; get key(nil)\n127.0.0.1:6379&gt; get key0\n\"nihao,hello\"\n127.0.0.1:6379&gt; type key0\nstring</code></pre> \n<blockquote>\n exists&nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#确认key是否存在</strong> \n <br>del&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#删除key</strong> \n <br>expire&nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#设置Key过期时间(单位秒)</strong> \n <br>persist&nbsp; &nbsp; &nbsp;\n <strong>#移除Key过期时间的配置</strong> \n <br>rename&nbsp; &nbsp; &nbsp;\n <strong>#重命名key</strong> \n <br>type&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#返回值的类型</strong> \n</blockquote> \n<p><strong>7、Redis服务相关的命令</strong></p> \n<pre><code>127.0.0.1:6379&gt; select 0\nOK\n127.0.0.1:6379&gt; info\n# Server\nredis_version:3.0.6\nredis_git_sha1:00000000\nredis_git_dirty:0\nredis_build_id:347e3eeef5029f3\nredis_mode:standalone\nos:Linux 3.10.0-693.el7.x86_64 x86_64\narch_bits:64\nmultiplexing_api:epoll\ngcc_version:4.8.5\nprocess_id:31197\nrun_id:8b6ec6ad5035f5df0b94454e199511084ac6fb12\ntcp_port:6379\nuptime_in_seconds:8514\nuptime_in_days:0\nhz:10\nlru_clock:14015928\nconfig_file:/usr/local/redis/redis.conf\n-------------------省略N行\n127.0.0.1:6379&gt; CONFIG GET 0\n(empty list or set)\n127.0.0.1:6379&gt; CONFIG GET 15\n(empty list or set)</code></pre> \n<blockquote>\n slect&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#选择数据库(数据库编号0-15)</strong> \n <br>quit&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#退出连接</strong> \n <br>info&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#获得服务的信息与统计</strong> \n <br>monitor&nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#实时监控</strong> \n <br>config get&nbsp; &nbsp;\n <strong>#获得服务配置</strong> \n <br>flushdb&nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#删除当前选择的数据库中的key</strong> \n <br>flushall&nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#删除所有数据库中的key</strong> \n</blockquote> \n<p><strong>8、Redis的发布与订阅</strong></p> \n<p>Redis发布与订阅(pub/sub)是它的一种消息通信模式，一方发送信息，一方接收信息。 <br><strong>下图是三个客户端同时订阅同一个频道</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022353598\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>下图是有新信息发送给频道1时，就会将消息发送给订阅它的三个客户端</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022353597\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>9、Redis事务</strong></p> \n<p>Redis事务可以一次执行多条命令</p> \n<blockquote>\n 1、发送exec命令前放入队列缓存，结束事务 \n <br>2、收到exec命令后执行事务操作，如果某一命令执行失败，其它命令仍可继续执行 \n <br>3、一个事务执行的过程中，其它客户端提交的请求不会被插入到事务执行的命令列表中\n</blockquote> \n<p><strong>一个事务经历三个阶段</strong> <br>&nbsp; 开始事务(命令:multi) <br>&nbsp; 命令执行 <br>&nbsp; 结束事务(命令:exec)</p> \n<pre><code>127.0.0.1:6379&gt; MULTI\nOK\n127.0.0.1:6379&gt; set key key1\nQUEUED\n127.0.0.1:6379&gt; get key\nQUEUED\n127.0.0.1:6379&gt; rename key key001\nQUEUED\n127.0.0.1:6379&gt; exec\n1) OK\n2) \"key1\"\n3) OK</code></pre> \n<p><strong>10、Redis安全配置</strong></p> \n<p>可以通过修改配置文件设备密码参数来提高安全性</p> \n<p><strong>&nbsp;#requirepass foobared</strong></p> \n<p>去掉注释#号就可以配置密码 <br><strong>没有配置密码的情况下查询如下</strong></p> \n<pre><code>127.0.0.1:6379&gt; CONFIG GET requirepass\n1) \"requirepass\"\n2) \"\"</code></pre> \n<p><strong>配置密码之后，就需要进行认证</strong></p> \n<pre><code>127.0.0.1:6379&gt; CONFIG GET requirepass\n(error) NOAUTH Authentication required.\n127.0.0.1:6379&gt; AUTH foobared \n#认证OK\n127.0.0.1:6379&gt; CONFIG GET requirepass\n1) \"requirepass\"\n2) \"foobared\"</code></pre> \n<p><strong>11、Redis持久化</strong></p> \n<p><strong>Redis持久有两种方式:Snapshotting(快照),Append-only file(AOF)</strong></p> \n<p><strong>Snapshotting(快照)</strong></p> \n<blockquote>\n 1、将存储在内存的数据以快照的方式写入二进制文件中，如默认dump.rdb中 \n <br>2、save 900 1&nbsp;\n <p><strong>#900秒内如果超过1个Key被修改，则启动快照保存</strong> <br>3、save 300 10&nbsp;</p> \n <p><strong>#300秒内如果超过10个Key被修改，则启动快照保存</strong> <br>4、save 60 10000&nbsp;</p> \n <p><strong>#60秒内如果超过10000个Key被修改，则启动快照保存</strong></p> \n</blockquote> \n<p><strong>Append-only file(AOF)</strong></p> \n<blockquote>\n 1、使用AOF持久时，服务会将每个收到的写命令通过write函数追加到文件中（appendonly.aof） \n <br>2、AOF持久化存储方式参数说明 \n <br>&nbsp; &nbsp;appendonly yes &nbsp;\n <p><strong>#开启AOF持久化存储方式</strong> <br>&nbsp; &nbsp; appendfsync always&nbsp;</p> \n <p><strong>#收到写命令后就立即写入磁盘，效率最差，效果最好</strong> <br>&nbsp; &nbsp; appendfsync everysec</p> \n <p><strong>&nbsp;#每秒写入磁盘一次，效率与效果居中</strong> <br>&nbsp; &nbsp; appendfsync no&nbsp;</p> \n <p><strong>#完全依赖OS，效率最佳，效果没法保证</strong></p> \n</blockquote> \n<p><strong>12、Redis 性能测试</strong></p> \n<p><strong>自带相关测试工具</strong></p> \n<pre><code>[root@test ~]# redis-benchmark --help\n\nUsage: redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests]&gt; [-k &lt;boolean&gt;] \n\n-h &lt;hostname&gt; &nbsp; &nbsp; &nbsp;Server hostname (default 127.0.0.1) \n-p &lt;port&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Server port (default 6379) \n-s &lt;socket&gt; &nbsp; &nbsp; &nbsp; &nbsp;Server socket (overrides host and port) -a &lt;password&gt; &nbsp; &nbsp; &nbsp;Password for Redis Auth \n-c &lt;clients&gt; &nbsp; &nbsp; &nbsp; Number of parallel connections (default 50) \n-n &lt;requests&gt; &nbsp; &nbsp; &nbsp;Total number of requests (default 100000) \n-d &lt;size&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Data size of SET/GET value in bytes (default 2) \n-dbnum &lt;db&gt; &nbsp; &nbsp; &nbsp; &nbsp;SELECT the specified db number (default 0) \n-k &lt;boolean&gt; &nbsp; &nbsp; &nbsp; 1=keep alive 0=reconnect (default 1) \n-r &lt;keyspacelen&gt; &nbsp; Use random keys for SET/GET/INCR, random values for SADD &nbsp;Using this option the benchmark will expand the string __rand_int__ &nbsp;inside an argument with a 12 digits number in the specified range &nbsp;from 0 to keyspacelen-1. The substitution changes every time a command &nbsp;is executed. Default tests use this to hit random keys in the &nbsp;specified range. \n-P &lt;numreq&gt; &nbsp; &nbsp; &nbsp; &nbsp;Pipeline &lt;numreq&gt; requests. Default 1 (no pipeline). \n-q &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Quiet. Just show query/sec values --csv &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output in CSV format \n-l &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Loop. Run the tests forever \n-t &lt;tests&gt; &nbsp; &nbsp; &nbsp; &nbsp; Only run the comma separated list of tests. The test &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;names are the same as the ones produced as output. \n-I &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Idle mode. Just open N idle connections and wait.\n\nExamples: \n\nRun the benchmark with the default configuration against 127.0.0.1:6379: &nbsp; \n$ redis-benchmark\n\nUse 20 parallel clients, for a total of 100k requests, against 192.168.1.1: &nbsp; \n$ redis-benchmark -h 192.168.1.1 -p 6379 -n 100000 -c 20 \n\nFill 127.0.0.1:6379 with about 1 million keys only using the SET test: &nbsp; \n$ redis-benchmark -t set -n 1000000 -r 100000000 \n\nBenchmark 127.0.0.1:6379 for a few commands producing CSV output: &nbsp; \n$ redis-benchmark -t ping,set,get -n 100000 --csv \n\nBenchmark a specific command line: &nbsp; \n$ redis-benchmark -r 10000 -n 10000 eval \'return redis.call(\"ping\")\' 0 \n\nFill a list with 10000 random elements: &nbsp; \n$ redis-benchmark -r 10000 -n 10000 lpush mylist __rand_int__ \n\nOn user specified command lines __rand_int__ is replaced with a random integer with a range of values selected by the -r option.</code></pre> \n<p><strong>实际测试同时执行100万的请求</strong></p> \n<pre><code>[root@test ~]# redis-benchmark -n 1000000 -q\nPING_INLINE: 152578.58 requests per second\nPING_BULK: 150308.14 requests per second\nSET: 143266.47 requests per second\nGET: 148632.58 requests per second\nINCR: 145857.64 requests per second\nLPUSH: 143781.45 requests per second\nLPOP: 147819.66 requests per second\nSADD: 138350.86 requests per second\nSPOP: 134282.27 requests per second\nLPUSH (needed to benchmark LRANGE): 141302.81 requests per second\nLRANGE_100 (first 100 elements): 146756.67 requests per second\nLRANGE_300 (first 300 elements): 148104.27 requests per second\nLRANGE_500 (first 450 elements): 152671.75 requests per second\nLRANGE_600 (first 600 elements): 148104.27 requests per second\nMSET (10 keys): 132731.62 requests per second</code></pre> \n<p><strong>13、Redis的备份与恢复</strong></p> \n<p><strong>Redis自动备份有两种方式</strong> <br>第一种是通过dump.rdb文件实现备份 <br>第二种使用aof文件实现自动备份</p> \n<p><strong>dump.rdb备份</strong> <br>Redis服务默认的自动文件备份方式(AOF没有开启的情况下)，在服务启动时，就会自动从dump.rdb文件中去加载数据。 <br>**具体配置在redis.conf <br>save 900 1 <br>save 300 10 <br>save 60 10000** <br>也可以手工执行save命令实现手动备份</p> \n<pre><code>127.0.0.1:6379&gt; set name key\nOK\n127.0.0.1:6379&gt; SAVE\nOK\n127.0.0.1:6379&gt; set name key1\nOK\n127.0.0.1:6379&gt; BGSAVE\nBackground saving started</code></pre> \n<p>redis快照到dump文件时，会自动生成dump.rdb的文件</p> \n<pre><code># The filename where to dump the DB\ndbfilename dump.rdb\n-rw-r--r-- 1 root root &nbsp; 253 Apr 17 20:17 dump.rdb</code></pre> \n<p><strong>SAVE命令</strong>表示使<strong>用主进程</strong>将当前数据库快照到dump文件 <br><strong>BGSAVE命令</strong>表示，主进程会<strong>fork一个子进程</strong>来进行快照备份 <br>两种备份不同之处，前者会阻塞主进程，后者不会。</p> \n<p><strong>恢复举例</strong></p> \n<pre><code># Note that you must specify a directory here, not a file name.dir \n/usr/local/redisdata/\n#备份文件存储路径\n127.0.0.1:6379&gt; CONFIG GET dir\n1) \"dir\"\n2) \"/usr/local/redisdata\"\n127.0.0.1:6379&gt; set key 001\nOK\n127.0.0.1:6379&gt; set key1 002\nOK\n127.0.0.1:6379&gt; set key2 003\nOK\n127.0.0.1:6379&gt; save\nOK</code></pre> \n<p><strong>将备份文件备份到其它目录</strong></p> \n<pre><code>[root@test ~]# ll /usr/local/redisdata/\ntotal 4\n-rw-r--r-- 1 root root 49 Apr 17 21:24 dump.rdb\n\n[root@test ~]# date\nTue Apr 17 21:25:38 CST 2018\n[root@test ~]# cp ./dump.rdb /tmp/</code></pre> \n<p><strong>删除数据</strong></p> \n<pre><code>127.0.0.1:6379&gt; del key1\n(integer) 1\n127.0.0.1:6379&gt; get key1\n(nil)</code></pre> \n<p><strong>关闭服务，将原备份文件拷贝回save备份目录</strong></p> \n<pre><code>[root@test ~]# redis-cli -a foobared shutdown\n[root@test ~]# lsof -i :6379\n[root@test ~]# cp /tmp/dump.rdb /usr/local/redisdata/\ncp: overwrite ‘/usr/local/redisdata/dump.rdb’? y\n[root@test ~]# redis-server /usr/local/redis/redis.conf &amp;\n[1] 31487</code></pre> \n<p><strong>登录查看数据是否恢复</strong></p> \n<pre><code>[root@test ~]# redis-cli -a foobared\n127.0.0.1:6379&gt; mget key key1 key2\n1) \"001\"\n2) \"002\"\n3) \"003\"</code></pre> \n<p><strong>AOF自动备份</strong> <br>redis服务默认是关闭此项配置</p> \n<pre><code>###### APPEND ONLY MODE ##########\nappendonly no\n\n# The name of the append only file (default: \"appendonly.aof\")\nappendfilename \"appendonly.aof\"\n\n# appendfsync always\nappendfsync everysec\n\n# appendfsync no</code></pre> \n<p>配置文件的相关参数，前面已经详细介绍过。 <br>AOF文件备份，是备份所有的历史记录以及执行过的命令，和mysql binlog很相似，在恢复时就是重新执次一次之前执行的命令，需要注意的就是在恢复之前，和数据库恢复一样需要手工删除执行过的del或误操作的命令。</p> \n<blockquote> \n <strong>AOF与dump备份不同</strong> \n <br>1、aof文件备份与dump文件备份不同 \n <br>2、服务读取文件的优先顺序不同，会按照以下优先级进行启动 \n <br>&nbsp; &nbsp;如果只配置AOF,重启时加载AOF文件恢复数据 \n <br>&nbsp; &nbsp; 如果同时 配置了RBD和AOF,启动是只加载AOF文件恢复数据 \n <br>&nbsp; &nbsp; 如果只配置RBD,启动时将加载dump文件恢复数据\n</blockquote> \n<p><strong>注意：只要配置了aof，但是没有aof文件，这个时候启动的数据库会是空的</strong></p> \n<p><strong>14、Redis 生产优化介绍</strong></p> \n<p><strong>1、内存管理优化</strong>&nbsp;</p> \n<pre><code>hash-max-ziplist-entries 512  \n&nbsp;hash-max-ziplist-value 64  \n&nbsp;list-max-ziplist-entries 512  \n&nbsp;list-max-ziplist-value 64\n&nbsp;#list的成员与值都不太大的时候会采用紧凑格式来存储，相对内存开销也较小</code></pre> \n<blockquote> \n <strong>在linux环境运行Redis时，如果系统的内存比较小，这个时候自动备份会有可能失败，需要修改系统的vm.overcommit_memory 参数，这个参数是linux系统的内存分配策略</strong> \n <br>&nbsp; &nbsp;0 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。 \n <br>&nbsp; &nbsp; 1 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。 \n <br>&nbsp; &nbsp; 2 表示内核允许分配超过所有物理内存和交换空间总和的内存 \n <br>&nbsp;\n <strong>Redis官方的说明是，建议将vm.overcommit_memory的值修改为1，可以用下面几种方式进行修改：</strong> \n <br>（1）编辑/etc/sysctl.conf 改vm.overcommit_memory=1，然后sysctl -p 使配置文件生效 \n <br>（2）sysctl vm.overcommit_memory=1 \n <br>&nbsp;（3）echo 1 &gt; /proc/sys/vm/overcommit_memory\n</blockquote> \n<p>**2、内存预分配 <br>3、持久化机制** <br>&nbsp; &nbsp;定时快照：效率不高，会丢失数据 <br>&nbsp; &nbsp; AOF：保持数据完整性（一个实例的数量不要太大2G最大）</p> \n<blockquote> \n <strong>优化总结</strong> \n <br>1）根据业务需要选择合适的数据类型 \n <br>2）当业务场景不需持久化时就关闭所有持久化方式（采用ssd磁盘来提升效率） \n <br>3）不要使用虚拟内存的方式，每秒实时写入AOF \n <br>4）不要让REDIS所在的服务器物理内存使用超过内存总量的3/5 \n <br>5）要使用maxmemory \n <br>6）大数据量按业务分开使用多个redis实例\n</blockquote> \n<p><strong>15、Redis集群应用</strong></p> \n<p>集群是将<strong>多个redis实例集中在一起</strong>，实现同一业务需求，或者<strong>实现高可用与负载均衡</strong></p> \n<p><strong>到底有哪些集群方案呢？？</strong> <br><strong>1、haproxy+keepalived+redis集群</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022353599\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>1）通过redis的配置文件，实现主从复制、读写分离 <br>2）通过haproxy的配置，实现负载均衡，当从故障时也会及时从集群中T除 <br>3）利用keepalived来实现负载的高可用</p> \n<p><strong>2、redis官方Sentinel集群管理工具</strong></p> \n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;mid=2247484546&amp;idx=1&amp;sn=d2afa23bad2bf25a4f551bfebba3d65f&amp;chksm=e91b619ede6ce8888c3089ab458d9d153e9684511dd7d63a0e9369be763782b97ea5efb3dd56&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\"><strong>Redis集群生产环境高可用方案实战过程</strong></a> </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022353600\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>1）sentinel负责对集群中的主从服务监控、提醒和自动故障转移 <br>2）redis集群负责对外提供服务 <br>关于redis sentinel cluster集群配置可参考</p> \n<p><strong>3、Redis Cluster</strong> <br>Redis Cluster是Redis的分布式解决方案，在Redis 3.0版本正式推出的，有效解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构达到负载均衡的目的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022353601\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>1）官方推荐，毋庸置疑。 <br>2）去中心化，集群最大可增加1000个节点，性能随节点增加而线性扩展。 <br>3）管理方便，后续可自行增加或摘除节点，移动分槽等等。 <br>4）简单，易上手。</p>', 'https://segmentfault.com/img/remote/1460000022353598', null, null, '0', '0', null, '1', '2020-04-14 20:58:15', '2020-04-14 20:58:15');
INSERT INTO `tb_recommend` VALUES ('94a01f7208254764a677b2b3fb2da221', '【译】10个帮助你捕获更多Bug的TypeScript建议', '然而这个想法是错误的！因为TypeScript最终是被编译成JavaScript代码，并且浏览器中运行的也是JavaScript。此时（译者注：运行时）所有的类型信息都丢失了，所以TypeScript无法自动验证类型。', '<blockquote>\n 本文翻译自Miłosz Piechocki提供的TypeScript迷你书\n <a href=\"https://typescriptmasterclass.com\" rel=\"nofollow noreferrer\">https://typescriptmasterclass.com</a>（需要发送邮件获取）\n <p>其个人博客<a href=\"https://codewithstyle.info\" rel=\"nofollow noreferrer\">https://codewithstyle.info</a>也有许多关于TS的文章可以学习。</p> \n</blockquote> \n<h2>1. 对TypeScript提供运行时检查的思考</h2> \n<p>有一个对TypeScript常见的误解是：一个变量只要标注了类型，那么它总是会检查自己的数据类型是否与我们的预期一致。</p> \n<p>与该误解相呼应的想法会认为：对一个从后端返回的对象进行类型标注可以在代码运行时执行检查来确保对象类型的正确性。</p> \n<p>然而这个想法是错误的！因为TypeScript最终是被编译成JavaScript代码，并且浏览器中运行的也是JavaScript。此时（译者注：运行时）所有的类型信息都丢失了，所以TypeScript无法自动验证类型。</p> \n<p>理解这一点的一个好方法是查看编译后的代码：</p> \n<pre><code>interface Person {\n  name: string;\n  age: number;\n}\n\nfunction fetchFromBackend(): Promise&lt;Person&gt; {\n  return fetch(\'http://example.com\')\n      .then((res) =&gt; res.json())\n}\n\n// 编译后\nfunction fetchFromBackend() {\n  return fetch(\'http://example.com\')\n      .then(function(res) {\n        return res.json();\n      })\n}</code></pre> \n<p>可以看到接口定义在编译后已经完全消失了，而且这里也不会有任何验证性的代码。</p> \n<p>不过你最好可以自己去执行运行时校验，许多库（译者注：<a href=\"https://github.com/gcanti/io-ts\" rel=\"nofollow noreferrer\">io-ts</a>）能帮你做到这点。不过，请记住，这一定会带来性能开销。</p> \n<p><strong>* 考虑对所有外部提供的对象执行运行时检查（例如从后端获取的对象，JSON反序列化的对象等）</strong></p> \n<h2>2. 不要将类型定义为any</h2> \n<p>使用TypeScript时，可以将变量或函数参数的类型声明为any，但是这样做也意味着该变量脱离了类型安全保障。</p> \n<p>不过声明为any类型也会有好处，在某种场景下很有帮助（例如将类型逐步添加到现有的JavaScript代码库中，译者注：一般是将代码库从js升级到ts时）。但是它也像一个逃生舱口，会大大降低代码的类型安全性。</p> \n<p>当类型安全涵盖尽可能多的代码时，它是最有效的。否则，安全网中会存在漏洞，漏洞可能会通过漏洞传播。例如：如果函数返回any，则使用其返回值的所有表达式类型也将变成any。</p> \n<p>所以你应该尽量避免使用any类型。幸运的是，TypeScript3.0引入了类型安全的替代方案——unknown。可以将任何值赋给unknown类型的变量，但是不能将unknown类型的变量的值赋给任何变量（这点不同于any）。</p> \n<p>如果你的函数返回的是unknown类型的值，则调用方需要执行检查（使用类型保护），或至少将值显式转换为某个特定类型。（译者注：如果对这段不理解，可以参考下这篇文章，<a href=\"https://juejin.im/post/5d04ac745188250a8b1fd203\" rel=\"nofollow noreferrer\">unknown 类型</a> 中的示例部分）</p> \n<pre><code>let foo: any;\n\n// anything can be assigned to foo\nfoo = \'abc\';\n// foo can be assigned to anything\nconst x: number = foo;\n\n\nlet bar: unknown;\n\n// anything can be assigned to bar\nbar = \'abc\';\n// COMPILE ERROR! Type \'unknown\' is not assignable to type \'number\'.\nconst y: number = bar;</code></pre> \n<p>使用unknown类型有时会有些麻烦，但是这也会让代码更易于理解，并且让你在开发时更加注意。</p> \n<p>另外，你需要开启noImplicitAny，每当编译器推断某个值的类型为any时就会抛出错误。换句话说，它让你显式的标注出所有会出现any的场景。</p> \n<p>尽管最终目标还是消除有any的情况，但明确申明any仍然是有益的：例如在code review时可以更容易捕获他们。</p> \n<p><strong>* 不要使用any类型并开启noImplicitAny</strong></p> \n<h2>3. 开启strictNullChecks</h2> \n<p>你已经见过多少次这样的报错信息了？</p> \n<pre><code>TypeError: undefined is not an object</code></pre> \n<p>我打赌有很多次了，JavaScript（甚至是软件编程）中最常见的bug来源之一就是忘记处理空值。</p> \n<p>在JavaScript中用null或undefined来表示空值。开发者们经常乐观的认为给定的变量不会是空的，于是就忘记处理空值的情况。</p> \n<pre><code>function printName(person: Person) {\n  console.log(person.name.toUpperCase());\n}\n\n// RUNTIME ERROR!  TypeError: undefined is not an object   \n// (evaluating \'person.name\') \nprintName(undefined);</code></pre> \n<p>通过开启strictNullChecks，编译器会迫使你去做相关的检查，这对防止出现这种常见问题起到了重要的作用。</p> \n<p>默认情况下，typescript的每个类型都包含null和undefined这两个值。也就是说，null和undefined可以被赋值给任意类型的任何变量。</p> \n<p>而开启strictNullChecks会更改该行为。由于无法将undefined作为Person类型的参数传递，因此下方的代码会在编译时报错。</p> \n<pre><code>// COMPILE ERROR! \n// Argument of type \'undefined\' is not assignable to parameter of type \'Person\'. printName(undefined); </code></pre> \n<p>那如果你确实就想将<code>undefined</code>传递给printName怎么办？那你可以调整类型签名，但是仍然会要求你处理undefined的情况。</p> \n<pre><code>function printName(person: Person | undefined) {\n  // COMPILE ERROR!\n  // Object is possibly \'undefined\'. \n     console.log(person.name.toUpperCase());\n}</code></pre> \n<p>你可以通过确保person是被定义的来修复这个错误：</p> \n<pre><code>function printName(person: Person | undefined) { \n    if (person) {\n        console.log(person.name.toUpperCase());\n    }\n} </code></pre> \n<p>不幸的是，<code>strictNullChecks</code>默认是不开启的，我们需要在<code>tsconfig.json</code>中进行配置。</p> \n<p>另外，strictNullChecks是更通用的严格模式的一部分，可以通过strict标志启用它。你绝对应该这样做！因为编译器的设置越严格，你就可以尽早发现更多bug。</p> \n<p><strong>* 始终开启strictNullChecks</strong></p> \n<h2>4. 开启strictPropertyInitialization</h2> \n<p><code>strictPropertyInitialization</code>是属于严格模式标志集的另一个标志。尤其在使用Class时开启<code>strictPropertyInitialization</code>很重要，它其实有点像是对<code>strictNullChecks</code>的扩展。</p> \n<p>如果不开启<code>strictPropertyInitialization</code>的话，TS会允许以下的代码：</p> \n<pre><code>class Person {\n  name: string;\n  sayHello() {\n    // RUNTIME ERROR!\n    console.log( `Hello from ${this.name.toUpperCase()}`);\n  }\n} </code></pre> \n<p>这里有个很明显的问题：<code>this.name</code>没有被初始化，因此在运行时调用<code>sayHello</code>就会报错。</p> \n<p>造成这个错误的根本原因是这个属性没有在构造函数里或使用属性初始化器赋值，所以它（至少在最初）是undefined，因此他的类型就会变成string | undefined。</p> \n<p>开启<code>strictPropertyInitialization</code>会提示以下错误：</p> \n<pre><code>Property \'name\' has no initializer and is not assigned in the constructor. </code></pre> \n<p>当然，如果你在构造函数里或使用属性初始化器赋值了，这个错误也就会消失。</p> \n<p><strong>* 始终开启strictPropertyInitialization</strong></p> \n<h2>5. 记得指定函数的返回类型</h2> \n<p>TypeScript使你可以高度依赖类型推断，这意味着只要在TS能推断类型的地方，你就不需要标注类型。</p> \n<p>然而这就像一把双刃剑，一方面，它非常方便，并且减少了使用TypeScript的麻烦。而另一方面，有时推断的类型可能会和你的预期不一致，从而降低了使用静态类型提供的保障。</p> \n<p>在下方的例子中，我们没有注明返回类型，而是让TypeScript来推断函数的返回值。</p> \n<pre><code>interface Person {\n    name: string;\n    age: number;\n}\n\nfunction getName(person: Person | undefined) {\n    if (person &amp;&amp; person.name) {\n        return person.name;\n    } else if (!person) {\n        return \"no name\";\n    }\n}</code></pre> \n<p>乍看之下，我们可能认为我们的方法很安全，并且始终返回的是<code>string</code>类型，然而，当我们明确声明该函数的（预期）返回类型时就会发现报了一个错。</p> \n<pre><code>// COMPILE ERROR! \n// Function lacks ending return statement and return type does not include \'undefined\'. \nfunction getName(person: Person | undefined): string \n{\n    // ... \n}</code></pre> \n<p>顺便说一句，这个错误只有当你开启了<code>strictNullChecks</code>才会被检测出来。</p> \n<p>上述错误表明getName函数的返回值没有覆盖到一种情况：当<code>person</code>不为空，但是<code>person.name</code>为空的情况。这种情况所有if条件都不等于true，所以会返回undefined。</p> \n<p>因此，TypeScript推断此函数的返回类型为<code>string</code> | <code>underfined</code>，而我们声明的却是<code>string</code>。（译者注：所以主动声明函数返回值类型有助于帮我们提前捕捉一些不易察觉的bug）</p> \n<p><strong>* 始终标注函数的返回值类型</strong></p> \n<h2>6. 不要将隐式类型变量存储到对象中</h2> \n<p><strong>TypeScript的类型检查有时很微妙。</strong></p> \n<p>通常，当类型A至少具有和类型B相同的属性，那么TypeScript就允许将类型A的对象赋值给类型B的变量。这意味着它可以包含其他属性。</p> \n<pre><code>// 译者举例：\ntype A = {\n    name: string;\n    age: number;\n};\n\ntype B = {\n    name: string;\n};\n\nlet a: A = {\n    name: \'John\',\n    age: 12,\n};\n\nlet b: B;\n\n// compile success\nb = a;</code></pre> \n<p>然而如果直接传递的是对象字面量，其行为是不同的。只有目标类型包含相同的属性时，TypeScript才会允许它（传递）。此时不允许包含其他属性。</p> \n<pre><code>interface Person {\n    name: string;\n}\n\nfunction getName(person: Person): string | undefined {\n    // ...\n}\n\n// ok\ngetName({ name: \'John\' });\n\n// COMPILE ERROR\n// Argument of type \'{ name: string; age: number; }\' is not assignable to parameter of type \'Person\'.\ngetName({ name: \'John\', age: 30 });</code></pre> \n<p>如果我们不是直接传对象字面量，而是将对象存到常量里（再传递），这看起来没有什么区别。然而这却更改了类型检查的行为：</p> \n<pre><code>const person = { name: \'John\', age: 30 }; \n// OK \ngetName(person); </code></pre> \n<p>传递额外的属性可能会引起bug（例如当你想合并两个对象时）。了解这个行为并且在可能的情况下，直接传递对象字面量。</p> \n<p><strong>* 请注意如何将对象传递给函数并且始终要考虑传递额外的属性是否安全</strong></p> \n<h2>7. 不要过度使用类型断言</h2> \n<p>尽管TypeScript能对你的代码进行很多推断，但有时候你会比TypeScript更了解某个值的详细信息。这时你可以通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。</p> \n<p>比如说对一个从服务器请求回来的对象断言，或者将一个子类型的对象断言为父类型。</p> \n<p><strong>类型断言需要保守使用。</strong>比如绝对不能在函数传参类型不匹配时使用。</p> \n<p>有一种更安全的使用类型断言的方式：类型保护。类型保护是一个当返回true时能断言其参数类型的函数。它可以提供代码运行时的检测，让我们对传入的变量是否符合预期这点上更有信心。</p> \n<p>下面的代码中，我们需要使用类型断言，因为TypeScript不知道从后端返回的对象的类型。</p> \n<pre><code>interface Person {\n    name: string;\n    age: number;\n}\n\ndeclare const fetchFromBackend: (url: string) =&gt; Promise&lt;object&gt;;\n\ndeclare const displayPerson: (person: Person) =&gt; void;\n\nfetchFromBackend(\'/person/1\').then((person) =&gt; displayPerson(person as Person));</code></pre> \n<p>我们可以通过使用类型保护，提供一个简单的运行时检查来让代码更完善。我们假设一个对象只要拥有了<code>name</code>和<code>age</code>属性那么它的类型就是<code>Person</code>。</p> \n<pre><code>const isPerson = (obj: Object): obj is Person =&gt; \'name\' in obj &amp;&amp; \'age\' in obj;\n\nfetchFromBackend(\'/person/1\').then((person) =&gt; {\n  if(isPerson(person)) {\n    // Type of `person` is `Person` here!\n    displayPerson(person);\n  }\n})</code></pre> \n<p>你可以发现，多亏了类型保护，在if语句中person的类型已经可以被正确推断了。</p> \n<p><strong>* 考虑使用类型保护来替代类型断言</strong></p> \n<h2>8. 不要对Partial类型使用扩展运算符</h2> \n<p>Partial是一个非常有用的类型，它的作用是将源类型的每个属性都变成可选的。</p> \n<p>Partial有个好的实际使用场景：当你有一个表示配置或选项的对象类型，并且想要创建一个该配置对象的子集来覆写它。</p> \n<p>你可能会写出如下的代码：</p> \n<pre><code>interface Settings {\n  a: string;\n  b: number;\n}\n\nconst defaultSettings: Settings = { /* ... */ }; \n\nfunction getSettings(overrides: Partial&lt;Settings&gt;): Settings {\n  return { ...defaultSettings, ...overrides };\n}</code></pre> \n<p>这看起来还不错，但实际上揭示了TypeScript的类型系统中的一个漏洞。</p> \n<p>看下方的代码，<code>result</code>的类型是<code>Settings</code>，然而<code>result.a</code>的值却是<code>undefined</code>了。</p> \n<pre><code>const result = getSettings({ a: undefined, b: 2 });</code></pre> \n<p>由于扩展Partial是一种常见的模式，并且TypeScript的目标之一是在严格性和便利性之间取得平衡，所以可以说是TypeScript本身的设计带来了这种不一致性。但是，意识到该问题仍然非常重要。</p> \n<p><strong>* 除非你确定对象里不包含显式的undefined，否则不要对Parital对象使用扩展运算符</strong></p> \n<h2>9. 不要过于相信Record类型</h2> \n<p>这是TypeScript内置类型定义中的一个微妙情况的另一个示例。</p> \n<p>Record定义了一个对象类型，其中所有key具有相同的类型，所有value具有相同的类型。 这非常适合表示值的映射和字典。</p> \n<p>换句话说，<code>Record&lt;KeyType, ValueType&gt;</code> 等价于 <code>{ [key: KeyType]: ValueType }</code>。</p> \n<p>从下方代码你可以看出，通过访问record对象的属性返回的值的类型应该和ValueType保持一致。然而你会发现这不是完全正确的，因为abc的值会是undefined。</p> \n<pre><code>const languages: Record&lt;string, string&gt; = {\n    \'c++\': \'static\',\n    \'java\': \'static\',\n    \'python\': \'dynamic\',\n};\n\n\nconst abc: string = languages[\'abc\']; // undefined</code></pre> \n<p>这又是一个TypeScript选择了便利性而不是严格性的例子。虽然大多数例子中这样使用都是可以的，但是你仍然要小心些。</p> \n<p>最简单的修复方式就是使Record的第二个参数可选：</p> \n<pre><code>const languages: Partial&lt;Record&lt;string, string&gt;&gt; = {\n    \'c++\': \'static\',\n    \'java\': \'static\',\n    \'python\': \'dynamic\',\n};\n\nconst abc = languages[\'abc\']; // abc is infer to string | underfined</code></pre> \n<p><strong>* 除非你确保没问题，否则可以始终保持Record的值类型参数（第二个参数）可选</strong></p> \n<h2>10. 不要允许出现不合格的类型声明</h2> \n<p>在定义业务域对象的类型时，通常会遇到类似以下的情况：</p> \n<pre><code>interface Customer {\n    acquisitionDate: Date;\n    type: CustomerType;\n    firstName?: string;\n    lastName?: string;\n    socialSecurityNumber?: string;\n    companyName?: string;\n    companyTaxId?: number;\n}</code></pre> \n<p>这个对象包含很多可选的对象。其中一些对象是当Customer表示人时（<code>type === CustomerType.Individual</code>）才有意义且必填，另外的则是当Custormer表示公司时（<code>type === CustomerType.Institution</code>）必填。</p> \n<p>问题在于Customer类型不能反映这一点！ 换句话说，它允许属性的某些非法组合（例如，lastName和companyName都未定义）</p> \n<p>这确实是有问题的。 你要么执行额外的检查，要么使用类型断言来消除基于type属性值的某些字段的可选性。</p> \n<p>幸运的是,有一个更好的解决方案——辨析联合类型。辨析联合类型是在联合类型的基础上增加了一个功能：在运行时可以区分不同的方案。</p> \n<p>我们将Customer类型重写为两种类型：<code>Individual</code>和<code>Institution</code>的联合，各自包含一些特定的字段，并且有一个共有字段：<code>type</code>，它的值是一个字符串。此字段允许运行时检查，并且TypeScript知道可以专门处理它。</p> \n<pre><code>interface Individual {\n  kind: \'individual\';\n  firstName: string;\n  lastName: string;\n  socialSecurityNumber: number;\n}\n\ninterface Institution {\n  kind: \'institutional\';\n  companyName: string;\n  companyTaxId: number;\n}\n\ntype Customer = Individual | Institution;</code></pre> \n<p>辨析联合类型真正酷的地方是TypeScript提供了内置的类型保护，可以让你避免类型断言。</p> \n<pre><code>function getCustomerName(customer: Customer) {\n  if (customer.kind === \'individual\') {\n    // The type of `customer` id `Individual`\n    return customer.lastName;\n  } else {\n    // The type of `customer` id `Institution`\n    return customer.companyName;\n  }\n}</code></pre> \n<p><strong>* 当遇到复杂的业务对象时尽量考虑使用辨析联合类型。这可以帮你创建更贴合现实场景的类型</strong></p> \n<p>文章到此结束了！我希望这个列表可以像帮助我一样，帮助你捕获许多讨厌的bug。</p> \n<p><strong>接下来是这篇文章所有建议的总结：</strong></p> \n<ol> \n <li><strong>考虑对所有外部提供的对象执行运行时检查（例如从后端获取的对象，JSON反序列化的对象等）</strong></li> \n <li><strong>不使要用any类型并开启noImplicitAny</strong></li> \n <li><strong>始终开启strictNullChecks</strong></li> \n <li><strong>始终开启strictPropertyInitialization</strong></li> \n <li><strong>始终标注函数的返回值类型</strong></li> \n <li><strong>请注意如何将对象传递给函数并且始终要考虑传递额外的属性是否安全</strong></li> \n <li><strong>考虑使用类型保护来替代类型断言</strong></li> \n <li><strong>除非你确定对象里不包含显式的undefined，否则不要对Parital对象使用扩展运算符</strong></li> \n <li><strong>除非你确保没问题，否则可以始终保持Record的值类型参数（第二个参数）可选</strong></li> \n <li><strong>当遇到复杂的业务对象时尽量考虑使用辨析联合类型。</strong></li> \n</ol>', null, null, null, '0', '0', null, '1', '2020-04-14 20:58:24', '2020-04-14 20:58:24');
INSERT INTO `tb_recommend` VALUES ('94d29098728945aeaf7ae95a62ac0491', '2020年十大最佳自动化测试工具', '对更快交付高质量软件（或\"快速质量\"）的需求要求组织以敏捷，持续集成（CI）和DevOps方法论来寻找解决方案。测试自动化是这些方面的重要组成部分。最新的《 2018-2019年世界质量报告》表明，测试自动化是实现\"快...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303938\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Best Automation Testing Tools for 2020</p> \n<p>对更快交付高质量软件（或\"快速质量\"）的需求要求组织以敏捷，持续集成（CI）和DevOps方法论来寻找解决方案。测试自动化是这些方面的重要组成部分。最新的《 2018-2019年世界质量报告》表明，测试自动化是实现\"快速质量\"的最大瓶颈，因为它是成功采用敏捷和DevOps的推动力。</p> \n<p>没有好的工具就无法实现测试自动化。因为它们决定了如何执行自动化以及是否可以实现自动化的好处。测试自动化工具是DevOps工具链中的关键组件。在应用人工智能和机器学习（AI / ML）来提供用于测试优化，智能测试生成，执行和报告的高级功能方面，当前的测试自动化趋势已经增长。有必要了解哪种工具最适合利用这些趋势。</p> \n<p>这些顶级的自动化测试工具被认为可以最好地解决未来几年自动化领域的挑战。从以下条件中选择此列表中包括的工具：</p> \n<ul> \n <li>支持API和服务测试</li> \n <li>提供一些AI / ML和分析功能</li> \n <li>知名度和成熟度</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303937\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Top 5 Automation Testing Tools for 2020</p> \n<h1>1.Selenium</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303939\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Selenium是测试自动化的家喻户晓的名字。它被认为是Web应用程序用户界面自动化测试的行业标准。根据\"测试自动化挑战调查\"显示，十分之九的测试人员中有近九位在其项目中使用或曾经使用过硒。</p> \n<p>对于具有编程和脚本编写经验和技能的开发人员和测试人员，Selenium提供了许多其他测试自动化工具和框架所不具备的灵活性。用户可以使用多种语言（例如Java，Groovy，Python，C＃，PHP，Ruby和Perl）编写测试脚本，这些脚本可以在多种系统环境（Windows，Mac，Linux）和浏览器（Chrome，Firefox，IE和 无头浏览器）。</p> \n<p>Selenium最近于2019年4月发布了其第一个alpha版本的Selenium。Selenium4正式版的发布尚未确定；目前，Selenium 4正式发布。但是您可以期望该版本将具有许多改进和丰富的功能。</p> \n<p>为了有效地使用Selenium，用户必须具备高级编程技能，并且需要花费大量时间来构建自动化所需的自动化框架和库。这是Selenium的主要缺点，可通过Katalon Studio等集成工具解决。</p> \n<p>许可证：开源</p> \n<h1>2. Katalon Studio</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303940\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Katalon Studio是功能强大且全面的自动化解决方案，用于测试API，Web，移动和桌面应用程序测试。它还为这些类型的测试提供了丰富的功能集，并支持包括Windows，macOS和Linux在内的多个平台。</p> \n<p>利用Selenium和Appium引擎，Katalon Studio为那些难以集成和部署不同框架和库以使用Selenium和Appium的测试人员以及已经熟悉这些引擎的测试人员提供了一个独特的集成环境。</p> \n<p>Katalon Studio赢得了Gartner Peer Insights客户的软件测试自动化大奖，获得了450多项正面评价，该评论获得了450多项正面评价，这再次证明该工具现在是市场上最大的公司之一。</p> \n<p>该工具的重点包括：</p> \n<ul> \n <li>API / Web服务，Web和移动应用程序的测试自动化的完整功能集</li> \n <li>同时支持SOAP和RESTful的API和服务测试</li> \n <li>数百个用于创建测试用例的内置关键字</li> \n <li>可用于自动化和探索性测试</li> \n <li>可以通过Katalon Store上的插件扩展测试功能，深入了解Katalon TestOps上的报告</li> \n</ul> \n<p>许可证：免费</p> \n<h1>3. UFT</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303942\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>UFT是测试桌面，Web和移动应用程序的流行商业工具。它已扩展为包括一组用于API测试的功能。通过为被测目标应用程序（AUT）支持多个平台，UFT提供了一种方便的选择来测试可在台式机，Web和移动设备上运行的AUT。</p> \n<p>UFT为智能对象检测，基于图像的对象检测和校正提供了几种高级功能。在2019年5月，Microfocus已发布具有新功能和增强功能的最新版UFT（v14.53）</p> \n<p>该工具的特点包括：</p> \n<ul> \n <li>直观的用户界面，用于创建，执行和报告API测试</li> \n <li>支持从WADL文档生成API测试</li> \n <li>测试的动作，活动和参数可以在图表中可视化</li> \n</ul> \n<p>许可证：每年3,200美元起。</p> \n<h1>4. TestComplete</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303941\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>今年，TestComplete凭借其强大，全面的Web，移动和桌面应用程序测试功能继续名列前茅。测试人员可以使用JavaScript，VBScript，Python或C ++ Script编写测试脚本。</p> \n<p>与UFT一样，TestComplete具有对象识别引擎，可以准确地检测动态用户界面元素。该引擎在具有动态且经常更改的用户界面的应用程序中特别有用。</p> \n<p>最新的TestComplete版本14.2包括与Jenkins的本机集成，以加速CI / CD流程，对Web测试组件（如Shadow DOM和自定义元素）的支持以及对所有最新浏览器版本和移动平台的支持。</p> \n<p>测试人员可以轻松使用TestComplete的记录和回放功能，例如Katalon Studio。他们可以将检查点插入测试步骤以验证结果。作为SmartBear的产品，TestComplete可以轻松地与SmartBear提供的其他产品集成。</p> \n<p>许可：每位用户每年$ 9,114起</p> \n<h1>5. SoapUI</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303943\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>SoapUI不是用于Web或移动应用程序测试的测试自动化工具；但是它可以作为测试API和服务的首选工具。它是专门为API测试而设计的无头功能测试工具。</p> \n<p>SoapUI支持REST和SOAP服务。API自动化测试人员可以使用开源版本或专业版。专业版具有友好的用户界面和一些高级功能，例如断言向导，表单编辑器和SQL查询生成器。SoapUI是SmartBear提供的ReadyAPI套件的工具。</p> \n<p>该工具为API测试提供了相当全面的功能集，其中包含许多高级功能，其中包括：</p> \n<ul> \n <li>拖放，点击即可轻松生成测试</li> \n <li>使用文件和数据库中的数据进行强大的数据驱动测试</li> \n <li>异步测试</li> \n <li>脚本可以轻松重用</li> \n <li>使用RESTful模拟创建模拟服务</li> \n</ul> \n<p>此外，SoapUI最近将SoapUI Pro的API Explorer功能引入了开源版本，从而使开发人员和测试人员可以立即调试其API的响应。</p> \n<p>许可：SoapUI打包和分发为两个版本，开源和Pro。后者的起价为每年659美元。</p> \n<p>请注意，SoapUI和Postman仅是此列表中几个顶级API测试工具的两个代表。要了解有关这些工具之间比较的更多信息，请参阅此文章。</p> \n<h1>6. IBM Rational Functional Tester（RFT）</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303944\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>IBM Rational Functional Tester是一个测试自动化工具，旨在测试使用不同语言和技术开发的应用程序，例如Web，.Net，Java，Visual Basic，Siebel，SAP，PowerBuilder，Adobe Flex和Dojo Toolkit。它也是用于功能和回归测试的数据驱动测试平台。</p> \n<p>RFT提供了一个称为\"故事板测试\"的功能，该功能可以使用自然语言和应用程序屏幕截图来可视化和编辑测试。RFT的ScriptAssure功能使测试人员能够生成可适应AUT用户界面变化的测试脚本。RFT还可以与其他IBM应用程序生命周期管理工具集成，例如IBM Rational Team Concert和Rational Quality Manager。</p> \n<p>执照：商业</p> \n<h1>7. Tricentis&nbsp;Tosca</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303946\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>有一些连续的测试平台可提供全面的工具集，以支持大多数（如果不是全部）测试活动，从测试设计和测试自动化到测试报告和分析。Tricentis Tosca是其中之一。</p> \n<p>该工具具有许多功能，例如仪表板，分析，集成和分布式执行，以支持持续集成和DevOps实践。此外，它提供了友好的用户界面和丰富的功能集，可用于设计，实施，执行，管理，优化API测试。</p> \n<p>该工具的其他一些亮点：</p> \n<ul> \n <li>可以轻松集成为DevOps流程的关键部分</li> \n <li>可以在浏览器，移动设备和平台上执行API测试</li> \n <li>启用了多种协议和标准，包括HTTP JMS，AMQP，Rabbit MQ，TIBCO EMS，SOAP，REST和IBM MQ</li> \n <li>一套很好的测试报告和分析功能</li> \n</ul> \n<p>Tricentis声称将大大减少回归测试（在数周至数分钟的时间内）。但是，此声明需要由测试团队仔细验证。</p> \n<p>执照：商业</p> \n<h1>8.Ranorex</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303945\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>已经存在很多年了，Ranorex为Web，移动，桌面和API测试提供了一套全面而专业的功能。利用其在基于桌面的测试自动化中的经验，Ranorex具有用于UI元素识别，编辑和管理的高级功能。</p> \n<p>与Katalon Studio一样，Ranorex友好而直观的GUI，记录/回放和脚本生成功能使测试人员可以轻松进行自动化测试。</p> \n<p>测试人员可以将Ranorex与Selenium Grid集成在一起，以实现分布式测试以及并行测试执行。</p> \n<p>许可：附加组件为690欧元，高级许可为2290欧元起。</p> \n<h1>9.Postman</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303947\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Postman是专为API测试设计的另一种自动化工具。用户可以在Mac，Linux，Windows上以浏览器扩展或桌面应用程序的形式安装此工具。它不仅在用于API测试自动化的测试人员中很流行，而且在使用该工具开发和测试API的开发人员中也很流行。实际上，它是用于开发和测试API的开发环境。</p> \n<p>该工具的一些亮点：</p> \n<ul> \n <li>用于设计，调试，测试，记录和发布API的综合功能集</li> \n <li>友好且易于使用的用户界面</li> \n <li>支持自动化和探索性测试</li> \n <li>接受Swagger和RAML API格式</li> \n <li>请求和应答者可以打包并与团队成员共享</li> \n</ul> \n<p>执照：商业</p> \n<h1>10. Apache JMeter</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303948\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>JMeter是设计用于测试加载和性能测量的开源工具-JMeter的两个功能是众所周知的。但是，该工具现在也用于API和服务测试，尤其是API性能。JMeter是第三种最受欢迎的测试自动化工具，在\"测试自动化挑战\"调查中有25％的受访者引用了JMeter的信息。</p> \n<p>该工具的重点包括：</p> \n<ul> \n <li>轻巧，具有简单易用的用户界面</li> \n <li>测试结果可以重播</li> \n <li>支持CSV文件来设置API参数的值</li> \n <li>支持与CI工具（例如Jenkins）集成。JMeter通常用作CI和DevOps工具链的一部分</li> \n</ul> \n<p>许可证：开源</p> \n<p>— — — —</p> \n<p>这里列出的顶级工具并不详尽。但是它代表了成熟，流行的最佳工具，并提供了使用AI / ML的功能来解决组织在交付\"快速质量\"时面临的挑战。此列表还包括仅支持API和服务测试对于成功进行敏捷和DevOps转换至关重要。</p> \n<p>您选择的测试工具不仅应满足您当前的需求，而且还应关注潜在的趋势和改进。体面的工具应支持基本优化，测试用例和数据生成的自动化，更智能的解决方案以及分析。</p> \n<p>随着增长的机会，将引入更多的工具；即使组织中的测试自动化水平低至14％到18％之间（WQR报告）。此外，很高兴看到现有和即将推出的工具如何应用AI / ML来应对未来的挑战。API和服务测试也是一种趋势，将来应该会得到进一步的发展。</p> \n<p>(本文翻译自Brian的文章《Best Automation Testing Tools for 2020 (Top 10 reviews)》，参考：<a href=\"https://medium.com/@briananderson2209/best-automation-testing-tools-for-2018-top-10-reviews-8a4a19f664d2)\" rel=\"nofollow noreferrer\">https://medium.com/@brianande...</a></p>', 'https://segmentfault.com/img/remote/1460000022303938', null, null, '0', '0', null, '1', '2020-04-14 20:58:20', '2020-04-14 20:58:20');
INSERT INTO `tb_recommend` VALUES ('af238c9a9cc548d39313fd7166e3842e', '跨端开发框架深度横评之2020版', '对应小程序开发领域，这一年也发生了巨大变化。开发框架从单纯的微信小程序开发，过渡到多端框架成为标配，进一步提升开发效率成为开发者的强烈需求。', '<p>又是一年四月天，距离上次发布<a href=\"https://segmentfault.com/a/1190000018738455\">跨端开发框架深度横评</a>已过去整整一年。</p> \n<p>这一年，小程序在用户规模及商业化方面都取得了极大的成功。微信小程序日活超过3亿，支付宝、百度、字节跳动小程序的月活也纷纷超过3亿。</p> \n<p>对应小程序开发领域，这一年也发生了巨大变化。开发框架从单纯的微信小程序开发，过渡到多端框架成为标配，进一步提升开发效率成为开发者的强烈需求。</p> \n<p>这一年 <code>mpvue</code> 停止更新，<code>Taro</code>开始探索 <code>taro next</code>，<code>uni-app</code> 产品和生态持续完善，微信新推出了支持H5和微信小程序的 <code>kbone</code> 框架...</p> \n<p>去年的深度横评中很多老将已经退出江湖，一些新秀吸引眼球，因此，是时候来一波2020版的新横评了。</p> \n<h2>评测目标筛选</h2> \n<p>跨端框架是一个重投入工作，在各框架的1年多的比拼中，很多框架因为投入不足而逐渐被开发者放弃，<code>uni-app</code>和<code>taro</code>依靠持续的大力度投入，成为了市场主流。</p> \n<p><code>taro</code> 在稳定版的基础之上，最近也推出了 <code>taro next</code>，这2个版本差异较大，本次会分别评测。</p> \n<p><code>kbone</code> 框架虽面世不久，但毕竟是微信官方发布，关注的人不少，故本次将 <code>kbone</code> 加入评测目标。</p> \n<p>所以，本次评测的对象（按发布时间排序）：</p> \n<ul> \n <li>微信原生开发</li> \n <li>taro，京东凹凸实验室出品，官网地址：<a href=\"https://taro.jd.com/\" rel=\"nofollow noreferrer\">https://taro.jd.com/</a> </li> \n <li>uni-app，DCloud出品，官网地址：<a href=\"https://uniapp.dcloud.net.cn\" rel=\"nofollow noreferrer\">https://uniapp.dcloud.net.cn</a> </li> \n <li>kbone，腾讯微信团队出品，官网地址：<a href=\"https://wechat-miniprogram.github.io/kbone/docs/\" rel=\"nofollow noreferrer\">https://wechat-miniprogram.github.io/kbone/docs/</a> </li> \n</ul> \n<p>本次评测除了运行性能等实测数据外，尽可能得通过框架官网及github、掘金、腾讯课堂等三方社区公开采集数据，希望给大家一个综合全面的评估依据。</p> \n<h2>功能实现</h2> \n<p><code>taro</code> 和 <code>uni-app</code> 是比较典型的多端框架，发布到各个端均可。而 <code>kbone</code> 只支持微信小程序和H5。</p> \n<p><code>taro</code> 和 <code>uni-app</code> 均将常用接口及组件封装了成了跨端API和跨端组件，组件规范沿用微信小程序的规范，部分平台特有API，这两个框架亦有应对方案：</p> \n<ul> \n <li>taro：支持<a href=\"https://nervjs.github.io/taro/docs/hybrid.html\" rel=\"nofollow noreferrer\">与小程序代码混写</a>，可通过混写的方式调用框架尚未封装的小程序新增API</li> \n <li>uni-app：支持<a href=\"https://uniapp.dcloud.io/platform\" rel=\"nofollow noreferrer\">条件编译</a>，可在条件编译代码块中，随意调用各个平台新增的API及组件</li> \n</ul> \n<p><code>taro</code> 和 <code>uni-app</code> 可以不受限的调用各家小程序平台所有的API及组件。</p> \n<p><code>kbone</code> 沿用<code>web</code>的开发习惯，使用<code>html</code>标签及<code>js api</code>；涉及微信特有api时，可通过<code>process.env.isMiniprogram</code>判断环境，然后编写微信原生代码。对于<code>html</code>中没有标签可替代的微信内置组件（如<code>swiper</code>），需要使用 <code>wx-component</code> 标签或者使用 <code>wx-</code> 前缀，这样的内置组件会被包裹一层自定义组件，带来相应的性能开销。</p> \n<p>除了接口、组件之外，我们以微信小程序为例，找几个典型能力对比框架支持度：</p> \n<table> \n <thead>\n  <tr> \n   <th align=\"center\">框架</th> \n   <th align=\"center\">taro</th> \n   <th align=\"center\">uni-app</th> \n   <th align=\"center\">kbone</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td align=\"center\">微信自定义组件</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n  <tr> \n   <td align=\"center\">三方插件</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">❌</td> \n  </tr> \n  <tr> \n   <td align=\"center\">分包加载</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n  <tr> \n   <td align=\"center\">sitemap</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n  <tr> \n   <td align=\"center\">wxs</td> \n   <td align=\"center\">❌</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">❌</td> \n  </tr> \n  <tr> \n   <td align=\"center\">云开发</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n </tbody> \n</table> \n<p>补充说明：</p> \n<ul> \n <li>如果在 Taro 项目引用了小程序原生的第三方组件，那么该项目将不再具备多端转换的能力，例如，如果使用了微信小程序的第三方组件，那么项目只能转换成微信小程序，转义成其他平台会失效，详见<a href=\"https://taro-docs.jd.com/taro/docs/mini-third-party.html\" rel=\"nofollow noreferrer\">taro官网</a> </li> \n <li>uni-app 中使用微信自定义组件的话，支持编译发行到App/H5/微信小程序/QQ小程序4个平台，详见<a href=\"https://uniapp.dcloud.net.cn/frame?id=%e5%b0%8f%e7%a8%8b%e5%ba%8f%e7%bb%84%e4%bb%b6%e6%94%af%e6%8c%81\" rel=\"nofollow noreferrer\">uni-app官网</a> </li> \n <li>taro 不支持 wxs 的依据：<a href=\"https://github.com/NervJS/taro/issues/2959\" rel=\"nofollow noreferrer\">#2959</a> </li> \n <li>kbone 不支持微信三方插件的依据：<a href=\"https://github.com/Tencent/kbone/issues/58\" rel=\"nofollow noreferrer\">#58</a>；不支持wxs的依据：<a href=\"https://github.com/Tencent/kbone/issues/129\" rel=\"nofollow noreferrer\">#129</a> </li> \n <li>云开发在微信平台，三个框架都支持，但 taro/kbone仅支持微信小程序平台，uni-app支持<code>App/H5/小程序</code>所有平台使用云开发，详见下方 <code>serverless/云开发</code> 章节。</li> \n</ul> \n<p><code>wxs</code>是提升性能体验的重要利器，除了微信小程序的<code>wxs</code>外，还有支付宝的<code>SJS</code>、百度的<code>Filter</code>，这些高级技术 <code>uni-app</code> 均完善支持。参考：<a href=\"https://juejin.im/post/5d7f366b6fb9a06af8250bc4\" rel=\"nofollow noreferrer\">谜之wxs，uni-app如何用它大幅提升性能</a></p> \n<p>从如上功能对比来看：微信原生 ~ uni-app &gt; taro &gt; kbone</p> \n<h2>运行性能</h2> \n<p>我们继续沿用去年的测试模型，看看一年来，各家小程序开发框架的性能是否有提升。详细如下：</p> \n<ul> \n <li>开发内容：开发一个仿微博小程序首页的复杂长列表，支持下拉刷新、上拉翻页、点赞。</li> \n <li>界面如下：</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326485\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li>开发版本：一共开发了5个版本，包括微信原生版、taro版、uni-app版、kbone版，按照官网指引通过<code>cli</code>方式默认安装。</li> \n <li>taro 目前稳定版本是2.0版，但近期在宣传跨框架的taro next，故我们基于同样的 react代码，同时测试了taro 2.0 和 taro next 两个版本的数据。</li> \n <li>测试代码开源（<a href=\"https://github.com/dcloudio/test-framework\" rel=\"nofollow noreferrer\">Github仓库地址：https://github.com/dcloudio/test-framework</a>），</li> \n</ul> \n<p><em>Tips:若有同学觉得测试代码写法欠妥，欢迎提交 PR 或 <a href=\"https://github.com/dcloudio/test-framework/issues\" rel=\"nofollow noreferrer\">Issus</a></em></p> \n<ul> \n <li>测试机型：红米 Redmi 6 Pro、MIUI 11.0.5 稳定版（最新版）、微信版本 7.0.12（最新版）</li> \n <li>测试环境：每个框架开始测试前，杀掉各App进程、清空内存，保证测试机环境基本一致；每次从本地读取静态数据，屏蔽网络差异。</li> \n</ul> \n<p>我们以上述仿微博小程序为例，测试2个容易出性能问题的点：长列表加载、大量点赞组件的响应。</p> \n<h3>长列表加载</h3> \n<p>仿微博的列表是一个包含很多组件的列表，这种复杂列表对性能的压力更大，很适合做性能测试。</p> \n<p>从触发上拉加载到数据更新、页面渲染完成，需要准确计时。人眼视觉计时肯定不行，我们采用程序埋点的方式，制定了如下计时时机：</p> \n<ul> \n <li>计时开始时机：交互事件触发，框架赋值之前，如：上拉加载（onReachBottom）函数开头</li> \n <li>计时结束时机：页面渲染完毕(微信setData回调函数开头)</li> \n</ul> \n<p>Tips：<code>setData</code>回调函数开头可认为是页面渲染完成的时间，是因为微信<code>setData</code>定义如下(<a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html?search-key=Page.prototype.setData\" rel=\"nofollow noreferrer\">微信规范</a>)：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326486\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>测试方式：从页面空列表开始，通过程序自动触发上拉加载，每次新增20条列表，记录单次耗时；固定间隔连续触发 N 次上拉加载，使得页面达到 20*N 条列表，计算这 N 次触发上拉到渲染完成的平均耗时。</p> \n<p>测试结果如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326487\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>说明：以400条微博列表为例，从页面空列表开始，每隔1秒触发一次上拉加载（新增20条微博），记录单次耗时，触发20次后停止（页面达到400条微博），计算这20次的平均耗时，结果微信原生在这20次 <code>触发上拉 -&gt; 渲染完成</code> 的平均耗时为538毫秒，最快的<code>uni-app</code>是446毫秒，最慢的<code>kbone</code>是4057毫秒</p> \n<p>大家初看这个数据，可能比较疑惑，别急，下方有详细说明</p> \n<p><strong>说明1：为何 taro next/kbone 测试数据不完整?</strong></p> \n<p>因为 <code>taro next</code> 和<code>kbone</code> 采用的是动态渲染方案，这类方案在页面复杂、组件较多时，会大量增加页面 <code>dom</code> 节点数量，甚至超出微信的 <code>dom</code> 节点数限制（如下告警信息）。我们在 红米手机（Redmi 6 Pro）上实测，页面组件超过600个时，<code>taro next</code>、<code>kbone</code> 实现的仿微博App就会报出运行异常，并停止渲染（页面白屏），故这两个测试框架在组件较多时，测试数据不完整。这也就意味着，当页面组件太多时，无法使用这2个框架。</p> \n<blockquote>\n dom limit exceeded please check if there\'s any mistake you\'ve made\n</blockquote> \n<p>另外，kbone官网有如下介绍：</p> \n<blockquote>\n kbone 是使用一定的性能损耗来换取更为全面的 Web 端特性支持。\n</blockquote> \n<p>故<code>taro next</code>、<code>kbone</code>的测试数据，明显和<code>taro 2.0</code>、<code>uni-app</code>不是一个量级的。</p> \n<p>如果你的应用是长列表场景，那<code>taro next</code>、<code>kbone</code>就明显不太合适。</p> \n<p><strong>说明2：为什么测试数据显示uni-app 会比微信原生框架的性能略好呢？</strong></p> \n<p>这个问题在去年的测评中，已解释过。为了避免新同学迷惑，这里再次说明一下。</p> \n<p>微信原生框架耗时主要在<code>setData</code>调用上，开发者若不单独优化，则每次都会传递大量数据；而 <code>uni-app</code>、<code>taro</code> 都在调用<code>setData</code>之前自动做<code>diff</code>计算，每次仅传递变动的数据。</p> \n<p>例如当前页面有20条数据，触发上拉加载时，会新加载20条数据，此时原生框架通过如下代码测试时，<code>setData</code>会传输40条数据</p> \n<pre><code>data: {\n    listData: []\n},\nonReachBottom() { //上拉加载\n    let listData = this.data.listData;\n    listData.push(...Api.getNews());//新增数据\n    this.setData({\n        listData\n    }) //全量数据，发送数据到视图层\n}</code></pre> \n<p>开发者使用微信原生框架，完全可以自己优化，精简传递数据（每次仅传递变化的20条数据），比如修改如下：</p> \n<pre><code class=\"javascript\">data: {\n    listData: []\n},\nonReachBottom() { //上拉加载\n    // 通过长度获取下一次渲染的索引\n    let index = this.data.listData.length;\n    let newData = {}; //新变更数据\n    Api.getNews().forEach((item) =&gt; {\n        newData[\'listData[\' + (index++) + \']\'] = item //赋值，索引递增\n    }) \n    this.setData(newData) //增量数据，发送数据到视图层\n}</code></pre> \n<p>经过如上优化修改后，再次测试，微信原生框架性能数据如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326489\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>从测试结果可看出：</p> \n<ul> \n <li>经过开发者手动优化，微信原生框架可达到更好的性能；</li> \n <li> <code>uni-app</code>相比微信原生，性能接近，算是一个数量级；并且随着数据量增加，性能消耗增加不明显，从438到454，只有16毫秒的变化</li> \n <li> <code>taro 2.0</code>随着数据量越大，性能损耗随着增大，从595到790，有将近200毫秒的变化；</li> \n <li> <code>taro next</code>和<code>kbone</code>相比之下，差距就比较大了。</li> \n</ul> \n<p>这个结果，和<code>web</code>开发类似，<code>web</code>开发也有原生js开发、<code>vue</code>、<code>react</code>框架等情况。如果不做特殊优化，原生js写的网页，性能经常还不如<code>vue</code>、<code>react</code>框架的性能。</p> \n<p>也恰恰是因为<code>Vue</code>、<code>react</code>框架的优秀，性能好，开发体验好，所以原生js开发已经逐渐减少使用了。</p> \n<p><strong>说明3：为何今年的性能测试数据和去年的不同？</strong></p> \n<p>细心的同学会发现，同样的测试手机，同样的测试代码，为何今年的性能数据会比<a href=\"https://juejin.im/post/5ca1736af265da30ae314248#heading-3\" rel=\"nofollow noreferrer\">去年的数据</a>有大幅提升？</p> \n<ul> \n <li>taro、uni-app及微信原生，三个框架的数据都有大幅提升，400条记录时，至少都有300毫秒的优化</li> \n <li>uni-app及优化后的微信原生，随着数据量的增加，耗时数据变化并不明显，但去年是很明显的线性增长</li> \n</ul> \n<p>其实，通过微信原生工程的数据对比，就能得出结论：2019年，微信针对小程序运行时做了大幅性能优化。</p> \n<p>这对开发者来说应该是个<strong>好消息</strong>，小程序性能体验更佳，可承载更好的用户业务。</p> \n<p>复杂长列表加载下一页评测结论：微信原生开发(手动优化) ~ <code>uni-app</code> &gt; 微信原生开发(未手动优化) ~ <code>taro 2.0</code> &gt; <code>taro next</code> &gt; <code>kbone</code></p> \n<h3>点赞组件响应速度</h3> \n<p>长列表中的某个组件，比如点赞组件，点击时是否能及时的修改未赞和已赞状态？是这项测试的评测点。</p> \n<p>测试方式：</p> \n<ul> \n <li>选中某微博，点击“点赞”按钮，实现点赞状态状态切换（已赞高亮、未赞灰色），</li> \n <li>点赞按钮 <code>onclick</code>函数开头开始计时，<code>setData</code>回调函数开头结束计时；</li> \n</ul> \n<p>在红米手机（Redmi 6 Pro）上进行多次测试，求其平均值，结果如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326488\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>说明：也就是在列表数量为400时，微信原生开发的应用，点赞按钮从点击到状态变化需要26毫秒。</p> \n<p>测试结果数据说明：</p> \n<ul> \n <li>taro next/kbone 测试数据不完整的原因同上，在组件较多时，页面已经不再渲染了</li> \n <li>taro 2.0版本、uni-app和微信原生在点赞组件上的性能体验接近，但taro next和kbone有较大的性能差距，这个也是因为动态运行时框架导致的。</li> \n</ul> \n<p>组件数据更新性能测评：<code>uni-app</code> ~ <code>taro 2.0</code> &gt; <code>taro next</code> &gt; <code>kbone</code></p> \n<p>综上，本性能测试做了2个测试，长列表加载和组件状态更新，综合2个实验，结论如下：</p> \n<p>微信原生开发(手动优化) ~ <code>uni-app</code> &gt; 微信原生开发(未手动优化) ~ <code>taro 2.0</code> &gt; <code>taro next</code> &gt; <code>kbone</code></p> \n<h2>跨端支持</h2> \n<p>这三个框架都是为了解决平台同构问题，跨端的比较是必需的。</p> \n<p><code>taro</code> 和 <code>uni-app</code> 相对比较成熟，支持主流的所有平台。kbone 只支持微信小程序和 Web 端。我们重点比较一下 <code>taro</code> 和 <code>uni-app</code>。</p> \n<h3>小程序平台</h3> \n<p><code>taro</code> 和 <code>uni-app</code> 均支持微信、支付宝、百度、字节跳动小程序，功能基本可以拉齐。</p> \n<p>双方都有不少大厂案例，<code>taro</code>有京东、货拉拉、淘票票等公司小程序案例，<code>uni-app</code>有腾讯、华为、vivo、联想、中华英才网等公司小程序案例。</p> \n<h3>App平台</h3> \n<ul>\n <li>能力方面</li>\n</ul> \n<p><code>taro</code>与微信小程序引擎拉齐度较低，很多功能需要开发者分别在iOS和Android上做原生开发才能实现。比如App端很常见的三方登录、支付、分享等能力，<code>taro</code>并未封装。</p> \n<p><code>uni-app</code>则在基础引擎层面提供了丰富的能力，还提供了丰富的插件市场，可切实提升开发者的效率。</p> \n<ul>\n <li>性能方面</li>\n</ul> \n<p><code>taro</code>在App端使用了<code>react native</code>的渲染引擎，虽然渲染层ui是原生的，但在实时交互和高响应要求的UI操作方面表现一直不佳，js层和视图层的通信损耗让很多开发者深感无力。</p> \n<p><code>uni-app</code>的App引擎同时给开发者提供了原生渲染引擎和小程序引擎的双选方案，并且由于发明了renderjs技术，以及支持wxs、bindingx等技术，解决了js层和视图层的通信损耗问题，在高响应要求的UI操作方面有更好的性能表现。比如这类canvas动画：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326491\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li>开发体验方面</li>\n</ul> \n<p>taro的开发者需自行搭建iOS/Android开发环境，比较繁琐，（<a href=\"https://taro-docs.jd.com/taro/docs/react-native.html#%E6%90%AD%E5%BB%BA-android-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83\" rel=\"nofollow noreferrer\">官方原文地址</a>）：</p> \n<p><code>uni-app</code>可以做到让前端开发者不依赖原生工程师独立完成App。其开发的小程序，可以更平滑的变成可商用的App。</p> \n<p>使用跨平台开发的核心诉求在于提升效率，如果一个App的开发由前端、iOS、Android等3拨工程师协作完成，其实效率反而非常低。</p> \n<p>另外，<code>uni-app</code>还提供了uni小程序sdk，这个工具可以帮助原生App快速搭建自己的小程序平台。这是其他框架所未提供的。</p> \n<h3>H5平台</h3> \n<p>taro的H5平台在一年来的进步较多，可用性大幅提升。但相比于<code>uni-app</code>，目前仍然缺失对wxs和小程序组件的支持。</p> \n<h3>快应用</h3> \n<p><code>taro</code>支持快应用的时间比<code>uni-app</code>早。</p> \n<p>但快应用发展到2020年有了一些变化，<code>uni-app</code>针对新的形势，提供了2个发行到快应用的方案（当前两个版本都处于社区维护状态）：</p> \n<ul> \n <li>quickapp-vue版：<a href=\"https://doc.quickapp.cn/tutorial/others/vue.html\" rel=\"nofollow noreferrer\">使用 Vue开发快应用</a>。此方案由小米主导，但华为快应用暂不支持。</li> \n <li>quickapp-light版：基于小程序架构的快应用（Light版），详见<a href=\"https://www.hellohub.cn\" rel=\"nofollow noreferrer\">https://www.hellohub.cn</a>。此方案由华为主导，但小米快应用暂不支持。</li> \n</ul> \n<h3>跨端灵活性</h3> \n<p>跨端开发，离不开条件编译。因为不能用统一来抹杀各个平台的特色。</p> \n<p>优良的条件编译能力对各端开发的灵活度至关重要，可以让开发者在共享和个性化之间游刃有余。</p> \n<p><code>taro</code> 、<code>uni-app</code>和 <code>kbone</code> 均支持在<code>js</code>代码通过<code>process.env</code>判断平台，然后编写平台特有代码。</p> \n<p><code>taro</code>额外支持统一接口的多端文件编码方式，以及在样式文件中使用<code>ifdef</code>条件编译。</p> \n<p><code>uni-app</code>是全面可条件编译的，目录、文件、配置、组件、js、css，所有一切均可通过<code>ifdef</code>条件编译。</p> \n<p>跨端支持小结结论：<code>uni-app</code> &gt; <code>taro</code> &gt; <code>kbone</code></p> \n<h2>开发体验</h2> \n<p><code>taro</code>、<code>uni-app</code>、<code>kbone</code>均支持<code>cli</code>模式，可以在主流前端工具中开发，且基本都带有d.ts的语法提示库。三个框架均支持主流的<code>vue</code>或<code>react</code>语法，配套的ide工具链较丰富，着色、校验、格式化完善。</p> \n<p>相比微信原生，这三个开发框架的开发体验都更为优秀。</p> \n<p>但在开发工具维度上，明显高出一截的框架是<code>uni-app</code>，其出品公司同时也是HBuilderX的出品公司<a href=\"https://dcloud.net.cn/\" rel=\"nofollow noreferrer\">DCloud.io</a>，HBuilderX为<code>uni-app</code>做了很多优化，代码提示、转到定义、easycom、运行调试...故<code>uni-app</code>的开发效率、易用性非其他框架可及。</p> \n<p>开发体验维度，对比结果：<code>uni-app</code> &gt; <code>taro</code>,<code>kbone</code></p> \n<h2>serverless/云开发</h2> \n<p>serverless是目前炙手可热的一个概念，被称为下一代的云技术，是真正的”云“。</p> \n<p>微信率先将 serverless 技术引入小程序开发领域，即<a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html\" rel=\"nofollow noreferrer\">云开发</a>，帮助开发者云端一体的完成业务。随后，支付宝、百度都上线了自己的云开发。根据微信公开的数据，已经有50万开发者在使用微信云开发了。</p> \n<p>不过小程序厂家主导的云开发存在一个天然限制，就是和平台绑定过紧，无法和其它平台共享数据。</p> \n<p>我们以微信云开发为例，如果你仅开发微信小程序，数据独家存在微信平台，那没问题；但如果你同时还有App或其他家小程序，此时微信小程序的数据存储在微信平台，其它平台的数据存储在开发者自己的服务器上，此时就出现了数据割裂。假设一个用户先使用小程序，个人数据存储在微信平台；有了粘性后升级到App，此时App端无法读取微信平台的数据，则用户就无法查看之前在小程序上的历史数据，甚至在App平台需要重新注册。这种情况对开发者是不利的。</p> \n<p>因此，跨端的 serverless 方案才是开发者的最优解。</p> \n<p>目前主流框架对云开发的支持情况：</p> \n<ul> \n <li>Taro：仅支持微信小程序，详见<a href=\"https://taro-docs.jd.com/taro/docs/wxcloudbase.html\" rel=\"nofollow noreferrer\">小程序云开发模板</a> </li> \n <li>uni-app：DCloud 联合阿里云、腾讯云，提供基于 serverless 模式和 js 编程的云开发平台，支持App/H5/小程序所有平台，详见<a href=\"https://uniapp.dcloud.net.cn/uniCloud/README\" rel=\"nofollow noreferrer\">uniCloud</a> </li> \n <li>kbone：仅支持微信小程序，详见<a href=\"https://wechat-miniprogram.github.io/kbone/docs/guide/advanced.html#%E4%BA%91%E5%BC%80%E5%8F%91\" rel=\"nofollow noreferrer\">云开发</a> </li> \n</ul> \n<p>serverless 维度上，<code>uni-app</code>大幅领先其它框架。</p> \n<h2>插件市场</h2> \n<p>一个开发框架能否成功，除了框架自身的高度产品化外，开发者生态的构建也至关重要。</p> \n<p><code>uni-app</code> 于2018年底率先推出<a href=\"https://ext.dcloud.net.cn\" rel=\"nofollow noreferrer\">插件市场</a>，支持前端组件、js sdk、页面模板、项目模板、原生插件等多种类型，且提供了赞赏、付费购买等手段，刺激轮子作者的创作激情。目前市场上已发布插件接近1500个，众多插件下载量都在万次以上。</p> \n<p><code>Taro</code> 于 2019年5月上线<a href=\"http://taro-ext.jd.com/\" rel=\"nofollow noreferrer\">物料市场</a>，目前市场上已发布物料90个；从热门榜单来看，下载量并不大，下载最多的也就数百。</p> \n<p><code>kbone</code>目前还没有插件市场。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326490\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Tips:</p> \n<ul>\n <li>插件数量及下载量数据采集时间为 2020.04.03 16：00</li>\n</ul> \n<p>插件市场维度，<code>uni-app</code>独领风骚。</p> \n<h2>学习资源</h2> \n<p>除了各大框架官网外，开发者通常还会通过视频教程、社区博客等方式系统学习。</p> \n<p>相关学习资源的丰富程度，也能侧面反映一个框架的受欢迎程度，故我们采集了几个三方站点的数据。</p> \n<p><strong>视频教程</strong></p> \n<table> \n <thead>\n  <tr> \n   <th>框架</th> \n   <th>腾讯课堂</th> \n   <th>网易云课堂</th> \n   <th>慕课网</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>taro</td> \n   <td>4</td> \n   <td>1</td> \n   <td>2</td> \n  </tr> \n  <tr> \n   <td>uni-app</td> \n   <td>16</td> \n   <td>16</td> \n   <td>1</td> \n  </tr> \n </tbody> \n</table> \n<p>Tips：</p> \n<ul>\n <li>视频教程数据采集时间为2020.04.05 22:00</li>\n</ul> \n<h2>开发交流</h2> \n<p>除了入门的学习资源，开发期的交流也很重要，这个我们主要看官方组织的社区和交流群。</p> \n<h3>社区论坛</h3> \n<p><code>uni-app</code> 的<a href=\"https://ask.dcloud.net.cn\" rel=\"nofollow noreferrer\">问答社区</a>，帖子丰富，沉淀较多；目前已沉淀2万多相关帖子，每日更新帖子数百篇，月uv百万。</p> \n<p>对于习惯使用 github issue反馈问题的用户，<code>uni-app</code>同样支持，目前累计有1391个issues。</p> \n<p>Taro 早期基于github issue进行产品Bug管理，目前累计已有近4898个issue；后于2019年5月上线<a href=\"http://taro-club.jd.com/\" rel=\"nofollow noreferrer\">开发者社区</a>，和物料市场上线时间相同，目前沉淀1300+帖子，每日更新帖子在10个左右，相关数据计算方法如下：</p> \n<ul> \n <li>帖子总数：Taro 社区顶部选择<code>板块</code>，计算每个板块下所有主题总数，如下图。</li> \n <li>每日更新帖子数：根据帖子列表中的最后回复时间，计算24小时内有回复或评论的主题总数</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326492\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>kbone 在微信开放社区中新增了一个<a href=\"https://developers.weixin.qq.com/community/minihome/mixflow/1213301129006825473\" rel=\"nofollow noreferrer\">Kbone官方框架</a>的专区，因产品发布较晚，目前只有一百多个帖子。</p> \n<p>总结一下社区帖子及issue数据，情况如下（采集时间为 2020.04.03 23：00）：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326493\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>交流群</h3> \n<table> \n <thead>\n  <tr> \n   <th>框架</th> \n   <th>微信群</th> \n   <th>QQ群</th> \n   <th>交流群开发者（预估）</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>taro</td> \n   <td>16</td> \n   <td>-</td> \n   <td>8k</td> \n  </tr> \n  <tr> \n   <td>uni-app</td> \n   <td>20</td> \n   <td>40+</td> \n   <td>90k</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>-</td> \n   <td>1</td> \n   <td>0.5k</td> \n  </tr> \n </tbody> \n</table> \n<p>Tips:</p> \n<ul> \n <li>Taro 有16个微信群是根据 Taro 官网上显示<code>Taro 开发交流 15 群 已满</code>推论而出，每个微信群500人，交流群人数： 500*16 = 8000人</li> \n <li>uni-app 官网 QQ群有35个，微信群20个，还有十几个专项QQ群，其中有30个QQ群达到2000人，交流群人数： 30 <em> 2000 + 5</em> 1000 + 20*500 + 5000 = 90000人</li> \n <li>kbone 在 github 的 readme中有一个qq交流群，申请加入时显示500人已满</li> \n</ul> \n<p>除了交流群外，DCloud对外公布的<code>uni-app</code>的开发者数量达到百万人，暂未看到<code>taro</code>和<code>kbone</code>公布此类数据。</p> \n<p>总体而言，开发交流维度比较结果如下：<code>uni-app</code> &gt; <code>taro</code> &gt; <code>kbone</code></p> \n<h2>其它指标</h2> \n<h3>github</h3> \n<table> \n <thead>\n  <tr> \n   <th>框架</th> \n   <th>star</th> \n   <th>贡献者</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>taro</td> \n   <td>24.6k</td> \n   <td>122</td> \n  </tr> \n  <tr> \n   <td>uni-app</td> \n   <td>19.7k</td> \n   <td>72</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>2.7k</td> \n   <td>7</td> \n  </tr> \n </tbody> \n</table> \n<p>在开源社区方面，<code>Taro</code>做的还是非常成功的，它吸引了更多开发者为其贡献代码、文档。</p> \n<h3>百度指数</h3> \n<p>通过<a>index.baidu.com</a>，可查看主流框架的搜索指数，它代表了网友的搜索量和相关文章的收录量。目前<code>kbone</code>尚未收录到百度指数中，如下是近期 <code>uni-app</code> 和 <code>taro</code>的百度指数对比图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326494\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>结语</h2> \n<p>所有的评测都只是提供决策依据，最后的结果还是要依赖开发者的团队技术栈、业务诉求、未来规划等。</p> \n<p>不过作为一篇评测文章的结语，我们还是要给出自己的建议：</p> \n<ul> \n <li>如果你熟悉React，不懂Vue.js，推荐Taro；</li> \n <li>如果你熟悉Vue.js，则推荐 uni-app；</li> \n <li>如果你已经有H5代码，只想增加微信小程序平台，并且对性能要求不高，可以考虑kbone；</li> \n <li>如果你的业务涉及多端，更推荐 uni-app；</li> \n <li>如果你希望通过 serverless 方案快速上线业务，推荐 uni-app。</li> \n</ul> \n<p>如有读者认为本文中任何评测失真，欢迎在这里报 <a href=\"https://github.com/dcloudio/test-framework/issues\" rel=\"nofollow noreferrer\">issuse</a>。</p>', 'https://segmentfault.com/img/remote/1460000022326485', null, null, '0', '0', null, '1', '2020-04-14 20:58:17', '2020-04-14 20:58:17');
INSERT INTO `tb_recommend` VALUES ('b2e37d14170743e9abe24b7f2772741d', 'NIO、BIO、AIO 与 PHP 实现', '最近看到NIO，AIO，Netty，Promise话题很热，我作为一个phper也想来凑凑热闹，凑着凑着发现周围怎么都是javaer，jser。那么PHP能做NIO，AIO么？', '<h2>前言</h2> \n<p>最近看到NIO，AIO，Netty，Promise话题很热，我作为一个phper也想来凑凑热闹，凑着凑着发现周围怎么都是javaer，jser。那么<code>PHP</code>能做<code>NIO</code>，<code>AIO</code>么？</p> \n<h2>什么BIO、NIO、AIO</h2> \n<p><code>BIO</code> 同步阻塞I/O。</p> \n<p>有小伙伴又要问了啥叫 <code>同步</code>，啥叫<code>阻塞</code>啊？</p> \n<h4>同步/异步 阻塞/非阻塞</h4> \n<p><strong>同步:</strong> 两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在<code>A-&gt;B</code>事件模型中，你需要先完成 A 才能执行B。 再换句话说，同步调用种被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</p> \n<p><strong>异步:</strong> 两个异步的任务完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用种一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情，</p> \n<p><strong>阻塞:</strong> 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</p> \n<p><strong>非阻塞:</strong> 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</p> \n<p>以上就是这四个词汇的解释，那么放到计算机IO上，比较接地气的解释</p> \n<h3>BIO （Blocking I/O)</h3> \n<p>那么我们拿快递揽件来举例，一个快递公司，有一部分工作是揽件，它的工作模式是只能一个一个的揽件，你要寄快递，必须排队，一个一个的来，这就是 <strong>同步</strong> 。好不容易轮到你了，你把快递一扔给他，他还让给你等着，快递工作人员说，我们这后面还有些信息要录入，快递要检查，必须等我们快递公司检查完毕后，你才能离开，这叫 <strong>阻塞</strong> 。</p> \n<h3>NIO （No-Blocking I/O）</h3> \n<p>同步非阻塞的I/O</p> \n<p>继续啊，拿快递公司举例。这个快递公司发现有些用户在后面排队，排着排着，太久了就去隔壁快递公司了，怎么办呢？快递公司想了个办法，置办了一个发号器和一批收纳盒。来一个客户，就把快递放在一个收纳盒里，再给用户一个编号，此时再来一个用户，不论前面一个的快递是否检查完毕，还是给他一个收纳盒，发一个编号。不同客户之间不排队，一来就被受理了，这就是 <strong>非阻塞</strong>。 我们再来看看内部，快递呢还是一个个地录入信息，X光检查，这样就是 <strong>同步</strong> 运行的，等待快递人员检查完毕叫号，客户拿到回执才能离开快递点。</p> \n<h3>AIO （Asynchronous I/O）</h3> \n<p>异步非阻塞IO</p> \n<p>也有Javaer叫他 NIO2，快递公司揽件又升级了，做了一个快递柜，客户又寄件需求，来了就放入快递柜，然后通过手机扫码关注这个柜子的动态，客户就可以离开了，此时服务被受理，并能马上离开。这就是 <strong>非阻塞</strong> 。等到快递人员来揽件时，会将柜子里面的寄件一并取走，快递点集中一起处理这些快递件，发现有问题的件，不是立即停下手中的活等待客户来出来，而是放一旁通知客户来，然后继续处理下一个快递，这就是 <strong>异步</strong>。</p> \n<h4>异步 阻塞 IO</h4> \n<p>同步/异步 阻塞/非阻塞，这4个名词，两两组和，还有一个就是 <code>异步/阻塞</code>。</p> \n<p>那么我们还是先把例子举出来吧，还是这个快递点，来了一批客户来寄口罩到国外，由于有很大的可能会通不过检查，所以，快递点把大家都留了下来。等所有的 寄件 都检查完了在统一给大家发送回执单，这就是 <strong>阻塞</strong> 。快递人员检查寄件时，发现问题不是立马通知客户来处理，而已放到一边，继续处理下一个。 这就是 <strong>异步</strong>。</p> \n<h4>伪异步 IO</h4> \n<p>这种模式，底层实现是多个 <code>同步阻塞的BIO</code>， 同时运行。</p> \n<p>最后总结一下：</p> \n<blockquote>\n 阻塞与非阻塞指的的是当不能进行读写（网卡满时的写/网卡空的时候的读）的时候， I/ O操作立即返回还是阻塞；同步异步指的是，当数据已经 ready的时候，读写操作是同步读还是异步读，阶段不同而已。\n</blockquote> \n<h3>区别</h3> \n<h4>异步/同步在计算机区别</h4> \n<p>以上是一些举例，只是帮助大家理解记忆，接下来我们看看计算上的实现。</p> \n<p>计算机提供的Web服务，刚开始的 <code>CGI</code> 模式，就是纯正的 <code>BIO</code> 模式。一个<code>cgi</code>进程监听一个端口，处理完一个请求，才能接收下一个http请求。这就是<code>同步</code></p> \n<blockquote>\n 实际使用体验式异步的，那是因为后来优化了，\n <code>CGI</code>能够自我fork进程的达到同时响应多个\n <code>http</code>请求的效果。\n</blockquote> \n<p>注意，我们这里讨论的基础是 <strong>单进程</strong> ，上的 <code>异步/同步</code>。</p> \n<h4>阻塞/非阻塞在计算机区别</h4> \n<p>这里拿购物流程举例，用户的下单，需要做如下操作：</p> \n<ul> \n <li>商品可售否</li> \n <li>库存数量</li> \n <li>用户余额</li> \n <li>触发哪些优惠规则</li> \n <li>奖券有效性众</li> \n</ul> \n<p>按照一般做法就是一步步验证，上一个检查完成再进行下一个检查，这就是 <strong>阻塞</strong> 的方式。</p> \n<p>那么非阻塞方式如何做呢，假设在微服务环境中，商品，库存，奖券，促销都是独立的系统，调用商品服务，发起商品可售检查请求；不等商品服务回复，继续调用库存服务，发起商品可售库存请求；紧接着依次发出...检查请求，这样5个检查项目同时发起，最后，我等他们所有的请求都回复我，再来校验是否所有的检查都通过了。就这种发起请求不等响应，就继续做下一件事的叫 <strong>非阻塞</strong> 。</p> \n<p>转载著名<a href=\"https://segmentfault.com/a/1190000022356197\">来源sifou</a></p> \n<h2>PHP 能做什么</h2> \n<h3>PHP 与 BIO 实现</h3> \n<p>PHP已经实现啦，这是最基本的好么。但我们平时测试时却感觉是不阻塞啊，你可以试试吧nginx和php-fpm的进程限制为1个试试。其实php-fpm就是 多进程的BIO。</p> \n<ul>\n <li>调整Nginx配置</li>\n</ul> \n<p>调整 <code>/etc/nginx/nginx.conf</code> 文件:</p> \n<pre><code class=\"shell\">## 把nginx worker数量设置为1\nworker_processes 1;</code></pre> \n<p>好了之后我们通过ps命令检查下<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFnUN\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<ul>\n <li>调整PHP配置</li>\n</ul> \n<p>调整 <code>/etc/php/php-fpm/conf.d/www.conf</code> 文件：</p> \n<pre><code class=\"shell\">pm = static\n\npm.max_children = 1\n\npm.start_servers = 1\n\npm.min_spare_servers = 1\n\npm.max_spare_servers = 1</code></pre> \n<p>找到这几个配置都改为如上数值。</p> \n<p>最后的结果如下</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFnVm\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>我在<code>index.php</code>代码里面加入第一行就加入了sleep。</p> \n<pre><code class=\"php\">&lt;?php\nsleep(5);</code></pre> \n<p>我们同时打开两个网页，一起访问试试<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFnW4\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>通过Firefox 抓包可以发现，其中一个耗时5s，另一个页面耗时9.3s，<em>（0.7s误差是我手速慢了）</em> 这就是 BIO。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFnX2\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>好的，我们在做一个实验。把以上nginx，php-fpm配置中<code>1</code>改成<code>2</code>.然后我们打开<code>三个网</code>页，<code>同时访问</code>试试看。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFnZH\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>结果是有<code>两个网页耗时5s</code>，<code>一个是9s</code>，也就是说服务器同时处理了2个请求，第三个请求等待了4s才被处理。这就是 多线程-BIO，一个服务同时接待的客户数量取决与worker的数量。</p> \n<h3>PHP 与 NIO 实现</h3> \n<p>我们写的大部分php-fpm代码都是非阻塞的。其实PHP是支持<code>非阻塞</code>IO编程的。</p> \n<p>我们来看看PHP原生代码实现NIO编程： <a href=\"https://segmentfault.com/a/1190000015365056#item-6\">PHP回顾之socket编程</a>。这段代码为了实现并发使用了<code>stream_select()</code>。</p> \n<h3>I/O 多路复用</h3> \n<p>这里，PHP 实现 NIO 核心就是 stream_select()<br>通过以上源码，发现原生的NIO实现还是比较繁琐，不易读的。那么 NIO 就是为了实现一个socket server么，我们来看看<a href=\"https://netty.io/\" rel=\"nofollow noreferrer\">Netty 官网</a>。打开Netty首页，它是这样描述自己的</p> \n<blockquote>\n Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server.\n</blockquote> \n<p>第一句话：Netty是一个 <code>NIO 客户端</code> 服务框架, 能快速轻松地开发协程<code>客户端</code>。第二句话：简化了网络编程，如创建TCP和UDP套接字服务。</p> \n<p>好，重点是什么？第一句话就是重点——开发 协程<code>客户端</code>！回到我们业务上，刚刚举了一个例子，购物到下单，有很多个流程需要做检查，按照一般的BIO那么程序时序图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFFlf\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"nio购物流程检查\" title=\"nio购物流程检查\"></span></p> \n<p>从上可以看到，三个检查依次分开执行。那么客户的等待时间是大于，库存检查时间加上，产品检查时间加上，促销检查时间 的。</p> \n<p>假设, 库存，产品，促销是三个微服务，然后购物车服务用 <code>NIO客户端</code>，与这三个微服务交互，那么会是怎样的效果呢：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFFna\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"nio请求时序图\" title=\"nio请求时序图\"></span></p> \n<p>这里，我们发起检查请求时，是按照顺序发起的，但不等第一个服务返回检查结果就开始发起下一个检查请求。最后三个服务都返回后，综合结果，返回给用户。那么这三个检查的耗时，就等于一个服务（耗时最长的那个服务）的检查耗时。大大减少得了购物车服务响应时间。</p> \n<h3>NIO 客户端</h3> \n<p>看到以上两个时序图，还是给大家演示一下用PHP原生代码实现一个 <code>PHP-BIO</code> 。 <a href=\"https://gitee.com/xupaul/php-nio-server\" rel=\"nofollow noreferrer\">PHP Simple NIO Server</a></p> \n<blockquote>\n 建议大家点击链接，把源码\n <code>git clone https://gitee.com/xupaul/php-nio-server</code> 到本地运行一下，再来看截图更容易理解。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFMRS\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<blockquote>\n 这三个所依赖的服务响应耗时，我设置为：inventory: 4s, product: 2s, promo:6s\n</blockquote> \n<p>蓝色框和黄色框标注了两个请求，我们主要看参数 <code>noBlocking： true/false</code> 的不同, 第一个是非阻塞方式请求， 可以看到共耗时6s，第二个共耗时12s！ <em>（第三个为啥和第二个耗时不一样——6s这个留给大家去研究）</em>。显而易见得非阻塞IO的优势。不过这代码结构就不那么友好了，看到代码 nio_server.php 中，有两种请求方式，阻塞代码流程还能看懂检查完成后就综合结果返回，而非阻塞方式中，发起三个检查后程序流程就开始进入到<code>handleMessage</code>，代码进入哪个分支，取决于 <code>socket_read</code> 的消息，不运行起程序来，没有文档，很难搞懂整个程序流程。</p> \n<p>那么，有没有什么什么方便的php类库，让我们编码更友好一点呢，这里介绍下 <a href=\"https://reactphp.org/\" rel=\"nofollow noreferrer\">ReactPHP</a> </p> \n<p>这里我用ReactPHP重新实现 <code>nio_server</code>, 代码在<a href=\"https://gitee.com/xupaul/php-nio-server/blob/master/react-php-demo/react_nio_server.php\" rel=\"nofollow noreferrer\">这里</a></p> \n<blockquote>\n 这个回调代码写起来有点 \n <code>NodeJS</code> 的味道呢，当你的PHP没启用 libev 之类的拓展时，\n <code>ReactPHP</code>内部Loop依然用的 \n <code>stream_select()</code>, 可以看代码 \n <code>~/react/event-loop/src/StreamSelectLoop.php@290</code> .\n</blockquote> \n<p>执行效果如下：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFN9K\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>这个同时发起请求这个业务逻辑，就还得提一下 <code>curl_multi</code>， 它能同时发起多个<code>curl</code>请求，最后不断检查是否所有的curl请求已完成。这只是在发起多个<code>curl</code>请求阶段做到 <code>非阻塞</code> 运行。</p> \n<p>还有个拓展<a href=\"https://www.php.net/manual/zh/book.pthreads.php\" rel=\"nofollow noreferrer\">pThreads</a>，能够实现多线程，不过对PHP编译参数有限制，需要在线程安全的模式下运行。</p> \n<blockquote>\n pThreads 现在已不是PHP官方所推荐使用的拓展了，当然了这种就属于\n <code>伪异步IO</code>范畴了\n</blockquote> \n<h3>PHP 与 AIO</h3> \n<p><code>PHP</code> <code>异步&amp;非阻塞</code> 编码。</p> \n<p>此处， 非阻塞I/O 系统调用( nonblocking system call ) 和 <strong>异步I/O系统调用 （asychronous system call）</strong>的区别是：</p> \n<ul> \n <li>一个非阻塞I/O 系统调用 <code>read()</code> 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。</li> \n <li>而异步I/O系统调用 <code>read()</code> 结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。</li> \n</ul> \n<pre><code class=\"php\">&lt;?php\n\n/**\n * 消息处理\n */\nfunction handleMessage() {\n    global $changed, $clients, $cartCheck;\n    foreach ($changed as $key =&gt; $client) {\n        while (true) {\n            // read socket data\n            $msg = @fread($client, 1024);\n//            $msg = 1;\n            if ($msg) {\n                // application process\n            } else {\n                if (feof($client)) {\n                    // TODO check data eof\n                }\n                break;\n            }</code></pre> \n<p>可以看到，在文件<a href=\"https://gitee.com/xupaul/php-nio-server/blob/master/cart-server-demo/nio_server.php\" rel=\"nofollow noreferrer\"><code>~/nio_server.php</code></a> 中， 虽然设置了 <code>stream_set_blocking false</code>， 但是在209行的 <code>fread()</code> , 这是在一个循环里读，这是一个阻塞读取。这的系统函数的响应速度是受系统IO影响的。</p> \n<p>而异步调用中，当有<code>I/O事件</code>时，系统会将数据复制到用户内存中，也就是准备好数据，再通知到用户程序。</p> \n<p>那么原生PHP显然是不支持的，这里呢就要引入PHP拓展，就是 <a href=\"https://www.php.net/manual/zh/book.event.php\" rel=\"nofollow noreferrer\"><code>Event</code></a>，或者 <a href=\"https://www.php.net/manual/zh/book.ev.php\" rel=\"nofollow noreferrer\"><code>Ev</code></a> 拓展。这篇博客主要讲 <code>Event</code>。</p> \n<blockquote> \n <code>Event</code> 拓展是基于 \n <a href=\"https://libevent.org/\" rel=\"nofollow noreferrer\"><code>libevent</code></a> 库封装而来，而 \n <code>Ev</code> 拓展是基于 \n <a href=\"http://software.schmorp.de/pkg/libev\" rel=\"nofollow noreferrer\"><code>libev</code></a> 库封装而来。 通过PHP接口，和C库的接口就能看到他们之间的联系，所以，如果通过PHP文档找不到相关资料可以去，看看C库的文档。\n</blockquote> \n<p>这里放上用<code>Event</code>实现的<code>Tcp Server</code> <a href=\"https://gitee.com/xupaul/php-nio-server/blob/master/event-php-demo/event_buffer_socket_server.php\" rel=\"nofollow noreferrer\">demo</a></p> \n<p>在用<code>Event</code>做这个<code>demo</code>中，我用到了<code>EventBuffer</code> ，读、写都和<code>Buffer</code>交互, <code>Buffer</code>数据是用户态数据，不会等待系统I/O或被阻塞，避免了程序耗时在I/O数据拷贝上。由此PHP 也能实现 <code>AIO</code> 程式，提高CPU利用率。</p> \n<p>讲到这里，就会感觉这个PHP的<code>AIO</code>有些牵强了，我这找了其他博主的论点来帮助大家理解，先放两张图。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFW7f\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>上面是<code>非阻塞IO</code>，下面是<code>异步IO</code>。中间的区别就是<code>非阻塞IO</code>的应用，需要不断的去访问内核获取数据（当然了，每一次访问都是有求必应，能取到数据），但不一定能取完; 而<code>异步IO</code>的特点就是，你告诉内核取数据，取完整了，我再一起发给应用程序。这就是Linux对<code>异步IO</code>的定义。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFW7c\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>那么再看到我们的Demo，这是一个简单TCP server，一个TCP请求系统是能知道一个数据的包大小的，是否接收完毕，这是传输层要做的。而我们的应用层面，是接收到数据还要做合并，分包，以及数据转码。 这就和 <strong><code>AIO</code> 数据结果必须是完整的</strong>，概率有些出入，（在系统层面显然是完整的） . 在应用层面呢，一次性收到的不一定是完整的数据，那么就还需要做额外代码来解决合包，分包，沾包。这就是<code>AIO</code>实现<code>Tcp Server</code>的需要问题。</p> \n<blockquote>\n 为了解决以上问题，就需要自定义TCP通讯协议。相当于自己开发RPC框架了。\n</blockquote> \n<p>那我们来看看Http呢，在应用层面有明确公开的协议(协议有头无尾，标明了每次请求具体长度)，并有丰富的实现。这就是一个非常适合采用<code>AIO</code>编程协议。而PHP的<code>Event</code>拓展，恰好有<a href=\"https://www.php.net/manual/zh/class.eventhttp.php\" rel=\"nofollow noreferrer\"><code>EventHttp</code></a>实现。</p> \n<p>话不多说，先上 <a href=\"https://gitee.com/xupaul/php-nio-server/blob/master/event-php-demo/event_http_server.php\" rel=\"nofollow noreferrer\"><code>Demo</code></a>。</p> \n<pre><code class=\"php\">&lt;?php\n...\n\n/**\n * event http 请求回调函数\n * \n * @param   \\EventHttpRequest   $req    Http请求对象\n */\nfunction _http_about($req) {\n    echo __METHOD__, PHP_EOL;\n    // print request URL\n    echo \"URI: \", $req-&gt;getUri(), PHP_EOL;\n    // print request\'s headers\n    echo \"Input headers:\"; var_dump($req-&gt;getInputHeaders());\n    echo \"\\n &gt;&gt; Sending reply ...\";\n    /**\n     * @var \\EventBuffer    $buf\n     */\n    $buf = $req-&gt;getOutputBuffer();\n    $buf-&gt;add(\"It\'s about Event http server\");\n    $req-&gt;sendReply(200, \"OK\", $buf);\n    echo \"OK\\n\";\n}</code></pre> \n<p>这里是一个回调函数，入参数就是一个由 <code>EventHttp</code> 封装的http请求对象。这就满足了以上 调用时非阻塞，数据完全准备好后，再通知回调——<strong>异步I/O</strong>。好，借助<code>Event</code>，PHP就实现了<code>AIO</code>.</p> \n<h2>结语</h2> \n<p>关于性能提升，这就不做压测了，主要论证PHP实现<code>NIO</code>、<code>AIO</code> 的可行性。也实际给大家展示了几个<code>Demo</code>, 简单展示了如何写<code>异步</code>,<code>非阻塞</code>程序。</p> \n<p>以上，希望大家通过文章能了解 <code>异步/同步</code>、<code>阻塞/非阻塞</code>区别，以及对PHP<code>异步</code>、<code>非阻塞</code>编程。</p> \n<p>有问题欢迎提问～</p> \n<h2>参考</h2> \n<ol> \n <li><a href=\"https://blog.csdn.net/linvo/article/details/5466046\" rel=\"nofollow noreferrer\">PHP实现非阻塞</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000015365056\">PHP回顾之socket编程</a></li> \n <li><a href=\"http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html\" rel=\"nofollow noreferrer\">Cooperative multitasking using coroutines (in PHP!)</a></li> \n <li><a href=\"https://blog.csdn.net/historyasamirror/article/details/5778378\" rel=\"nofollow noreferrer\">IO - 同步，异步，阻塞，非阻塞</a></li> \n <li><a href=\"https://blog.csdn.net/lengxiao1993/article/details/78154467\" rel=\"nofollow noreferrer\">同步/异步，阻塞/非阻塞概念深度解析</a></li> \n <li><a href=\"https://www.cnblogs.com/52fhy/p/9258040.html\" rel=\"nofollow noreferrer\">PHP之高性能I/O框架：Libevent</a></li> \n <li><a href=\"https://zhuanlan.zhihu.com/p/20315482\" rel=\"nofollow noreferrer\">网络编程（三）：从libevent到事件通知机制</a></li> \n</ol>', 'https://segmentfault.com/img/bVbFnUN', null, null, '0', '0', null, '1', '2020-04-14 20:58:14', '2020-04-14 20:58:14');
INSERT INTO `tb_recommend` VALUES ('c30c55e06899497992d7c476b8e2e616', 'iOS SpringBoard tweak插件，双击图标快速启动debugserver', 'debugserver+lldb很好用，但启动起来太麻烦？我们开发了一款iOS SpringBoard tweak小插件，简化debugserver启动过程。老铁，请双击！', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326917\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>debugserver+lldb很好用，但启动起来太麻烦？我们开发了一款iOS SpringBoard tweak小插件，简化debugserver启动过程。老铁，请双击！</p> \n<h2>0x00 懒是第一生产力</h2> \n<p>我们经常要通过debugserver对App进行调试，有<a href=\"https://book.douban.com/subject/25826902/\" rel=\"nofollow noreferrer\">书籍</a>和<a href=\"http://bbs.iosre.com/t/debugserver-lldb-gdb/65\" rel=\"nofollow noreferrer\">论坛</a>对相关的技术和实践进行了说明，但实际应用起来还是有些麻烦。先要重签拷贝，再要启动终端ssh到iPhone启动debugserver，各种ls加grep找到想调试的应用，敲命令启动debugserver，然后Mac本地终端启动lldb。这样折腾下来，至少要开两个终端，有的时候甚至更多。GitHub上有个<a href=\"https://github.com/4ch12dy/issh\" rel=\"nofollow noreferrer\">issh工具</a>对上述操作有封装和优化，但是还是需要敲命令找App，再运行debugserver。</p> \n<p>所以做个tweak提升一下生产力。只需<strong>双击应用图标，即可一键启动debugserver</strong>。</p> \n<p><strong>代码见：Github</strong></p> \n<p><em><a href=\"https://github.com/TalkingData/tap2debug\" rel=\"nofollow noreferrer\">https://github.com/TalkingDat...</a></em></p> \n<p><strong>运行界面</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326916\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>我们所用的开发环境是iOS 13.3，但是并没有用到特殊版本的API，低版本手机应该也OK。</p> \n<p>下面简单分享开发过程：</p> \n<h2>0x01 通过图标找到应用执行路径</h2> \n<p>从界面找逻辑，逆向发现SpringBoard的图标是<strong>SBIconView</strong>。并且有一个叫属性 <strong>applicationBundleIdentifierForShortcuts</strong> 返回的是图标对应的App的Bundle ID。通过Bundle ID构造<strong>LSApplicationProxy</strong>对象，并且获得<strong>canonicalExecutablePath</strong>属性，也就是应用的可执行文件路径。</p> \n<pre><code>Class LSApplicationProxy_class = objc_getClass(\"LSApplicationProxy\");NSObject* proxyObj = [LSApplicationProxy_class performSelector:@selector(applicationProxyForIdentifier:) withObject:bundle];NSString * canonicalExecutablePath = [proxyObj performSelector:@selector(canonicalExecutablePath)];复制代码</code></pre> \n<h2>0x02 寻找注入点添加扩展</h2> \n<p>接续看<strong>SBIconView</strong>，图标上有两个手势对象：</p> \n<ul> \n <li>单击，用来启动App。</li> \n <li>长按，进入编辑状态，执行删除和排列图标等操作。</li> \n</ul> \n<p>所以，我们来给图标交互加个双击扩展。</p> \n<p>%hook SBIconView</p> \n<pre><code>- (void)didMoveToWindow{    %orig;    UITapGestureRecognizer *doubleTap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(handleDoubleClick:)];    [doubleTap setNumberOfTapsRequired:2];    [self addGestureRecognizer:doubleTap];    NSArray * ges = self.gestureRecognizers;    for(UITapGestureRecognizer * each in ges){        if([each isKindOfClass:[UITapGestureRecognizer class]]){            [each requireGestureRecognizerToFail: doubleTap];        }    }}复制代码</code></pre> \n<p>这里额外说一句，[each requireGestureRecognizerToFail: doubleTap]添加了双击手势指挥，由于iOS内部维护了手势的状态机，我们进行单击操作的时候，其实产生了两种Possible State。第一种是识别为单击，然后结束。第二种是识别为双击的第一下并等待第二下的发生，然后根据两次点击之时间间隔阈值来判断是不是合法的双击。</p> \n<p>所以我们手动增加了约束，相当于指定了识别的优先级，只有双击失败了，才继续执行单击回调。这种操作会带来一点几乎无感的瑕疵：单击后等待双击识别失败的延迟，延迟的值就是双击识别执行的阈值（大约零点几秒）。</p> \n<h2>0x03 debugserver启动和关闭</h2> \n<p>debugserver是一个二进制文件，狗神的教程里有如何重签，issh把这些过程给简化了。先看一下debugserver的权限： <br><strong>-rwxr-xr-x 1 root admin 9876848 Jan 19 11:28 /iOSRE/tools/debugserver*</strong></p> \n<p>再来看一下SpringBoard的权限: <br><strong>-rwxr-xr-x 1 root wheel 71264 Dec 5 13:15 SpringBoard*</strong></p> \n<p>属主用户都是root，没毛病。找个函数调用一下：</p> \n<ol> \n <li>system函数</li> \n <li>posix_spawn函数</li> \n <li>NSTask ，面向对象方便管理，异步执行，不会block UI，就用它了。</li> \n</ol> \n<p>代码如下：</p> \n<pre><code>task = [[NSTask alloc]init];[task setLaunchPath:bin_serverpath];[task setArguments:args];[task launch];复制代码</code></pre> \n<p>每次server在launch之前，要把之前的task结束掉。</p> \n<pre><code>- (void)interrupt; // Not always possible. Sends SIGINT.复制代码</code></pre> \n<pre><code>- (void)terminate; // Not always possible. Sends SIGTERM.复制代码</code></pre> \n<p><strong>NSTask</strong>头文件里竟然告诉我 <strong>Not always possible</strong>。事实上，在调用的时候，还真的不怎么possible，实际测试第一次server正常启动，后续由于没成功关闭，所以第二次就没法启动了。</p> \n<p>所以还是换种方式关闭吧。简单粗暴的 kill 函数：</p> \n<pre><code>NSTask * task = [TaskManager sharedManager].runningTask;if(task){    kill(task.processIdentifier,SIGKILL);    task = nil;}复制代码</code></pre> \n<h2>0x04 添加UI交互</h2> \n<p>直接用Alert，又有按钮又有输入框，不过UIAlertView已经被废弃掉了，需要用UIAlertController。由于弹出Controller需要父Controller，通过View找到当前的Controller，做正向的应该都写过这段代码吧：</p> \n<pre><code>@implementation UIView(find)-(UIViewController*)findViewController{    UIResponder* target= self;    while (target) {        target = target.nextResponder;        if ([target isKindOfClass:[UIViewController class]]) {            break;        }    }    return (UIViewController*)target;}@end复制代码</code></pre> \n<h2>0x05 优化一下用户体验</h2> \n<p>输入框里的IP和debugserver的path，每个人都不一样，所以在第一次输入完成之后，把这些值用NSUserDefault持久化存储起来，下次直接读取填充。</p> \n<h2>0x06后记</h2> \n<p>之前在相关技术论坛读到讨论用Root身份运行App的帖子，学习完帖子里的技巧，增强对操作系统的理解以及实践之后，发现如果真的想RootApp运行，其实SpringBoard本身就是一个RootApp，我们把SpringBoard当做RootViewController，很容易把一些系统工具做出界面，从而提升生产力。比如砸壳、重签、拷贝App等。</p> \n<p>**<br>作者：TalkingData小张同学</p> \n<p>本文版权归TalkingData所有，如需转载请注明来源**</p>', 'https://segmentfault.com/img/remote/1460000022326917', null, null, '0', '0', null, '1', '2020-04-14 20:58:16', '2020-04-14 20:58:16');
INSERT INTO `tb_recommend` VALUES ('c3a1d7e383934c69952aba38cea84fff', 'GNU Guix 将终止对 Linux 内核的支持，全面替换为 GNU Hurd', 'GNU Guix 项目官方近日宣布，正在用 GNU Hurd 替换其 Linux（确切地说是GNU Linux-libre）内核，Guix 1.1 将是最后一个支持 Linux 的版本。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFHty\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>GNU Guix 项目官方近日宣布，正在用 GNU Hurd 替换其 Linux（确切地说是GNU Linux-libre）内核，Guix 1.1 将是最后一个支持 Linux 的版本。</p> \n<p>而到了 Guix 2.0，他们可能会完全删除 Linux 内核，但仍然允许“外国”发行版尽最大努力支持它。</p> \n<p>他们希望 GNU Hurd 可以“为用户增加安全性和自由度”。尽管 GNU Hurd 仍然不能在当今的许多硬件上运行，更不用说支持其他较新的硬件功能和设备。</p> \n<p>基本上，现阶段的 GNU Hurd 可以为基本的虚拟机加速，但除此之外并不太实用。</p> \n<h2>GNU Guix</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFHtA\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>GNU Guix 是一个事务包管理器，是 GNU 系统的高级发行版，它尊重用户的自由。如前文所说，Guix 可以在运行 Hurd 或 Linux 内核的任何系统上使用，也可以用作 i686，x86_64，ARMv7 和 AArch64 机器的独立操作系统发行版。</p> \n<p>除了标准的软件包管理功能之外，Guix 还支持事务性升级和回滚，无特权的软件包管理，每用户配置文件以及垃圾回收。当用作独立的 GNU / Linux 发行版时，Guix 为操作系统配置管理提供了一种声明式，无状态的方法。通过 Guile 编程接口和 Scheme 语言的扩展，Guix 具有高度可定制性和可破解性。</p> \n<h2>GNU Hurd</h2> \n<p>GNU Hurd 是一套操作系统內核，以微內核架构设计。Hurd 是 GNU 操作系统的核心部分。GNU 项目从 1990 年开始开发 GNU Hurd，并且将它作为一个遵循 GPL 的自由软件发布。Hurd 的目标是从功能、安全性和稳定性上全面超越传统 Unix 內核，而同时又能保持对其的兼容性，为此 Hurd 遵守 POSIX 标准。</p> \n<p>「Hurd」是一个间接递归缩写，来自“HIRD of Unix Replacing Daemons”，其中“HIRD”表示“HURD of Interfaces Representing Depth”。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyLB\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFHty', null, null, '0', '0', null, '1', '2020-04-14 20:58:21', '2020-04-14 20:58:21');
INSERT INTO `tb_recommend` VALUES ('c827daf7957e41a090bc5a50f114502b', '互联网通信云 PaaS 选型 开发者必备指南', '几乎所有技术团队都经历过服务选型问题，在最常见的 3 大云服务交付模式（IaaS、PaaS、SaaS）中，PaaS 是目前市场上增速最快的交付模式，选型过程也是最令开发者头疼的。而相同问题往往不止一种解决方案，如何才...', '<p>几乎所有技术团队都经历过服务选型问题，在最常见的 3 大云服务交付模式（IaaS、PaaS、SaaS）中，PaaS 是目前市场上增速最快的交付模式，选型过程也是最令开发者头疼的。而相同问题往往不止一种解决方案，如何才能正确选择，少趟坑，是件烧脑的事情。那么我们究竟该如何做出正确的选择？下面就以 PaaS 层的互联网通信云服务为例，借助几个具有通用性的角度来告诉大家如何避坑。</p> \n<p><strong>一：功能的灵活性和易用性</strong></p> \n<p>互联网通信云服务通常是将 IM 和实时音视频技术封装成 SDK/API 交付给开发者使用，在 App 功能的开发中占据了非常重要的地位，特别是对于社交、直播等行业而言，通信能力就是命脉。如果选择了不适合或不能满足自己业务场景的功能，初期由于业务复杂程度和业务量都比较小，可能问题不会十分明显，但是到了后期这可能成为一个噩梦，会导致系统问题频发，极不稳定，甚至导致项目迭代举步维艰，有的团队会停止新功能的开发，专门修复 bug，给业务造成重大的经济损失。</p> \n<p>因此，寻找能够满足适合自身业务场景的产品，能够灵活地进行二次开发，同时支持多平台和开发语言，是开发者前期调研中需要考虑的首要问题。通常意义上来讲，SDK 接口的数量在一定程度上代表了可实现功能量级的多寡，SDK 接口越多，开发者在功能实现上就有更多的选择空间，可以根据不同接口的组合来打造符合自身产品思路的功能。</p> \n<p>但同时也要看到，有的服务商不断增加 SDK 接口数量，但这并不代表越多就一定越好，有可能让新接触的开发者越发混乱，无从选择。所以有些厂商直接将符合某一业务场景需求的十几个或几十个 SDK 接口，打包成一个解决方案供开发者使用，这样不仅避免了开发集成的复杂度，还提高了功能的易用性。</p> \n<p>此外，SDK 的体积也是一个需要注意的点，过大的 SDK 会造成最终 App 体积也随之变大，这对于用户的下载体验非常糟糕，需要避免。</p> \n<p><strong>二：开发工具的完备性</strong></p> \n<p>灵活的功能性确保了项目开发从一开始就能够走在正确的道路上。接下来要考虑的是真正进入项目实施阶段，开发工具的完备性。开发工具既包括开发文档、SDK 注释等基础性文档，也包括 Demo、视频教程等多种支持性工具。</p> \n<p>开发者在写代码的时候是很不喜欢被打断的，特别是一些基础性的开发问题，比如怎么创建 ID，怎么创建群组，有文档之后直接扔 URL 链接就行了。因此，一个易读易懂的技术开发文档将有助于 Coding 事半功倍。一个好的开发文档至少要做到结构简单、逻辑清晰。</p> \n<p>所谓结构简单就是用户能马上找到自己要查找的知识点在哪，分类清晰。有些文档爱用模棱两可的词，比如“1.常见问题”，“2.热点问题”，一旦开发中遇到了问题，无法快捷查找答案，所以就需要将具体问题合理归类。另一点是逻辑清晰，这样可以让开发者减少对业务和交互的思考，更专注于技术的逻辑与实现。</p> \n<p>除了开发文档外，SDK 注释是一种更简便的文档说明方式。不需要开发者翻阅大量的技术文档，通过完美的注释，直接在代码上就可以方便了解 SDK 功能。此外，还有 Demo 产品和视频教程等支持性工具，辅助开发者更好地理解和应用开发，避免不停的试错后才完成开发。</p> \n<p><strong>三：抗弱网环境和 QPS 承载能力的稳定性</strong></p> \n<p>产品稳定性至关重要，直接关乎用户体验。在地铁、电梯等相对密闭的弱网环境，常常面临信号不畅，App 稳定性失常、无法使用的问题。因此，开发者需要考虑的是，如果遭遇弱网环境，能不能在系统运行中通过最优算法实施智能调度，择优选择最佳链路进行用户无感知切换。</p> \n<p>在平时业务压力不大的情况下，系统看似运行的很平稳了，但是当遇到双十一、大型直播、春晚等特殊事件，瞬时的激增流量有可能直接导致系统瞬间崩塌，那么，开发者在一开始选择的时候，就需要考量 QPS 承载能力，要求服务商必须有应对高并发的能力。此外，还要考核消息到达率和准确率，一些 App 中，消息“半路失踪”，漏发、错序的事件时有发生，这些大概率都因为架构设计存在缺陷，是 App 使用者所无法容忍的。</p> \n<p>要规避上面的这些坑，需要有良好的系统架构做支撑。如果，开发者因为产品上线前的经验不足，导致产品在研发架构，或者风险漏洞方面存在隐患时，我们最好选择能够全程提供业务方案咨询和技术方案咨询服务的厂商，以他们的最佳实践帮助我们做出最优方案，在 App 上线前即规避可能存在的风险。</p> \n<p><strong>四：全球化能力</strong></p> \n<p>业务前景和技术前景也是开发人员应优先考虑的因素。比如初创企业优先布局在国内，但未来发展也许会出海，那么所选择的服务商就必须具备全球化服务能力。</p> \n<p>想要拥有稳定的全球通信能力，不仅要有基础 IaaS 架构的支持，还要有海外数据中心、多路动态节点及稳定的全球链路做支撑，才可以有效解决跨国、跨运营商、大规模用户访问导致的响应慢、丢包高、服务不稳定等诸多痛点。</p> \n<p>还有些服务商构建了私有加密协议的全球通信加速网络，针对性的进行全球链路优化，这对开发者来说，通信安全性和质量稳定性便有了双重保障。</p> \n<p><strong>五：服务</strong></p> \n<p>目前，绝大多数厂商都能给开发者提供便利的服务，以满足产品开发、上线前后以及产品运营阶段的各种需求。但也有极少数的厂商只提供 SDK 技术及开发文档，而后续无任何服务支持，这对开发者而言，当然不是一个好的选择。</p> \n<p>虽然，知名度高一点的通信云服务商都提供 7*24 小时的运维保障服务，但仍有服务意识的强弱之分。以客服工单为例，业界平均工单回复时间为 4-6 小时，而优质的服务商则可以做到 1 小时内回复。</p> \n<p>产品上线后，如果有自动故障排除工具类的服务支持，可以帮助开发者极大节省与厂商之间的沟通成本。除了这些工具类服务外，人的服务也是必备保障之一。比如，有的服务商从项目开发之前，便配备 CTO 或首席架构师级别的顶级技术团队进行全方位答疑，帮忙开发选择适合场景的技术架构和解决方案。还有的服务商，在项目上线运营时，针对可能出现的突发流量状态，通过人工方式帮开发者制定相应的保障方案，动态调整服务器部署，这样就可以有效地帮助开发者顺利避开“坑”点。</p> \n<p><strong>选型填“坑”后，最优性价比的胜出</strong></p> \n<p>价格将是选型过程中“最后的试金石”。通常来讲，选择好的技术和服务，意味着选择更多的成本投入，而在当下的复工复产期间，行业回暧需要过程，节省开支就成了企业发展中的头等大事，选型者往往因为价格因素，不得不退而求其次。</p> \n<p>对于正处于选型当口的企业和开发者而言，好消息来了。互联网通信云行业的领导者融云针对全体开发者推出了“199 元 IM 商用版首购限量开放”活动，充值优惠有效期为 2020 年 5 月 1 至 12 月 31 日。这是融云自成立以来，推出的优惠幅度最大的一次活动，特别一提的是，由于疫情期间，受 IaaS 层带宽资源成本均有提升等多重因素影响，加之确保最后一公里通信的稳定、可靠、安全，绝不降品质的执着，融云为此承担了巨大的成本负担。但是，活动仍然不惜打破成本底线，以最大优惠让利于开发者，誓为全行业复工“输血”。也是因为以上原因，本次活动限量名额 1000 个，额满即止。</p> \n<p>【 <a href=\"http://rong.io/B1Off\" rel=\"nofollow noreferrer\"><strong>点此了解更多活动详情！</strong></a>】</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFGJz\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"思否199海报.png\" title=\"思否199海报.png\"></span></p> \n<p><strong>结语</strong></p> \n<p>总体说来，互联网通信云 PaaS 平台越来越成熟的技术能力为开发者提供了极大便利。作为技术选型，开发者根据自己的业务需求和行业特性，通过对通信云厂商在技术、服务、全球化方面的全面考量，再结合价格进行综合判断，答案自然水落石出。</p>', 'https://segmentfault.com/img/bVbFGJz', null, null, '0', '0', null, '1', '2020-04-14 20:58:17', '2020-04-14 20:58:17');
INSERT INTO `tb_recommend` VALUES ('dc9f8795cb124b31a57cd7a129c01ab5', 'Flutter异常监测与上报', '众所周知，软件项目的交付是一个复杂的过程，任何原因都有可能导致交付的失败。很多时候经常遇到的一个现象是，应用在开发测试时没有任何异常，但一旦上线就问题频出。出现这些异常，可能是因为不充分的机型适配...', '<h1>Flutter异常</h1> \n<p>众所周知，软件项目的交付是一个复杂的过程，任何原因都有可能导致交付的失败。很多时候经常遇到的一个现象是，应用在开发测试时没有任何异常，但一旦上线就问题频出。出现这些异常，可能是因为不充分的机型适配或者用户糟糕的网络状况造成的，也可能是Flutter框架自身缺陷造成的，甚至是操作系统底层的问题。</p> \n<p>而处理此类异常的最佳方式是捕获用户的异常信息，将异常现场保存起来并上传至服务器，然后通过分析异常上下文来定位引起异常的原因，并最终解决此类问题。</p> \n<p>所谓Flutter异常，指的是Flutter程序中Dart代码运行时发生的错误。与Java和OC等多线程模型的编程语言不同，Dart是一门单线程的编程语言，采用事件循环机制来运行任务，所以各个任务的运行状态是互相独立的。也即是说，当程序运行过程中出现异常时，并不需要像Java那样使用try-catch机制来捕获异常，因为即便某个任务出现了异常，Dart程序也不会退出，只会导致当前任务后续的代码不会被执行，而其它功能仍然可以继续使用。</p> \n<p>在Flutter开发中，根据异常来源的不同，可以将异常分为Framework异常和Dart异常。Flutter对这两种异常提供了不同的捕获方式，Framework异常是由Flutter框架引发的异常，通常是由于错误的应用代码造成Flutter框架底层的异常判断引起的，当出现Framework异常时，Flutter会自动弹出一个的红色错误界面。而对于Dart异常，则可以使用try-catch机制和catchError语句进行处理。</p> \n<p>除此之外，Flutter还提供了集中处理框架异常的方案。集中处理框架异常需要使用Flutter提供的FlutterError类，此类的onError属性会在接收到框架异常时执行相应的回调。因此，要实现自定义捕获异常逻辑，只需要为它提供一个自定义的错误处理回调函数即可。</p> \n<h1>异常捕获</h1> \n<p>在Flutter开发中，根据异常来源的不同，可以将异常分为Framework异常和Dart异常。所谓Dart异常，指的是应用代码引起的异常。根据异常代码的执行时序，Dart异常可以分为同步异常和异步异常两类。对于同步异常，可以使用try-catch机制来进行捕获，而异步异常的捕获则比较麻烦，需要使用Future提供的catchError语句来进行捕获，如下所示。</p> \n<pre><code>//使用try-catch捕获同步异常\ntry {\n  throw StateError(\'This is a Dart exception\');\n}catch(e) {\n  print(e);\n}\n\n//使用catchError捕获异步异常\nFuture.delayed(Duration(seconds: 1))\n    .then((e) =&gt; throw StateError(\'This is a Dart exception in Future.\'))\n    .catchError((e)=&gt;print(e));\n</code></pre> \n<p>需要说明的是，对于异步调用所抛出的异常是无法使用try-catch语句进行捕获的，因此下面的写法就是错误的。</p> \n<pre><code>//以下代码无法捕获异步异常\ntry {\n  Future.delayed(Duration(seconds: 1))\n      .then((e) =&gt; throw StateError(\'This is a Dart exception in Future\'))\n}catch(e) {\n  print(\"This line will never be executed\");\n}\n</code></pre> \n<p>因此，对于Dart中出现的异常，同步异常使用的是try-catch，异步异常则使用的是catchError。如果想集中管理代码中的所有异常，那么可以Flutter提供的Zone.runZoned()方法。在Dart语言中，Zone表示一个代码执行的环境范围，其概念类似沙盒，不同沙盒之间是互相隔离的。如果想要处理沙盒中代码执行出现的异常，可以使用沙盒提供的onError回调函数来拦截那些在代码执行过程中未捕获的异常，如下所示。</p> \n<pre><code>//同步抛出异常\nrunZoned(() {\n  throw StateError(\'This is a Dart exception.\');\n}, onError: (dynamic e, StackTrace stack) {\n  print(\'Sync error caught by zone\');\n});\n\n//异步抛出异常\nrunZoned(() {\n  Future.delayed(Duration(seconds: 1))\n      .then((e) =&gt; throw StateError(\'This is a Dart exception in Future.\'));\n}, onError: (dynamic e, StackTrace stack) {\n  print(\'Async error aught by zone\');\n});\n</code></pre> \n<p>可以看到，在没有使用try-catch、catchError语句的情况下，无论是同步异常还是异步异常，都可以使用Zone直接捕获到。<br>同时，如果需要集中捕获Flutter应用中未处理的异常，那么可以把main函数中的runApp语句也放置在Zone中，这样就可以在检测到代码运行异常时对捕获的异常信息进行统一处理，如下所示。</p> \n<pre><code>runZoned&lt;Future&lt;Null&gt;&gt;(() async {\n  runApp(MyApp());\n}, onError: (error, stackTrace) async {\n  //异常处理\n});\n</code></pre> \n<p>除了Dart异常外，Flutter应用开发中另一个比较常见的异常是Framework异常。Framework异常指的是Flutter框架引起的异常，通常是由于执行错误的应用代码造成Flutter框架底层异常判断引起的，当出现Framework异常时，系统会自动弹出一个的红色错误界面，如下图所示。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280731\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>之所以会弹出一个错误提示页面，是由于系统在调用build()方法构建页面时会进行try-catch处理，如果出现任何错误就会调用ErrorWidget页面展示异常信息，并且Flutter框架在很多关键位置都自动进行了异常捕获处理。</p> \n<p>通常，此页面反馈的错误信息对于开发环境的问题定位还是很有帮助的，但如果让线上用户也看到这样的错误页面，体验上就不是很友好比较了。对于Framework异常，最通用的处理方式就是重写ErrorWidget.builder()方法，然后将默认的错误提示页面替换成一个更加友好的自定义提示页面，如下所示。</p> \n<pre><code>ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails){\n  //自定义错误提示页面\n  return Scaffold(\n    body: Center(\n      child: Text(\"Custom Error Widget\"),\n    )\n  );\n};\n</code></pre> \n<h1>应用示例</h1> \n<p>通常，只有当代码运行出现错误时，系统才会给出异常错误提示。为了说明Flutter捕获异常的工作流程，首先来看一个越界访问的示例。首先，新建一个Flutter项目，然后修改main.dart文件的代码，如下所示。</p> \n<pre><code>class MyHomePage extends StatelessWidget {\n @override\n Widget build(BuildContext context) {\n   List&lt;String&gt; numList = [\'1\', \'2\'];\n   print(numList[5]);\n   return Container();\n }\n}\n</code></pre> \n<p>上面的代码模拟的是一个越界访问的异常场景。当运行上面的代码时，控制台会给出如下的错误信息。</p> \n<pre><code>RangeError (index): Invalid value: Not in range 0..2, inclusive: 5</code></pre> \n<p>对于程序中出现的异常，通常只需要在Flutter应用程序的入口main.dart文件中，使用Flutter提供的FlutterError类集中处理即可，如下所示。</p> \n<pre><code>Future&lt;Null&gt; main() async {\n  FlutterError.onError = (FlutterErrorDetails details) async {\n    Zone.current.handleUncaughtError(details.exception, details.stack);\n  };\n  \n  runZoned&lt;Future&lt;void&gt;&gt;(() async {\n    runApp(MyApp());\n  },  onError: (error, stackTrace) async {\n    await _reportError(error, stackTrace);\n  });\n}\n\nFuture&lt;Null&gt; _reportError(dynamic error, dynamic stackTrace) async {\n  print(\'catch error=\'+error);\n}\n</code></pre> \n<p>同时，对于开发环境和线上环境还需要区别对待。因为，对于开发环境遇到的错误，一般是可以立即定位并修复问题的，而对于线上问题才需要对日志进行上报。因此，对于错误日志上报，需要对开发环境和线上环境进行区分对待，如下所示。</p> \n<pre><code>Future&lt;Null&gt; main() async {\n  FlutterError.onError = (FlutterErrorDetails details) async {\n    if (isDebugMode) {\n      FlutterError.dumpErrorToConsole(details);\n    } else {\n      Zone.current.handleUncaughtError(details.exception, details.stack);\n    }\n  };\n   … //省略其他代码\n}\n\nbool get isDebugMode {\n  bool inDebugMode = false;\n  assert(inDebugMode = true);\n  return inDebugMode;\n}\n</code></pre> \n<h1>异常上报</h1> \n<p>目前为止，我们已经对应用中出现的所有未处理异常进行了捕获，不过这些异常还只能被保存在移动设备中，如果想要将这些异常上报到服务器还需要做很多的工作。<br>目前，支持Flutter异常的日志上报的方案有Sentry、Crashlytics等。其中，Sentry是收费的且免费天数只有13天左右，不过它提供的Flutter插件可以帮助开发者快速接入日志上报功能。Crashlytics是Flutter官方支持的日志上报方案，开源且免费，缺点是没有公开的Flutter插件，而flutter_crashlytics插件接入起来也比较麻烦。</p> \n<h2>Sentry方案</h2> \n<p>Sentry是一个商业级的日志管理系统，支持自动上报和手动上报两种方方。在Flutter开发中，由于Sentry提供了Flutter插件，因此如果有日志上报的需求，Sentry是一个不错的选择。<br>使用Sentry之前，需要先在官方网站注册开发者账号。如果还没有Sentry账号，可以先注册一个，然后再创建一个App工程。等待工程创建完成之后，系统会自动生成一个DSN，可以依次点击【Project】→【Settings 】→【Client Keys】来打开DSN，如下图所示。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280734\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>接下来，使用Android Studio打开Flutter工程，在pubspec.yaml文件中添加Sentry插件依赖，如下所示。</p> \n<pre><code>dependencies:\n  sentry: \"&gt;=3.0.0 &lt;4.0.0\"\n</code></pre> \n<p>然后，使用flutter packages get命令将插件拉取到本地。使用Sentry之前，需要先创建一个SentryClient对象，如下所示。</p> \n<pre><code>const dsn=\'\';\nfinal SentryClient _sentry = new SentryClient(dsn: dsn);\n</code></pre> \n<p>为了方便对错误日志进行上传，可以提供一个日志的上报方法，然后在需要进行日志上报的地方调用日志上报方法即可，如下所示。</p> \n<pre><code>Future&lt;void&gt; _reportError(dynamic error, dynamic stackTrace) async {\n  _sentry.captureException(\n      exception: error,\n      stackTrace: stackTrace,\n    );\n}\n\nrunZoned&lt;Future&lt;void&gt;&gt;(() async {\n  runApp(MyApp());\n}, onError: (error, stackTrace) {\n  _reportError(error, stackTrace);         //上传异常日志\n});\n</code></pre> \n<p>同时，开发环境遇到的异常通常是不需要上报的，因为可以立即定位并修复问题，线上遇到的问题才需要进行上报，因此在进行异常上报时还需要区分开发环境和线上环境。</p> \n<pre><code>const dsn=\'https://872ea62a55494a73b73ee139da1c1449@sentry.io/5189144\';\nfinal SentryClient _sentry = new SentryClient(dsn: dsn);\n\nFuture&lt;Null&gt; main() async {\n  FlutterError.onError = (FlutterErrorDetails details) async {\n    if (isInDebugMode) {\n      FlutterError.dumpErrorToConsole(details);\n    } else {\n      Zone.current.handleUncaughtError(details.exception, details.stack);\n    }\n  };\n\n  runZoned&lt;Future&lt;Null&gt;&gt;(() async {\n    runApp(MyApp());\n  }, onError: (error, stackTrace) async {\n    await _reportError(error, stackTrace);\n  });\n}\n\nFuture&lt;Null&gt; _reportError(dynamic error, dynamic stackTrace) async {\n  if (isInDebugMode) {\n    print(stackTrace);\n    return;\n  }\n  final SentryResponse response = await _sentry.captureException(\n    exception: error,\n    stackTrace: stackTrace,\n  );\n\n  //上报结果处理\n  if (response.isSuccessful) {\n    print(\'Success! Event ID: ${response.eventId}\');\n  } else {\n    print(\'Failed to report to Sentry.io: ${response.error}\');\n  }\n}\n\nbool get isInDebugMode {\n  bool inDebugMode = false;\n  assert(inDebugMode = true);\n  return inDebugMode;\n}\n</code></pre> \n<p>在真机上运行Flutter应用，如果出现错误，就可以在Sentry服务器端看到对应的错误日志，如下图所示。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280735\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>除此之外，目前市面上还有很多优秀的日志采集服务厂商，如Testin、Bugly和友盟等，不过它们大多还没有提供Flutter接入方案，因此需要开发者在原生平台进行接入。</p> \n<h2>Bugly方案</h2> \n<p>目前，Bugly还没有提供Flutter插件，那么，我们针对混合工程，可以采用下面的方案。接入Bugly时，只需要完成一些前置应用信息关联绑定和 SDK 初始化工作，就可以使用 Dart 层封装好的数据上报接口去上报异常了。可以看到，对于一个应用而言，接入数据上报服务的过程，总体上可以分为两个步骤：</p> \n<ol> \n <li>初始化 Bugly SDK；</li> \n <li>使用数据上报接口。</li> \n</ol> \n<p>这两步对应着在 Dart 层需要封装的 2 个原生接口调用，即 setup 和 postException，它们都是在方法通道上调用原生代码宿主提供的方法。考虑到数据上报是整个应用共享的能力，因此我们将数据上报类 FlutterCrashPlugin 的接口都封装成了单例，如下所示。</p> \n<pre><code>\nclass FlutterCrashPlugin {\n  //初始化方法通道\n  static const MethodChannel _channel =\n      const MethodChannel(\'flutter_crash_plugin\');\n\n  static void setUp(appID) {\n    //使用app_id进行SDK注册\n    _channel.invokeMethod(\"setUp\",{\'app_id\':appID});\n  }\n  static void postException(error, stack) {\n    //将异常和堆栈上报至Bugly\n    _channel.invokeMethod(\"postException\",{\'crash_message\':error.toString(),\'crash_detail\':stack.toString()});\n  }\n}</code></pre> \n<p>Dart 层是原生代码宿主的代理，可以看到这一层的接口设计还是比较简单的。接下来，我们分别去接管数据上报的 Android 和 iOS 平台上完成相应的实现即可。</p> \n<h3>iOS 接口实现</h3> \n<p>考虑到 iOS 平台的数据上报配置工作相对较少，因此我们先用 Xcode 打开 example 下的 iOS 工程进行插件开发工作。需要注意的是，由于 iOS 子工程的运行依赖于 Flutter 工程编译构建产物，所以在打开 iOS 工程进行开发前，你需要确保整个工程代码至少 build 过一次，否则 IDE 会报错。以下是<a href=\"https://bugly.qq.com/docs/user-guide/instruction-manual-ios/?v=20190712210424\" rel=\"nofollow noreferrer\">Bugly 异常上报 iOS SDK 接入指南</a></p> \n<p>首先，我们需要在插件工程下的 flutter_crash_plugin.podspec 文件中引入 Bugly SDK，即 Bugly，这样我们就可以在原生工程中使用 Bugly 提供的数据上报功能了。</p> \n<pre><code>\nPod::Spec.new do |s|\n  ...\n  s.dependency \'Bugly\'\nend</code></pre> \n<p>然后，在原生接口 FlutterCrashPlugin 类中，依次初始化插件实例、绑定方法通道，并在方法通道中先后为 setup 与 postException 提供 Bugly iOS SDK 的实现版本，如下所示。</p> \n<pre><code>\n@implementation FlutterCrashPlugin\n+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar {\n    //注册方法通道\n    FlutterMethodChannel* channel = [FlutterMethodChannel\n      methodChannelWithName:@\"flutter_crash_plugin\"\n            binaryMessenger:[registrar messenger]];\n    //初始化插件实例，绑定方法通道 \n    FlutterCrashPlugin* instance = [[FlutterCrashPlugin alloc] init];\n    //注册方法通道回调函数\n    [registrar addMethodCallDelegate:instance channel:channel];\n}\n\n- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result {\n    if([@\"setUp\" isEqualToString:call.method]) {\n        //Bugly SDK初始化方法\n        NSString *appID = call.arguments[@\"app_id\"];\n        [Bugly startWithAppId:appID];\n    } else if ([@\"postException\" isEqualToString:call.method]) {\n      //获取Bugly数据上报所需要的各个参数信息\n      NSString *message = call.arguments[@\"crash_message\"];\n      NSString *detail = call.arguments[@\"crash_detail\"];\n\n      NSArray *stack = [detail componentsSeparatedByString:@\"\\n\"];\n      //调用Bugly数据上报接口\n      [Bugly reportExceptionWithCategory:4 name:message reason:stack[0] callStack:stack extraInfo:@{} terminateApp:NO];\n      result(@0);\n  }\n  else {\n    //方法未实现\n    result(FlutterMethodNotImplemented);\n  }\n}\n\n@end</code></pre> \n<p>至此，在完成了 Bugly iOS SDK 的接口封装之后，FlutterCrashPlugin 插件的 iOS 部分也就搞定了。</p> \n<h3>Android 接口实现</h3> \n<p>与 iOS 类似，我们需要使用 Android Studio 打开 example 下的 android 工程进行插件开发工作。同样，在打开 android 工程前，你需要确保整个工程代码至少 build 过一次，否则 IDE 会报错。以下是<a href=\"https://bugly.qq.com/docs/user-guide/instruction-manual-android/\" rel=\"nofollow noreferrer\">Bugly 异常上报 Android SDK 接入指南</a>。</p> \n<p>首先，我们需要在插件工程下的 build.gradle 文件引入 Bugly SDK，即 crashreport 与 nativecrashreport，其中前者提供了 Java 和自定义异常的的数据上报能力，而后者则是 JNI 的异常上报封装，如下所示。</p> \n<pre><code>\ndependencies {\n    implementation \'com.tencent.bugly:crashreport:latest.release\' \n    implementation \'com.tencent.bugly:nativecrashreport:latest.release\' \n}</code></pre> \n<p>然后，在原生接口 FlutterCrashPlugin 类中，依次初始化插件实例、绑定方法通道，并在方法通道中先后为 setup 与 postException 提供 Bugly Android SDK 的实现版本，代码如下。</p> \n<pre><code>\npublic class FlutterCrashPlugin implements MethodCallHandler {\n  //注册器，通常为MainActivity\n  public final Registrar registrar;\n  //注册插件\n  public static void registerWith(Registrar registrar) {\n    //注册方法通道\n    final MethodChannel channel = new MethodChannel(registrar.messenger(), \"flutter_crash_plugin\");\n    //初始化插件实例，绑定方法通道，并注册方法通道回调函数 \n    channel.setMethodCallHandler(new FlutterCrashPlugin(registrar));\n  }\n\n  private FlutterCrashPlugin(Registrar registrar) {\n    this.registrar = registrar;\n  }\n\n  @Override\n  public void onMethodCall(MethodCall call, Result result) {\n    if(call.method.equals(\"setUp\")) {\n      //Bugly SDK初始化方法\n      String appID = call.argument(\"app_id\");\n\n      CrashReport.initCrashReport(registrar.activity().getApplicationContext(), appID, true);\n      result.success(0);\n    }\n    else if(call.method.equals(\"postException\")) {\n      //获取Bugly数据上报所需要的各个参数信息\n      String message = call.argument(\"crash_message\");\n      String detail = call.argument(\"crash_detail\");\n      //调用Bugly数据上报接口\n      CrashReport.postException(4,\"Flutter Exception\",message,detail,null);\n      result.success(0);\n    }\n    else {\n      result.notImplemented();\n    }\n  }\n}</code></pre> \n<p>在完成了 Bugly Android 接口的封装之后，由于 Android 系统的权限设置较细，考虑到 Bugly 还需要网络、日志读取等权限，因此我们还需要在插件工程的 AndroidManifest.xml 文件中，将这些权限信息显示地声明出来，如下所示。</p> \n<pre><code>\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  package=\"com.hangchen.flutter_crash_plugin\"&gt;\n    &lt;!-- 电话状态读取权限 --&gt; \n    &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt;\n    &lt;!-- 网络权限 --&gt; \n    &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n    &lt;!-- 访问网络状态权限 --&gt; \n    &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;\n    &lt;!-- 访问wifi状态权限 --&gt; \n    &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt;\n    &lt;!-- 日志读取权限 --&gt; \n    &lt;uses-permission android:name=\"android.permission.READ_LOGS\" /&gt;\n&lt;/manifest&gt;</code></pre> \n<p>至此，在完成了极光 Android SDK 的接口封装和权限配置之后，FlutterCrashPlugin 插件的 Android 部分也搞定了。FlutterCrashPlugin 插件为 Flutter 应用提供了数据上报的封装，不过要想 Flutter 工程能够真正地上报异常消息，我们还需要为 Flutter 工程关联 Bugly 的应用配置。</p> \n<h3>应用工程配置</h3> \n<p>在单独为 Android/iOS 应用进行数据上报配置之前，我们首先需要去Bugly 的官方网站，为应用注册唯一标识符（即 AppKey）。这里需要注意的是，在 Bugly 中，Android 应用与 iOS 应用被视为不同的产品，所以我们需要分别注册。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280732\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280736\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>在得到了 AppKey 之后，我们需要依次进行 Android 与 iOS 的配置工作。iOS 的配置工作相对简单，整个配置过程完全是应用与 Bugly SDK 的关联工作，而这些关联工作仅需要通过 Dart 层调用 setUp 接口，访问原生代码宿主所封装的 Bugly API 就可以完成，因此无需额外操作。</p> \n<p>而 Android 的配置工作则相对繁琐些。由于涉及 NDK 和 Android P 网络安全的适配，我们还需要分别在 build.gradle 和 AndroidManifest.xml 文件进行相应的配置工作。首先，由于 Bugly SDK 需要支持 NDK，因此我们需要在 App 的 build.gradle 文件中为其增加 NDK 的架构支持，如下所示。</p> \n<pre><code>\ndefaultConfig {\n    ndk {\n        // 设置支持的SO库架构\n        abiFilters \'armeabi\' , \'x86\', \'armeabi-v7a\', \'x86_64\', \'arm64-v8a\'\n    }\n}</code></pre> \n<p>然后，由于 Android P 默认限制 http 明文传输数据，因此我们需要为 Bugly 声明一项网络安全配置 network_security_config.xml，允许其使用 http 传输数据，并在 AndroidManifest.xml 中新增同名网络安全配置。</p> \n<pre><code>\n//res/xml/network_security_config.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;!-- 网络安全配置 --&gt; \n&lt;network-security-config&gt;\n    &lt;!-- 允许明文传输数据 --&gt;  \n    &lt;domain-config cleartextTrafficPermitted=\"true\"&gt;\n        &lt;!-- 将Bugly的域名加入白名单 --&gt; \n        &lt;domain includeSubdomains=\"true\"&gt;android.bugly.qq.com&lt;/domain&gt;\n    &lt;/domain-config&gt;\n&lt;/network-security-config&gt;\n\n//AndroidManifest/xml\n&lt;application\n  ...\n  android:networkSecurityConfig=\"@xml/network_security_config\"\n  ...&gt;\n&lt;/application&gt;</code></pre> \n<p>至此，Flutter 工程所需的原生配置工作和接口实现，就全部搞定了。接下来，我们就可以在 Flutter 工程中的 main.dart 文件中，使用 FlutterCrashPlugin 插件来实现异常数据上报能力了。当然，我们首先还需要在 pubspec.yaml 文件中，将工程对它的依赖显示地声明出来，如下所示。</p> \n<pre><code>\ndependencies:\n  flutter_push_plugin:\n    git:\n      url: xxx</code></pre> \n<p>在下面的代码中，我们在 main 函数里为应用的异常提供了统一的回调，并在回调函数内使用 postException 方法将异常上报至 Bugly。而在 SDK 的初始化方法里，由于 Bugly 视 iOS 和 Android 为两个独立的应用，因此我们判断了代码的运行宿主，分别使用两个不同的 App ID 对其进行了初始化工作。</p> \n<p>此外，为了与你演示具体的异常拦截功能，我们还在两个按钮的点击事件处理中分别抛出了同步和异步两类异常，代码如下：</p> \n<pre><code>\n//上报数据至Bugly\nFuture&lt;Null&gt; _reportError(dynamic error, dynamic stackTrace) async {\n  FlutterCrashPlugin.postException(error, stackTrace);\n}\n\nFuture&lt;Null&gt; main() async {\n  //注册Flutter框架的异常回调\n  FlutterError.onError = (FlutterErrorDetails details) async {\n    //转发至Zone的错误回调\n    Zone.current.handleUncaughtError(details.exception, details.stack);\n  };\n  //自定义错误提示页面\n  ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails){\n    return Scaffold(\n      body: Center(\n        child: Text(\"Custom Error Widget\"),\n      )\n    );\n  };\n  //使用runZone方法将runApp的运行放置在Zone中，并提供统一的异常回调\n  runZoned&lt;Future&lt;Null&gt;&gt;(() async {\n    runApp(MyApp());\n  }, onError: (error, stackTrace) async {\n    await _reportError(error, stackTrace);\n  });\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  State&lt;StatefulWidget&gt; createState() =&gt; _MyAppState();\n}\n\nclass _MyAppState extends State&lt;MyApp&gt; {\n  @override\n  void initState() {\n    //由于Bugly视iOS和Android为两个独立的应用，因此需要使用不同的App ID进行初始化\n    if(Platform.isAndroid){\n      FlutterCrashPlugin.setUp(\'43eed8b173\');\n    }else if(Platform.isIOS){\n      FlutterCrashPlugin.setUp(\'088aebe0d5\');\n    }\n    super.initState();\n  }\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: MyHomePage(),\n    );\n  }\n}\n\nclass MyHomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\'Crashy\'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: &lt;Widget&gt;[\n            RaisedButton(\n              child: Text(\'Dart exception\'),\n              onPressed: () {\n                //触发同步异常\n                throw StateError(\'This is a Dart exception.\');\n              },\n            ),\n            RaisedButton(\n              child: Text(\'async Dart exception\'),\n              onPressed: () {\n                //触发异步异常\n                Future.delayed(Duration(seconds: 1))\n                      .then((e) =&gt; throw StateError(\'This is a Dart exception in Future.\'));\n              },\n            )\n          ],\n        ),\n      ),\n    );\n  }\n}</code></pre> \n<p>运行上面的代码，模拟异常上传，然后我们<a href=\"https://bugly.qq.com/v2/workbench/apps\" rel=\"nofollow noreferrer\">打开Bugly 开发者后台</a>，选择对应的 App，切换到错误分析选项查看对应的面板信息。可以看到，Bugly 已经成功接收到上报的异常上下文了，如下图所示。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280733\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h1>总结</h1> \n<p>对于 Flutter 应用的异常捕获，可以分为单个异常捕获和多异常统一拦截两种情况。其中，单异常捕获，使用 Dart 提供的同步异常 try-catch，以及异步异常 catchError 机制即可实现。而对多个异常的统一拦截，可以细分为如下两种情况：一是 App 异常，我们可以将代码执行块放置到 Zone 中，通过 onError 回调进行统一处理；二是 Framework 异常，我们可以使用 FlutterError.onError 回调进行拦截。</p> \n<p>需要注意的是，Flutter 提供的异常拦截只能拦截 Dart 层的异常，而无法拦截 Engine 层的异常。这是因为，Engine 层的实现大部分是 C++ 的代码，一旦出现异常，整个程序就直接 Crash 掉了。不过通常来说，这类异常出现的概率极低，一般都是 Flutter 底层的 Bug，与我们在应用层的实现没太大关系，所以我们也无需过度担心。</p> \n<p>如果我们想要追踪 Engine 层的异常（比如给 Flutter 提 Issue），则需要借助于原生系统提供的 Crash 监听机制。不过，这方面的内容比较繁琐，具体可以参考：<a href=\"https://github.com/flutter/flutter/wiki/Crashes\" rel=\"nofollow noreferrer\">Flutter官方文档</a></p>', 'https://segmentfault.com/img/remote/1460000022280731', null, null, '0', '0', null, '1', '2020-04-14 20:58:23', '2020-04-14 20:58:23');
INSERT INTO `tb_recommend` VALUES ('e245c26bef5c48209f2f261b0c14b2c9', 'MySQL 同步复制及高可用方案总结', 'mysql作为应用程序的数据存储服务，要实现mysql数据库的高可用。必然要使用的技术就是数据库的复制，如果主节点出现故障可以手动的切换应用到从节点，这点相信运维同学都是知道，并且可以实现的。但是这种情况只...', '<h4><strong>1.前言</strong></h4> \n<p>mysql作为应用程序的数据存储服务，要实现mysql数据库的高可用。必然要使用的技术就是数据库的复制，如果主节点出现故障可以手动的切换应用到从节点，这点相信运维同学都是知道，并且可以实现的。但是这种情况只是手动的切换，对可用性有要求的业务需要分别实现主库和从库的高可用，保障在数据库出现down机的情况下，可以自动实现数据库的故障转移，保障应用的可用性和用户体验。</p> \n<p>本文将会对一些常用的数据库高可用方案进行介绍，根据你不同的场景，选择合适的高可用方案即可。</p> \n<h4><strong>2.MMM高可用方案</strong></h4> \n<hr> \n<h6><strong>2.1.Mysql-MMM介绍</strong></h6> \n<p>MMM(Master-Master replication managerfor Mysql，Mysql主主复制管理器)是一套灵活的脚本程序，基于perl实现，用来对mysql replication进行监控和故障迁移，并能管理mysql Master-Master复制的配置(同一时间只有一个节点是可写的)。</p> \n<h6><strong>2.2.组件</strong></h6> \n<p><strong>mmm_mond：</strong>监控进程，负责所有的监控工作，决定和处理所有节点角色活动。此脚本需要在监管机上运行。</p> \n<p><strong>mmm_agentd：</strong>运行在每个mysql服务器上的代理进程，完成监控的探针工作和执行简单的远端服务设置。此脚本需要在被监管机上运行。</p> \n<p><strong>mmm_control：</strong>一个简单的脚本，提供管理mmm_mond进程的命令。</p> \n<p>mysql-mmm的监管端会提供多个虚拟IP（VIP），包括一个可写VIP，多个可读VIP，通过监管的管理，这些IP会绑定在可用mysql之上，当某一台mysql宕机时，监管会将VIP迁移至其他mysql。</p> \n<p>在整个监管过程中，需要在mysql中添加相关授权用户，以便让mysql可以支持监理机的维护。授权的用户包括一个mmm_monitor用户和一个mmm_agent用户，如果想使用mmm的备份工具则还要添加一个mmm_tools用户。</p> \n<h6><strong>2.3.架构图</strong></h6> \n<p>正常工作时： </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313467\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>主节点故障时： </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313468\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h6><strong>2.4.MMM优点</strong></h6> \n<p>（1）高可用性，扩展性好，出现故障自动转移，对于主主同步，在同一时间只提供一台数据库写操作，保证数据的一致性。</p> \n<p>（2）配置简单，容易操作。</p> \n<h6><strong>2.5.MMM缺点</strong></h6> \n<p>（1）需要一台备份服务器，浪费资源</p> \n<p>（2）需要多个虚拟IP</p> \n<p>（3）agent可能意外终止，引起裂脑。</p> \n<h4><strong>3.MHA介绍</strong></h4> \n<hr> \n<p>MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案，它由日本DeNA公司youshimaton（现就职于Facebook公司）开发，是一套优秀的作为MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中，MHA能做到在0~30秒之内自动完成数据库的故障切换操作，并且在进行故障切换的过程中，MHA能在最大程度上保证数据的一致性，以达到真正意义上的高可用。</p> \n<h6><strong>3.1.MHA架构介绍</strong></h6> \n<p>该软件由两部分组成：MHA Manager（管理节点）和MHA Node（数据节点）。MHA Manager可以单独部署在一台独立的机器上管理多个master-slave集群，也可以部署在一台slave节点上。MHA Node运行在每台MySQL服务器上，MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master。整个故障转移过程对应用程序完全透明。</p> \n<p>在MHA自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据的不丢失(配合mysql半同步复制效果更佳)，但这并不总是可行的。例如，如果主服务器硬件故障或无法通过ssh访问，MHA没法保存二进制日志，只进行故障转移而丢失了最新的数据。使用MySQL 5.5的半同步复制，可以大大降低数据丢失的风险。MHA可以与半同步复制结合起来。如果只有一个slave已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其他所有的slave服务器上，因此可以保证所有节点的数据一致性。</p> \n<p>注意：目前MHA主要支持一主多从的架构，要搭建MHA,要求一个复制集群中必须最少有三台数据库服务器，一主二从，即一台充当master，一台充当备用master，另外一台充当从库，因为至少需要三台服务器，出于机器成本的考虑，淘宝也在该基础上进行了改造，目前淘宝TMHA已经支持一主一从。</p> \n<h6><strong>3.2.MHA架构图</strong></h6> \n<p>正常工作时架构图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313469\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>主库down机时架构：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313466\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h6><strong>3.3.故障转移过程</strong></h6> \n<p>（1）从宕机崩溃的master保存二进制日志事件（binlog events）;</p> \n<p>（2）识别含有最新更新的slave；</p> \n<p>（3）应用差异的中继日志（relay log）到其他的slave；</p> \n<p>（4）应用从master保存的二进制日志事件（binlog events）；</p> \n<p>（5）提升一个slave为新的master；</p> \n<p>（6）使其他的slave连接新的master进行复制；</p> \n<p>（7）在新的master启动vip地址，保证前端请求可以发送到新的master。</p> \n<h6><strong>3.4.MHA优点</strong></h6> \n<p>（1）不需要备份服务器</p> \n<p>（2）不改变现有环境</p> \n<p>（3）操作非常简单</p> \n<p>（4）可以进行日志的差异修复</p> \n<p>（5）可以将任意slave提升为master</p> \n<h6><strong>3.5.MHA缺点</strong></h6> \n<p>（1）需要全部节点做ssh秘钥</p> \n<p>（2）MHA出现故障后配置文件会被修改，如果再次故障转移需要重新修改配置文件。</p> \n<p>（3）自带的脚本还需要进一步补充完善，且用perl开发，二次开发困难。</p> \n<h4><strong>4.DRBD+（heartbeat,corosync）</strong></h4> \n<hr> \n<h6>4.1.<strong>方案简介</strong> </h6> \n<p>本方案采用Heartbeat或者corosync双机热备软件来保证数据库的高稳定性和连续性，数据的一致性由DRBD这个工具来保证（如果可以尽量放到分布式存储上面）。默认情况下只有一台mysql在工作，当主mysql服务器出现问题后，系统将自动切换到备机上继续提供服务，当主数据库修复完毕，又将服务切回继续由主mysql提供服务。</p> \n<h6>4.2.<strong>组件</strong> </h6> \n<p>Heartbeat,corosync作为心跳检测机制，监控primary节点的状态。当主节点宕掉之后，迅速提升secondary节点为新的主节点，并切换IP；</p> \n<p><strong>drbd</strong>负责数据同步</p> \n<h6>4.3.<strong>架构图</strong> </h6> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313465\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h6>4.4.<strong>数据同步过程</strong> </h6> \n<p>mysql进行刷盘时，会通过不同的sync方式，最终将数据写入disk；</p> \n<p>drbd收到刷盘成功的信息后，将对应的磁盘块位置，和变更动作，通过网络传递至secondary节点；</p> \n<p>secondary的drbd接收到变更信息后，将这些信息落盘；</p> \n<h6>4.5.<strong>切换过程</strong> </h6> \n<p>前提：secondary节点的mysql服务不启动；</p> \n<p>heartbeat检测到primary的mysql服务停止，则摘掉IP、umount掉数据盘、将primary切换为secondary；</p> \n<p>在原来的secondary上，提升drbd同步为primary，挂载数据盘，启动mysql服务、绑定IP；</p> \n<p>从库跟着IP和端口自动进行迁移；</p> \n<h6>4.6.<strong>方案优点</strong> </h6> \n<p>（1）历史悠久、安全性高、稳定性高、可用性高、出现故障自动切换。</p> \n<p>（2）数据一致性强</p> \n<h6>4.7.<strong>方案缺点</strong> </h6> \n<p>（1）需要一台备份服务器，浪费资源</p> \n<p>（2）不方便扩展</p> \n<p>（3）无论drbd还是headbetart，corosync都可能发生裂脑</p> \n<h4><strong>5.Mysql route介绍</strong></h4> \n<hr> \n<h6><strong>5.1.什么是mysql route</strong></h6> \n<p>MySQL Router是处于应用client和dbserver之间的轻量级代理程序，它能检测，分析和转发查询到后端数据库实例，并把结果返回给client。是mysql-proxy的一个替代品。其架构图和功能如下。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313470\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>（1）Router实现读写分离，程序不是直接连接数据库IP，而是固定连接到mysql router。MySQL Router对前端应用是透明的。应用程序把MySQL Router当作是普通的mysql实例，把查询发给MySQL Router,而MySQL Router会把查询结果返回给前端的应用程序。</p> \n<p>（2）从数据库服务器故障，业务可以正常运行。由MySQL Router来进行自动下线不可用服务器。程序配置不需要任何修改。</p> \n<p>（3）主数据库故障，由MySQL Router来决定主从自动切换，业务可以正常访问。程序配置不需要做任何修改。</p> \n<h6><strong>5.2.读写分离原理</strong></h6> \n<p>MySQL Router接受前端应用程序请求后，根据不同的端口来区分读写，把连接读写端口的所有查询发往主库，把连接只读端口的select查询以轮询方式发往多个从库，从而实现读写分离的目的。读写返回的结果会交给MySQL Router,由MySQL Router返回给客户端的应用程序。</p> \n<h6><strong>5.3.Mysql router用途</strong></h6> \n<p>MySQL Router的主要用途是读写分离，主主故障自动切换，负载均衡，连接池等。</p> \n<h6><strong>5.4.Mysql router主主故障自动切换的坑</strong></h6> \n<p>Mysql router主主故障切换功能经过测试没有问题，但是有一个比较大的坑需要注意，主库发生切换之后，从库的连接的master服务器地址不会发生改变，需要自己写脚本进行判断。</p> \n<h6>5.5.优点</h6> \n<p>（1）基于DAL层实现mysql的高可用。</p> \n<p>（2）可以同时实现主主故障切换和读写分离。</p> \n<p>（3）插件式架构允许用户进行额外的功能扩展。</p> \n<h6><strong>5.6.缺点</strong></h6> \n<p>（1）高可用功能需要进一步完善：存在主库切换之后，从库不会自动切换主库地址的坑。</p> \n<p>（2）读写情况使用不同端口，需要修改应用程序。</p> \n<h4><strong>6.mysql Cluster</strong></h4> \n<hr> \n<p>国内用的非常少，主要因为一下三点：</p> \n<p>（1）需要更改存储引擎</p> \n<p>（2）付费</p> \n<p>（3）国内几乎没有使用案例</p> \n<p><strong>优点：</strong></p> \n<p>高可用，可用率达99.999%</p> \n<h4>7.结束语</h4> \n<p>上面的高可用方案，只是我自己比较熟悉的，而且也是应用比较多的。mysql毕竟发展了有20多年了，各种高可用方案还是很多的，其他的高可用方案各位钥匙有兴趣，可以自己研究。</p>', 'https://segmentfault.com/img/remote/1460000022313467', null, null, '0', '0', null, '1', '2020-04-14 20:58:18', '2020-04-14 20:58:18');
INSERT INTO `tb_recommend` VALUES ('e343515229a04f6b8e7eeb83d9c36ddb', '[译]Flutter - 使用Provider实现状态管理', '这篇文章好的的地方在于它不仅讲了Flutter Provider如何管理State的，还讲述了一个Flutter App可以采用哪一种架构。这种架构是基于clean architecture和FilledStacks这两种架构原则的（这里可能理解或者表达有误...', '<p>这篇文章好的的地方在于它不仅讲了Flutter Provider如何管理State的，还讲述了一个Flutter App可以采用哪一种架构。这种架构是基于<a href=\"https://pusher.com/tutorials/clean-architecture-introduction\" rel=\"nofollow noreferrer\">clean architecture</a>和<a href=\"https://www.filledstacks.com/post/flutter-architecture-my-provider-implementation-guide/\" rel=\"nofollow noreferrer\">FilledStacks</a>这两种架构原则的（这里可能理解或者表达有误，请指正）。但是文中最后采用的还是<strong>MVVM</strong>的模式。</p> \n<p>更加重要的一点，就是本文要讲述的Provider其实就是一种widget。搭配着<code>Consumer</code>这个widget一起使用，达到<strong>UI = f(state)</strong>这个<code>state</code>变化，UI跟着变的效果。</p> \n<p>最后，还是那句话要看原文的请到<a href=\"https://www.raywenderlich.com/6373413-state-management-with-provider\" rel=\"nofollow noreferrer\">这里</a>，文章本身有质量，而且写的不难。</p> \n<h2>正文</h2> \n<p>Flutter团队建议初学者使用<strong>Provider</strong>来管理state。但是Provider到底是什么，该如何使用？</p> \n<p>Provider是一个UI工具。如果你对于架构、state和架构之间有疑惑，那么并不只有你是这样。本文会帮助你理清这些概念，让你知道如何从无到有写一个app。</p> \n<p>本文会带你学习Provider管理state的方方面面。这里我们来写一个计算汇率的app，就叫做<strong>MoolaX</strong>。在写这个app的时候你会提升你的Flutter技能：</p> \n<ol> \n <li>app架构</li> \n <li>实现一个Provider</li> \n <li>熟练管理app的state</li> \n <li>根据state的更改来更新UI</li> \n</ol> \n<blockquote>\n 注意：本文假设你已经知道Dart和如何写一个Flutter的app了。如果在这方面还有不清楚的话请移步\n <a href=\"https://www.raywenderlich.com/4529993-getting-started-with-flutter\" rel=\"nofollow noreferrer\">Flutter入门</a>。\n</blockquote> \n<h2>开始</h2> \n<p>点击“下载材料”来下载项目的代码。然后你就可以一步一步的跟着本文添加代码完成开发。</p> \n<p>本文使用了Android Studio，但是Visual Studio Code也是可以用的。（其实VS Code更好用，译者观点）。</p> \n<p>在MoolaX里你可以选择不同的货币。App运行起来是这样的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263766\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"最终效果\" title=\"最终效果\"></span></p> \n<p>打开初始项目，解压后的starter目录。Android Studio会出现一个弹出框，点击<strong>Get dependencies</strong>。</p> \n<p>在初始项目里已经包含了一部分代码，本教程会带着你添加必要的代码，让你轻松学会下文的内容。</p> \n<p>现在这个app运行起来的时候是这样的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263767\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>搭建App的架构</h2> \n<p>如果你没听说过<a href=\"https://pusher.com/tutorials/clean-architecture-introduction\" rel=\"nofollow noreferrer\">clean architecture</a>，再继续之前请阅读这篇文章。</p> \n<p>主旨就是把核心业务逻辑从UI、数据库、网络请求和第三方包中分离出来。为什么？核心业务逻辑相对并不会那么频繁的更改。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263770\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>UI不应该直接请求网络。也不应该把数据库读写的代码写的到处都是。所有的数据都应该从一个统一的地方发出，这就是业务逻辑。</p> \n<p>这就形成了一个插件系统。即使你更换了一个数据库，app的其他部分也不会有任何的感知。你可以从一个移动端UI更换的一个桌面UI，app的其他部分也并不用关心。这对于开发一个易于维护、扩展的app来说十分有效。</p> \n<h2>使用Provider管理state</h2> \n<p>MoolaX的架构就符合这个原则。业务逻辑处理汇率相关的计算。Local Storage、网络请求和Flutter的UI、Provider这些全部都互相独立。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263774\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Local storage使用的是shared preferences，但是这个和app的其他部分没有关联。同理网络请求如何获取数据和app的其他部分也没有任何关联。</p> \n<p>接下来要理解的是UI、Flutter和Provider都在同一个部分里。Flutter就是一个UI框架，Provider是这个框架里的一个widget。</p> \n<p>Provider是架构吗？不是。<br>Provider是状态管理吗？不是，至少在这个app里不是。</p> \n<p><strong>state</strong>是app的变量的当前值。这些变量是app的业务逻辑的一部分，分散、管理在不同的model对象里。所以，业务逻辑管理了state，而不是Provider。</p> \n<p>所以，Provider到底是什么呢？</p> \n<p>它是<strong>状态管理的helper</strong>，它是一个widget。通过这个widget可以把model对象传递给它的子widget。</p> \n<p><code>Consumer</code> widget，属于<a href=\"https://pub.dev/packages/provider\" rel=\"nofollow noreferrer\">Provider 包</a>的一部分，监听了Provider暴露的mode值的改变，并重新build它的全部子widget。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263777\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><a href=\"https://www.raywenderlich.com/6011211-manage-state-with-provider\" rel=\"nofollow noreferrer\">使用Provider管理state系列</a>对state和provider做了更加全面的解析。Provider有很多种，不过多数不在本文的范围内。</p> \n<h2>和业务逻辑通信</h2> \n<p>文本的架构模式受到了<a href=\"https://www.filledstacks.com/post/flutter-architecture-my-provider-implementation-guide/\" rel=\"nofollow noreferrer\">FilledStacks</a>的启发。它可以让架构足够有条理而又不会太过复杂。对初学者也很友好。</p> \n<p>这个模型非常类似于<strong>MVVM</strong>（Model View ViewModel)。</p> \n<p><strong>model</strong>就是从数据库或者网络请求得到的数据。<strong>view</strong>就是UI，也可以是一个screen或者widget。<strong>viewmodel</strong>就是在UI和数据中间的业务逻辑，并提供了UI可以展示的数据。但是它对UI并无感知。这一单和<a href=\"https://www.youtube.com/watch?v=ugpC98LcNqA\" rel=\"nofollow noreferrer\">MVP</a>不同。viewmodel也不应该知道数据从哪里来。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263776\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在MoolaX里，每页都有独立的view model。数据可以从网络和本地存储获得。处理这部分内容的类叫做services。MoolaX的架构基本是这样的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263768\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>注意如下几点：</p> \n<ul> \n <li>UI页面监听view model的改变，也会给view model发送事件</li> \n <li>view model不会感知到UI的具体细节</li> \n <li>业务逻辑与货币抽象交互。它不会感知数据是从网络请求得来还是从本地存储得来。</li> \n</ul> \n<p>理论部分到此结束，现在开始代码部分！</p> \n<h2>创建核心业务逻辑</h2> \n<p>项目的目录结构如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263775\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>Models</h2> \n<p>我们来看看mdels目录：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263769\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这些就是业务逻辑要用到的数据结构了。<a href=\"http://www.agilemodeling.com/artifacts/crcModel.htm\" rel=\"nofollow noreferrer\">类职责协同卡片模型</a>是一个很好的方法可以确定哪些model是需要的。卡片如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263779\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>最后会用到<code>Currency</code>和<code>Rate</code>两个model。他们代表了先进和汇率，就算你没哟计算机也需要这两个。</p> \n<h2>View Model</h2> \n<p>view mode的职责就是拿到数据，然后转化成UI可用的格式。</p> \n<p>展开<strong>view_models</strong>目录。你会看到两个view model，一个是给结算页用的，一个是给选择汇率页用的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263780\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>打开<strong>choose_favorites_viewmodel.dart</strong>。你会看到下面的代码：</p> \n<pre><code class=\"dart\">// 1\nimport \'package:flutter/foundation.dart\';\n\n// 2\nclass ChooseFavoritesViewModel extends ChangeNotifier {\n  // 3\n  final CurrencyService _currencyService = serviceLocator&lt;CurrencyService&gt;();\n\n  List&lt;FavoritePresentation&gt; _choices = [];\n  List&lt;Currency&gt; _favorites = [];\n\n  // 4\n  List&lt;FavoritePresentation&gt; get choices =&gt; _choices;\n\n  void loadData() async {\n    // ...\n    // 5\n    notifyListeners();\n  }\n\n  void toggleFavoriteStatus(int choiceIndex) {\n    // ...\n    // 5\n    notifyListeners();\n  }\n}</code></pre> \n<p>解释：</p> \n<ol> \n <li>使用<code>ChangeNotifier</code>来实现UI对view model的监听。这个类在Flutter<code>foundation</code>包。</li> \n <li>view model类继承了<code>ChangeNotifier</code>类。另一个选项是使用mixin。<code>ChangeNotifier</code>里有一个<code>notifyListeners()</code>方法，你后面会用到。</li> \n <li>一个service来负责获取和保存货币以及汇率数据。<code>CurrencyService</code>是一个抽象类，它的具体实现隐藏在view model之外。你可以任意更换不同的实现。</li> \n <li>任意可以访问这个view mode的实例都可以访问到一个货币列表，然后从里面选出一个最喜欢的。UI会使用这个列表来创建一个可选的listview。</li> \n <li>在获取到货币列表或者修改了最喜欢的货币之后，都会调用<code>notifyListeners()</code>方法发出通知。UI会接受到通知，并作出更新。</li> \n</ol> \n<p>在<strong>choose_favorites_viewmodel.dart</strong>文件还有另外的一个类：<code>FavoritePresentation</code>:</p> \n<pre><code class=\"dart\">class FavoritePresentation {\n  final String flag;\n  final String alphabeticCode;\n  final String longName;\n  bool isFavorite;\n\n  FavoritePresentation(\n      {this.flag, this.alphabeticCode, this.longName, this.isFavorite,});\n}</code></pre> \n<p>这个类就是为UI展示用的。这里尽量不保存任何与UI无关的内容。</p> \n<p>在<code>ChooseFavoritesViewModel</code>，用下面的代码替换掉<code>loadData()</code>方法</p> \n<pre><code class=\"dart\">void loadData() async {\n    final rates = await _currencyService.getAllExchangeRates();\n    _favorites = await _currencyService.getFavoriteCurrencies();\n    _prepareChoicePresentation(rates);\n    notifyListeners();\n  }\n\n  void _prepareChoicePresentation(List&lt;Rate&gt; rates) {\n    List&lt;FavoritePresentation&gt; list = [];\n    for (Rate rate in rates) {\n      String code = rate.quoteCurrency;\n      bool isFavorite = _getFavoriteStatus(code);\n      list.add(FavoritePresentation(\n        flag: IsoData.flagOf(code),\n        alphabeticCode: code,\n        longName: IsoData.longNameOf(code),\n        isFavorite: isFavorite,\n      ));\n    }\n    _choices = list;\n  }\n\n  bool _getFavoriteStatus(String code) {\n    for (Currency currency in _favorites) {\n      if (code == currency.isoCode)\n        return true;\n    }\n    return false;\n  }</code></pre> \n<p><code>loadData</code>获取一列汇率。接着，<code>_prepareChoicePresentation()</code>方法把列表转化成UI可以直接显示的格式。<code>_getFavoriteStatus()</code>决定了一个货币是否为最喜欢货币。</p> \n<p>接着使用下面的代码替换掉<code>toggleFavoriteStatus()</code>方法：</p> \n<pre><code class=\"dart\">void toggleFavoriteStatus(int choiceIndex) {\n    final isFavorite = !_choices[choiceIndex].isFavorite;\n    final code = _choices[choiceIndex].alphabeticCode;\n    _choices[choiceIndex].isFavorite = isFavorite;\n    if (isFavorite) {\n      _addToFavorites(code);\n    } else {\n      _removeFromFavorites(code);\n    }\n    notifyListeners();\n  }\n\n  void _addToFavorites(String alphabeticCode) {\n    _favorites.add(Currency(alphabeticCode));\n    _currencyService.saveFavoriteCurrencies(_favorites);\n  }\n\n  void _removeFromFavorites(String alphabeticCode) {\n    for (final currency in _favorites) {\n      if (currency.isoCode == alphabeticCode) {\n        _favorites.remove(currency);\n        break;\n      }\n    }\n    _currencyService.saveFavoriteCurrencies(_favorites);\n  }</code></pre> \n<p>只要这个方法被调用，view model就会调用货币服务保存新的最喜欢货币。同时因为<code>notifyListeners</code>方法也被调用了，所以UI也会立刻显示最新的修改。</p> \n<p>恭喜你，你已经完成了view model了。</p> \n<p>总结一下，你的view model类需要做的就是继承<code>ChangeNotifier</code>类并在需要更新UI的地方调用<code>notifyListeners()</code>方法。</p> \n<h2>Services</h2> \n<p>我们这里有三种service，分别是：汇率交换，存储以及网络请求。看下面的架构图，所有服务都在右边红色的框表示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263778\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ol> \n <li>创建一个抽象类，在里面添加所有会用到的方法</li> \n <li>给抽象类写一个具体的实现类</li> \n</ol> \n<p>因为每次创建一个service的方式都差不多，我们就用网络请求为例。初始项目中已经包含了<strong>汇率服务</strong>和<strong>存储服务</strong>了。</p> \n<h2>创建一个抽象service类</h2> \n<p>打开<strong>web_api.dart</strong>：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263771\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>你会看到如下的代码：</p> \n<pre><code class=\"dart\">import \'package:moolax/business_logic/models/rate.dart\';\n\nabstract class WebApi {\n  Future&lt;List&lt;Rate&gt;&gt; fetchExchangeRates();\n}</code></pre> \n<p>这是一个抽象类，所以它并不具体做什么。然而，它还是会反映出app需要它做什么：它应该从网络请求一串汇率回来。具体如何实现由你决定。</p> \n<h2>使用假数据</h2> \n<p>在<strong>web_api</strong>里，新建一个文件<strong>web_api_fake.dart</strong>。之后复制如下代码进去：</p> \n<pre><code class=\"dart\">import \'package:moolax/business_logic/models/rate.dart\';\nimport \'web_api.dart\';\n\nclass FakeWebApi implements WebApi {\n\n  @override\n  Future&lt;List&lt;Rate&gt;&gt; fetchExchangeRates() async {\n    List&lt;Rate&gt; list = [];\n    list.add(Rate(\n      baseCurrency: \'USD\',\n      quoteCurrency: \'EUR\',\n      exchangeRate: 0.91,\n    ));\n    list.add(Rate(\n      baseCurrency: \'USD\',\n      quoteCurrency: \'CNY\',\n      exchangeRate: 7.05,\n    ));\n    list.add(Rate(\n      baseCurrency: \'USD\',\n      quoteCurrency: \'MNT\',\n      exchangeRate: 2668.37,\n    ));\n    return list;\n  }\n\n}</code></pre> \n<p>这个类实现了抽象<code>WebApi</code>类，反回了某些写死的数据。现在你可以继续编写其他部分的代码了，网络请求的部分可以放心了。什么时候准备好了，可以回来实现真正的网络请求。</p> \n<h2>添加一个Service定位器</h2> \n<p>即使抽象类都实现了，你还是要告诉app去哪里找这些抽象类的具体实现类。</p> \n<p>有一个service定位器可以很快完成这个功能。一个service定位器是<a href=\"https://martinfowler.com/articles/injection.html\" rel=\"nofollow noreferrer\">一个依赖注入的替代</a>。它可以用来把一个service和app的其他部分解耦。</p> \n<p>在<code>ChooseFavoriatesViewModel</code>里有这么一行：</p> \n<pre><code class=\"dart\">final CurrencyService _currencyService = serviceLocator&lt;CurrencyService&gt;();</code></pre> \n<p><code>serviceLocator</code>是一个单例对象，它回到你用到的所有的service。</p> \n<p>在<strong>services</strong>目录下，打开<strong>service_locator.dart</strong>。你会看到下面的代码：</p> \n<pre><code class=\"dart\">// 1\nGetIt serviceLocator = GetIt.instance;\n\n// 2\nvoid setupServiceLocator() {\n\n  // 3\n  serviceLocator.registerLazySingleton&lt;StorageService&gt;(() =&gt; StorageServiceImpl());\n  serviceLocator.registerLazySingleton&lt;CurrencyService&gt;(() =&gt; CurrencyServiceFake());\n\n  // 4\n  serviceLocator.registerFactory&lt;CalculateScreenViewModel&gt;(() =&gt; CalculateScreenViewModel());\n  serviceLocator.registerFactory&lt;ChooseFavoritesViewModel&gt;(() =&gt; ChooseFavoritesViewModel());\n}</code></pre> \n<p>解释：</p> \n<ol> \n <li> <code>GetIt</code>是一个叫做<strong>get_it</strong>的service 定位包。这里已经预先添加到<code>pubspec.yaml</code>里了。<strong>get_it</strong>会通过一个全局的单例来保留所有注册的对象。</li> \n <li>这个方法就是用来注册服务的。在构建UI之前就需要调用这个方法了。</li> \n <li>你可以把你的服务注册为延迟加载的单例。注册为单例也就是说你每次取回的是同一个实例。注册为一个延迟加载的单例等于，在第一次使用的时候，只有在用的时候才会初始化。</li> \n <li>你也可以使用service定位器来注册view model。这样在UI里可以很容易拿到他们的引用。当然view models都是注册为一个factory了。每次取回来的都是一个新的view model实例。</li> \n</ol> \n<p>注意代码是在哪里调用<code>setupServiceLocator()</code>的。打开<strong>main.dart</strong>文件：</p> \n<pre><code class=\"dart\">void main() {\n  setupServiceLocator(); //              &lt;--- here\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: \'Moola X\',\n      theme: ThemeData(\n        primarySwatch: Colors.indigo,\n      ),\n      home: CalculateCurrencyScreen(),\n    );\n  }\n}</code></pre> \n<h2>注册FakeWebApi</h2> \n<p>现在来注册<code>FakeWebApi</code>。</p> \n<pre><code class=\"dart\">serviceLocator.registerLazySingleton&lt;WebApi&gt;(() =&gt; FakeWebApi());</code></pre> \n<p>使用<code>CurrencyServiceImpl</code>替换<code>CurrencyServiceFake</code>：</p> \n<pre><code class=\"dart\">serviceLocator.registerLazySingleton&lt;CurrencyService&gt;(() =&gt; CurrencyServiceImpl());</code></pre> \n<p>初始项目里使用了<code>CurrencyServiceFake</code>，这样才能运行起来。</p> \n<p>引入缺失的类：</p> \n<pre><code class=\"dart\">import \'web_api/web_api.dart\';\nimport \'web_api/web_api_fake.dart\';\nimport \'currency/currency_service_implementation.dart\';</code></pre> \n<p>运行app，点击右上角的心形。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263773\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>Web API的具体实现</h2> \n<p>前面注册了假的web api实现，app已经可以运行了。下面就需要从真的web服务器上获取真正的数据了。在<strong>services/web_api</strong>目录下，新建文件<strong>web_api_implementation.dart</strong>。添加如下的代码：</p> \n<pre><code class=\"dart\">import \'dart:convert\';\nimport \'package:http/http.dart\' as http;\nimport \'package:moolax/business_logic/models/rate.dart\';\nimport \'web_api.dart\';\n\n// 1\nclass WebApiImpl implements WebApi {\n  final _host = \'api.exchangeratesapi.io\';\n  final _path = \'latest\';\n  final Map&lt;String, String&gt; _headers = {\'Accept\': \'application/json\'};\n\n  // 2\n  List&lt;Rate&gt; _rateCache;\n\n  Future&lt;List&lt;Rate&gt;&gt; fetchExchangeRates() async {\n    if (_rateCache == null) {\n      print(\'getting rates from the web\');\n      final uri = Uri.https(_host, _path);\n      final results = await http.get(uri, headers: _headers);\n      final jsonObject = json.decode(results.body);\n      _rateCache = _createRateListFromRawMap(jsonObject);\n    } else {\n      print(\'getting rates from cache\');\n    }\n    return _rateCache;\n  }\n\n  List&lt;Rate&gt; _createRateListFromRawMap(Map jsonObject) {\n    final Map rates = jsonObject[\'rates\'];\n    final String base = jsonObject[\'base\'];\n    List&lt;Rate&gt; list = [];\n    list.add(Rate(baseCurrency: base, quoteCurrency: base, exchangeRate: 1.0));\n    for (var rate in rates.entries) {\n      list.add(Rate(baseCurrency: base,\n          quoteCurrency: rate.key,\n          exchangeRate: rate.value as double));\n    }\n    return list;\n  }\n}，</code></pre> \n<p>注意下面的几点：</p> \n<ol> \n <li>如同<code>FakeWebApi</code>，这个类也实现了<code>WebApi</code>。它包含了从<strong>api.exchangeratesapi.io</strong>获取数据的逻辑。然而，app的其他部分并不知道这一点，所以如果你想换到别的web api，毫无疑问这里就是你唯一可以更改的地方。</li> \n <li>exchangeratesapi.io慷慨的提供了给定数据的货币的汇率，都不要额外的token。</li> \n</ol> \n<p>打开<strong>service_localtor.dart</strong>，把<code>FakeWebApi()</code>修改为<code>WebApiImp()</code>，并更新对应的<em>import</em>语句。</p> \n<pre><code class=\"dart\">import \'web_api/web_api_implementation.dart\';\n\nvoid setupServiceLocator() {\n  serviceLocator.registerLazySingleton&lt;WebApi&gt;(() =&gt; WebApiImpl());\n  // ...\n}</code></pre> \n<h2>实现Provider</h2> \n<p>现在总算轮到Provider了。这篇怎么说也是一个Provider的教程!</p> \n<p>我们等了这么久才开始Provider的部分，你应该意识到了Provider其实是一个app的很小一部分。它只是用来方便在更改发生的时候方便把值传递给子widget，但也不是架构或者状态管理的系统。</p> \n<p>在<strong>pubspec.yaml</strong>里找到Provider包：</p> \n<pre><code class=\"dart\">dependencies:\n  provider: ^4.0.1</code></pre> \n<p>有一个比较特殊的Provider：<code>ChangeNotifierProvider</code>。它监听实现了<code>ChangeNotifier</code>的view model的修改。</p> \n<p>在<strong>ui/views</strong>目录下，打开<strong>choose_favorites.dart</strong>文件。这个文件的内容替换为如下的代码：</p> \n<pre><code class=\"dart\">import \'package:flutter/material.dart\';\nimport \'package:moolax/business_logic/view_models/choose_favorites_viewmodel.dart\';\nimport \'package:moolax/services/service_locator.dart\';\nimport \'package:provider/provider.dart\';\n\nclass ChooseFavoriteCurrencyScreen extends StatefulWidget {\n  @override\n  _ChooseFavoriteCurrencyScreenState createState() =&gt;\n      _ChooseFavoriteCurrencyScreenState();\n}\n\nclass _ChooseFavoriteCurrencyScreenState\n    extends State&lt;ChooseFavoriteCurrencyScreen&gt; {\n\n  // 1\n  ChooseFavoritesViewModel model = serviceLocator&lt;ChooseFavoritesViewModel&gt;();\n\n  // 2\n  @override\n  void initState() {\n    model.loadData();\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\'Choose Currencies\'),\n      ),\n      body: buildListView(model),\n    );\n  }\n\n  // Add buildListView() here.\n}</code></pre> \n<p>你会发现<code>buildListView()</code>方法，注意如下的更改：</p> \n<ol> \n <li>servie定位器返回一个view model的实例</li> \n <li>使用<code>StatefulWidget</code>,它包含了<code>initState()</code>方法。这里你可以告诉view model加载货币数据。</li> \n</ol> \n<p>在<code>build()</code>方法下，添加如下的<code>buildListView()</code>实现：</p> \n<pre><code class=\"dart\">Widget buildListView(ChooseFavoritesViewModel viewModel) {\n    // 1\n    return ChangeNotifierProvider&lt;ChooseFavoritesViewModel&gt;(\n      // 2\n      create: (context) =&gt; viewModel,\n      // 3\n      child: Consumer&lt;ChooseFavoritesViewModel&gt;(\n        builder: (context, model, child) =&gt; ListView.builder(\n          itemCount: model.choices.length,\n          itemBuilder: (context, index) {\n            return Card(\n              child: ListTile(\n                leading: SizedBox(\n                  width: 60,\n                  child: Text(\n                    \'${model.choices[index].flag}\',\n                    style: TextStyle(fontSize: 30),\n                  ),\n                ),\n                // 4\n                title: Text(\'${model.choices[index].alphabeticCode}\'),\n                subtitle: Text(\'${model.choices[index].longName}\'),\n                trailing: (model.choices[index].isFavorite)\n                    ? Icon(Icons.favorite, color: Colors.red)\n                    : Icon(Icons.favorite_border),\n                onTap: () {\n                  // 5\n                  model.toggleFavoriteStatus(index);\n                },\n              ),\n            );\n          },\n        ),\n      ),\n    );\n  }</code></pre> \n<p>代码解析：</p> \n<ol> \n <li>添加<code>ChangeNotifierProvider</code>，一个特殊类型的provider，它监听了来自view model的修改。</li> \n <li> <code>ChangeNotifierProvider</code>有一个<code>create</code>方法。这个方法给子wdiget提供了view model值。在这里你已经有了view model的引用，那就直接使用。</li> \n <li> <code>Consumer</code>，当view model的<code>notifyListeners()</code>告知更改发生的时候重新build界面。Consumer的builder方法向下传递了view model值。这个view model是从<code>ChangeNotifierProvider</code>传下来的。</li> \n <li>使用<code>model</code>里的数据来重新build界面。注意UI里只有很少的逻辑。</li> \n <li>既然你有了view model的引用，那么完全可以调用里面的方法。<code>toggleFavoriteStatus()</code>调用了<code>notifyListeners()</code>。</li> \n</ol> \n<p>再次运行app。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263772\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>在大型app中使用Provider</h2> \n<p>你可以按照本文所述的方式添加更多的界面。一旦你习惯了为每个界面添加view model就可以考虑为某些类创建基类来减少重复代码。本文没有这么做，因为这样的话理解这些代码要花更多的时间。</p> \n<h2>其他的架构和状态管理方法</h2> \n<p>如果你不喜欢本文所述的架构，可以考虑BLoC模式。<a href=\"https://www.raywenderlich.com/4074597-getting-started-with-the-bloc-pattern\" rel=\"nofollow noreferrer\">BLoC模式入门</a>也是一个很好的起点。你会发现BLoC模式也不像传说的那么难以理解。</p> \n<p>还有<a href=\"https://flutter.dev/docs/development/data-and-backend/state-mgmt/options\" rel=\"nofollow noreferrer\">其他</a>的，不过Provider和BLoC是目前最普遍采用的。</p>', 'https://segmentfault.com/img/remote/1460000022263766', null, null, '0', '0', null, '1', '2020-04-14 20:58:24', '2020-04-14 20:58:24');
INSERT INTO `tb_recommend` VALUES ('eb4f3e72788d4f2d9d3619a69d0e79ca', 'Python正则表达式，这一篇就够了！', '大多数编程语言的正则表达式设计都师从Perl，所以语法基本相似，不同的是每种语言都有自己的函数去支持正则，今天我们就来学习 Python中关于 正则表达式的函数。re模块主要定义了9个常量、12个函数、1个异常，每...', '<p>之前我们讲解了 <a href=\"https://segmentfault.com/a/1190000021787021\">正则表达式语法</a> 的起源、发展、流派、语法、引擎、优化等相关知识，今天我们主要来学习一下 <strong>正则表达式在 Python语言 中的应用</strong>！</p> \n<p>大多数编程语言的正则表达式设计都师从Perl，所以语法基本相似，不同的是每种语言都有自己的函数去支持正则，今天我们就来学习 Python中关于 正则表达式的函数。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242430\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>re模块主要定义了9个常量、12个函数、1个异常，每个常量和函数猪哥都会通过实际代码案例讲解，让大家能更直观的了解其作用！</p> \n<p>注：为避免出现代码格式错乱，猪哥尽量使用代码截图演示哦。</p> \n<h2>一、re模块简介</h2> \n<p>聊到Python正则表达式的支持，首先肯定会想到<code>re</code>库，这是一个Python处理文本的<strong>标准库</strong>。</p> \n<blockquote> \n <strong>标准库</strong>的意思表示这是一个\n <strong>Python内置模块</strong>，不需要额外下载，目前Python内置模块大概有300个。可以在这里查看Python所有的内置模块：\n <a href=\"https://docs.python.org/3/py-modindex.html#cap-r\" rel=\"nofollow noreferrer\">https://docs.python.org/3/py-...</a> \n</blockquote> \n<p>因为re是内置模块，所以不需要再下载，使用时直接引入即可：</p> \n<pre><code class=\"python\">import re</code></pre> \n<p>re模块官方文档：<a href=\"https://docs.python.org/zh-cn/3.8/library/re.html\" rel=\"nofollow noreferrer\">https://docs.python.org/zh-cn...</a><br>re模块库源码：<a href=\"https://github.com/python/cpython/blob/3.8/Lib/re.py\" rel=\"nofollow noreferrer\">https://github.com/python/cpy...</a></p> \n<h2>二、re模块常量</h2> \n<p>常量即表示不可更改的变量，一般用于做标记。</p> \n<p>re模块中有9个常量，常量的值都是int类型！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242436\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>上图我们可以看到，所有的常量都是在<strong>RegexFlag枚举类</strong>来实现，这是在Python 3.6做的改版。在Python 3.6以前版本是直接将常量写在re.py中，使用枚举的好处就是方便管理和使用！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242435\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>下面我们来快速学习这些常量的作用及如何使用他们，按常用度排序！</p> \n<h3>1. IGNORECASE</h3> \n<p><strong>语法：</strong> re.IGNORECASE 或简写为 re.I</p> \n<p><strong>作用：</strong> 进行忽略大小写匹配。</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242431\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>在默认匹配模式下<strong>大写字母B</strong>无法匹配<strong>小写字母b</strong>，而在 忽略大小写 模式下是可以的。</p> \n<h3>2. ASCII</h3> \n<p><strong>语法：</strong> re.ASCII 或简写为 re.A</p> \n<p><strong>作用：</strong> 顾名思义，ASCII表示ASCII码的意思，让 <code>\\w</code>, <code>\\W</code>, <code>\\b</code>, <code>\\B</code>, <code>\\d</code>, <code>\\D</code>, <code>\\s</code> 和 <code>\\S</code> 只匹配ASCII，而不是Unicode。</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242441\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>在默认匹配模式下<code>\\w+</code>匹配到了所有字符串，而在<strong>ASCII</strong>模式下，只匹配到了a、b、c（ASCII编码支持的字符）。</p> \n<p>注意：这只对字符串匹配模式有效，对字节匹配模式无效。</p> \n<h3>3. DOTALL</h3> \n<p><strong>语法：</strong> re.DOTALL 或简写为 re.S</p> \n<p><strong>作用：</strong> DOT表示<code>.</code>，ALL表示所有，连起来就是<code>.</code>匹配所有，包括换行符<code>\\n</code>。<strong>默认模式下<code>.</code>是不能匹配行符<code>\\n</code>的</strong>。</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242434\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>在默认匹配模式下<code>.</code>并没有匹配换行符<code>\\n</code>，而是将字符串分开匹配；而在<strong>re.DOTALL</strong>模式下，换行符<code>\\n</code>与字符串一起被匹配到。</p> \n<p>注意：<strong>默认匹配模式下<code>.</code>并不会匹配换行符<code>\\n</code></strong>。</p> \n<h3>4. MULTILINE</h3> \n<p><strong>语法：</strong> re.MULTILINE 或简写为 re.M</p> \n<p><strong>作用：</strong> 多行模式，当某字符串中有换行符<code>\\n</code>，默认模式下是不支持换行符特性的，比如：行开头 和 行结尾，而多行模式下是支持匹配行开头的。</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242433\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>正则表达式中<code>^</code>表示匹配行的开头，默认模式下它只能匹配字符串的开头；而在多行模式下，它还可以匹配 换行符<code>\\n</code>后面的字符。</p> \n<p>注意：正则语法中<code>^</code>匹配行开头、<code>\\A</code>匹配字符串开头，单行模式下它两效果一致，多行模式下<code>\\A</code>不能识别<code>\\n</code>。</p> \n<h3>5. VERBOSE</h3> \n<p><strong>语法：</strong> re.VERBOSE 或简写为 re.X</p> \n<p><strong>作用：</strong> 详细模式，可以在正则表达式中加注解！</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242442\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>默认模式下并不能识别正则表达式中的注释，而详细模式是可以识别的。</p> \n<p>当一个正则表达式十分复杂的时候，详细模式或许能为你提供另一种注释方式，但它不应该成为炫技的手段，建议谨慎考虑后使用！</p> \n<h3>6.LOCALE</h3> \n<p><strong>语法：</strong> re.LOCALE 或简写为 re.L </p> \n<p><strong>作用：</strong> 由当前语言区域决定 <code>\\w</code>, <code>\\W</code>, <code>\\b</code>, <code>\\B</code> 和大小写敏感匹配，这个标记只能对byte样式有效。<strong>这个标记官方已经不推荐使用</strong>，因为语言区域机制很不可靠，它一次只能处理一个 \"习惯”，而且只对8位字节有效。</p> \n<p><strong>注意：</strong> 由于这个标记官方已经不推荐使用，而且猪哥也没使用过，所以就不给出实际的案例！</p> \n<h3>7.UNICODE</h3> \n<p><strong>语法：</strong> re.UNICODE 或简写为 re.U</p> \n<p><strong>作用：</strong> 与 ASCII 模式类似，匹配unicode编码支持的字符，但是 Python 3 默认字符串已经是Unicode，所以有点冗余。</p> \n<h3>8. DEBUG</h3> \n<p><strong>语法：</strong> re.DEBUG </p> \n<p><strong>作用：</strong> 显示编译时的debug信息。</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242443\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>虽然debug模式下确实会打印编译信息，但猪哥并不理解这是什么语言 以及表达的含义，<strong>希望了解的朋友能不吝赐教。</strong></p> \n<h3>9.TEMPLATE</h3> \n<p><strong>语法：</strong> re.TEMPLATE 或简写为 re.T</p> \n<p><strong>作用：</strong> 猪哥也没搞懂TEMPLATE的具体用处，源码注释中写着：disable backtracking(禁用回溯)，有了解的同学可以留言告知！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242432\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h3>10. 常量总结</h3> \n<ol> \n <li>9个常量中，前5个（IGNORECASE、ASCII、DOTALL、MULTILINE、VERBOSE）有用处，两个（LOCALE、UNICODE）官方不建议使用、两个（TEMPLATE、DEBUG）试验性功能，不能依赖。</li> \n <li>常量在re常用函数中都可以使用，查看源码可得知。<span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242444\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span> </li> \n <li>常量可叠加使用，因为常量值都是2的幂次方值，所以是可以叠加使用的，叠加时请使用 <code>|</code> 符号，请勿使用<code>+</code> 符号！<span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242445\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span> </li> \n</ol> \n<p>最后来一张思维导图总结一下re模块中的常量吧。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242438\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h2>三、re模块函数</h2> \n<p>re模块有12个函数，猪哥将以功能分类来讲解；这样更具有比较性，同时也方便记忆。</p> \n<h3>1.查找一个匹配项</h3> \n<p>查找并返回一个匹配项的函数有3个：<strong>search、match、fullmatch</strong>，他们的区别分别是：</p> \n<ol> \n <li> <strong>search：</strong> 查找任意位置的匹配项</li> \n <li> <strong>match：</strong> 必须从字符串开头匹配</li> \n <li> <strong>fullmatch：</strong> 整个字符串与正则完全匹配</li> \n</ol> \n<p>我们再来根据实际的代码案例比较：</p> \n<p><strong>案例1:</strong><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242437\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>案例1中<strong>search函数</strong>是在字符串中任意位置匹配，只要有符合正则表达式的字符串就匹配成功，其实有两个匹配项，但search函数值返回一个。</p> \n<p>而<strong>match函数</strong>是要从头开始匹配，而字符串开头多了个字母<code>a</code>，所以无法匹配，<strong>fullmatch函数</strong>需要完全相同，故也不匹配！</p> \n<p><strong>案例2:</strong><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242439\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>案例2删除了text最开头的字母a，这样<strong>match函数</strong>就可以匹配啦，而<strong>fullmatch函数</strong>依然不能完全匹配！</p> \n<p><strong>案例3:</strong><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242440\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>案例3中，我们只留下一段文字，并且与正则表达式一致；这时<strong>fullmatch函数</strong>终于可以匹配了。</p> \n<p><strong>完整案例：</strong><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242455\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><strong>注意：查找 一个匹配项 返回的都是一个匹配对象（Match）。</strong></p> \n<h3>2.查找多个匹配项</h3> \n<p>讲完查找一项，现在来看看查找多项吧，查找多项函数主要有：<strong>findall函数</strong> 与 <strong>finditer函数</strong>：</p> \n<ol> \n <li> <strong>findall：</strong> 从字符串任意位置查找，<strong>返回一个列表</strong> </li> \n <li> <strong>finditer</strong>：从字符串任意位置查找，<strong>返回一个迭代器</strong> </li> \n</ol> \n<p>两个方法基本类似，只不过一个是返回列表，一个是返回迭代器。我们知道列表是一次性生成在内存中，而迭代器是需要使用时一点一点生成出来的，内存使用更优。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242446\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>如果可能存在大量的匹配项的话，建议使用<strong>finditer函数</strong>，一般情况使用<strong>findall函数</strong>基本没啥影响。</p> \n<h3>3.分割</h3> \n<p><strong>re.split(pattern, string, maxsplit=0, flags=0)</strong> 函数：用 <strong>pattern</strong> 分开 string ， <strong>maxsplit</strong>表示最多进行分割次数， <strong>flags</strong>表示模式，就是上面我们讲解的常量！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242448\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><strong>注意：<code>str</code>模块也有一个 split函数 ，那这两个函数该怎么选呢？</strong><br>str.split函数功能简单，不支持正则分割，而re.split支持正则。</p> \n<p><strong>关于二者的速度如何？</strong> 猪哥实际测试一下，在相同数据量的情况下使用<code>re.split</code>函数与<code>str.split</code>函数<strong>执行次数</strong> 与 <strong>执行时间</strong> 对比图：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242447\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>通过上图对比发现，1000次循环以内<code>str.split</code>函数更快，而循环次数1000次以上后<code>re.split</code>函数明显更快，而且次数越多差距越大！</p> \n<p><strong>所以结论是：在 不需要正则支持 且 数据量和数次不多 的情况下使用<code>str.split</code>函数更合适，反之则使用<code>re.split</code>函数。</strong></p> \n<p>注：具体执行时间与测试数据有关！</p> \n<h3>4.替换</h3> \n<p>替换主要有<strong>sub函数</strong> 与 <strong>subn函数</strong>，他们功能类似！</p> \n<p>先来看看<strong>sub函数</strong>的用法：</p> \n<p><strong>re.sub(pattern, repl, string, count=0, flags=0)</strong> 函数参数讲解：repl替换掉string中被pattern匹配的字符， count表示最大替换次数，flags表示正则表达式的常量。</p> \n<p>值得注意的是：<strong>sub函数</strong>中的入参：<strong>repl替换内容既可以是字符串，也可以是一个函数哦！</strong> 如果repl为函数时，只能有一个入参：Match匹配对象。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242450\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p><strong>re.subn(pattern, repl, string, count=0, flags=0)</strong> 函数与 <strong>re.sub函数</strong> 功能一致，只不过返回一个元组 (字符串, 替换次数)。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242449\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h3>5.编译正则对象</h3> \n<p><strong>compile函数</strong> 与 <strong>template函数</strong> 将正则表达式的样式编译为一个 正则表达式对象 （正则对象Pattern），这个对象与re模块有同样的正则函数（后面我们会讲解Pattern正则对象）。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242451\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>而<strong>template函数</strong> 与 <strong>compile函数</strong> 类似，只不过是增加了我们之前说的<strong>re.TEMPLATE</strong> 模式，我们可以看看源码。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242452\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h3>6.其他</h3> \n<p><strong>re.escape(pattern)</strong> 可以转义正则表达式中具有特殊含义的字符，比如：<code>.</code> 或者 <code>*</code> ，举个实际的案例：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242453\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><strong>re.escape(pattern)</strong> 看似非常好用省去了我们自己加转义，但是使用它很容易出现转义错误的问题，所以并不建议使用它转义，<strong>而建议大家自己手动转义！</strong></p> \n<p><strong>re.purge()</strong> 函数作用就是清除 <strong>正则表达式缓存</strong>，具体有什么缓存呢？我们来看看源码就知道它背地里干了 什么：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242454\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>看方法大概是清除缓存吧，我们再来看看具体的案例：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242456\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>猪哥在两个案例之间使用了<strong>re.purge()</strong> 函数清除缓存，然后分别比较前后案例源码里面的缓存，看看是否有变化！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242457\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h3>7.总结</h3> \n<p>同样最后来一张思维导图总结一下re模块中的函数吧。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242459\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h2>四、re模块异常</h2> \n<p>re模块还包含了一个正则表达式的编译错误，当我们给出的<strong>正则表达式是一个无效的表达式</strong>（就是表达式本身有问题）时，就会raise一个异常！</p> \n<p>我们来看看具体的案例吧：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242458\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>上图案例中我们可以看到，在编写正则表达式中我们多写了一个括号，这导致执行结果报错；而且是在其他所有案例执行之前，所以说明是在正则表达式编译时期就报错了。</p> \n<p>注意：这个异常一定是 正则表达式 本身是无效的，与要匹配的字符串无关！</p> \n<h2>五、正则对象Pattern</h2> \n<p>关于<code>re</code>模块的常量、函数、异常我们都讲解完毕，但是完全有必要再讲讲<strong>正则对象Pattern</strong>。</p> \n<h3>1. 与re模块 函数一致</h3> \n<p>在<code>re</code>模块的函数中有一个重要的函数 <strong>compile函数</strong> ，这个函数可以预编译返回一个正则对象，此正则对象拥有与<code>re</code>模块相同的函数，我们来看看<strong>Pattern类</strong>的源码。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242460\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>既然是一致的，那到底该用<strong>re模块</strong> 还是 <strong>正则对象Pattern</strong> ？</p> \n<p>而且，有些同学可能看过<code>re</code>模块的源码，你会发现其实<strong>compile函数</strong> 与 其他 <strong>re函数</strong>（search、split、sub等等） 内部调用的是同一个函数，最终还是调用正则对象的函数！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242461\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>也就是说下面 两种代码写法 底层实现 其实是一致的：</p> \n<pre><code class=\"python\"># re函数\nre.search(pattern, text)\n\n# 正则对象函数\ncompile = re.compile(pattern)\ncompile.search(text)</code></pre> \n<p>那还有必要使用<strong>compile函数</strong> 得到正则对象再去调用 <strong>search函数</strong> 吗？直接调用re.search 是不是就可以？</p> \n<h3>2. 官方文档怎么说</h3> \n<p>关于到底该用<strong>re模块</strong> 还是 <strong>正则对象Pattern</strong> ，官方文档是否有说明呢？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242463\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>官方文档推荐：<strong>在多次使用某个正则表达式时推荐使用正则对象Pattern</strong> 以增加复用性，因为通过 <strong>re.compile(pattern)</strong> 编译后的模块级函数会被缓存！</p> \n<h3>3. 实际测试又如何？</h3> \n<p>上面官方文档推荐我们在 <strong>多次使用某个正则表达式时使用正则对象</strong>，那实际情况真的是这样的吗？</p> \n<p>我们在实测一下吧</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242462\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>猪哥编写了两个函数，一个使用<strong>re.search函数</strong> 另一个使用 <strong>compile.search函数</strong> ，分别(不同时)循环执行<strong>count次</strong>(count从1-1万)，比较两者的耗时！</p> \n<p>得出的结果猪哥绘制成折线图：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242464\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>得出的结论是：100次循环以内两者的速度基本一致，当超出100次后，使用 <strong>正则对象Pattern</strong> 的函数 耗时明显更短，所以比<strong>re模块</strong> 要快！</p> \n<p>通过实际测试得知：Python 官方文档推荐 <strong>多次使用某个正则表达式时使用正则对象函数</strong> 基本属实！</p> \n<h2>六、注意事项</h2> \n<p>Python 正则表达式知识基本讲解完毕，最后稍微给大家提一提需要注意的点。</p> \n<h3>1.字节串 与 字符串</h3> \n<p>模式和被搜索的字符串既可以是 Unicode 字符串 (str) ，也可以是8位字节串 (bytes)。 但是，Unicode 字符串与8位字节串不能混用！</p> \n<h3>2.r 的作用</h3> \n<p>正则表达式使用反斜杠（\'\'）来表示特殊形式，或者把特殊字符转义成普通字符。 </p> \n<p>而反斜杠在普通的 Python 字符串里也有相同的作用，所以就产生了冲突。</p> \n<p>解决办法是对于正则表达式样式使用 Python 的原始字符串表示法；在带有 \'r\' 前缀的字符串字面值中，反斜杠不必做任何特殊处理。</p> \n<h3>3.正则查找函数 返回匹配对象</h3> \n<p>查找一个匹配项（search、match、fullmatch）的函数返回值都是一个 <strong>匹配对象Match</strong> ，需要通过<strong>match.group()</strong> 获取匹配值，这个很容易忘记。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242465\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>另外还需要注意：<strong>match.group()</strong> 与<strong>match.groups()</strong> 函数的差别！</p> \n<h3>4.重复使用某个正则</h3> \n<p>如果要重复使用某个正则表达式，推荐先使用 <strong>re.compile(pattern)函数</strong> 返回一个正则对象，然后复用这个正则对象，这样会更快！</p> \n<h3>5.Python 正则面试</h3> \n<p>笔试可能会遇到需要使用Python正则表达式，不过不会太难的，大家只要记住那几个方法的区别，会正确使用，基本问题不大。</p>', 'https://segmentfault.com/img/remote/1460000022242430', null, null, '0', '0', null, '1', '2020-04-14 20:58:26', '2020-04-14 20:58:26');
INSERT INTO `tb_recommend` VALUES ('fc3d6ab92b1a4546a23c5001c9d0596d', 'core-js 作者入狱 18 个月，周下载 2600 万次的开源项目恐将无人维护', '俄罗斯开发者丹尼斯·普什卡列夫（Denis Pushkarev）是 JavaScript 的模块化标准库 Core-js 的唯一维护人员。去年 10 月，其因驾驶摩托车时撞到了两位行人并造成其中一人死亡，上诉无效后，最终被判处 18 个月有期...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFwal\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>俄罗斯开发者丹尼斯·普什卡列夫（Denis Pushkarev）是 JavaScript 的模块化标准库 Core-js 的唯一维护人员。去年 10 月，其因驾驶摩托车时撞到了两位行人并造成其中一人死亡，上诉无效后，最终被判处 18 个月有期徒刑。</p> \n<p>那么，这 18 个月谁能替他来维护这个库？</p> \n<h2>周下载量 2600 万次的 core-js</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFv91\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>尽管周下载量达到惊人的 2600 万次，但该项目的知名度似乎与其的使用程度并不匹配。这里引用思否社区技术专家 <a href=\"/u/justjavac\">@justjavac</a> 在相关问题中的一个回复：</p> \n<blockquote>\n 现在 react/vue/angular，webpack，babel、core-js 等已经是前端的基础设施，但是 core-js 的存在感太弱了。core-js 在 npm 的下载量比 react/vue/angular 的总和还要多几倍。然而几乎所有前端开发者就算没有使用过也都听说过 3 大框架。至于 core-js 就尴尬了，很多两三年从业经历的前端开发者都不一定听说过这个库。\n</blockquote> \n<p>不仅如此，从 npmjs.com 上我们能看到，总共有 19279 个 Package 依赖 core-js。可见该项目的重要程度。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFwcQ\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<h2>该项目最终将何去何从？</h2> \n<p>对于这种情况，GitHub 社区与安全高级产品经理本·巴尔特（Ben Balter）表示，在项目维护者不响应的情况下，该公司将继续考虑回购所有权的转移。Balter 说：“在一种首选的情况下，我们要确保提前主动缓解问题。”同时还表示，“我们鼓励维护者将受欢迎的项目从他们的个人帐户转移到组织中。除了获得高级社区管理功能之外，添加至少一名其他维护者作为共同所有者进一步确保了该项目能够继续进行，即使一个维护者是无法使用。”</p> \n<p>Balter 还表示，GitHub 拥有在生病时转移帐户所有权的流程，适用于亲戚，合作者，同事和业务合作伙伴。他说，GitHub 提供了某种应急迁移流程，fork 不活动的代码库也是其中的一个选项。他还指出，如果 GitHub 可以接管项目的规范资源，则它有可能重新定位。</p> \n<p>目前该项目还处于无人维护的装填，但项目的一位贡献者 slowcheetah 表示他可以有一些时间来修复关键错误和重大更新，并且显示他具备「合作者」的权限。</p> \n<h2>永远在求职的开源大佬</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFwju\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>项目这么受欢迎，尤其还是一个人独立维护，Pushkarev 绝对称得上 GitHub 大佬了。但这位大佬的 GitHub 个人主页的状态仍然是“Looking for a good job.”</p> \n<p>并且，早在去年 5 月发生车祸之后，他还曾提出通过在库中加入广告从而增加收入，因为他觉得自己需要额外的收入来支付车祸相关的法律和医疗费用。</p> \n<blockquote> \n <strong>参考链接：</strong>\n <p><a href=\"https://www.theregister.co.uk/2020/03/26/corejs_maintainer_jailed_code_release/\" rel=\"nofollow noreferrer\">https://www.theregister.co.uk...</a></p> \n <p>丹尼斯·普什卡列夫（Denis Pushkarev）个人网站： <a href=\"https://vk.com/xrock\" rel=\"nofollow noreferrer\">https://vk.com/xrock</a></p> \n <p>《What happens when the maintainer of a JS library downloaded 26m times<br>a week goes to prison for killing someone with a motorbike? Core-js<br>just found out》<br><a href=\"https://www.theregister.co.uk/2020/03/26/corejs_maintainer_jailed_code_release/\" rel=\"nofollow noreferrer\">https://www.theregister.co.uk...</a></p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sf.png\" title=\"sf.png\"></span></p>', 'https://segmentfault.com/img/bVbFwal', null, null, '0', '0', null, '1', '2020-04-14 20:58:25', '2020-04-14 20:58:25');

-- ----------------------------
-- Table structure for tb_users
-- ----------------------------
DROP TABLE IF EXISTS `tb_users`;
CREATE TABLE `tb_users` (
  `uuid` varchar(50) NOT NULL,
  `nickname` varchar(10) DEFAULT NULL COMMENT '昵称',
  `password` varchar(50) DEFAULT NULL COMMENT '密码',
  `username` varchar(10) DEFAULT NULL COMMENT '真实姓名',
  `phone` varchar(11) DEFAULT NULL COMMENT '手机号码',
  `website` varchar(50) DEFAULT NULL COMMENT '个人网站',
  `email` varchar(50) DEFAULT NULL COMMENT '邮箱',
  `image_url` varchar(255) DEFAULT NULL COMMENT '头像',
  `location_city` varchar(10) DEFAULT NULL COMMENT '所在城市',
  `address` varchar(50) DEFAULT NULL COMMENT '通讯地址',
  `resume_description` varchar(255) DEFAULT NULL COMMENT '履历说明',
  `good_at_technology` varchar(255) DEFAULT NULL COMMENT '擅长技术（逗号隔开）',
  `description` varchar(255) DEFAULT NULL COMMENT '个人简介',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表';

-- ----------------------------
-- Records of tb_users
-- ----------------------------
INSERT INTO `tb_users` VALUES ('6d86ce8599a94f12ad1191fa38797771', '哈哈哈1', 'e10adc3949ba59abbe56e057f20f883e', null, '18588773301', null, null, null, null, null, null, null, null, null, null);
INSERT INTO `tb_users` VALUES ('ab6384d237e645c8a5afbb8f4c8aaead', '哈哈哈', 'e10adc3949ba59abbe56e057f20f883e', null, '18588773304', null, null, null, null, null, null, null, null, null, null);
INSERT INTO `tb_users` VALUES ('d6754affc7864ea9b67b61e493d28614', '12', 'fcea920f7412b5da7be0cf42b8c93759', null, '18588773302', null, null, null, null, null, null, null, null, '2020-04-10 13:51:26', '2020-04-10 13:51:26');

-- ----------------------------
-- Table structure for tb_users_info
-- ----------------------------
DROP TABLE IF EXISTS `tb_users_info`;
CREATE TABLE `tb_users_info` (
  `uuid` varchar(50) NOT NULL,
  `name` varchar(20) DEFAULT NULL COMMENT '名称',
  `name_sub` varchar(20) DEFAULT NULL COMMENT '子标题',
  `start_time` datetime DEFAULT NULL COMMENT '开始时间',
  `end_time` datetime DEFAULT NULL COMMENT '结束时间',
  `is_time` bit(1) DEFAULT NULL COMMENT '判断结束时间是否要填',
  `city` varchar(50) DEFAULT NULL COMMENT '所在城市',
  `label_id` varchar(255) DEFAULT NULL COMMENT '标签id',
  `desc` varchar(255) DEFAULT NULL COMMENT '描述',
  `type` int(1) DEFAULT NULL COMMENT '1、工作经历 2、教育经历 3、开源项目',
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户信息表(工作经历,教育经历,开源项目 & 文章著作)';

-- ----------------------------
-- Records of tb_users_info
-- ----------------------------
