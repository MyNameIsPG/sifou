/*
Navicat MySQL Data Transfer

Source Server         : localhost
Source Server Version : 50562
Source Host           : localhost:3306
Source Database       : bbs_sifou

Target Server Type    : MYSQL
Target Server Version : 50562
File Encoding         : 65001

Date: 2020-04-17 16:34:57
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for tb_channels
-- ----------------------------
DROP TABLE IF EXISTS `tb_channels`;
CREATE TABLE `tb_channels` (
  `uuid` varchar(50) NOT NULL,
  `name` varchar(10) DEFAULT NULL COMMENT '名称',
  `url` varchar(50) DEFAULT NULL COMMENT '地址',
  `icon_url` varchar(255) DEFAULT NULL COMMENT '图标',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='频道表';

-- ----------------------------
-- Records of tb_channels
-- ----------------------------
INSERT INTO `tb_channels` VALUES ('04547238127a4676b504cc4496865d7b', '安全', 'netsec', '', '2020-04-14 09:23:09', '2020-04-14 09:23:09');
INSERT INTO `tb_channels` VALUES ('049b3bd76c1e49ccbe48b36197e77f76', '前端', 'frontend', '', '2020-04-08 16:42:59', '2020-04-10 11:33:53');
INSERT INTO `tb_channels` VALUES ('19eb3dd59ef8430d9f637d97449fc417', '开源', 'oss', '', '2020-04-14 09:23:41', '2020-04-14 09:23:41');
INSERT INTO `tb_channels` VALUES ('1a7cc9fbc4654cb0afec84e080816ef1', '游戏', 'game', '', '2020-04-14 09:22:59', '2020-04-14 09:22:59');
INSERT INTO `tb_channels` VALUES ('2a353971222c4aff8e8d3e9c370330cd', '工具', 'toolkit', '', '2020-04-14 09:23:54', '2020-04-14 09:23:54');
INSERT INTO `tb_channels` VALUES ('3798854967b444e0b8156e5154f94b97', '区块链', 'bc', '', '2020-04-14 09:23:31', '2020-04-14 09:23:31');
INSERT INTO `tb_channels` VALUES ('7b3e40f8b9cc4b7780dc39a71d7f580e', '小程序', 'miniprogram', '', '2020-04-08 16:43:43', '2020-04-08 16:43:43');
INSERT INTO `tb_channels` VALUES ('819ad72c1efe450f9d7affc135a4b457', 'Android', 'android', '', '2020-04-14 09:22:31', '2020-04-14 09:22:31');
INSERT INTO `tb_channels` VALUES ('91832bd0c3a244fb88c0bca74c0d404d', '程序员', 'programmer', '', '2020-04-14 09:24:04', '2020-04-14 09:24:04');
INSERT INTO `tb_channels` VALUES ('a0ea520851b4484f9cebac9ff7e47bc6', '金融科技', 'fintech', '', '2020-04-14 09:23:17', '2020-04-14 09:23:17');
INSERT INTO `tb_channels` VALUES ('a2718d66a7234b1499ed897ff4df05c8', '行业', 'industry', '', '2020-04-14 09:24:15', '2020-04-14 09:24:15');
INSERT INTO `tb_channels` VALUES ('a337904dd1d5477b9689d7693be316de', 'IOS', 'ios', '', '2020-04-14 09:22:11', '2020-04-14 09:22:11');
INSERT INTO `tb_channels` VALUES ('b299a2a48cd64e77a3431ce958b42055', '云计算', 'cloud', '', '2020-04-14 09:22:49', '2020-04-14 09:22:49');
INSERT INTO `tb_channels` VALUES ('bb0b7e69ad3e46fcb121baefda8f1f78', '后端', 'backend', '', '2020-04-08 16:43:25', '2020-04-08 16:43:25');
INSERT INTO `tb_channels` VALUES ('cbad2058b4014634aec6515f4adbef0d', 'AI', 'ai', '', '2020-04-14 09:22:41', '2020-04-14 09:22:41');
INSERT INTO `tb_channels` VALUES ('ee1accc0cfb444fa96d6811569830ecd', '其它', '', '', '2020-04-16 15:30:16', '2020-04-16 15:30:16');

-- ----------------------------
-- Table structure for tb_comment
-- ----------------------------
DROP TABLE IF EXISTS `tb_comment`;
CREATE TABLE `tb_comment` (
  `uuid` varchar(50) NOT NULL,
  `recommend_id` varchar(50) DEFAULT NULL COMMENT '文章id/问答id',
  `user_id` varchar(50) DEFAULT NULL COMMENT '用户id',
  `like_number` int(9) DEFAULT '0' COMMENT '点赞数',
  `content` varchar(255) DEFAULT NULL COMMENT '评论内容',
  `create_time` datetime DEFAULT NULL,
  `parent_id` varchar(50) DEFAULT NULL COMMENT '父级id',
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='评论主表';

-- ----------------------------
-- Records of tb_comment
-- ----------------------------
INSERT INTO `tb_comment` VALUES ('30e30671ffb04f12b5047753bca66f52', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是评论4', '2020-04-14 15:34:51', '');
INSERT INTO `tb_comment` VALUES ('47a7bc7cf5ca481fb9785bac2db8251c', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是评论3', '2020-04-14 15:34:43', '');
INSERT INTO `tb_comment` VALUES ('728a0954563542ae9e38108669de6ccf', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-1', '2020-04-14 15:35:23', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('7615021c3af346e791516fc443b03cc7', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-3', '2020-04-14 15:35:39', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('76d33636d29b4f78a717d148dca1a23e', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-2', '2020-04-14 15:35:35', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('7bef431461844a9da921ad1ab29c41d3', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是回复1-4', '2020-04-14 15:35:43', 'f18e7b63ceca4166b65c23451535abaa');
INSERT INTO `tb_comment` VALUES ('f18e7b63ceca4166b65c23451535abaa', '062bca4100ca40a1b39e7226b216bf12', 'd6754affc7864ea9b67b61e493d28614', '0', '我是评论1', '2020-04-14 15:34:08', '');

-- ----------------------------
-- Table structure for tb_labels
-- ----------------------------
DROP TABLE IF EXISTS `tb_labels`;
CREATE TABLE `tb_labels` (
  `uuid` varchar(50) NOT NULL,
  `channels_id` varchar(50) DEFAULT NULL COMMENT '频道id',
  `name` varchar(20) DEFAULT NULL COMMENT '标签名称',
  `icon_url` varchar(255) DEFAULT NULL COMMENT '图标',
  `description` varchar(120) DEFAULT NULL COMMENT '描述',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='标签表';

-- ----------------------------
-- Records of tb_labels
-- ----------------------------
INSERT INTO `tb_labels` VALUES ('0009b2289c004b7a9c9ee325d693fd1f', 'cbad2058b4014634aec6515f4adbef0d', '自动驾驶', '', '', '2020-04-16 15:18:15', '2020-04-16 15:18:15');
INSERT INTO `tb_labels` VALUES ('015783aba70b4c11bc1fddcaffa72d31', '2a353971222c4aff8e8d3e9c370330cd', '路由', null, null, '2020-04-16 16:59:44', '2020-04-16 16:59:44');
INSERT INTO `tb_labels` VALUES ('077a6486ebf94f5e9a589411d2e4adb5', 'ee1accc0cfb444fa96d6811569830ecd', '破解', null, null, '2020-04-16 16:47:08', '2020-04-16 16:47:08');
INSERT INTO `tb_labels` VALUES ('09e0eefc1b14434c936b613d1a2b0bf3', 'ee1accc0cfb444fa96d6811569830ecd', '震动', null, null, '2020-04-16 16:47:11', '2020-04-16 16:47:11');
INSERT INTO `tb_labels` VALUES ('09e48b1bf7c9412aa8fd18d1fb76ba85', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'maven', '', '', '2020-04-16 15:10:14', '2020-04-16 15:10:14');
INSERT INTO `tb_labels` VALUES ('0a5aa8da93084aa6ac3dc20b1cc90863', 'ee1accc0cfb444fa96d6811569830ecd', '心得', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('0b50d8c7b2a44489a9dd703b034feac2', 'a337904dd1d5477b9689d7693be316de', 'sdk', null, null, '2020-04-16 16:50:16', '2020-04-16 16:50:16');
INSERT INTO `tb_labels` VALUES ('0c52f81f27204666928190ebbc74d1aa', 'ee1accc0cfb444fa96d6811569830ecd', 'libevent', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('0e8101b2d5224b029a5f8f4b0948a37e', 'cbad2058b4014634aec6515f4adbef0d', '数据集', null, null, '2020-04-16 16:55:39', '2020-04-16 16:55:39');
INSERT INTO `tb_labels` VALUES ('0f2596e8a00f4ed58d2b4e47f674a118', 'b299a2a48cd64e77a3431ce958b42055', '阿里云', null, null, '2020-04-16 16:56:37', '2020-04-16 16:56:37');
INSERT INTO `tb_labels` VALUES ('1062207552f54e86b0a1ad8dd7c0a888', '049b3bd76c1e49ccbe48b36197e77f76', 'typescript', '', '', '2020-04-16 15:06:19', '2020-04-16 15:06:19');
INSERT INTO `tb_labels` VALUES ('10a8813a8ce34deb9b8d590fcf74124c', 'ee1accc0cfb444fa96d6811569830ecd', 'gnu', null, null, '2020-04-16 16:47:16', '2020-04-16 16:47:16');
INSERT INTO `tb_labels` VALUES ('1103d9e24e014eeab039ce0de76ad440', '2a353971222c4aff8e8d3e9c370330cd', 'gitlab', null, null, '2020-04-16 16:59:47', '2020-04-16 16:59:47');
INSERT INTO `tb_labels` VALUES ('115ec0efd61e4e22942b00b9fd1246b0', 'ee1accc0cfb444fa96d6811569830ecd', '百度', null, null, '2020-04-16 16:47:08', '2020-04-16 16:47:08');
INSERT INTO `tb_labels` VALUES ('12f91faac18b49819869f52fbdbb1960', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'reactnative', null, null, '2020-04-16 16:49:27', '2020-04-16 16:49:27');
INSERT INTO `tb_labels` VALUES ('13f1211b651544e3a17611b2117e9cec', 'cbad2058b4014634aec6515f4adbef0d', '数据挖掘', '', '', '2020-04-16 15:18:34', '2020-04-16 15:18:34');
INSERT INTO `tb_labels` VALUES ('14ab12176ade47da95ba97d7151eb1f9', 'ee1accc0cfb444fa96d6811569830ecd', 'flutter', null, null, '2020-04-16 16:47:14', '2020-04-16 16:47:14');
INSERT INTO `tb_labels` VALUES ('14b1d605b9c340139163c4f22f384a7f', '1a7cc9fbc4654cb0afec84e080816ef1', '魔兽', null, null, '2020-04-16 16:57:54', '2020-04-16 16:57:54');
INSERT INTO `tb_labels` VALUES ('1500b6a8b7a64b41a84f31328c0a3c9a', 'bb0b7e69ad3e46fcb121baefda8f1f78', '缓存', null, null, '2020-04-16 16:48:53', '2020-04-16 16:48:53');
INSERT INTO `tb_labels` VALUES ('152de5fe7cc14dedb342ba8dd2800d42', '049b3bd76c1e49ccbe48b36197e77f76', '技术', null, null, '2020-04-16 16:09:19', '2020-04-16 16:09:19');
INSERT INTO `tb_labels` VALUES ('15941dc0af92453481b8a0626f963283', '7b3e40f8b9cc4b7780dc39a71d7f580e', '微信小程序', '', '', '2020-04-09 19:49:34', '2020-04-09 19:49:34');
INSERT INTO `tb_labels` VALUES ('15ef803612034600809b3e6c99cb32ab', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'uni-app', '', '', '2020-04-16 15:13:41', '2020-04-16 15:13:41');
INSERT INTO `tb_labels` VALUES ('18261a31165d4a00b819e4f5132c9049', 'cbad2058b4014634aec6515f4adbef0d', '自然语言处理', '', '', '2020-04-16 15:18:05', '2020-04-16 15:18:05');
INSERT INTO `tb_labels` VALUES ('1939b672cc5446439db2b7017c7cfa48', 'ee1accc0cfb444fa96d6811569830ecd', '开源协议', null, null, '2020-04-16 16:47:15', '2020-04-16 16:47:15');
INSERT INTO `tb_labels` VALUES ('19b5930ba00e4cf09120e04c1f0a9e6b', 'a337904dd1d5477b9689d7693be316de', 'phonegap', '', '', '2020-04-16 15:14:59', '2020-04-16 15:14:59');
INSERT INTO `tb_labels` VALUES ('1a77ff8ac4c54e58b5e6b22210cff64f', 'ee1accc0cfb444fa96d6811569830ecd', 'mysql', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('1af5f9c4e9a14953af29cb85b3dd6caa', 'ee1accc0cfb444fa96d6811569830ecd', '后端开发', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('1ca15ce069584c35ad17790f81a05a60', 'ee1accc0cfb444fa96d6811569830ecd', 'gui', null, null, '2020-04-16 16:47:14', '2020-04-16 16:47:14');
INSERT INTO `tb_labels` VALUES ('1d0ffae0426e4e6e8add67530ec689b4', '049b3bd76c1e49ccbe48b36197e77f76', 'html', '', '', '2020-04-09 19:47:46', '2020-04-09 19:47:46');
INSERT INTO `tb_labels` VALUES ('1d36446f3db84f4c836556d1513c37f0', '04547238127a4676b504cc4496865d7b', 'thymeleaf', null, null, '2020-04-16 16:58:56', '2020-04-16 16:58:56');
INSERT INTO `tb_labels` VALUES ('1daffe9846d8484ea60a6379e07cadef', '819ad72c1efe450f9d7affc135a4b457', 'xml', '', '', '2020-04-16 15:17:25', '2020-04-16 15:17:25');
INSERT INTO `tb_labels` VALUES ('1f222fff35904eafba3af5103e7f5121', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'gin', null, null, '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_labels` VALUES ('1fb6bf7d213640b28d89fe5a369dc60d', 'b299a2a48cd64e77a3431ce958b42055', 'qingcloud', null, null, '2020-04-16 16:56:36', '2020-04-16 16:56:36');
INSERT INTO `tb_labels` VALUES ('219d7aff8dfe4ffc9c8f368e2987187f', '7b3e40f8b9cc4b7780dc39a71d7f580e', '支付宝小程序', '', '', '2020-04-09 19:49:42', '2020-04-09 19:49:42');
INSERT INTO `tb_labels` VALUES ('224db6e7ee264d868ecd07eba961eb6f', '049b3bd76c1e49ccbe48b36197e77f76', '内存泄漏', null, null, '2020-04-16 16:09:10', '2020-04-16 16:09:10');
INSERT INTO `tb_labels` VALUES ('2294832fe5104d73ace4f14ad9549018', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'java', '', '', '2020-04-16 15:09:09', '2020-04-16 15:09:09');
INSERT INTO `tb_labels` VALUES ('259269231c934c80878839ea2f348955', 'b299a2a48cd64e77a3431ce958b42055', '云杉网络', '', '', '2020-04-16 15:21:02', '2020-04-16 15:21:02');
INSERT INTO `tb_labels` VALUES ('25b298296d9948c5aceac5227fa0ef07', 'ee1accc0cfb444fa96d6811569830ecd', '经验教训', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('277530c212aa4407b43c58c657fe8194', 'a0ea520851b4484f9cebac9ff7e47bc6', '大数据', null, null, '2020-04-16 16:59:08', '2020-04-16 16:59:08');
INSERT INTO `tb_labels` VALUES ('278262a4258f4beca20e334398ab06d8', 'a0ea520851b4484f9cebac9ff7e47bc6', '分布式', null, null, '2020-04-16 16:59:10', '2020-04-16 16:59:10');
INSERT INTO `tb_labels` VALUES ('2a09bf1afefd4d659606f43445741ee3', 'cbad2058b4014634aec6515f4adbef0d', '人工智能', '', '', '2020-04-16 15:17:51', '2020-04-16 15:17:51');
INSERT INTO `tb_labels` VALUES ('2a81fe886a0a41028a7b13cb4915b40f', '19eb3dd59ef8430d9f637d97449fc417', '加密技术', null, null, '2020-04-16 16:59:31', '2020-04-16 16:59:31');
INSERT INTO `tb_labels` VALUES ('2deb4787e1714b42b076355a58fa9fcc', 'b299a2a48cd64e77a3431ce958b42055', '百度云', '', '', '2020-04-16 15:20:01', '2020-04-16 15:20:01');
INSERT INTO `tb_labels` VALUES ('2fd0d43e373d4a38add451c1ae47594f', 'ee1accc0cfb444fa96d6811569830ecd', 'aio', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('2ff36c3d3aec49d8a19cd1d17c6e9a7e', 'ee1accc0cfb444fa96d6811569830ecd', '性能测试', null, null, '2020-04-16 16:47:20', '2020-04-16 16:47:20');
INSERT INTO `tb_labels` VALUES ('30ea6d13caf14dc8990e3284489224d9', '2a353971222c4aff8e8d3e9c370330cd', 'svn', null, null, '2020-04-16 16:59:47', '2020-04-16 16:59:47');
INSERT INTO `tb_labels` VALUES ('3283cc5d6e714f1eb30181e3d83d99af', '7b3e40f8b9cc4b7780dc39a71d7f580e', '百度小程序', '', '', '2020-04-09 19:49:47', '2020-04-09 19:49:47');
INSERT INTO `tb_labels` VALUES ('32b327672bf34bb49868560bae1a0ab0', '2a353971222c4aff8e8d3e9c370330cd', '插件', null, null, '2020-04-16 16:59:44', '2020-04-16 16:59:44');
INSERT INTO `tb_labels` VALUES ('3300149da71245d9b748b46d3a41c628', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'rpc', null, null, '2020-04-16 16:48:52', '2020-04-16 16:48:52');
INSERT INTO `tb_labels` VALUES ('3450238252414287a0b3fbac4a4e198b', '049b3bd76c1e49ccbe48b36197e77f76', '能力', null, null, '2020-04-16 16:09:19', '2020-04-16 16:09:19');
INSERT INTO `tb_labels` VALUES ('34a4fdb41d174683a033a2528f5432fc', 'ee1accc0cfb444fa96d6811569830ecd', 'netty', null, null, '2020-04-16 16:47:14', '2020-04-16 16:47:14');
INSERT INTO `tb_labels` VALUES ('34b18c0fcab44fec86f4a5d8f9845545', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'sql', null, null, '2020-04-16 16:48:55', '2020-04-16 16:48:55');
INSERT INTO `tb_labels` VALUES ('37cf11776ac6429fb9acf87d5c755ab2', 'ee1accc0cfb444fa96d6811569830ecd', '设计模式', null, null, '2020-04-16 16:47:14', '2020-04-16 16:47:14');
INSERT INTO `tb_labels` VALUES ('3820770e46ef414faee8ed89ce154fdc', '91832bd0c3a244fb88c0bca74c0d404d', 'devops', null, null, '2020-04-16 17:00:00', '2020-04-16 17:00:00');
INSERT INTO `tb_labels` VALUES ('382be152cdba43989a2a4408c1116f87', 'cbad2058b4014634aec6515f4adbef0d', '模型', null, null, '2020-04-16 16:55:39', '2020-04-16 16:55:39');
INSERT INTO `tb_labels` VALUES ('3921afbb134d45f6aa368b52d2670e7b', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'leetcode', null, null, '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_labels` VALUES ('3a7297510e14482196aeb38b5b53c846', '3798854967b444e0b8156e5154f94b97', '比特币', '', '', '2020-04-16 15:22:46', '2020-04-16 15:22:46');
INSERT INTO `tb_labels` VALUES ('3b375646301546259a8fb29d74ae4447', '049b3bd76c1e49ccbe48b36197e77f76', '小程序', null, null, '2020-04-16 16:09:06', '2020-04-16 16:09:06');
INSERT INTO `tb_labels` VALUES ('401f1c4dcfbc499e8f7129c091c299f8', '049b3bd76c1e49ccbe48b36197e77f76', 'html5', '', '', '2020-04-09 19:48:27', '2020-04-09 19:48:27');
INSERT INTO `tb_labels` VALUES ('404982af52c7437280759bb9156099eb', '04547238127a4676b504cc4496865d7b', 'springboot', null, null, '2020-04-16 16:58:56', '2020-04-16 16:58:56');
INSERT INTO `tb_labels` VALUES ('406ef08e86cc4caa88239b8e0e4ea758', '19eb3dd59ef8430d9f637d97449fc417', 'paddle', null, null, '2020-04-16 16:59:30', '2020-04-16 16:59:30');
INSERT INTO `tb_labels` VALUES ('40a18ee9514e46b28a96cc182f4f8df2', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'tomcat', '', '', '2020-04-16 15:10:06', '2020-04-16 15:10:06');
INSERT INTO `tb_labels` VALUES ('40c24c15130143f6be0c452503550a5b', 'b299a2a48cd64e77a3431ce958b42055', 'ucloud', '', '', '2020-04-16 15:21:17', '2020-04-16 15:21:17');
INSERT INTO `tb_labels` VALUES ('410e0ac328ce4db8bebc61f2c565943b', 'a337904dd1d5477b9689d7693be316de', 'macos', '', '', '2020-04-16 15:15:23', '2020-04-16 15:15:23');
INSERT INTO `tb_labels` VALUES ('419c570a467e42b1b29bb02eef1b36dd', '7b3e40f8b9cc4b7780dc39a71d7f580e', '头条小程序', '', '', '2020-04-16 15:13:00', '2020-04-16 15:13:00');
INSERT INTO `tb_labels` VALUES ('43145b2d806a4c3e8bb30d20ef04d61b', 'ee1accc0cfb444fa96d6811569830ecd', 'python', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('448959a7e0394148ae465d890ed2bbd2', 'ee1accc0cfb444fa96d6811569830ecd', '滴滴出行', null, null, '2020-04-16 16:47:21', '2020-04-16 16:47:21');
INSERT INTO `tb_labels` VALUES ('45a9e20bf502451396f25c51ff9f7972', 'a337904dd1d5477b9689d7693be316de', 'dart', null, null, '2020-04-16 16:50:18', '2020-04-16 16:50:18');
INSERT INTO `tb_labels` VALUES ('4754192fa3a348589f4dce6a37965a21', '819ad72c1efe450f9d7affc135a4b457', 'webview', '', '', '2020-04-16 15:16:22', '2020-04-16 15:16:22');
INSERT INTO `tb_labels` VALUES ('4810ef0267f242fa99b85b2fd8a3cc02', 'ee1accc0cfb444fa96d6811569830ecd', 'ddd', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('499b6d4decaa4985b8272adc258273fc', '7b3e40f8b9cc4b7780dc39a71d7f580e', '异步', null, null, '2020-04-16 16:49:26', '2020-04-16 16:49:26');
INSERT INTO `tb_labels` VALUES ('4a2750c3e1fc45fa885bedbd3a9ee7d8', '3798854967b444e0b8156e5154f94b97', 'ico', '', '', '2020-04-16 15:23:01', '2020-04-16 15:23:01');
INSERT INTO `tb_labels` VALUES ('4a80ddea758b47c990fb8b276d19a350', 'cbad2058b4014634aec6515f4adbef0d', '机器人', null, null, '2020-04-16 16:55:38', '2020-04-16 16:55:38');
INSERT INTO `tb_labels` VALUES ('4af39019dc66420fb7c786629449fbc9', '1a7cc9fbc4654cb0afec84e080816ef1', '游戏引擎', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('4c3a5a1f039b42a5b26aeb9aca0646bb', '7b3e40f8b9cc4b7780dc39a71d7f580e', '微信开发', null, null, '2020-04-16 16:49:22', '2020-04-16 16:49:22');
INSERT INTO `tb_labels` VALUES ('4c5f061cd88a451d91f4d1f0d52f3ed0', 'a0ea520851b4484f9cebac9ff7e47bc6', 'antdesign', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('50952da4831a49c98a02a58ccc545509', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'golang', null, null, '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_labels` VALUES ('50b1ead18a154fb9a3be3ed4bc61398b', 'b299a2a48cd64e77a3431ce958b42055', '容器', null, null, '2020-04-16 16:56:37', '2020-04-16 16:56:37');
INSERT INTO `tb_labels` VALUES ('55723db96b9f4593bae02bc1e49f1e87', 'ee1accc0cfb444fa96d6811569830ecd', '后端', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('57f41641447a40eb9bde76ded2a16296', 'ee1accc0cfb444fa96d6811569830ecd', 'segmentfault', null, null, '2020-04-16 16:47:09', '2020-04-16 16:47:09');
INSERT INTO `tb_labels` VALUES ('581c0fef5c3347b8bedbf8c2421d911b', 'b299a2a48cd64e77a3431ce958b42055', '华为云', null, null, '2020-04-16 16:56:35', '2020-04-16 16:56:35');
INSERT INTO `tb_labels` VALUES ('582af48b567844cebb5bd26cc36dee97', 'a337904dd1d5477b9689d7693be316de', 'swift', '', '', '2020-04-16 15:15:39', '2020-04-16 15:15:39');
INSERT INTO `tb_labels` VALUES ('58f71f062add49e089c84a3db4103629', 'a337904dd1d5477b9689d7693be316de', 'sqlite', '', '', '2020-04-16 15:14:30', '2020-04-16 15:14:30');
INSERT INTO `tb_labels` VALUES ('5bc240f3bc174167bf6eaa745d97c6ae', '049b3bd76c1e49ccbe48b36197e77f76', 'solid原则', null, null, '2020-04-16 16:09:20', '2020-04-16 16:09:20');
INSERT INTO `tb_labels` VALUES ('603c056cdb7840da9242d2c0844d5c0f', 'cbad2058b4014634aec6515f4adbef0d', '深度学习', '', '', '2020-04-16 15:18:50', '2020-04-16 15:18:50');
INSERT INTO `tb_labels` VALUES ('60e459d5028e400894856f94e826804c', 'cbad2058b4014634aec6515f4adbef0d', '互联网', null, null, '2020-04-16 16:55:35', '2020-04-16 16:55:35');
INSERT INTO `tb_labels` VALUES ('6224a68b52f54990a07d51854b320f32', 'a337904dd1d5477b9689d7693be316de', 'google', null, null, '2020-04-16 16:50:17', '2020-04-16 16:50:17');
INSERT INTO `tb_labels` VALUES ('62f75a9c3455489e9e5128982e759700', 'a0ea520851b4484f9cebac9ff7e47bc6', '金融', null, null, '2020-04-16 16:59:08', '2020-04-16 16:59:08');
INSERT INTO `tb_labels` VALUES ('631c6273e6474a3d858ca44050a4bc8b', '7b3e40f8b9cc4b7780dc39a71d7f580e', '代理', null, null, '2020-04-16 16:49:25', '2020-04-16 16:49:25');
INSERT INTO `tb_labels` VALUES ('634b81d655c74cb0adc4d0aa362b8819', 'ee1accc0cfb444fa96d6811569830ecd', 'github', null, null, '2020-04-16 16:47:20', '2020-04-16 16:47:20');
INSERT INTO `tb_labels` VALUES ('63b70326a7b34ffeb8eeb2f0098c86c1', '049b3bd76c1e49ccbe48b36197e77f76', 'cookie', null, null, '2020-04-16 16:09:17', '2020-04-16 16:09:17');
INSERT INTO `tb_labels` VALUES ('63c4e1e7ec204b43a62065a3ced4c2ce', '049b3bd76c1e49ccbe48b36197e77f76', '前端', null, null, '2020-04-16 16:09:10', '2020-04-16 16:09:10');
INSERT INTO `tb_labels` VALUES ('640c003521964678a2e591447f8be769', 'a0ea520851b4484f9cebac9ff7e47bc6', '数据安全', null, null, '2020-04-16 16:59:08', '2020-04-16 16:59:08');
INSERT INTO `tb_labels` VALUES ('646ad4ce7b3c43b89c17dcdea128af0b', '91832bd0c3a244fb88c0bca74c0d404d', 'docker', null, null, '2020-04-16 17:00:04', '2020-04-16 17:00:04');
INSERT INTO `tb_labels` VALUES ('6694b0611a0d403e9bb25c543e006f8a', '1a7cc9fbc4654cb0afec84e080816ef1', '云安全', null, null, '2020-04-16 16:57:48', '2020-04-16 16:57:48');
INSERT INTO `tb_labels` VALUES ('66d1b6953b664c409cf7283cdb6c6566', '1a7cc9fbc4654cb0afec84e080816ef1', '开发者', null, null, '2020-04-16 16:57:51', '2020-04-16 16:57:51');
INSERT INTO `tb_labels` VALUES ('66df11ef95064996ba39f328e25451f5', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'mpx', '', '', '2020-04-16 15:13:49', '2020-04-16 15:13:49');
INSERT INTO `tb_labels` VALUES ('674b70b62fa24c7ca9a671f8e54b8d15', 'cbad2058b4014634aec6515f4adbef0d', '开源项目介绍', null, null, '2020-04-16 16:55:40', '2020-04-16 16:55:40');
INSERT INTO `tb_labels` VALUES ('695a8bbf358245c5a5284af4df5b2222', 'a0ea520851b4484f9cebac9ff7e47bc6', '蚂蚁金服', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('69a24148dd3149e49273bc7d178fa7bc', 'b299a2a48cd64e77a3431ce958b42055', '公有云', null, null, '2020-04-16 16:56:37', '2020-04-16 16:56:37');
INSERT INTO `tb_labels` VALUES ('6a6ae02394fb478caf6f772dc358e727', '3798854967b444e0b8156e5154f94b97', '智能合约', '', '', '2020-04-16 15:23:09', '2020-04-16 15:23:09');
INSERT INTO `tb_labels` VALUES ('6aec6c8499c44483beecd569d05c7f4b', 'a0ea520851b4484f9cebac9ff7e47bc6', '金融科技', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('6b3ff922b0dd4d378ac2f31d32e5f60d', 'ee1accc0cfb444fa96d6811569830ecd', '行业', null, null, '2020-04-16 16:47:08', '2020-04-16 16:47:08');
INSERT INTO `tb_labels` VALUES ('6b76e0ffbe6a4ccea745d288e312af0b', '3798854967b444e0b8156e5154f94b97', '以太坊', '', '', '2020-04-16 15:23:17', '2020-04-16 15:23:17');
INSERT INTO `tb_labels` VALUES ('6bc7339a27854278b1489eb30425aa1b', '1a7cc9fbc4654cb0afec84e080816ef1', 'wow', null, null, '2020-04-16 16:57:52', '2020-04-16 16:57:52');
INSERT INTO `tb_labels` VALUES ('6db071127bc8442497d14d9527082793', '1a7cc9fbc4654cb0afec84e080816ef1', 'swoole', null, null, '2020-04-16 16:57:52', '2020-04-16 16:57:52');
INSERT INTO `tb_labels` VALUES ('6dcac97ec78c41b3a5f265d015ca34f5', '1a7cc9fbc4654cb0afec84e080816ef1', '游戏服务端', null, null, '2020-04-16 16:57:52', '2020-04-16 16:57:52');
INSERT INTO `tb_labels` VALUES ('6e98a760af6d411d8e06b244853c67e9', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'async-await', null, null, '2020-04-16 16:49:26', '2020-04-16 16:49:26');
INSERT INTO `tb_labels` VALUES ('6e99f9fefb2d45f59288b87ccf651628', 'a0ea520851b4484f9cebac9ff7e47bc6', '设计', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('6ec468fa6e2a402e84dfa1f10c689405', '7b3e40f8b9cc4b7780dc39a71d7f580e', '微信开发者工具', '', '', '2020-04-16 15:12:51', '2020-04-16 15:12:51');
INSERT INTO `tb_labels` VALUES ('6fa64cc90cb140feb9b431413237469f', 'ee1accc0cfb444fa96d6811569830ecd', 'pandas', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('6fe04eb419474fd7ad1248f0b1a2a7e6', 'ee1accc0cfb444fa96d6811569830ecd', '知识产权', null, null, '2020-04-16 16:47:15', '2020-04-16 16:47:15');
INSERT INTO `tb_labels` VALUES ('7415188933514e5ab6d45d3645d83337', '19eb3dd59ef8430d9f637d97449fc417', 'mozilla', null, null, '2020-04-16 16:59:32', '2020-04-16 16:59:32');
INSERT INTO `tb_labels` VALUES ('7506700dea5a42298b9ecb0ac0aaab41', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'taro', '', '', '2020-04-16 15:13:32', '2020-04-16 15:13:32');
INSERT INTO `tb_labels` VALUES ('753b5aee3913424e81fe2b5299626d8c', 'ee1accc0cfb444fa96d6811569830ecd', 'linux', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('754a84ad28ed43fea93a468acd8f727b', '049b3bd76c1e49ccbe48b36197e77f76', '图表', null, null, '2020-04-16 16:09:10', '2020-04-16 16:09:10');
INSERT INTO `tb_labels` VALUES ('762f519a9c8f4151a9ef8506cde667a6', '819ad72c1efe450f9d7affc135a4b457', 'json', '', '', '2020-04-16 15:17:17', '2020-04-16 15:17:17');
INSERT INTO `tb_labels` VALUES ('76784f1e92394410abc853268ee6f31b', '1a7cc9fbc4654cb0afec84e080816ef1', '浏览器原理', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('7684950d0a9e46f1b8067594e8a0161d', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'spring', '', '', '2020-04-16 15:09:41', '2020-04-16 15:09:41');
INSERT INTO `tb_labels` VALUES ('76da78c6bbf04ec78109330e4b617f8e', 'b299a2a48cd64e77a3431ce958b42055', 'alauda', '', '', '2020-04-16 15:21:32', '2020-04-16 15:21:32');
INSERT INTO `tb_labels` VALUES ('77a7bd638e0a45ec84569ef6b79325c1', '04547238127a4676b504cc4496865d7b', '服务器', null, null, '2020-04-16 16:58:55', '2020-04-16 16:58:55');
INSERT INTO `tb_labels` VALUES ('7871a3acb3374d36b738a36c95c3f8ea', '04547238127a4676b504cc4496865d7b', 'zoom', null, null, '2020-04-16 16:58:53', '2020-04-16 16:58:53');
INSERT INTO `tb_labels` VALUES ('789898341cc64d45a1f44e26daab183f', 'bb0b7e69ad3e46fcb121baefda8f1f78', '数据结构', null, null, '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_labels` VALUES ('78b2eb8f68e34e6e8e8863c0ed281b45', '2a353971222c4aff8e8d3e9c370330cd', '思维', null, null, '2020-04-16 16:59:45', '2020-04-16 16:59:45');
INSERT INTO `tb_labels` VALUES ('7937aecb2ef543908ed511c9d5abceb3', '3798854967b444e0b8156e5154f94b97', '区块链', '', '', '2020-04-16 15:22:54', '2020-04-16 15:22:54');
INSERT INTO `tb_labels` VALUES ('79c58d0fa766471e8390a7d60e9f57be', 'ee1accc0cfb444fa96d6811569830ecd', 'nio', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('7af79b929d3e4a33892d3b4305e3587f', '7b3e40f8b9cc4b7780dc39a71d7f580e', '小程序云开发', '', '', '2020-04-16 15:13:10', '2020-04-16 15:13:10');
INSERT INTO `tb_labels` VALUES ('7b39e36da1f543c995c416f3d2950cf5', '049b3bd76c1e49ccbe48b36197e77f76', 'css', '', '', '2020-04-09 19:48:41', '2020-04-09 19:48:41');
INSERT INTO `tb_labels` VALUES ('7bdbb73fad864154bd1b93c965c3ea62', '049b3bd76c1e49ccbe48b36197e77f76', '微前端', null, null, '2020-04-16 16:09:11', '2020-04-16 16:09:11');
INSERT INTO `tb_labels` VALUES ('7c555cea2dd347e389848f652e8f6ff7', '049b3bd76c1e49ccbe48b36197e77f76', 'bootstrap', '', '', '2020-04-14 20:02:45', '2020-04-14 20:02:45');
INSERT INTO `tb_labels` VALUES ('7e8a80ce2b624cf78c1048efc7c7a623', '91832bd0c3a244fb88c0bca74c0d404d', '内推', null, null, '2020-04-16 17:00:05', '2020-04-16 17:00:05');
INSERT INTO `tb_labels` VALUES ('80961fb9ea954af187319d2b8e8bd474', 'ee1accc0cfb444fa96d6811569830ecd', 'providers', null, null, '2020-04-16 16:47:19', '2020-04-16 16:47:19');
INSERT INTO `tb_labels` VALUES ('81a4561c1c294e0cae32c9fe6b5dc397', '049b3bd76c1e49ccbe48b36197e77f76', '程序员', null, null, '2020-04-16 16:09:14', '2020-04-16 16:09:14');
INSERT INTO `tb_labels` VALUES ('83f62facb3b943ffa8e46abd1ebc64d9', 'ee1accc0cfb444fa96d6811569830ecd', '数据库', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('84564b2b178141059e2bf061053de54b', 'ee1accc0cfb444fa96d6811569830ecd', 'ios开发工具', null, null, '2020-04-16 16:47:11', '2020-04-16 16:47:11');
INSERT INTO `tb_labels` VALUES ('84e1fca09c4340be87d5c1ef4601b026', 'ee1accc0cfb444fa96d6811569830ecd', 'php', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('85ee959b27f74072b13cc763b9bbf77e', 'a337904dd1d5477b9689d7693be316de', 'ios', '', '', '2020-04-16 15:14:12', '2020-04-16 15:14:12');
INSERT INTO `tb_labels` VALUES ('88d818c918534e0c94dc46380a03493a', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'jar', '', '', '2020-04-16 15:09:32', '2020-04-16 15:09:32');
INSERT INTO `tb_labels` VALUES ('8ac6e1f57bef4d348ee96af25d750c44', 'b299a2a48cd64e77a3431ce958b42055', '腾讯云', '', '', '2020-04-16 15:20:55', '2020-04-16 15:20:55');
INSERT INTO `tb_labels` VALUES ('8d3b9574902f4306bcf2833371d35439', '2a353971222c4aff8e8d3e9c370330cd', 'paas平台', null, null, '2020-04-16 16:59:47', '2020-04-16 16:59:47');
INSERT INTO `tb_labels` VALUES ('8df713ae0be648fc8158438f191920da', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'hibernate', '', '', '2020-04-16 15:09:49', '2020-04-16 15:09:49');
INSERT INTO `tb_labels` VALUES ('8dfc62f227ae4076888ea4872e03cddd', '819ad72c1efe450f9d7affc135a4b457', 'android', '', '', '2020-04-16 15:16:04', '2020-04-16 15:16:04');
INSERT INTO `tb_labels` VALUES ('90ebd6b2270249dc8580eb97aa14aa02', 'ee1accc0cfb444fa96d6811569830ecd', 'redis', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('91a1be3a7ac0413482742452c7613692', 'ee1accc0cfb444fa96d6811569830ecd', '正则表达式', null, null, '2020-04-16 16:47:21', '2020-04-16 16:47:21');
INSERT INTO `tb_labels` VALUES ('9223827da7dc4f1c8f6790777fb42d6e', '2a353971222c4aff8e8d3e9c370330cd', 'facebook', null, null, '2020-04-16 16:59:45', '2020-04-16 16:59:45');
INSERT INTO `tb_labels` VALUES ('9276a7fb738f4d38aec0e4c23347fba7', 'a337904dd1d5477b9689d7693be316de', '系统', null, null, '2020-04-16 16:50:20', '2020-04-16 16:50:20');
INSERT INTO `tb_labels` VALUES ('9424c753324d4c6198c85fff4f681dd4', '1a7cc9fbc4654cb0afec84e080816ef1', '游戏开发', null, null, '2020-04-16 16:57:48', '2020-04-16 16:57:48');
INSERT INTO `tb_labels` VALUES ('944695fd251146a99e7298a08f69d2e2', 'ee1accc0cfb444fa96d6811569830ecd', '通信云', null, null, '2020-04-16 16:47:12', '2020-04-16 16:47:12');
INSERT INTO `tb_labels` VALUES ('95e7c5b00e4743e0aa3dceec593ce6bd', 'a337904dd1d5477b9689d7693be316de', 'safari', '', '', '2020-04-16 15:14:41', '2020-04-16 15:14:41');
INSERT INTO `tb_labels` VALUES ('9661fbcbaed6483c9f5992883e9a62a6', 'ee1accc0cfb444fa96d6811569830ecd', 'select', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('9cbb3f4a239b433aa4be468f5b8c82ec', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'eclipse', '', '', '2020-04-16 15:10:23', '2020-04-16 15:10:23');
INSERT INTO `tb_labels` VALUES ('9cf3a084c4d94f4da9a6423ab27b8649', '819ad72c1efe450f9d7affc135a4b457', 'arm', null, null, '2020-04-16 16:54:49', '2020-04-16 16:54:49');
INSERT INTO `tb_labels` VALUES ('9cf3c6405733421e9693ef7c6e1885c8', 'ee1accc0cfb444fa96d6811569830ecd', '代码质量', null, null, '2020-04-16 16:47:19', '2020-04-16 16:47:19');
INSERT INTO `tb_labels` VALUES ('9d5eb002705648e2bc3d345fa34a8191', '19eb3dd59ef8430d9f637d97449fc417', 'microsoft', null, null, '2020-04-16 16:59:34', '2020-04-16 16:59:34');
INSERT INTO `tb_labels` VALUES ('9eccd82e1d9a4a8cb3a0971df3788f2b', '7b3e40f8b9cc4b7780dc39a71d7f580e', '微信分享', null, null, '2020-04-16 16:49:22', '2020-04-16 16:49:22');
INSERT INTO `tb_labels` VALUES ('9f3d90e736494f6d9cb8cab5f854d73a', '819ad72c1efe450f9d7affc135a4b457', 'android-studio', '', '', '2020-04-16 15:16:30', '2020-04-16 15:16:30');
INSERT INTO `tb_labels` VALUES ('9fc0276000e346da8c0bab1b5f78adaa', 'ee1accc0cfb444fa96d6811569830ecd', '感悟', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('a0ac07cb5e6b446f8d1b9034d86fd880', '1a7cc9fbc4654cb0afec84e080816ef1', '推送', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('a1dff4d6d5dd4ee69cb3d44463606477', '1a7cc9fbc4654cb0afec84e080816ef1', '小游戏', null, null, '2020-04-16 16:57:53', '2020-04-16 16:57:53');
INSERT INTO `tb_labels` VALUES ('a4f4fd7a73b84a7298db0174165eeaac', '1a7cc9fbc4654cb0afec84e080816ef1', '游戏', null, null, '2020-04-16 16:57:48', '2020-04-16 16:57:48');
INSERT INTO `tb_labels` VALUES ('a75d7c6da04041d5a9cf4dd7e270c3cf', 'ee1accc0cfb444fa96d6811569830ecd', 'im', null, null, '2020-04-16 16:47:12', '2020-04-16 16:47:12');
INSERT INTO `tb_labels` VALUES ('a7e018e203b949f0b51e659db4105653', 'ee1accc0cfb444fa96d6811569830ecd', 'kotlin', null, null, '2020-04-16 16:47:11', '2020-04-16 16:47:11');
INSERT INTO `tb_labels` VALUES ('a819e12d8465406d8430a3e7ee826d1c', 'a0ea520851b4484f9cebac9ff7e47bc6', '阿里巴巴', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('a83bf36999c94af989d2d78048df00b8', 'b299a2a48cd64e77a3431ce958b42055', '抓包过滤', null, null, '2020-04-16 16:56:38', '2020-04-16 16:56:38');
INSERT INTO `tb_labels` VALUES ('ac3b36c7838044519e53efc72ad02613', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'mpvue', '', '', '2020-04-16 15:13:26', '2020-04-16 15:13:26');
INSERT INTO `tb_labels` VALUES ('aed399344712406e830d6efe028b7fe2', 'ee1accc0cfb444fa96d6811569830ecd', '思否news', null, null, '2020-04-16 16:47:08', '2020-04-16 16:47:08');
INSERT INTO `tb_labels` VALUES ('affcefc3661947ccae893a1ed7dbca10', 'a0ea520851b4484f9cebac9ff7e47bc6', '供应链', null, null, '2020-04-16 16:59:09', '2020-04-16 16:59:09');
INSERT INTO `tb_labels` VALUES ('b350d9c92c524bb4b9feedd40e5eebcd', '049b3bd76c1e49ccbe48b36197e77f76', 'vue.js', '', '', '2020-04-14 20:04:01', '2020-04-14 20:04:01');
INSERT INTO `tb_labels` VALUES ('b3b8c4672aad4d63919b3a05dac79983', '049b3bd76c1e49ccbe48b36197e77f76', 'ecmascript', '', '', '2020-04-14 20:04:12', '2020-04-14 20:04:12');
INSERT INTO `tb_labels` VALUES ('b3f77d5589a04c80899972f9efe8752f', 'b299a2a48cd64e77a3431ce958b42055', '灵雀云', '', '', '2020-04-16 15:21:23', '2020-04-16 15:21:23');
INSERT INTO `tb_labels` VALUES ('b456ad7a7d1d468ba659bb4c31f24e99', '049b3bd76c1e49ccbe48b36197e77f76', '浏览器', null, null, '2020-04-16 16:09:17', '2020-04-16 16:09:17');
INSERT INTO `tb_labels` VALUES ('b687605a1b8842a593f27620e3c26af5', '04547238127a4676b504cc4496865d7b', 'chrome', null, null, '2020-04-16 16:58:55', '2020-04-16 16:58:55');
INSERT INTO `tb_labels` VALUES ('b7460efd3f3b4d6ea78254959a2aebff', 'a337904dd1d5477b9689d7693be316de', 'app', null, null, '2020-04-16 16:50:15', '2020-04-16 16:50:15');
INSERT INTO `tb_labels` VALUES ('b7ff3b2c61d84f139d3fea7fcb5d3131', 'b299a2a48cd64e77a3431ce958b42055', '美团云', '', '', '2020-04-16 15:20:19', '2020-04-16 15:20:19');
INSERT INTO `tb_labels` VALUES ('b84d5a3e64644516915697f2c8409437', '1a7cc9fbc4654cb0afec84e080816ef1', 'serverless', null, null, '2020-04-16 16:57:53', '2020-04-16 16:57:53');
INSERT INTO `tb_labels` VALUES ('ba16f5b739f24380990a4ccacfe6f833', 'b299a2a48cd64e77a3431ce958b42055', 'amazon-web-services', '', '', '2020-04-16 15:19:50', '2020-04-16 15:19:50');
INSERT INTO `tb_labels` VALUES ('ba43c444c9a0480dae0ea17d7463821b', '049b3bd76c1e49ccbe48b36197e77f76', 'ajax', '', '', '2020-04-14 20:03:15', '2020-04-14 20:03:15');
INSERT INTO `tb_labels` VALUES ('ba4a5064430447f5a3a2eb9aae580758', 'ee1accc0cfb444fa96d6811569830ecd', 'paas', null, null, '2020-04-16 16:47:12', '2020-04-16 16:47:12');
INSERT INTO `tb_labels` VALUES ('bacd32e8a1ea43c8967204c5abba4872', '7b3e40f8b9cc4b7780dc39a71d7f580e', 'wepy', '', '', '2020-04-16 15:13:19', '2020-04-16 15:13:19');
INSERT INTO `tb_labels` VALUES ('bb08094058724cb5a595418407aa6c06', 'ee1accc0cfb444fa96d6811569830ecd', 'dokit', null, null, '2020-04-16 16:47:21', '2020-04-16 16:47:21');
INSERT INTO `tb_labels` VALUES ('bc0022273e34499a9bc31681102eb488', 'a337904dd1d5477b9689d7693be316de', 'xcode', '', '', '2020-04-16 15:14:49', '2020-04-16 15:14:49');
INSERT INTO `tb_labels` VALUES ('bec7f52ed0374eaab0d1172b70a1e739', '1a7cc9fbc4654cb0afec84e080816ef1', 'canvas', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('c0d2479bf6564cf5aa35b1b40604f199', 'ee1accc0cfb444fa96d6811569830ecd', 'talkingdata', null, null, '2020-04-16 16:47:11', '2020-04-16 16:47:11');
INSERT INTO `tb_labels` VALUES ('c5c7574f5419441aba6a3361c81ef09e', '049b3bd76c1e49ccbe48b36197e77f76', 'es6', null, null, '2020-04-16 16:09:04', '2020-04-16 16:09:04');
INSERT INTO `tb_labels` VALUES ('c62a8c466b0546c19e04906b878a96d2', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'java-ee', '', '', '2020-04-16 15:09:22', '2020-04-16 15:09:22');
INSERT INTO `tb_labels` VALUES ('c6611ad44f6e40fea7acd54a33ad01c2', 'a0ea520851b4484f9cebac9ff7e47bc6', '微服务', null, null, '2020-04-16 16:59:09', '2020-04-16 16:59:09');
INSERT INTO `tb_labels` VALUES ('c6be57ee659c4ebe8f254e3e7adf74a2', 'a0ea520851b4484f9cebac9ff7e47bc6', 'oceanbase', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('c7913adc87544598962767df48355990', 'cbad2058b4014634aec6515f4adbef0d', '语音', null, null, '2020-04-16 16:55:38', '2020-04-16 16:55:38');
INSERT INTO `tb_labels` VALUES ('c825aa5f765543a1a8c96368462f9371', '1a7cc9fbc4654cb0afec84e080816ef1', '即时通讯', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('c8cd9b29a54f4d27bee226951a981924', '049b3bd76c1e49ccbe48b36197e77f76', 'oop', null, null, '2020-04-16 16:09:20', '2020-04-16 16:09:20');
INSERT INTO `tb_labels` VALUES ('c9c8ca5b55c44b598a25593a4a204e20', 'ee1accc0cfb444fa96d6811569830ecd', '数据分析', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('cb1ca7cb006244a3a4b5b52cb568301c', 'ee1accc0cfb444fa96d6811569830ecd', '购物车', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('cb77a1c04f4241b98e8f6d57d78e3e10', 'a2718d66a7234b1499ed897ff4df05c8', '电信', null, null, '2020-04-16 17:00:14', '2020-04-16 17:00:14');
INSERT INTO `tb_labels` VALUES ('cc944f24ed5e4383a975481674f255e0', 'cbad2058b4014634aec6515f4adbef0d', '又拍云', null, null, '2020-04-16 16:55:35', '2020-04-16 16:55:35');
INSERT INTO `tb_labels` VALUES ('ccaaa3888a50432ebcbc469fa62c40b5', 'a337904dd1d5477b9689d7693be316de', 'afnetworking', null, null, '2020-04-16 16:50:18', '2020-04-16 16:50:18');
INSERT INTO `tb_labels` VALUES ('cdff0c49eb5e40918b3cfb6f3048b361', 'b299a2a48cd64e77a3431ce958b42055', 'deepflow', '', '', '2020-04-16 15:21:10', '2020-04-16 15:21:10');
INSERT INTO `tb_labels` VALUES ('cefcbb7ca2c24b738ea0386eb45886de', 'ee1accc0cfb444fa96d6811569830ecd', 'graphql', null, null, '2020-04-16 16:47:09', '2020-04-16 16:47:09');
INSERT INTO `tb_labels` VALUES ('cf84afe221f24e72b201344b3e15fa85', 'ee1accc0cfb444fa96d6811569830ecd', '移动应用开发', null, null, '2020-04-16 16:47:21', '2020-04-16 16:47:21');
INSERT INTO `tb_labels` VALUES ('cf8fd6f64b3f46d5a7a3468a046b4d3e', '19eb3dd59ef8430d9f637d97449fc417', '开源框架', null, null, '2020-04-16 16:59:36', '2020-04-16 16:59:36');
INSERT INTO `tb_labels` VALUES ('cfd640a90e5f4fa7b713a1afcedf12cf', 'cbad2058b4014634aec6515f4adbef0d', '亚马逊', null, null, '2020-04-16 16:55:38', '2020-04-16 16:55:38');
INSERT INTO `tb_labels` VALUES ('cff4263234c04178b6f716310595544e', '19eb3dd59ef8430d9f637d97449fc417', '监控工具', null, null, '2020-04-16 16:59:33', '2020-04-16 16:59:33');
INSERT INTO `tb_labels` VALUES ('d009d894f21a489c88c52d85c142b3ba', 'a0ea520851b4484f9cebac9ff7e47bc6', '黑客马拉松', null, null, '2020-04-16 16:59:10', '2020-04-16 16:59:10');
INSERT INTO `tb_labels` VALUES ('d07dbcd8900c4d34811137be64dd4301', '049b3bd76c1e49ccbe48b36197e77f76', 'css3', '', '', '2020-04-09 19:48:44', '2020-04-09 19:48:44');
INSERT INTO `tb_labels` VALUES ('d0d5d1c0f4924513816e10a4cf13fb12', 'cbad2058b4014634aec6515f4adbef0d', 'tensorflow', '', '', '2020-04-16 15:18:57', '2020-04-16 15:18:57');
INSERT INTO `tb_labels` VALUES ('d114b152c3b644a6ab136104b4330b6f', '19eb3dd59ef8430d9f637d97449fc417', 'paddlefl', null, null, '2020-04-16 16:59:30', '2020-04-16 16:59:30');
INSERT INTO `tb_labels` VALUES ('d16a93d83052441a90afaa57d69fdc3c', '049b3bd76c1e49ccbe48b36197e77f76', 'node.js', '', '', '2020-04-14 20:04:47', '2020-04-14 20:04:47');
INSERT INTO `tb_labels` VALUES ('d1d122dcdca34dceaad794efaef79d56', '19eb3dd59ef8430d9f637d97449fc417', '数据仓库', null, null, '2020-04-16 16:59:29', '2020-04-16 16:59:29');
INSERT INTO `tb_labels` VALUES ('d3d03b3c361b4e3f9148f6ae02761c29', '91832bd0c3a244fb88c0bca74c0d404d', 'kubernetes', null, null, '2020-04-16 17:00:00', '2020-04-16 17:00:00');
INSERT INTO `tb_labels` VALUES ('d56b9fa723c243c3bfff49e3717856d3', '2a353971222c4aff8e8d3e9c370330cd', '应用', null, null, '2020-04-16 16:59:47', '2020-04-16 16:59:47');
INSERT INTO `tb_labels` VALUES ('d684aaace0484f8dbc17e1e28457d432', '1a7cc9fbc4654cb0afec84e080816ef1', '2019总结', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('d7416e100af54eb7a4d9274b9a462240', 'ee1accc0cfb444fa96d6811569830ecd', '运维', null, null, '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_labels` VALUES ('d79254c4ca5e45dca9d484307c935281', '049b3bd76c1e49ccbe48b36197e77f76', 'javascript', '', '', '2020-04-09 19:49:00', '2020-04-09 19:49:00');
INSERT INTO `tb_labels` VALUES ('d9330057da5647f68af981444ac862f0', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'struts', '', '', '2020-04-16 15:09:57', '2020-04-16 15:09:57');
INSERT INTO `tb_labels` VALUES ('d93a57344da0482d9257c6279866c8a1', 'b299a2a48cd64e77a3431ce958b42055', '金山云', '', '', '2020-04-16 15:20:09', '2020-04-16 15:20:09');
INSERT INTO `tb_labels` VALUES ('d986ab02dd4345098381ef8b01db7e4d', '19eb3dd59ef8430d9f637d97449fc417', '美团', null, null, '2020-04-16 16:59:29', '2020-04-16 16:59:29');
INSERT INTO `tb_labels` VALUES ('db5ba932c64646c2a6e112753fbd78d2', '3798854967b444e0b8156e5154f94b97', '数字化货币', '', '', '2020-04-16 15:23:25', '2020-04-16 15:23:25');
INSERT INTO `tb_labels` VALUES ('db6b58ae709645f2b64166fd73f2f705', 'b299a2a48cd64e77a3431ce958b42055', '工具', null, null, '2020-04-16 16:56:38', '2020-04-16 16:56:38');
INSERT INTO `tb_labels` VALUES ('dc85b19b1d3742cabe11b25cce8f79b2', '19eb3dd59ef8430d9f637d97449fc417', 'Tars', null, null, '2020-04-16 16:59:35', '2020-04-16 16:59:35');
INSERT INTO `tb_labels` VALUES ('dced02b7f53045f9b0bc172e06ba8202', 'a2718d66a7234b1499ed897ff4df05c8', '华为', null, null, '2020-04-16 17:00:14', '2020-04-16 17:00:14');
INSERT INTO `tb_labels` VALUES ('dd1f4cf63050478eb6179b794afaf40c', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'idea', '', '', '2020-04-16 15:10:47', '2020-04-16 15:10:47');
INSERT INTO `tb_labels` VALUES ('ddfb55921ea24001b6178c86a1d11095', 'ee1accc0cfb444fa96d6811569830ecd', '系统架构', null, null, '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_labels` VALUES ('df5b4b0986d44f169be91f7496d1dbc5', 'a337904dd1d5477b9689d7693be316de', 'react-native', null, null, '2020-04-16 16:50:15', '2020-04-16 16:50:15');
INSERT INTO `tb_labels` VALUES ('df8bf047f459444da79182766276661c', 'b299a2a48cd64e77a3431ce958b42055', '七牛云存储', '', '', '2020-04-16 15:19:40', '2020-04-16 15:19:40');
INSERT INTO `tb_labels` VALUES ('e08558de0cef4bd899b5b6aa03550a21', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'cpu', null, null, '2020-04-16 16:48:53', '2020-04-16 16:48:53');
INSERT INTO `tb_labels` VALUES ('e0a1c37357374c5b81385440f46da50d', '049b3bd76c1e49ccbe48b36197e77f76', 'react.js', '', '', '2020-04-14 20:03:42', '2020-04-14 20:03:42');
INSERT INTO `tb_labels` VALUES ('e1461b476a0f4662aa26c90ecff5579b', 'a0ea520851b4484f9cebac9ff7e47bc6', '组件库', null, null, '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_labels` VALUES ('e2937a6cc53645a0909a3904d8b4517d', 'a337904dd1d5477b9689d7693be316de', 'objective-c', '', '', '2020-04-16 15:14:19', '2020-04-16 15:14:19');
INSERT INTO `tb_labels` VALUES ('e75baefb206a4efe959a99aad77632a3', '049b3bd76c1e49ccbe48b36197e77f76', '安全', null, null, '2020-04-16 16:09:18', '2020-04-16 16:09:18');
INSERT INTO `tb_labels` VALUES ('e7ef2c314f5244fd810e87742ea22b53', 'ee1accc0cfb444fa96d6811569830ecd', '网络安全', null, null, '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_labels` VALUES ('e80d97c3472e428dabdaf417adac7a3c', 'b299a2a48cd64e77a3431ce958b42055', '云计算', '', '', '2020-04-16 15:19:24', '2020-04-16 15:19:24');
INSERT INTO `tb_labels` VALUES ('ead69bffd58e43f2a5ead395c498cf8e', '7b3e40f8b9cc4b7780dc39a71d7f580e', '组件化', null, null, '2020-04-16 16:49:24', '2020-04-16 16:49:24');
INSERT INTO `tb_labels` VALUES ('ec3409e632664448918190c226301c4b', '04547238127a4676b504cc4496865d7b', 'ssh', null, null, '2020-04-16 16:58:56', '2020-04-16 16:58:56');
INSERT INTO `tb_labels` VALUES ('ed28022185f44ae4ba91f8f8b36dc265', '1a7cc9fbc4654cb0afec84e080816ef1', '云存储', null, null, '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_labels` VALUES ('ee14e23a519141ae9086e8f917ca1d67', 'a337904dd1d5477b9689d7693be316de', 'ipad', '', '', '2020-04-16 15:15:32', '2020-04-16 15:15:32');
INSERT INTO `tb_labels` VALUES ('efd45535a5504d5595fba4d1dbbc489c', 'cbad2058b4014634aec6515f4adbef0d', '机器学习', '', '', '2020-04-16 15:18:41', '2020-04-16 15:18:41');
INSERT INTO `tb_labels` VALUES ('f0e336796bd94b8299ef69b2b2529ec4', '049b3bd76c1e49ccbe48b36197e77f76', 'http', null, null, '2020-04-16 16:09:20', '2020-04-16 16:09:20');
INSERT INTO `tb_labels` VALUES ('f2fb7d236fec4c138cacd9162eb4488c', 'a337904dd1d5477b9689d7693be316de', 'https', null, null, '2020-04-16 16:50:18', '2020-04-16 16:50:18');
INSERT INTO `tb_labels` VALUES ('f3eb17e6e5664a97af3e9b1fca12b286', 'ee1accc0cfb444fa96d6811569830ecd', '开放源代码', null, null, '2020-04-16 16:47:15', '2020-04-16 16:47:15');
INSERT INTO `tb_labels` VALUES ('f4485e212bb64f2a8d2761524742e3d7', '91832bd0c3a244fb88c0bca74c0d404d', '找工作', null, null, '2020-04-16 17:00:05', '2020-04-16 17:00:05');
INSERT INTO `tb_labels` VALUES ('f4fda25145b9451a9b0d77d6a2a63712', '2a353971222c4aff8e8d3e9c370330cd', 'git', null, null, '2020-04-16 16:59:46', '2020-04-16 16:59:46');
INSERT INTO `tb_labels` VALUES ('f7e58b2632604a99bbb8f9471c0675ad', 'ee1accc0cfb444fa96d6811569830ecd', '前端框架', null, null, '2020-04-16 16:47:20', '2020-04-16 16:47:20');
INSERT INTO `tb_labels` VALUES ('f831bc1c03f94b4b9e49390a3a354a3e', '7b3e40f8b9cc4b7780dc39a71d7f580e', '云服务', null, null, '2020-04-16 16:49:23', '2020-04-16 16:49:23');
INSERT INTO `tb_labels` VALUES ('f989bd033828421fba0efd21536e57e4', 'cbad2058b4014634aec6515f4adbef0d', '神经网络', '', '', '2020-04-16 15:18:25', '2020-04-16 15:18:25');
INSERT INTO `tb_labels` VALUES ('faf36da502544b51be926ab85450c40d', 'bb0b7e69ad3e46fcb121baefda8f1f78', '算法', null, null, '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_labels` VALUES ('fb364499fe3f4b5bb7f0442e2fe0df82', 'bb0b7e69ad3e46fcb121baefda8f1f78', 'apache', null, null, '2020-04-16 16:48:54', '2020-04-16 16:48:54');
INSERT INTO `tb_labels` VALUES ('fb50fb634b0d40f5af9f608e6ebbd8d1', 'b299a2a48cd64e77a3431ce958b42055', '又拍云存储', '', '', '2020-04-16 15:19:31', '2020-04-16 15:19:31');
INSERT INTO `tb_labels` VALUES ('fd167cdfd8a045b59f76eaf678fc15b9', 'a337904dd1d5477b9689d7693be316de', 'cocoa', '', '', '2020-04-16 15:15:08', '2020-04-16 15:15:08');
INSERT INTO `tb_labels` VALUES ('fe12e28fbbf0499eb1f1008377ea09ff', 'ee1accc0cfb444fa96d6811569830ecd', '代码规范', null, null, '2020-04-16 16:47:19', '2020-04-16 16:47:19');
INSERT INTO `tb_labels` VALUES ('fe213d41bcb743e2840d8aa58cf48d3e', '049b3bd76c1e49ccbe48b36197e77f76', '网页爬虫', null, null, '2020-04-16 16:09:14', '2020-04-16 16:09:14');
INSERT INTO `tb_labels` VALUES ('fe6fc6074c634420b6d2a69f54fc6c50', '7b3e40f8b9cc4b7780dc39a71d7f580e', '百度智能小程序', '', '', '2020-04-16 15:12:38', '2020-04-16 15:12:38');

-- ----------------------------
-- Table structure for tb_recommend
-- ----------------------------
DROP TABLE IF EXISTS `tb_recommend`;
CREATE TABLE `tb_recommend` (
  `uuid` varchar(50) CHARACTER SET utf8 NOT NULL,
  `title` varchar(60) CHARACTER SET utf8 DEFAULT NULL COMMENT '标题',
  `excerpt` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '列表展示字段',
  `content` longtext CHARACTER SET utf8mb4 COMMENT '富文本内容',
  `image_url` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '封面图',
  `user_id` varchar(50) CHARACTER SET utf8 DEFAULT NULL COMMENT '用户id',
  `labels` varchar(255) CHARACTER SET utf8 DEFAULT NULL COMMENT '标签id',
  `views_word` int(11) DEFAULT NULL COMMENT '阅读数',
  `status` int(1) DEFAULT NULL COMMENT '1、草稿箱  2、审核中 3、推荐',
  `type` int(1) DEFAULT NULL COMMENT '1 文章  2 问答',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=sjis COMMENT='文章、问答表';

-- ----------------------------
-- Records of tb_recommend
-- ----------------------------
INSERT INTO `tb_recommend` VALUES ('00bc5856747b4d30b9ffedc5a8ad9b71', 'SegmentFault 思否为什么要做技术媒体？', '2019 年 7 月思否冷启动了媒体业务并开始组建专业技术编辑团队，去年 12 月我们发布的『中国技术品牌影响力企业榜单』在行业引起了广泛关注。开发者应该已经注意到，前不久我们在社区的导航栏低调上线了资讯板块...', '<p>2019 年 7 月思否冷启动了媒体业务并开始组建专业技术编辑团队，去年 12 月我们发布的『<a href=\"https://segmentfault.com/a/1190000021395952\">中国技术品牌影响力企业榜单</a>』在行业引起了广泛关注。开发者应该已经注意到，前不久我们在社区的导航栏低调上线了资讯板块，意味着<strong>思否技术媒体业务正式对外发布</strong>了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF32F\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"SegmentFault 思否技术媒体正式上线\" title=\"SegmentFault 思否技术媒体正式上线\"></span></p> \n<p><strong>媒体业务的上线其实源于思否公司的初心和使命</strong>——</p> \n<p>在思否成立之初我们就确立了“<strong>改变并提升开发者获取知识的效率，帮助开发者获得成功</strong>”的公司使命。除了专业技术，对行业的认知和了解也是“知识”的重要组成部分，影响着开发者的综合素养、职业选择与发展。通过查看源代码可以看到我们对于技术媒体业务的介绍：SegmentFault 思否资讯频道集合了 IT 技术领域最新鲜的行业快讯，深度行业观察和技术人访谈等栏目，<strong>致力于记录和推动 IT 技术行业创新，帮助更多的开发者获得认知和能力的提升</strong>。</p> \n<p>同时，我们希望通过 SegmentFault 技术媒体平台可以更好地分享思否对于技术行业的观点和看法，让我们更多地<strong>与行业产生连接</strong>，<strong>帮助科技企业与开发者对话</strong>。</p> \n<p>在未来我们也希望通过我们的能力<strong>赋能技术媒体行业</strong>，<strong>帮助开发者更好地通过我们的媒体平台发表观点和行业洞见</strong>，记录和推动技术行业的发展。</p> \n<hr> \n<p><strong>关于思否为什么要做技术媒体，我也访谈了公司另外三位合伙人，我们一起来看看他们的想法</strong> ——</p> \n<h4>你为什么想要去做技术媒体？</h4> \n<p><strong>运营合伙人 Nadia</strong>：<em>于我而言，帮助开发者成长就是我『改变世界』的方式和我的新闻理想。</em></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF31n\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"SegmentFault 思否运营合伙人：于我而言，帮助开发者成长就是我『改变世界』的方式和我的新闻理想。\" title=\"SegmentFault 思否运营合伙人：于我而言，帮助开发者成长就是我『改变世界』的方式和我的新闻理想。\"></span></p> \n<p>想去做媒体其实和我的个人经历和理想有很大关系，此前我曾经在传统媒体（《凤凰周刊》、南方报社、广东台）有过 3 年左右的工作 / 实习经历，我相信文字的力量、信息的价值，也体会着个体文字工作者在社会进程中的渺小。</p> \n<p>时隔 5 年，媒体格局已经发生翻天地覆的变化，自媒体的飞速发展、信息爆炸……再做媒体这件事，我会希望可以更专注于某一具体领域，具体来说，我希望可以在思否带领媒体团队做真正面向开发者的技术媒体，筛选对开发者有价值的信息、以开发者的视角去分析和解读，并最终作用于他们，为他们创造价值。</p> \n<p>前段时间在面试一位技术编辑时，我们偶然聊到媒体工作者的『新闻理想』，白岩松说『新闻有助于让这个世界变得更好』，邵飘萍说『铁肩担道义，妙手著文章』，而于我而言，帮助开发者成长就是我『改变世界』的方式和我的新闻理想。</p> \n<h4>你希望我们的媒体业务未来在产品上会有什么创新？</h4> \n<p><strong>产品合伙人 Fen</strong>：<em>赋能技术内容创作者，加强创作者和读者的互动，让交流更加开放自由。</em></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF31p\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"SegmentFault 产品合伙人 Fen：赋能技术内容创作者，加强创作者和读者的互动，让交流更加开放自由。\" title=\"SegmentFault 产品合伙人 Fen：赋能技术内容创作者，加强创作者和读者的互动，让交流更加开放自由。\"></span></p> \n<p>从产品角度，未来社区媒体的产品应该：</p> \n<ol> \n <li>承载不同的媒体类型：支持文字、视频、代码、直播、短消息、邮件等媒体，并帮助他们获得更好的展现；</li> \n <li>为作者提供内容分发的渠道：帮助作者产生的内容触达更多的目标读者；</li> \n <li>为读者提供内容筛选的能力：帮助读者快速获取自己需要的内容；</li> \n <li>建立个体与个体互动关系：加强作者和读者的互动，让交流更加开放自由。</li> \n</ol> \n<p>谈不上创新，本质上是电子邮件和邮件组的衍生，我觉得 ActivityPub 的一张图可以很好的解释。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF23v\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"ActivityPub\" title=\"ActivityPub\"></span></p> \n<h4>对于我们技术媒体业务有什么建议和期待？</h4> \n<p><strong>技术合伙人 Joyqi</strong>：技术媒体千千万，能让人记住你却不多。做媒体不一定要吸引眼球，但希望能有自己的理念，并一直坚持下去。<strong>读者更希望看到的是人的观点，而不只是新闻。</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF31z\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"SegmentFault 思否技术合伙人Joyqi：读者更希望看到的是人的观点，而不只是新闻\" title=\"SegmentFault 思否技术合伙人Joyqi：读者更希望看到的是人的观点，而不只是新闻\"></span></p> \n<hr> \n<p>我们的媒体业务还处在早期，也还有很多不完善的地方，我们非常欢迎各位开发者和从业者给我们反馈建议。</p> \n<p>我们也非常欢迎各位社区开发者和各科技厂商的媒体关系同事与我们建立联系，给我们贡献优质的新闻源。</p> \n<p><strong>联系邮箱：pr@segmentfault.com</strong></p>', 'https://segmentfault.com/img/bVbF32F', '5ca4567d892841b087fac5246effac40', '57f41641447a40eb9bde76ded2a16296,81a4561c1c294e0cae32c9fe6b5dc397,aed399344712406e830d6efe028b7fe2', '0', '3', '1', '2020-04-16 16:47:09', '2020-04-16 16:47:09');
INSERT INTO `tb_recommend` VALUES ('00dac1be4aa94e168232f9bf81844f0d', 'Android | 教你如何开发扫二维码功能', '最近要做一个停车场扫码收费的app，在网上搜了一圈，首先接触到了ZXing，上手试了下，集成过程不复杂，但是感觉效果欠佳，比如距离稍微远点儿就扫不出来了，另外角度对的不好，反光或者光线比较暗的时候，成功率...', '<h1>前言</h1> \n<p>  最近要做一个停车场扫码收费的app，在网上搜了一圈，首先接触到了ZXing，上手试了下，集成过程不复杂，但是感觉效果欠佳，比如距离稍微远点儿就扫不出来了，另外角度对的不好，反光或者光线比较暗的时候，成功率也比较低，集成好给我们老大看了下，感觉不是很满意。最近偶尔看到了华为一个发布会里面有介绍扫码功能，稍微研究了下，居然是一款免费扫码神器，官方称之为Scan Kit，号称还同时支持Android和iOS，半信半疑上手搞了一把发现效果还真不错！测了下发现对于一些有反光，污损，形变，超远距离的场景都能很好地识别！<br>  今天简单总结了下，分享给大家，码字不易，也算是疫情期间，给大家的一点小小福利。</p> \n<hr> \n<h1>官网的Demo和Sample代码体验</h1> \n<p>  官网有Demo可以直接下下来体验，还有sample代码样例，小伙伴们可以直接到官网下载Demo或者示例代码体验下：<a href=\"https://developer.huawei.com/consumer/cn/doc/development/HMS-Examples/scan-sample-code4\" rel=\"nofollow noreferrer\">华为官网的Demo和示例代码</a>，示例代码下下来就可以运行。<br>我自己也结合下面的讲解写了个简易的sample，各位看官也可以下下来参考。<br>  <a href=\"https://download.csdn.net/download/winisit86/12243327\" rel=\"nofollow noreferrer\">简易扫码sample示例</a></p> \n<hr> \n<h2>1 开发准备</h2> \n<h3>1.1 android studio 安装</h3> \n<p>  这里就不啰嗦了，到官网下载和安装：<a href=\"https://developer.android.com/studio\" rel=\"nofollow noreferrer\">Android studio官网下载链接</a>，<a href=\"https://www.cnblogs.com/xiadewang/p/7820377.html\" rel=\"nofollow noreferrer\">Android studio安装流程参考链接</a></p> \n<h3>1.2 在项目级gradle里添加华为maven仓</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022352728\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>  增量添加如下maven地址：</p> \n<pre><code class=\"java\">buildscript {\n    repositories {        \n        maven {url \'http://developer.huawei.com/repo/\'}\n    }    \n}\nallprojects {\n    repositories {       \n        maven { url \'http://developer.huawei.com/repo/\'}\n    }\n}</code></pre> \n<h3>1.3 在应用级的build.gradle里面加上SDK依赖</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022352727\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>  增量添加SDK依赖，SDK他们有两种版本，plus和普通版，plus效果好点儿但是包稍微大一点儿，这个地方我选了plus版本,小伙伴们可以根据自己需要自行选择,版本号填他们最新的版本就好。</p> \n<pre><code class=\"java\">dependencies{ \n  implementation \'com.huawei.hms:scanplus:1.1.1.301\' \n }</code></pre> \n<h3>1.4 加一下混淆配置</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022352729\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>  复制粘贴华为官网上给的混淆代码就可以了</p> \n<pre><code class=\"java\">-ignorewarnings \n-keepattributes *Annotation*  \n-keepattributes Exceptions  \n-keepattributes InnerClasses  \n-keepattributes Signature  \n-keepattributes SourceFile,LineNumberTable  \n-keep class com.hianalytics.android.**{*;}  \n-keep class com.huawei.**{*;}</code></pre> \n<h3>1.5 Manifest申请静态权限和扫码页面声明：</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022352730\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>  申请静态权限和使用特性</p> \n<pre><code class=\"java\">&lt;!--相机权限--&gt; \n&lt;uses-permission android:name=\"android.permission.CAMERA\" /&gt; \n&lt;!--读文件权限--&gt; \n&lt;uses-permission android:name=\"android.permission.READ_EXTERNAL_STORAGE\" /&gt; \n&lt;!--使用特性--&gt; \n&lt;uses-feature android:name=\"android.hardware.camera\" /&gt; \n&lt;uses-feature android:name=\"android.hardware.camera.autofocus\" /&gt;</code></pre> \n<p>  在application标签内添加对扫码页面的声明</p> \n<pre><code class=\"java\">&lt;!—对扫码页面进行声明--&gt; \n&lt;activity android:name=\"com.huawei.hms.hmsscankit.ScanKitActivity\" /&gt;</code></pre> \n<h2>2 代码开发</h2> \n<h3>2.1 动态申请权限</h3> \n<p>  在启动扫码Activity的地方添加动态权限申请。</p> \n<pre><code class=\"java\">public void loadScanKitBtnClick(View view) {\n    requestPermission(CAMERA_REQ_CODE, DECODE);\n}\n\nprivate void requestPermission(int requestCode, int mode) {\n    ActivityCompat.requestPermissions(\n            this,\n            new String[]{Manifest.permission.CAMERA, Manifest.permission.READ_EXTERNAL_STORAGE},\n            requestCode);\n}</code></pre> \n<h3>2.2 在权限申请回调中启动扫码界面</h3> \n<p>  扫码格式通过setHmsScanTypes指定为QR码，小伙伴们如果需要支持其它码可以自己指定。</p> \n<pre><code class=\"java\">@Override\npublic void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {\n    if (permissions == null || grantResults == null) {\n        return;\n    }\n    if (grantResults.length &lt; 2 || grantResults[0] != PackageManager.PERMISSION_GRANTED || grantResults[1] != PackageManager.PERMISSION_GRANTED) {\n        return;\n    }\n    if (requestCode == CAMERA_REQ_CODE) {\n        ScanUtil.startScan(this, REQUEST_CODE_SCAN_ONE, new HmsScanAnalyzerOptions.Creator().setHmsScanTypes(HmsScan.QRCODE_SCAN_TYPE).create());\n    }\n}</code></pre> \n<h3>2.3 在activity回调里面获取码结果</h3> \n<pre><code class=\"java\">@Override\nprotected void onActivityResult(int requestCode, int resultCode, Intent data) {\n   super.onActivityResult(requestCode, resultCode, data);\n   if (resultCode != RESULT_OK || data == null) {\n       return;\n   }\n   if (requestCode == REQUEST_CODE_SCAN_ONE) {\n       HmsScan obj = data.getParcelableExtra(ScanUtil.RESULT);\n       if (obj != null) {\n           this.textView.setText(obj.originalValue);\n       }\n   }\n}</code></pre> \n<hr> \n<h1>结后语</h1> \n<p>  整个代码开发过程就结束了，是不是超简单，给大家看下效果：<br>效果非常赞，支持自动缩放，两米开外瞬间就识别成功了！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022352731\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>附官方开发指南<br><a href=\"https://developer.huawei.com/consumer/cn/doc/development/HMS-Guides/scan-introduction-4\" rel=\"nofollow noreferrer\">华为扫码服务员官方指南</a></p> \n<hr> \n<p>往期链接：Android | 教你如何用代码一键实现银行卡绑定</p> \n<p>内容来源：<a href=\"https://developer.huawei.com/consumer/cn/forum/topicview?tid=0201217390745110144&amp;fid=18\" rel=\"nofollow noreferrer\">https://developer.huawei.com/consumer/cn/forum/topicview?tid=0201217390745110144&amp;fid=18</a></p> \n<p>原文来源：<a href=\"https://blog.csdn.net/winisit86/article/details/104807678\" rel=\"nofollow noreferrer\">https://blog.csdn.net/winisit...</a></p> \n<p>原作者：winisit86</p>', 'https://segmentfault.com/img/remote/1460000022352728', '6fbfa4aaad3a43458f21c8acf0038ac5', '8dfc62f227ae4076888ea4872e03cddd,2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-16 16:54:48', '2020-04-16 16:54:48');
INSERT INTO `tb_recommend` VALUES ('02e03eba26e645d08c95cd8b426a5e7c', 'Chrome 81 发布 ！消灭混合内容的最后一步～', 'Chrome 81 于前天正式发布了，这个版本其实最初是计划在 3 月 17 号 发布的，但由于冠状病毒（COVID-19）爆发而导致推迟到了现在。Chrome 81 的延迟也扰乱了 Google 正常的六周发布时间表。因此 Google 此前也宣...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309252\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><code>Chrome 81</code> 于前天正式发布了，这个版本其实最初是计划在 <code>3 月 17 号</code> 发布的，但由于冠状病毒（<code>COVID-19</code>）爆发而导致推迟到了现在。<code>Chrome 81</code> 的延迟也扰乱了 <code>Google</code> 正常的六周发布时间表。因此 <code>Google</code> 此前也宣布，下一个版本将直接跳过 <code>Chrome 82</code> ，直接发布 <code>Chrome 83</code>。</p> \n<p>下面我就来带大家看看 <code>Chrome 81</code> 有哪些重要的更新。</p> \n<h2>速览</h2> \n<ul> \n <li>混合内容升级三步走的第三步 —— 禁用混合img资源</li> \n <li>删除 FTP 协议支持</li> \n <li>弃用 TLS 1.0 和 TLS 1.1（延迟）</li> \n <li>TLS 1.3 稳定性增强</li> \n <li>不安全的下载将被直接阻止</li> \n <li>支持 WEB NFC</li> \n</ul> \n<h2>混合内容升级三步走的第三步 —— 禁用混合img资源</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309250\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><code>Chrome 81</code> 标志着 <code>Google</code> 分三步走的计划中的最后一个版本，该计划目的是从网络上全面消除混合 <code>HTTPS</code> 内容。</p> \n<blockquote>\n 混合 \n <code>HTTPS</code> 内容早在上个版本（\n <code>Chrome 80</code>）的更新中我就介绍过了：是指通过 \n <code>HTTP</code> 和 \n <code>HTTPS</code> 加载图像、\n <code>JavaScript</code> 或样式表等内容的网页，这意味着该站点实际上并不完全通过 \n <code>HTTPS</code> 加载。\n</blockquote> \n<p><code>Google</code> 宣布的最终目标是将所有 <code>HTTP</code> 内容自动升级到他们的模拟 <code>HTTPS URL</code>。但是，一次性执行这样的操作是很危险的，因为这可能会导致大量混合内容的站点出现问题。</p> \n<p>因此，为了防止造成重大破坏，<code>Google</code> 为该过程选择了一个三步计划：</p> \n<p>在 <code>2019</code> 年 12 月发布的 <code>Chrome 79</code> 中，该团队将引入一个新设置来取消阻止特定网站上的混合内容。此设置将应用于混合脚本、<code>iframe</code> 和 <code>Chrome</code> 当前默认阻止的其他类型的内容。用户可以通过单击任意 <code>https://</code> 页面上的锁定图标并单击“站点设置”来切换此设置。这将替换显示在多功能框右侧的屏蔽图标，以取消阻止以前版本的台式机 <code>Chrome</code> 浏览器中的混合内容。</p> \n<p>在 <code>Chrome 80</code> 中，混合的音频和视频资源将自动升级到 <code>https://</code>，如果它们无法通过 <code>https://</code> 加载，则 <code>Chrome</code> 默认会阻止它们。 <code>Chrome 80</code> 仍然可以加载混合图像资源，但它们会使 <code>Chrome</code> 在状态框上显示不安全。</p> \n<p>在 <code>Chrome 81</code> 中，混合的图像资源会自动升级到 <code>https://</code>，如果无法通过 <code>https://</code> 加载，<code>Chrome</code>默认会阻止它们。</p> \n<h2>弃用 TLS 1.0 和 TLS 1.1（延迟）</h2> \n<p><code>Chrome</code> 小组早在去年10月就宣布了淘汰旧版TLS版本（<code>TLS 1.0和1.1</code>）的计划。<code>Firefox 74</code> 也在前几天宣布将禁用基于 <code>TLS 1.0 和 TSL 1.1</code> 协议的网站。</p> \n<p>在 <code>Chrome 81</code> 中，<code>Chrome</code> 将用整页警告标记用户不支持 <code>TLS 1.2</code> 更高版本的站点连接不完全安全。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309248\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>但是，在最新的 <code>Chrome</code> 官方博客中我发现：从 <code>Chrome</code> 删除 <code>TLS 1.0</code> 和 <code>TLS 1.1</code> 加密协议的计划现在延迟到了 <code>Chrome84</code>。延迟删除这两个协议的决定与当前的新冠病毒爆发有关，因为很多重要政府医疗网站还在使用 <code>TLS 1.0 和 1.1</code> 来建立其 <code>HTTPS</code> 连接，现在进行整页警告可能会对抗击疫情造成影响。</p> \n<p>目前 <code>Chrome</code> 将继续针对使用 <code>TLS 1.0</code> 或 <code>1.1</code> 的网站显示 “不安全” 提示， <code>Chrome 81 Beta</code> 会显示受影响网站的整页插页式警告。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309249\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>删除 FTP 协议支持</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309253\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><code>Chrome 81</code> 将不再直接支持 <code>FTP</code> 协议，建议用户使用本机 FTP 客户端。</p> \n<h2>TLS 1.3 稳定性增强</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309251\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在 <code>Chrome</code> 之前的更新中，由于开启了 <code>TLS 1.3</code>，但是兼容性没有处理好，而 <code>TLS 1.3</code> 只有在浏览器端和服务器同时支持的时候才能正常访问。从而导致大量用户无法访问站点，谷歌官方当时给出的解决办法是先关闭浏览器的 <code>TLS 1.3</code> 版本的支持。后来 <code>Chrome</code> 又禁用了一些 <code>TLS 1.3</code> 的功能才使得访问稳定。</p> \n<p><code>Chrome 81</code> 中又对 <code>TLS 1.3</code> 做了加强，防止攻击者降级到 <code>TLS 1.2</code> 及更早版本，并且支持了 <code>TLS 1.3</code> 完整功能的向后兼容。</p> \n<h2>不安全的下载将被直接阻止</h2> \n<p>从 <code>Chrome 83</code> 开始，不安全的下载将直接被阻止，和上面的混合内容更新一样，这个更新也是分步进行的，直到 <code>Chrome 86</code> 所有在安全页面上的不安全的下载将被全部阻止：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309254\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>支持 WEB NFC</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309255\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><code>Chrome</code> 中添加的新的 <code>Web NFC</code> 标准将允许网站与 <code>NFC</code> 标签进行交互，从而无需用户在手机上安装特殊的应用程序。</p> \n<pre><code class=\"js\">const reader = new NDEFReader();\n\nasync function startScan() {\n  await reader.scan();\n  reader.onreading = (e) =&gt; {\n    console.log(e.message);\n  };\n}</code></pre> \n<p><code>Google</code> 相信，新的 <code>Web NFC</code> 标准将在 <code>Web</code> 开发人员中取得广泛的应用，尤其是对于 <code>Android</code> 版 <code>Chrome</code> 而言，该标准可用于以下场景：</p> \n<p>当用户将运行 <code>Chrome</code> 的智能手机或平板电脑触摸展览附近的 <code>NFC</code> 卡时，博物馆和美术馆可以显示有关显示器的其他信息。</p> \n<p>处理公司库存的网站，公司站点和 <code>Intranet</code> 将能够读取数据或将数据写入容器或产品上的 <code>NFC</code> 标签，从而简化库存管理。</p> \n<p>会议现场可以使用它来扫描 <code>NFC</code> 标签。</p> \n<h2>AR（增强现实）支持</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022309256\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>谷歌为 <code>WebXR API</code> 增加了两个沉浸性特性，允许在相机视图中放置虚拟物体。</p>', 'https://segmentfault.com/img/remote/1460000022309252', '692c6787030d4b8882077b2ab9279c52', '63c4e1e7ec204b43a62065a3ced4c2ce,b687605a1b8842a593f27620e3c26af5,e75baefb206a4efe959a99aad77632a3', '0', '3', '1', '2020-04-16 16:58:55', '2020-04-16 16:58:55');
INSERT INTO `tb_recommend` VALUES ('03ab3eb0493e471a8410aaf7325866eb', '如何清爽的安排日常？', '你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it well enough', '<p>| <strong>好看请赞，养成习惯</strong></p> \n<blockquote>\n <ul> \n  <li>你有一个思想，我有一个思想，我们交换后，一个人就有两个思想</li> \n  <li>If you can NOT explain it simply, you do NOT understand it well enough</li> \n </ul>\n</blockquote> \n<hr> \n<p>有朋友私信问我如何安排日常，以及相对高效的写东西？我觉得有必要单独写一篇文章来和大家交流这个事</p> \n<h2>不做没有灵魂的 TODO List</h2> \n<p>我们都是上进的好青年，大家手里应该都有自己的 TODO list，我通常会用 <code>Microsoft To Do</code> 这款软件做简单的日常安排</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF22M\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>求学期间，每个寒暑假临近，我都可以把做各种 plan，立各种 flag 的气质拿捏的死死的。如你所料，假期过后一个 plan 都没有做，一个 flag 都没有完成。</p> \n<p>这种表面风光，实则没有了灵魂TODO list 只是短期心理慰藉，当需要验证结果时，情绪轻则低落一会，重则焦虑半天</p> \n<p>造成这种问题的原因很简单</p> \n<ul> \n <li>大杂烩 TODO</li> \n <li>没有轻重缓急</li> \n <li>没有可以落地的执行计划和自我约束能力</li> \n</ul> \n<p>如何解决这个问题呢？</p> \n<h3>筛选</h3> \n<p>做事我们知道三思而后行，做 plan 好像没有成本一样，我却忘记了三思而后行的道理。导致 todo list 又臭又长的原因多数出于冲动性思维，这是人性，但我不打算逆人性而为之，我选择在原有基础上，再多做两个 todo list（你没看错）</p> \n<ul> \n <li>清单B（Agile Backlog）：日常天马行空的，意淫的，临时想到的，我都会放到这个清单里面，满足了我这【收藏】梦</li> \n <li>清单G（Agile Grooming）: 反复查看清单A，自我反问，某一项是你想要的吗？最终在该清单G中留下3到7个选项</li> \n <li>清单S（Agile Sprint）：灵魂拷问自己，做出取舍，最多能留下 1到3个</li> \n</ul> \n<p>这样我们只需在短时间内关注<code>清单S</code>的内容，当清单S的内容做完，重复这个筛选步骤即可。我的欲望清单并没有删减，只是换了个视角，感觉完全不一样了</p> \n<h3>优先级</h3> \n<p>事有【轻重缓急】，这四个字的排列组合就是你熟悉的象限图了</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF22R\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>排列优先级是基本技能，注意这个图是要持续更新的，而不是一成不变的</p> \n<blockquote>\n Tips: 生活中总会有很多插曲来打断我们的计划，所以我并不会将时间排的很满，一定要给自己留有一些buffer，这样不至于被其他事打断，导致原有事情做不完而带来的挫败感，但也不能留太多buffer，因为我们都有拖延症/惰性\n</blockquote> \n<p>另外，生活中的大多数事情都处在第二象限【重要 &amp; 不紧急】，所以如何分解任务，制定计划，并按部就班执行就显得很重要了</p> \n<h2>不要将整块时间碎片化</h2> \n<p>都知道有连续性的做事会比较高效，这就需要整块的时间，但当我有整块时间时，貌似并不珍惜这个福利，一会看手机聊天，一会读书，一会看视频。感觉自己忙忙碌碌，实则什么都没做成，过后需要验证成果时，一片茫然，原因是我们将时间碎片化了</p> \n<p>我们能保持专注的时间有限，过长时间的约束自己反而是逆人性的行为，所以我们就需要在专注和放松之间找到一个平衡点</p> \n<h3>番茄工作法</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF22S\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>按照番茄工作法，一个番茄钟是25分钟，番茄钟铃响，休息3～5分钟，继续下一个番茄钟。番茄钟内科学的让我保持专注；休息时间又让我简单把玩手机。更重要的是可以将整块事情按照番茄钟进行细分，形成可执行的计划（Chrome浏览器就有相应的番茄插件，比如我用的这个）<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF22T\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>最大化利用碎片化时间</h2> \n<p>大家的碎片化时间真的非常多，感觉可以玩手机的时间都是我们的碎片化时间（你脑补一下你通常都在什么时候玩手机）</p> \n<p>这个时间我们能做什么？</p> \n<ul> \n <li>简单拉伸动作和扩展运动</li> \n <li>回顾过去一两天的点点滴滴做个复盘总结，做到心中有数</li> \n <li>集中阅读高质量订阅（比如日拱一兵，这个广告打的连我自己都猝不及防）</li> \n <li>给家人朋友一些问候</li> \n <li>......</li> \n</ul> \n<p>你会发现，生活中的一些细枝末节小事，都可以通过碎片化时间来完成，不会忙忙碌碌</p> \n<h2>分清主次</h2> \n<p>大家都是成年人，生活中肯定不止一两件事需要你照顾。即便同样多的事，每个人照顾的方式和顺序不一样，得到的结果和感受自然也就不一样，为了说明这个问题，我把很久以前看过的一个视频放到这里【如果视频打不开，可以点开打开<a href=\"https://mp.weixin.qq.com/s/Otyl5dcAin0zpUm_RX-kqQ\" rel=\"nofollow noreferrer\">如何清爽的安排日常？</a> 查看】</p> \n<p><a href=\"http://www.youtube.com/watch?v=R0C_uHXiH10\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF22U\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p>像视频中说的一样，偶尔给自己几杯啤酒（我酒精过敏就不喝了）</p> \n<h2>寻找</h2> \n<p>我们都是程序员，我就拿程序工作的事情举例子：</p> \n<ul> \n <li>你写了无数个CRUD，带给你的是什么感觉？</li> \n <li>你做了简单的调优，性能提升了几个百分比，带给的是什么感觉？</li> \n <li>你通过努力，克服一些困难，完成一些你之前看似很难得的问题，带给你的是什么感觉？</li> \n</ul> \n<p>我们无时无刻不需要自身的成就感来驱动自我，下面这句话是我焦虑的时候发给我的朋友佳兴大佬得到的回复，希望对你有帮助</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF22V\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<hr> \n<p>最后，都说执行困难，如果你没有行之有效的方法，请按照上面这些方法进行逐步改善，自然会给你带来幸福感和成就感，也就自然会推动你做下一步执行</p> \n<p>我也在改变思维和方式的路上... 我们一起</p> \n<p>最后如果你通过这个方法改变了很多，一定要记得回来告诉我，这能给我带来成就感</p> \n<p>日拱一兵 ｜ 原创</p>', 'https://segmentfault.com/img/bVbF22M', '692c6787030d4b8882077b2ab9279c52', '2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-16 16:47:08', '2020-04-16 16:47:08');
INSERT INTO `tb_recommend` VALUES ('04f38022641843c38cb5e7b4ceeac83f', 'SegmentFault 支持赛事：全国高校金融科技挑战赛决赛倒计时，顶尖战队巅峰对决！', '2006 年世界杯，齐达内怒撞马特拉齐，让法国队错失大力神杯，如果当年的计算机能够上线唇语识别技术，鹿死谁手犹未可知。时至今日，视频裁判等手段逐渐普及，科技人才拿着代码正在改变赛场规则。', '<p>2006 年世界杯，齐达内怒撞马特拉齐，让法国队错失大力神杯，如果当年的计算机能够上线唇语识别技术，鹿死谁手犹未可知。时至今日，视频裁判等手段逐渐普及，科技人才拿着代码正在改变赛场规则。</p> \n<p>日前，经过三个多月角逐，由 SegmentFault 特别支持的 2019“创青春•交子杯”新网银行高校金融科技挑战赛线上初赛结束，两个赛道 10 强战队突出重围，即将在 12 月 7 日 - 8 日，汇聚蓉城展开巅峰对决。来自新网银行的“主考官”设置了两道参赛题目，不仅有考验挑战者 AI 建模能力，利用说话人嘴唇运动序列图片，识别说话内容的考题。还有测试分布式算法能力，考验挑战者打造一个动态高可用网络能力的考题。</p> \n<p>SegmentFault 携手新网银行在成都举办这样一场具有全国高校影响力的赛事，对于推动西部金融科技建设、加强校企合作，动员更多青年为推动治蜀兴川再上新台阶贡献青春力量具有重要意义。</p> \n<h2>重奖寻觅金融科技人才 为治蜀兴川招贤纳士</h2> \n<p>2019 “创青春•交子杯”新网银行高校金融科技挑战赛开赛以来，吸引了来自北京大学、清华大学、复旦大学、武汉大学、浙江大学、厦门大学、斯坦福大学、康奈尔大学等 208 所高等学府学子参赛，共有 1632 名 Hack 参赛，3054 套算法作品脱颖而出，最终 20 支顶尖战队集结成都展开巅峰对决。</p> \n<p>此次活动由共青团四川省委、四川省教育厅、四川省地方金融监督管理局主办，成都市地方金融监督管理局、成都市高新区管委会、四川新网银行承办，主要面向全国在校大学生（含本科、硕士/博士研究生等）。SegmentFault 作为赛事支持单位深度参与线上线下选手招募、赛事运营等环节。</p> \n<p>举办这样一场科技挑战赛事，是为了发掘金融科技领域的优秀在校大学生，锻造金融实战能力。活动主办方还拿出了 47 万元奖金、丰厚的人才培养计划，重奖获胜挑战者。</p> \n<p>据大赛主办方透露，入围作品数量超出了预期，“唇语识别涉及前沿的计算机视觉、自然语言处理技术，需要熟练运用深度学习等人工智能算法，这对学生来说还是挺难的。”据介绍，主办方通过机器评审，在线测试作品准确率，排名前十的准确率都超过了 80%，第一名更是达到了 85.2% 的好成绩。</p> \n<h2>两条赛道火力全开 金融科技应用领域更广</h2> \n<p>立足成都，以“技术立行”，设置赛题的新网银行是成都金融科技领域的“排头兵”，作为四川省金融科技典范企业，新网银行被纳入了地方的独角兽企业培育计划，牵头的“智能金融风险管控”项目，2018 年也成功入选四川省新一代人工智能重大科技专项，这些金融科技在社会其他领域同样具有现实意义。</p> \n<p>“在金融领域的人工智能等技术，对于生产生活的其他领域同样适用。”据新网银行风控科学部的相关人士介绍，在此次金融科技挑战赛中将唇语识别作为挑战内容，也是为了鼓励大学生学习和实践 AI 技术，激活大家的创新思维。据他介绍，对于银行的反欺诈系统来说，唇语识别可以很直接地辅助人脸识别、活体语音等，形成综合多模态识别手段。</p> \n<p>一旦技术成熟，这项技术即使离开金融领域，也能够有广泛的运用，比如在噪音环境下辅助语言识别，运用到穿戴设备智能交互、智能家居中，还能够运用到公益项目中，比如辅助听障人士交流。</p> \n<p>在分布式算法赛道（智能路由），比赛目的则是基于开放银行模式下，银行与互联网平台、银行与科技服务商、银行与银行交融成了一张复杂的数据交换网络，挑战者需要打造一个动态高可用网络，满足银行间的数据传输的速率及稳定性的要求。</p> \n<h2>构筑金融产业集群 迈向国家西部金融中心城市</h2> \n<p>成都正在朝着建设国家西部金融中心城市极速前进，新网银行也将培养高素质金融人才队伍，提高金融科技迭代速度，将移动互联、5G、人工智能等技术引进“开放银行”建设，继续实施普惠金融，支持创新创造业，为实体经济发展护航。 </p> \n<p>从 2017 年开始，成都市也出台了系列金融扶持政策，增强西部金融中心功能，全面构筑现代金融产业集群和支撑体系，强化金融要素市场建设，加快发展新兴金融业态，优化金融生态环境，到 2022 年，成都将全面建成立足四川、服务西部、辐射全国、具有国际影响力的西部金融中心。</p>', null, '1894b118d35d44cb8fe8009529c4154b', '2a09bf1afefd4d659606f43445741ee3,278262a4258f4beca20e334398ab06d8,6aec6c8499c44483beecd569d05c7f4b,d009d894f21a489c88c52d85c142b3ba,57f41641447a40eb9bde76ded2a16296', '0', '3', '1', '2020-04-16 16:59:10', '2020-04-16 16:59:10');
INSERT INTO `tb_recommend` VALUES ('063f9176eaef47cb97585b486142e1df', '不交“赎金”就打爆！出海游戏企业如何应对DDoS勒索', '2019年12月下旬，某游戏公司突然遭到70G流量的DDoS攻击，并基于前期购买的UCloud高防服务抵抗住了这一波攻击。游戏公司负责人G先生本以为这就是一次小打小闹，黑客方应该已经知难而退。', '<p>近年来，中国互联网出海已成燎原之势，游戏出海，网络先行。但是，DDoS 攻击却始终是环绕在出海游戏企业头顶的噩梦。</p> \n<p>近期，UCloud安全中心就接到一例关于DDoS勒索攻击的求助，最终经过完备的云上安全防护，成功逼退黑客。</p> \n<h2><strong>不交“赎金”就打爆！</strong></h2> \n<p>2019年12月下旬，某游戏公司突然遭到70G流量的DDoS攻击，并基于前期购买的UCloud高防服务抵抗住了这一波攻击。游戏公司负责人G先生本以为这就是一次小打小闹，黑客方应该已经知难而退。</p> \n<p>没有料到的是，这仅仅是一次攻击的前奏曲。</p> \n<p>当天晚上，G先生便收到了来自黑客组织的勒索消息。黑客方声称来自A记，A记是一个臭名昭著的国际黑客组织，从2018年起便陆续被各大安全厂商曝光DDoS勒索的行径。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979751\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>图：黑客勒索的沟通截图</p> \n<p>在G先生与黑客的沟通过程中，黑客声称第一次的70G DDoS攻击只是一个引子，如若G先生不妥协，将持续发动更大规模的攻击。</p> \n<p>这也是A记黑客组织一贯的攻击套路，通常先进行小规模攻击试探，并威胁企业支付“赎金”，如果被拒便会发起更为猛烈的大流量攻击，以此胁迫企业就范。可以看出来，黑客应该已有多次勒索成功经历，似乎笃定了这次G先生也会妥协，言辞之间非常狂妄嚣张。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979752\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>图：黑客态度非常狂妄</p> \n<h2><strong>妥协 or 拒绝？</strong></h2> \n<p>可能有很多人不太理解，为什么黑客组织会有勒索成功的经历，以下稍作说明。</p> \n<p>DDoS攻击与其他黑客攻击的区别在于，DDoS没有太多花样，不像钓鱼链接、后门等需要伪装潜伏的攻击手段，DDoS攻击非常简单粗暴，就是<strong>以攻击量取胜</strong>。</p> \n<p>这也便导致了2个问题：</p> \n<p>1、防御成本远远高于攻击成本；</p> \n<p>2、大流量攻击下出海游戏企业难以抵御。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979754\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>什么意思呢？对于游戏企业来讲，网络稳定性至关重要，访问中断几小时或者几天，便足够毁掉一个企业。正因如此，不少黑客瞄准了受害者的心理，出海游戏企业便成为了DDoS受害的重灾区。此外，当发生上百G甚至更高的大流量攻击时，通常需要多集群防护与足够的带宽资源，这也对提供抗DDoS服务的安全企业提出了较高的要求。</p> \n<p><strong>由于缺钱缺资源、攻击紧迫性又非常高</strong>，不少企业出于“花钱买平安”的心态，便会屈服于黑客的勒索之下。</p> \n<p>此时，摆在G先生面前也是同样一个问题：<strong>妥协 or &nbsp;拒绝？</strong></p> \n<p>毫无疑问，G先生果断拒绝。</p> \n<h2><strong>成功化解300G大流量攻击</strong></h2> \n<p>黑客与G先生谈崩以后，恼羞成怒，摈弃之前小规模的试探，在当天下午2点钟左右便开始发动猛烈的攻势。如下图，攻击流量瞬时达到了<strong>近300G的峰值</strong>！ </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979753\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>图：攻击流量监控图</p> \n<p>可能有读者无法直观体会300G大流量攻击的威力，来看近期发生的一个案例：2月28日，加密货币交易所 OKEx 先是遭到300G流量攻击，致使网络宕机1分钟左右，之后又遭到400G流量攻击，直接导致 OKEx 暂停相关交易40分钟。</p> \n<p>在本次针对游戏企业的攻击过程中，除了超大流量外，黑客还发动了多种攻击手段，先是<strong>DNS反射与LDAP反射齐飞</strong>，接着又陆续发动<strong>TCP SYN Flood</strong>、<strong>ACK Flood</strong>以及各种<strong>IP层报文的混合攻击</strong>……总攻击时长持续<strong>73分钟</strong>，累计攻击流量<strong>39PB</strong>。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979755\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>图：各类攻击手段数据统计</p> \n<p>可以看到，黑客几乎拿出了所有看家本领。但是，在UCloud的协助布防下，这次攻击对用户网络丝毫无影响，在此期间，游戏业务正常稳定运行。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979756\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>图：与用户确认业务是否受影响</p> \n<p>在游戏公司遭受第一波小规模DDoS攻击时，UCloud安全中心便已介入了解该事件。在了解到勒索情况后，由于无法预估黑客具体的攻击数字，UCloud和用户沟通后建议采用<strong>弹性防护措施布防</strong>，并先后采取高防IP分配、特殊转发规则配置、精细化防护策略添加等手段，实现隐藏用户源站IP的效果。</p> \n<p>当黑客开始攻击时，所有的攻击量及攻击手段全部被转移至UCloud云端高防IP站点，该高防站点设置攻击上限为1T，可轻松实现300G的攻击量抵御。最终，成功逼退A记黑客组织。</p> \n<h2><strong>黑客攻击手段分析</strong></h2> \n<p>此次事件并不是个例，在UCloud安全中心的监测历史中，DDoS攻击的发生频率非常高，我们也帮助用户做了不少防御。</p> \n<p>我们注意到，黑客的攻击手段在不断进化，除了常规的的Syn Flood攻击、CC攻击等，近几年更为流行的是<strong>反射放大型攻击</strong>，也是本次攻击过程中黑客使用较多的一类手段：攻击者只需要付出少量的代价，即可对需要攻击的目标产生巨大的流量，对网络带宽资源、连接资源和计算机资源造成巨大的压力。</p> \n<p>常规DDoS攻击的缺点是耗时长且隐蔽度不够，黑客很可能出现伤敌一千、自损八百的情况，而反射放大型攻击则充分实现了<strong>四两拨千斤</strong>的效果。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979758\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>图：反射放大攻击示意</p> \n<p>以DNS反射放大型攻击原理为例，网络上有大量的开放DNS解析服务器，它们会响应来自任何地址的解析请求。通常发出很小的解析请求长度后，便会收到大量的结果，尤其是查询某一域名所有类型的DNS记录时，返回的数据量就更大了。攻击者利用被控制的机器发起伪造的解析请求，然后将放大数倍的解析结果返回给被攻击目标，以此达成反射放大攻击的目的。</p> \n<h2><strong>公有云抗DDoS指南</strong></h2> \n<p>针对公有云 DDoS 防护问题，除了常规的高防服务以外，我们还自研了 Anycast 全球清洗技术，充分利用 UCloud 覆盖全球多地域节点的 BGP 宣告能力及节点间的专线资源，帮助海外公有云用户实现 DDoS 的无忧防护。</p> \n<p>Anycast 清洗技术主要针对部分海外业务场景中网络复杂、基础设施保障不稳定的情况，如下图，基于强大的检测集群、清洗集群及上联带宽资源，AnycastClean 可从横向扩充清洗节点的角度完成大流量 DDoS 清洗。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021979757\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>图：攻击流量被引至法兰克福/华盛顿/台北节点分散清洗</p> \n<p>同时&nbsp;Anycast&nbsp;清洗能力不设上限，集合海外多个地域节点的清洗能力，可帮助用户全力进行抗攻击保障。换句话讲，AnycastClean 能够将海量集中的攻击源分散至多处 UCloud 海外节点，将原本巨大的攻击流一一化解，从而达到以柔克刚的效果</p> \n<h2><strong>结语</strong></h2> \n<p>在面临黑客DDoS攻击和恶意勒索时，相信没有一个公司愿意屈服。事实上这是一场决心和能力的博弈，如果有坚强的决心，加上完善的技术手段、足够的资源和运营经验来应对，来自外部的攻击是可以化解的。UCloud作为业界领先的云服务商，也一直在完善我们的能力，为客户的业务提供全方位的防护。</p>', 'https://segmentfault.com/img/remote/1460000021979751', '1894b118d35d44cb8fe8009529c4154b', '6694b0611a0d403e9bb25c543e006f8a,a4f4fd7a73b84a7298db0174165eeaac,e80d97c3472e428dabdaf417adac7a3c,40c24c15130143f6be0c452503550a5b', '0', '3', '1', '2020-04-16 16:57:48', '2020-04-16 16:57:48');
INSERT INTO `tb_recommend` VALUES ('06a12d104d9c4419a551c4b43b719075', '以图搜图系统工程实践', '以图搜图系统工程实践 之前写过一篇概述: 以图搜图系统概述 。 以图搜图系统需要解决的主要问题是： 提取图像特征向量（用特征向量去表示一幅图像） 特征向量的相似度计算（寻找内容相似的图像） 对应的工程实践...', '<h1>以图搜图系统工程实践</h1> \n<p>之前写过一篇概述: <a href=\"https://segmentfault.com/a/1190000022208225\">以图搜图系统概述</a> 。</p> \n<p>以图搜图系统需要解决的主要问题是：</p> \n<ul> \n <li>提取图像特征向量（用特征向量去表示一幅图像）</li> \n <li>特征向量的相似度计算（寻找内容相似的图像）</li> \n</ul> \n<p>对应的工程实践，具体为：</p> \n<ul> \n <li>卷积神经网络 <code>CNN</code> 提取图像特征</li> \n <li>向量搜索引擎 <code>Milvus</code> </li> \n</ul> \n<h2>CNN</h2> \n<p>使用卷积神经网路 CNN 去提取图像特征是一种主流的方案，具体的模型则可以使用 <code>VGG16</code> ，技术实现上则使用 <code>Keras</code> + <code>TensorFlow</code> ，参考 <a href=\"https://keras.io/applications/#extract-features-with-vgg16\" rel=\"nofollow noreferrer\">Keras 官方示例</a>：</p> \n<pre><code>from keras.applications.vgg16 import VGG16\nfrom keras.preprocessing import image\nfrom keras.applications.vgg16 import preprocess_input\nimport numpy as np\n\nmodel = VGG16(weights=\'imagenet\', include_top=False)\n\nimg_path = \'elephant.jpg\'\nimg = image.load_img(img_path, target_size=(224, 224))\nx = image.img_to_array(img)\nx = np.expand_dims(x, axis=0)\nx = preprocess_input(x)\n\nfeatures = model.predict(x)</code></pre> \n<p>这里提取出来的 <code>feature</code> 就是特性向量。</p> \n<h3>1、归一化</h3> \n<p>为了方便后续操作，我们常常会将 <code>feature</code> 进行归一化的处理：</p> \n<pre><code>from numpy import linalg as LA\n\nnorm_feat = feat[0]/LA.norm(feat[0])</code></pre> \n<p>后续实际使用的也是归一化后的 <code>norm_feat</code> 。</p> \n<h3>2、Image 说明</h3> \n<p>这里加载图像使用的是 <code>keras.preprocessing</code> 的 <code>image.load_img</code> 方法即：</p> \n<pre><code>from keras.preprocessing import image\n\nimg_path = \'elephant.jpg\'\nimg = image.load_img(img_path, target_size=(224, 224))</code></pre> \n<p>实际上是 <code>Keras</code> 调用的 <code>TensorFlow</code> 的方法，详情见 <a href=\"https://www.tensorflow.org/api_docs/python/tf/keras/preprocessing/image/load_img\" rel=\"nofollow noreferrer\"> TensorFlow 官方文档</a> ，而最后得到的 <code>image</code> 对象其实是一个 <a href=\"https://pillow.readthedocs.io/en/stable/reference/Image.html\" rel=\"nofollow noreferrer\">PIL Image</a> 实例（ <code>TensorFlow</code> 使用的 <code>PIL</code> ）。</p> \n<h3>3、Bytes 转换</h3> \n<p>实际工程中图像内容常常是通过网络进行传输的，因此相比于从 path 路径加载图片，我们更希望直接将 bytes 数据转换为 image 对象即 <a href=\"https://pillow.readthedocs.io/en/stable/reference/Image.html\" rel=\"nofollow noreferrer\">PIL Image</a> ：</p> \n<pre><code>import io\nfrom PIL import Image\n\n# img_bytes: 图片内容 bytes\nimg = Image.open(io.BytesIO(img_bytes))\nimg = img.convert(\'RGB\')\n\nimg = img.resize((224, 224), Image.NEAREST)</code></pre> \n<p>以上 <code>img</code> 与前文中的 <code>image.load_img</code> 得到的结果相同，这里需要注意的是：</p> \n<ul> \n <li>必须进行 <code>RGB</code> 转换</li> \n <li>必须进行 <code>resize</code> （ <code>load_img</code> 方法的第二个参数也就是 resize ）</li> \n</ul> \n<h3>4、黑边处理</h3> \n<p>有时候图像会有比较多的黑边部分（例如截屏），而这些黑边的部分即没有实际价值，又会产生比较大的干扰，因此去除黑边也是一项常见的操作。</p> \n<p>所谓黑边，本质上就是一行或一列的像素点全部都是 <code>(0, 0, 0)</code> ( RGB 图像)，去除黑边就是找到这些行或列，然后删除，实际是一个 numpy 的 3-D Matrix 操作。</p> \n<p>移除横向黑边示例：</p> \n<pre><code># -*- coding: utf-8 -*-\n\nimport numpy as np\nfrom keras.preprocessing import image\n\n\ndef RemoveBlackEdge(img):\n    \"\"\"移除图片横向黑边\n\n    Args:\n        img: PIL image 实例\n\n    Returns:\n        PIL image 实例\n    \"\"\"\n    width = img.width\n    img = image.img_to_array(img)\n    img_without_black = img[~np.all(img == np.zeros((1, width, 3), np.uint8), axis=(1, 2))]\n    img = image.array_to_img(img_without_black)\n    return img\n</code></pre> \n<p>CNN 提取图像特征以及图像的其它相关处理先写这么多，我们再看向量搜索引擎。</p> \n<hr> \n<h2>向量搜索引擎 Milvus</h2> \n<p>只有图像的特征向量是远远不够的，我们还需要对这些特征向量进行动态的管理（增删改），以及计算向量的相似度并返回最邻近范围内的向量数据，而开源的向量搜索引擎 <a href=\"https://milvus.io/cn/\" rel=\"nofollow noreferrer\">Milvus</a> 则很好的完成这些工作。</p> \n<p>下文将会讲述具体的实践，以及要注意的地方。</p> \n<h3>1、对 CPU 有要求</h3> \n<p>想要使用 <code>Milvus</code> ，首先必须要求你的 CPU 支持 <code>avx2</code> 指令集，如何查看你的 CPU 支持哪些指令集呢？对于 Linux 系统，输入指令</p> \n<pre><code>cat /proc/cpuinfo | grep flags</code></pre> \n<p>你将会看到形如以下的内容：</p> \n<pre><code>flags           : fpu vme de pse tsc msr pae mce cx8 apic sep mtrr pge mca cmov pat pse36 clflush dts acpi mmx fxsr sse sse2 ss ht tm pbe syscall nx pdpe1gb rdtscp lm constant_tsc arch_perfmon pebs bts rep_good nopl xtopology nonstop_tsc cpuid aperfmperf pni pclmulqdq dtes64 monitor ds_cpl vmx smx est tm2 ssse3 sdbg fma cx16 xtpr pdcm pcid dca sse4_1 sse4_2 x2apic movbe popcnt aes xsave avx f16c rdrand lahf_lm abm cpuid_fault epb invpcid_single pti intel_ppin tpr_shadow vnmi flexpriority ept vpid ept_ad fsgsbase tsc_adjust bmi1 avx2 smep bmi2 erms invpcid cqm xsaveopt cqm_llc cqm_occup_llc dtherm ida arat pln pts</code></pre> \n<p><code>flags</code> 后面的这一大堆就是你的 CPU 支持的全部指令集，当然内容太多了，我只想看是否支持具体的某个指令集，比如 <code>avx2</code> ， 再加一个 grep 过滤一下即可：</p> \n<pre><code>cat /proc/cpuinfo | grep flags | grep avx2</code></pre> \n<p>如果执行结果没有内容输出，就是不支持这个指令集，你只能换一台满足要求的机器。</p> \n<h3>2、容量规划</h3> \n<p>系统设计时，容量规划是需要首先考虑的地方，我们需要存储多少数据，这些数据需要多少内存以及多大的磁盘空间？</p> \n<p>速算，上文中特征向量的每一个维度都是 <code>float32</code> 的数据类型，一个 <code>float32</code> 需要占用 <code>4 byte</code>，那么一个 512 维的向量就需要 <code>2 KB</code> ，依次类推：</p> \n<ul> \n <li>一千个 512 维向量需要 2 MB</li> \n <li>一百万 512 维向量需要 2 GB</li> \n <li>一千万 512 维向量需要 20 GB</li> \n <li>一个亿 512 维向量需要 200 GB</li> \n <li>十个亿 512 维向量需要 2 TB</li> \n</ul> \n<p>如果我们希望能将数据全部存在内存中，那么系统就至少需要对应大小的内存容量。</p> \n<p>这里推荐你使用官方的大小计算工具: <a href=\"https://milvus.io/tools/sizing\" rel=\"nofollow noreferrer\">milvus tools</a></p> \n<p>实际上我们的内存可能并没有那么大（内存不够没关系，milvus 会将数据自动刷写到磁盘上），另外除了这些原始的向量数据之外，还会有一些其他的数据例如日志等的存储也是我们需要考虑的地方。</p> \n<h3>3、系统配置</h3> \n<p>关于系统配置，官方文档有比较详细的说明：</p> \n<ul> \n <li><a href=\"https://www.milvus.io/cn/docs/v0.7.1/reference/milvus_config.md\" rel=\"nofollow noreferrer\">Milvus 服务端配置</a></li> \n <li><a href=\"https://www.milvus.io/cn/blogs/2020-2-19-milvus-config.md\" rel=\"nofollow noreferrer\">如何设置系统配置项</a></li> \n <li><a href=\"https://www.milvus.io/cn/docs/v0.7.1/reference/performance_tuning.md\" rel=\"nofollow noreferrer\">配置 Milvus 用于生产环境</a></li> \n</ul> \n<h3>4、数据库设计</h3> \n<h4>collection &amp; partition</h4> \n<p>在 Milvus 中，数据会按照 <code>collection</code> 和 <code>partition</code> 进行划分：</p> \n<ul> \n <li> <code>collection</code> 就是我们理解的表。</li> \n <li> <code>partition</code> 则是 <code>collection</code> 的分区，也就是某个表内部的分区。</li> \n</ul> \n<p><code>partition</code> 分区在底层实现上其实与 <code>collection</code> 集合是一致的，只是前者从属于后者，但是有了分区之后，数据的组织方式变得更加灵活，我们也可以指定集合中某个特定分区进行查询，从而达到一个更高的查询性能，更多内容参考 <a href=\"https://www.milvus.io/cn/blogs/2019-12-16-table-partition.md\" rel=\"nofollow noreferrer\">分区表详细说明</a> 。</p> \n<p>我们可以使用多少个 <code>collection</code> 和 <code>partition</code> ？<br>由于 <code>collection</code> 和 <code>partition</code> 的基本信息都属于元数据，而 milvus 内部进行元数据管理需要使用 <code>SQLite</code>（ milvus 内部集成）或者 <code>MySQL</code> (需要外部连接) 其中之一，如果你使用默认的 <code>SQLite</code> 去管理元数据的话，当集合和分区的数量过多时，性能损耗会很严重，因此集合和分区总数不要超过 <code>50000</code> ( 0.8.0 及以后版本将会限制为 <code>4096</code> ) ，需要设置更多的数量则建议使用外接 <code>MySQL</code> 的方式。</p> \n<p>Milvus 的 <code>collection</code> 和 <code>partition</code> 内部支持的数据结构非常简单，只支持 <code>ID + vector</code> ，换句话说，表只有两列，一列是 ID ，一列是向量数据。</p> \n<p>注意：</p> \n<ul> \n <li>ID 目前只支持整数类型</li> \n <li>我们需要保证 ID 在 <code>collection</code> 的层面是唯一的，而不是 <code>partition</code> 。</li> \n</ul> \n<h4>条件过滤</h4> \n<p>我们使用一些传统的数据库时，往往可以指定字段进行条件过滤，但是 Milvus 并不能直接支持这项功能，然而我们是可以通过集合和分区的设计去实现简单的条件过滤，例如，我们有很多图片数据，但是这些图片数据都明确的属于具体的用户，那么我们就可以按照用户去划分 <code>partition</code> ，这样查询的时候以用户作为过滤条件其实就是指定 <code>partition</code> 即可。</p> \n<h4>结构化数据与向量的映射</h4> \n<p>由于 milvus 只支持 <code>ID + vector</code> 的数据结构，而实际业务上我们最终需要的往往是具有业务意义的结构化数据，也就是说，我们需要通过 <code>vector</code> 向量最终找到结构化数据，因此我们需要通过 <code>ID</code> 去维护结构化数据与向量之间的映射关系:</p> \n<pre><code>结构化数据 ID  &lt;--&gt;  映射表  &lt;--&gt;  Milvus ID</code></pre> \n<h4>索引类型选择</h4> \n<p>请参考以下文档:</p> \n<ul> \n <li><a href=\"https://www.milvus.io/cn/docs/v0.7.1/guides/index.md\" rel=\"nofollow noreferrer\">索引类型</a></li> \n <li><a href=\"https://www.milvus.io/cn/blogs/2019-12-03-select-index.md\" rel=\"nofollow noreferrer\">如何选择索引类型</a></li> \n</ul> \n<h3>5、搜索结果处理</h3> \n<p>Milvus 的搜索结果是 <code>ID + distance</code> 的集合:</p> \n<ul> \n <li> <code>ID</code> : <code>collection</code> 中的 <code>ID</code> 。</li> \n <li> <code>distance</code> : 0 ~ 1 的距离值，表示相似性程度，越小越相似。</li> \n</ul> \n<h4>过滤 ID 为 -1 的数据</h4> \n<p>当数据集过少的时候，搜索结果可能会包含 ID 为 -1 的数据，我们需要自己去过滤掉。</p> \n<h4>翻页</h4> \n<p>向量的搜索比较特别，查询的结果是按照相似性顺序，从最相似开始往后选取 <code>topK</code> 个数据（ <code>topK</code> 需要搜索时由用户指定）。</p> \n<p>Milvus 的搜索不支持翻页，如果我们希望在业务上实现这个功能，那么只能由我们自己去处理，比如，我想要每页 10 条数据，只显示第 3 页的数据，那么我们需要去取 <code>topK = 30</code> 的数据，然后只返回最后 10 条。</p> \n<h4>业务上的相似性阈值</h4> \n<p>两张图片的特征向量的距离 <code>distance</code> 范围是 0 ~ 1 ，有些时候我们需要在业务上去判定两张图片是否相似，这时就需要我们自己去设置一个距离的阈值，当 <code>distance</code> 小于阈值时就可以判定为相似，大于阈值时判定为不相似，这个也是需要根据具体的业务自己去处理。</p> \n<h2>结语</h2> \n<p>本文讲述了以图搜图系统进行工程实践时比较常见的内容，最后强烈推荐一下 <a href=\"https://milvus.io/cn/\" rel=\"nofollow noreferrer\">Milvus</a> 。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzBfa\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"qrcode_for_gh_9ccbe5e0dfb3_258.jpg\" title=\"qrcode_for_gh_9ccbe5e0dfb3_258.jpg\"></span></p>', 'https://segmentfault.com/img/bVbzBfa', 'c56940aa8b004dab84568e86900b2ee6', '55723db96b9f4593bae02bc1e49f1e87,43145b2d806a4c3e8bb30d20ef04d61b,d16a93d83052441a90afaa57d69fdc3c,50952da4831a49c98a02a58ccc545509,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-16 16:55:40', '2020-04-16 16:55:40');
INSERT INTO `tb_recommend` VALUES ('07b43bb6d69e42e5a5a6ae8070684c47', '【Flutter工具】可能是Flutter上最简单的本地数据保存方案', 'local_cache_sync是一个非常简单易用的Flutter本地储存库，适用于在本地储存一列轻量数据（例如用户保存在本地的一系列蓝牙设备的配置，或者缓存一系列用户信息）', '<h1>简介</h1> \n<p><code>local_cache_sync</code>是一个非常简单易用的<code>Flutter</code>本地储存库，适用于在本地储存一列轻量数据（例如用户保存在本地的一系列蓝牙设备的配置，或者缓存一系列用户信息）</p> \n<p><code>local_cache_sync</code>的所有方法，包括保存与读取，都是<strong>同步</strong>的，而不是<strong>异步</strong>的。</p> \n<p><strong>同步存取</strong>意味着你不需要使用<code>await</code>就可以获取和保存数据。在<code>flutter</code>中，这可以显著减少<code>StatefulWidget</code>的数量，大量减少代码的复杂度。</p> \n<h1>例子</h1> \n<p>使用<code>local_cache_sync</code>保存与读取参数都是同步的，这意味着赋值即是保存，而且在<code>StatelessWidget</code>中，可以<strong>立即使用数据</strong>，而不是异步请求数据再刷新。</p> \n<p>下面这个<code>Switch</code>组件的值会被缓存到本地，即使重新启动App也会保留：</p> \n<pre><code class=\"dart\">Switch(\n  value: LocalCacheSync.userDefault.getWithKey&lt;bool&gt;(\'switch-A\'),\n  onChanged: (v) {\n    setState(() {\n      LocalCacheSync.userDefault.setWithKey&lt;bool&gt;(\'switch-A\', v);\n    });\n  },\n),</code></pre> \n<h2>安装</h2> \n<p>添加你的pubspec.yaml</p> \n<pre><code class=\"yaml\">  path_provider: ^1.4.5\n  local_cache_sync: ^1.1.0</code></pre> \n<p>初始化设置路径</p> \n<pre><code class=\"dart\">getTemporaryDirectory().then((uri) {\n      LocalCacheSync.instance.setCachePath(uri.path);\n});</code></pre> \n<h1>用户偏好设置缓存</h1> \n<p>使用<code>local_cache_sync</code>实现保存用户自定义设置非常简单，<strong>只需要赋值与取值，无需异步等待</strong>，即可保存参数到本地。 <br>读取参数也是同步的，这意味着你可以在<code>StatelessWidget</code>中立即使用数据。</p> \n<h2>使用函数调用：</h2> \n<p>保存数据</p> \n<pre><code class=\"dart\">LocalCacheSync.userDefault.setWithKey&lt;bool&gt;(\'isDarkMode\',true);\nLocalCacheSync.userDefault.setWithKey&lt;String&gt;(\'token\',\'aabbccdd\');\nLocalCacheSync.userDefault.setWithKey&lt;Map&gt;(\'x-config\',{\'id\':1243});</code></pre> \n<p>读取数据</p> \n<pre><code class=\"dart\">var res = LocalCacheSync.userDefault.getWithKey&lt;bool&gt;(\'isDarkMode\');\nvar res = LocalCacheSync.userDefault.getWithKey&lt;String&gt;(\'token\');\nvar res = LocalCacheSync.userDefault.getWithKey&lt;Map&gt;(\'x-config\');</code></pre> \n<h2>使用操作符:</h2> \n<p>保存数据</p> \n<pre><code class=\"dart\">LocalCacheSync.userDefault[\'isDarkMode\'] = true;\nLocalCacheSync.userDefault[\'token\'] = \'aabbccdd\';\nLocalCacheSync.userDefault[\'x-config\'] = {\'id\':1243};</code></pre> \n<p>读取数据</p> \n<pre><code class=\"dart\">bool res = LocalCacheSync.userDefault[\'isDarkMode\'];\nString res = LocalCacheSync.userDefault[\'token\'];\nMap res = LocalCacheSync.userDefault[\'x-config\'];</code></pre> \n<h1>管理一组数据缓存</h1> \n<p>如果你需要管理一系列值，请使用<code>LocalCacheLoader</code>，只需要一个<code>channel</code>标志，你就可以管理一系列值。</p> \n<h2>懒加载</h2> \n<p><code>LocalCacheLoader</code>在内部实现了懒加载的效果：只有取<code>value</code>属性时数据才真正被加载。 </p> \n<p>在应用中，加入你有1-100号设备显示在Listview.builder中，只有100号设备即将进入屏幕中时，100号设备的缓存参数才会被真正加载。也就是说LocalCacheLoader不会导致长列表卡顿。</p> \n<h2>Model例子</h2> \n<p>我推荐你这样创建你的model:</p> \n<pre><code class=\"dart\">\nclass Device {\n  final String uuid;\n  final String name;\n  final int type;\n\n  Device({\n    this.uuid,\n    this.name,\n    this.type,\n  });\n\n  Device.formJson(Map&lt;String, dynamic&gt; map)\n      : this(\n          uuid: map[\'uuid\'],\n          name: map[\'name\'],\n          type: map[\'type\'],\n        );\n\n  static LocalCacheLoader get _loader =&gt; LocalCacheLoader(\'device\');\n\n  static List&lt;Device&gt; all() {\n    return _loader.all\n        .map&lt;Device&gt;(\n          (cache) =&gt; Device.fromJson(cache),\n        )\n        .toList();\n  }\n\n  LocalCacheObject save() {\n    return Device._loader.saveById(uuid, jsonMap);\n  }\n\n  Map&lt;String, dynamic&gt; get jsonMap =&gt; {\n        \'uuid\': uuid,\n        \'name\': name,\n        \'type\': type,\n      };\n}</code></pre> \n<p>你也可以另外封装loader来读写其他信息，对于轻量级的储存，以上是非常简单易用的。</p> \n<h2>警告</h2> \n<p>不要在io密集型场景使用local_cache_sync，例如即时储存每秒10次的扫描结果。 <br>虽然flutter中阻塞主线程不会导致UI卡顿，但是你仍不应当在io密集型场景使用，这超出了local_cache_sync设计的工作范围。</p> \n<h1>仓库与Pub地址</h1> \n<p>如果有问题，可以在github上issue或者pr。</p> \n<p><a href=\"https://pub.dev/packages/local_cache_sync#-changelog-tab-\" rel=\"nofollow noreferrer\">PUB地址（可以赞一下）</a><br><a href=\"https://github.com/mjl0602/local_cache_sync\" rel=\"nofollow noreferrer\">Github仓库</a></p>', null, '3f69fcc9b13843d1910b3dac597f5215', '14ab12176ade47da95ba97d7151eb1f9,63c4e1e7ec204b43a62065a3ced4c2ce,d79254c4ca5e45dca9d484307c935281,85ee959b27f74072b13cc763b9bbf77e,8dfc62f227ae4076888ea4872e03cddd', '0', '3', '1', '2020-04-16 16:50:19', '2020-04-16 16:50:19');
INSERT INTO `tb_recommend` VALUES ('092a55ad55764e91a3ca1976c3fc011a', 'iOS 14 或将推出新的 App 体验方式：无需下载即可使用', '通过分析 iOS 14 早期版本代码发现，苹果正在开发一种名为「Clips」的新 API。该 API 可以实现在用户扫描到某个 App 的二维码或打开链接时，不再跳转到 AppStore 的下载页面，而是直接在屏幕上显示一个浮窗卡片，...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQL9\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>据 9to5mac 报道，苹果正在研究一种新的 App 体验方式，让用户无需下载 App 即可体验某款应用程序的部分功能。</p> \n<p>通过分析 iOS 14 早期版本代码发现，苹果正在开发一种名为「Clips」的新 API。该 API 可以实现在用户扫描到某个 App 的二维码或打开链接时，不再跳转到 AppStore 的下载页面，而是直接在屏幕上显示一个浮窗卡片，展示 App 本身的内容。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQML\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>根据透露的消息显示，「Clips」API 与开发者可以访问的内部版本中的 QR Code 阅读器直接相关，因此用户可以扫描链接到应用程序的代码，然后直接从显示在屏幕上的卡上与其进行交互。也就是说，它允许开发人员为他们的应用程序提供交互式和动态内容，即使用户尚未安装它们。</p> \n<p>不过开发人员将需要指定应用程序的哪一部分可供下载并读取，同时跳出的浮动卡片会显示“从App Store下载完整版本的应用程序”的选项或“在已安装的应用程序中打开该内容”的选项。</p> \n<hr> \n<p>Android有一个类似的功能，叫做「Slices」，可以在谷歌搜索结果和谷歌助手等地方显示应用的交互部分。</p> \n<p>代码还显示，苹果公司正在测试 OpenTable、Yelp、DoorDash 和索尼 PS4 Second Screen、YouTube 以进一步优化新的 API。</p> \n<p>资料来源：<a href=\"https://9to5mac.com/2020/04/09/ios-14-apple-developing-clips-feature-for-using-apps-without-requiring-full-downloads/\" rel=\"nofollow noreferrer\">9to5mac</a></p>', 'https://segmentfault.com/img/bVbFQL9', 'f53014d680884163a5bd5ce762e90cdf', '85ee959b27f74072b13cc763b9bbf77e,b7460efd3f3b4d6ea78254959a2aebff', '0', '3', '1', '2020-04-16 16:50:14', '2020-04-16 16:50:14');
INSERT INTO `tb_recommend` VALUES ('0bee7d1865b943f5a5d902736b353504', 'Flutter 学习笔记《插件篇》：路由插件 fluro', 'Flutter 自身是提供了 Navigator widget 来实现应用的路由功能。但使用一些路由插件，可以帮助我们更方便快捷的实现 Flutter 应用页面间的跳转和传值等功能。', '<p>Flutter 自身是提供了 <code>Navigator</code> widget 来实现应用的路由功能。但使用一些路由插件，可以帮助我们更方便快捷的实现 Flutter 应用页面间的跳转和传值等功能。</p> \n<p>这篇笔记我们主要来学习一下 fluro 这个插件。</p> \n<h1>1. 项目引入 fluro</h1> \n<p>Flutter 应用中要使用任何第三方插件，都需要先在项目中进行引入。</p> \n<p>打开项目根目录中的 <code>pubspec.yaml</code> 文件，在 <code>dependencies</code> 属性下面添加 fluro 的配置代码：</p> \n<pre><code class=\"yaml\">dependencies:\n  fluro: ^1.6.3</code></pre> \n<p>参考代码截图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFMXv\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<blockquote>\n 说明：1.6.3 是当前（2020.04.13）fluro 的最新版本号，大家以后在使用时，建议先去\n <a href=\"https://github.com/theyakka/fluro\" rel=\"nofollow noreferrer\">官网</a>看看最新的版本号是多少，配置的时候就改成最新版本号即可。\n</blockquote> \n<h1>2. fluro 的基本使用</h1> \n<p>fluro 最基本的功能就是“跳转页面”，其他的“传值”、“返回”等功能对于我们菜鸡来说都是高级操作了，所以先不谈。我们先来学基操！</p> \n<h2>2.1 建立路由文件</h2> \n<p>一般情况下，我们都会在项目的 lib 目录中创建一个的新的文件夹（例如：<code>lib/routers</code>），专门用来存放与路由相关的配置代码。</p> \n<h2>2.2 路由配置</h2> \n<p>创建一个 <code>lib/routers/routes.dart</code> 文件用来进行路由的相关配置：</p> \n<pre><code class=\"dart\">import \'package:flutter/material.dart\';\n// 引入 fluro\nimport \'package:fluro/fluro.dart\';\n// 引入路由要跳转的页面文件\nimport \'package:flutter_fluro_demo/home_page.dart\';\nimport \'package:flutter_fluro_demo/login_page.dart\';\n\nclass Routes {\n  // 各个页面的路径字符串\n  static String home = \'/home\';\n  static String login = \'/login\';\n  // 创建一个 configureRoutes 方法，用于路由配置\n  static void configureRoutes(Router router) {\n    // 配置 home 首页路由\n    router.define(home, handler: Handler(\n        handlerFunc: (BuildContext context, Map&lt;String, List&lt;String&gt;&gt; params) {\n          return HomePage();\n        },\n      ),\n    );\n    // 配置 login 登录页路由\n    router.define(login, handler: Handler(\n        handlerFunc: (BuildContext context, Map&lt;String, List&lt;String&gt;&gt; params) {\n          return LoginPage();\n        }\n      ),\n    );\n  }\n}</code></pre> \n<p>在这个配置文件里，我们以“首页”和“登录页”为例，做了一个最基础的路由配置。</p> \n<h2>2.3 路由静态化处理</h2> \n<p>为了方便我们后面在各个页面中使用路由，我建议（官方也建议）先对路由做一个静态化处理。</p> \n<p>在 <code>lib/routers</code> 中再创建一个 <code>application.dart</code> 文件，添加以下代码：</p> \n<pre><code class=\"dart\">import \'package:fluro/fluro.dart\';\n\nclass Application {\n  static Router router;\n}</code></pre> \n<p>在这段代码中，我们创建了一个 Application 对象，并设置了一个静态属性 router。</p> \n<p>在下一步全局注入路由的时候，我们会把调用 <code>Router()</code> 方法得到的路由对象保存在 <code>Application.router</code> 属性中。这样，在后续各个页面中使用路由时，就可以直接通过 <code>Application.router</code> 来拿到路由对象，而不需要反复调用 <code>Router()</code> 方法了。</p> \n<h2>2.4 全局注入路由</h2> \n<p>各项配置完成之后，接下来就需要在项目入口文件 <code>main.dart</code> 中注入路由来使我们的路由生效。</p> \n<pre><code class=\"dart\">import \'package:flutter/material.dart\';\nimport \'package:fluro/fluro.dart\';\nimport \'package:flutter_fluro_demo/routers/routes.dart\'; // 路由配置文件\nimport \'package:flutter_fluro_demo/routers/application.dart\';  // 路由静态化文件\n\nvoid main() {\n  final router = Router();  // 获取路由对象\n  Routes.configureRoutes(router);  // 调用路由配置方法\n  Application.router = router;  // 将路由对象静态化\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      onGenerateRoute: Application.router.generator,  // 将路由配置到 MaterialApp 中\n      // ...\n    );\n  }\n}</code></pre> \n<h2>2.5 路由跳转</h2> \n<p>fluro 中最简单的跳转方式就是通过 <code>navigateTo()</code> 方法来实现：</p> \n<pre><code class=\"dart\">import \'package:flutter_fluro_demo/routers/application.dart\';\n// ...\nApplication.router.navigateTo(context, \'/home\');</code></pre> \n<p>参考代码截图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFNGP\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span><br>到这一步，我们一个最简单的路由跳转就实现啦。</p> \n<h1>3. fluro 的进阶使用</h1> \n<p>路由的基本使用学会了之后，接下来我们就需要增加一丢丢的难度了。</p> \n<h2>3.1 拆分路由配置文件</h2> \n<p>在前面的路由基础用法里，我们将所有关于路由的配置都放在了 <code>routes.dart</code> 文件中，当我们项目的页面逐渐增多时，就会导致这个文件变得越来越大，代码越来越多，后期维护起来也会越来越不方便。</p> \n<p>所以，我们要对 <code>routes.dart</code> 文件中的代码进行拆分。</p> \n<p><code>routes.dart</code> 原本的代码如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF2EA\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>从图中代码可以看到，路由操作的大部分代码都集中在了 <code>handler</code> 属性中，因此，我们就把每一个 <code>handler</code> 属性的属性值都提取出去。</p> \n<p>在 <code>lib/routers</code> 中再创建一个文件：<code>route_handlers.dart</code>，将拆分出来的代码放进去：</p> \n<pre><code class=\"dart\">import \'package:flutter/material.dart\';\nimport \'package:fluro/fluro.dart\';\n\nimport \'package:flutter_fluro_demo/home_page.dart\';\nimport \'package:flutter_fluro_demo/login_page.dart\';\n\nHandler homeHandler = Handler(\n  handlerFunc: (BuildContext context, Map&lt;String, List&lt;String&gt;&gt; params) {\n    return HomePage();\n  },\n);\n\nHandler loginHandler = Handler(\n  handlerFunc: (BuildContext context, Map&lt;String, List&lt;String&gt;&gt; params) {\n    return LoginPage();\n  },\n);</code></pre> \n<p>这样拆分后，我们原本的 <code>routes.dart</code> 文件就变得很干净了。</p> \n<pre><code class=\"dart\">import \'package:fluro/fluro.dart\';\nimport \'./route_handlers.dart\';\n\nclass Routes {\n  static String home = \'/home\';\n  static String login = \'/login\';\n\n  static void configureRoutes(Router router) {\n    router.define(home, handler: homeHandler);\n    router.define(login, handler: loginHandler);\n  }\n}</code></pre> \n<h2>3.2 路由传参</h2> \n<p>虽然我们把路由传参划分到了进阶用法里，但是实际上我们应该都清楚，任何一个 App 里，路由传参功能都是必不可少的。更何况，fluro 的路由传参其实 so easy～</p> \n<blockquote>\n 路由传参其实简单理解为一个点外卖的过程。例如我们要将 home 页面的数据传递 detail 页面，那么 home 页面就是商家，detial 页面就是整天宅在家里扣 jio 的你，而 fluro，就是我们的外卖骑手。\n</blockquote> \n<p>理解了传参的流程之后，接下来我们就可以开始搬砖了。</p> \n<p><strong>第一步：在 detial 页面配置要接收的参数</strong></p> \n<p>detail 页面中的代码如下：</p> \n<pre><code class=\"dart\">import \'package:flutter/material.dart\';\n\nclass DetailPage extends StatelessWidget {\n  DetailPage({this.detailId});\n  final String detailId;\n\n  //...\n}</code></pre> \n<p>这里我们定义了一个 <code>detailId</code>，用来接收后面 home 传递过来的参数。</p> \n<p>我的案例代码截图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFWpy\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p><strong>第二步：在 home 页面设置要传递的参数</strong></p> \n<p>home 页面的路由跳转和传参代码如下：</p> \n<pre><code class=\"dart\">RaisedButton(\n  child: Text(\'去详情页\'),\n  onPressed: () {\n    Application.router.navigateTo(context, \'/detail/001\');\n  },\n),</code></pre> \n<p><code>/detail/001</code> 中的 <code>/detail</code> 就是我们要去到的 detail 页面的路径，<code>001</code> 就是我们要传递给 detail 页面的参数。</p> \n<p><strong>第三步：在路由配置文件中对 detail 路由进行配置</strong></p> \n<p>打开 <code>lib/routers/routes.dart</code> 文件，对 detail 的路由进行如下配置：</p> \n<pre><code class=\"dart\">class Routes {\n  // ...\n  static String detail = \'/detail/:id\';\n\n  static void configureRoutes(Router router) {\n    // ...\n    router.define(detail, handler: detailHandler);\n  }\n}</code></pre> \n<p>参考代码截图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF2EH\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>（<code>detailHandler</code> 报错是因为我们还没创建这个变量，下一步创建好就不会报错了。）</p> \n<p><code>/detail/:id</code> 中的 <code>id</code> 是我们自己定义的一个参数名，是对 home 页面传递的参数进行命名。 </p> \n<p>接下来，再打开 <code>lib/routers/routes_handlers.dart</code> 文件，配置 detail 的 handler 方法。</p> \n<pre><code class=\"dart\">import \'package:flutter_fluro_demo/detail_page.dart\';\n// ...\nHandler detailHandler = Handler(\n  handlerFunc: (BuildContext context, Map&lt;String, List&lt;String&gt;&gt; params) {\n    String id = params[\'id\'].first; // 通过 params 获取到路由中传递的参数\n    return DetailPage(detailId: id);\n  },\n);</code></pre> \n<p>到此，我们 home 页面，通过路由往 detail 页面的传参就已经完成了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFWpC\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<h2>3.3 返回页面</h2> \n<p>在 Flutter 中，跳转后的页面左上角会自带一个返回箭头，但是有的时候，我们也需要点击界面其他地方来实现页面的返回，又或者，我们想返回到一个指定的界面。</p> \n<h3>3.3.1 返回到上一页面</h3> \n<p>页面返回的代码很简单：</p> \n<pre><code class=\"dart\">RaisedButton(\n  child: Text(\'返回上一页\'),\n  onPressed: () {\n    // flutter \n    Navigator.pop(context);\n    // fluro\n    // Application.router.pop(context);\n  },\n)</code></pre> \n<p>从上面代码可以看出，实现“返回上一页面”功能的方式两种：一种是 flutter 自带的 <code>Navigator</code> widget 提供的 pop 方法；另一种是 fluro 中提供的 pop 方法。</p> \n<p>这里我们列出 flutter 原生的返回方式，是因为 flutter 原生的方式更简洁一些，所以路由的返回功能我们更多会选择直接用 <code>Navigator</code> 的方法返回。</p> \n<h3>3.3.2 返回到指定页面</h3> \n<p>fluro 中并没有提供专门的“返回到指定页面”的方法（我有看 fluro 的源码，确实没有找到，如果这里说法有误请大家评论里告诉我）。所以如果我们想要实现“返回到指定页面”的效果，可以直接用 <code>navigateTo</code> 页面跳转方法实现。</p> \n<p>具体代码可以参考前面「2.5 路由跳转」的示例代码。</p> \n<h2>3.4 管理历史记录</h2> \n<p>默认情况下，每一次的路由跳转，都会有一个新的路由记录注册到路由表中。</p> \n<p>fluro 中的 <code>navigateTo()</code> 方法可以设置第三个参数来管理路由历史记录。</p> \n<h3>3.4.1 替换历史记录</h3> \n<p>替换历史记录是指用“跳转后的新页面”记录替换掉“当前页面”记录。将 <code>navigateTo()</code> 方法的第三个参数设置为 <code>replace: true</code> 即可。</p> \n<pre><code class=\"dart\">child: RaisedButton(\n  child: Text(\'去详情页\'),\n  onPressed: () {\n    Application.router.navigateTo(context, \'/detail/001\', replace: true);\n  },\n),</code></pre> \n<p>参考代码截图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF2CX\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>当我们从“登录页”跳转到“首页”，再从“首页”跳转到“详情页”，然后点击“详情页”左上角的返回按钮，可以发现，直接返回到了“登录页”。因为我们的历史记录里面已经没有保留“首页”的记录了。</p> \n<h3>3.4.2 清空历史记录</h3> \n<p>除了替换一条历史记录外，<code>navigateTo()</code> 方法还可以将第三个参数设置为 <code>clearStack: true</code> 来实现清空历史记录的效果。</p> \n<pre><code class=\"dart\">child: RaisedButton(\n  child: Text(\'去详情页\'),\n  onPressed: () {\n    Application.router.navigateTo(context, \'/detail/001\', clearStack: true);\n  },\n),</code></pre> \n<h1>4. 最后</h1> \n<p>fluro 的用法大概就是这些了，如果还有没写到的知识点，大家可以在评论里告诉我，我再补充。</p>', 'https://segmentfault.com/img/bVbFMXv', '6fbfa4aaad3a43458f21c8acf0038ac5', '14ab12176ade47da95ba97d7151eb1f9,015783aba70b4c11bc1fddcaffa72d31,32b327672bf34bb49868560bae1a0ab0', '0', '3', '1', '2020-04-16 16:59:43', '2020-04-16 16:59:43');
INSERT INTO `tb_recommend` VALUES ('0d47cc526b0949f29cc6dc8ecf40ea43', 'GitHub 的 App 会开源吗？', '早在 2019 年的 GitHub Universe 大会上，GitHub 官方就宣布，他们即将推出移动端 App。而近日，GitHub APP 终于问世了。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbE7E6\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>早在 2019 年的 GitHub Universe 大会上，GitHub 官方就宣布，他们即将推出移动端 App。而近日，GitHub APP 终于问世了。</p> \n<p>作为世界上最受欢迎的同性交友网站，在发布之后自然是喜大普奔，但在此之外，也有很多开发者提出功能不太全面，希望可以添加比如代码编辑之类的其他功能。</p> \n<p>对此，有热心的开发者留言建议，建议将 GitHub 的移动应用程序开源，大家一起来进行优化。</p> \n<p>对于此事，GitHub 的总监给出了回复。</p> \n<h2>GitHub 的移动应用程序会开源么？</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbE7Fe\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>对于这个问题，GitHub 的工程总监 Ryan Nystrom 给出了两个回复：</p> \n<p>\"It\'s not right now。\"</p> \n<p>\"Maybe.\"</p> \n<p>开源是现在的一个大趋势，虽然有很多软件确实是不需要开源的，但作为全球最大的开源软件平台，自己的产品不应该开源么？</p> \n<p>当今很多开源项目的开发都是在 GitHub 上或者通过 GitHub 进行的。对于这一开发者用来“吃饭”的工具，改善 GitHub App 的使用体验能有效的改善开发者的工作效率和方式，所以如果该项目真的开源，一定会吸引很多开发者参与其中。</p> \n<p>但 Ryan Nystrom 之所以不急于开源或者不“期待”开源的原因，是他认为要想让开源项目蓬勃发展，既要有对其感兴趣的开发者群体，也需要该群体具备足够的能力来为项目作出贡献。</p> \n<p>我们可以看一下 Linux。Linux 的开源之所以做的好，是因为每个开发者都需要这样的一个操作系统，并且有相当一部分人有能力对其作出贡献。</p> \n<p>但根据业内分析师给出的分析，假如 GitHub 推出一个收费程序，那么开发者的兴趣就会大幅降低；如果 GitHub App 的开源项目只是通过加载项/扩展的方式进行开发，那么 GitHub 项目的开源就没有太大的意义。</p> \n<p>所以 GitHub 总监说的“Maybe”，可能真的就是个“Maybe”了，毕竟没有人比他们更了解开源能带来多少价值。</p> \n<h2>开源的定义</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbE7Ff\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>开源的概念，在电脑诞生前就已经出现了。最早的开源可能是发生在「吃」的领域，为了生存下去、提升食物的品质，人类学会了分享食谱。而目前对于开源比较认可的定义，由 Debian 的创始人 Bruce Perens 提出：</p> \n<blockquote> \n <ul>\n  <li>自由再散布（Free Distribution）：</li>\n </ul> \n <p>允许获得源代码的人可自由再将此源代码散布。</p> \n <ul>\n  <li>源代码（Source Code）：</li>\n </ul> \n <p>程序的可执行档在散布时，必需以随附完整源代码或是可让人方便的事后获取源代码。</p> \n <ul>\n  <li>派生著作（Derived Works）：</li>\n </ul> \n <p>让人可依此源代码修改后，在依照同一许可协议的情形下再散布。</p> \n <ul>\n  <li>原创作者程序源代码的完整性（Integrity of The Author’s Source Code）：</li>\n </ul> \n <p>意即修改后的版本，需以不同的版本号码以与原始的代码做分别，保障原始的代码完整性。</p> \n <ul>\n  <li>不得对任何人或团体有差别待遇（No Discrimination Against Persons or Groups）：</li>\n </ul> \n <p>开放源代码软件不得因性别、团体、国家、族群等设置限制，但若是因为法律规定的情形则为例外（如：美国政府限制高加密软件的出口）。</p> \n <ul>\n  <li>对程序在任何领域内的利用不得有差别待遇（No Discrimination Against Fields of Endeavor）：</li>\n </ul> \n <p>意即不得限制商业使用。</p> \n <ul>\n  <li>散布许可协议（Distribution of License）：</li>\n </ul> \n <p>若软件再散布，必需以同一条款散布之。</p> \n <ul>\n  <li>许可协议不得专属于特定产品（License Must Not Be Specific to a Product）：</li>\n </ul> \n <p>若多个程序组合成一套软件，则当某一开放源代码的程序单独散布时，也必需要符合开放源代码的条件。</p> \n <ul>\n  <li>许可协议不得限制其他软件（License Must Not Restrict Other Software）：</li>\n </ul> \n <p>当某一开放源代码软件与其他非开放源代码软件一起散布时（例如放在同一光盘），不得限制其他软件的许可条件也要遵照开放源代码的许可。</p> \n <ul>\n  <li>许可协议必须技术中立（License Must Be Technology-Neutral）：</li>\n </ul> \n <p>意即许可协议不得限制为电子格式才有效，若是纸本的许可协议也应视为有效。</p> \n</blockquote> \n<p>在软件产业中，免费软件、开源软件与自由软件的概念常常被不同程度地混淆起来，一般人并没有理顺其中的逻辑关系，造成了一定的误解，也引发了不少的错误决策。</p> \n<p>但其实简单来说，免费软件不一定必然开源，开源软件不一定必然免费。这点大家都很好理解。</p> \n<p>严格地来说，开放源代码软件与自由软件是两个不同的概念，只要符合开源软件定义的软件就能被称为开放源代码软件（开源软件）。自由软件是一个比开源软件更严格的概念，因此所有自由软件都是开放源代码的，但不是所有的开源软件都是“自由”的。</p> \n<p>虽说自由的态度就是要激励打破牢笼穿越围墙迎接思想的开放，努力分享展示自己的技术、原理，而不为了蝇头小利而对自己所谓的“技术”沾沾自喜而固步自封，但自由软件是否一定免费呢？</p> \n<p>也不能一概而论。</p> \n<p>每一位自由软件的贡献者当然是此软件的开发者和免费使用者，但对于普通用户而言，就不那么确定了。普通用户一般需要的不是软件而是服务，软件也许是免费，但是服务就从来都不是免费的了。</p> \n<h2>开源的价值</h2> \n<p>对于很多人来说，提到开源想到的就是「免费」和「非专业软件」。但实际上，随着开源的发展，现在的「开源」已经成为技术发展最好的生长模式之一。</p> \n<p>可以这么说，如果没有开源，很多的科技企业都不能达到今天的行业高度，比如谷歌、Facebook 和我们前面提到的 Linux。</p> \n<p>为了让更多人能够使用优秀的产品、让技术或者项目能够群策群力、快速的发展升级，都离不开开源带来的价值。</p> \n<p>美国的科技企业之所以热衷于开源，和文化有很大的关系。如果一家企业没有开源项目，会被质疑这家公司只会一味的索取，而不为行业和生态做出应有的贡献。</p> \n<p>所以从企业层面来说，开源一方面可以树立品牌形象，另外还可以通过开源项目吸引人才，招揽员工。往大了说开源对于企业甚至具有一定的战略意义。</p> \n<p>比如 Android，最初就是通过开源和病毒式的传播一下就赶上了 iOS。</p> \n<p>从个人层面来说，尝试开源也有着两个比较突出的意义。</p> \n<p>第一是有助于提升自己的代码水平。既然是开源项目，那么在写代码的时候一定会尽量的展现自身最好的水平，这会逼着自己让代码更简洁、易懂。其次，你的代码开源后，别人也能针对性的给你提出一些建议，帮助你进行代码的优化。</p> \n<p>其次可以通过开源项目展示个人的能力。虽然现在 GitHub 已经快被「别有用心的人」给玩坏了，但对于企业招聘来说仍然具有一定的参考价值。如果个人有个不错的开源项目，那么在面试的时候一定是个不错的加分项。</p> \n<p>对于开源，你怎么看？</p> \n<p>如果你有自己开源项目，可以和我私信进行交流，我们会定期对社区用户的优质开源项目进行推荐。</p> \n<blockquote>\n 参考资料：\n <p>《GitHub\'s mobile app to go open source? Definitely \"maybe\"》：<br><a href=\"https://www.techrepublic.com/article/githubs-mobile-app-to-go-open-source-definitely-maybe/\" rel=\"nofollow noreferrer\">https://www.techrepublic.com/...</a><br>《免费、开源与自由》：<br><a href=\"https://www.jianshu.com/p/eab781d2f8b9\" rel=\"nofollow noreferrer\">https://www.jianshu.com/p/eab...</a></p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCJ1M\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbE7E6', '1894b118d35d44cb8fe8009529c4154b', '634b81d655c74cb0adc4d0aa362b8819,f3eb17e6e5664a97af3e9b1fca12b286', '0', '3', '1', '2020-04-16 16:59:33', '2020-04-16 16:59:33');
INSERT INTO `tb_recommend` VALUES ('0eb8688cf48a49d597316baa1758286d', 'DeepL：一家在翻译领域超越谷歌和微软的德国公司', '科技巨头谷歌、微软和Facebook都在将机器学习的经验教训应用到翻译领域，但一家名为DeepL的小公司却超越了他们，提高了这个领域的标准。它的翻译工具的速度不亚于那些规模庞大的竞争对手，但比我们尝试过的任何一...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道丨公众号：SegmentFault</strong></p> \n<hr> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFP66\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"AI Assistance for Language。DeepL trains artificial intelligenceto understand and translate texts.\" title=\"AI Assistance for Language。DeepL trains artificial intelligenceto understand and translate texts.\"></span></p> \n<p>科技巨头谷歌、微软和Facebook都在将机器学习的经验教训应用到翻译领域，但一家名为DeepL的小公司却超越了他们，提高了这个领域的标准。它的翻译工具的速度不亚于那些规模庞大的竞争对手，但比我们尝试过的任何一款翻译工具都要准确和细致。</p> \n<p>经过几次试验，我们都认为DeepL的翻译普遍优于Google Translate和Bing的翻译。Google Translate经常会去找一个非常直白的翻译，错过了一些细微的差别和成语（或者是把这些成语翻译成错了），而DeepL经常提供一个更自然的翻译，更接近于一个训练有素的翻译者的翻译。</p> \n<p><strong>DeepL从Linguee演化而来</strong></p> \n<p>DeepL诞生于同样优秀的Linguee，这是一款已经存在多年的翻译工具，虽然很受欢迎，但一直没有达到谷歌翻译的水平--毕竟后者在品牌和地位上有很大的优势。Linguee的联合创始人Gereon Frahling曾在Google Research工作过，但在2007年离开Google并开始了自己的新的事业Linguee。</p> \n<p>这支团队多年来一直致力于机器学习，从事与核心翻译相邻的任务，但直到去年，他们才开始认真地研究一个全新的系统和公司，而这两个系统和公司的名字都将是DeepL。</p> \n<p>Frahling提到现在时机已经成熟：\"我们已经建立了一个神经翻译网络，其中包含了大部分最新的发展，我们在其中加入了自己的想法。\"</p> \n<p>一个由超过10亿个翻译和查询组成的庞大数据库，再加上通过在网络上搜索类似的片段进行落地翻译的方法，为新模型的训练打下了坚实的基础。他们还把他们声称的世界上第23台最强大的超级计算机放在了一起，位于冰岛境内。</p> \n<p>DeepL的翻译服务使用了搭建在Linguee数据库之上的卷积神经网络及另一种并未公布的专有方法涉及注意力机制。DeepL GmbH拥有一台浮点性能为5 Petaflops的机器，用于其翻译服务的训练和生产。</p> \n<p>由大学、研究机构以及Linguee公司的竞争对手所公布的发展情况表明，卷积神经网络才是发展的方向，而不是该公司之前一直使用的递归神经网络。现在真的不是深入研究CNNs和RNNNs之间的区别的地方，所以必须要说的是，对于长的、复杂的相关词串的准确翻译，只要你能控制好它的弱点，前者是一个更好的选择。</p> \n<p>例如，CNN大致可以说是可以一次解决一个单词的句子。但当比如经常发生的情况，句尾的一个词决定了句子开头的一个词应该如何组成时，这就成了问题。通读整个句子，只是发现网络选取的第一个词是错误的，然后再根据这个知识重新开始，这是很浪费的，所以DeepL和机器学习领域的其他人应用了 \"注意力机制\"，监控这种潜在的绊脚石，并在CNN转移到下一个词或短语之前解决它们。</p> \n<p><strong>关于隐私政策</strong></p> \n<p>无论是DeepL Pro还是免费的DeepL Translator都不允许被用于翻译“包含任何种类个人资料的文本” 与免费版不同，DeepL Pro宣称并不会储存翻译文本。更多可以查看他们的<a href=\"https://www.deepl.com/privacy.html\" rel=\"nofollow noreferrer\">privacy</a>。</p> \n<p>感兴趣的同学们可以试一试，相信Deepl会成为你新的助力你翻译的生产力工具。我们也非常欢迎对Deepl背后技术的同学们分享更多他们更多技术相关的细节。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"SegmentFault思否微信公众号\" title=\"SegmentFault思否微信公众号\"></span></p>', 'https://segmentfault.com/img/bVbFP66', 'c56940aa8b004dab84568e86900b2ee6', 'efd45535a5504d5595fba4d1dbbc489c,db6b58ae709645f2b64166fd73f2f705,9223827da7dc4f1c8f6790777fb42d6e,9d5eb002705648e2bc3d345fa34a8191', '0', '3', '1', '2020-04-16 16:59:45', '2020-04-16 16:59:45');
INSERT INTO `tb_recommend` VALUES ('0fd6f75e7f92494ea11cbede18465c99', '滴滴开源企业级监控解决方案：夜莺 Nightingale', 'SegmentFault 思否消息：近日滴滴基础平台联合滴滴云开源了他们研发的企业级监控解决方案：夜莺（Nightingale），Nightingale 是旨在满足云原生时代企业级的监控需求。Nightingale 在产品完成度、系统高可用、以...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p>SegmentFault 思否消息：近日滴滴基础平台联合滴滴云开源了他们研发的企业级监控解决方案：夜莺（Nightingale），Nightingale 是旨在满足云原生时代企业级的监控需求。Nightingale 在产品完成度、系统高可用、以及用户体验方面，达到了企业级的要求，可满足不同规模用户的场景，小到几台机器，大到数十万都可以完美支撑。兼顾云原生和裸金属，支持应用监控和系统监控，插件机制灵活，插件丰富完善，具有高度的灵活性和可扩展性。</p> \n<p><a href=\"https://github.com/didi/nightingale\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022226405\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p>Nightingale 在<a href=\"https://github.com/open-falcon\" rel=\"nofollow noreferrer\">Open-Falcon</a>的基础上，结合滴滴内部的最佳实践，在性能、可维护性、易用性方面做了大量的改进，作为滴滴统一的监控解决方案，支撑了滴滴内部数十亿监控指标，覆盖了从系统、容器、到应用等各层面的监控需求。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022226404\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Nightingale 采用树状节点导航，我们称之为对象树。对象树本质上是一种对监控对象的分组管理机制，方便查找和查看监控对象，以及对监控对象设置监控策略等管理动作。一棵典型的树可从上到下描述为组织架构关系、产品服务模块关系、机房和机器挂载关系，该导航树可根据用户需求自行灵活定制。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022226406\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>监控策略应用到某个节点后，该节点下的所有子节点挂载的所有的机器都会应用这个策略，任何一台机器触发相关阈值都会产生告警。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022226407\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>监控大盘的定制做了大幅易用性改进，支持了图表阈值，支持了图表分类，新增图表和排序管理都是可见即所得的方式，巡检大盘的定制从此不再是困难。</p> \n<p>Nightingale 是在 Open-Falcon 的基础上衍化发展而来，Open-Falcon 作为国内使用最广泛的监控解决方案之一，为 Nightingale 的设计开发提供了大量的借鉴意义。</p> \n<p><strong>▍</strong><strong>与Open-Falcon的不同点</strong></p> \n<ul> \n <li> <strong>告警引擎重构</strong>：Open-Falcon 的告警策略，在监控数据推送上来的同时会触发策略判断，这种「推」的模式优势是策略的判断时效性非常高，但是不利于更高级的告警策略的支持和扩展，比如多条件的组合报警就很难支持。Nightingale 转为推拉结合模式，通过推模式保证大部分策略判断的效率，通过拉模式支持了与条件告警和nodata告警；</li> \n <li> <strong>引入了导航对象树：</strong>将 Open-Falcon 采用的扁平 HostGroup，转为 Nightingale 的导航对象树，对象树本质上是一种对监控对象的分组管理机制，方便查找和查看监控对象，以及对监控对象设置监控策略等管理动作。同时在 Nightingale 中，去除了告警模板的概念，告警策略直接与树节点绑定，简化设计，大幅提升灵活度和易用性；</li> \n <li> <strong>索引模块升级换代：</strong>Open-Falcon 使用 MySQL 存储 metrics 的索引数据，在扩展性和灵活性上存在瓶颈。Nightingale 根据监控需求，设计开发了全新的内存索引模块 index，查询方式更多样，查询效率更高，避免了原来 MySQL 索引数据达到亿级别时面临的维护优化工作；</li> \n <li> <strong>时序数据库优化：</strong>在 Open-Falcon 存储模块 Graph 的基础上，引入 Facebook 的 Gorilla 压缩方案，近期几个小时的数据采用内存存储，大幅提升数据查询效率，长期数据仍然使用 rrdtool 数据格式存储在硬盘上。同时进一步完善了时序数据库的性能和稳定性；</li> \n <li> <strong>告警引擎高可用改进：</strong>告警引擎 judge 模块通过心跳机制做到了故障自动摘除，再也不用担心单个 judge 宕机导致部分策略失效，需要人工介入的问题，index 模块也是采用类似方式保证可用性；</li> \n <li> <strong>原生内置日志监控功能：</strong>Nightingale 客户端原生内置了日志匹配和指标抽取能力，在 web 控制台页面上支持了日志匹配规则的配置，同时也支持读取目标机器特定目录下的配置文件的方式，让业务指标监控更为易用；</li> \n <li> <strong>可运维性增强：</strong>将 portal(falcon-plus中的api)、uic、dashboard、hbs、alarm 合并为一个模块：monapi，简化了系统整体部署难度，原来的部分模块间调用变成进程内方法调用，性能更高；</li> \n <li> <strong>配置文件中心化：</strong>配置文件做了易用性改造，抽取数据库通用配置到 mysql.yml，抽取端口实例地址等关联配置到 address.yml，大批配置在代码里给了默认值，使得配置文件更清晰，易于维护。</li> \n</ul> \n<p><strong>▍</strong><strong>与Open-Falcon的相同点</strong></p> \n<ul> \n <li>数据模型没有变化，仍然是 metric、endpoint、tags 的组织方式，agent 基本是可以复用的，Nightingale 中的 agent 叫 collector，融合了原来 Open-Falcon 的 agent 和 falcon-log-agent 的逻辑，各种监控插件也都是可以复用的。</li> \n <li>数据流向和整体处理逻辑是类似的，仍然使用灵活的推模型，分为数据存储和告警判断两条链路。</li> \n</ul> \n<p><strong>▍</strong><strong>Nightingale架构</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022226408\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><em>如果想了解更细节的内容，可以参看这个小视频：<a href=\"https://s3-gz01.didistatic.com/n9e-pub/video/n9e-arch-intro.mp4\" rel=\"nofollow noreferrer\">夜莺架构讲解</a></em></p> \n<ul> \n <li>collector 即 agent，可以采集机器常见指标，原生支持日志监控，支持插件机制，支持业务通过接口直接上报数据；</li> \n <li>transfe r提供 rpc 接口接收 collector 上报的数据，然后通过一致性哈希，将数据转发给多台tsdb和多台judge；</li> \n <li>tsdb 即 open-falcon 中的 graph 组件，用于存储历史数据，支持配置为双写模式提升系统容灾能力，tsdb 会把监控数据转发一份给 index 建索引；</li> \n <li>index 是内存索引模块，替换原来的 mysql 方案，在内存里构建索引，便于后续数据检索，在检索的灵活性和检索性能方面大幅提升；</li> \n <li>judge 是告警引擎，从 monapi(portal) 同步监控策略，然后对接收到的数据做告警判断，如满足阈值，则生成告警事件推送到 redis 队列；</li> \n <li>monapi(alarm) 从 redis 队列中读取 judge 生成的事件，进行二次处理，补充一些元信息，生成告警消息，重新推送回 redis 队列；</li> \n <li>各发送组件，比如 mail-sender、sms-sender 等，从 redis 读取告警消息，发送告警，抽象出各类 sender 是为了后续定制方便；</li> \n <li>monapi 集成了原来多个模块的功能，提供接口给 js 调用，api 前缀为 /api/portal，数据查询走 transfer，去除了 open-falcon 中原来的 query 组件，api 前缀为 /api/transfer，索引查询的 api 前缀 /api/index，于是，在前端统一搭建 nginx，即可通过不同 location 将请求转发到不同后端；</li> \n <li>数据库仍然使用 MySQL，主要存储的内容包括：用户信息、团队信息、树节点信息、告警策略、监控大盘、屏蔽策略、采集策略、部分组件心跳信息等。</li> \n</ul> \n<p>项目开发文档地址：<a href=\"https://n9e.didiyun.com/docs/intro/\" rel=\"nofollow noreferrer\">https://n9e.didiyun.com/docs/...</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFmMq\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p>', 'https://segmentfault.com/img/remote/1460000022226405', '61cdf41d1e5e4f229b76f6a042e254b6', '448959a7e0394148ae465d890ed2bbd2,f3eb17e6e5664a97af3e9b1fca12b286,cff4263234c04178b6f716310595544e,db6b58ae709645f2b64166fd73f2f705', '0', '3', '1', '2020-04-16 16:59:32', '2020-04-16 16:59:32');
INSERT INTO `tb_recommend` VALUES ('12ad6d59be8b4ba7b20bf66d89fdb279', 'Zoom 数万私人视频被公开，被曝加密技术造假', '向华盛顿邮报爆料的是美国国家安全局的前研究员帕特里克·杰克逊（Patrick Jackson），他爆料称在开放的云存储空间中一次性搜到了 15000 个 Zoom 视频。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFCGD\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>因新冠疫情，视频会议软件使用量激增，其中的代表性产品 Zoom 的日活跃用户，从去年 12 月份的 1000 万人激增到现在的2亿人。</p> \n<p>但近日，华盛顿邮报报道 Zoom 存在的重大安全漏洞，数以万计的私人 Zoom 视频被上传至公开网页，任何人均可在线围观。</p> \n<p>向华盛顿邮报爆料的是美国国家安全局的前研究员帕特里克·杰克逊（Patrick Jackson），他爆料称在开放的云存储空间中一次性搜到了 15000 个 Zoom 视频。</p> \n<p>此外，加拿大多伦多大学公民实验室的研究人员对软件进行了逆向工程，发现该公司在加密方案上有虚假宣传。Zoom 称其会议使用 AES-256 加密，但实际上只在 ECB 模式下使用了简单的 AES-128 密钥，密钥由 Zoom 的服务器产生。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFCGA\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>Zoom 还声称使用端对端加密，但事实上距离真正的端对端加密还比较遥远，该公司对端对端加密的定义与通常的定义有差距。</p> \n<p>种种安全事件频繁发生后，Zoom 受到了全球用户的批评。因此，Zoom 宣布暂停任何新功能的开发，以专注于安全和隐私问题。企业创始人袁征表示，该公司为解决安全疑虑而采取如下的步骤：</p> \n<ul> \n <li>对加密方法进行说明</li> \n <li>删除从 iOS 应用到脸书的共享代码</li> \n <li>发布与 Mac 相关问题的修复程序</li> \n <li>删除与领英网站（LinkedIn）之连接，以防止不必要的数据泄露</li> \n <li>发布如何避免成为「Zoom 轰炸」受害者的说明</li> \n</ul> \n<p>在接下来的 90 天内，该公司又计划：</p> \n<ul> \n <li>暂时冻结新功能开发，以专注于安全和隐私</li> \n <li>与独立专家进行审查，以了解新客户所需的新安全功能</li> \n <li>编写有关数据请求的透明度报告</li> \n <li>扩大其“漏洞赏金”计划</li> \n <li>每周举行一次网络研讨会，以提供隐私和资讯安全更新</li> \n</ul> \n<p>袁征坦言，如果安全问题不解决，甚至会考虑开源 Zoom 代码。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFxVM\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFCGD', '1c5851dc916d4e70a60f0c957f548876', '2a81fe886a0a41028a7b13cb4915b40f,f3eb17e6e5664a97af3e9b1fca12b286', '0', '3', '1', '2020-04-16 16:59:30', '2020-04-16 16:59:30');
INSERT INTO `tb_recommend` VALUES ('14c0bb59c6ca4877baee85c0bd331242', '[宝宝也能看懂的活动篇][30-Day LeetCoding Challenge] 第十一天', '二叉树的直径 Hi 大家好，我是张小猪。欢迎来到『宝宝也能看懂』系列特别篇 - 官方小活动 『30-Day LeetCoding Challenge』。 这里是 4 月 11 号的题，也是题目列表中的第 543 题 -- 『二叉树的直径』 题目描述 ...', '<h1>二叉树的直径</h1> \n<p>Hi 大家好，我是张小猪。欢迎来到『宝宝也能看懂』系列特别篇 - 官方小活动 『30-Day LeetCoding Challenge』。</p> \n<p>这里是 4 月 11 号的题，也是题目列表中的第 543 题 -- 『二叉树的直径』</p> \n<h2>题目描述</h2> \n<p>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。</p> \n<p>示例 :</p> \n<pre><code class=\"shell\">给定二叉树\n\n          1\n         / \\\n        2   3\n       / \\\n      4   5</code></pre> \n<p>返回&nbsp;__3__, 它的长度是路径 [4,2,1,3] 或者&nbsp;[5,2,1,3]。</p> \n<p><strong>注意：</strong> 两结点之间的路径长度是以它们之间边的数目表示。</p> \n<h2>官方难度</h2> \n<p>EASY</p> \n<h2>解决思路</h2> \n<p>题目的需求是求一颗二叉树的直径。第一眼看起来似乎有些不知道如何下手，不过我们尝试把这个问题拆解开来。站在一个节点的视角上看来这个目标，那其实只有两种情况：</p> \n<ul> \n <li>这个最长路径以\"我\"为转折点：那么这个最长路径必然就是以\"我\"为根节点的子树左侧的高度 + 右侧的高度 + 1。</li> \n <li>这个最长路径不以\"我\"为转折点：那么它一定以其他某个节点为转折点，对于\"我\"无需进行后续计算。</li> \n</ul> \n<p>通过这种方式，我们成功的把目标拆解为了比较简单的小目标。然后我们只需要找到方法求出子树的高度即可。</p> \n<h3>直接方案</h3> \n<p>通过深度优先遍历，我们可以轻松的求得某个子树的高度。为了避免大量的重复计算，我们可以用一个 map 把运算的结果进行暂存。最后再结合上面的思路，我们可以得到类似下面的代码：</p> \n<pre><code class=\"js\">const diameterOfBinaryTree = root =&gt; {\n  const cache = new Map();\n  let max = 0;\n  dfs(root);\n  return max;\n\n  function dfs(node) {\n    if (!node) return 0;\n    if (cache.has(node)) return cache.get(node);\n    const r = dfs(node.right);\n    const l = dfs(node.left);\n    if (max &lt; r + l) max = r + l;\n    cache.set(node, Math.max(r, l) + 1);\n    return Math.max(r, l) + 1;\n  }\n};</code></pre> \n<h2>总结</h2> \n<p>分析的过程其实就是尝试把一个大目标拆分成很多的小目标来处理。而对于二叉树，我们常用的经典的遍历方式例如深度优先遍历，再结合 memo 来做一点优化。希望能帮助到有需要的小伙伴。</p> \n<p>如果觉得不错的话，记得『三连』哦。小猪爱你们哟~</p> \n<h2>相关链接</h2> \n<ul> \n <li><a href=\"https://github.com/poppinlp/leetcode#30-day-leetcoding-challenge\" rel=\"nofollow noreferrer\">活动题目列表</a></li> \n <li><a href=\"https://github.com/poppinlp/leetcode\" rel=\"nofollow noreferrer\">leetcode 题解 repo</a></li> \n <li><a href=\"https://segmentfault.com/blog/zxzfbz\">我的 segmentfault 专栏</a></li> \n <li><a href=\"https://zhuanlan.zhihu.com/zxzfbz\" rel=\"nofollow noreferrer\">我的知乎专栏</a></li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCAAa\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"qrcode_green.jpeg\" title=\"qrcode_green.jpeg\"></span></p>', 'https://segmentfault.com/img/bVbCAAa', '3f69fcc9b13843d1910b3dac597f5215', '3921afbb134d45f6aa368b52d2670e7b,faf36da502544b51be926ab85450c40d,789898341cc64d45a1f44e26daab183f,63c4e1e7ec204b43a62065a3ced4c2ce,55723db96b9f4593bae02bc1e49f1e87', '0', '3', '1', '2020-04-16 16:55:35', '2020-04-16 16:55:35');
INSERT INTO `tb_recommend` VALUES ('1aab5419d1b241a5aa2cbb3dd633d534', 'Facebook 推出实验性工具链 Rome，为 JavaScript 提供「多合一」解决方案', '近期，Facebook 推出了一个 JavaScript 的实验性工具链，用于 JavaScript 和 TypeScript 开发的「多合一」解决方案。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFK7d\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>近期，Facebook 推出了一个 JavaScript 的实验性工具链，用于 JavaScript 和 TypeScript 开发的「多合一」解决方案。</p> \n<p>据悉，该项目以「条条大路通罗马」和「罗马不是一天建成的」俗语来命名，徽标选择的是古希腊的斯巴达头盔。</p> \n<hr> \n<p>该项目由塞巴斯蒂安·麦肯齐（Sebastian McKenzie）发起，塞巴斯蒂安·麦肯齐是 Babas 和 Yarn 的创建者。现在该项目已交由 Facebook 的 React Native 团队进行开发。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFLa3\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>Rome 是一个 JavaScript 的实验性工具链。该工具链由编译器，linter，格式化程序，打包器，测试框架等组成。旨在成为与 JavaScript 源代码处理相关的所有功能的综合工具。</p> \n<p>据 FaceBook 工程师介绍，Rome 使用 JavaScript 工具的方法与现有的开放源代码堆栈不同，并且可能与大型公司中基于内部基于单仓库的工具相似。Rome 负责所有构建和编译步骤，因此开发人员避免了在不同阶段必须通过多个工具传递源代码的情况。</p> \n<p>罗马的所有编译都是按模块进行的，从而允许在工作线程池中处理每个模块。为了避免这种情况导致需要重新解析每个模块，需要对它们进行预先命名，以便它们都可以共享一个作用域。</p> \n<p>当对每个文件进行编译时，Rome 可以通过在所有模块作用域变量之前加上基于模块文件名生成的标识符，来捆绑各个元素。这也适用于每个模块的导入和导出标识符，这意味着任何模块导出都可以仅使用模块的文件名和导出名称来解决：</p> \n<p>该工具链用 TypeScript 编写的，并且完全是自托管的，没有第三方依赖性，可用于处理 JSX，Flow 和 TypeScript 代码。</p> \n<p>但 Rome 尚未在生产中使用，仍处于试验阶段，但可以尝试从源码进行构建。目前，该项目在 GitHub 上已获得近 5K Star。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFLbW\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<blockquote> \n <strong>参考资料：</strong>\n <p>Rome 官网：<a href=\"https://romejs.dev/\" rel=\"nofollow noreferrer\">https://romejs.dev/</a> GitHub<br>地址：<a href=\"https://github.com/facebookexperimental/rome\" rel=\"nofollow noreferrer\">https://github.com/facebookex...</a></p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFtEG\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFK7d', '6fbfa4aaad3a43458f21c8acf0038ac5', 'd79254c4ca5e45dca9d484307c935281,db6b58ae709645f2b64166fd73f2f705,9223827da7dc4f1c8f6790777fb42d6e,63c4e1e7ec204b43a62065a3ced4c2ce', '0', '3', '1', '2020-04-16 16:59:46', '2020-04-16 16:59:46');
INSERT INTO `tb_recommend` VALUES ('1ae15e992d764346af4945cf729d2f4d', 'Pandownload 开发者被捕后，百度网盘会变得更好么？丨附律师事件解读', '来自扬州网警巡查执法官微的消息，受害人刘某报案称其下载的「Pandownload」软件会在未授权的情况下，将自己百度网盘的数据共享出去，导致隐私照片和文件泄露。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5GP\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"净网.jpg\" title=\"净网.jpg\"></span><br><strong>技术编辑：宗恩丨发自 SiFou NewOffice </strong><br><strong>SegmentFault 思否报道丨公众号：SegmentFault</strong></p> \n<hr> \n<p>这两天，又发生了一起迷惑行为。侵权行为被保护，受害的一方反而被「声讨」。</p> \n<p>来自扬州网警巡查执法官微的消息，受害人刘某报案称其下载的「Pandownload」软件会在未授权的情况下，将自己百度网盘的数据共享出去，导致隐私照片和文件泄露。</p> \n<p>经过警方调查，发现该软件可以以非会员权限突破百度网盘官方设定，实现高速下载，系侵入、非法控制计算机信息系统的程序、工具，并且该软件的使用者达到数万人，致使北京百度网讯科技有限公司(百度)损失高达上千万元。</p> \n<p>事件发生后，SegmentFault 思否第一时间跟进在微博分享了该新闻事件，但评论点赞最高的却是为 Pandownload 「平反」，并威胁要起诉百度。 </p> \n<p>这是个什么操作？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF7et\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"净网 知否网友回复-1.jpeg\" title=\"净网 知否网友回复-1.jpeg\"></span></p> \n<h2><strong>Pandownload 是谁？</strong></h2> \n<p>在此之前，大部分人其实并不知道这款软件，毕竟作为一个第三方小工具，用户只有几十万左右。但在第三方网盘下载工具这块儿，绝对是影响力和口碑最好的产品之一了。</p> \n<p>Pandownload 发布于 3 年前，作为一款网盘的下载工具，Pandownload 用户在没有百度会员权限情况下，对文件进行在线解压，且可以进行多任务不限速同时下载。</p> \n<p>大家都知道，百度网盘非会员用户的下载速度一直是其被大众诟病的原因，因此，Pandownload 被很多人称为「宝藏软件」。</p> \n<p>它的实现原理与 IDM 法类似，通过软件获取直链后调用 aria2 下载。操作的原理是在本地维护一个 IE 浏览器，可以在登录的时候看到，弹出了 IE 的百度网盘的登录页面，登录成功后再将浏览器进行隐藏。</p> \n<p>但这毕竟是未经授权的操作，并对百度网盘造成了直接的利益侵犯，再加上此次被举报的隐私泄露、违规谋利事件，让该软件的制作者蔡某被警方逮捕。</p> \n<p>据举报人所说，蔡某通过租用网络服务器对产品进行更新维护，并通过 QQ 群收取 1 到 10 元不等的进群费，总计牟利达 30 万余元。不过也有网友反馈 Pandownload 软件免费开放，蔡某所有获利均为自愿打赏。</p> \n<h2><strong>究竟犯了什么法？</strong></h2> \n<p>正因为 Pandownload 为用户带来的直接便利，才导致了微博上近乎一边倒的评论，但也有用户表示，这是「慷他人之慨」。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF7eu\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"净网 知否网友回复-2.png\" title=\"净网 知否网友回复-2.png\"></span></p> \n<p>为了弄清楚这背后到底的法律纠纷，SegmentFault 咨询了君合律师事务所的律师，为网友提出专业人士对此次事件的看法：</p> \n<hr> \n<p>首先，「破解」软件开发者由于对原软件著作权的人的著作权及经济利益造成了损害，将承担相应的民事责任及行政责任： </p> \n<p>pandownload软件开发者通过对百度网盘客户端的「反编译」，实现了百度网盘的客户端服务认证及高速下载服务功能，属于“故意避开或者破坏著作权人为保护其软件著作权而采取的技术措施”的行为，侵害了百度网盘经营主体对百度网盘所享有的软件著作权，并造成了百度网盘经营主体的经济损失。</p> \n<p>根据《计算机软件保护条例》，pandownload软件开发者将承担停止侵害、消除影响、赔礼道歉、赔偿损失等民事责任，并承担著作权行政管理部门的罚款等行政责任。</p> \n<p>其次，如软件开发者提供「破解」软件「情节严重」的，软件开发者还将承担刑事责任：pandownload软件开发者通过软件破解方式实施未经百度云盘许可的客户端认证及高速下载功能，构成了对百度云盘计算机系统的一种「侵入」。</p> \n<p>依据《刑法》，提供专门用于侵入、非法控制计算机信息系统的程序、工具的，情节严重的，将可能被处以三年以下有期徒刑或者拘役，并处或者单处罚金。情节特别严重的，处三年以上七年以下有期徒刑，并处罚金。</p> \n<p>根据相关司法解释，提供程序、工具二十人次以上的、违法所得五千元以上或者造成经济损失一万元以上即属于情节严重，将面临相关刑事处罚风险。</p> \n<p>目前法律法规对于计算机软件著作权在民事、行政、刑事层面予以多重保护。软件开发者在日常工作中应注重对于其他主体所依法享有的软件著作权的保护。对于软件「反编译」等行为，应事先征得该软件著作权人同意，或严格依据《计算机软件保护条例》规定的「以学习及研究目的」为限进行，并遵守相关法律法规的规定。</p> \n<h2><strong>Pandownload 没了，百度会更好么？</strong></h2> \n<p>从律师提出的分析可以了解到，虽然「情有可原」，但「法理难容」。Pandownload 确实存在着违法侵权行为。但另一方面，我们也能从网友们的呼声中了解到另一件事：</p> \n<p>网友苦百度网盘久矣。 </p> \n<p>不能否认，百度网盘是一个好产品。几年前曾经还有过百盘大战的盛况：金山网盘、迅雷快盘、UC网盘、新浪微盘、360网盘、乐视网盘、华为网盘，但最后一枝独秀的，就是百度网盘了。</p> \n<p>这背后的原因其实也不难理解。维系一个免费的网盘，尤其是用户量极大的一个产品，成本远远超过我们的想象，百度在这方面一定也投入了大量的人力物力来维系产品的正常运营。</p> \n<p>虽然百度推出了付费会员业务，但也不影响大家的免费使用，并且非会员也可以享用 2T 的存储空间，已经算是一个不错的福利了。如果百度突然宣布关闭百度网盘，相信也是很难接受的。</p> \n<p>不过话说回来，没开会员的百度网盘用户，下载速度确实感人，因此网友才会希望给 Pandownload 这种第三方工具一面“免死金牌”，让普通用户真的享受到互联网发展带给我们的社会福利。</p> \n<p>而这也是百度需要考虑的问题。Pandownload 被依法处理后，希望能让百度敲响一面警钟，不仅仅是百度网盘，如何在不破坏运营结构的情况下满足用户需求，找回曾经用户对百度企业品牌的推崇，对百度来说真的是个亟待解决的问题。</p>', 'https://segmentfault.com/img/bVbF5GP', '692c6787030d4b8882077b2ab9279c52', '81a4561c1c294e0cae32c9fe6b5dc397,077a6486ebf94f5e9a589411d2e4adb5,115ec0efd61e4e22942b00b9fd1246b0,6b3ff922b0dd4d378ac2f31d32e5f60d,aed399344712406e830d6efe028b7fe2', '0', '3', '1', '2020-04-16 16:47:07', '2020-04-16 16:47:07');
INSERT INTO `tb_recommend` VALUES ('1bd72b49c94a4a61a35134cd99445fe2', '超 50 万 ZOOM 账户在暗网上售卖，单价仅为 0.002 美分', '视频会议软件 Zoom 最近的日子真的是不好过。从被曝出重大安全漏洞之后，到被各企业机构封杀，再到被个人股东发起集体诉讼。近日又被曝出，在暗网和黑客论坛上，有超过 50 万个 Zoom 账户正在以不到每个一分钱（0...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZO5\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>视频会议软件 Zoom 最近的日子真的是不好过。从被曝出重大安全漏洞之后，到被各企业机构封杀，再到被个人股东发起集体诉讼。近日又被曝出，在暗网和黑客论坛上，有超过 50 万个 Zoom 账户正在以不到每个一分钱（0.002美分）的价格出售，甚至还可以被免费赠送。</p> \n<h2>黑客为名不图财</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZOL\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>据网络安全情报公司 cyble 透露，黑客提供这些免费账户是为了在黑客社区中获得更高的声誉。</p> \n<p>这些帐户是通过文本共享网站共享的，包括受害者的电子邮件地址、密码、个人会议 URL 及其主机密钥。根据透露的资料显示，有包含佛蒙特大学、科罗拉多大学、达特茅斯大学、拉斐特大学、佛罗里达大学等 290 所学校的相关帐户被免费发布出来。</p> \n<p>国外媒体已试图联系了这些列表中显示的随机电子邮件地址，并确认某些信息是正确的。但一位被出售信息的用户表示列表中的密码是旧密码，这表明其中一些凭证可能来自较旧的凭证填充攻击。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZOT\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>在看到卖家发布售卖信息后，Cyble 公司希望大量购买被出售的账号信息，以便来通知并警告相关客户可能出现的漏洞。</p> \n<p>据悉，Cyble 已经以每个账户 0.002 美分的价格购买了超过 53 万个 Zoom 账号信息，购买的信息包括电子邮件地址、密码、个人会议 URL 和他们的主机秘钥。经测试，这 53 万的账号信息中还包含摩根大通、花旗银行和很多知名教育机构的帐户。</p> \n<h2>建议更改密码</h2> \n<p>由于这些账户可能是利用旧有的数据漏洞所收集到的凭证填充攻击，为了安全起见，如果您的 Zoom 密码和其他网站的密码相同，建议不仅要尽快修改 Zoom 的密码，还要将其他平台的密码进行更换。</p> \n<blockquote>\n 相关阅读：\n <p><a href=\"https://segmentfault.com/a/1190000022310248\">Zoom 再遭谷歌封杀，个人股东发起集体诉讼</a> <br><a href=\"https://segmentfault.com/a/1190000022274150\">《Zoom 数万私人视频被公开，被曝加密技术造假》</a> <br><a href=\"https://mp.weixin.qq.com/s?__biz=MzU3NTQ2NDIyOQ==&amp;mid=2247492246&amp;idx=1&amp;sn=52ce6baee03a454332c6423c6f7d8774&amp;chksm=fd2014dcca579dca8a13b52efc1f3cf8d2772b45cd74fdf5c03acbfe46bf6b382df9a067f238&amp;mpshare=1&amp;scene=1&amp;srcid=&amp;sharer_sharetime=1586391238777&amp;sharer_shareid=25f66f2583339eda80990afae77dc8d4&amp;rd2werd=1#wechat_redirect\" rel=\"nofollow noreferrer\">《雪上加霜！股东向 Zoom 发起集体诉讼，索赔高额补偿》</a></p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyR0\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFZO5', '6fbfa4aaad3a43458f21c8acf0038ac5', 'e75baefb206a4efe959a99aad77632a3,7871a3acb3374d36b738a36c95c3f8ea', '0', '3', '1', '2020-04-16 16:58:53', '2020-04-16 16:58:53');
INSERT INTO `tb_recommend` VALUES ('20038a28482344bdada450abd5a838dc', '2021算法岗基础技能树怎么点？', '尽管目前本人求职的重心还是在后端上，但是为了能从现在的人工智能专业硕士顺利毕业，也为了让自己顺便拓展算法工程这条路，简单的规划一下算法这部分需要补的知识和技能还是有必要的。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFWpV\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"title.jpg\" title=\"title.jpg\"></span></p> \n<p>文章创作于2020年4月，大约7000字，预计阅读时间18分钟，请坐和放宽。</p> \n<h2>0 - 前言</h2> \n<p>注：本文默认传统算法是所有工程师的基础技能，所以后面提到的算法主要指机器学习以及深度学习等算法。</p> \n<p>尽管目前本人求职的重心还是在后端上，但是为了能从现在的人工智能专业硕士顺利毕业，也为了让自己顺便拓展算法工程这条路，简单的规划一下算法这部分需要补的知识和技能还是有必要的。</p> \n<p>本文以拿到2021算法岗Offer为目标，从2020的算法岗面经入手，分析需要点的技能树都有哪些。</p> \n<h2>1 - 不同算法岗的区别</h2> \n<p>首先需要说明的一个地方就是，不同领域的技术岗位，都会按照接触科研和业务的程度来进行一定的区分。</p> \n<p>可以简单参考知乎上霍华德在问题<a href=\"https://www.zhihu.com/question/366503145/answer/978673635\" rel=\"nofollow noreferrer\">“学术界科研（research）与工业界研发（R&amp;D）有什么区别？”</a>的回答[1]，算法岗可以大致分为：</p> \n<ul> \n <li>业务导向，大部分情况下以Development为主；</li> \n <li>技术导向，Research和Development兼顾；</li> \n <li>科研导向，大部分情况下会Research为主；</li> \n</ul> \n<p>近几年这一点在算法岗上表现体现的比较明显，因为在几年前大部分算法都还只在研究阶段，而最近随着一些成熟的机器学习封装库被开放过后，部分行业里开始发现这些算法可以产生实际的价值，所以算法岗位也就呈现了近几年的爆发式增长，尤其是业务导向的算法工程师（因为大部分公司还是希望这些算法能更多更快的产出业务价值）。</p> \n<p>当然这话其实说的已经有点晚了，现在已经不是刚开始那样的时候了，那个时候会使用框架、调调参就可以拿到Offer，现在的算法岗更像是浪潮过后的归于正常的情况，不仅需要扎实的理论基础，还需要丰富的项目实践。</p> \n<p>我个人是更倾向于业务导向的算法工程，所以本文以这部分为目标来编写，如果你有兴趣了解三种不同岗位的细节，可以阅读夕小瑶的一篇公众号文章<a href=\"http://suo.im/6385SY\" rel=\"nofollow noreferrer\">《拒绝跟风，谈谈几种算法岗的区别和体验》</a>[2]。</p> \n<h2>2 - 2020面经读后感</h2> \n<p>为了更好地了解各行业公司都比较看重哪些方面的东西（很可能也都是这些公司在用的技术），我选择直接从算法岗的面经里去寻找可能的答案，面经贴主要是<a href=\"https://www.nowcoder.com/discuss/experience?tagId=645\" rel=\"nofollow noreferrer\">牛客网</a>上的[3]。</p> \n<p>找到的点可以简单分为以下几类：</p> \n<ul> \n <li>纯数学相关</li> \n <li>机器学习</li> \n <li>深度学习</li> \n <li>NLP相关</li> \n <li>推荐算法</li> \n</ul> \n<p>一些传统算法相关就不在此列了（Leetcode和一些书比如《剑指Offer》整理的也足够多了）。我能够看到的面经是有限的，面经里提供的内容也是有限的，所以后面的内容不能说能概括到全部，但是至少能提取出很大一部分频繁出现的关键词（如果真的有需要的话再写个爬虫+关键词提取吧）。</p> \n<p>内容因为并没有特别多的先后依赖关系，所以就按照在面经里出现的顺序来列了。</p> \n<h3>2.1 - 纯数学相关</h3> \n<ul> \n <li>事件概率计算</li> \n <li>狄利克雷分布</li> \n <li>最大似然估计和贝叶斯估计</li> \n <li>...</li> \n</ul> \n<h3>2.2 - 机器学习</h3> \n<ul> \n <li>数据清洗、数据平滑</li> \n <li>常用的降维方式、PCA</li> \n <li>LDA(Linear Discriminant Analysis)</li> \n <li>决策树，ID3、C4.5、CART</li> \n <li>XGBoost、LightGBM、随机森林、Adaboost、GBDT</li> \n <li>SVM原理、对偶问题</li> \n <li>L1、L2正则化</li> \n <li>过拟合</li> \n <li>特征选择方法</li> \n <li>LR(Logistic Regression)和SVM、Linear SVM 和 LR</li> \n <li>聚类方法、K-means、层次聚类</li> \n <li>模型的评价指标、ROC</li> \n <li>朴素贝叶斯原理</li> \n <li>scikit-learn、numpy</li> \n <li>bagging和boosting</li> \n <li>集成学习</li> \n <li>分类方法</li> \n <li>模型上线优化</li> \n <li>连续值、离散值，离散化连续特征的好处</li> \n <li>回归方法、线性回归、岭回归、Lasso回归、LR</li> \n <li>信息增益，信息增益比，Gini系数的关系</li> \n <li>One-Hot编码的原理及意义</li> \n <li>Optimizers(Gradient Descent、...)</li> \n <li>统计学习算法</li> \n <li>...</li> \n</ul> \n<h3>2.3 - 深度学习</h3> \n<ul> \n <li>Feedforward Neural Network</li> \n <li>Back Propagation</li> \n <li>Layers，convolutional、pooling、full connected</li> \n <li>CNN(卷积)、RNN(梯度消失问题)、LSTM、GRU</li> \n <li>GAN</li> \n <li>目标检测，R-CNN、Fast R-CNN、Faster R-CNN、YOLO、SSD、...</li> \n <li>SoftMax、Sigmoid</li> \n <li>Embedding</li> \n <li>注意力机制</li> \n <li>GCN(Graph Convolutional Network)</li> \n <li>Optimizers(Gradient Descent、BGD、SGD、Adam、Adagard...)</li> \n <li>Tensorflow、Keras、PyTorch</li> \n <li>Activation(sigmoid、softmax、relu...)</li> \n <li>MobileNet</li> \n <li>Dropout</li> \n <li>CPU、GPU加速</li> \n <li>...</li> \n</ul> \n<h3>2.4 - NLP相关</h3> \n<ul> \n <li>关键字提取、TF-IDF</li> \n <li>命名实体</li> \n <li>LDA(Latent Dirichlet Allocation)</li> \n <li>word2vec</li> \n <li>Bert、Transformer</li> \n <li>...</li> \n</ul> \n<h3>2.5 - 推荐算法</h3> \n<ul> \n <li>基于内容的推荐</li> \n <li>协同过滤推荐、UserCF、ItemCF</li> \n <li>如何处理稀疏矩阵</li> \n <li>...</li> \n</ul> \n<h3>2.6 - 面经总结</h3> \n<p>在大部分算法面试中，面试官的问题都是围绕着简历上的项目来问的，我们可以看到上面的很多项目所涉及到的点，面试官都有可能往深了问，比如：</p> \n<ul> \n <li>SVM原始问题为什么要转化为对偶问题，为什么对偶问题就好求解，原始问题不能求解么？</li> \n <li>K-means 中我想聚成100类 结果发现只能聚成98类，为什么？</li> \n <li>LR和SVM这两个应用起来有什么不同？</li> \n <li>对于PCA，会有第一主成分、第二主成分，怎么为什么第一主成分是第一，原因是什么？</li> \n <li>bagging 和boosting 哪个可以让结果的方差更小一些，为什么？</li> \n <li>...</li> \n</ul> \n<p>所以在学习过程中不光要知道How，还是要多知道几个Why，一是为了能在面试的时候能回答出问题，二是为了更好地理解手里的这个工具。</p> \n<h2>3 - 算法的基础技能树</h2> \n<p>面经总结出来的点也还是有点乱，所以我又参考了一些算法学习路线的帖子来简单的归类梳理一下各个点，主要是参考的机器之心的这篇<a href=\"https://mp.weixin.qq.com/s/dI0im1AZmwrFQCO2uWiXXg\" rel=\"nofollow noreferrer\">完备的 AI 学习路线，最详细的中英文资源整理</a>[4]，时效为2019-04-28，还参考了一个不知道我什么时候在哪里找到的知识点总结图，如果有人知道出处的话可以在评论里和我说一下，图片链接会附在文章末尾（图片很大，所以放进来会看不清）。</p> \n<h3>3.1 - 数学基础</h3> \n<ul> \n <li>高等数学</li> \n <li>线性代数</li> \n <li>概率论与数理统计</li> \n</ul> \n<p>并不是说要把上面三个教材吃的完全透了才开始学习后面的，其实人工智能领域很多方法都只是用到了其中的一小部分，有一些专门总结了的机器学习中需要使用到的数学知识的书籍和文档[4]，你可以在机器之心的公众号文章找到这些（我在文章末尾也会上一个链接），具有基本的数学基础的可以用来复习，没有数学基础的还是建议在看不懂的地方回顾到教材。</p> \n<p>有些帖子可能会在数学基础这部分加上一个凸优化，个人理解上，在纯粹的学习过程中凸优化可以说是最枯燥的一门课，里面大部分是一些凸优化的定义和理论公式的证明，所以建议在后期遇到的时候再切入某一个点深入学习。</p> \n<h3>3.2 - 编程基础</h3> \n<p>在数值分析和人工智能这方面，还是Python支持的库比较方便，在入门学习方面已经足够使用了，版本目前推荐3.5 or 3.6。</p> \n<p>Anaconda(or Miniconda)是一个比较方便的Python虚拟环境和包管理软件，但是在某些时候会遇到麻烦事(比如一些算法框架的奇奇怪怪的环境要求)，但是在大部分情况下的入门阶段已经足够使用了。</p> \n<p>Python的IDE大部分人常用的就是Pycharm，如果有些能力折腾的，可以考虑用vscode+插件等等。</p> \n<h3>3.3 - 数据处理/分析/挖掘</h3> \n<p>实际使用中，很多机器学习、深度学习方法只有在高质量数据中才能起作用，比如数据的信息量足够多、噪声和错误信息足够少。而实际数据收集过程中，很多情况下不可能让数据这么完美，所以需要进行一些初步的数据处理（采集、清洗、采样、去噪、降维、...）。</p> \n<p>除了Python语言基础，还需要掌握一些基础的数据处理库，比如numpy、pandas、matplotlib等，可以参考机器之心推荐的《利用python进行数据分析》。</p> \n<blockquote>\n 这本书含有大量的实践案例，你将学会如何利用各种Python库（包括NumPy，Pandas、Matplotlib以及IPython等）高效地解决各式各样的数据分析问题。如果把代码都运行一次，基本上就能解决数据分析的大部分问题了。\n</blockquote> \n<p>另外还有就是[4]：</p> \n<ul> \n <li><a href=\"https://blog.csdn.net/Datawhale/article/details/83033869\" rel=\"nofollow noreferrer\">数据挖掘中的特征工程</a></li> \n <li><a href=\"https://blog.csdn.net/datawhale/article/details/80847662\" rel=\"nofollow noreferrer\">一些数据挖掘的项目</a></li> \n</ul> \n<p>数据挖掘可以帮助我们初步的理解数据各特征之间具有的一些关系，增加或者删除一些特征来帮助后续的学习。数据挖掘可以通过一些导论书籍或者课程进行一些初步系统性的了解，其中的大部分原理都不是很高深。</p> \n<h3>3.4 - 传统机器学习</h3> \n<h4>3.4.1 - 入门</h4> \n<p>如果在入门的时候，一开始就学习数学和理论公式，也不去弄明白这个东西到底有什么用，就很难去理解到底为什么需要这些理论。</p> \n<p>在学习每个机器学习算法前，可以先笼统的明白这个东西的作用，然后带着问题“这个是怎么实现的？”去探究算法的理论，才能比较贯通的理解其中的数学和公式。</p> \n<p>这里推荐一个网站，<a href=\"https://easyai.tech/\" rel=\"nofollow noreferrer\">产品经理的人工智能学习库</a>。</p> \n<blockquote>\n 人工智能领域的百科全书，非常适合小白和新手入门 AI 领域。现在市面上大家看到的绝大部分 AI 资料都是追求严谨的“理工科天书”，这个世界不缺少严谨真确晦涩难懂的 AI 资料，但是很缺容易理解的内容。我们希望抛开复杂的公式，复杂的逻辑，复杂的专用名词。做一套文科生也能看懂的 AI 知识库。\n</blockquote> \n<h4>3.4.2 - 理论</h4> \n<p>机器学习的理论部分大概有：</p> \n<ul> \n <li> <p>机器学习所面向的问题</p> \n  <ul> \n   <li> <p>分类</p> \n    <ul> \n     <li>决策树</li> \n     <li>K-近邻</li> \n     <li>SVM</li> \n     <li>Logistic回归</li> \n     <li>贝叶斯</li> \n     <li>随机森林</li> \n     <li>...</li> \n    </ul> </li> \n   <li> <p>回归</p> \n    <ul> \n     <li>线性回归</li> \n     <li>最小二乘回归</li> \n     <li>局部回归</li> \n     <li>神经网络</li> \n     <li>...</li> \n    </ul> </li> \n   <li> <p>聚类</p> \n    <ul> \n     <li>K-means</li> \n     <li>EM</li> \n     <li>...</li> \n    </ul> </li> \n   <li> <p>降维</p> \n    <ul> \n     <li>主成分分析 PCA</li> \n     <li>线性判别分析 LDA</li> \n     <li>...</li> \n    </ul> </li> \n   <li>...</li> \n  </ul> </li> \n <li> <p>回归</p> \n  <ul> \n   <li>线性回归</li> \n   <li>Logistic回归</li> \n   <li>...</li> \n  </ul> </li> \n <li> <p>决策树与随机森林</p> \n  <ul> \n   <li>ID3</li> \n   <li>C4.5</li> \n   <li>CART</li> \n   <li>回归树</li> \n   <li>随机森林</li> \n   <li>...</li> \n  </ul> </li> \n <li> <p>SVM</p> \n  <ul> \n   <li>线性可分</li> \n   <li>线性不可分</li> \n  </ul> </li> \n <li>最大熵与EM算法</li> \n <li> <p>多算法组合与模型优化</p> \n  <ul> \n   <li>模型选择</li> \n   <li>模型状态分析</li> \n   <li>模型优化</li> \n   <li>模型融合</li> \n  </ul> </li> \n <li>贝叶斯网络</li> \n <li> <p>隐马尔可夫链HMM</p> \n  <ul> \n   <li>马尔可夫链</li> \n   <li>隐马尔可夫链</li> \n  </ul> </li> \n <li>主题模型LDA</li> \n <li>集成学习</li> \n <li>...</li> \n</ul> \n<p>内心OS：这总结下来基本上和某些书的目录差不多了。</p> \n<p>推荐课程[4]：</p> \n<ul> \n <li> <a href=\"https://www.coursera.org/learn/machine-learning\" rel=\"nofollow noreferrer\">《Machine Learning》- 吴恩达，源：Coursera</a>，比较适合入门的课程。</li> \n <li> <a href=\"https://study.163.com/course/courseLearn.htm?courseId=1004570029#/learn/video?lessonId=1049052745&amp;courseId=1004570029\" rel=\"nofollow noreferrer\">《机器学习》- 吴恩达，源：网易云课堂</a>，网易云课堂对上面课程的翻译和搬运。</li> \n <li> <a href=\"http://open.163.com/special/opencourse/machinelearning.html\" rel=\"nofollow noreferrer\">《CS229》 - 吴恩达，斯坦福，源：网易云</a>，与《Machine Learning》相似，有更多的数学要求和公式的推导。</li> \n <li> <a href=\"https://www.bilibili.com/video/av36731342\" rel=\"nofollow noreferrer\">《机器学习基石》 - 林轩田，台湾大学，源：Bilibili</a>，老师风趣幽默，侧重于机器学习理论知识，配套书籍<a href=\"http://amlbook.com/\" rel=\"nofollow noreferrer\">《Learning From Data》</a>。</li> \n</ul> \n<p>推荐书籍[4]：</p> \n<ul> \n <li>西瓜书《机器学习》- 周志华，主要是机器学习的核心数学理论和算法。</li> \n <li>《统计学习方法》- 李航，更加完备和专业的机器学习理论知识，作为夯实理论非常不错。</li> \n <li>《Pattern Recognition and Machine Learning》，中文译名《模式识别与机器学习》，简称PRML，出自微软剑桥研究院实验室主任 克里斯托弗·毕晓普(Christopher Bishop)之手，豆瓣评分9.5，目前这本书已经被微软开源，地址：<a href=\"https://www.microsoft.com/en-us/research/uploads/prod/2006/01/Bishop-Pattern-Recognition-and-Machine-Learning-2006.pdf\" rel=\"nofollow noreferrer\">https://www.microsoft.com/en-...</a>，书是英文的，网上可以找到一些第三方的中文翻译，不过还是建议读英文，再次也是中英对照着来。</li> \n</ul> \n<h4>3.4.3 - 实践</h4> \n<p>在初步入门和学习理论后，为了活学活用学到的算法，可以尝试进行实践。</p> \n<p>首先是一些可以拓展能力的常用工具（免得自己造轮子）：</p> \n<ul> \n <li> <a href=\"https://scikit-learn.org/stable/\" rel=\"nofollow noreferrer\">scikit-learn</a>：一个Python第三方提供的非常强力的机器学习库，它包含了从数据预处理到训练模型的各个方面。在实战使用scikit-learn中可以极大的节省我们编写代码的时间以及减少我们的代码量，使我们有更多的精力去分析数据分布，调整模型和修改超参。</li> \n <li> <a href=\"https://xgboost.readthedocs.io/\" rel=\"nofollow noreferrer\">XGBoost</a>：xgboost是大规模并行boosted tree的工具，它是目前最快最好的开源boosted tree工具包，比常见的工具包快10倍以上。在数据科学方面，有大量kaggle选手选用它进行数据挖掘比赛，其中包括两个以上kaggle比赛的夺冠方案。在工业界规模方面，xgboost的分布式版本有广泛的可移植性，支持在YARN, MPI, Sungrid Engine等各个平台上面运行，并且保留了单机并行版本的各种优化，使得它可以很好地解决于工业界规模的问题。</li> \n <li> <a href=\"https://lightgbm.readthedocs.io/en/latest/\" rel=\"nofollow noreferrer\">LightBGM</a>：​ LightGBM（Light Gradient Boosting Machine）同样是一款基于决策树算法的分布式梯度提升框架。为了满足工业界缩短模型计算时间的需求，LightGBM的设计思路主要是两点：1. 减小数据对内存的使用，保证单个机器在不牺牲速度的情况下，尽可能地用上更多的数据；2. 减小通信的代价，提升多机并行时的效率，实现在计算上的线性加速。由此可见，LightGBM的设计初衷就是提供一个快速高效、低内存占用、高准确度、支持并行和大规模数据处理的数据科学工具。</li> \n <li>...</li> \n</ul> \n<p>然后就可以去<a href=\"https://www.kaggle.com/\" rel=\"nofollow noreferrer\">Kaggle</a>上和大佬们对线了，如果你有能力也有idea，可以自己开出一个项目来做。</p> \n<p>如果你对某些算法有更深程度的理解，你甚至可以尝试用自己代码复现这些算法。</p> \n<p>推荐书籍：</p> \n<ul>\n <li>《Scikit-Learn 与 TensorFlow 机器学习使用指南》：这本书分为两大部分，第一部分介绍机器学习基础算法，每章都配备 Scikit-Learn 实操项目；第二部分介绍神经网络与深度学习，每章配备 TensorFlow 实操项目。如果只是机器学习，可先看第一部分的内容。</li>\n</ul> \n<h3>3.5 - 深度学习</h3> \n<h4>3.5.1 - 入门</h4> \n<p>在这里同样推荐<a href=\"https://easyai.tech/\" rel=\"nofollow noreferrer\">产品经理的人工智能学习库</a>。</p> \n<h4>3.5.2 - 理论</h4> \n<p>深度学习的理论部分大概有[4]：</p> \n<ul> \n <li> <p>基础神经网络</p> \n  <ul> \n   <li>神经元</li> \n   <li>激活函数</li> \n   <li>基本结构：输入层、隐藏层、输出层</li> \n   <li>反向传播算法</li> \n  </ul> </li> \n <li> <p>CNN</p> \n  <ul> \n   <li>卷积层</li> \n   <li>池化层</li> \n   <li>全连接层</li> \n   <li>CNN的典型网络结构(LeNet, AlexNet, VGG, ResNet, ...)</li> \n  </ul> </li> \n <li> <p>RNN</p> \n  <ul> \n   <li>单向RNN</li> \n   <li>双向RNN</li> \n   <li>深度RNN</li> \n   <li>LSTM</li> \n   <li>GRU</li> \n  </ul> </li> \n <li>GAN</li> \n <li>...</li> \n</ul> \n<p>你可以从广度上入手，在都了解的基础上，选择一个方向进行深入学习：</p> \n<ul> \n <li>计算机视觉（图像、视频处理，主要用CNN）；</li> \n <li>自然语言处理NLP（包括文本、语音处理，序列数据往往需要RNN）；</li> \n <li>生成模型（GAN、VAE等等）；</li> \n</ul> \n<p>推荐课程[4]：</p> \n<ul> \n <li> <a href=\"https://mooc.study.163.com/university/deeplearning_ai#/c\" rel=\"nofollow noreferrer\">《Deep Learning》- 吴恩达，源：网易云</a>，整个专题共包括五门课程：01.神经网络和深度学习；02.改善深层神经网络-超参数调试、正则化以及优化；03.结构化机器学习项目；04.卷积神经网络；05.序列模型。</li> \n <li> <a href=\"https://www.bilibili.com/video/av18904696?from=search&amp;seid=10813837536595120136\" rel=\"nofollow noreferrer\">程序员深度学习实战 - Fast.ai，源：Bilibili</a>，与吴恩达《Deep Learning》并驾齐驱，这门课最大的特点便是“自上而下”而不是“自下而上”,是绝佳的通过实战学习深度学习的课程，<a href=\"https://edu.csdn.net/course/detail/5192\" rel=\"nofollow noreferrer\">中文字母，源CSDN</a>。</li> \n <li> <a href=\"https://www.bilibili.com/video/av47055599\" rel=\"nofollow noreferrer\">CS230 - 吴恩达，斯坦福，源Bilibili</a>，涵盖了CNNs, RNNs, LSTM, Adam, Dropout, BatchNorm, Xavier/He initialization 等深度学习的基本模型，涉及医疗、自动驾驶、手语识别、音乐生成和自然语言处理等领域。</li> \n</ul> \n<p>推荐书籍[4]：</p> \n<ul> \n <li>开源书籍<a href=\"https://nndl.github.io/\" rel=\"nofollow noreferrer\">《神经网络与深度学习》 - 复旦邱锡鹏</a>，这本书花费了邱老师三年的时间，将自己的研究，日常的教学和实践结合梳理出这个深度学习知识体系。该书主要介绍神经网络与深度学习中的基础知识、主要模型（前馈网络、卷积网络、循环网络等）以及在计算机视觉、自然语言处理等领域的应用[5]。</li> \n <li>花书<a href=\"https://github.com/exacity/deeplearningbook-chinese\" rel=\"nofollow noreferrer\">《深度学习》，源：Github网友翻译</a>，该书从浅入深介绍了基础数学知识、机器学习经验以及现阶段深度学习的理论和发展，它能帮助人工智能技术爱好者和从业人员在三位专家学者的思维带领下全方位了解深度学习。</li> \n <li>神贴<a href=\"https://github.com/scutan90/DeepLearning-500-questions\" rel=\"nofollow noreferrer\">《深度学习 500 问》</a>，作者是川大的一名优秀毕业生谈继勇。该项目以深度学习面试问答形式，收集了 500 个问题和答案。内容涉及了常用的概率知识、线性代数、机器学习、深度学习、计算机视觉等热点问题，该书目前尚未完结，却已经收获了Github 2.4w stars（现在已经3.7w star了）。</li> \n</ul> \n<h4>3.5.3 - 实践</h4> \n<p>在初步入门和学习理论后，为了活学活用学到的深度学习算法，可以尝试进行实践。</p> \n<p>首先是一些可以拓展能力的常用工具（免得自己造轮子）：</p> \n<ul> \n <li> <a href=\"https://www.tensorflow.org/\" rel=\"nofollow noreferrer\">TensorFlow</a>，Google开源的深度学习框架，不过接口都比较底层，可能入门级稍难。</li> \n <li> <a href=\"https://keras.io/\" rel=\"nofollow noreferrer\">Keras</a>，一个用 Python 编写的高级神经网络 API，它能够以 TensorFlow, CNTK, 或者 Theano 作为后端运行。Keras对入门友好，不过其中过多的封装可能会导致需要自定义修改比较麻烦，所以他们主要面向的是快速实验、快速验证的任务。</li> \n <li> <a href=\"https://pytorch.org/\" rel=\"nofollow noreferrer\">PyTorch</a>，Facebook发布的一套深度学习框架，PyTorch专注于直接处理数组表达式的较低级别 API。去年它受到了大量关注，成为学术研究和需要优化自定义表达式的深度学习应用偏好的解决方案。</li> \n</ul> \n<p>关于哪个工具更好的问题，\"支持者\"之间也是争议不断，其实也不用纠结到底应该选哪一个，都试试不就知道了（逃。</p> \n<p>选择一个工具学会后，就可以去<a href=\"https://www.kaggle.com/\" rel=\"nofollow noreferrer\">Kaggle</a>上和大佬们对线了，如果你有能力也有idea，可以自己开出一个项目来做。</p> \n<h3>3.6 - 其他</h3> \n<p>至于强化学习、迁移学习、计算机视觉、NLP、推荐系统、知识图谱等内容，限于文章篇幅，就不在这里介绍了，不过你可以在机器之心的那篇文章中找到和他们有关的内容。</p> \n<h3>3.7 - 论文阅读</h3> \n<p>机器学习、深度学习大部分理论内容都来自计算机科研领域发表的论文，当下的前沿技术也都在近几年发表的论文中。</p> \n<p>作为入门、理论、实践的之后一个拓展阶段，可以通过阅读前沿论文来增加知识面。</p> \n<p>由于前沿论文阅读并不能算是一个业务导向的算法工程师所必须具有的能力，所以在这就不做过多的介绍了，同样，你可以在机器之心的那篇文章中找到关于阅读前沿Paper的相关介绍。</p> \n<h2>4 - 总结</h2> \n<p>不久前，某404网站给我推送了一个视频，名字看起来非常标题党，<a href=\"https://www.youtube.com/watch?v=cyLWtMSry58&amp;t=269s\" rel=\"nofollow noreferrer\">Don\'t learn machine learning - Daniel Bourke，源：Youtube</a>，其中作者核心的内容是不要为了只是学习算法而学习算法，要为了创造产品（或者说应用、或者说解决问题）而学习算法，有条件的同学可以看看（暂时还没有看到国内的翻译搬运，如果有时间有机会的话我就翻译搬运一下吧）。</p> \n<p>面向Offer学习未必是最优的一条路。我的目标是以后端为主线发展，之所以还没有完全的放弃这部分的算法，一部分是因为我的专业，更多的原因是我知道在某些问题上只有这些算法才能有效地解决，会用更多的算法也可以让程序员解决更多的问题。</p> \n<h2>5 - 参考文章</h2> \n<ul> \n <li>[1] 学术界科研（research）与工业界研发（R&amp;D）有什么区别？, <a href=\"https://www.zhihu.com/question/366503145/answer/978673635\" rel=\"nofollow noreferrer\">https://www.zhihu.com/questio...</a> </li> \n <li>[2] 拒绝跟风，谈谈几种算法岗的区别和体验 - 夕小瑶, <a href=\"http://suo.im/6385SY\" rel=\"nofollow noreferrer\">http://suo.im/6385SY</a> </li> \n <li>[3] 算法工程师精选面经合集 - 牛客网, <a href=\"https://www.nowcoder.com/discuss/experience?tagId=645\" rel=\"nofollow noreferrer\">https://www.nowcoder.com/disc...</a> </li> \n <li>[4] 完备的 AI 学习路线，最详细的中英文资源整理 - 机器之心, <a href=\"https://mp.weixin.qq.com/s/dI0im1AZmwrFQCO2uWiXXg\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/dI...</a> </li> \n <li>[5] 复旦教授邱锡鹏开源发布《神经网络与深度学习》- Datawhale, <a href=\"http://suo.im/6qyB8b\" rel=\"nofollow noreferrer\">http://suo.im/6qyB8b</a> </li> \n</ul>', 'https://segmentfault.com/img/bVbFWpV', '6fbfa4aaad3a43458f21c8acf0038ac5', 'faf36da502544b51be926ab85450c40d,efd45535a5504d5595fba4d1dbbc489c,2a09bf1afefd4d659606f43445741ee3,603c056cdb7840da9242d2c0844d5c0f,13f1211b651544e3a17611b2117e9cec', '0', '3', '1', '2020-04-16 16:55:38', '2020-04-16 16:55:38');
INSERT INTO `tb_recommend` VALUES ('20a91fa9f7744def8b05edee34e20ace', 'DoKit - 滴滴开源的一款功能齐全的客户端（ iOS 、Android ）研发助手', 'SegmentFault 思否消息：滴滴技术团队今天宣布，Dokit 3.0 版本正式发布，DoraemonKit，简称 DoKit，中文名哆啦 A 梦，是滴滴开源的一款功能齐全的客户端（ iOS 、Android ）研发助手。', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p>SegmentFault 思否消息：滴滴技术团队今天宣布，Dokit 3.0 版本正式发布，DoraemonKit，简称 DoKit，中文名哆啦 A 梦，是滴滴开源的一款功能齐全的客户端（ iOS 、Android ）研发助手。</p> \n<p>每一个稍微有点规模的 App，总会自带一些线下的测试功能代码，比如环境切换功能、帧率查看功能等等，这些功能的切换入口往往放在各式各样的入口中，比如一些特殊的手势，双击 statusBar，双击某一个功能区块，或者新建一个 keyWindow 始终至于 App 最上方等等，而且每一个 App 里面的线下附带功能模块很多是相似的，比如帧率查看、内存和 CPU 监控等等，但是现在基本上都是每个 App 都是自己实现了一份，经历了以上的问题之后，DoraemonKit 就有了它存在的意义。</p> \n<p>DoraemonKit 是一个功能平台，能够让每一个 App 快速接入一些常用的或者你没有实现的一些辅助开发工具、测试效率工具、视觉辅助工具，而且能够完美在 Doraemon 面板中接入你已经实现的与业务紧密耦合的一些非通有的辅助工具，并搭配<a href=\"https://www.dokit.cn/\" rel=\"nofollow noreferrer\">dokit</a>平台，让功能得到延伸，接入方便，便于扩展。</p> \n<p><strong>简单总结</strong></p> \n<p>1、DoraemonKit 能够快速让你的业务测试代码能够在这里统一管理，统一收口； <br>2、DoraemonKit 内置很多常用的工具，避免重复实现，一次接入，你将会拥有强大的工具集合。 3、搭配<a href=\"https://www.dokit.cn/\" rel=\"nofollow noreferrer\">dokit</a>平台，方便你进行<strong>数据mock</strong>以及记录你的每一次<strong>健康体检</strong>用例</p> \n<h4>效果演示</h4> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022238554\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"DoKit 首页效果演示\" title=\"DoKit 首页效果演示\"></span></p> \n<h3><strong>DoKit 3.0 版本新特性</strong></h3> \n<p><strong>▍</strong><strong>优化点</strong></p> \n<ul> \n <li>DoKit 3.0 相比于上一个版本一共解决了 github 上的 issues 70 多个，合并 PR 30 多个；</li> \n <li>内部架构升级，其中性能和代码的健壮性都得到了显著的提升；</li> \n <li>工具优化用户体验优化。</li> \n</ul> \n<p><strong>Android</strong></p> \n<p>Android 端主要优化了网络拦截、悬浮窗、位置模拟、Aop 解决方案等等：</p> \n<ul> \n <li>网络拦截统一了 okhttp、urlconnection；</li> \n <li>悬浮窗新增了普通模式，不再需要系统悬浮窗权限；</li> \n <li>位置模拟现已支持百度、腾讯、高德、系统原生；</li> \n <li>AOP 的代码插装方案也由一开始的 Aspectj 改成了 ASM 方案，兼容性和性能也都有了明显的提升。</li> \n</ul> \n<p><strong>iOS</strong></p> \n<p>iOS 端主要优化了多个工具的用户体验、加速代码安装速度、减少对于业务方的影响等等：</p> \n<ul> \n <li>NSLog 监控、子线程 UI、CocoaLumberjack 日志日志监控等功能不需要重新启动 App 即可进行开关；</li> \n <li>pod 仓库多地备份（github、gitee、gitlab），解决 pod install 缓慢的问题；</li> \n <li>解决 DoKit 的 window 影响 UIMenuController 的吗，导致业务方在某些机型弹不出来的问题；</li> \n <li>减少代码 hook 对于全局的影响；</li> \n <li>全局支持中英文切换。</li> \n</ul> \n<p><strong>▍</strong><strong>新增工具</strong></p> \n<p>以下新增的大部分 Kit 在 Android 和 iOS 两端是对齐的，有些平台特有的功能会进行标注。</p> \n<p><strong>1）数据&nbsp;Mock</strong></p> \n<p>提供一套基于 App 网络拦截的接口 Mock 方案，无需修改代码即可完成对于接口数据的 Mock。</p> \n<p>了解详情：<a href=\"https://www.dokit.cn/#/index/productCenter\" rel=\"nofollow noreferrer\">https://www.dokit.cn/#/index/productCenter</a></p> \n<p>了解更多可以查看文章《<a href=\"https://mp.weixin.qq.com/s/hXaeH1nVELA2PJDfJqLlvw\" rel=\"nofollow noreferrer\">滴滴正式发布开源客户端研发助手DoKit 3.0，新特性解读</a>》</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFmMq\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"思否公众号\" title=\"思否公众号\"></span></p>', 'https://segmentfault.com/img/remote/1460000022238554', '6fbfa4aaad3a43458f21c8acf0038ac5', '448959a7e0394148ae465d890ed2bbd2,f3eb17e6e5664a97af3e9b1fca12b286,cf84afe221f24e72b201344b3e15fa85,bb08094058724cb5a595418407aa6c06', '0', '3', '1', '2020-04-16 16:47:21', '2020-04-16 16:47:21');
INSERT INTO `tb_recommend` VALUES ('23a05695759b47cb8b1712013780e1b7', 'Gartner 发布 2020 年公共云容器报告，阿里云与 AWS 并列成全球容器产品最完善云服务商', '近日，国际知名调研机构 Gartner 发布 2020 年公共云容器报告。该报告评选标准严格，需要在 Serverless 容器、服务网格、安全沙箱容器、混合云和边缘等 10 个产品维度对云厂商进行考核。', '<p>近日，国际知名调研机构 Gartner 发布 2020 年公共云容器报告。该报告评选标准严格，需要在 Serverless 容器、服务网格、安全沙箱容器、混合云和边缘等 10 个产品维度对云厂商进行考核。</p> \n<p>根据此次报告结果显示，阿里云和 AWS 拥有最丰富的产品布局，覆盖了 9 项产品能力，领先谷歌、微软及 IBM 等企业。此外，阿里云也连续两年成为唯一入选的中国企业。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyDn\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>Gartner 报告指出，企业使用容器技术是大势所趋，主流云服务商都在布局无服务化容器、混合云、安全和自动化 DevOps 等容器相关领域。</p> \n<hr> \n<p>阿里云是国内最早布局容器技术的公司之一，其容器服务经历了阿里巴巴集团内部业务场景十余年的淬炼，并衍生了一系列产品服务，已在全球 19 个公共云可用区开服，服务规模增速连续多年超 400%，支撑上万个集群、数百万容器。</p> \n<p>Gartner 分析师认为，“阿里云拥有丰富的容器产品形态，在中国市场表现强劲，并在上述产品领域具备良好的技术发展策略。”</p> \n<p>近日，斯坦福大学公布的 DAWNBench 深度学习榜单中，阿里云同样表现优异，在最新的Image Classification on ImageNet图像识别榜单中，阿里云一举包揽了训练时间、训练成本、推理延迟、推理成本四项第一，打破了Google等保持了一年多的纪录。</p> \n<blockquote> \n <strong>Gartner 报告地址：</strong>\n <br>\n <a href=\"https://www.gartner.com/en/documents/3982527/competitive-landscape-public-cloud-container-services\" rel=\"nofollow noreferrer\">https://www.gartner.com/en/do...</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFxVM\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFyDn', '1c5851dc916d4e70a60f0c957f548876', '69a24148dd3149e49273bc7d178fa7bc,50b1ead18a154fb9a3be3ed4bc61398b,0f2596e8a00f4ed58d2b4e47f674a118,ba16f5b739f24380990a4ccacfe6f833,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-16 16:56:37', '2020-04-16 16:56:37');
INSERT INTO `tb_recommend` VALUES ('2438768bfb1d421d8f27de6647ddda40', '抽签小程序，妈妈再也不用担心谁洗碗（分配任务）了，so easy', '背景 今天谁炒菜，谁洗碗，谁买菜...啊，Boss说用抽签吧，于是有了下图 这样存在作弊的问题（记住棍子特征，谁先，谁后抽等等）于是有了这个抽签小程序（当然小程序我一个人控制，我想不想作弊看心情了） 简介 扫...', '<h2>背景</h2> \n<p>今天谁炒菜，谁洗碗，谁买菜...啊，Boss说用抽签吧，于是有了下图<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383943\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>这样存在作弊的问题（记住棍子特征，谁先，谁后抽等等）于是有了这个抽签小程序（当然小程序我一个人控制，我想不想作弊看心情了）</p> \n<h2>简介</h2> \n<p>扫码体验</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383942\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<h2>数据服务，存储</h2> \n<p>本项目使用的是微信云开发，云数据库声明个抽签chouqianList集合即可（云开发为开发者提供完整的原生云端支持和微信服务支持，弱化后端和运维概念，无需搭建服务器，使用平台提供的 API 进行核心业务开发，即可实现快速上线和迭代）</p> \n<h2>运行前准备</h2> \n<p>(1)<a href=\"https://mp.weixin.qq.com/wxopen/waregister?action=step1\" rel=\"nofollow noreferrer\">注册微信小程序</a>，获取 appid,替换本项目project.config.json里的appid</p> \n<p>(2)<a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/quickstart.html\" rel=\"nofollow noreferrer\">开通小程序的云开发</a></p> \n<h2>具体实现</h2> \n<h3>首页</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383945\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>首页从上至下有抽签主题，抽签选项，发起抽签，常用抽签，此页面主要功能发起抽签，把抽签内容存到数据库里面。</p> \n<blockquote>\n 微信审核提示\n <br>\n <span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383944\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span>\n <br>解决这个问题添加的内容调用这个方法（小程序内容安全api，云开发可调用）\n</blockquote> \n<pre><code>  isCheckMsg: function (msg) {\n        return new Promise(function (n, s) {\n            wx.cloud.callFunction({\n                name: \'msg\',\n                data: ({\n                    text: msg\n                })\n            }).then(res =&gt; {\n                if (res.result.errCode === 87014) {\n                    // 没通过\n                    n(false) \n                } else {\n                    // (\"通过\")\n                    n(true)\n                }\n            });\n        });\n    },</code></pre> \n<p>随机抽签</p> \n<pre><code> // 递归随机返回抽签项\n    edchouqian() {\n        let that = this;\n        return new Promise(function (n, s) {\n            const db = wx.cloud.database()\n            // 查询当前用户所有的 chouqianList\n            db.collection(\'chouqianList\').where({\n                _id: that.data.drawlotsId\n            }).get({\n                success: res =&gt; {\n                    that.setData({\n                        detail: res.data[0].detail,\n                    });\n                    let nullDetail = res.data[0].detail.filter(item =&gt; item.openid == \"\");//找出没有抽签的选项\n                    let arrIndex = Math.floor((Math.random() * nullDetail.length));//从没有抽签的选项随机选择一个选项\n                    let objindex = nullDetail[arrIndex].index;\n                    n(objindex)\n                },\n                fail: err =&gt; {\n                    wx.showToast({\n                        icon: \'none\',\n                        title: \'查询记录失败\'\n                    })\n                    console.error(\'[数据库] [查询记录] 失败：\', err);\n                    s(err);\n                }\n            })\n        });\n    },</code></pre> \n<h3>抽签页</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383947\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>抽签页有抽签功能，显示抽签结果，此页面主要功能，从数据库查询是否已经抽签，已抽签显示抽签结果，未抽签随机分配抽签（或者显示抽签次数已用完）。</p> \n<blockquote>\n 重复抽签问题用函数防抖或者节流\n</blockquote> \n<h3>抽签结果页</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383946\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>抽签结果页，显示所有抽签人员和结果（结果从数据库根据抽签表的id查询）</p> \n<h4>至此完毕 <a href=\"https://github.com/mgbq/draw\" rel=\"nofollow noreferrer\">源码地址</a> </h4> \n<h3>结语：</h3> \n<p>因为发的时间比较短，页面、功能还需要慢慢完善，发布了的功能也有一些待改进的地方，欢迎同样志同道合的码友们多多指教和交流。ヾ(????)?~</p> \n<p>前端学习大佬群493671066，美女多多。老司机快上车，来不及解释了。</p> \n<h4>作者相关Vue文章</h4> \n<p><a href=\"https://github.com/mgbq/vue-permission\" rel=\"nofollow noreferrer\">基于Vue2.0实现后台系统权限控制</a></p> \n<p><a href=\"https://blog.csdn.net/qq_32340877/article/details/80176987\" rel=\"nofollow noreferrer\">vue2.0-基于elementui换肤（自定义主题）</a></p> \n<p><a href=\"https://github.com/mgbq/front-end-Doc\" rel=\"nofollow noreferrer\">前端文档汇总</a></p> \n<p><a href=\"https://github.com/mgbq/Vue-admin\" rel=\"nofollow noreferrer\">VUE2.0增删改查附编辑添加model(弹框)组件共用</a></p> \n<h2>打赏 衷心的表示感谢</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383948\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"打赏\" title=\"打赏\"></span></p>', 'https://segmentfault.com/img/remote/1460000022383943', '61cdf41d1e5e4f229b76f6a042e254b6', '9eccd82e1d9a4a8cb3a0971df3788f2b,4c3a5a1f039b42a5b26aeb9aca0646bb,15941dc0af92453481b8a0626f963283', '0', '3', '1', '2020-04-16 16:49:22', '2020-04-16 16:49:22');
INSERT INTO `tb_recommend` VALUES ('26e98227304845bbada73cf6708d20c4', '云服务商青云递交招股书，2019 年营收 3.8 亿元，计划融资 11.88 亿元', '青云成立于 2012 年 4 月，是一家平台级混合云 ICT 厂商和服务商，致力于为企业用户提供自主可控、中立可靠、性能卓越、灵活开放的云计算产品与服务。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIHv\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>4 月 7 日 晚，上交所披露了云服务商青云科技的招股说明书，公司计划于科创板上市。据招股书显示，青云计划上市融资 11.88 亿元。</p> \n<p>青云成立于 2012 年 4 月，是一家平台级混合云 ICT 厂商和服务商，致力于为企业用户提供自主可控、中立可靠、性能卓越、灵活开放的云计算产品与服务。</p> \n<p>经过多年发展，青云科技具备了全维度的云产品与云服务交付能力：在技术层次上，自主研发形成跨越智能广域网、IaaS 和 PaaS 的云网一体技术架构体系，拥有全面的 ICT 服务能力；</p> \n<p>在交付形态上，以统一技术架构形成云产品、云服务两大标准化业务模块，根据客户需要满足私有云、公有云和混合云的部署需求，并针对多个行业形成了完善的行业云计算解决方案；</p> \n<p>在场景纵深上，正着力布局发展集云、网、边、端于一体化的综合服务能力，实现更广义的数据互联。</p> \n<p>2019 年，青云营收 3.77 亿元，同比增长 33.7%，扣除非经常损益净亏损为 1.38 亿元，同比扩大 10%。青云在招股书「重大事项提示」中称由于前期固定资产投入及研发支出较大，目前尚未实现盈利，且预计公司经营会持续产生大量开支。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFICz\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>青云在招股书中坦言存在以下风险：</p> \n<h2><strong>一、公司目前尚未盈利，且预计短期内无法盈利、未弥补亏损持续存在</strong></h2> \n<p>由于前期固定资产投入及研发支出较大，公司目前尚未实现盈利，且预计公司经营会持续产生大量开支。另外，公司存在金额较大的累计未弥补亏损，公司由有限责任公司整体变更为股份有限公司的基准日未分配利润为负。</p> \n<p>截至本招股说明书签署之日，由于公司新技术与新产品研发投入较大、所处云计算行业尤其是公有云领域竞争较为激烈，该情形尚未消除。</p> \n<p>以下风险将导致公司在未来一段时间内持续亏损且存在累计未弥补亏损的情形：</p> \n<p><strong>1、收入增速不达预期的风险</strong><br><strong>2、固定资产投入及数据中心采购较大的风险</strong><br><strong>3、毛利率波动风险</strong><br><strong>4、研发支出较大的风险</strong><br><strong>5、资金状况、研发投入、业务拓展、人才引进、团队稳定等方面受到限制或影响的风险</strong></p> \n<h2><strong>二、云计算行业尤其是公有云领域竞争激烈，存在竞争风险</strong></h2> \n<p>云计算是信息化时代的重要 IT 基础设施，潜在市场空间巨大，经济效益和社会价值极高。产业各界高度关注云计算市场机会，众多大型知名企业纷纷进军云计算行业，富有活力的中小型云计算创业公司也不断成立。</p> \n<p>公司在云产品业务领域面临着华为、新华三、VMware等大型IT行业龙头的竞争，在云服务业务领域也有着阿里云、腾讯云、AWS等实力雄厚的竞争对手，各大厂商通过降低产品报价、加强营销推广等多种手段，积极争取客户订单，着力抢占市场份额。</p> \n<p>若公司不能在竞争中构筑核心技术壁垒，加速产品更新迭代，拓展销售渠道网络，优化服务质量，从而进一步加强核心竞争能力，提升市场份额，将对公司经营业绩形成不利影响。</p> \n<h2><strong>三、公司研发、运营资金需求持续增加，存在营运资金风险</strong></h2> \n<p>公司业务运营所需资金量较高，2017 年度、2018 年度及 2019 年度，公司经营活动产生的现金流量净额分别为 1,051.19 万元、-6,239.70 万元及 -8,700.04 万元。</p> \n<p>报告期内，公司通过股权融资及债权融资方式获得营运资金、保证较为充裕的现金流；未来，公司为了进一步拓展公司业务规模、丰富产品线、完善销售渠道、提升公司核心技术先进性与市场竞争力，仍需要继续投入持续增加的研发投入、销售投入、固定资产支出和其他日常经营支出。</p> \n<p>若公司无法获得足够的营运资金，公司商业计划及业务发展目标可能会被推迟甚至取消，进而对公司业务造成重大不利影响。</p> \n<h2><strong>四、云计算行业技术演进较快，存在技术研发失败风险</strong></h2> \n<p>由于云计算行业仍处于发展早期，技术迭代较快，创新产品和创新模式不断涌现，推动行业产品和服务的质量不断提升，如计算速度、系统稳定性等核心指标都有了较大提升。云计算作为技术密集型行业，产品性能和可靠性是客户在选择供应商时的核心考量因素。</p> \n<p>若公司不能准确把握行业发展趋势，针对性地研发技术和开发产品，导致产品性能和服务质量落后于竞争对手，可能存在已有客户流失、业务发展迟滞、市场份额下降的风险。</p> \n<h2><strong>五、募投项目可能带来即期收益摊薄风险</strong></h2> \n<p>本次发行完成后，公司的资产规模将大幅增加，但因募投项目实施需要一定周期、募集资金到位当期无法立刻全部投入生产运营，在当期产生的效益可能较低。预计发行完成后公司的每股收益和摊薄每股收益会有所下降，即期回报短期内将被摊薄。</p> \n<hr> \n<p>此前，青云市场副总裁刘靓在某次采访中，曾透露青云在 2020 年的新规划。</p> \n<p>刘靓认为，2020 年的云计算市场将聚焦三个特点：重传统企业数字化转型、重生态能力的提升、IT 服务能力与 AI 深度融合。因此，青云将继续深耕传统行业领域，持续贯彻并积极投身与百行千业合作伙伴的深入合作，并将继续加大研发力度，与人工智能技术深度结合，提高云计算产业链条各环节效率、能力和客户体验，打造出更智能的云。</p> \n<p>扫描下方二维码并回复关键词「招股书」，获取招股书完整版 PDF。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyR0\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFIHv', 'f53014d680884163a5bd5ce762e90cdf', '1fb6bf7d213640b28d89fe5a369dc60d,f831bc1c03f94b4b9e49390a3a354a3e,e80d97c3472e428dabdaf417adac7a3c', '0', '3', '1', '2020-04-16 16:56:35', '2020-04-16 16:56:35');
INSERT INTO `tb_recommend` VALUES ('2a28d1c6d76a4a94bac56f5681e03afc', 'core-js 作者入狱 18 个月，周下载 2600 万次的开源项目恐将无人维护', '俄罗斯开发者丹尼斯·普什卡列夫（Denis Pushkarev）是 JavaScript 的模块化标准库 Core-js 的唯一维护人员。去年 10 月，其因驾驶摩托车时撞到了两位行人并造成其中一人死亡，上诉无效后，最终被判处 18 个月有期...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFwal\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>俄罗斯开发者丹尼斯·普什卡列夫（Denis Pushkarev）是 JavaScript 的模块化标准库 Core-js 的唯一维护人员。去年 10 月，其因驾驶摩托车时撞到了两位行人并造成其中一人死亡，上诉无效后，最终被判处 18 个月有期徒刑。</p> \n<p>那么，这 18 个月谁能替他来维护这个库？</p> \n<h2>周下载量 2600 万次的 core-js</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFv91\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>尽管周下载量达到惊人的 2600 万次，但该项目的知名度似乎与其的使用程度并不匹配。这里引用思否社区技术专家 <a href=\"/u/justjavac\">@justjavac</a> 在相关问题中的一个回复：</p> \n<blockquote>\n 现在 react/vue/angular，webpack，babel、core-js 等已经是前端的基础设施，但是 core-js 的存在感太弱了。core-js 在 npm 的下载量比 react/vue/angular 的总和还要多几倍。然而几乎所有前端开发者就算没有使用过也都听说过 3 大框架。至于 core-js 就尴尬了，很多两三年从业经历的前端开发者都不一定听说过这个库。\n</blockquote> \n<p>不仅如此，从 npmjs.com 上我们能看到，总共有 19279 个 Package 依赖 core-js。可见该项目的重要程度。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFwcQ\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<h2>该项目最终将何去何从？</h2> \n<p>对于这种情况，GitHub 社区与安全高级产品经理本·巴尔特（Ben Balter）表示，在项目维护者不响应的情况下，该公司将继续考虑回购所有权的转移。Balter 说：“在一种首选的情况下，我们要确保提前主动缓解问题。”同时还表示，“我们鼓励维护者将受欢迎的项目从他们的个人帐户转移到组织中。除了获得高级社区管理功能之外，添加至少一名其他维护者作为共同所有者进一步确保了该项目能够继续进行，即使一个维护者是无法使用。”</p> \n<p>Balter 还表示，GitHub 拥有在生病时转移帐户所有权的流程，适用于亲戚，合作者，同事和业务合作伙伴。他说，GitHub 提供了某种应急迁移流程，fork 不活动的代码库也是其中的一个选项。他还指出，如果 GitHub 可以接管项目的规范资源，则它有可能重新定位。</p> \n<p>目前该项目还处于无人维护的装填，但项目的一位贡献者 slowcheetah 表示他可以有一些时间来修复关键错误和重大更新，并且显示他具备「合作者」的权限。</p> \n<h2>永远在求职的开源大佬</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFwju\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>项目这么受欢迎，尤其还是一个人独立维护，Pushkarev 绝对称得上 GitHub 大佬了。但这位大佬的 GitHub 个人主页的状态仍然是“Looking for a good job.”</p> \n<p>并且，早在去年 5 月发生车祸之后，他还曾提出通过在库中加入广告从而增加收入，因为他觉得自己需要额外的收入来支付车祸相关的法律和医疗费用。</p> \n<blockquote> \n <strong>参考链接：</strong>\n <p><a href=\"https://www.theregister.co.uk/2020/03/26/corejs_maintainer_jailed_code_release/\" rel=\"nofollow noreferrer\">https://www.theregister.co.uk...</a></p> \n <p>丹尼斯·普什卡列夫（Denis Pushkarev）个人网站： <a href=\"https://vk.com/xrock\" rel=\"nofollow noreferrer\">https://vk.com/xrock</a></p> \n <p>《What happens when the maintainer of a JS library downloaded 26m times<br>a week goes to prison for killing someone with a motorbike? Core-js<br>just found out》<br><a href=\"https://www.theregister.co.uk/2020/03/26/corejs_maintainer_jailed_code_release/\" rel=\"nofollow noreferrer\">https://www.theregister.co.uk...</a></p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sf.png\" title=\"sf.png\"></span></p>', 'https://segmentfault.com/img/bVbFwal', '5ca4567d892841b087fac5246effac40', 'f7e58b2632604a99bbb8f9471c0675ad,634b81d655c74cb0adc4d0aa362b8819', '0', '3', '1', '2020-04-16 16:47:19', '2020-04-16 16:47:19');
INSERT INTO `tb_recommend` VALUES ('2b02a11102e44abc84094e4feb7400a4', 'Redis快速入门，学会这15点，真的够用了！', '     REmote DIctionary Server(Redis)是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可基于内存亦可持久化的日志型、Key-Value数据库，并...', '<p><strong>1、Redis简介</strong></p> \n<p><strong>&nbsp; &nbsp; &nbsp;REmote DIctionary Server(Redis)</strong>是一个由Salvatore Sanfilippo写的key-value存储系统。Redis是一个开源的使用ANSI C语言编写、遵守BSD协议、支持网络、可<strong>基于内存</strong>亦<strong>可持久化</strong>的日志型、<strong>Key-Value</strong>数据库，并提供<strong>多种语言的A</strong>PI。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Map), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p> \n<p><strong>大家都知道了redis是基于<strong><em><em>key-value的no sql数据库</em></em></strong>，因此，先来了解一下关于key相关的知识点</strong></p> \n<blockquote>\n 1、任何\n <strong>二进制的序列</strong>都可以作为key使用 \n <br>2、Redis有\n <strong>统一的规则</strong>来设计key \n <br>3、对key-value允许的\n <strong>最大长度是512MB</strong> \n</blockquote> \n<p><strong>2、支持的语言</strong></p> \n<pre><code>ActionScript Bash &nbsp;C &nbsp;C# &nbsp;C++ &nbsp;Clojure Common LispCrystal &nbsp;D &nbsp;Dart &nbsp;Elixir &nbsp;emacs &nbsp;lisp &nbsp;Erlang &nbsp;Fancy &nbsp;gawk &nbsp;GNU Prolog &nbsp;Go &nbsp;Haskell &nbsp;Haxe &nbsp;Io Java &nbsp;Javascript &nbsp;Julia &nbsp;Lua &nbsp;Matlab &nbsp;mruby &nbsp;Nim &nbsp;Node.js &nbsp;Objective-C &nbsp;OCaml Pascal &nbsp;Perl &nbsp;PHP &nbsp;Pure Data &nbsp;Python &nbsp;R &nbsp;Racket &nbsp;Rebol &nbsp;Ruby &nbsp;Rust Scala &nbsp;Scheme &nbsp;Smalltalk &nbsp;Swift &nbsp;Tcl &nbsp;VB &nbsp;VCL</code></pre> \n<p><strong>3、Redis的应用场景到底有哪些？？</strong></p> \n<blockquote>\n 1、最常用的就是\n <strong>会话缓存</strong> \n <br>2、\n <strong>消息队列</strong>，比如支付 \n <br>3、活动\n <strong>排行榜或计数</strong> \n <br>4、\n <strong>发布、订阅</strong>消息(消息通知) \n <br>5、\n <strong>商品列表、评论列表</strong>等\n</blockquote> \n<p><strong>4、Redis安装</strong></p> \n<p><strong>关于redis安装与相关的知识点介绍请参考&nbsp;</strong><a href=\"http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;mid=2247485429&amp;idx=1&amp;sn=a20b8d23aa47efc52ec48ef43c32aea5&amp;chksm=e91b62e9de6cebfff3ebfa2ec84c6e8163c14bf98fba1250261a2a960fe3983ec780fe9dd082&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\"><strong>Nosql数据库服务之redis</strong></a></p> \n<p><strong>安装的大概步骤如下：</strong></p> \n<p>Redis是c语言开发的，安装redis需要c语言的编译环境</p> \n<p>如果没有gcc需要在线安装：yum install gcc-c++</p> \n<blockquote>\n 第一步：获取源码包：wget \n <a href=\"http://download.redis.io/releases/redis-3.0.0.tar.gz\" rel=\"nofollow noreferrer\">http://download.redis.io/rele...</a>\n <p>第二步：解压缩redis：tar zxvf redis-3.0.0.tar.gz</p> \n <p>第三步：编译。进入redis源码目录(cd redis-3.0.0)。执行 make</p> \n <p>第四步：安装。make install PREFIX=/usr/local/redis</p> \n <p>PREFIX参数指定redis的安装目录</p> \n</blockquote> \n<p><strong>5、Redis数据类型</strong></p> \n<p>Redis一共<strong>支持五种</strong>数据类型</p> \n<blockquote>\n 1、\n <strong>string</strong>(字符串) \n <br>2、\n <strong>hash</strong>(哈希) \n <br>3、\n <strong>list</strong>(列表) \n <br>4、\n <strong>set</strong>(集合) \n <br>5、\n <strong>zset</strong>（sorted set 有序集合）\n</blockquote> \n<p><strong>string(字符串)</strong> <br>它是redis最基本的数据类型，<strong>一个key对应一个value</strong>，需要注意是一个键值最大存储512MB。</p> \n<pre><code>127.0.0.1:6379&gt; set key \"hello world\"\nOK\n127.0.0.1:6379&gt; get key\n\"hello world\"\n127.0.0.1:6379&gt; getset key \"nihao\"\n\"hello world\"\n127.0.0.1:6379&gt; mset key1 \"hi\" key2 \"nihao\" key3 \"hello\"\nOK\n127.0.0.1:6379&gt; get key1\n\"hi\"\n127.0.0.1:6379&gt; get key2\n\"nihao\"\n127.0.0.1:6379&gt; get key3\n\"hello\"</code></pre> \n<blockquote> \n <strong>相关命令介绍</strong> \n <br>set 为一个Key设置value（值） \n <br>get 获得某个key对应的value（值） \n <br>getset 为一个Key设置value（值）并返回对应的值 \n <br>mset 为多个key设置value（值）\n</blockquote> \n<p><strong>hash(哈希)</strong> <br>redis hash是一个<strong>键值对的集合</strong>， 是一个string类型的<strong>field和value的映射表</strong>，适合用于存储对象</p> \n<pre><code>127.0.0.1:6379&gt; hset redishash 1 \"001\"\n(integer) 1\n127.0.0.1:6379&gt; hget redishash 1\n\"001\"\n127.0.0.1:6379&gt; hmset redishash 1 \"001\" 2 \"002\"\nOK\n127.0.0.1:6379&gt; hget redishash 1\n\"001\"\n127.0.0.1:6379&gt; hget redishash 2\n\"002\"\n127.0.0.1:6379&gt; hmget redishash 1 2\n1) \"001\"\n2) \"002\"</code></pre> \n<blockquote> \n <strong>相关命令介绍</strong> \n <br>hset 将Key对应的hash中的field配置为value，如果hash不存则自动创建， \n <br>hget 获得某个hash中的field配置的值 \n <br>hmset 批量配置同一个hash中的多个field值 \n <br>hmget 批量获得同一个hash中的多个field值\n</blockquote> \n<p><strong>list(列表)</strong> <br>是redis简单的<strong>字符串列表</strong>，它按插入顺序排序</p> \n<pre><code>127.0.0.1:6379&gt; lpush word &nbsp;hi\n(integer) 1\n127.0.0.1:6379&gt; lpush word &nbsp;hello\n(integer) 2\n127.0.0.1:6379&gt; rpush word &nbsp;world\n(integer) 3\n127.0.0.1:6379&gt; lrange word 0 2\n1) \"hello\"\n2) \"hi\"\n3) \"world\"\n127.0.0.1:6379&gt; llen word\n(integer) 3</code></pre> \n<blockquote> \n <strong>相关命令介绍</strong> \n <br>lpush 向指定的列表左侧插入元素，返回插入后列表的长度 \n <br>rpush 向指定的列表右侧插入元素，返回插入后列表的长度 \n <br>llen &nbsp;返回指定列表的长度 \n <br>lrange 返回指定列表中指定范围的元素值\n</blockquote> \n<p><strong>set(集合)</strong> <br>是string类型的<strong>无序集合</strong>，也<strong>不可重复</strong></p> \n<pre><code>127.0.0.1:6379&gt; sadd redis redisset\n(integer) 1\n127.0.0.1:6379&gt; sadd redis redisset1\n(integer) 1\n127.0.0.1:6379&gt; sadd redis redisset2\n(integer) 1\n127.0.0.1:6379&gt; smembers redis\n1) \"redisset1\"\n2) \"redisset\"\n3) \"redisset2\"\n127.0.0.1:6379&gt; sadd redis redisset2\n(integer) 0\n127.0.0.1:6379&gt; smembers redis\n1) \"redisset1\"\n2) \"redisset\"\n3) \"redisset2\"\n127.0.0.1:6379&gt; smembers redis\n1) \"redisset1\"\n2) \"redisset3\"\n3) \"redisset\"\n4) \"redisset2\"\n127.0.0.1:6379&gt; srem redis redisset\n(integer) 1\n127.0.0.1:6379&gt; smembers redis\n1) \"redisset1\"\n2) \"redisset3\"\n3) \"redisset2\"</code></pre> \n<blockquote> \n <strong>相关命令介绍</strong> \n <br>sadd 添加一个string元素到key对应的set集合中，成功返回1，如果元素存在返回0 \n <br>smembers 返回指定的集合中所有的元素 \n <br>srem 删除指定集合的某个元素\n</blockquote> \n<p><strong>zset（sorted set 有序集合）</strong> <br>是string类型的<strong>有序集合，也不可重复</strong> <br>sorted set中的每个元素都需要指定一个分数，根据分数对元素进行升序排序，如果多个元素有相同的分数，则以字典序进行升序排序，sorted set 因此非常适合实现排名</p> \n<pre><code>127.0.0.1:6379&gt; zadd nosql 0 001\n(integer) 1\n127.0.0.1:6379&gt; zadd nosql 0 002\n(integer) 1\n127.0.0.1:6379&gt; zadd nosql 0 003\n(integer) 1\n127.0.0.1:6379&gt; zcount nosql 0 0 \n(integer) 3\n127.0.0.1:6379&gt; zcount nosql 0 3\n(integer) 3\n127.0.0.1:6379&gt; zrem nosql 002\n(integer) 1\n127.0.0.1:6379&gt; zcount nosql 0 3\n(integer) 2\n127.0.0.1:6379&gt; zscore nosql 003\n\"0\"\n127.0.0.1:6379&gt; zrangebyscore nosql 0 10\n1) \"001\"\n2) \"003\"\n127.0.0.1:6379&gt; zadd nosql 1 003\n(integer) 0\n127.0.0.1:6379&gt; zadd nosql 1 004\n(integer) 1\n127.0.0.1:6379&gt; zrangebyscore nosql 0 10\n1) \"001\"\n2) \"003\"\n3) \"004\"\n127.0.0.1:6379&gt; zadd nosql 3 005\n(integer) 1\n127.0.0.1:6379&gt; zadd nosql 2 006\n(integer) 1\n127.0.0.1:6379&gt; zrangebyscore nosql 0 10\n1) \"001\"\n2) \"003\"\n3) \"004\"\n4) \"006\"\n5) \"005\"</code></pre> \n<blockquote> \n <strong>相关命令介绍</strong> \n <br>zadd &nbsp;向指定的sorteset中添加1个或多个元素 \n <br>zrem &nbsp;从指定的sorteset中删除1个或多个元素 \n <br>zcount 查看指定的sorteset中指定分数范围内的元素数量 \n <br>zscore 查看指定的sorteset中指定分数的元素 \n <br>zrangebyscore 查看指定的sorteset中指定分数范围内的所有元素\n</blockquote> \n<p><strong>6、键值相关的命令</strong></p> \n<pre><code>127.0.0.1:6379&gt; exists key\n(integer) 1\n127.0.0.1:6379&gt; exists key1\n(integer) 1\n127.0.0.1:6379&gt; exists key100\n(integer) 0\n127.0.0.1:6379&gt; get key\n\"nihao,hello\"\n127.0.0.1:6379&gt; get key1\n\"hi\"\n127.0.0.1:6379&gt; del key1\n(integer) 1\n127.0.0.1:6379&gt; get key1\n(nil)\n127.0.0.1:6379&gt; rename key key0\nOK\n127.0.0.1:6379&gt; get key(nil)\n127.0.0.1:6379&gt; get key0\n\"nihao,hello\"\n127.0.0.1:6379&gt; type key0\nstring</code></pre> \n<blockquote>\n exists&nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#确认key是否存在</strong> \n <br>del&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#删除key</strong> \n <br>expire&nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#设置Key过期时间(单位秒)</strong> \n <br>persist&nbsp; &nbsp; &nbsp;\n <strong>#移除Key过期时间的配置</strong> \n <br>rename&nbsp; &nbsp; &nbsp;\n <strong>#重命名key</strong> \n <br>type&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#返回值的类型</strong> \n</blockquote> \n<p><strong>7、Redis服务相关的命令</strong></p> \n<pre><code>127.0.0.1:6379&gt; select 0\nOK\n127.0.0.1:6379&gt; info\n# Server\nredis_version:3.0.6\nredis_git_sha1:00000000\nredis_git_dirty:0\nredis_build_id:347e3eeef5029f3\nredis_mode:standalone\nos:Linux 3.10.0-693.el7.x86_64 x86_64\narch_bits:64\nmultiplexing_api:epoll\ngcc_version:4.8.5\nprocess_id:31197\nrun_id:8b6ec6ad5035f5df0b94454e199511084ac6fb12\ntcp_port:6379\nuptime_in_seconds:8514\nuptime_in_days:0\nhz:10\nlru_clock:14015928\nconfig_file:/usr/local/redis/redis.conf\n-------------------省略N行\n127.0.0.1:6379&gt; CONFIG GET 0\n(empty list or set)\n127.0.0.1:6379&gt; CONFIG GET 15\n(empty list or set)</code></pre> \n<blockquote>\n slect&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#选择数据库(数据库编号0-15)</strong> \n <br>quit&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#退出连接</strong> \n <br>info&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#获得服务的信息与统计</strong> \n <br>monitor&nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#实时监控</strong> \n <br>config get&nbsp; &nbsp;\n <strong>#获得服务配置</strong> \n <br>flushdb&nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#删除当前选择的数据库中的key</strong> \n <br>flushall&nbsp; &nbsp; &nbsp; &nbsp;\n <strong>#删除所有数据库中的key</strong> \n</blockquote> \n<p><strong>8、Redis的发布与订阅</strong></p> \n<p>Redis发布与订阅(pub/sub)是它的一种消息通信模式，一方发送信息，一方接收信息。 <br><strong>下图是三个客户端同时订阅同一个频道</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022353598\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>下图是有新信息发送给频道1时，就会将消息发送给订阅它的三个客户端</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022353597\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>9、Redis事务</strong></p> \n<p>Redis事务可以一次执行多条命令</p> \n<blockquote>\n 1、发送exec命令前放入队列缓存，结束事务 \n <br>2、收到exec命令后执行事务操作，如果某一命令执行失败，其它命令仍可继续执行 \n <br>3、一个事务执行的过程中，其它客户端提交的请求不会被插入到事务执行的命令列表中\n</blockquote> \n<p><strong>一个事务经历三个阶段</strong> <br>&nbsp; 开始事务(命令:multi) <br>&nbsp; 命令执行 <br>&nbsp; 结束事务(命令:exec)</p> \n<pre><code>127.0.0.1:6379&gt; MULTI\nOK\n127.0.0.1:6379&gt; set key key1\nQUEUED\n127.0.0.1:6379&gt; get key\nQUEUED\n127.0.0.1:6379&gt; rename key key001\nQUEUED\n127.0.0.1:6379&gt; exec\n1) OK\n2) \"key1\"\n3) OK</code></pre> \n<p><strong>10、Redis安全配置</strong></p> \n<p>可以通过修改配置文件设备密码参数来提高安全性</p> \n<p><strong>&nbsp;#requirepass foobared</strong></p> \n<p>去掉注释#号就可以配置密码 <br><strong>没有配置密码的情况下查询如下</strong></p> \n<pre><code>127.0.0.1:6379&gt; CONFIG GET requirepass\n1) \"requirepass\"\n2) \"\"</code></pre> \n<p><strong>配置密码之后，就需要进行认证</strong></p> \n<pre><code>127.0.0.1:6379&gt; CONFIG GET requirepass\n(error) NOAUTH Authentication required.\n127.0.0.1:6379&gt; AUTH foobared \n#认证OK\n127.0.0.1:6379&gt; CONFIG GET requirepass\n1) \"requirepass\"\n2) \"foobared\"</code></pre> \n<p><strong>11、Redis持久化</strong></p> \n<p><strong>Redis持久有两种方式:Snapshotting(快照),Append-only file(AOF)</strong></p> \n<p><strong>Snapshotting(快照)</strong></p> \n<blockquote>\n 1、将存储在内存的数据以快照的方式写入二进制文件中，如默认dump.rdb中 \n <br>2、save 900 1&nbsp;\n <p><strong>#900秒内如果超过1个Key被修改，则启动快照保存</strong> <br>3、save 300 10&nbsp;</p> \n <p><strong>#300秒内如果超过10个Key被修改，则启动快照保存</strong> <br>4、save 60 10000&nbsp;</p> \n <p><strong>#60秒内如果超过10000个Key被修改，则启动快照保存</strong></p> \n</blockquote> \n<p><strong>Append-only file(AOF)</strong></p> \n<blockquote>\n 1、使用AOF持久时，服务会将每个收到的写命令通过write函数追加到文件中（appendonly.aof） \n <br>2、AOF持久化存储方式参数说明 \n <br>&nbsp; &nbsp;appendonly yes &nbsp;\n <p><strong>#开启AOF持久化存储方式</strong> <br>&nbsp; &nbsp; appendfsync always&nbsp;</p> \n <p><strong>#收到写命令后就立即写入磁盘，效率最差，效果最好</strong> <br>&nbsp; &nbsp; appendfsync everysec</p> \n <p><strong>&nbsp;#每秒写入磁盘一次，效率与效果居中</strong> <br>&nbsp; &nbsp; appendfsync no&nbsp;</p> \n <p><strong>#完全依赖OS，效率最佳，效果没法保证</strong></p> \n</blockquote> \n<p><strong>12、Redis 性能测试</strong></p> \n<p><strong>自带相关测试工具</strong></p> \n<pre><code>[root@test ~]# redis-benchmark --help\n\nUsage: redis-benchmark [-h &lt;host&gt;] [-p &lt;port&gt;] [-c &lt;clients&gt;] [-n &lt;requests]&gt; [-k &lt;boolean&gt;] \n\n-h &lt;hostname&gt; &nbsp; &nbsp; &nbsp;Server hostname (default 127.0.0.1) \n-p &lt;port&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Server port (default 6379) \n-s &lt;socket&gt; &nbsp; &nbsp; &nbsp; &nbsp;Server socket (overrides host and port) -a &lt;password&gt; &nbsp; &nbsp; &nbsp;Password for Redis Auth \n-c &lt;clients&gt; &nbsp; &nbsp; &nbsp; Number of parallel connections (default 50) \n-n &lt;requests&gt; &nbsp; &nbsp; &nbsp;Total number of requests (default 100000) \n-d &lt;size&gt; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Data size of SET/GET value in bytes (default 2) \n-dbnum &lt;db&gt; &nbsp; &nbsp; &nbsp; &nbsp;SELECT the specified db number (default 0) \n-k &lt;boolean&gt; &nbsp; &nbsp; &nbsp; 1=keep alive 0=reconnect (default 1) \n-r &lt;keyspacelen&gt; &nbsp; Use random keys for SET/GET/INCR, random values for SADD &nbsp;Using this option the benchmark will expand the string __rand_int__ &nbsp;inside an argument with a 12 digits number in the specified range &nbsp;from 0 to keyspacelen-1. The substitution changes every time a command &nbsp;is executed. Default tests use this to hit random keys in the &nbsp;specified range. \n-P &lt;numreq&gt; &nbsp; &nbsp; &nbsp; &nbsp;Pipeline &lt;numreq&gt; requests. Default 1 (no pipeline). \n-q &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Quiet. Just show query/sec values --csv &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;Output in CSV format \n-l &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Loop. Run the tests forever \n-t &lt;tests&gt; &nbsp; &nbsp; &nbsp; &nbsp; Only run the comma separated list of tests. The test &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;names are the same as the ones produced as output. \n-I &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; Idle mode. Just open N idle connections and wait.\n\nExamples: \n\nRun the benchmark with the default configuration against 127.0.0.1:6379: &nbsp; \n$ redis-benchmark\n\nUse 20 parallel clients, for a total of 100k requests, against 192.168.1.1: &nbsp; \n$ redis-benchmark -h 192.168.1.1 -p 6379 -n 100000 -c 20 \n\nFill 127.0.0.1:6379 with about 1 million keys only using the SET test: &nbsp; \n$ redis-benchmark -t set -n 1000000 -r 100000000 \n\nBenchmark 127.0.0.1:6379 for a few commands producing CSV output: &nbsp; \n$ redis-benchmark -t ping,set,get -n 100000 --csv \n\nBenchmark a specific command line: &nbsp; \n$ redis-benchmark -r 10000 -n 10000 eval \'return redis.call(\"ping\")\' 0 \n\nFill a list with 10000 random elements: &nbsp; \n$ redis-benchmark -r 10000 -n 10000 lpush mylist __rand_int__ \n\nOn user specified command lines __rand_int__ is replaced with a random integer with a range of values selected by the -r option.</code></pre> \n<p><strong>实际测试同时执行100万的请求</strong></p> \n<pre><code>[root@test ~]# redis-benchmark -n 1000000 -q\nPING_INLINE: 152578.58 requests per second\nPING_BULK: 150308.14 requests per second\nSET: 143266.47 requests per second\nGET: 148632.58 requests per second\nINCR: 145857.64 requests per second\nLPUSH: 143781.45 requests per second\nLPOP: 147819.66 requests per second\nSADD: 138350.86 requests per second\nSPOP: 134282.27 requests per second\nLPUSH (needed to benchmark LRANGE): 141302.81 requests per second\nLRANGE_100 (first 100 elements): 146756.67 requests per second\nLRANGE_300 (first 300 elements): 148104.27 requests per second\nLRANGE_500 (first 450 elements): 152671.75 requests per second\nLRANGE_600 (first 600 elements): 148104.27 requests per second\nMSET (10 keys): 132731.62 requests per second</code></pre> \n<p><strong>13、Redis的备份与恢复</strong></p> \n<p><strong>Redis自动备份有两种方式</strong> <br>第一种是通过dump.rdb文件实现备份 <br>第二种使用aof文件实现自动备份</p> \n<p><strong>dump.rdb备份</strong> <br>Redis服务默认的自动文件备份方式(AOF没有开启的情况下)，在服务启动时，就会自动从dump.rdb文件中去加载数据。 <br>**具体配置在redis.conf <br>save 900 1 <br>save 300 10 <br>save 60 10000** <br>也可以手工执行save命令实现手动备份</p> \n<pre><code>127.0.0.1:6379&gt; set name key\nOK\n127.0.0.1:6379&gt; SAVE\nOK\n127.0.0.1:6379&gt; set name key1\nOK\n127.0.0.1:6379&gt; BGSAVE\nBackground saving started</code></pre> \n<p>redis快照到dump文件时，会自动生成dump.rdb的文件</p> \n<pre><code># The filename where to dump the DB\ndbfilename dump.rdb\n-rw-r--r-- 1 root root &nbsp; 253 Apr 17 20:17 dump.rdb</code></pre> \n<p><strong>SAVE命令</strong>表示使<strong>用主进程</strong>将当前数据库快照到dump文件 <br><strong>BGSAVE命令</strong>表示，主进程会<strong>fork一个子进程</strong>来进行快照备份 <br>两种备份不同之处，前者会阻塞主进程，后者不会。</p> \n<p><strong>恢复举例</strong></p> \n<pre><code># Note that you must specify a directory here, not a file name.dir \n/usr/local/redisdata/\n#备份文件存储路径\n127.0.0.1:6379&gt; CONFIG GET dir\n1) \"dir\"\n2) \"/usr/local/redisdata\"\n127.0.0.1:6379&gt; set key 001\nOK\n127.0.0.1:6379&gt; set key1 002\nOK\n127.0.0.1:6379&gt; set key2 003\nOK\n127.0.0.1:6379&gt; save\nOK</code></pre> \n<p><strong>将备份文件备份到其它目录</strong></p> \n<pre><code>[root@test ~]# ll /usr/local/redisdata/\ntotal 4\n-rw-r--r-- 1 root root 49 Apr 17 21:24 dump.rdb\n\n[root@test ~]# date\nTue Apr 17 21:25:38 CST 2018\n[root@test ~]# cp ./dump.rdb /tmp/</code></pre> \n<p><strong>删除数据</strong></p> \n<pre><code>127.0.0.1:6379&gt; del key1\n(integer) 1\n127.0.0.1:6379&gt; get key1\n(nil)</code></pre> \n<p><strong>关闭服务，将原备份文件拷贝回save备份目录</strong></p> \n<pre><code>[root@test ~]# redis-cli -a foobared shutdown\n[root@test ~]# lsof -i :6379\n[root@test ~]# cp /tmp/dump.rdb /usr/local/redisdata/\ncp: overwrite ‘/usr/local/redisdata/dump.rdb’? y\n[root@test ~]# redis-server /usr/local/redis/redis.conf &amp;\n[1] 31487</code></pre> \n<p><strong>登录查看数据是否恢复</strong></p> \n<pre><code>[root@test ~]# redis-cli -a foobared\n127.0.0.1:6379&gt; mget key key1 key2\n1) \"001\"\n2) \"002\"\n3) \"003\"</code></pre> \n<p><strong>AOF自动备份</strong> <br>redis服务默认是关闭此项配置</p> \n<pre><code>###### APPEND ONLY MODE ##########\nappendonly no\n\n# The name of the append only file (default: \"appendonly.aof\")\nappendfilename \"appendonly.aof\"\n\n# appendfsync always\nappendfsync everysec\n\n# appendfsync no</code></pre> \n<p>配置文件的相关参数，前面已经详细介绍过。 <br>AOF文件备份，是备份所有的历史记录以及执行过的命令，和mysql binlog很相似，在恢复时就是重新执次一次之前执行的命令，需要注意的就是在恢复之前，和数据库恢复一样需要手工删除执行过的del或误操作的命令。</p> \n<blockquote> \n <strong>AOF与dump备份不同</strong> \n <br>1、aof文件备份与dump文件备份不同 \n <br>2、服务读取文件的优先顺序不同，会按照以下优先级进行启动 \n <br>&nbsp; &nbsp;如果只配置AOF,重启时加载AOF文件恢复数据 \n <br>&nbsp; &nbsp; 如果同时 配置了RBD和AOF,启动是只加载AOF文件恢复数据 \n <br>&nbsp; &nbsp; 如果只配置RBD,启动时将加载dump文件恢复数据\n</blockquote> \n<p><strong>注意：只要配置了aof，但是没有aof文件，这个时候启动的数据库会是空的</strong></p> \n<p><strong>14、Redis 生产优化介绍</strong></p> \n<p><strong>1、内存管理优化</strong>&nbsp;</p> \n<pre><code>hash-max-ziplist-entries 512  \n&nbsp;hash-max-ziplist-value 64  \n&nbsp;list-max-ziplist-entries 512  \n&nbsp;list-max-ziplist-value 64\n&nbsp;#list的成员与值都不太大的时候会采用紧凑格式来存储，相对内存开销也较小</code></pre> \n<blockquote> \n <strong>在linux环境运行Redis时，如果系统的内存比较小，这个时候自动备份会有可能失败，需要修改系统的vm.overcommit_memory 参数，这个参数是linux系统的内存分配策略</strong> \n <br>&nbsp; &nbsp;0 表示内核将检查是否有足够的可用内存供应用进程使用；如果有足够的可用内存，内存申请允许；否则，内存申请失败，并把错误返回给应用进程。 \n <br>&nbsp; &nbsp; 1 表示内核允许分配所有的物理内存，而不管当前的内存状态如何。 \n <br>&nbsp; &nbsp; 2 表示内核允许分配超过所有物理内存和交换空间总和的内存 \n <br>&nbsp;\n <strong>Redis官方的说明是，建议将vm.overcommit_memory的值修改为1，可以用下面几种方式进行修改：</strong> \n <br>（1）编辑/etc/sysctl.conf 改vm.overcommit_memory=1，然后sysctl -p 使配置文件生效 \n <br>（2）sysctl vm.overcommit_memory=1 \n <br>&nbsp;（3）echo 1 &gt; /proc/sys/vm/overcommit_memory\n</blockquote> \n<p>**2、内存预分配 <br>3、持久化机制** <br>&nbsp; &nbsp;定时快照：效率不高，会丢失数据 <br>&nbsp; &nbsp; AOF：保持数据完整性（一个实例的数量不要太大2G最大）</p> \n<blockquote> \n <strong>优化总结</strong> \n <br>1）根据业务需要选择合适的数据类型 \n <br>2）当业务场景不需持久化时就关闭所有持久化方式（采用ssd磁盘来提升效率） \n <br>3）不要使用虚拟内存的方式，每秒实时写入AOF \n <br>4）不要让REDIS所在的服务器物理内存使用超过内存总量的3/5 \n <br>5）要使用maxmemory \n <br>6）大数据量按业务分开使用多个redis实例\n</blockquote> \n<p><strong>15、Redis集群应用</strong></p> \n<p>集群是将<strong>多个redis实例集中在一起</strong>，实现同一业务需求，或者<strong>实现高可用与负载均衡</strong></p> \n<p><strong>到底有哪些集群方案呢？？</strong> <br><strong>1、haproxy+keepalived+redis集群</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022353599\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>1）通过redis的配置文件，实现主从复制、读写分离 <br>2）通过haproxy的配置，实现负载均衡，当从故障时也会及时从集群中T除 <br>3）利用keepalived来实现负载的高可用</p> \n<p><strong>2、redis官方Sentinel集群管理工具</strong></p> \n<p><a href=\"http://mp.weixin.qq.com/s?__biz=MzI0MDQ4MTM5NQ==&amp;mid=2247484546&amp;idx=1&amp;sn=d2afa23bad2bf25a4f551bfebba3d65f&amp;chksm=e91b619ede6ce8888c3089ab458d9d153e9684511dd7d63a0e9369be763782b97ea5efb3dd56&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\"><strong>Redis集群生产环境高可用方案实战过程</strong></a> </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022353600\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>1）sentinel负责对集群中的主从服务监控、提醒和自动故障转移 <br>2）redis集群负责对外提供服务 <br>关于redis sentinel cluster集群配置可参考</p> \n<p><strong>3、Redis Cluster</strong> <br>Redis Cluster是Redis的分布式解决方案，在Redis 3.0版本正式推出的，有效解决了Redis分布式方面的需求。当遇到单机内存、并发、流量等瓶颈时，可以采用Cluster架构达到负载均衡的目的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022353601\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>1）官方推荐，毋庸置疑。 <br>2）去中心化，集群最大可增加1000个节点，性能随节点增加而线性扩展。 <br>3）管理方便，后续可自行增加或摘除节点，移动分槽等等。 <br>4）简单，易上手。</p>', 'https://segmentfault.com/img/remote/1460000022353598', '3f69fcc9b13843d1910b3dac597f5215', '55723db96b9f4593bae02bc1e49f1e87,90ebd6b2270249dc8580eb97aa14aa02,d7416e100af54eb7a4d9274b9a462240,753b5aee3913424e81fe2b5299626d8c,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_recommend` VALUES ('2d1bf6547e13411ba6622ef3510f5b84', 'Python制作的一些小游戏', 'python制作的一些小游戏，供新手练习使用，源代码都在这(欢迎随手给个stars)：[链接]包括： 坦克大战 塔防游戏 推箱子 滑雪游戏 俄罗斯方块 拼图游戏 乒乓球小游戏 24点 打砖块 Pacman 飞机大战 等等。', '<p>python制作的一些小游戏，供新手练习使用，源代码都在这(欢迎随手给个stars)：<br><a href=\"https://github.com/CharlesPikachu/Games\" rel=\"nofollow noreferrer\">https://github.com/CharlesPikachu/Games</a><br>包括：</p> \n<ul>\n <li>坦克大战</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbBtlI\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"1576255389.jpg\" title=\"1576255389.jpg\"></span></p> \n<ul>\n <li>塔防游戏</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzUOE\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"1572940685(1).jpg\" title=\"1572940685(1).jpg\"></span></p> \n<ul>\n <li>推箱子</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzUPN\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"1572940847.jpg\" title=\"1572940847.jpg\"></span></p> \n<ul> \n <li>滑雪游戏</li> \n <li>俄罗斯方块</li> \n <li>拼图游戏</li> \n <li>乒乓球小游戏</li> \n <li>24点</li> \n <li>打砖块</li> \n <li>Pacman</li> \n <li>飞机大战</li> \n</ul> \n<p>等等。</p>', 'https://segmentfault.com/img/bVbBtlI', '61cdf41d1e5e4f229b76f6a042e254b6', '43145b2d806a4c3e8bb30d20ef04d61b,a4f4fd7a73b84a7298db0174165eeaac,9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-16 16:57:51', '2020-04-16 16:57:51');
INSERT INTO `tb_recommend` VALUES ('2dbb4c0627a541fba07bbf99c6eb6faa', '未来数据库应具备什么核心能力？', '上周六，我们开启了 The Future of Database 系列 的第一期直播，我司 CTO 黄东旭及 Engineering VP 申砾畅聊了“未来的数据库会是什么样？”这个颇具想象力的话题。以下是第一期直播的部分文字&视频回顾 Enjoy ~', '<blockquote>\n 上周六，我们开启了 \n <a href=\"https://mp.weixin.qq.com/s/SiAO0_RcKw2edJj-B8Yu6A\" rel=\"nofollow noreferrer\">The Future of Database 系列</a> 的第一期直播，我司 CTO 黄东旭及 Engineering VP 申砾畅聊了“未来的数据库会是什么样？”这个颇具想象力的话题。\n <p>以下是第一期直播的部分文字&amp;视频回顾 Enjoy ~</p> \n</blockquote> \n<p><strong>视频链接</strong>：<a href=\"https://www.bilibili.com/video/BV1Ji4y1t7io\" rel=\"nofollow noreferrer\">https://www.bilibili.com/vide...</a></p> \n<h2>目前业界数据存储方案存在的问题？</h2> \n<ul> \n <li>受限的 Scale 能力<p>分库分表和一些「伪分库分表」的方案，仍然有天花板，带来了额外的运维和消耗。</p> </li> \n <li>碎片化<p>回想一下最近几年后端的技术栈，有 NoSQL、缓存、Kafka、 离线数据仓库、Hadoop、HBase……<strong>不同的工具可能面对的是某些特定、甚至「狭窄」的场景，为了应对一个复杂的业务，大家必然就要多种技术方案组合来覆盖所有的应用场景。这个过程中自然会产生「数据孤岛」</strong>，打通孤岛的成本也是巨大的，Kafka 最近几年这么火也是正因为存储方案的多样导致的「数据孤岛」的问题正在显现。</p> </li> \n <li>在线业务与分析脱节<p>现在大家构建存储系统的时候，默认会让在线业务与离线业务是分开的， 在线业务用 MySQL、MongoDB 等等，离线业务（或者分析系统）用 Hadoop 做数据分析，好像大家都是理所当然的认为：在线和离线就该这样，泾渭分明。</p> <p><strong>但目前有个趋势，分析的场景的需求越来越「实时」，或者说高时效的数据分析带来的业务价值受到重视</strong>，这就与大家惯性认知产生了本质的冲突：业务需要当日甚至实时的数据分析结果，但后端只能说今天的数据明天才能导出。还有一个问题是，各个部分维护团队也是分开的，当业务发生变化时，很难灵活地调整和适应。</p> </li> \n</ul> \n<p><strong>导致以上这些问题出现的深层共性是：变化永远比计划快</strong>，你永远没法预测未来需要多少机器？业务会膨胀到多大？到底需要多“实时”的数据来做决策？</p> \n<p><strong>有没有可能存在一个应付更多变化、覆盖更多场景的系统</strong>？从前可能是：我的工具箱里装了各种型号的锤子（工具软件），去应对不同场景、形状的钉子，现在可能追求用一个锤子，快速、低成本的解决不同的钉子（问题），<strong>以不变应万变</strong>。</p> \n<h2>Real-Time HTAP 是解药吗？</h2> \n<p>聊到最近几年数据库领域的变化，申砾提到最近两年很多数据库打出了 HTAP 的标签，黄东旭分享了自己对“一个真正的 Real-Time HTAP 数据库”的理解：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392464\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"1-real-time-htap\" title=\"1-real-time-htap\"></span></p> \n<p><strong>那么 Real-Time HTAP 价值在何处？应该在于它是一个简单、灵活的方案——能够将各个系统/团队集中在一个 Real-Time HTAP 系统上，节省成本并灵活应对业务变化。</strong></p> \n<h2>Real-Time HTAP 之后?</h2> \n<p>Real-Time HTAP 可能是当下厂商们能够看得到的努力方向，那么在 Real-Time HTAP 之后的未来是什么呢？</p> \n<p>或许五年之后有以下场景：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392463\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"2-several-scenes\" title=\"2-several-scenes\"></span></p> \n<p>基于这些场景，<strong>未来数据库绕不开的核心能力应该是：智能、弹性调度能力</strong>。</p> \n<p>最近有个新概念是 Serverless，Severless 是伴随云（Cloud）诞生的概念。当然 Severless 不是没有服务器，通俗地说，Serverless 就是会根据你的实际需求情况，调整数据库的形态，例如业务流量峰值的时候快速的采购弹性的计算资源进行扩容，低峰的时候自动的释放多余的资源。所以可以把 Severless 当做智能、弹性调度的落地形式来理解，同时未来的数据库一定是跑在云上的。</p> \n<h2>第二期直播预告</h2> \n<h3>主题</h3> \n<p><strong>会 MySQL 就会大数据 - HTAP 的现在和未来</strong></p> \n<h3>时间</h3> \n<p><strong>4 月 18 日 本周六 20:00</strong></p> \n<h3>主讲人</h3> \n<p>黄东旭，PingCAP 联合创始人兼 CTO</p> \n<p>马晓宇，PingCAP 实时分析产品负责人</p> \n<h3>简介</h3> \n<p>上周我们探讨了未来的数据库会走向何方，并透露了 TiDB 4.0 是一个具备未来数据库雏形的数据库。“Talk is cheap, show me the TiDB 4.0” ，本周我司 CTO 黄东旭&amp;实时分析产品负责人马晓宇将会演示在高写入的 TP 负载下，如何运行大计算量的分析型请求、并且互相没有任何肉眼可见的延迟影响<em>（想象一下吧，你的系统可以一边下订单一边出数据报表）</em>，另外还将展示一下其他的“参考系”在同样语句下的表现哦~</p> \n<h3>参与方式</h3> \n<p>点击【 <a href=\"http://h.qr61.cn/ozn4Ej/qktbOTy\" rel=\"nofollow noreferrer\">这里</a> 】，添加 TiDB Robot 为好友，回复【新特性】进群参与讨论~</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021958757\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p>', 'https://segmentfault.com/img/remote/1460000022392464', '1894b118d35d44cb8fe8009529c4154b', '83f62facb3b943ffa8e46abd1ebc64d9,277530c212aa4407b43c58c657fe8194,278262a4258f4beca20e334398ab06d8,60e459d5028e400894856f94e826804c', '0', '3', '1', '2020-04-16 17:00:12', '2020-04-16 17:00:12');
INSERT INTO `tb_recommend` VALUES ('2e80cd6e3b3a4e5c9230149d69a39284', '事件驱动及其设计模式', '在GUI编程中，事件是非常常见的。比如，用户在界面点击了按钮，就会发送一个“点击”事件，而相应的会有一个处理“点击”事件的事件处理器会来处理该事件。', '<p>在GUI编程中，事件是非常常见的。比如，用户在界面点击了按钮，就会发送一个“点击”事件，而相应的会有一个处理“点击”事件的事件处理器会来处理该事件。</p> \n<p>因此，所谓事件驱动，简单地说就是你点什么按钮（即产生什么事件），电脑执行什么操作（即调用什么函数）。当然事件也不仅限于用户的操作. 事件驱动的核心自然是事件。从事件角度说，事件驱动程序的基本结构是由一个事件收集器、一个事件发送器和一个事件处理器组成。事件收集器专门负责收集所有事件，包括来自用户的（如鼠标、键盘事件等）、来自硬件的（如时钟事件等）和来自软件的（如操作系统、应用程序本身等）。事件发送器负责将收集器收集到的事件分发到目标对象中。事件处理器做具体的事件响应工作，它往往要到实现阶段才完全确定。对于框架的使用者来说，他们唯一能够看到的是事件处理器。这也是他们所关心的内容。</p> \n<h1>事件驱动编程</h1> \n<p>事件驱动编程通常只是用一个执行过程，CPU之间不是并发的，在处理多任务的时候，事件驱动编程是使用协作式处理任务，而不是多线程的抢占式。事件驱动简洁易用，只需要注册感兴趣的事件，在回调中设计逻辑就可以了。在调用的过程中，事件循环器（Event Loop）在等待事件的发生，跟着调用处理器。事件处理器不是抢占式的，处理器一般只有很短的生命周期。</p> \n<h2>事件驱动编程的优势</h2> \n<p>l 在大部分的应用场景中，事件编程优与多线程编程。</p> \n<p>l 相对与多线程编程来讲，事件驱动编程比较容易，复杂度低，是开发者乐于接受的。</p> \n<p>l 大多数的GUI框架，都是使用事件驱动编程了架构的。每一个事件会绑定一个处理器，这些事件通常是点击按钮，选择菜单，等等。处理器r来实现具体的行为逻辑。</p> \n<p>l 事件驱动经常使用在I/O框架中，可以很好的实现I/O复用。很多高性能的I/O框架都是使用事件驱动模型的，例如：Netty、Mina、Node.js。</p> \n<p>l 易于调试。时间依赖只和事件有关系，而不是内部调度。问题容易暴露。</p> \n<h2>事件驱动编程的劣势</h2> \n<p>l 如果处理器占用时间较长，那会阻塞应用程序的响应。</p> \n<p>l 无法通过时间来维护本地状态，因为处理器必须返回。</p> \n<p>l 通常在单CPU环境下，比多线程编程要快，因为没有锁的因素，没有线程切换的损耗。CPU不是并发的，这样的话就不适合用在一些科学计算的应用中。</p> \n<h1>事件循环器（Event Loop）的实现</h1> \n<p>事件循环器（Event Loop）是一个程序结构，用于等待和发送消息和事件。事件驱动编程的代码核心就是事件循环器，在Linux下推荐使用epoll实现，在其它没有epoll 的系统上可以使用kqueue/ports/poll/select实现。</p> \n<p>下图是事件循环器的工作示例图。事件循环器不断接受来自客户端（Client）的请求，事件循环器把请求转交给注册了某类事件的工作线程（Worker）处理。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022048090\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span>&nbsp;</p> \n<p>根据实现的方式不同，在网络编程中基于事件驱动主要有两种设计模式：Reactor和Proactor。</p> \n<h1>Reactor</h1> \n<p>首先来回想一下普通函数调用的机制：</p> \n<p>l&nbsp; 程序调用某函数-&gt;函数执行</p> \n<p>l&nbsp; 程序等待-&gt;函数将结果</p> \n<p>l&nbsp; 控制权返回给程序-&gt;程序继续处理</p> \n<p>和普通函数调用的不同之处在于：应用程序不是主动的调用某个API完成处理，而是恰恰相反，应用程序需要提供相应的接口并注册到Reactor上，如果相应的事件发生，Reactor将主动调用应用程序注册的接口，这些接口又称为“回调函数”。</p> \n<p>用“好莱坞原则”来形容Reactor再合适不过了：不要打电话给我们，我们会打电话通知你。</p> \n<p>举个例子：你去应聘某xx公司，面试结束后。</p> \n<p>l&nbsp; “普通函数调用机制”公司HR比较懒，不会记你的联系方式，那怎么办呢，你只能面试完后自己打电话去问结果；有没有被录取啊，还是被拒了；</p> \n<p>l&nbsp; “Reactor”公司HR就记下了你的联系方式，结果出来后会主动打电话通知你：有没有被录取啊，还是被拒了；你不用自己打电话去问结果，事实上也不能，因为你没有HR的联系方式。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022048091\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>Reactor模式的优点</h2> \n<p>Reactor模式是编写高性能网络服务器的必备技术之一，它具有如下的优点：</p> \n<p>1）响应快，不必为单个同步时间所阻塞，虽然Reactor本身依然是同步的；</p> \n<p>2）编程相对简单，可以最大程度的避免复杂的多线程及同步问题，并且避免了多线程/进程的切换开销；</p> \n<p>3）可扩展性，可以方便的通过增加Reactor实例个数来充分利用CPU资源；</p> \n<p>4）可复用性，Reactor框架本身与具体事件处理逻辑无关，具有很高的复用性；</p> \n<h2>Reactor模式框架</h2> \n<p>使用Reactor模型，必备的几个组件：事件源、Reactor框架、事件多路复用机制和事件处理程序，先来看看Reactor模型的整体框架，接下来再对每个组件做逐一说明。</p> \n<p>1）事件源：Linux上是文件描述符，Windows上就是Socket或者Handle了，这里统一称为“句柄集”；程序在指定的句柄上注册关心的事件，比如I/O事件。</p> \n<p>2）事件多路复用机制：由操作系统提供的I/O多路复用机制，比如select和epoll。程序首先将其关心的句柄（事件源）及其事件注册到多路复用机制上。当有事件到达时，事件多路复用机制会发出通知“在已经注册的句柄集中，一个或多个句柄的事件已经就绪”。程序收到通知后，就可以在非阻塞的情况下对事件进行处理了。</p> \n<p>3） Reactor。是事件管理的接口，内部使用事件多路复用机制注册、注销事件；并运行事件循环，当有事件进入“就绪”状态时，调用注册事件的回调函数处理事件。</p> \n<p>4）事件处理程序。事件处理程序提供了一组接口，每个接口对应了一种类型的事件，供Reactor在相应的事件发生时调用，执行相应的事件处理。通常它会绑定一个有效的句柄。</p> \n<p>使用Reactor模式后，事件控制流是什么样子呢？可以参见下面的序列图。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022048092\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>我们分别以读操作和写操作为例来看看Reactor中的具体步骤：</p> \n<p>1) 应用程序注册读就绪事件和相关联的事件处理器；</p> \n<p>2) 事件分离器等待事件的发生；</p> \n<p>3) 当发生读就绪事件的时候，事件分离器调用第一步注册的事件处理器；</p> \n<p>4) 事件处理器首先执行实际的读取操作，然后根据读取到的内容进行进一步的处理。</p> \n<p>写入操作类似于读取操作，只不过第一步注册的是写就绪事件。</p> \n<h1>Proactor</h1> \n<p>我们来看看Proactor模式中读取操作和写入操作的过程：</p> \n<p>1) 应用程序初始化一个异步读取操作，然后注册相应的事件处理器，此时事件处理器不关注读取就绪事件，而是关注读取完成事件，这是区别于Reactor的关键。</p> \n<p>2) 事件分离器等待读取操作完成事件。</p> \n<p>3) 在事件分离器等待读取操作完成的时候，操作系统调用内核线程完成读取操作（异步I/O都是操作系统负责将数据读写到应用传递进来的缓冲区供应用程序操作），并将读取的内容放入用户传递过来的缓存区中。这也是区别于Reactor的一点。</p> \n<p>4) 事件分离器捕获到读取完成事件后，激活应用程序注册的事件处理器，事件处理器直接从缓存区读取数据，而不需要进行实际的读取操作。</p> \n<p>Proactor中写入操作和读取操作，只不过感兴趣的事件是写入完成事件。</p> \n<p>从上面可以看出，Reactor和Proactor模式的主要区别就是真正的读取和写入操作是有谁来完成的，Reactor中需要应用程序自己读取或者写入数据，而Proactor模式中，应用程序不需要进行实际的读写过程，它只需要从缓存区读取或者写入即可，操作系统会读取缓存区或者写入缓存区到真正的I/O设备。</p> \n<h1>参考引用</h1> \n<p>l&nbsp; 《Netty原理解析与开发实战》</p> \n<p>l&nbsp; 《分布式系统常用技术及案例分析（第二版）》</p>', 'https://segmentfault.com/img/remote/1460000022048090', '1c5851dc916d4e70a60f0c957f548876', '1ca15ce069584c35ad17790f81a05a60,37cf11776ac6429fb9acf87d5c755ab2,34a4fdb41d174683a033a2528f5432fc', '0', '3', '1', '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_recommend` VALUES ('2f5ba40cefe3479a954d886606438921', 'IINA 播放器开发者称其开源项目，屡次被盗用上架并且收费获利', 'IINA，是一个基于 mpv、契合 macOS 设计风格、力求做到最佳用户体验、轻便且功能强大的视频播放器项目。IINA 以 mpv 为播放核心，所以享受到了 mpv 解码和图像方面的所有优点。IINA 使用了 libmpv 的 C API，来提...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022271502\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Feature 1\" title=\"Feature 1\"></span></p> \n<p><a href=\"https://iina.io/\" rel=\"nofollow noreferrer\">IINA</a>，是一个基于 mpv、契合 macOS 设计风格、力求做到最佳用户体验、轻便且功能强大的视频播放器项目。IINA 以 mpv 为播放核心，所以享受到了 mpv 解码和图像方面的所有优点。IINA 使用了 libmpv 的 C API，来提供更加稳定快速的渲染和控制。此外，它使用原始屏幕分辨率渲染，所以比起其他一些播放器画质有显著提高。</p> \n<p>SegmentFault 思否消息：近期 IINA 播放器的开发者发文称，作为一个开源项目，屡次被盗用上架并且收费获利，确实是很无奈的事情，但是有的开发者被发现后主动下架，有的从不回应，现在貌似还有了理直气壮拒不承认的。</p> \n<p>开发者的态度是：作为开源项目，我们无意私藏这些东西，只要遵守许可证，对它进行再发布和出售也无妨；而这位开发者做的是：把所有贡献者的名字抹除掉换成了自己，并试图在这个基础上盈利。这是我无法忍受的。</p> \n<hr> \n<p><strong>针对这个情况，我们也咨询了我们思否合作的律师事务所君合的律师团队，以下是君合团队给出的反馈：</strong></p> \n<p>开源软件是一种开放软件授权使用限制的软件，开源软件的版权持有人通常授予他人自由使用、复制、散布、研究和改进软件的权利，但是其具体授权使用方式需按照相应开源许可证（“开源协议”或“许可证”）执行。一般每一个开源软件都会附有一个许可证，该许可证以格式文本形式的授权许可协议体现，许可证规定了软件使用者的权利和义务，使用者只有同意遵守这个许可证才可合法使用开源软件（或者使用该开源软件即视为同意接受该许可证）。</p> \n<p>我国法律目前对开源软件没有明确的、有针对性的具体规定，但是在法院审判实践中，法院在相关司法判例中引用了一些开源协议（如GPL协议、CC协议等），并认可开源协议在当事人（授权人、被授权人）之间的效力以及对当事人的约束力。</p> \n<p>以GPL协议为例，根据该协议第4条规定，传播未修改的完整源代码需要满足以下条件：（1）显著而适当地在每个副本上发布一个合适的版权声明；（2）附上陈述本协议和任何按照协议第7条加入的非许可的条款的全部、完整的声明；（3）附上全部、完整的免责申明；（4）随程序给所有的接受者（recipients）一份本协议。</p> \n<p>另根据GPL协议（3.0版本）第5条规定，用户可以以源代码的方式传播“基于GPL程序所开发的作品”或从GPL程序中取出一部分，对此部分进行修改而形成修改版，该传播行为必须首先符合第4条的规定（传播未修改的完整源代码的条件），并且符合以下所有条件：（1）作品应包含显著声明，说明用户修改了GPL程序，并指出修改了时间；（2）作品必须包含明确的声明，说明该作品在本协议下发布，并指出任何按照第6款（附加条款）加入的条件；（3）用户应根据本协议授权获取作品副本的使用者使用整个作品，本协议和任何按照第7款（附加条款）加入的条件一起，对整个作品及其所有部分发生法律效力，无论是以何种形式打包的作品；（4）如果作品中有用户界面，则应在界面中显示适当的法律声明；然而如果GPL程序存在用户界面，但该界面没有显示法律声明，则用户由此开发的作品没有必要修改该界面显示。</p> \n<p>因此，如果用户使用开源软件，需遵守开源协议的要求，如果使用者不遵守开源协议，其自由使用开源软件的许可可以被开源软件的著作权人终止，并且，开源软件的著作权人可以主张使用者使用开源软件的行为侵犯其软件著作权。</p> \n<p><strong>各位思否社区的开发者怎么看？欢迎在评论区留言。</strong></p> \n<hr> \n<p>以下是 IINA 播放器的开发者发布的原文：<strong>剽窃别人成果的人一直有，不过今天遇到了格外厉害的</strong></p> \n<p>我是<a href=\"https://github.com/iina/iina\" rel=\"nofollow noreferrer\">IINA</a>的开发者。一直以来 IINA 都面临一个小问题，就是有人用它的代码上架 Mac App Store （ MAS ）。IINA 使用的 GPLv3 许可证和 MAS 的协议是冲突的，这也是 IINA 至今都没有 MAS 版本的原因之一。</p> \n<p>这个问题一直存在。一直以来我的流程是向 MAS 提交 Dispute 。Apple 对这种事情的处理比较懒，会要求对方的开发者和我直接沟通。一小部分开发者可能会主动下架，但大部分都是选择沉默。对方的开发者在提醒两次都不回应的情况下，MAS 会将 App 强制下架，而这整个流程差不多要三个月（也就是对方开发者可以继续销售三个月）。</p> \n<p>这些操作我其实都习惯了（ Notes.app 里都放了一份模板来写 Dispute ）。我毕竟有自己的日常工作，让 Apple 来处理这种事情，虽然慢一点也是最好的选择。不过今天遇到的一位开发者非常厉害。我把他回复的原话复制上来：</p> \n<blockquote>\n 请问我哪里使用了，请告知，谢谢！\n</blockquote> \n<p>这款名叫 MPlayer X Pro 的 App 在港区售价 15 港币，国区应该是 12 元左右。如果你试用一下就会发现，它完全就是 IINA 的复制品。之前见过的复制品有的还会加上一些分享之类的新功能，而这个相比之下显得非常没有诚意。</p> \n<p>当然，仅仅口头上说「用户界面完全一致」也很难作为证据，那我打开稍微看了一下它里面有什么：</p> \n<ul> \n <li>此 App 和 IINA 有完全相同的用户界面，完全相同的 xib 结构。</li> \n <li>反编译后，可以看到绝大部分代码结构都是雷同的。</li> \n <li>此 App 中包含的资源文件，包括文件图标，本地化文件等等和 IINA 中包含的一模一样，SHA 结果相同。</li> \n <li>此 App 包含了没有任何用处的 cli 二进制文件（修改自 iina-cli ）。</li> \n <li>此 App 使用的二进制库和 IINA 使用的完全相同。</li> \n <li>此 App 中的 Translator.json 中有 IINA 所有的翻译者名字和联系方式。这位开发者只把我的联系方式改成了他自己的，连我的名字都留在里面。</li> \n <li>此 App 中包含了 IINA 用于自动更新的公钥文件。噗，你要这个干嘛！</li> \n</ul> \n<p>我实在是吃惊于这位开发者居然能在这样的情况下说出「请问我哪里使用了」这种话来。虽然近期更新缓慢，我们在业余时间也是一直持续开发，IINA 中使用的图标基本上都是我自己画的，现在积累的 20 多种语言的翻译也都是各国译者的努力成果。作为开源项目，我们无意私藏这些东西，只要遵守许可证，对它进行再发布和出售也无妨；而这位开发者做的是：<strong>把所有贡献者的名字抹除掉换成了自己，并试图在这个基础上盈利</strong>。这是我无法忍受的。</p> \n<p>IINA 从 2017 年发布到现在，域名、开发者证书、官网和邮件服务器都是我在出钱（确切地说，0.0.4 的时候短暂地贴了一下支付宝二维码，不过当时没有稳定的下载渠道，买 CDN 很快就用完了）。很多人建议我们开放捐助，不过因为事情太多更新太慢，没有精力也不太好意思（目前打算在插件系统做完后接受捐助，我觉得不会超过几个月；关于捐助的详情到时候会另外写点什么）。</p> \n<p>我相信在 v2 上发帖吐槽并不能解决问题，反而可能还会有人本来没这想法，现在看了也想试试了（不）。更多的是让自己心情好一点吧。</p> \n<blockquote> \n <p>最后放一下这位开发者的信息。这些信息都是可以在 MAS 或是这款 App “MPlayer X Pro” 的资源文件中公开查到的。请注意，我并不希望有人滥用这些信息或者用它获取这位开发者的其他隐私，而是希望如果有人认识这位开发者或者与其有合作，可以考虑敬而远之。</p> \n <ul> \n  <li>邮箱：13728063720@139.com</li> \n  <li>姓名：yuanteng li</li> \n  <li>App 中附带的微信二维码（外链）：<a href=\"https://imgur.com/a/Pnx14rq\" rel=\"nofollow noreferrer\">https://imgur.com/a/Pnx14rq</a> </li> \n </ul> \n <p><strong>事件后续</strong>：感谢大家的回复和支持！看到能引起这么多人的关注很开心。 </p> \n <p>今天对方回复说是「离职员工私自上传」，这个的可信度相信大家都自有判断。目前来看可以先等 Apple 处理了。 </p> \n <p>关于 IINA 的上架问题：我们可以考虑给 MAS 单独用一份许可证发布，不过要先征求贡献者的同意。同时，调用了私有 API 的功能（比如 PIP ）都要在 MAS 版本去掉。不过这些一直没有搞的原因还是太忙了……我觉得是需要想一下上架问题了。 </p> \n <p>关于捐助：可能大家也发现近一年 IINA 更新缓慢，如果一直收到捐助却不干活感觉说不过去，大家也不是为了钱才持续维护的。不过捐助（和大更新）几个月内会有的。 </p> \n <p>发帖之后有群友告诉我还有人在淘宝上卖 IINA 的，去搜了一下笑死了</p> \n <p><strong>对方已经下架了。 </strong> </p> \n <p>现在 App Store 上仍然有其他复制品存在，所以我们已经在考虑 MAS 版本的可行性。MAS 版本也不会收费，毕竟这不是个以营利为目标的项目。 </p> \n <p>有网友通过电话邮件微信等方式直接联系了侵权的开发者，谢谢你们的帮助。这虽然非常有效，但只能说是无奈之举，终究不是正确而且万能的做法。侵权的开发者已经在邮件中道歉，我也不想再去追究对方的销售所得等等，更希望把精力用在 MAS 版本的 IINA 上，以杜绝这种问题的持续出现。希望大家不要再通过以上联系方式骚扰对方了。 </p> \n <p>再次感谢大家的声援。</p> \n</blockquote> \n<p>原文链接：<a href=\"https://www.v2ex.com/t/658387\" rel=\"nofollow noreferrer\">https://www.v2ex.com/t/658387</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sf.png\" title=\"sf.png\"></span></p>', 'https://segmentfault.com/img/remote/1460000022271502', '1c5851dc916d4e70a60f0c957f548876', 'f3eb17e6e5664a97af3e9b1fca12b286,81a4561c1c294e0cae32c9fe6b5dc397,1939b672cc5446439db2b7017c7cfa48,6fe04eb419474fd7ad1248f0b1a2a7e6', '0', '3', '1', '2020-04-16 16:47:15', '2020-04-16 16:47:15');
INSERT INTO `tb_recommend` VALUES ('3481d5ba1ef34b0abe9b8537c8fb2a4c', '低级失误恐酿大祸？NASA 向 AWS 迁移数据，忽略了 3000 万美元的成本...', 'NASA 为了节约时间和资源，选择将数据迁移至 AWS，但做预算的时候却忽略了后续数据下载所需要的费用。初步计算，因为 NASA 庞大的数据使用量，这笔钱将高达 3000 万美元/年。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFB8d\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"![图片描述\" title=\"![图片描述\"></span></p> \n<p>谁能想到，可能代表了人类最高智力团体的机构，竟然会犯一个看似明显却又相当致命的错误。</p> \n<p>NASA 为了节约时间和资源，选择将数据迁移至 AWS，但做预算的时候却忽略了后续数据下载所需要的费用。初步计算，因为 NASA 庞大的数据使用量，这笔钱将高达 3000 万美元/年。</p> \n<p>按照国外媒体的评价，这一项决策遗漏，让 NASA 的云战略“pointing at the ground rather than at the heavens.”</p> \n<h2>NASA 的数据上云计划</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFB8b\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>NASA 为了进行相关的科学研究，收集了大量的有关气候和自然地球现象的卫星数据和其他信息，为了管理这些数据，NASA 于 2019 年 7 月 启动了 Earthdata Cloud 项目，致力于将所有的数据上云，存储到分布式存档中心 DAAC（分布式活动存档中心）中。</p> \n<p>目前 NASA 已成立 12 个 DAAC，分布在不同地点（大学，政府机构等）。NASA 的全球水文资源中心分布式活动档案中心（GHRC DAAC）被选为第一个类目，GHRC DAAC 现在与内部部署系统同时在云中运行，数据迁移已接近完成，预计将在 2020 年全面移交。</p> \n<p>去年，NASA 选择了亚马逊云服务（AWS）来托管地球科学和 ESDIS 信息系统的数据。此项计划旨在从与地球观测相关的众多空间任务中收集信息。收集完成后，相应读数将由地球观测系统数据与信息系统（EOSDIS）向各研究机构交付。</p> \n<h2>小失误每年损失 3000 万美元</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFB8B\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>NASA 监察长在今年 3 月发布的审计报告中提到：EOSDIS 并没有在这项云端计划当中正确核算数据在出口端被下载产生的费用。</p> \n<p>“目前，当用户访问 DAAC 并从 DAAC 获取数据时，除了维护当前的基础架构之外，NASA 不会付出额外的成本。但是当用户从 Earthdata Cloud 下载数据或上传数据时，代理机构（而不是用户）都将被收取费用。因此，ESDIS 必须承担 12 个 DAAC 的运营成本以及与云相关的运营成本（包括与数据输出相关的成本）。</p> \n<p>也就是说，NASA 终于意识到了，他们之前忽略的一笔庞大费用。</p> \n<p>此前，NASA 与 AWS 达成了 6500 万美元的交易，而根据统计，NASA 每年在数据下载上要额外支付约 3000 万美元。</p> \n<p>最重要的是，该报告发现该项目的组织者在决定购买云服务之前没有进行充分的咨询，没有遵循 NIST 数据完整性标准，并且在内部审核期间没有适当地试图控制成本，而部分原因是这个团队之前大部分的时间都花在具体的项目当中。</p> \n<p>监管机构对此给出的结论是：“总体而言，如果 NASA 出于成本控制的原因而限制了数据输出量，这将带来潜在的风险，即最终用户无法获得科学数据。”</p> \n<p>对此，监管机构对 NASA 提出了三点建议：</p> \n<ol> \n <li>一旦 NISAR 与 SWOT 投入运行并产生足够的数据，NASA 应进行独立分析，以确定支持云迁移和运营同时保持当前 DAAC 足迹的长期财务可持续性；</li> \n <li>结合适当的机构指导，NASA 应在数据管理计划制定期间，协调 ESDIS 和 OCIO 的早期任务生命周期；</li> \n <li>确保在 DAAC 分类期间考虑所有适用的信息类型，确定影响级别和数据使用的前提，并且适当的将分类程序标准化。</li> \n</ol> \n<h2>坎坷的登月计划</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFB8D\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>NASA 一直致力于让人类在月球定居。在今年最新的研究报告中，NASA 提出了一个基本成型的方案，并且给出了其中的三个关键要素：</p> \n<ol> \n <li>月球地形车（LTV）。机组人员可以使用它来绕月。从本质上讲，这是一辆漫游车，但它没有封闭的座舱，所以宇航员在短途旅行中要穿着全面的防护性舱外活动（EVA）太空服。</li> \n <li>一个可居住的移动平台。它将是一个较大的流动站，被完全容纳并加压，从而可以从航天器着陆点到更远的地方进行更长的行程，一次最多 45 天。</li> \n <li>月球地表栖地。可以在较短的停留时间内充当机组人员的更永久、固定的住所。尽管可居住的机动平台将是地面任务的主要主动住所，但它可以一次容纳多达四名宇航员，而绕月球飞行的 Gateway 空间站将是不从事主动地面探索和科学工作的机组人员的主要行动基地。</li> \n</ol> \n<p>NASA 之前已经公布将在 2024 年将两名宇航员送上月球，一个月前开始的太空人训练班已经从 1.2万个候选人中做完了最终筛选。但因为疫情的影响，此前就已经宣布计划将被推迟，再加上此次的财务问题，估计 NASA 的下次登月真的遥遥无期了...</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFxVM\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFB8d', '1894b118d35d44cb8fe8009529c4154b', 'f831bc1c03f94b4b9e49390a3a354a3e,ba16f5b739f24380990a4ccacfe6f833', '0', '3', '1', '2020-04-16 16:56:36', '2020-04-16 16:56:36');
INSERT INTO `tb_recommend` VALUES ('34b1fc9834dd4b83a0f10f250a9121d5', 'TARS 基金会：构建微服务开源生态', '在 20 世纪 60 至 70 年代，软件开发人员通常在大型机和小型机上使用单体架构进行软件开发，没有一个应用程序能够满足大多数最终用户的需求。垂直行业使用的软件代码量更小，与其他应用程序的接口更简单，而可伸...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEvoE\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"0.jpeg\" title=\"0.jpeg\"></span></p> \n<p>作者丨The Linux Foundation<br>原文丨<a href=\"https://www.linuxfoundation.org/blog/2020/03/the-tars-foundation-the-formation-of-a-microservices-ecosystem/\" rel=\"nofollow noreferrer\">《The TARS Foundation：The Formation of a Microservices Ecosystem》</a></p> \n<h3>导语</h3> \n<p>在 20 世纪 60 至 70 年代，软件开发人员通常在大型机和小型机上使用单体架构进行软件开发，没有一个应用程序能够满足大多数最终用户的需求。垂直行业使用的软件代码量更小，与其他应用程序的接口更简单，而可伸缩性在当时并不是优先考虑的。</p> \n<p>随着互联网的发展，开发人员逐渐将服务层从单体架构中分离出来，逐步产生 RPC 和 C/S 架构。</p> \n<p>但是，当时的架构依旧无法应对不断增长的数据流量，更无法满足大型企业的需求。从 20 世纪 90 年代中期开始，分布式架构开始流行起来，面向服务的架构(SOA)越来越占主导地位。</p> \n<p>在 21 世纪初，微服务开始出现，一系列基于微服务架构的框架涌现，而 TARS 于 2008 年出现。经过 10 年的大规模使用和迭代，TARS 于 2018 年成为 Linux 基金会的项目。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEvoK\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"0.png\" title=\"0.png\"></span><br>图 1. 搜索趋势证明对微服务的兴趣呈指数增长</p> \n<h3>关于 TARS 基金会</h3> \n<p>2020 年 3 月 10 日，Linux 基金会正式宣布，旗下的 TARS 开源项目将成立 TARS 基金会。TARS 基金会是一个专注于微服务领域的开源基金会，致力于构建一个健康并且开放的微服务开源生态。</p> \n<p>视频 1：<br><a href=\"https://youtu.be/NpixKfkt1ds\" rel=\"nofollow noreferrer\">TARS Foundation, established on March 10th 2020</a></p> \n<p>视频 2:<br><a href=\"https://v.qq.com/x/page/w0932r98lfj.html\" rel=\"nofollow noreferrer\">TARS Foundation, established on March 10th 2020</a></p> \n<h3>一个中立的微服务开源基金会</h3> \n<p>TARS 基金会是一个非盈利性的开源基金会，它致力于帮助企业在拓展新领域时拥抱微服务体系架构。</p> \n<p>它将继续支持自 2018 年以来在 Linux 基金会下运作的 TARS 项目及其社区。Linux 基金会为基础设施、开放治理和社区参与支持提供了一个中立的组织，帮助开源微服务项目，使任何行业都能够迅速实现自己的想法。</p> \n<p>TARS 基金会正致力于解决在使用微服务方面可能出现的问题，包括减少开发和服务治理的难度。它旨在解决多编程语言的互通、数据传输、数据存储一致性问题，并在支持海量请求的同时保证高性能。</p> \n<p>TARS 基金会希望吸纳上下游的开源项目，以建立更好的微服务生态。包含但不限于基础设施、存储、开发框架、服务治理、DevOps 和基于任何编程语言的应用。</p> \n<h3>它始于成熟的微服务框架</h3> \n<p>现代企业需要一个更好的微服务平台，以更好地实现 DevOps 实践、更全面的服务治理、更高性能的数据传输、以及面对大量数据请求的存储自动扩缩容以及内置的跨语言互操作性(例如 Golang、Java、C++、PHP、Node.js)。</p> \n<p>为了支持这些不断增长的需求，开发自<a href=\"https://www.tencent.com/\" rel=\"nofollow noreferrer\">腾讯</a>&nbsp;(<a href=\"https://finance.yahoo.com/quote/0700.HK/\" rel=\"nofollow noreferrer\">0700.HK</a>)的 TARS 项目提供了一个成熟的、高性能的 RPC 框架。除腾讯外，也有其他许多公司为扩展该平台的功能和价值做出了重大贡献。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEvoU\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"0 (1).png\" title=\"0 (1).png\"></span><br>图 2. TARS 项目的微服务开源生态</p> \n<p>TARS 可以在考虑到易用性和高性能的同时快速构建系统并自动生成代码。TARS 支持多种编程语言，包括 C++、Golang、Java、Node.js、PHP 和 Python。TARS 可以帮助开发人员和企业以微服务的方式快速构建自己稳定可靠的分布式应用，从而令开发人员只关注业务逻辑，提高运营效率。</p> \n<p>多语言、敏捷研发、高可用和高效运营的特性使 TARS 成为企业级产品。TARS 在腾讯经过 10 多年的大规模使用和迭代，广泛应用于腾讯的在线社交、金融服务、边缘计算、汽车、视频、游戏、地图、应用市场和安全等数百项核心业务中。微服务的规模已经超过百万节点，完善了业界标准的 DevOps 理念和腾讯的海量服务之道。</p> \n<h3>为什么应该加入 TARS 基金会？</h3> \n<p>加入 TARS 基金会将为成员组织和项目带来以下好处：</p> \n<h5>社区参与</h5> \n<ul>\n <li>TARS 基金会将组织开展一系列活动。 TARS 基金会的成员将获得更多机会参与开源项目和社区的生态建设，并分享他们的想法和实践案例。</li>\n</ul> \n<h5>思想领袖</h5> \n<ul>\n <li>TARS 基金会的成员将能够形成一个圈子，一起帮助基金会打造不断发展的微服务生态。</li>\n</ul> \n<h5>提升营销和品牌影响力</h5> \n<ul>\n <li>会员可以通过 TARS 基金会的营销计划来扩大在社区中的覆盖面和知名度。</li>\n</ul> \n<p>建立 TARS 基金会是为了发展和促进开放的微服务生态，它将建立不同的技术兴趣小组以支持其用户社区。</p> \n<p>TARS 基金会还将建立一系列新项目孵化和发展机制。在项目同意加入基金会后，将根据项目情况量身定做合适的孵化和发展路线。在满足所有孵化要求后，TARS 基金会将宣布该项目毕业。</p> \n<p>除了提供技术监督委员会和用户社区外，董事会还会根据项目的实际情况，决策项目发展战略以协助其发展。</p> \n<h3>TARS 基金会合作伙伴</h3> \n<p>TARS 基金会的目标是助力各垂直行业通过应用微服务来实现他们的想法。截至目前，TARS 已经与许多行业建立合作，包括金融科技、游戏、边缘计算、视频、电商和教育等。</p> \n<p>同时，许多在各行业具有领先水平的公司，如腾讯、Arm、AfterShip、Ampere、API7、Kong 和 Zenlayer 已经成为 TARS 基金会的成员和合作伙伴。</p> \n<h5>腾讯</h5> \n<p>TARS 在腾讯经过 10 年的大规模使用和迭代，广泛应用于腾讯的在线社交、金融服务、边缘计算、汽车、视频、游戏、地图、应用市场和安全等数百项核心业务中。微服务的规模已经超过百万节点，完善了业界标准的 DevOps 理念和腾讯的海量服务之道。</p> \n<h5>Arm</h5> \n<p>Arm 是世界领先的半导体知识产权(IP)供应商，在过去一年里一直与腾讯合作，将 TARS 微服务完全移植到 Arm 架构中。目前移植工作已经完成，并可发布于 Akraino Blueprint。AR/VR 以及供腾讯内部使用的自动驾驶案例是 Arm 和腾讯合作的开始。</p> \n<blockquote>\n 我们希望在微服务领域能发挥积极的作用，因此我们选择成为 TARS 基金会的初始成员。\n</blockquote> \n<h5>AfterShip</h5> \n<p>AfterShip 是一家香港初创公司，通过 SaaS 模式提供物流跟踪，并支持全球 400 多项物流服务。</p> \n<blockquote>\n &nbsp;我们相信微服务将成为我们产品的一个新概念，TARS 基金会可以帮助我们使用微服务技术。\n</blockquote> \n<h5>Ampere</h5> \n<p>Ampere 专注于云原生硬件的研制开发。Ampere 的愿景是为云和边缘服务器建立新的标准，它需要确保有相应软件可以在其硬件上完美运行，以满足客户的需求。</p> \n<blockquote>\n 近几年微服务变得非常流行，所以我们选择加入 TARS 基金会并专注于微服务技术，这将我们离愿景更近一步。\n</blockquote> \n<h5>API7（支流科技）</h5> \n<p>API7 是一家初创的开源商业化公司，提供云原生微服务 API 网关，旨在为所有 API 和微服务提供开源的、高性能、安全，可扩展的平台。</p> \n<blockquote>\n 我们特别愿意参与到开源社区的生态建设中去，和其他成员一起打造微服务的生态系统。\n</blockquote> \n<h5>Kong</h5> \n<p>Kong 是全球最受欢迎的开源微服务 API 网关，用于保护、管理和编排微服务 API。</p> \n<blockquote>\n 我们期待与 TARS 基金会的成员合作，一起推动所有行业的微服务使用和创新。\n</blockquote> \n<h5>Zenlayer</h5> \n<p>Zenlayer 是一家边缘云服务提供商，目标是让企业能够在全球范围内，特别是在新兴市场中，快速改善数字用户的体验。</p> \n<blockquote>\n 微服务与边缘计算的集成已经很普遍，我们希望与 TARS 基金会在这方面做更多的研究。\n</blockquote> \n<h3>结语</h3> \n<p>TARS 基金会将助力构建出一个高效的微服务生态。随着越来越多的技术公司在生产中部署微服务，我们期待推动更多传统行业成功转型。TARS 基金会欢迎有更多的公司和个人参与，共同建设更好、更开放的微服务生态。</p> \n<blockquote>\n TARS 基金会将通过开放的管理模式加速微服务生态的创新。Linux 基金会非常乐意支持这项事业，并促进它不断的发展。\n <p>——Linux 基金会执行董事，Jim Zemlin</p> \n</blockquote>', 'https://segmentfault.com/img/bVbEvoE', '6fbfa4aaad3a43458f21c8acf0038ac5', 'dc85b19b1d3742cabe11b25cce8f79b2,c6611ad44f6e40fea7acd54a33ad01c2,cf8fd6f64b3f46d5a7a3468a046b4d3e', '0', '3', '1', '2020-04-16 16:59:35', '2020-04-16 16:59:35');
INSERT INTO `tb_recommend` VALUES ('3974daef892f48a689b9a42fd5271626', '烧脑！JS+Canvas带你体验「偶消奇不消」的智商挑战', '层叠拼图Plus是一款需要空间想象力和逻辑推理能力完美结合的微信小游戏，偶消奇不消，在简单的游戏规则下却有着无数种可能性，需要你充分发挥想象力去探索，看似简单却具有极大的挑战性和趣味性，这就是其魅力所...', '<blockquote>\n 启逻辑之高妙，因想象而自由\n</blockquote> \n<p><strong>层叠拼图Plus</strong>是一款需要空间想象力和逻辑推理能力完美结合的微信小游戏，偶消奇不消，在简单的游戏规则下却有着无数种可能性，需要你充分发挥想象力去探索，看似简单却具有极大的挑战性和趣味性，这就是其魅力所在！温馨提示，体验后再阅读此文体验更佳哦！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268626?w=258&amp;h=258\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>预览：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020280148\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<blockquote>\n Talk is cheap. Show me the code\n</blockquote> \n<p><strong>层叠拼图Plus</strong>微信小游戏采用<code>js</code>+<code>canvas</code>实现，没有使用任何游戏引擎，对于初学者来说，也比较容易入门。接下来，我将通过以下几个点循序渐进的讲解<strong>层叠拼图Plus</strong>微信小游戏的实现。</p> \n<ul> \n <li><strong>如何解决Canvas绘图模糊？</strong></li> \n <li><strong>如何绘制任意多边形图形？</strong></li> \n <li><strong>1 + 1 = 0，「偶消奇不消」的效果如何实现？</strong></li> \n <li><strong>如何判断一个点是否在任意多边形内部 ？</strong></li> \n <li><strong>如何判断游戏结果是否正确？</strong></li> \n <li><strong>排行榜的展示</strong></li> \n <li><strong>游戏性能优化</strong></li> \n</ul> \n<h2>如何解决Canvas绘图模糊？</h2> \n<blockquote>\n canvas 绘图时，会从两个物理像素的中间位置开始绘制并向两边扩散 0.5 个物理像素。当设备像素比为 1 时，一个 1px 的线条实际上占据了两个物理像素（每个像素实际上只占一半），由于不存在 0.5 个像素，所以这两个像素本来不应该被绘制的部分也被绘制了，于是 1 物理像素的线条变成了 2 物理像素，视觉上就造成了模糊\n</blockquote> \n<p>绘图模糊的原因知道了，在微信小游戏里面又该如何解决呢？</p> \n<pre><code class=\"javascript\">const ratio = wx.getSystemInfoSync().pixelRatio\nlet ctx = canvas.getContext(\'2d\')\ncanvas.width = screenWidth * ratio\ncanvas.height = screenHeight * ratio\n\nctx.fillStyle = \'black\'\nctx.font = `${18 * ratio}px Arial`\nctx.fillText(\'我是清晰的文字\', x * ratio, y * ratio)\n\nctx.fillStyle = \'red\'\nctx.fillRect(x * ratio, y * ratio, width * ratio, height * ratio)</code></pre> \n<p>可以看到，我们先通过 <code>wx.getSystemInfoSync().pixelRatio</code> 获取设备的像素比<code>ratio</code>，然后将在屏 <code>Canvas</code> 的宽度和高度按照所获取的像素比<code>ratio</code>进行放大，在绘制文字、图片的时候，坐标点 <code>x</code>、<code>y</code> 和所要绘制图形的 <code>width</code>、<code>height</code>均需要按照像素比 <code>ratio</code> 进行缩放，这样我们就可以清晰的在高清屏中绘制想要的文字、图片。</p> \n<p>可参考微信官方 <a href=\"https://developers.weixin.qq.com/community/develop/doc/00040c9903023848e0d7bd6205a401?highLine=canvas%2520%25E6%25A8%25A1%25E7%25B3%258A\" rel=\"nofollow noreferrer\">缩放策略调整</a></p> \n<p><strong><em>另外，需要注意的是，这里的 <code>canvas</code> 是由 <a href=\"https://developers.weixin.qq.com/minigame/dev/guide/best-practice/adapter.html\" rel=\"nofollow noreferrer\">weapp-adapter</a> 预先调用 <code>wx.createCanvas()</code> 创建一个上屏 <code>Canvas</code>，并暴露为一个全局变量 <code>canvas</code>。</em></strong></p> \n<h2>如何绘制任意多边形图形？</h2> \n<blockquote>\n 任意一个多边形图形，是由多个平面坐标点所组成的图形区域。\n</blockquote> \n<p>在游戏画布内，我们以左上角为坐标原点 <code>{x: 0, y: 0}</code> ，一个多边形包含多个单位长度的平面坐标点，如：<code>[{ x: 1, y: 3 }, { x: 5, y: 3 }, { x: 3, y: 5 }]</code> 表示为一个三角形的区域，需要注意的是，<code>x</code>、<code>y</code> 并不是真实的平面坐标值，而是通过屏幕宽度计算出来的单位长度，在画布内的真实坐标值则为 <code>{x: x * itemWidth, y: y * itemWidth}</code> 。</p> \n<p>绘制多边形代码实现如下：</p> \n<pre><code class=\"javascript\">/**\n * 绘制多边形\n */\nexport default class Block {\n    constructor() { }\n    init(points, itemWidth, ctx) {\n        this.points = []\n        this.itemWidth = itemWidth // 单位长度\n        this.ctx = ctx\n        for (let i = 0; i &lt; points.length; i++) {\n            let point = points[i]\n            this.points.push({\n                x: point.x * this.itemWidth,\n                y: point.y * this.itemWidth\n            })\n        }\n    }\n\n    draw() {\n        this.ctx.globalCompositeOperation = \'xor\'\n        this.ctx.fillStyle = \'black\'\n        this.ctx.beginPath()\n        this.ctx.moveTo(this.points[0].x, this.points[0].y)\n        for (let i = 1; i &lt; this.points.length; i++) {\n            let point = this.points[i]\n            this.ctx.lineTo(point.x, point.y)\n        }\n        this.ctx.closePath()\n        this.ctx.fill()\n    }\n}</code></pre> \n<p>使用：</p> \n<pre><code class=\"javascript\">let points = [\n    [{ x: 4, y: 5 }, { x: 8, y: 9 }, { x: 4, y: 9 }],\n    [{ x: 10, y: 8 }, { x: 10, y: 12 }, { x: 6, y: 12 }],\n    [{ x: 7, y: 4 }, { x: 11, y: 4 }, { x: 11, y: 8 }]\n]\npoints.map((sub_points) =&gt; {\n    let block = new Block()\n    block.init(sub_points, this.itemWidth, this.ctx)\n    block.draw()\n})</code></pre> \n<p>效果如下图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268627?w=300&amp;h=301\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><code>CanvasRenderingContext2D</code>其他使用方法可参考：<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/API/CanvasRenderingContext2D\" rel=\"nofollow noreferrer\">CanvasRenderingContext2D API 列表</a></p> \n<h2>1 + 1 = 0，「偶消奇不消」的效果如何实现？</h2> \n<blockquote>\n 1 + 1 = 0，是\n <strong>层叠拼图Plus</strong>小游戏玩法的精髓所在。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268628?w=300&amp;h=306\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>有经验的同学，也许一眼就发现了，<code>1 + 1 = 0</code> 刚好符合通过 <code>异或运算</code> 得出的结果。当然，细心的同学也可能已经发现，在 <code>如何绘制任意多边形图形</code> 这一章节内，有一句特殊的代码：<code>this.ctx.globalCompositeOperation = \'xor\'</code>，也正是通过设置 <code>CanvasContext</code> 的 <code>globalCompositeOperation</code> 属性值为 <code>xor</code> 便实现了「偶消奇不消」的神奇效果。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268629?w=1526&amp;h=522\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"globalCompositeOperation\" title=\"globalCompositeOperation\"></span></p> \n<p><code>globalCompositeOperation</code> 是指 <code>在绘制新形状时应用的合成操作的类型</code>，其他效果可参考：<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation\" rel=\"nofollow noreferrer\">globalCompositeOperation 示例</a></p> \n<h2>如何判断一个点是否在任意多边形内部？</h2> \n<blockquote>\n 当回转数为 0 时，点在闭合曲线外部。\n</blockquote> \n<p>讲到这里，我们已经知道如何在<code>Canvas</code>画布内绘制出偶消奇不消效果的层叠图形了，接下来我们来看下玩家如何移动选中的图形。我们发现绘制出的图形对象并没有提供点击事件绑定之类的操作，那又如何判断玩家选中了哪个图形呢？这里我们就需要去实现如何判断玩家触摸事件的<code>x</code>，<code>y</code>坐标在哪个多边形图形内部区域，从而判断出玩家选中的是哪一个多边形图形。</p> \n<p>判断一个点是否在任意多边形内部有多种方法，比如：</p> \n<ul> \n <li>射线法</li> \n <li>面积判别法</li> \n <li>叉乘判别法</li> \n <li>回转数法</li> \n <li>...</li> \n</ul> \n<p>在<strong>层叠拼图Plus</strong>小游戏内，采用的是 <code>回转数</code> 法来判断玩家触摸点是否在多边形内部。<code>回转数</code> 是拓扑学中的一个基本概念，具有很重要的性质和用途。当然，展开讨论 <code>回转数</code> 的概念并不在该文的讨论范围内，我们仅需了解一个概念：<strong>当回转数为 0 时，点在闭合曲线外部。</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268631?w=300&amp;h=244\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>上面面这张图动态演示了回转数的概念：图中红色曲线关于点（人所在位置）的回转数为 <code>2</code>。</p> \n<p>对于给定的点和多边形，回转数应该怎么计算呢？</p> \n<ul>\n <li>用线段分别连接点和多边形的全部顶点</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268632?w=500&amp;h=360\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li>计算所有点与相邻顶点连线的夹角</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268633?w=500&amp;h=360\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li>计算所有夹角和。注意每个夹角都是有方向的，所以有可能是负值</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268634?w=500&amp;h=360\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>最后根据角度累加值计算回转数。360°（2π）相当于一次回转。</p> \n<p>在使用 <code>JavaScript</code> 实现时，需要注意以下问题：</p> \n<ul> \n <li> <code>JavaScript</code> 的数只有 <code>64</code> 位双精度浮点这一种。对于三角函数产生的无理数，浮点数计算不可避免会造成一些误差，因此在最后计算回转数需要做取整操作。</li> \n <li>通常情况下，平面直角坐标系内一个角的取值范围是 -π 到 π 这个区间，这也是 <code>JavaScript</code> 三角函数 <code>Math.atan2()</code> 返回值的范围。但 <code>JavaScript</code> 并不能直接计算任意两条线的夹角，我们只能先计算两条线与 <code>x</code> 正轴夹角，再取两者差值。这个差值的结果就有可能超出 <code>-π</code> 到 <code>π</code> 这个区间，因此我们还需要处理差值超出取值区间的情况。</li> \n</ul> \n<p>代码实现：</p> \n<pre><code class=\"javascript\">/**\n * 判断点是否在多边形内/边上\n */\nisPointInPolygon(p, poly) {\n    let px = p.x,\n        py = p.y,\n        sum = 0\n\n    for (let i = 0, l = poly.length, j = l - 1; i &lt; l; j = i, i++) {\n        let sx = poly[i].x,\n            sy = poly[i].y,\n            tx = poly[j].x,\n            ty = poly[j].y\n\n        // 点与多边形顶点重合或在多边形的边上\n        if ((sx - px) * (px - tx) &gt;= 0 &amp;&amp;\n            (sy - py) * (py - ty) &gt;= 0 &amp;&amp;\n            (px - sx) * (ty - sy) === (py - sy) * (tx - sx)) {\n            return true\n        }\n\n        // 点与相邻顶点连线的夹角\n        let angle = Math.atan2(sy - py, sx - px) - Math.atan2(ty - py, tx - px)\n\n        // 确保夹角不超出取值范围（-π 到 π）\n        if (angle &gt;= Math.PI) {\n            angle = angle - Math.PI * 2\n        } else if (angle &lt;= -Math.PI) {\n            angle = angle + Math.PI * 2\n        }\n        sum += angle\n    }\n\n    // 计算回转数并判断点和多边形的几何关系\n    return Math.round(sum / Math.PI) === 0 ? false : true\n}</code></pre> \n<p><em>注：该章节内容图片均来自网络，如有侵权，请告知删除。另外有兴趣的同学可以使用其他方法来实现判断一个点是否在任意多边形内部。</em></p> \n<h2>如何判断游戏结果是否正确？</h2> \n<blockquote>\n 探索的过程固然精彩，而结果却更令我们期待\n</blockquote> \n<p>通过前面的介绍我们可以知道，判断游戏结果是否正确其实就是比对玩家组合图形的 <code>xor</code> 结果与目标图形的 <code>xor</code> 结果。那么如何求多个多边形 <code>xor</code> 的结果呢？ <a href=\"https://github.com/mfogel/polygon-clipping\" rel=\"nofollow noreferrer\">polygon-clipping</a> 正是为此而生的。它不仅支持 <code>xor</code> 操作，还有其他的比如：<code>union</code>, <code>intersection</code>, <code>difference</code> 等操作。<br>在<strong>层叠拼图Plus</strong>游戏内通过 <a href=\"https://github.com/mfogel/polygon-clipping\" rel=\"nofollow noreferrer\">polygon-clipping</a> 又是怎样实现游戏结果判断的呢？</p> \n<ul>\n <li>目标图形</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268635?w=300&amp;h=288\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>多边形平面坐标点集合：</p> \n<pre><code class=\"javascript\">points = [\n    [{ x: 6, y: 6 }, { x: 10, y: 6 }, { x: 10, y: 10 }, { x: 6, y: 10 }],\n    [{ x: 8, y: 6 }, { x: 10, y: 8 }, { x: 8, y: 10 }, { x: 6, y: 8 }]\n]</code></pre> \n<pre><code class=\"javascript\">/**\n * 获取 多个多边形 xor 结果\n */\nconst polygonClipping = require(\'polygon-clipping\')\n\npolygonXor(points) {\n    let poly = []\n    points.forEach(function (sub_points) {\n        let temp = []\n        sub_points.forEach(function (point) {\n            temp.push([point.x, point.y])\n        })\n        poly.push([temp])\n    })\n\n    let results = polygonClipping.xor(...poly)\n\n    // 找出左上角的点\n    let min_x = 100, min_y = 100\n    results.forEach(function (sub_results) {\n        sub_results.forEach(function (temps) {\n            temps.forEach(function (point) {\n                if (point[0] &lt; min_x) min_x = point[0]\n                if (point[1] &lt; min_y) min_y = point[1]\n            })\n        })\n    })\n\n    // 以左上角为参考点 多边形平移至 原点 {x: 0, y: 0}\n    results.forEach(function (sub_results) {\n        sub_results.forEach(function (temps) {\n            temps.forEach(function (point) {\n                point[0] -= min_x\n                point[1] -= min_y\n            })\n        })\n    })\n}</code></pre> \n<pre><code class=\"javascript\">let result = this.polygonXor(points)</code></pre> \n<p><code>xor</code>结果：</p> \n<pre><code class=\"javascript\">[\n    [[[0, 0], [2, 0], [0, 2], [0, 0]]],\n    [[[0, 2], [2, 4], [0, 4], [0, 2]]],\n    [[[2, 0], [4, 0], [4, 2], [2, 0]]],\n    [[[2, 4], [4, 2], [4, 4], [2, 4]]]\n]</code></pre> \n<p>同理计算出玩家操作图形的<code>xor</code>结果进行比对即可得出答案正确与否。</p> \n<p><strong><em>需要注意的是，获取玩家的 <code>xor</code> 结果并不能直接拿来与目标图形<code>xor</code> 结果进行比较，我们需要将<code>xor</code> 的结果以左上角为参考点将图形平移至原点内，然后再进行比较，如果结果一致，则代表玩家答案正确。</em></strong></p> \n<h2>排行榜的展示</h2> \n<blockquote>\n 有人的地方就有江湖，有江湖的地方就有排行\n</blockquote> \n<p>在看本章节内容之前，建议先浏览一遍排行榜相关的官方文档：<a href=\"https://developers.weixin.qq.com/minigame/dev/guide/open-ability/ranklist.html\" rel=\"nofollow noreferrer\">好友排行榜</a>、<a href=\"https://developers.weixin.qq.com/minigame/dev/guide/open-ability/open-data.html\" rel=\"nofollow noreferrer\">关系链数据</a>，以便对相关内容有个大概的了解。</p> \n<ul>\n <li>开放数据域</li>\n</ul> \n<p><code>开放数据域</code>是一个封闭、独立的 <code>JavaScript</code> 作用域。要让代码运行在开放数据域，需要在 <code>game.json</code> 中添加配置项 <code>openDataContext</code> 指定开放数据域的代码目录。添加该配置项表示小游戏启用了开放数据域，这将会导致一些限制。</p> \n<pre><code class=\"javascript\">// game.json\n{\n  \"openDataContext\": \"src/myOpenDataContext\"\n}</code></pre> \n<ul> \n <li>在游戏内使用 <code>wx.setUserCloudStorage(obj)</code> 对玩家游戏数据进行托管。</li> \n <li>在开放数据域内使用 <code>wx.getFriendCloudStorage(obj)</code>拉取当前用户所有同玩好友的托管数据</li> \n <li>展示关系链数据</li> \n</ul> \n<p>如果想要展示通过关系链 <code>API</code> 获取到的用户数据，如绘制排行榜等业务场景，需要将排行榜绘制到 <code>sharedCanvas</code> 上，再在主域将 <code>sharedCanvas</code> 渲染上屏。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020268636?w=620&amp;h=460\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<pre><code class=\"javascript\">// src/myOpenDataContext/index.js\nlet sharedCanvas = wx.getSharedCanvas()\n\nfunction drawRankList (data) {\n  data.forEach((item, index) =&gt; {\n    // ...\n  })\n}\n\nwx.getFriendCloudStorage({\n  success: res =&gt; {\n    let data = res.data\n    drawRankList(data)\n  }\n})</code></pre> \n<p><code>sharedCanvas</code> 是主域和开放数据域都可以访问的一个离屏画布。在开放数据域调用 <code>wx.getSharedCanvas()</code> 将返回 <code>sharedCanvas</code>。</p> \n<pre><code class=\"javascript\">// src/myOpenDataContext/index.js\nlet sharedCanvas = wx.getSharedCanvas()\nlet context = sharedCanvas.getContext(\'2d\')\ncontext.fillStyle = \'red\'\ncontext.fillRect(0, 0, 100, 100)</code></pre> \n<p>在主域中可以通过开放数据域实例访问 <code>sharedCanvas</code>，通过 <code>drawImage()</code> 方法可以将 <code>sharedCanvas</code> 绘制到上屏画布。</p> \n<pre><code class=\"javascript\">// game.js\nlet openDataContext = wx.getOpenDataContext()\nlet sharedCanvas = openDataContext.canvas\n\nlet canvas = wx.createCanvas()\nlet context = canvas.getContext(\'2d\')\ncontext.drawImage(sharedCanvas, 0, 0)</code></pre> \n<p><code>sharedCanvas</code> 本质上也是一个离屏 <code>Canvas</code>，而重设 <code>Canvas</code> 的宽高会清空 <code>Canvas</code> 上的内容。所以要通知开放数据域去重绘 <code>sharedCanvas</code>。</p> \n<pre><code class=\"javascript\">// game.js\nopenDataContext.postMessage({\n  command: \'render\'\n})\n\n// src/myOpenDataContext/index.js\nopenDataContext.onMessage(data =&gt; {\n  if (data.command === \'render\') {\n    // 重绘 sharedCanvas\n  }\n})</code></pre> \n<p><strong><em>需要注意的是：<code>sharedCanvas</code> 的宽高只能在主域设置，不能在开放数据域中设置。</em></strong></p> \n<h2>游戏性能优化</h2> \n<blockquote>\n 性能优化，简而言之，就是在不影响系统运行正确性的前提下，使之运行地更快，完成特定功能所需的时间更短。\n</blockquote> \n<p>一款能让人心情愉悦的游戏，性能问题必然不能成为绊脚石。那么可以从哪些方面对游戏进行性能优化呢？</p> \n<h3>离屏 <code>Canvas</code> </h3> \n<p>在<strong>层叠拼图Plus</strong>小游戏内，针对需要大量使用且绘图繁复的静态场景，都是使用离屏 <code>Canvas</code>进行绘制的，如首页网格背景、关卡列表、排名列表等。在微信内 <code>wx.createCanvas()</code> 首次调用创建的是显示在屏幕上的画布，之后调用创建的都是离屏画布。初始化时将静态场景绘制完备，需要时直接拷贝离屏<code>Canvas</code>的图像即可。<code>Canvas</code> 绘制本身就是不断的更新帧从而达到动画的效果，通过使用离屏 <code>Canvas</code>，就大大减少了一些静态内容在上屏<code>Canvas</code>的绘制，从而提升了绘制性能。</p> \n<pre><code class=\"javascript\">this.offScreenCanvas = wx.createCanvas()\nthis.offScreenCanvas.width = this.width * ratio\nthis.offScreenCanvas.height = this.height * ratio\n\nthis.ctx.drawImage(this.offScreenCanvas, x * ratio, y * ratio, this.offScreenCanvas.width, this.offScreenCanvas.height)</code></pre> \n<h3>内存优化</h3> \n<p>玩家在游戏过程中拖动方块的移动其实就是不断更新多边形图形的坐标信息，然后不断的清空画布再重新绘制，可以想象，这个绘制是非常频繁的，按照普通的做法就需要不断去创建多个新的 <code>Block</code> 对象。针对游戏中需要频繁更新的对象，我们可以通过使用<code>对象池</code>的方法进行优化，对象池维护一个装着空闲对象的池子，如果需要对象的时候，不是直接<code>new</code>，而是从对象池中取出，如果对象池中没有空闲对象，则新建一个空闲对象，<strong>层叠拼图Plus</strong>小游戏内使用的是官方<code>demo</code>内已经实现的<code>对象池</code>类，实现如下：</p> \n<pre><code class=\"javascript\">const __ = {\n  poolDic: Symbol(\'poolDic\')\n}\n\n/**\n * 简易的对象池实现\n * 用于对象的存贮和重复使用\n * 可以有效减少对象创建开销和避免频繁的垃圾回收\n * 提高游戏性能\n */\nexport default class Pool {\n  constructor() {\n    this[__.poolDic] = {}\n  }\n\n  /**\n   * 根据对象标识符\n   * 获取对应的对象池\n   */\n  getPoolBySign(name) {\n    return this[__.poolDic][name] || ( this[__.poolDic][name] = [] )\n  }\n\n  /**\n   * 根据传入的对象标识符，查询对象池\n   * 对象池为空创建新的类，否则从对象池中取\n   */\n  getItemByClass(name, className) {\n    let pool = this.getPoolBySign(name)\n\n    let result = (  pool.length\n                  ? pool.shift()\n                  : new className()  )\n\n    return result\n  }\n\n  /**\n   * 将对象回收到对象池\n   * 方便后续继续使用\n   */\n  recover(name, instance) {\n    this.getPoolBySign(name).push(instance)\n  }\n}</code></pre> \n<h3>垃圾回收</h3> \n<p>小游戏中，<code>JavaScript</code> 中的每一个 <code>Canvas</code> 或 <code>Image</code> 对象都会有一个客户端层的实际纹理储存，实际纹理储存中存放着 <code>Canvas</code>、<code>Image</code> 的真实纹理，通常会占用相当一部分内存。</p> \n<p>每个客户端实际纹理储存的回收时机依赖于 <code>JavaScript</code> 中的 <code>Canvas</code>、<code>Image</code> 对象回收。在 <code>JavaScript</code> 的 <code>Canvas</code>、<code>Image</code> 对象被回收之前，客户端对应的实际纹理储存不会被回收。通过调用 <code>wx.triggerGC()</code> 方法，可以加快触发 <code>JavaScriptCore Garbage Collection</code>（垃圾回收），从而触发 <code>JavaScript</code> 中没有引用的 <code>Canvas</code>、<code>Image</code> 回收，释放对应的实际纹理储存。</p> \n<p>但 <code>GC</code> 具体触发时机还要取决于 <code>JavaScriptCore</code> 自身机制，并不能保证调用 <code>wx.triggerGC()</code> 能马上触发回收，<strong>层叠拼图Plus</strong>小游戏在每局游戏开始或结束都会触发一下，及时回收内存垃圾，以保证最良好的游戏体验。</p> \n<h3>多线程 Worker</h3> \n<p>对于游戏来说，每帧 <code>16ms</code> 是极其宝贵的，如果有一些可以异步处理的任务，可以放置于 <code>Worker</code> 中运行，待运行结束后，再把结果返回到主线程。<code>Worker</code> 运行于一个单独的全局上下文与线程中，不能直接调用主线程的方法，<code>Worker</code> 也不具备渲染的能力。 <code>Worker</code>与主线程之间的数据传输，双方使用 <code>Worker.postMessage()</code> 来发送数据，<code>Worker.onMessage()</code> 来接收数据，传输的数据并不是直接共享，而是被复制的。</p> \n<pre><code class=\"javascript\">// game.json\n{\n  \"workers\": \"workers\"\n}\n\n// 创建worker线程\nlet worker = worker = wx.createWorker(\'workers/request/index.js\') // 文件名指定 worker 的入口文件路径，绝对路径\n\n// 主线程向 Worker 发送消息\nworker.postMessage({\n  msg: \'hello worker\'\n})\n\n// 主线程监听 Worker 返回消息\nworker.onMessage(function (res) {\n  console.log(res)\n})</code></pre> \n<p><strong><em>需要注意的是：<code>Worker</code> 最大并发数量限制为 <code>1</code> 个，创建下一个前请用 <code>Worker.terminate()</code> 结束当前 <code>Worker</code></em></strong></p> \n<p>其他 <code>Worker</code> 相关的内容请参考微信官方文档：<a href=\"https://developers.weixin.qq.com/minigame/dev/guide/base-ability/worker.html\" rel=\"nofollow noreferrer\">多线程 Worker</a></p> \n<h2>结语</h2> \n<p>短短的一篇文章，定不能将<strong>层叠拼图Plus</strong>小游戏的前前后后讲明白讲透彻，加上文笔有限，有描述不当的地方还望多多海涵。其实最让人心累的还是软著的申请过程，由于各种原因前前后后花了将近三个月的时间，本来也想写一下软著申请相关的内容，最后发现篇幅有点长，无奈作罢，争取后面花点时间整理一下我这边的经验，希望可以帮助到需要的童鞋。</p> \n<p>由于项目结构以及代码还比较混乱，个人觉得，目前暂时还不适合开源。<strong><em>好在，小游戏内的所有核心代码以及游戏实现思想均已呈上</em></strong>，有兴趣的同学如果有相关方面的疑问也可以与我多多交流，大家互相学习，共同进步。</p> \n<p><strong>江湖不远，我们游戏里见！</strong></p>', 'https://segmentfault.com/img/remote/1460000020268626?w=258&amp;h=258', 'c56940aa8b004dab84568e86900b2ee6', '15941dc0af92453481b8a0626f963283,63c4e1e7ec204b43a62065a3ced4c2ce,9424c753324d4c6198c85fff4f681dd4,a1dff4d6d5dd4ee69cb3d44463606477', '0', '3', '1', '2020-04-16 16:57:52', '2020-04-16 16:57:52');
INSERT INTO `tb_recommend` VALUES ('3a25c2a693df48a2899050afb107fe9d', '美国联邦贸易委员会提出 AI 发展建议：不要给消费者带来惊喜', '美国联邦贸易委员会（FTC）下属的消费者保护局局长安德鲁-史密斯（Andrew Smith）本周发布了一篇文章，名为《使用人工智能和算法》。该文章旨在对正在开发和使用消费级人工智能的企业提供一些帮助。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFY5A\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>美国联邦贸易委员会（FTC）下属的消费者保护局局长安德鲁-史密斯（Andrew Smith）本周发布了一篇文章，名为《使用人工智能和算法》。该文章旨在对正在开发和使用消费级人工智能的企业提供一些帮助。</p> \n<p>文章中的经验主要来自于 FTC 过去的执法行动、行业报告以及研讨会，其中一个最重要的信息就是建议企业在开发和使用人工智能时，不要让消费者或者他们自身感到惊讶。</p> \n<hr> \n<p>谨慎对待人工智能，除了有助于避免 FTC 的审查之外，还能带来一些好处。比如还可以帮助避免与消费者和商业伙伴的关系受损。此次 FTC 在文中提出的建议主要分为四大类：</p> \n<ol> \n <li>要透明。</li> \n <li>向消费者解释你的决定；</li> \n <li>确保你的决定是公平的；</li> \n <li>确保你的数据和模型是稳健的、经验性的。</li> \n</ol> \n<p>尽管其中许多信息涉及到 FTC 执行的特定行业法律，如《公平信用报告法》（FCRA）和《平等信用机会法》（ECOA）等，但其实很多建议具有更广泛的适用性。</p> \n<h2>担起企业的责任</h2> \n<p>诸如 FCRA、ECOA 和 1964 年《民权法》第七章等行之已久的法律，他们分别适用于消费者报告、消费信贷、投票、教育和提供公共场所等领域的人工智能使用。要履行这些法律的义务，有赖于承认这些法律是否以及何时适用。</p> \n<p>然而，FTC 的文章中讨论的法律远非详尽无遗。在文章中提到的法律之外，还有一条重要的法律需要补充 —— 健康保险便利和责任法案（HIPAA）。</p> \n<p>该法案制定了一系列安全标准，就保健计划、供应商以及结算中心如何以电子文件的形式来传送、访问和存储受保护的健康信息做出详细的规定。法案规定在确保私密性的情况下保存病人信息档案六年，还详细规定了医疗机构处理病人信息规范，以及违法保密原则、通过电子邮件或未授权的网络注销病人档案的处罚方案。</p> \n<p>虽然通常情况下，当一个企业作为医疗服务提供者、保险人或信息交换中心时，通常是很清楚的，但要确定公司何时成为受保实体的「商业伙伴」可能更具挑战性。</p> \n<p>此次新冠疫情的影响加速了和医疗健康相关的 AI 产业发展，而这些企业在寻求技术突破的同事，更需要了解企业应该担负的责任。</p> \n<h2>全面评估数据和 AI 模型</h2> \n<p>根据文章所述，FTC 已经制定了评估 AI 系统是否存在非法歧视的法律和经济标准。</p> \n<p>具体来说，该机构将查看输入的信息，以确定它们是否包括「基于种族的因素，或此类因素的替代信息」。</p> \n<p>文章中表达了一个强烈的观点，就是 FTC 对通过使用 AI 可能产生的歧视的关注度相当高。\"使用人工智能和算法工具的公司应该考虑是否应该对人工智能结果进行自我测试，以管理这类模型所固有的消费者保护风险\"。</p> \n<p>然而，FTC 并没有为这些评估提供一个框架，也没有更笼统地指出哪些类型的 AI 歧视风险可以被采取行动。尽管如此，企业仍需善意地努力识别和降低此类风险。</p> \n<h2>对供应商进行尽职调查，约束下游用户</h2> \n<p>FTC 的 AI 指南中贯穿着另一个主题：公司应仔细评估 AI 相关数据和分析的上游供应商如何遵守其法律义务，并对其进行适当的约束，以防止自己的客户以不适当或非法的方式使用 AI 服务。</p> \n<p>虽然 FTC 重点关注 FCRA 和 ECOA 下的上游和下游要求，但远离更多的高监管活动才是其意图。</p> \n<p>在签订人工智能相关业务关系之前进行尽职调查，要求在合同条款中写明人工智能系统和数据输入的允许用途，以及监督业务合作伙伴的表现，都是实现这些目的的关键。</p> \n<hr> \n<p>FTC 在监督人工智能在经济领域的使用方面的作用还处于起步阶段，并将继续发展。但不管怎么说，该机构此次发布的文章，对于随着科技发展而新兴的法律和企业对自我监管的思考，都提供了一个有用的资源。</p> \n<blockquote>\n 参考资料：\n <br>\n <a href=\"https://www.adlawaccess.com/2020/04/articles/ftc-guidance-on-ai-dont-surprise-consumers-or-yourself/\" rel=\"nofollow noreferrer\">AD LAW ACCESS</a>\n <br>维基百科：\n <a href=\"https://zh.wikipedia.org/wiki/%E5%81%A5%E5%BA%B7%E4%BF%9D%E9%99%A9%E4%BE%BF%E5%88%A9%E5%92%8C%E8%B4%A3%E4%BB%BB%E6%B3%95%E6%A1%88\" rel=\"nofollow noreferrer\">健康保险便利和责任法案</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyR0\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFY5A', '3f69fcc9b13843d1910b3dac597f5215', '2a09bf1afefd4d659606f43445741ee3,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-16 16:55:37', '2020-04-16 16:55:37');
INSERT INTO `tb_recommend` VALUES ('3a6a7becd90b419685450dd77cdbe0a1', '宜信科技年货包｜精选49篇干货文章+全年沙龙视频+速记+ppt', '还有10天就要到春节了，前几天被各种年度盘点刷屏，有人感慨我哪来这么些钱，有人惊讶自己的回答竟然帮助过那么多人，有人看到了自己的“9”后真言开心地点点头，有人则回想起深夜里单曲循环的那首歌... ...数据记...', '<p>还有10天就要到春节了，前几天被各种年度盘点刷屏，有人感慨我哪来这么些钱，有人惊讶自己的回答竟然帮助过那么多人，有人看到了自己的“9”后真言开心地点点头，有人则回想起深夜里单曲循环的那首歌... ...数据记录着多少尘封的念想，又镌刻下多少成长的记忆,或许盘点是为了更好地上路，让一切过往都成为重新出发的力量！细数这一年宜信技术学院在公众号发布的文章，<strong>从数据中台“C”位出道，到区块链热度重燃，从宜信数据中台建设实践，到宜信用区块链技术构建可信商业环境</strong>，这里的每一篇文章都值得再一次回看，如果你错过了之前的推送，那这一篇你一定不能错过~</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCHtR\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"科技年货.jpeg\" title=\"科技年货.jpeg\"></span></p> \n<p><strong>【年货包1：精选49篇硬核干货（戳文字直达）】</strong> </p> \n<p><strong>年度干货文章：</strong><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993365&amp;idx=1&amp;sn=5133a7601a3289d343267cae8f493d54&amp;chksm=83037242b474fb54956e0d86ad989e439013466d8748974929ee0210d726571674701b71894a&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Sharding-JDBC 使用入门和基本配置</a> </p> \n<p><strong>年度主题活动：</strong><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993615&amp;idx=2&amp;sn=4570c294b57d46044d8ca4d3d988f0e8&amp;chksm=83037358b474fa4ed3fed93d5027f3f7c72acb2832d50fe29a2433cf19d720ddc1256358e193&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">宜信敏捷数据中台建设实践</a>[](<a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993615&amp;idx=2&amp;sn=4570c294b57d46044d8ca4d3d988f0e8&amp;chksm=83037358b474fa4ed3fed93d5027f3f7c72acb2832d50fe29a2433cf19d720ddc1256358e193&amp;scene=21#wechat_redirect)\" rel=\"nofollow noreferrer\">http://mp.weixin.qq.com/s?__b...</a></p> \n<p><strong>人物专访（4）：</strong></p> \n<ul> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993871&amp;idx=1&amp;sn=82d329270eaa7705a93b284d11b3980e&amp;chksm=83037058b474f94e8ce989aa10252d7883e79537e06741cced1157d9e079affef6ce1e15e546&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">智慧金融时代，大数据和AI如何为业务赋能？|专访宜信AI中台团队负责人王东</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993971&amp;idx=1&amp;sn=f9563a578225732738aca3b0b28cef27&amp;chksm=83037024b474f932ddf06462bf7401c59e70880fa3a466cb0596e992336305470326814facbe&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">一切技术创新都要以赋能业务为目标|专访宜信数据智能研发部负责人张军</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993982&amp;idx=1&amp;sn=ed07b7983cc36f4588dceb71b229c5df&amp;chksm=83037029b474f93f202360e7cff15ac7f400688cad1e858100a8c17cd2f86c9315095395ae43&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">回归架构本质，重新理解微服务|专访宜信开发平台（SIA）负责人梁鑫</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994133&amp;idx=1&amp;sn=f2c7c436b7be8e0e253141fcbb96cdd6&amp;chksm=83037142b474f854d9192487766d0ee3ed21948bc6e35cb85fb79123823ee3c36eab59aa26de&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">市场变化驱动产品思维升级|专访宜信财富管理产品部负责人Bob</a></li> \n</ul> \n<p><strong>宜信技术沙龙分享实录（7）：</strong></p> \n<ul> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993441&amp;idx=1&amp;sn=5a3515a34cd1d64e51269839b39ffe2a&amp;chksm=83037236b474fb202cd4b052e8afc85228d73fcc3bf4e0233de4712195ded557802a9635c2c1&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">AI中台：一种敏捷的智能业务支持方案</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993615&amp;idx=2&amp;sn=4570c294b57d46044d8ca4d3d988f0e8&amp;chksm=83037358b474fa4ed3fed93d5027f3f7c72acb2832d50fe29a2433cf19d720ddc1256358e193&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">数据中台：宜信敏捷数据中台建设实践</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993929&amp;idx=2&amp;sn=dfd6145f9190d44b864900e7fab356fa&amp;chksm=8303701eb474f9085a957011917dfdbb61b2b75c35c4cfb15f25a41fd1e7cbc4d869bc582d8e&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">AI中台——智能聊天机器人平台的架构与应用</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994199&amp;idx=1&amp;sn=bca4d4c1402717fc17a3480888c7a5d3&amp;chksm=83037100b474f8167f0c74d10251ecf22f78132108de152a33f4189866ea3b5aaa56bac4ff16&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">宜信微服务任务调度平台建设实践</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994329&amp;idx=1&amp;sn=28f3ec4b7e9b916c8d6a59ee2ddfbb0e&amp;chksm=8303718eb474f89860cd88bb4901b81c6faae44130418d8640dd99392788dd0d2de0ed3b5849&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">宜信智能监控平台建设实践</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994470&amp;idx=1&amp;sn=65176a323fad6ef99c6128c1a740066d&amp;chksm=83036e31b474e72732d0ee97067b0d75141d0a1af5fdfe456fe44566b104e8287dc7421dfa3b&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">宜信容器云的A点与B点</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994535&amp;idx=1&amp;sn=3ebc530e30afdec105300b52dbee469d&amp;chksm=83036ef0b474e7e65a691d69fc35371e18ca69d9662092b1ec164b605f828e4039ac6e6712e4&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">宜信微服务架构落地及其演进</a></li> \n</ul> \n<p><strong>文章干货（38）：</strong> </p> \n<p><strong><em><em>△技术管理：</em></em></strong></p> \n<ul>\n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994363&amp;idx=1&amp;sn=6d2a971256a09951efc7cf617b65274f&amp;chksm=830371acb474f8bac017185809627339405f34182b493dc3821a42b6ded55a4595dca4e1cf96&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">大型科技团队的管理|分享实录</a></li>\n</ul> \n<p><strong>△区块链：</strong></p> \n<ul> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993292&amp;idx=1&amp;sn=b1f5f6771a0f7a38d7999f0aab72702d&amp;chksm=8303759bb474fc8d9f55f2beb1679d9d150984063faf3cf27f7b064abb7d697ef8ad95e21b7b&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">供应链金融+区块链双链合璧</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994470&amp;idx=2&amp;sn=a801237bef54a4e8c415e17e05dfc0eb&amp;chksm=83036e31b474e727445a09992aa95f8dcc5205529e421c73d95b656ca1fd9b4cc4b85c34571a&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">一篇干货文读懂宜信的区块链实践 |宜信CEO座谈会</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994535&amp;idx=2&amp;sn=57ec0c96af0b408660dcb4d5b3e6f6ef&amp;chksm=83036ef0b474e7e6baf18e8132c0ef278a661b74a7c47214fd3953257b405dcfc4751cd76c73&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">宜信Blockworm BaaS：用区块链技术构建可信商业环境</a></li> \n</ul> \n<p><strong>△微服务：</strong></p> \n<ul> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993519&amp;idx=1&amp;sn=288bb1755588f3da009cd6f560771633&amp;chksm=830372f8b474fbee255984392e1e0546edfb98d5eda53f9783e4f05b91bab2e6ee20e867797d&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">详解Eureka缓存机制</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993615&amp;idx=1&amp;sn=e8ea7c8adb5c0c9dde630646ff7db01c&amp;chksm=83037358b474fa4e1903a5226afa6266d8c2ec4aec44cfacda14b1b0b67e278d194a5997213f&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">一次Zookeeper 扩展之殇</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993704&amp;idx=1&amp;sn=5c81b40506b9850f88d3399b4a77e6f4&amp;chksm=8303733fb474fa29dd954481457c538611e007d71e0bc7d38856d79ae2b81161ec4417cea4f1&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">宜信开源|微服务任务调度平台SIA-TASK入手实践</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993947&amp;idx=1&amp;sn=cb943c6a262b0c7d51078643fc8baea8&amp;chksm=8303700cb474f91ac89b4c731ae3d55aee4962e2ea045403904af665b452d3753aca7dd1c8f7&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">一个项目的SpringCloud微服务改造过程</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993971&amp;idx=2&amp;sn=88e80969d59ef347ba36c6c3d650b2bb&amp;chksm=83037024b474f932519f810062eb34b49322f8d2fa18ff4a6472e71770f973a81ae93769ae57&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">微服务与网关技术（SIA-GateWay）</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993988&amp;idx=1&amp;sn=8d22099e6d706ba84d2da0affabded8c&amp;chksm=830370d3b474f9c5b7d5041497dd66ddd0f1bfd412d9fb648ee2cc791dccb255a17630d23ea7&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">82天突破1000star，项目团队梳理出软件开源必须注意的8个方面</a></li> \n</ul> \n<p><strong>△Spring专题：</strong></p> \n<ul> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993277&amp;idx=2&amp;sn=558852fa05af3dfdfdf712a09e593e42&amp;chksm=830375eab474fcfcbc07efaf3fc72eb481f5cca0163f3fcc461b93576f2e323adab0d1e81cec&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">深入理解Spring异常处理</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993365&amp;idx=1&amp;sn=5133a7601a3289d343267cae8f493d54&amp;chksm=83037242b474fb54956e0d86ad989e439013466d8748974929ee0210d726571674701b71894a&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Sharding-JDBC 使用入门和基本配置</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993326&amp;idx=1&amp;sn=329d365b91790796063ced2d62966871&amp;chksm=830375b9b474fcaffb9d747ee315b0104918e4a044ca35a10ae39b27cc0101de4cb373692bb8&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Spring基本概念速览</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993342&amp;idx=1&amp;sn=314010a0136d5530ba7bffee2c297047&amp;chksm=830375a9b474fcbf6228971fd60a16387ab7d398954b5e66713b7dec63879d5509efb0fa50db&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">springboot 之常用注解</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993392&amp;idx=1&amp;sn=7ab3c8a6e8bd00beceef8b7d8d507718&amp;chksm=83037267b474fb71e43ae57b0a8c736f9ea9594cc187760e71d2c5edb94ad90b0675cb11dd9c&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">如何编写优雅的Dockerfile</a></li> \n</ul> \n<p><strong>△安全：</strong></p> \n<ul>\n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994423&amp;idx=1&amp;sn=1b2f61b06724668af72632fa83a5f547&amp;chksm=83036e60b474e7766b40b40c72eeacfdd5bf9123fb3fbe0a15724440daed8f68011294ee0a12&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">宜信SDL实践：产品经理如何驱动产品安全建设</a></li>\n</ul> \n<p><strong>△Redis专题：</strong></p> \n<ul> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993501&amp;idx=1&amp;sn=08c4d041c43693496e01ce976676e1b7&amp;chksm=830372cab474fbdc211e29b09e7fa2ce608caeb2f0e35623d5a8e3e33589aa19fb9403658774&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Redis闲谈（1）：构建知识图谱</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993678&amp;idx=1&amp;sn=37c878f55e7701f52c9e0843335637a7&amp;chksm=83037319b474fa0f04d53f4b34a886a71467910ccff35445ae3c14f459d4f46fc150f054c83d&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Redis专题(2)：Redis数据结构底层探秘</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994091&amp;idx=1&amp;sn=0e68cbe5f96acc58f382fa00775ce202&amp;chksm=830370bcb474f9aaaec36e37d703a0ba7428df0e1140867e4efa17069bebcc5cdf83c2a37311&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Redis专题（3）：锁的基本概念到Redis分布式锁实现</a></li> \n</ul> \n<p><strong>△容器云：</strong></p> \n<ul> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994222&amp;idx=1&amp;sn=b7b74b3607a3a213376b3f76b4349c95&amp;chksm=83037139b474f82fe668dc21ca28b1b63ae354dbf089a52a51aa129b4ce09ab6692b60eed1b1&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">如何快速部署容器化应用</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994395&amp;idx=1&amp;sn=f73fe1ccfb0f1bca23e415272dda5df1&amp;chksm=83036e4cb474e75a8634c851c01bc48eb92824735b45a2f8d7e90b127f5c722bbf58e7462f13&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">宜信容器云排错工具集</a></li> \n</ul> \n<p><strong>△测试&amp;运维：</strong></p> \n<ul> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993704&amp;idx=2&amp;sn=d6a3cd63315cab97ca002b0082cf4688&amp;chksm=8303733fb474fa2925c43422c9430df4633b9051a6613da94ed35cb51b7c97da81127e5b9820&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Linux三剑客之awk（1）：awk简介与表达式实例</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993731&amp;idx=2&amp;sn=30ee965a87e297daeb049748361b6149&amp;chksm=830373d4b474fac23bcbad5ee7b0ec7b862a1298fcf6139f9e4b481457c7d3f8822db6554fe0&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Linux三剑客之awk（2）:awk进阶-变量与执行、数组与语法</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993245&amp;idx=3&amp;sn=6a5f73f86e498926a09c9f97f7b83fd8&amp;chksm=830375cab474fcdca7e34b3490ddc64463083de4dba46e22ff751996d7a8f7830c13a146effe&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">浅析安全测试</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993245&amp;idx=2&amp;sn=4831bf5fc758932d4a9e0dec31a42ad9&amp;chksm=830375cab474fcdc12672ec7d5a5cb96d15f50f6d26a2a4de0cbee12a854c4bbc1afa6b66ac0&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">API自动化测试实践</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993772&amp;idx=1&amp;sn=96f96fb5cad52c9141fde4c91f05c5bb&amp;chksm=830373fbb474faed09145915b55143ff52b2c3423e6af6409079e65cdc0003527811a7f75eb9&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">自动化最佳实践（一）：从纺锤模型到金字塔模型</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993847&amp;idx=1&amp;sn=ece775aa2d89f6b5bfe1452588d41314&amp;chksm=830373a0b474fab65d331c217b9e6614163231f42e736681d1160fb36ec24aa1519d024426a3&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">实例解说AngularJS在自动化测试中的应用</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994065&amp;idx=1&amp;sn=b401082ee2cf54e6bf7d10e9d0e46aff&amp;chksm=83037086b474f99008f90023b8f9ab675026da4980050c5afe5fd2596cecb5cbe60a5e0d4b9f&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">巧用自动化测试组合拳保证产品质量</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993816&amp;idx=1&amp;sn=975c1b285c06138323c10b46c0e83baa&amp;chksm=8303738fb474fa998fb92fb611c5f8efccd9f29607260d338b6596736ebc2130ddf7d3936c0e&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">分布式主动感知在智能运维中的实践</a></li> \n</ul> \n<p><strong>△程序员笔记：</strong></p> \n<ul> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993731&amp;idx=1&amp;sn=5d9fbef99ba5f5d834eca7a6f8b8c340&amp;chksm=830373d4b474fac2d8a8ebb5ba63a239e4f4d03810983c73d71e0490fe3f50b662e61d9d8d07&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">简洁方便的集合处理——Java 8 stream流</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994018&amp;idx=1&amp;sn=5ad1aac50a6a3c50d6c54de5bb5f0861&amp;chksm=830370f5b474f9e33f106f6543b7e9c272e2698cbf37d3d480d1b9af69102aa73ac2ec1da423&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">MyCat数据库的基础配置及使用</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647994261&amp;idx=1&amp;sn=bde3a14c189e2f85508acf890fa420fc&amp;chksm=830371c2b474f8d4522dfb07edc0313ef1807fe058d1f719c89857271cc18804417f925aa66c&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">快速入门开发实现订单类图片识别结果抽象解析</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993480&amp;idx=1&amp;sn=cdeeafc818be0fccb0f7a947c48b9a92&amp;chksm=830372dfb474fbc96ba08906bef16aa5ca2f3086dc527fc42db67990f79b71f76c958052e181&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">专注业务逻辑的轻量级服务框架nextsystem4</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993253&amp;idx=1&amp;sn=0ac5cda90f03dcf287c61c3618036f06&amp;chksm=830375f2b474fce45e75397255737b27d3cdead1d17078a972631acf4dcc44b2dd3cdcae00dc&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">如何写一个无配置格式统一的日志</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993534&amp;idx=2&amp;sn=0d0c0fa6b7d5d1155bb69a085cbe4069&amp;chksm=830372e9b474fbff6703f797f1d9df6d15bec5df3fbfebc74dcb61df18a5ea1da2395c661cfd&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">3个问题带你入门数据建模</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993652&amp;idx=1&amp;sn=cd20db1c83f45b1345f8763d79ba5115&amp;chksm=83037363b474fa7577764a212c2dd0b867ca5ee099d789902529303b77383f97bd0e46fc25aa&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">程序员笔记|API网关如何实现对服务下线的实时感知</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993678&amp;idx=2&amp;sn=ebe91a0c5c18f4d3a9c9a1362cef18e1&amp;chksm=83037319b474fa0f50c6e5c30ebff508bf5f0a73c3dc4e26854922092ad2f527ca6c54c97c4b&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">程序员笔记|三步实现Django Paginator 分页</a></li> \n <li><a href=\"http://mp.weixin.qq.com/s?__biz=MzAwNTAyNDU2OA==&amp;mid=2647993267&amp;idx=2&amp;sn=9221e122e70d61a3a02391204764d1d6&amp;chksm=830375e4b474fcf2113e4da5a3d7f27277a2009010e2dd81281bdf85411c2c4d468c72c8c188&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">安卓跨平台开发实践</a></li> \n</ul> \n<p><strong>【年货包2：2019全年技术沙龙 视频回放+速记+ppt全套内容】</strong></p> \n<p><strong>获取方式：</strong></p> \n<p>关注公众号“<strong>宜信技术学院</strong>”回复关键字“<strong>科技年货</strong>”，即可获取。</p>', 'https://segmentfault.com/img/bVbCHtR', '692c6787030d4b8882077b2ab9279c52', '277530c212aa4407b43c58c657fe8194,c6611ad44f6e40fea7acd54a33ad01c2,753b5aee3913424e81fe2b5299626d8c,6aec6c8499c44483beecd569d05c7f4b,50b1ead18a154fb9a3be3ed4bc61398b', '0', '3', '1', '2020-04-16 16:59:08', '2020-04-16 16:59:08');
INSERT INTO `tb_recommend` VALUES ('3b90589454bd4a6694595cf902d5d81e', 'AI端侧落地，京东AI技术如何部署边缘？', '导语：随着物联网的快速发展，越来越多的用户希望将 AI能力下沉到边缘层，让边缘设备能够自动处理关心的一些数据，再把结果上报到云平台。这样做既节省了资源，又提高了运算效率。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022360719\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Alt\" title=\"Alt\"></span></p> \n<blockquote>\n <strong>导语：随着物联网的快速发展，越来越多的用户希望将 AI能力下沉到边缘层，让边缘设备能够自动处理关心的一些数据，再把结果上报到云平台。这样做既节省了资源，又提高了运算效率。</strong>\n</blockquote> \n<p>随着技术进步，手机等移动设备已成为非常重要的本地深度学习载体，然而日趋异构化的硬件平台和复杂的终端侧的使用状况，让AI技术在端侧的应用能力颇受挑战。端侧模型的推理往往面临着算力和内存的限制，为了能够完整的支持众多硬件架构，并且实现在这些硬件之上人工智能应用性能的优化，不少科技公司开启了深入研究。技术媒体InfoQ上周采访了京东智联云视觉研发部的产品经理张志强，交流了京东AI技术在端侧的应用。</p> \n<p>（以下为采访稿件内整理）</p> \n<h3>AI技术在端侧能解决什么问题？</h3> \n<p>在探讨这个话题之前，我们需要先明确端侧的定义。端侧其实是相对于云中心侧来讲的。云中心侧其实是一种集中式服务，所有采集和感知到的视频、图像数据都通过网络传输到云中心侧进行后续处理。云侧的资源高度集中并且具有很高的通用性，但是随着IoT设备和数据的指数爆发式增长，云侧的集中式计算模型慢慢暴露出了很多不足，比如数据处理的实时性，网络条件制约，数据安全等。</p> \n<p>AI技术用于端侧也就是我们常说的边缘计算，张志强说，这种模式可以更好的支持AIoT场景，具有如下优点：一是AI技术用于端侧可以第一时间对收集的数据进行处理，不需要通过网络上传到云侧的处理中心，极大加快了系统响应也减少了系统处理延迟，5G技术的普及也为端侧处理提供了保证；二是端侧计算可以更高效的处理有价值的关键数据（大约20%），其余的数据（大约80%）只是临时性的，在端侧结合AI能力，不仅可以更及时处理数据，而且减轻网络带宽的限制和缓解对中心侧数据存储的压力；三是在端侧的AI技术可以高效地对用户的源数据进行处理，将一些敏感的数据进行清洗和保护，端侧设备只将AI处理后的结果进行上报。</p> \n<p>总的来说，AI在边缘侧的执行可以实时进行数据处理，实时响应，有效降低因数据传送到云计算中心而导致的延迟。</p> \n<p>目前，主要的应用是物联网的边缘计算，京东对内、对外都有一些落地案例，例如：无人售货机和智能结算台上使用了AI的商品检测技术，包括顾客所选取的商品SKU等，主要采用的是端侧的AI能力；以及在智慧园区里进行基本的人脸结构化、人体结构化、车辆结构化，还有基于视频分析的周界安全检测、物体遗留等场景。某些场景不仅结合了边缘计算的AI能力，同时也使用了云端的AI能力进行二次分析，采用的形式是云端协同。在一些更复杂的场景，比如智慧园区，智慧社区，智慧城市的项目落地中，大多都是采用的端云协同的应用形式。</p> \n<h3>端侧AI的研发难点</h3> \n<p>众所周知，端侧的技术难度是如何在资源有限的硬件环境里满足业务对性能的要求，无论是存储、内存，或者计算资源都比较有限。端侧对AI模型提出了更高的要求，比如对模型生命周期的管理，发布，回滚，灰度，版本管理等，如何方便模型的升级更新需要建立一套完善通用的机制和平台。另外，边缘计算的硬件设备种类很多，在初期对不同硬件架构的学习、适配和模型迁移工作会占用比较长的时间，比如有很多之前自定义的模型算法算子不支持，需要算法侧重新设计和开发，无形中增加了AI在端侧应用的复杂度。</p> \n<p>为此，经过前期积累，京东也针对市面上流行的不同边缘计算硬件产品进行了抽象和平台化，屏蔽底层差异化，统一建设了从算法开发、模型适配、本地测试，部署上线等的一系列CI/CD机制，实现快速交付。</p> \n<p>过往，不少开发者都会遇到离线训练和在线推理结果不一致的问题。对此，京东方面发现训练和推理的结果不会完全一样，但是基本一致。可以从以下三方面考虑：一是在模型设计上尽可能轻量化。在保证模型性能的前提下，使网络参数减少的同时，不损失网络性能，尽可能的降低模型的复杂度以及运算量；二是性能与精度进行权衡，找到平衡点；三是检测两者的预处理与后处理有无差异，可以在网络处理前后进行预判和比较。</p> \n<h3>京东端侧AI技术实践</h3> \n<p>2019年中，京东云与AI视觉研发部开始规划在端侧场景下的AI视频分析平台mVCG-Air，与该版本相呼应的是在云端场景部署的mVCG-Pro，二者统称为mVCG（mega-Video Computing Grid），也就是超大规模的视频计算分析网络。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022360720\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Alt\" title=\"Alt\"></span><br><em>【mVCG-Air技术整体架构图】</em></p> \n<p>mVCG-Air是AI视频分析处理能力在端侧应用的典型产品，经过快速迭代mVCG-Air目前已经在不同场景落地。张志强表示，该平台解决了在落地场景中接入的设备多，同时对视频分析的时效性很高，云端处理受网络带宽有滞后影响的问题。</p> \n<p>此外，mVCG-Air结合了目前性能较高的端侧计算设备，同时内部全部使用了京东智联云自研的AI核心技术，所有算法模型针对端侧计算设备进行了全面优化和加速，开发者可以轻松实现定制化、快速交付。</p> \n<h3>有必要统一模型研发流程</h3> \n<p>综合整个实践过程，不难发现 ，拥有统一所有模型的研发流程，使得模型研发之初的特征工程再到模型训练，再到推理上线等做统一的规划是十分必要的。比如，京东同一个模型未来可能会在不同的场景都需要部署落地，有的是基于边缘计算的mVCG-Air部署，有的是基于云中心的mVCG-Pro进行部署，那么就需要有统一的模型训练和转换机制。同时，同一个模型有可能会在不同的边缘硬件上进行部署，在模型设计之初就需要考虑后续的一致性等问题。京东内部已经沉淀了一套完整的模型研发测试流程，使得一个模型可以轻松同时落地不同的异构硬件设备上。</p> \n<h3>资源调度设计</h3> \n<p>关于资源调度，其实包括边缘侧mVCG-Air和中心侧mVCG-Pro的调度，也包括mVCG-Air管理的设备之间的调度。张志强表示，在mVCG内部有个很重要的模块组件，就是模型仓库，与其相关联的有算力调度，任务调度等。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022360721\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><em>【算法仓库体系架构图】</em></p> \n<p>算法仓库体系架构使得智能分析能力不再固化在mVCG的产品中，实现“一套平台，多种算法”，具有系统高可用、资源高利用率、算法灵活开放等优势。基于算法仓库可以对mVCG所有算法模型进行统一高效管理，包括模型管理、模型灰度部署、模型发布、模型升级、模型算法版本管理。每个模型都有自己的画像Model Profile，通过分布式组件，根据模型画像和当前业务负载实现模型算力的灵活分配和调度，所有模型算法是基于插件机制实现灵活部署、自动分配、快速加载、高效运行和无感知版本更新。</p> \n<h3>硬件选型</h3> \n<p>事实上，软件层面的定制优化永无止境，这包括模型加速推理，模型量化剪枝，让模型体积更小，占用资源小同时又不失精度。当然，软件层面的优化工作也需要取决于边缘侧设备的开放程度。</p> \n<p>除了软件层面的能力，AI所需的超强算力必须有合适的硬件与之相匹配。张志强表示，京东云与AI视觉研发部mVCG-Air在研发过程中使用了ARM架构的CPU+NPU，现在不断有更新、更快的硬件加速卡或者是端侧产品推出，选取性价比最高，同时最适合业务场景的才是最好的。</p> \n<p>未来，mVCG-Air也将继续赋能感知设备以智能，并融合云端物联网和信息网的数据，实现对人（人脸、人体）、车、物体、场景、行为的全息感知，同时深入挖掘多维数据的潜在价值。应用的重点包括京东内部的很多重要场景，也包括对外的场景，比如智慧园区，智慧城市，智慧车站，智慧警务等。</p> \n<h3>未来规划</h3> \n<p>边缘计算作为传统云计算的重要补充，各自发挥特长，随着端侧设备处理能力的大幅度提升，基于AI的智能设备正在发挥越来越重要的作用。</p> \n<p>AI和端侧的结合其实属于AIoT的一部分，因为智能物联网AIoT是在2018年兴起的概念，目前各类AI公司、芯片公司都处在百家争鸣的阶段，市场空间非常大，包括端侧人工智能在建筑人居、工业制造、智慧城市等不同产业领域的瞭望，都充满了期待。</p> \n<p>2020年，AIoT正在发生的一个趋势是人工智能和设备的加速融合。大多数情况下，端侧人工智能计算和云侧计算将会长期共存，甚至采用混合的方式，一部分由设备自身的AI能力及时执行运算，另一部分通过统一云中心完成。现在，业界对于端侧人工智能讨论比较多的还是软硬件选型、动态调度和垂类落地的问题。作为云计算的下沉计算模型，端侧的人工智能发展还需要一些时间和耐心。</p> \n<p><strong>欢迎点击“<a href=\"https://www.jdcloud.com/cn/?utm_source=PMM_Segmentfault&amp;utm_medium=ReadMore_220&amp;utm_campaign=ReadMore&amp;utm_term=NA\" rel=\"nofollow noreferrer\">更多</a>”了解京东智联云！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022360722\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Alt\" title=\"Alt\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022360723\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Alt\" title=\"Alt\"></span></p>', 'https://segmentfault.com/img/remote/1460000022360719', '3f69fcc9b13843d1910b3dac597f5215', '2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-16 16:55:36', '2020-04-16 16:55:36');
INSERT INTO `tb_recommend` VALUES ('3be1c93f73e94063bd80684c196264cc', '如何实现 Vue 自定义组件中 hover 事件以及 v-model', '点赞再看，养成习惯本文 GitHub [链接] 上已经收录，更多往期高赞文章的分类，也整理了很多我的文档，和教程资料。欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。', '<blockquote>\n 作者：Joshua Bemenderfer\n <br>译者：前端小智\n <br>来源：alligator\n</blockquote> \n<blockquote> \n <strong>点赞再看，养成习惯</strong>\n <p><strong>本文 <code>GitHub</code> <a href=\"https://github.com/qq449245884/xiaozhi\" rel=\"nofollow noreferrer\">https://github.com/qq44924588...</a> 上已经收录，更多往期高赞文章的分类，也整理了很多我的文档，和教程资料。欢迎Star和完善，大家面试可以参照考点复习，希望我们一起有点东西。</strong></p> \n</blockquote> \n<p>在CSS中，很容易在鼠标<code>hover</code>时进行更改，只需：</p> \n<pre><code>.item {\n  background: blue;\n}\n\n.item:hover {\n  background: green;\n}\n</code></pre> \n<p>在Vue中，它会变得更复杂一些，因为我们没有内置这个功能。我们必须自己实现这些。不过别担心，工作量不是很大。</p> \n<h2>监听正确的事件</h2> \n<p>那么，我们需要监听哪些事件？</p> \n<p>我们想知道什么时候鼠标悬停在元素上，这可以通过跟踪鼠标何时进入元素以及何时离开元素来确定。为了跟踪鼠标何时离开，可以使用<code>mouseleave</code>事件。</p> \n<p>检测鼠标何时进入可以通过相应的<code>mouseenter</code>事件来完成，但是我们不使用这个。</p> \n<p>原因是在深度嵌套 DOM 树上使用<code>mouseenter</code>时可能会出现严重的性能问题。这是因为<code>mouseenter</code>向输入的元素以及每个单独的祖先元素触发一个唯一的事件。</p> \n<p>那我们会用什么来代替呢？</p> \n<p>我们使用<code>mouseover</code>事件。</p> \n<p>二者的本质区别在于,<code>mouseenter</code>不会冒泡,简单的说,它不会被它本身的子元素的状态影响到.但是<code>mouseover</code>就会被它的子元素影响到,在触发子元素的时候,<code>mouseover</code>会冒泡触发它的父元素.(想要阻止<code>mouseover</code>的冒泡事件就用<code>mouseenter</code>)</p> \n<p>为了把知识点串联起来，我们使用Vue 事件侦听鼠标进入和离开时的状态，并相应地更新状态。</p> \n<pre><code>&lt;template&gt;\n  &lt;div\n    @mouseover=\"hover = true\"\n    @mouseleave=\"hover = false\"\n  /&gt;\n&lt;/template&gt;\n----------------------------------\n\nexport default {\n  data() {\n    return {\n      hover: false,\n    };\n  }\n}\n</code></pre> \n<p>现在通过变量 <code>hover</code> 就可以响应鼠标的进入和移出。</p> \n<h2>在鼠标悬停时显示一个元素</h2> \n<p>如果希望显示基于悬停状态的元素，可以将其与<code>v-if</code>指令配对</p> \n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;span\n      @mouseover=\"hover = true\"\n      @mouseleave=\"hover = false\"\n    &gt;\n      鼠标悬停时显示该内容\n    &lt;/span&gt;\n    &lt;span v-if=\"hover\"&gt;这里是秘密消息&lt;/span&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n-------------------------------------------------\n\nexport default {\n  data() {\n    return {\n      hover: false,\n    };\n  }\n}</code></pre> \n<h2>鼠标悬停时切换样式类</h2> \n<p>还可以做类似的事情来切换类</p> \n<pre><code>&lt;template&gt;\n  &lt;div&gt;\n    &lt;span\n      @mouseover=\"hover = true\"\n      @mouseleave=\"hover = false\"\n      :class=\"{ active: hover }\"\n    &gt;\n      Hover me to change the background!\n    &lt;/span&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n-------------------------------------------\n\nexport default {\n  data() {\n    return {\n      hover: false,\n    };\n  }\n}\n-------------------------------------------\n\n.active {\n  background: green;\n}\n</code></pre> \n<p>虽然这是可行的，但不是最好的解决方案。</p> \n<p>对于这种情况，最好使用CSS</p> \n<pre><code>&lt;template&gt;\n  &lt;span&gt;\n    Hover me to change the background!\n  &lt;/span&gt;\n&lt;/template&gt;\n\n----------------------------------------\n\nspan:hover {\n  background: green;\n}\n</code></pre> \n<h2>将鼠标悬停在一个Vue组件上</h2> \n<p>如果你想要使用一个Vue组件来实现这种行为，那么我们需要做一些轻微的修改。我们不能像以前那样听<code>mouseover</code>和<code>mouseleave</code>事件。</p> \n<p>如果Vue组件不发出那些事件，那么我们就不能监听它们。</p> \n<p>相反，我们可以添加<code>.native</code>事件修饰符来直接监听定制Vue组件上的DOM事件。</p> \n<pre><code>&lt;template&gt;\n  &lt;my-custom-component\n    @mouseover.native=\"hover = true\"\n    @mouseleave.native=\"hover = false\"\n  /&gt;\n&lt;/template&gt;\n--------------------------------------\nexport default {\n  data() {\n    return {\n      hover: false,\n    };\n  }\n}\n</code></pre> \n<p>使用<code>.native</code>，我们侦听本地DOM事件，而不是从Vue组件发出的事件。</p> \n<p>接着我们来看看如何在自定义组件中 实现 <code>v-model</code>。</p> \n<p>虽然<code>v-model</code>是向普通组件添加双向数据绑定的强大功能，但是如何向自己的自定义组件添加对<code>v-model</code>的支持并不总是那么容易，但其实很简单。</p> \n<h2>v-model 介绍</h2> \n<p>要了解如何在组件中实现<code>v-model</code>支持，需要了解它是如何工作的。虽然看起来很神奇，但<code>v-model= syncedProp</code>实际上是一个非常简单的简写:<code>value= syncedProp @input= syncedProp = arguments[0]</code> (或者 <code>value= syncedProp @input= syncedProp = $event.target</code>)。</p> \n<p>因此，要与<code>v-model</code>兼容，你的组件需要做的就是接受<code>:value</code>属性，并在用户更改值时发出<code>@input</code>事件。</p> \n<h2>基础事例</h2> \n<p>假设有一个日期选择器组件，该组件在一个对象中接受<code>month</code>和<code>year</code>的值，格式为：<code>{month：1，year：2017}</code>。 该组件需要传入两个属性值 <code>month</code> 和 <code>year</code>，，并通过<code>v-model</code>更新绑定对象。</p> \n<pre><code>// DatePicker.vue\n&lt;template&gt;\n  &lt;div class=\"date-picker\"&gt;\n    Month: &lt;input type=\"number\" ref=\"monthPicker\" :value=\"value.month\" @input=\"updateDate()\"/&gt;\n    Year: &lt;input type=\"number\" ref=\"yearPicker\" :value=\"value.year\" @input=\"updateDate()\"/&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  props: [\'value\'],\n\n  methods: {\n    updateDate() {\n      this.$emit(\'input\', {\n        month: +this.$refs.monthPicker.value,\n        year: +this.$refs.yearPicker.value\n      })\n    }\n  }\n};\n&lt;/script&gt;</code></pre> \n<p>使用方式：</p> \n<pre><code>// WrapperComponent.vue\n\n&lt;template&gt;\n  &lt;div class=\"wrapper\"&gt;\n    &lt;date-picker v-model=\"date\"&gt;&lt;/date-picker&gt;\n    &lt;p&gt;\n      Month: {{date.month}}\n      Year: {{date.year}}\n    &lt;/p&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nimport DatePicker from \'./DatePicker.vue\';\n\nexport default {\n  components: {\n    DatePicker\n  },\n\n  data() {\n    return {\n      date: {\n        month: 1,\n        year: 2017\n      }\n    }\n  }\n})\n&lt;/script&gt;\n</code></pre> \n<p>如上所看到的，它只是接受一个<code>:value</code>属性并发出一个带有更新日期的<code>@input</code>事件，一点也不复杂</p> \n<p><strong>大家都说简历没项目写，我就帮大家找了一个项目，还附赠<a href=\"https://github.com/qq449245884/xiaozhi/issues/210\" rel=\"nofollow noreferrer\">【搭建教程】</a>。</strong></p> \n<h2>高级用法</h2> \n<p>通过使用一个或多个计算属性，我们可以将输入数据(如字符串)反规范化为输入元素更容易处理的格式。这通常与更高级的定制组件一起使用，这些组件必须处理各种可能的输入格式，比如颜色选择器。</p> \n<p>对于日期选择器示例，假设日期传递的格式是<code>m/yyyy</code>结构的字符串。 通过使用计算属性（在本例中为<code>splitDate</code>），我们可以将输入字符串拆分为具有<code>month</code>和<code>year</code>属性的对象，同时仅对日期选择器组件进行最少的修改。</p> \n<pre><code>// StringyDatePicker.vue\n&lt;template&gt;\n  &lt;div class=\"date-picker\"&gt;\n    Month: &lt;input type=\"number\" ref=\"monthPicker\" :value=\"splitDate.month\" @input=\"updateDate()\"/&gt;\n    Year: &lt;input type=\"number\" ref=\"yearPicker\" :value=\"splitDate.year\" @input=\"updateDate()\"/&gt;\n  &lt;/div&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\nexport default {\n  props: [\'value\'],\n\n  computed: {\n    splitDate() {\n      const splitValueString = this.value.split(\'/\');\n\n       return {\n        month: splitValueString[0],\n        year: splitValueString[1]\n      }\n    }\n  },\n\n  methods: {\n    updateDate() {\n      const monthValue = this.$refs.monthPicker.value;\n      const yearValue = this.$refs.yearPicker.value;\n      this.$emit(\'input\', `${monthValue}/${yearValue}`);\n    }\n  }\n};\n&lt;/script&gt;</code></pre> \n<p>一旦熟悉了这里介绍的概念，可能会发现自己对任何和每个我们创建的接受用户输入的组件都使用了<code>v-model</code>。这是在自己的自定义组件中添加双向数据绑定支持的一种非常简单但功能强大的方法。</p> \n<hr> \n<p><strong>代码部署后可能存在的BUG没法实时知道，事后为了解决这些BUG，花了大量的时间进行log 调试，这边顺便给大家推荐一个好用的BUG监控工具 <a href=\"https://www.fundebug.com/?utm_source=xiaozhi\" rel=\"nofollow noreferrer\">Fundebug</a>。</strong></p> \n<p>原文：</p> \n<p><a href=\"https://alligator.io/vuejs/add-v-model-support/\" rel=\"nofollow noreferrer\">https://alligator.io/vuejs/ad...</a><br><a href=\"https://michaelnthiessen.com/hover-in-vue/\" rel=\"nofollow noreferrer\">https://michaelnthiessen.com/...</a></p> \n<hr> \n<h2>交流</h2> \n<p>文章每周持续更新，可以微信搜索「 大迁世界 」第一时间阅读和催更（比博客早一到两篇哟），本文 GitHub <a href=\"https://github.com/qq449245884/xiaozhi\" rel=\"nofollow noreferrer\">https://github.com/qq449245884/xiaozhi</a> 已经收录，整理了很多我的文档，欢迎Star和完善，大家面试可以参照考点复习，另外关注公众号，后台回复<strong>福利</strong>，即可看到福利，你懂的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020353567?w=800&amp;h=400\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p>', 'https://segmentfault.com/img/remote/1460000020353567?w=800&amp;h=400', '6fbfa4aaad3a43458f21c8acf0038ac5', '63c4e1e7ec204b43a62065a3ced4c2ce,b350d9c92c524bb4b9feedd40e5eebcd', '0', '3', '1', '2020-04-16 16:48:03', '2020-04-16 16:48:03');
INSERT INTO `tb_recommend` VALUES ('3d32fb4b96fe45f0bf0e4b931f6942e8', '云开发之实时数据推送：打造在线对战五子棋', '本次「云开发」公开课，将通过实战「在线对战五子棋」，一步步带领大家，在不借助后端的情况下，利用「小程序 ✖ 云开发」，独立完成一款微信小游戏的开发与上线。', '<blockquote>\n 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)：\n <br>「微信公众号：\n <strong>心谭博客</strong>」| \n <a href=\"https://xin-tan.com/\" rel=\"nofollow noreferrer\">xin-tan.com</a> | \n <a href=\"https://github.com/dongyuanxin/blog\" rel=\"nofollow noreferrer\">GitHub</a> \n</blockquote> \n<h2>1 项目概述</h2> \n<p>游戏开发，尤其是微信小游戏开发，是最近几年比较热门的话题。</p> \n<p>本次「云开发」公开课，将通过实战「在线对战五子棋」，一步步带领大家，在不借助后端的情况下，利用「小程序 ✖ 云开发」，独立完成一款微信小游戏的开发与上线。</p> \n<h2>2 任务目标</h2> \n<p>根据项目初始框架，阅读教程的同时，逐步完成棋盘绘制、音乐播放、玩家对战、输赢判定等功能，最终实现一个可以快乐玩耍的在线对战五子棋。</p> \n<p>在这个过程中，会了解到 Serverless 的一些概念，并且实际应用它们，比如：<strong>云数据库</strong>、<strong>云存储</strong>、<strong>云函数</strong>、<strong>增值能力</strong>。除了这些基本功能，还准备了更多的硬核概念与落地实践，比如：<strong>实时数据库</strong>、<strong>聚合搜索</strong>、<strong>权限控制</strong>。</p> \n<p>完成开发后，上传并且设置为体验版，欢迎邀请更多人来体验。</p> \n<h2>3 准备工作</h2> \n<p>从 <a href=\"https://github.com/TencentCloudBase/tcb-game-gomoku\" rel=\"nofollow noreferrer\">TencentCloudBase/tcb-game-gomoku</a> 中下载代码到本地：</p> \n<pre><code class=\"bash\">git clone https://github.com/TencentCloudBase/tcb-game-gomoku.git\ncd tcb-game-gomoku/</code></pre> \n<p>切换课程专用的 <code>minigame-study</code> 分支：</p> \n<pre><code class=\"bash\">git checkout minigame-study</code></pre> \n<p>⚠️<code>minigame</code>分支保存着「小游戏版」的完整代码，<code>miniprogram</code>分支保存着「小程序版」的完整代码。</p> \n<h2>4 游戏流程图</h2> \n<p>小游戏版本的核心放在了实时对战上，中间穿插应用了云开发的各个方面。如果想体验完整的流程与交互，请前往<a href=\"https://github.com/TencentCloudBase/tcb-game-gomoku/tree/miniprogram\" rel=\"nofollow noreferrer\"><code>miniprogram</code>分支</a>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218520?w=888&amp;h=1049\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>5 实战任务</h2> \n<h3>5.1 创建云开发与小游戏环境</h3> \n<p>1、打开微信 IDE，点击左侧的小游戏，选择右侧的导入项目，导入之前下载的「在线对战五子棋」的目录，AppID 修改为你已经注册好的小游戏 AppID。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218521?w=1628&amp;h=1104\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>2、进入后，点击上方的云开发按钮。如果之前没有开通过云开发，需要开通云开发，新开通的话需要等待 10 ～ 20 分钟。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218522?w=1168&amp;h=174\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>3、进入「云开发/数据库」，创建新的集合，新集合的名称是<code>rooms</code>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218524?w=2072&amp;h=662\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>4、进入「云开发/存储」，点击“上传文件”。上传的内容是<code>/static/</code>下的<code>bgm.mp3</code> 和 <code>fall.mp3</code>。之后的代码中会通过云存储的接口，请求文件的临时 url，这样做的目的是<strong>减少用户首次进入游戏加载的静态资源</strong>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304018\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>5.2 准备配置文件</h3> \n<p>创建配置文件：</p> \n<pre><code class=\"bash\">cp miniprogram/shared/config.example.js miniprogram/shared/config.js</code></pre> \n<p>将关键字段的信息，换成自己账号的信息即可：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304019\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>5.3 创建云开发接口</h3> \n<p>打开 <code>miniprogram/shared/cloud.js</code>，在里面初始化云开发能力，并且对外暴露云数据库以及聚合搜索的 API。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218527?w=1512&amp;h=1358\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>5.4 获取云存储资源的链接</h3> \n<p>为了减少用户首屏加载的静态资源，音乐资源并没有放在<code>miniprogram</code>目录下，而是放在了云存储中，通过调用云存储的 api 接口，来返回静态资源的临时链接。</p> \n<p>在 <code>miniprogram/modules/music.js</code>中，会调用资源接口，获取资源链接：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218528?w=1638&amp;h=1476\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><code>getTempFileURL</code>函数属于云开发相关，因此放在了 <code>miniprogram/shared/cloud.js</code>中。这里只需要临时链接<code>tempFileURL</code>属性，其它返回值直接过滤调即可。</p> \n<p>为了方便外面调用，promise 内部不再用 reject 抛错。对于错误异常，返回空字符串。这样，加载失败的资源不会影响正常资源的加载和 Promise.all 中逻辑进行。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304020\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>5.5 游戏进入与身份判断</h3> \n<p>根据前面的流程图我们可以看到，游戏玩家的身份是分为 owner 与 player。它们的含义如下：</p> \n<ul> \n <li>owner：玩家进入游戏后，查找是否有空闲房间，如果不存在空闲房间，那么就会主动创建新的空闲房间。那么对于新创建的房间，玩家就是 owner。</li> \n <li>player：玩家进入游戏后，查找是否有空闲房间，如果存在空闲房间，那么就加入空闲房间。那么对于空闲房间，玩家就是 player。</li> \n</ul> \n<p>判断的依据就是 <code>judgeIdentity</code> 方法中，读取云数据库集合中的 rooms 的记录。如果存在多个空闲房间，需要选取创建时间最近的一个房间。因此，这里需要用到「聚合搜索」的逻辑。</p> \n<p>聚合搜索的条件，在这里有 3 个：</p> \n<ol> \n <li>标记人数的字段，是否为 1</li> \n <li>创建时间倒叙排序</li> \n <li>只选择 1 个</li> \n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304021\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>5.6 创建新房间</h3> \n<p>在上述的身份判断函数逻辑中，如果聚合搜索查询的结果为空，说明没有空闲房间，玩家需要作为 owner 来创建新的房间，等待其它玩家加入。</p> \n<p>创建房间的逻辑就是将约定好的字段，放进云数据库的记录中。这些字段有：</p> \n<ul> \n <li>roomid&lt;<code>String</code>&gt;: 6 位房间号，<strong>唯一</strong> </li> \n <li>nextcolor&lt;<code>\"white\" | \"black\"</code>&gt;: 下一步是白棋/黑棋走</li> \n <li>chessmen&lt;<code>String</code>&gt;: 编码后的棋盘数据</li> \n <li>createTimestamp&lt;<code>String</code>&gt;: 记录创建时间戳，精确到 ms</li> \n <li>people&lt;<code>Number</code>&gt;: 房间人数</li> \n</ul> \n<p>是的，你可能注意到了，这里需要保证 roomid 是不重复的。因此本地生成的随机 roomid，需要先调用云数据库的查询接口，检测是否存在。如果存在，那么递归调用，重新生成随机字符串。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218531?w=1812&amp;h=1306\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>5.7 监听玩家进入</h3> \n<p>对于 owner 身份来说，除了要创建新房间，还需要在创建后监听 player 身份的玩家进入游戏。</p> \n<p>对于 player 身份的玩家进入游戏后，会更新记录中的 people 字段（1 =&gt; 2）。这时候就需要利用「实时数据库」的功能，监听远程记录的 people 字段变化。</p> \n<p>代码实现上，调用<code>watch</code>方法，并且传递<code>onChange</code>函数参数。一旦有任何风吹草动，都可以在<code>onChange</code>回调函数中获得。对于传递给回调函数的参数，有两个比较重要：</p> \n<ul> \n <li>docChanges&lt;<code>Array</code>&gt;: 数组中的每一项对应每条记录的变化类型，变化类型有 init、update、delete 等。</li> \n <li>docs&lt;<code>Array</code>&gt;: 数组中的每一项对应每条记录的当前数据。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218532?w=2022&amp;h=1326\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>5.8 越权更新字段</h3> \n<p>对于 player 身份来说，进入房间后，既不需要「创建新房间」，也不需要「监听玩家进入」。但需要更新记录的 people 字段。由于记录是由 owner 身份的玩家创建的，而云数据库只有以下 4 种权限：</p> \n<ul> \n <li>所有用户可读，仅创建者可读写</li> \n <li>仅创建者可读写</li> \n <li>所有用户可读</li> \n <li>所有用户不可读写</li> \n</ul> \n<p>以上 4 种权限，并没有「所有用户可读写」。因此，对于越权读写的情况，需要通过调用云函数来以“管理员”的权限实现。在 <code>cloudfunction</code> 中创建 <code>updateDoc</code> 云函数，接收前端传来的 collection、docid、data 字段。对于 data 字段来说，就是数据记录的最新更新数据。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304022\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在小游戏中，通过<code>wx.cloud.callFunction</code>来调用云函数。传入的 data 字段指明被调用的云函数，传入的 data 字段可以在云函数的回调函数的 event 参数中访问到（如上图所示）。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304023\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>5.9 落子更新逻辑</h3> \n<p>不论对于 player 还是 owner 身份，都需要处理落子的逻辑。落子逻辑中，下面的两种情况是属于无效落子：</p> \n<ol> \n <li>点击位置已经有棋子</li> \n <li>对方还未落子，目前依然处于等待情况</li> \n</ol> \n<p>对于以上两种情况，处理的逻辑分别是：</p> \n<ol> \n <li>棋盘状态保存在内部类中，调用落子的函数，会返回是否成功的字段标识</li> \n <li>只有监听到远程棋盘更新后，才会打开本地的锁，允许落子；落子后，会重新上锁</li> \n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218535?w=2284&amp;h=1088\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>落子成功后，要在本地判断是否胜利。如果胜利，需要调用退出的逻辑。但无论是否胜利，都要将本地的最新状态更新到云端。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304024\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>5.10 监听远程棋盘更新</h3> \n<p>不论对于 player 还是 owner 身份的玩家，都需要监听远程棋盘的更新逻辑。当远程棋盘字段更新时，本地根据最新的棋盘状态，重绘整个棋盘。并且进行输赢判定，如果可以判定输赢，则退出游戏；否则，打开本地的锁，玩家可以落子。</p> \n<p><strong>因为不同身份均需要监听，因此这一块的监听逻辑可以复用</strong>。<strong>不同的是，两种身份的监听启动时间不一样</strong>。owner 身份需要等待 player 身份玩家进入游戏后才开启棋盘监听；player 身份是更新了 people 字段后，开启棋盘监听。</p> \n<p>在监听逻辑中，需要判断远程更新的字段是否是 chessmen，这是通过前面提及的 dataType 来实现的。还徐哟啊判断记录中的 nextcolor 字段是否和本地的 color 一样，来决定是否打开本地的锁。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218537?w=2100&amp;h=1054\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>如果上述的两个条件均满足，则执行更新本地棋盘、判定输赢、打开本地锁的逻辑。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304025\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>5.11 游戏结束与退出</h3> \n<p>每次需要判定输赢的地方，如果可以判定输赢，那么都会走到游戏退出逻辑。退出的逻辑分为 2 个部分，第 1 个是给用户提示，第 2 个是调用云函数清空记录。</p> \n<p>第 1 个逻辑中用户提示，需要判定用户胜负状态：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218539?w=1226&amp;h=1030\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>第 2 个逻辑中清除记录的原因是为了方便调试，对于真正的业务场景，一般不会删除历史数据，方便问题定位。同时，这也是一个越权操作，需要调用云函数来实现。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020218540?w=1240&amp;h=966\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>6. 课程源码</h2> \n<ul> \n <li><a href=\"https://github.com/TencentCloudBase/tcb-game-gomoku/tree/minigame-study\" rel=\"nofollow noreferrer\">小游戏版·教程</a></li> \n <li><a href=\"https://github.com/TencentCloudBase/tcb-game-gomoku\" rel=\"nofollow noreferrer\">小游戏版本</a></li> \n <li><a href=\"https://github.com/TencentCloudBase/tcb-game-gomoku/tree/miniprogram\" rel=\"nofollow noreferrer\">小程序版本</a></li> \n</ul> \n<h2>7. 更多</h2> \n<blockquote>\n 专注前端与算法的系列干货分享，欢迎关注(¬‿¬)\n <br>\n <span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021304002\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span> \n</blockquote>', 'https://segmentfault.com/img/remote/1460000020218520?w=888&amp;h=1049', '5ca4567d892841b087fac5246effac40', 'd79254c4ca5e45dca9d484307c935281,b84d5a3e64644516915697f2c8409437,15941dc0af92453481b8a0626f963283,9424c753324d4c6198c85fff4f681dd4,83f62facb3b943ffa8e46abd1ebc64d9', '0', '3', '1', '2020-04-16 16:57:53', '2020-04-16 16:57:53');
INSERT INTO `tb_recommend` VALUES ('3d8244173bef45318e428061ecfc8ec1', '那些功能逆天，却鲜为人知的pandas骚操作', 'pandas有一种功能非常强大的方法，它就是accessor，可以将它理解为一种属性接口，通过它可以获得额外的方法。其实这样说还是很笼统，下面我们通过代码和实例来理解一下。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022271880\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<blockquote>\n 作者：东哥\n</blockquote> \n<p>pandas有些功能很逆天，但却鲜为人知，本篇给大家盘点一下。</p> \n<h2><strong>一、ACCESSOR</strong></h2> \n<p>pandas有一种功能非常强大的方法，它就是accessor，可以将它理解为一种属性接口，通过它可以获得额外的方法。其实这样说还是很笼统，下面我们通过代码和实例来理解一下。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;pd.Series._accessors  \n{\'cat\',&nbsp;\'str\',&nbsp;\'dt\'}</code></pre> \n<p>对于Series数据结构使用_accessors方法，可以得到了3个对象：cat，str，dt。</p> \n<ul> \n <li> <code>.cat</code>：用于分类数据（Categorical data）</li> \n <li> <code>.str</code>：用于字符数据（String Object data）</li> \n <li> <code>.dt</code>：用于时间数据（datetime-like data）</li> \n</ul> \n<p>下面我们依次看一下这三个对象是如何使用的。</p> \n<p><strong>str对象的使用</strong></p> \n<p>Series数据类型：str字符串</p> \n<h3>&nbsp;定义一个Series序列</h3> \n<pre><code>&gt;&gt;&gt;&nbsp;addr&nbsp;=&nbsp;pd.Series([  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'Washington,&nbsp;D.C.&nbsp;20003\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'Brooklyn,&nbsp;NY&nbsp;11211-1755\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'Omaha,&nbsp;NE&nbsp;68154\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'Pittsburgh,&nbsp;PA&nbsp;15211\'  \n...&nbsp;])&nbsp;  \n  \n&gt;&gt;&gt;&nbsp;addr.str.upper()  \n0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;WASHINGTON,&nbsp;D.C.&nbsp;20003  \n1&nbsp;&nbsp;&nbsp;&nbsp;BROOKLYN,&nbsp;NY&nbsp;11211-1755  \n2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;OMAHA,&nbsp;NE&nbsp;68154  \n3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;PITTSBURGH,&nbsp;PA&nbsp;15211  \ndtype:&nbsp;object  \n  \n&gt;&gt;&gt;&nbsp;addr.str.count(r\'\\d\')&nbsp;  \n0&nbsp;&nbsp;&nbsp;&nbsp;5  \n1&nbsp;&nbsp;&nbsp;&nbsp;9  \n2&nbsp;&nbsp;&nbsp;&nbsp;5  \n3&nbsp;&nbsp;&nbsp;&nbsp;5  \ndtype:&nbsp;int64</code></pre> \n<p>关于以上str对象的2个方法说明：</p> \n<ul> \n <li> <code>Series.str.upper</code>：将Series中所有字符串变为大写</li> \n <li> <code>Series.str.count</code>：对Series中所有字符串的个数进行计数</li> \n</ul> \n<p>其实不难发现，该用法的使用与Python中字符串的操作很相似。没错，在pandas中你一样可以这样简单的操作，而不同的是你操作的是一整列的字符串数据。仍然基于以上数据集，再看它的另一个操作：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;regex&nbsp;=&nbsp;(r\'(?P&lt;city&gt;[A-Za-z&nbsp;]+),&nbsp;\'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;一个或更多字母  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r\'(?P&lt;state&gt;[A-Z]{2})&nbsp;\'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;#&nbsp;两个大写字母  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;r\'(?P&lt;zip&gt;\\d{5}(?:-\\d{4})?)\')&nbsp;&nbsp;#&nbsp;可选的4个延伸数字  \n...  \n&gt;&gt;&gt;&nbsp;addr.str.replace(\'.\',&nbsp;\'\').str.extract(regex)  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;city&nbsp;state&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;zip  \n0&nbsp;&nbsp;Washington&nbsp;&nbsp;&nbsp;&nbsp;DC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20003  \n1&nbsp;&nbsp;&nbsp;&nbsp;Brooklyn&nbsp;&nbsp;&nbsp;&nbsp;NY&nbsp;&nbsp;11211-1755  \n2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Omaha&nbsp;&nbsp;&nbsp;&nbsp;NE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;68154  \n3&nbsp;&nbsp;Pittsburgh&nbsp;&nbsp;&nbsp;&nbsp;PA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15211</code></pre> \n<p>关于以上str对象的2个方法说明：</p> \n<ul> \n <li> <code>Series.str.replace</code>：将Series中指定字符串替换</li> \n <li> <code>Series.str.extract</code>：通过正则表达式提取字符串中的数据信息</li> \n</ul> \n<p>这个用法就有点复杂了，因为很明显看到，这是一个链式的用法。通过<code>replace</code>将&nbsp;<code>\" . \"</code> 替换为<code>\"\"</code>，即为空，紧接着又使用了3个正则表达式（分别对应city，state，zip）通过<code>extract</code>对数据进行了提取，并由原来的Series数据结构变为了DataFrame数据结构。</p> \n<p>当然，除了以上用法外，常用的属性和方法还有<code>.rstrip</code>，<code>.contains</code>，<code>split</code>等，我们通过下面代码查看一下<code>str</code>属性的完整列表：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;[i&nbsp;for&nbsp;i&nbsp;in&nbsp;dir(pd.Series.str)&nbsp;if&nbsp;not&nbsp;i.startswith(\'_\')]  \n[\'capitalize\',  \n&nbsp;\'cat\',  \n&nbsp;\'center\',  \n&nbsp;\'contains\',  \n&nbsp;\'count\',  \n&nbsp;\'decode\',  \n&nbsp;\'encode\',  \n&nbsp;\'endswith\',  \n&nbsp;\'extract\',  \n&nbsp;\'extractall\',  \n&nbsp;\'find\',  \n&nbsp;\'findall\',  \n&nbsp;\'get\',  \n&nbsp;\'get_dummies\',  \n&nbsp;\'index\',  \n&nbsp;\'isalnum\',  \n&nbsp;\'isalpha\',  \n&nbsp;\'isdecimal\',  \n&nbsp;\'isdigit\',  \n&nbsp;\'islower\',  \n&nbsp;\'isnumeric\',  \n&nbsp;\'isspace\',  \n&nbsp;\'istitle\',  \n&nbsp;\'isupper\',  \n&nbsp;\'join\',  \n&nbsp;\'len\',  \n&nbsp;\'ljust\',  \n&nbsp;\'lower\',  \n&nbsp;\'lstrip\',  \n&nbsp;\'match\',  \n&nbsp;\'normalize\',  \n&nbsp;\'pad\',  \n&nbsp;\'partition\',  \n&nbsp;\'repeat\',  \n&nbsp;\'replace\',  \n&nbsp;\'rfind\',  \n&nbsp;\'rindex\',  \n&nbsp;\'rjust\',  \n&nbsp;\'rpartition\',  \n&nbsp;\'rsplit\',  \n&nbsp;\'rstrip\',  \n&nbsp;\'slice\',  \n&nbsp;\'slice_replace\',  \n&nbsp;\'split\',  \n&nbsp;\'startswith\',  \n&nbsp;\'strip\',  \n&nbsp;\'swapcase\',  \n&nbsp;\'title\',  \n&nbsp;\'translate\',  \n&nbsp;\'upper\',  \n&nbsp;\'wrap\',  \n&nbsp;\'zfill\']</code></pre> \n<p>属性有很多，对于具体的用法，如果感兴趣可以自己进行摸索练习。</p> \n<p><strong>dt对象的使用</strong></p> \n<p>Series数据类型：datetime</p> \n<p>因为数据需要datetime类型，所以下面使用pandas的date_range()生成了一组日期datetime演示如何进行dt对象操作。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;daterng&nbsp;=&nbsp;pd.Series(pd.date_range(\'2017\',&nbsp;periods=9,&nbsp;freq=\'Q\'))  \n&gt;&gt;&gt;&nbsp;daterng  \n0&nbsp;&nbsp;&nbsp;2017-03-31  \n1&nbsp;&nbsp;&nbsp;2017-06-30  \n2&nbsp;&nbsp;&nbsp;2017-09-30  \n3&nbsp;&nbsp;&nbsp;2017-12-31  \n4&nbsp;&nbsp;&nbsp;2018-03-31  \n5&nbsp;&nbsp;&nbsp;2018-06-30  \n6&nbsp;&nbsp;&nbsp;2018-09-30  \n7&nbsp;&nbsp;&nbsp;2018-12-31  \n8&nbsp;&nbsp;&nbsp;2019-03-31  \ndtype:&nbsp;datetime64[ns]  \n  \n&gt;&gt;&gt;&nbsp;&nbsp;daterng.dt.day_name()  \n0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Friday  \n1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Friday  \n2&nbsp;&nbsp;&nbsp;&nbsp;Saturday  \n3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sunday  \n4&nbsp;&nbsp;&nbsp;&nbsp;Saturday  \n5&nbsp;&nbsp;&nbsp;&nbsp;Saturday  \n6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sunday  \n7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Monday  \n8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sunday  \ndtype:&nbsp;object  \n  \n&gt;&gt;&gt;&nbsp;#&nbsp;查看下半年  \n&gt;&gt;&gt;&nbsp;daterng\\[daterng.dt.quarter&nbsp;&gt;&nbsp;2]  \n2&nbsp;&nbsp;&nbsp;2017-09-30  \n3&nbsp;&nbsp;&nbsp;2017-12-31  \n6&nbsp;&nbsp;&nbsp;2018-09-30  \n7&nbsp;&nbsp;&nbsp;2018-12-31  \ndtype:&nbsp;datetime64[ns]  \n  \n&gt;&gt;&gt;&nbsp;daterng[daterng.dt.is_year_end]  \n3&nbsp;&nbsp;&nbsp;2017-12-31  \n7&nbsp;&nbsp;&nbsp;2018-12-31  \ndtype:&nbsp;datetime64[ns]</code></pre> \n<p>以上关于dt的3种方法说明：</p> \n<ul> \n <li> <code>Series.dt.day_name()</code>：从日期判断出所处星期数</li> \n <li> <code>Series.dt.quarter</code>：从日期判断所处季节</li> \n <li> <code>Series.dt.is_year_end</code>：从日期判断是否处在年底</li> \n</ul> \n<p>其它方法也都是基于datetime的一些变换，并通过变换来查看具体微观或者宏观日期。</p> \n<p><strong>cat对象的使用</strong></p> \n<p>Series数据类型：Category</p> \n<p>在说cat对象的使用前，先说一下<code>Category</code>这个数据类型，它的作用很强大。虽然我们没有经常性的在内存中运行上g的数据，但是我们也总会遇到执行几行代码会等待很久的情况。使用<code>Category</code>数据的一个好处就是：<strong>可以很好的节省在时间和空间的消耗。</strong>下面我们通过几个实例来学习一下。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;colors&nbsp;=&nbsp;pd.Series([  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'periwinkle\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'mint&nbsp;green\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'burnt&nbsp;orange\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'periwinkle\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'burnt&nbsp;orange\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'rose\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'rose\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'mint&nbsp;green\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'rose\',  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\'navy\'  \n...&nbsp;])  \n...  \n&gt;&gt;&gt;&nbsp;import&nbsp;sys  \n&gt;&gt;&gt;&nbsp;colors.apply(sys.getsizeof)  \n0&nbsp;&nbsp;&nbsp;&nbsp;59  \n1&nbsp;&nbsp;&nbsp;&nbsp;59  \n2&nbsp;&nbsp;&nbsp;&nbsp;61  \n3&nbsp;&nbsp;&nbsp;&nbsp;59  \n4&nbsp;&nbsp;&nbsp;&nbsp;61  \n5&nbsp;&nbsp;&nbsp;&nbsp;53  \n6&nbsp;&nbsp;&nbsp;&nbsp;53  \n7&nbsp;&nbsp;&nbsp;&nbsp;59  \n8&nbsp;&nbsp;&nbsp;&nbsp;53  \n9&nbsp;&nbsp;&nbsp;&nbsp;53  \ndtype:&nbsp;int64</code></pre> \n<p>上面我们通过使用<code>sys.getsizeof</code>来显示内存占用的情况，数字代表字节数。还有另一种计算内容占用的方法：<code>memory\\_usage()</code>，后面会使用。</p> \n<p>现在我们将上面<code>colors</code>的不重复值映射为一组整数，然后再看一下占用的内存。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;mapper&nbsp;=&nbsp;{v:&nbsp;k&nbsp;for&nbsp;k,&nbsp;v&nbsp;in&nbsp;enumerate(colors.unique())}  \n&gt;&gt;&gt;&nbsp;mapper  \n{\'periwinkle\':&nbsp;0,&nbsp;\'mint&nbsp;green\':&nbsp;1,&nbsp;\'burnt&nbsp;orange\':&nbsp;2,&nbsp;\'rose\':&nbsp;3,&nbsp;\'navy\':&nbsp;4}  \n  \n&gt;&gt;&gt;&nbsp;as_int&nbsp;=&nbsp;colors.map(mapper)  \n&gt;&gt;&gt;&nbsp;as_int  \n0&nbsp;&nbsp;&nbsp;&nbsp;0  \n1&nbsp;&nbsp;&nbsp;&nbsp;1  \n2&nbsp;&nbsp;&nbsp;&nbsp;2  \n3&nbsp;&nbsp;&nbsp;&nbsp;0  \n4&nbsp;&nbsp;&nbsp;&nbsp;2  \n5&nbsp;&nbsp;&nbsp;&nbsp;3  \n6&nbsp;&nbsp;&nbsp;&nbsp;3  \n7&nbsp;&nbsp;&nbsp;&nbsp;1  \n8&nbsp;&nbsp;&nbsp;&nbsp;3  \n9&nbsp;&nbsp;&nbsp;&nbsp;4  \ndtype:&nbsp;int64  \n  \n&gt;&gt;&gt;&nbsp;as_int.apply(sys.getsizeof)  \n0&nbsp;&nbsp;&nbsp;&nbsp;24  \n1&nbsp;&nbsp;&nbsp;&nbsp;28  \n2&nbsp;&nbsp;&nbsp;&nbsp;28  \n3&nbsp;&nbsp;&nbsp;&nbsp;24  \n4&nbsp;&nbsp;&nbsp;&nbsp;28  \n5&nbsp;&nbsp;&nbsp;&nbsp;28  \n6&nbsp;&nbsp;&nbsp;&nbsp;28  \n7&nbsp;&nbsp;&nbsp;&nbsp;28  \n8&nbsp;&nbsp;&nbsp;&nbsp;28  \n9&nbsp;&nbsp;&nbsp;&nbsp;28  \ndtype:&nbsp;int64</code></pre> \n<blockquote>\n 注：对于以上的整数值映射也可以使用更简单的\n <code>pd.factorize()</code>方法代替。\n</blockquote> \n<p>我们发现上面所占用的内存是使用object类型时的一半。其实，这种情况就类似于<code>Category data</code>类型内部的原理。</p> \n<p><strong>内存占用区别：</strong>Categorical所占用的内存与Categorical分类的数量和数据的长度成正比，相反，object所占用的内存则是一个常数乘以数据的长度。 </p> \n<p>下面是<code>object</code>内存使用和category内存使用的情况对比。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;colors.memory_usage(index=False,&nbsp;deep=True)  \n650  \n&gt;&gt;&gt;&nbsp;colors.astype(\'category\').memory_usage(index=False,&nbsp;deep=True)  \n495</code></pre> \n<p>上面结果是使用<code>object</code>和<code>Category</code>两种情况下内存的占用情况。我们发现效果并没有我们想象中的那么好。但是注意Category内存是成比例的，如果数据集的数据量很大，但不重复分类（unique）值很少的情况下，<strong>那么Category的内存占用可以节省达到10倍以上</strong>，比如下面数据量增大的情况：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;manycolors&nbsp;=&nbsp;colors.repeat(10)  \n&gt;&gt;&gt;&nbsp;len(manycolors)/manycolors.nunique()&nbsp;  \n20.0  \n  \n&gt;&gt;&gt;&nbsp;manycolors.memory_usage(index=False,&nbsp;deep=True)  \n6500  \n&gt;&gt;&gt;&nbsp;manycolors.astype(\'category\').memory_usage(index=False,&nbsp;deep=True)  \n585</code></pre> \n<p>可以看到，在数据量增加10倍以后，使用<code>Category</code>所占内容节省了10倍以上。</p> \n<p><strong>除了占用内存节省外，另一个额外的好处是计算效率有了很大的提升。</strong>因为对于<code>Category</code>类型的<code>Series</code>，str字符的操作发生在<code>.cat.categories</code>的非重复值上，而并非原Series上的所有元素上。也就是说对于每个非重复值都只做一次操作，然后再向与非重复值同类的值映射过去。</p> \n<p>对于<code>Category</code>的数据类型，可以使用<code>accesso</code>r的cat对象，以及相应的属性和方法来操作<code>Category</code>数据。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;ccolors&nbsp;=&nbsp;colors.astype(\'category\')  \n&gt;&gt;&gt;&nbsp;ccolors.cat.categories  \nIndex([\'burnt&nbsp;orange\',&nbsp;\'mint&nbsp;green\',&nbsp;\'navy\',&nbsp;\'periwinkle\',&nbsp;\'rose\'],&nbsp;dtype=\'object\')</code></pre> \n<p>实际上，对于开始的整数类型映射，可以先通过<code>reorder_categories</code>进行重新排序，然后再使用<code>cat.codes</code>来实现对整数的映射，来达到同样的效果。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;ccolors.cat.reorder_categories(mapper).cat.codes  \n0&nbsp;&nbsp;&nbsp;&nbsp;0  \n1&nbsp;&nbsp;&nbsp;&nbsp;1  \n2&nbsp;&nbsp;&nbsp;&nbsp;2  \n3&nbsp;&nbsp;&nbsp;&nbsp;0  \n4&nbsp;&nbsp;&nbsp;&nbsp;2  \n5&nbsp;&nbsp;&nbsp;&nbsp;3  \n6&nbsp;&nbsp;&nbsp;&nbsp;3  \n7&nbsp;&nbsp;&nbsp;&nbsp;1  \n8&nbsp;&nbsp;&nbsp;&nbsp;3  \n9&nbsp;&nbsp;&nbsp;&nbsp;4  \ndtype:&nbsp;int8</code></pre> \n<p>dtype类型是Numpy的<code>int8（-127~128）</code>。可以看出以上只需要一个单字节就可以在内存中包含所有的值。我们开始的做法默认使用了<code>int64</code>类型，然而通过<code>pandas</code>的使用可以很智能的将<code>Category</code>数据类型变为最小的类型。</p> \n<p>让我们来看一下cat还有什么其它的属性和方法可以使用。下面cat的这些属性基本都是关于查看和操作Category数据类型的。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;[i&nbsp;for&nbsp;i&nbsp;in&nbsp;dir(ccolors.cat)&nbsp;if&nbsp;not&nbsp;i.startswith(\'_\')]  \n[\'add_categories\',  \n&nbsp;\'as_ordered\',  \n&nbsp;\'as_unordered\',  \n&nbsp;\'categories\',  \n&nbsp;\'codes\',  \n&nbsp;\'ordered\',  \n&nbsp;\'remove_categories\',  \n&nbsp;\'remove_unused\\_categories\',  \n&nbsp;\'rename_categories\',  \n&nbsp;\'reorder_categories\',  \n&nbsp;\'set_categories\']</code></pre> \n<p>但是Category数据的使用不是很灵活。例如，插入一个之前没有的值，首先需要将这个值添加到.categories的容器中，然后再添加值。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;ccolors.iloc[5]&nbsp;=&nbsp;\'a&nbsp;new&nbsp;color\'  \n#&nbsp;...  \nValueError:&nbsp;Cannot&nbsp;setitem&nbsp;on&nbsp;a&nbsp;Categorical&nbsp;with&nbsp;a&nbsp;new&nbsp;category,  \nset&nbsp;the&nbsp;categories&nbsp;first  \n  \n&gt;&gt;&gt;&nbsp;ccolors&nbsp;=&nbsp;ccolors.cat.add\\_categories([\'a&nbsp;new&nbsp;color\'])  \n&gt;&gt;&gt;&nbsp;ccolors.iloc[5]&nbsp;=&nbsp;\'a&nbsp;new&nbsp;color\'&nbsp;&nbsp;</code></pre> \n<p>如果你想设置值或重塑数据，而非进行新的运算操作，那么Category类型不是那么有用。</p> \n<h2><strong>二、从clipboard剪切板载入数据</strong></h2> \n<p>当我们的数据存在excel表里，或者其它的IDE编辑器中的时候，我们想要通过pandas载入数据。我们通常的做法是先保存再载入，其实这样做起来十分繁琐。一个简单的方法就是使用<code>pd.read\\_clipboard()</code>&nbsp;直接从电脑的剪切板缓存区中提取数据。 </p> \n<p>这样我们就可以直接将结构数据转变为DataFrame或者Series了。excel表中数据是这样的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022271879\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在纯文本文件中，比如txt文件，是这样的：</p> \n<pre><code>a&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d  \n0&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;inf&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1/1/00  \n2&nbsp;&nbsp;&nbsp;7.389056099&nbsp;N/A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;5-Jan-13  \n4&nbsp;&nbsp;&nbsp;54.59815003&nbsp;nan&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7/24/18  \n6&nbsp;&nbsp;&nbsp;403.4287935&nbsp;None&nbsp;&nbsp;&nbsp;&nbsp;NaT</code></pre> \n<p>将上面excel或者txt中的数据选中然后复制，然后使用pandas的<code>read_clipboard()</code>即可完成到DataFrame的转换。<code>parse_dates</code>参数设置为\"d\"，可以自动识别日期，并调整为<code>xxxx-xx-xx</code>的格式。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;df&nbsp;=&nbsp;pd.read_clipboard(na_values=[None],&nbsp;parse_dates=[\'d\'])  \n&gt;&gt;&gt;&nbsp;df  \n&nbsp;&nbsp;&nbsp;a&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;b&nbsp;&nbsp;&nbsp;&nbsp;c&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;d  \n0&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;1.0000&nbsp;&nbsp;inf&nbsp;2000-01-01  \n1&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;7.3891&nbsp;&nbsp;NaN&nbsp;2013-01-05  \n2&nbsp;&nbsp;4&nbsp;&nbsp;&nbsp;54.5982&nbsp;&nbsp;NaN&nbsp;2018-07-24  \n3&nbsp;&nbsp;6&nbsp;&nbsp;403.4288&nbsp;&nbsp;NaN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;NaT  \n  \n&gt;&gt;&gt;&nbsp;df.dtypes  \na&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int64  \nb&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float64  \nc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;float64  \nd&nbsp;&nbsp;&nbsp;&nbsp;datetime64[ns]  \ndtype:&nbsp;object</code></pre> \n<h2>三、将pandas对象转换为“压缩”格式</h2> \n<p>在pandas中，我们可以直接将<code>objects</code>打包成为<code>gzip</code>, <code>bz2</code>, <code>zip</code>, or <code>xz</code>等压缩格式，而不必将没压缩的文件放在内存中然后进行转化。来看一个例子如何使用：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;abalone&nbsp;=&nbsp;pd.read_csv(url,&nbsp;usecols=[0,&nbsp;1,&nbsp;2,&nbsp;3,&nbsp;4,&nbsp;8],&nbsp;names=cols)  \n  \n&gt;&gt;&gt;&nbsp;abalone  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sex&nbsp;&nbsp;length&nbsp;&nbsp;&nbsp;diam&nbsp;&nbsp;height&nbsp;&nbsp;weight&nbsp;&nbsp;rings  \n0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.455&nbsp;&nbsp;0.365&nbsp;&nbsp;&nbsp;0.095&nbsp;&nbsp;0.5140&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;15  \n1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.350&nbsp;&nbsp;0.265&nbsp;&nbsp;&nbsp;0.090&nbsp;&nbsp;0.2255&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7  \n2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;0.530&nbsp;&nbsp;0.420&nbsp;&nbsp;&nbsp;0.135&nbsp;&nbsp;0.6770&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9  \n3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.440&nbsp;&nbsp;0.365&nbsp;&nbsp;&nbsp;0.125&nbsp;&nbsp;0.5160&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10  \n4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;0.330&nbsp;&nbsp;0.255&nbsp;&nbsp;&nbsp;0.080&nbsp;&nbsp;0.2050&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;7  \n5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;I&nbsp;&nbsp;&nbsp;0.425&nbsp;&nbsp;0.300&nbsp;&nbsp;&nbsp;0.095&nbsp;&nbsp;0.3515&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8  \n6&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;0.530&nbsp;&nbsp;0.415&nbsp;&nbsp;&nbsp;0.150&nbsp;&nbsp;0.7775&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;20  \n...&nbsp;&nbsp;&nbsp;..&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;...&nbsp;&nbsp;&nbsp;&nbsp;...  \n4170&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.550&nbsp;&nbsp;0.430&nbsp;&nbsp;&nbsp;0.130&nbsp;&nbsp;0.8395&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10  \n4171&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.560&nbsp;&nbsp;0.430&nbsp;&nbsp;&nbsp;0.155&nbsp;&nbsp;0.8675&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;8  \n4172&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;0.565&nbsp;&nbsp;0.450&nbsp;&nbsp;&nbsp;0.165&nbsp;&nbsp;0.8870&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;11  \n4173&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.590&nbsp;&nbsp;0.440&nbsp;&nbsp;&nbsp;0.135&nbsp;&nbsp;0.9660&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10  \n4174&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.600&nbsp;&nbsp;0.475&nbsp;&nbsp;&nbsp;0.205&nbsp;&nbsp;1.1760&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;9  \n4175&nbsp;&nbsp;&nbsp;F&nbsp;&nbsp;&nbsp;0.625&nbsp;&nbsp;0.485&nbsp;&nbsp;&nbsp;0.150&nbsp;&nbsp;1.0945&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;10  \n4176&nbsp;&nbsp;&nbsp;M&nbsp;&nbsp;&nbsp;0.710&nbsp;&nbsp;0.555&nbsp;&nbsp;&nbsp;0.195&nbsp;&nbsp;1.9485&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;12</code></pre> \n<p>导入文件，读取并存为<code>abalone</code>（DataFrame结构）。当我们要存为压缩的时候，简单的使用&nbsp;<code>to_json()</code>即可轻松完成转化过程。下面通过设置相应参数将<code>abalone</code>存为了<code>.gz</code>格式的压缩文件。</p> \n<pre><code>abalone.to_json(\'df.json.gz\',&nbsp;orient=\'records\',  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;lines=True,&nbsp;compression=\'gzip\')</code></pre> \n<p>如果我们想知道储存压缩文件的大小，可以通过内置模块os.path，使用getsize方法来查看文件的字节数。下面是两种格式储存文件的大小对比。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;import&nbsp;os.path  \n&gt;&gt;&gt;&nbsp;abalone.to_json(\'df.json\',&nbsp;orient=\'records\',&nbsp;lines=True)  \n&gt;&gt;&gt;&nbsp;os.path.getsize(\'df.json\')&nbsp;/&nbsp;os.path.getsize(\'df.json.gz\')  \n11.603035760226396</code></pre> \n<h2>四、使用\"测试模块\"制作伪数据</h2> \n<p>在pandas中，有一个测试模块可以帮助我们生成半真实（伪数据），并进行测试，它就是<code>util.testing</code>。下面同我们通过一个简单的例子看一下如何生成数据测试：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;import&nbsp;pandas.util.testing&nbsp;as&nbsp;tm  \n&gt;&gt;&gt;&nbsp;tm.N,&nbsp;tm.K&nbsp;=&nbsp;15,&nbsp;3&nbsp;&nbsp;#&nbsp;默认的行和列  \n  \n&gt;&gt;&gt;&nbsp;import&nbsp;numpy&nbsp;as&nbsp;np  \n&gt;&gt;&gt;&nbsp;np.random.seed(444)  \n  \n&gt;&gt;&gt;&nbsp;tm.makeTimeDataFrame(freq=\'M\').head()  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C  \n2000-01-31&nbsp;&nbsp;0.3574&nbsp;-0.8804&nbsp;&nbsp;0.2669  \n2000-02-29&nbsp;&nbsp;0.3775&nbsp;&nbsp;0.1526&nbsp;-0.4803  \n2000-03-31&nbsp;&nbsp;1.3823&nbsp;&nbsp;0.2503&nbsp;&nbsp;0.3008  \n2000-04-30&nbsp;&nbsp;1.1755&nbsp;&nbsp;0.0785&nbsp;-0.1791  \n2000-05-31&nbsp;-0.9393&nbsp;-0.9039&nbsp;&nbsp;1.1837  \n  \n&gt;&gt;&gt;&nbsp;tm.makeDataFrame().head()  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;B&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;C  \nnTLGGTiRHF&nbsp;-0.6228&nbsp;&nbsp;0.6459&nbsp;&nbsp;0.1251  \nWPBRn9jtsR&nbsp;-0.3187&nbsp;-0.8091&nbsp;&nbsp;1.1501  \n7B3wWfvuDA&nbsp;-1.9872&nbsp;-1.0795&nbsp;&nbsp;0.2987  \nyJ0BTjehH1&nbsp;&nbsp;0.8802&nbsp;&nbsp;0.7403&nbsp;-1.2154  \n0luaYUYvy1&nbsp;-0.9320&nbsp;&nbsp;1.2912&nbsp;-0.2907</code></pre> \n<p>上面简单的使用了</p> \n<p><code>makeTimeDataFrame</code>&nbsp;和&nbsp;<code>makeDataFrame</code>&nbsp;分别生成了一组时间数据和DataFrame的数据。但这只是其中的两个用法，关于<code>testing</code>中的方法有大概30多个，如果你想全部了解，可以通过查看dir获得：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;[i&nbsp;for&nbsp;i&nbsp;in&nbsp;dir(tm)&nbsp;if&nbsp;i.startswith(\'make\')]  \n[\'makeBoolIndex\',  \n&nbsp;\'makeCategoricalIndex\',  \n&nbsp;\'makeCustomDataframe\',  \n&nbsp;\'makeCustomIndex\',  \n&nbsp;#&nbsp;...,  \n&nbsp;\'makeTimeSeries\',  \n&nbsp;\'makeTimedeltaIndex\',  \n&nbsp;\'makeUIntIndex\',  \n&nbsp;\'makeUnicodeIndex\']</code></pre> \n<h2><strong>五、从列项中创建DatetimeIndex</strong></h2> \n<p>也许我们有的时候会遇到这样的情形（为了说明这种情情况，我使用了product进行交叉迭代的创建了一组关于时间的数据）：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;from&nbsp;itertools&nbsp;import&nbsp;product  \n&gt;&gt;&gt;&nbsp;datecols&nbsp;=&nbsp;[\'year\',&nbsp;\'month\',&nbsp;\'day\']  \n  \n&gt;&gt;&gt;&nbsp;df&nbsp;=&nbsp;pd.DataFrame(list(product([2017,&nbsp;2016],&nbsp;[1,&nbsp;2],&nbsp;[1,&nbsp;2,&nbsp;3])),  \n...&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;columns=datecols)  \n&gt;&gt;&gt;&nbsp;df[\'data\']&nbsp;=&nbsp;np.random.randn(len(df))  \n&gt;&gt;&gt;&nbsp;df  \n&nbsp;&nbsp;&nbsp;&nbsp;year&nbsp;&nbsp;month&nbsp;&nbsp;day&nbsp;&nbsp;&nbsp;&nbsp;data  \n0&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-0.0767  \n1&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-1.2798  \n2&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;0.4032  \n3&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;1.2377  \n4&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-0.2060  \n5&nbsp;&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;0.6187  \n6&nbsp;&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;2.3786  \n7&nbsp;&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-0.4730  \n8&nbsp;&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;-2.1505  \n9&nbsp;&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-0.6340  \n10&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;0.7964  \n11&nbsp;&nbsp;2016&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;0.0005</code></pre> \n<p>明显看到，列项中有year，month，day，它们分别在各个列中，而并非是一个完整日期。那么如何从这些列中将它们组合在一起并设置为新的<code>index</code>呢？ </p> \n<p>通过<code>to_datetime</code>的使用，我们就可以直接将年月日组合为一个完整的日期，然后赋给索引。代码如下：</p> \n<pre><code>&gt;&gt;&gt;&nbsp;df.index&nbsp;=&nbsp;pd.to_datetime(df[datecols])  \n&gt;&gt;&gt;&nbsp;df.head()  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;year&nbsp;&nbsp;month&nbsp;&nbsp;day&nbsp;&nbsp;&nbsp;&nbsp;data  \n2017-01-01&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;-0.0767  \n2017-01-02&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-1.2798  \n2017-01-03&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;3&nbsp;&nbsp;0.4032  \n2017-02-01&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;1.2377  \n2017-02-02&nbsp;&nbsp;2017&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;-0.2060</code></pre> \n<p>当然，你可以选择将原有的年月日列移除，只保留data数据列，然后<code>squeeze</code>转换为Series结构。</p> \n<pre><code>&gt;&gt;&gt;&nbsp;df&nbsp;=&nbsp;df.drop(datecols,&nbsp;axis=1).squeeze()  \n&gt;&gt;&gt;&nbsp;df.head()  \n2017-01-01&nbsp;&nbsp;&nbsp;-0.0767  \n2017-01-02&nbsp;&nbsp;&nbsp;-1.2798  \n2017-01-03&nbsp;&nbsp;&nbsp;&nbsp;0.4032  \n2017-02-01&nbsp;&nbsp;&nbsp;&nbsp;1.2377  \n2017-02-02&nbsp;&nbsp;&nbsp;-0.2060  \nName:&nbsp;data,&nbsp;dtype:&nbsp;float64  \n  \n&gt;&gt;&gt;&nbsp;df.index.dtype_str  \n\'datetime64[ns]</code></pre> \n<hr> \n<p>更多精彩内容请关注<strong>Python数据科学</strong></p>', 'https://segmentfault.com/img/remote/1460000022271880', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '43145b2d806a4c3e8bb30d20ef04d61b,6fa64cc90cb140feb9b431413237469f,c9c8ca5b55c44b598a25593a4a204e20', '0', '3', '1', '2020-04-16 16:47:16', '2020-04-16 16:47:16');
INSERT INTO `tb_recommend` VALUES ('3db9192af7c94b15994cb3f031bf5e4c', '互联网通信云 PaaS 选型 开发者必备指南', '几乎所有技术团队都经历过服务选型问题，在最常见的 3 大云服务交付模式（IaaS、PaaS、SaaS）中，PaaS 是目前市场上增速最快的交付模式，选型过程也是最令开发者头疼的。而相同问题往往不止一种解决方案，如何才...', '<p>几乎所有技术团队都经历过服务选型问题，在最常见的 3 大云服务交付模式（IaaS、PaaS、SaaS）中，PaaS 是目前市场上增速最快的交付模式，选型过程也是最令开发者头疼的。而相同问题往往不止一种解决方案，如何才能正确选择，少趟坑，是件烧脑的事情。那么我们究竟该如何做出正确的选择？下面就以 PaaS 层的互联网通信云服务为例，借助几个具有通用性的角度来告诉大家如何避坑。</p> \n<p><strong>一：功能的灵活性和易用性</strong></p> \n<p>互联网通信云服务通常是将 IM 和实时音视频技术封装成 SDK/API 交付给开发者使用，在 App 功能的开发中占据了非常重要的地位，特别是对于社交、直播等行业而言，通信能力就是命脉。如果选择了不适合或不能满足自己业务场景的功能，初期由于业务复杂程度和业务量都比较小，可能问题不会十分明显，但是到了后期这可能成为一个噩梦，会导致系统问题频发，极不稳定，甚至导致项目迭代举步维艰，有的团队会停止新功能的开发，专门修复 bug，给业务造成重大的经济损失。</p> \n<p>因此，寻找能够满足适合自身业务场景的产品，能够灵活地进行二次开发，同时支持多平台和开发语言，是开发者前期调研中需要考虑的首要问题。通常意义上来讲，SDK 接口的数量在一定程度上代表了可实现功能量级的多寡，SDK 接口越多，开发者在功能实现上就有更多的选择空间，可以根据不同接口的组合来打造符合自身产品思路的功能。</p> \n<p>但同时也要看到，有的服务商不断增加 SDK 接口数量，但这并不代表越多就一定越好，有可能让新接触的开发者越发混乱，无从选择。所以有些厂商直接将符合某一业务场景需求的十几个或几十个 SDK 接口，打包成一个解决方案供开发者使用，这样不仅避免了开发集成的复杂度，还提高了功能的易用性。</p> \n<p>此外，SDK 的体积也是一个需要注意的点，过大的 SDK 会造成最终 App 体积也随之变大，这对于用户的下载体验非常糟糕，需要避免。</p> \n<p><strong>二：开发工具的完备性</strong></p> \n<p>灵活的功能性确保了项目开发从一开始就能够走在正确的道路上。接下来要考虑的是真正进入项目实施阶段，开发工具的完备性。开发工具既包括开发文档、SDK 注释等基础性文档，也包括 Demo、视频教程等多种支持性工具。</p> \n<p>开发者在写代码的时候是很不喜欢被打断的，特别是一些基础性的开发问题，比如怎么创建 ID，怎么创建群组，有文档之后直接扔 URL 链接就行了。因此，一个易读易懂的技术开发文档将有助于 Coding 事半功倍。一个好的开发文档至少要做到结构简单、逻辑清晰。</p> \n<p>所谓结构简单就是用户能马上找到自己要查找的知识点在哪，分类清晰。有些文档爱用模棱两可的词，比如“1.常见问题”，“2.热点问题”，一旦开发中遇到了问题，无法快捷查找答案，所以就需要将具体问题合理归类。另一点是逻辑清晰，这样可以让开发者减少对业务和交互的思考，更专注于技术的逻辑与实现。</p> \n<p>除了开发文档外，SDK 注释是一种更简便的文档说明方式。不需要开发者翻阅大量的技术文档，通过完美的注释，直接在代码上就可以方便了解 SDK 功能。此外，还有 Demo 产品和视频教程等支持性工具，辅助开发者更好地理解和应用开发，避免不停的试错后才完成开发。</p> \n<p><strong>三：抗弱网环境和 QPS 承载能力的稳定性</strong></p> \n<p>产品稳定性至关重要，直接关乎用户体验。在地铁、电梯等相对密闭的弱网环境，常常面临信号不畅，App 稳定性失常、无法使用的问题。因此，开发者需要考虑的是，如果遭遇弱网环境，能不能在系统运行中通过最优算法实施智能调度，择优选择最佳链路进行用户无感知切换。</p> \n<p>在平时业务压力不大的情况下，系统看似运行的很平稳了，但是当遇到双十一、大型直播、春晚等特殊事件，瞬时的激增流量有可能直接导致系统瞬间崩塌，那么，开发者在一开始选择的时候，就需要考量 QPS 承载能力，要求服务商必须有应对高并发的能力。此外，还要考核消息到达率和准确率，一些 App 中，消息“半路失踪”，漏发、错序的事件时有发生，这些大概率都因为架构设计存在缺陷，是 App 使用者所无法容忍的。</p> \n<p>要规避上面的这些坑，需要有良好的系统架构做支撑。如果，开发者因为产品上线前的经验不足，导致产品在研发架构，或者风险漏洞方面存在隐患时，我们最好选择能够全程提供业务方案咨询和技术方案咨询服务的厂商，以他们的最佳实践帮助我们做出最优方案，在 App 上线前即规避可能存在的风险。</p> \n<p><strong>四：全球化能力</strong></p> \n<p>业务前景和技术前景也是开发人员应优先考虑的因素。比如初创企业优先布局在国内，但未来发展也许会出海，那么所选择的服务商就必须具备全球化服务能力。</p> \n<p>想要拥有稳定的全球通信能力，不仅要有基础 IaaS 架构的支持，还要有海外数据中心、多路动态节点及稳定的全球链路做支撑，才可以有效解决跨国、跨运营商、大规模用户访问导致的响应慢、丢包高、服务不稳定等诸多痛点。</p> \n<p>还有些服务商构建了私有加密协议的全球通信加速网络，针对性的进行全球链路优化，这对开发者来说，通信安全性和质量稳定性便有了双重保障。</p> \n<p><strong>五：服务</strong></p> \n<p>目前，绝大多数厂商都能给开发者提供便利的服务，以满足产品开发、上线前后以及产品运营阶段的各种需求。但也有极少数的厂商只提供 SDK 技术及开发文档，而后续无任何服务支持，这对开发者而言，当然不是一个好的选择。</p> \n<p>虽然，知名度高一点的通信云服务商都提供 7*24 小时的运维保障服务，但仍有服务意识的强弱之分。以客服工单为例，业界平均工单回复时间为 4-6 小时，而优质的服务商则可以做到 1 小时内回复。</p> \n<p>产品上线后，如果有自动故障排除工具类的服务支持，可以帮助开发者极大节省与厂商之间的沟通成本。除了这些工具类服务外，人的服务也是必备保障之一。比如，有的服务商从项目开发之前，便配备 CTO 或首席架构师级别的顶级技术团队进行全方位答疑，帮忙开发选择适合场景的技术架构和解决方案。还有的服务商，在项目上线运营时，针对可能出现的突发流量状态，通过人工方式帮开发者制定相应的保障方案，动态调整服务器部署，这样就可以有效地帮助开发者顺利避开“坑”点。</p> \n<p><strong>选型填“坑”后，最优性价比的胜出</strong></p> \n<p>价格将是选型过程中“最后的试金石”。通常来讲，选择好的技术和服务，意味着选择更多的成本投入，而在当下的复工复产期间，行业回暧需要过程，节省开支就成了企业发展中的头等大事，选型者往往因为价格因素，不得不退而求其次。</p> \n<p>对于正处于选型当口的企业和开发者而言，好消息来了。互联网通信云行业的领导者融云针对全体开发者推出了“199 元 IM 商用版首购限量开放”活动，充值优惠有效期为 2020 年 5 月 1 至 12 月 31 日。这是融云自成立以来，推出的优惠幅度最大的一次活动，特别一提的是，由于疫情期间，受 IaaS 层带宽资源成本均有提升等多重因素影响，加之确保最后一公里通信的稳定、可靠、安全，绝不降品质的执着，融云为此承担了巨大的成本负担。但是，活动仍然不惜打破成本底线，以最大优惠让利于开发者，誓为全行业复工“输血”。也是因为以上原因，本次活动限量名额 1000 个，额满即止。</p> \n<p>【 <a href=\"http://rong.io/B1Off\" rel=\"nofollow noreferrer\"><strong>点此了解更多活动详情！</strong></a>】</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFGJz\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"思否199海报.png\" title=\"思否199海报.png\"></span></p> \n<p><strong>结语</strong></p> \n<p>总体说来，互联网通信云 PaaS 平台越来越成熟的技术能力为开发者提供了极大便利。作为技术选型，开发者根据自己的业务需求和行业特性，通过对通信云厂商在技术、服务、全球化方面的全面考量，再结合价格进行综合判断，答案自然水落石出。</p>', 'https://segmentfault.com/img/bVbFGJz', '1c5851dc916d4e70a60f0c957f548876', 'ba4a5064430447f5a3a2eb9aae580758,a75d7c6da04041d5a9cf4dd7e270c3cf,944695fd251146a99e7298a08f69d2e2', '0', '3', '1', '2020-04-16 16:47:12', '2020-04-16 16:47:12');
INSERT INTO `tb_recommend` VALUES ('418929042dae4b7a9ec1fac92f29d635', 'Taro 小程序开发大型实战（四）：使用 Hooks 版的 Redux 实现应用状态管理（上篇）', '欢迎继续阅读《Taro 小程序开发大型实战》系列，前情回顾： 熟悉的 React，熟悉的 Hooks：我们用 React 和 Hooks 实现了一个非常简单的添加帖子的原型 多页面跳转和 Taro UI 组件库：我们用 Taro 自带的路由功能...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022164780\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>欢迎继续阅读《Taro 小程序开发大型实战》系列，前情回顾：</p> \n<ul> \n <li> <a href=\"https://segmentfault.com/a/1190000022091448\">熟悉的 React，熟悉的 Hooks</a>：我们用 React 和 Hooks 实现了一个非常简单的添加帖子的原型</li> \n <li> <a href=\"https://segmentfault.com/a/1190000022100581\">多页面跳转和 Taro UI 组件库</a>：我们用 Taro 自带的路由功能实现了多页面跳转，并用 Taro UI 组件库升级了应用界面</li> \n <li> <a href=\"https://segmentfault.com/a/1190000022151908\">实现微信和支付宝多端登录</a>：实现了微信、支付宝以及普通登录和退出登录</li> \n</ul> \n<p>如果你跟着敲到了这里，你一定会发现现在 的状态管理和数据流越来越臃肿，组件状态的更新非常复杂。在这一篇中，我们将开始用 Redux 重构，因为此次重构涉及的改动文件有点多，所以这一步使用 Redux 重构我们分两篇文章来讲解，这篇是上篇。</p> \n<p>如果你不熟悉 Redux，推荐阅读我们的《Redux 包教包会》系列教程：</p> \n<ul> \n <li><a href=\"https://segmentfault.com/a/1190000021999973\">Redux 包教包会（一）：解救 React 状态危机</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022027834\">Redux 包教包会（二）：趁热打铁，完全重构</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022108939\">Redux 包教包会（三）：各司其职，重拾初心</a></li> \n</ul> \n<p>如果你希望直接从这一步开始，请运行以下命令：</p> \n<pre><code class=\"bash\">git clone -b redux-start https://github.com/tuture-dev/ultra-club.git\ncd ultra-club</code></pre> \n<blockquote>\n 本文所涉及的源代码都放在了 \n <a href=\"https://github.com/tuture-dev/ultra-club\" rel=\"nofollow noreferrer\">Github</a> 上，如果您觉得我们写得还不错，希望您能给❤️这篇文章点赞+Github仓库加星❤️哦~\n</blockquote> \n<h2>双剑合璧：Hooks + Redux</h2> \n<p>写到这一步，我们发现状态已经有点多了，而且 <code>src/pages/mine/mine.jsx</code> 文件是众多状态的顶层组件，比如我们的普通登录按钮 <code>src/components/LoginButton/index.jsx</code> 组件和我们的 <code>src/components/Footer/index.jsx</code> 组件，我们通过点击普通登录按钮打开登录弹窗的状态 <code>isOpened</code> 需要在 <code>LoginButton</code> 里面进行操作，然后进而影响到 <code>Footer</code> 组件内的 <code>FloatLayout</code> 弹窗组件，像这种涉及到多个子组件进行通信，我们将状态保存到公共父组件中的方式在 React 中叫做 ”状态提升“。</p> \n<p>但是随着状态增多，状态提升的状态也随着增多，导致保存这些状态的父组件会臃肿不堪，而且每次状态的改变需要影响很多中间组件，带来极大的性能开销，这种状态管理的难题我们一般交给专门的状态管理容器 Redux 来做，而让 React 专注于渲染用户界面。</p> \n<p>Redux 不仅可以保证状态的可预测性，还能保证状态的变化只和对应的组件相关，不影响到无关的组件，关于 Redux 的详细剖析的实战教程可以参考图雀社区的：<a href=\"https://juejin.im/post/5df62cd8e51d4558270ef5ca\" rel=\"nofollow noreferrer\">Redux 包教包会系列文章</a>。</p> \n<p>在这一节中，我们将结合 React Hooks 和 Redux 来重构我们状态管理。</p> \n<h3>安装依赖</h3> \n<p>首先我们先来安装使用 Redux 必要的依赖：</p> \n<pre><code class=\"Bash\">$ yarn add redux @tarojs/redux @tarojs/redux-h5  redux-logger\n# 或者使用 npm\n$ npm install --save redux @tarojs/redux @tarojs/redux-h5 redux-logger</code></pre> \n<p>除了我们熟悉的 <code>redux</code> 依赖，以及用来打印 Action 的中间件 <code>redux-logger</code> 外，还有两个额外的包，这是因为在 Taro 中，Redux 原绑定库 <code>react-redux</code> 被替换成了 <code>@tarojs/redux</code> 和 <code>@tarojs/redux-h5</code>，前者用在小程序中，后者用在 H5 页面中，Taro 对原 <code>react-redux</code> 进行了封装并提供了与 react-redux API 几乎一致的包来让开发人员获得更加良好的开发体验。</p> \n<h3>创建 Redux Store</h3> \n<p>Redux 的三大核心概念为：Store，Action，Reducers：</p> \n<ul> \n <li>Store：保存着全局的状态，有着 ”数据的唯一真相来源之称“。</li> \n <li>Action：发起修改 Store 中保存状态的动作，是修改状态的唯一手段。</li> \n <li>Reducers：一个个的纯函数，用于响应 Action，对 Store 中的状态进行修改。</li> \n</ul> \n<p>好的，复习了一下 Redux 的概念之后，我们马上来创建 Store，Redux 的最佳实践推荐我们在将 Store 保存在 <code>store</code> 文件夹中，我们在 <code>src</code> 文件夹下面创建 <code>store</code> 文件夹，并在其中创建 <code>index.js</code> 来编写我们的 Store：</p> \n<pre><code class=\"js\">import { createStore, applyMiddleware } from \'redux\'\nimport { createLogger } from \'redux-logger\'\nimport rootReducer from \'../reducers\'\n\nconst middlewares = [createLogger()]\n\nexport default function configStore() {\n  const store = createStore(rootReducer, applyMiddleware(...middlewares))\n  return store\n}</code></pre> \n<p>可以看到，我们导出了一个 <code>configureStore</code> 函数，并在其中创建并返回 Store，这里我们用到了 <code>redux-logger</code> 中间件，用于在发起 Action 时，在控制台打印 Action 及其前后 Store 中的保存的状态信息。</p> \n<p>这里我们的 <code>createstore</code> 接收两个参数：<code>rootReducer</code> 和 <code>applyMiddleware(...middlewares)</code> 。</p> \n<p><code>rootReducer</code> 是响应 <code>action</code> 的 <code>reducer</code>，这里我们导出了一个 <code>rootReducer</code>，代表组合了所有的 <code>reducer</code> ，我们将在后面 \"组合 User 和 Post Reducer“ 中讲到它。</p> \n<p><code>createStore</code> 函数的第二个参数我们使用了 <code>redux</code> 为我们提供的工具函数 <code>applyMiddleware</code> 来在 Redux 中注入需要使用的中间件，因为它接收的参数是 <code>(args1, args2, args3, ..., argsn)</code> 的形式，所以这里我们用了数组展开运算符 <code>...</code> 来展开 <code>middlewares</code> 数组。</p> \n<h3>编写 User Reducer</h3> \n<p>创建完 Store 之后，我们接在来编写 Reducer。回到我们的页面逻辑，我们在底部有两个 Tab 栏，一个为 \"首页\"，一个为 \"我的\"，在 ”首页“ 里面主要是展示一列文章和允许添加文章等，在 ”我的“ 里面主要是允许用户进行登录并展示登录信息，所以整体上我们的逻辑有两类，我们分别将其命名为 <code>post</code> 和 <code>user</code>，接下来我们将创建处理这两类逻辑的 reducers。</p> \n<p>Reducer 的逻辑形如 <code>(state, action) =&gt; newState</code>，即接收上一步 state 以及修改 state 的动作 action，然后返回修改后的新的 state，它是一个纯函数，意味着我们不能突变的修改 state。</p> \n<p>推荐：</p> \n<pre><code class=\"JavaScript\">newState = { ...state, prop: newValue }</code></pre> \n<p>不推荐：</p> \n<pre><code class=\"JavaScript\">state.prop = newValue</code></pre> \n<p>Redux 推荐的最佳实践是创建独立的 <code>reducers</code> 文件夹，在里面保存我们的一个个 reducer 文件。我们在 <code>src</code> 文件夹下创建 <code>reducers</code> 文件夹，在里面创建 <code>user.js</code> 文件，并加入我们的 User Reducer 相应的内容如下：</p> \n<pre><code class=\"js\">import { SET_LOGIN_INFO, SET_IS_OPENED } from \'../constants/\'\n\nconst INITIAL_STATE = {\n  avatar: \'\',\n  nickName: \'\',\n  isOpened: false,\n}\n\nexport default function user(state = INITIAL_STATE, action) {\n  switch (action.type) {\n    case SET_IS_OPENED: {\n      const { isOpened } = action.payload\n\n      return { ...state, isOpened }\n    }\n\n    case SET_LOGIN_INFO: {\n      const { avatar, nickName } = action.payload\n\n      return { ...state, nickName, avatar }\n    }\n\n    default:\n      return state\n  }\n}</code></pre> \n<p>我们在 <code>user.js</code> 中申明了 User Reducer 的初始状态 <code>INITIAL_STATE</code>，并将它赋值给 <code>user</code> 函数 state 的默认值，它接收待响应的 action，在 <code>user</code> 函数内部就是一个 <code>switch</code> 语句根据 <code>action.type</code> 进行判断，然后执行相应的逻辑，这里我们主要有两个类型：<code>SET_IS_OPENED</code> 用于修改 <code>isOpened</code> 属性，<code>SET_LOGIN_INFO</code> 用于修改 <code>avatar</code> 和 <code>nickName</code> 属性，当 <code>switch</code> 语句中没有匹配到任何 <code>action.type</code> 值时，它返回原 state。</p> \n<blockquote> \n <strong>提示</strong>\n <p>根据 Redux 最近实践，这里的 <code>SET_IS_OPENED</code> 和 <code>SET_LOGIN_INFO</code> 常量一般保存到 <code>constants</code> 文件夹中，我们将马上创建它。这里使用常量而不是直接硬编码字符串的目的是为了代码的可维护性。</p> \n</blockquote> \n<p>接下来我们来创建 <code>src/reducer/user.js</code> 中会用到的常量，我们在 <code>src</code> 文件夹下创建 <code>constants</code> 文件夹，并在其中创建 <code>user.js</code> 文件，在其中添加内容如下：</p> \n<pre><code class=\"js\">export const SET_IS_OPENED = \'MODIFY_IS_OPENED\'\nexport const SET_LOGIN_INFO = \'SET_LOGIN_INFO\'</code></pre> \n<h3>编写 Post Reducer</h3> \n<p>为了响应 <code>post</code> 逻辑的状态修改，我们创建在 <code>src/reducers</code> 下创建 <code>post.js</code>，并在其中编写相应的内容如下：</p> \n<pre><code class=\"js\">import { SET_POSTS, SET_POST_FORM_IS_OPENED } from \'../constants/\'\n\nimport avatar from \'../images/avatar.png\'\n\nconst INITIAL_STATE = {\n  posts: [\n    {\n      title: \'泰罗奥特曼\',\n      content: \'泰罗是奥特之父和奥特之母唯一的亲生儿子\',\n      user: {\n        nickName: \'图雀酱\',\n        avatar,\n      },\n    },\n  ],\n  isOpened: false,\n}\n\nexport default function post(state = INITIAL_STATE, action) {\n  switch (action.type) {\n    case SET_POSTS: {\n      const { post } = action.payload\n      return { ...state, posts: state.posts.concat(post) }\n    }\n\n    case SET_POST_FORM_IS_OPENED: {\n      const { isOpened } = action.payload\n\n      return { ...state, isOpened }\n    }\n\n    default:\n      return state\n  }\n}</code></pre> \n<p>可以看到，Post Reducer 的形式和 User Reducer 类似，我们将之前需要多组件中共享的状态 <code>posts</code> 和 <code>isOpened</code> 提取出来保存在 <code>post</code> 的状态里，这里的 <code>post</code> 函数主要响应 <code>SET_POSTS</code> 逻辑，用于添加新的 <code>post</code> 到 <code>posts</code> 状态种，以及 <code>SET_POST_FORM_IS_OPENED</code> 逻辑，用户设置 <code>isOpened</code> 状态。</p> \n<p>接下来我们来创建 <code>src/reducer/post.js</code> 中会用到的常量，我们在 <code>src/constants</code> 文件夹下创建 <code>user.js</code> 文件，在其中添加内容如下：</p> \n<pre><code class=\"js\">export const SET_POSTS = \'SET_POSTS\'\nexport const SET_POST_FORM_IS_OPENED = \'SET_POST_FORM_IS_OPENED\'</code></pre> \n<p>眼尖的同学可能注意到了，我们在 <code>src/reducers/user.js</code> 和 <code>src/reducers/post.js</code> 中导入需要使用的常量时都是从 <code>../constants</code> 的形式，那是因为我们在 <code>src/constants</code> 文件夹下创建了一个 <code>index.js</code> 文件，用于统一导出所有的常量，这也是代码可维护性的一种尝试。</p> \n<pre><code class=\"js\">export * from \'./user\'\nexport * from \'./post\'</code></pre> \n<h3>组合 User 和 Post Reducer</h3> \n<p>我们在之前将整个全局的响应逻辑分别拆分到了 <code>src/reducers/user.js</code> 和 <code>src/reducers/post.js</code> 中，这使得我们可以把响应逻辑拆分到很多个很小的函数单元，极大增加了代码的可读性和可维护性。</p> \n<p>但最终我们还是要将这些拆分的逻辑组合成一个逻辑树，并将其作为参数传给 <code>createStore</code> 函数来使用。</p> \n<p>Redux 为我们提供了 <code>combineReducers</code> 来组合这些拆分的逻辑，我们在 <code>src/reducers</code> 文件夹下创建 <code>index.js</code> 文件，并在其中编写如下内容：</p> \n<pre><code class=\"js\">import { combineReducers } from \'redux\'\n\nimport user from \'./user\'\nimport post from \'./post\'\n\nexport default combineReducers({\n  user,\n  post,\n})</code></pre> \n<p>可以看到，我们导入了 <code>user.js</code> 和 <code>post.js</code>，并使用对象简介写法传给 <code>combineReducers</code> 函数并导出，通过 <code>combineReducers</code> 将逻辑进行组合并导出为 <code>rootReducer</code> 作为参数在我们的 <code>src/store/index.js</code> 的 <code>createStore</code> 函数中使用。</p> \n<p>这里的 <code>combineReducers</code> 函数主要完成两件事：</p> \n<ul> \n <li>组合 user Reducer 和 post Reducer 中的状态，并将其合并成一颗形如 <code>{ user, post }</code> 的状态树，其中 <code>user</code> 属性保存这 user Reducer 的状态，<code>post</code> 属性保存着 post Reducer 的状态。</li> \n <li>分发 Action，当组件中 <code>dispatch</code> 一个 Action，&nbsp;<code>combineReducers</code> 会遍历 user Reducer 和 post Reducer，当匹配到任一 Reducer 的 <code>switch</code> 语句时，就会响应这个 Action。</li> \n</ul> \n<blockquote> \n <strong>提示</strong>\n <p>我们将马上在之后讲解如何在组件中 <code>dispatch</code> Action。</p> \n</blockquote> \n<h3>整合 Redux 和 React</h3> \n<p>当我们编写了 reducers 创建了 store 之后，下一步要考虑的就是如何将 Redux 整合进 React，我们打开 <code>src/app.js</code>，对其中的内容作出如下修改：</p> \n<pre><code class=\"jsx\">import Taro, { Component } from \'@tarojs/taro\'\nimport { Provider } from \'@tarojs/redux\'\n\nimport configStore from \'./store\'\nimport Index from \'./pages/index\'\nimport \'./app.scss\'\n\n// ...\n\nconst store = configStore()\n\nclass App extends Component {\n  config = {\n    // ...\n  }\n\n  render() {\n    return (\n      &lt;Provider store={store}&gt;\n        &lt;Index /&gt;\n      &lt;/Provider&gt;\n    )\n  }\n}\n\nTaro.render(&lt;App /&gt;, document.getElementById(\'app\'))</code></pre> \n<p>可以看到，上面的内容主要修改了三部分：</p> \n<ul> \n <li>我们导入了 <code>configureStore</code>，并调用它获取 <code>store</code>。</li> \n <li>接着我们从 Redux 对应的 Taro 绑定库 <code>@tarojs/redux</code> 中导出 <code>Provider</code>，它架设起 Redux 和 React 交流的桥梁。</li> \n <li>最后我们用 <code>Provider</code> 包裹我们之前的根组件，并将 <code>store</code> 作为其属性传入，这样后续的组件就可以通过获取到 <code>store</code> 里面保存的状态。</li> \n</ul> \n<h3>Hooks 版的 Action 初尝鲜</h3> \n<p>准备好了 Store 和 Reducer，又整合了 Redux 和 React，是时候来体验一下 Redux 状态管理容器的先进性了，不过为了使用 Hooks 版本的 Action，这里我们先来讲一讲会用到的 Hooks。</p> \n<h4>useDispatch Hooks</h4> \n<p>这个 Hooks 返回 Redux store 的 <code>dispatch</code> 引用。你可以使用它来 dispatch actions。</p> \n<p>讲完 useDispatch Hooks，我们马上来实践一波，首先搞定我们 ”普通登录“ 的 Redux 化问题，让我们打开 <code>src/components/LoginButton/index.js</code>，对其中内容作出相应的修改如下：</p> \n<pre><code class=\"js\">import Taro from \'@tarojs/taro\'\nimport { AtButton } from \'taro-ui\'\nimport { useDispatch } from \'@tarojs/redux\'\n\nimport { SET_IS_OPENED } from \'../../constants\'\n\nexport default function LoginButton(props) {\n  const dispatch = useDispatch()\n\n  return (\n    &lt;AtButton\n      type=\"primary\"\n      onClick={() =&gt;\n        dispatch({ type: SET_IS_OPENED, payload: { isOpened: true } })\n      }\n    &gt;\n      普通登录\n    &lt;/AtButton&gt;\n  )\n}</code></pre> \n<p>可以看到，上面的内容主要有四块改动：</p> \n<ul> \n <li>首先我们从 <code>@tarojs/redux</code> 中导出 <code>useDispatch</code> API。</li> \n <li>接着我们从之前定义的常量文件中导出 <code>SET_IS_OPENED</code> 常量。</li> \n <li>然后，我们在 <code>LoginButton</code> 函数式组件中调用 <code>useDispatch</code> Hooks 来返回我们的 <code>dispatch</code> 函数，我们可以用它来 dispatch action 来修改 Redux store 的状态</li> \n <li>最后我们将 <code>AtButton</code> 的 <code>onClick</code> 接收的回调函数进行替换，当按钮点击时，我们发起一个 <code>type</code> 为 <code>SET_IS_OPENED</code> 的 action，并传递了一个 <code>payload</code> 参数，用于将 Redux store 里面对应的 <code>user</code> 属性中的 <code>isOpened</code> 修改为 <code>true</code>。</li> \n</ul> \n<p>搞定完 ”普通登录“，我们接着来收拾一下 ”微信登录“ 的逻辑，打开 <code>src/components/WeappLoginButton/index.js</code> 文件，对文件的内容作出如下修改：</p> \n<pre><code class=\"js\">import Taro, { useState } from \'@tarojs/taro\'\nimport { Button } from \'@tarojs/components\'\nimport { useDispatch } from \'@tarojs/redux\'\n\nimport \'./index.scss\'\nimport { SET_LOGIN_INFO } from \'../../constants\'\n\nexport default function WeappLoginButton(props) {\n  const [isLogin, setIsLogin] = useState(false)\n\n  const dispatch = useDispatch()\n\n  async function onGetUserInfo(e) {\n    setIsLogin(true)\n\n    const { avatarUrl, nickName } = e.detail.userInfo\n\n    await Taro.setStorage({\n      key: \'userInfo\',\n      data: { avatar: avatarUrl, nickName },\n    })\n\n    dispatch({\n      type: SET_LOGIN_INFO,\n      payload: {\n        avatar: avatarUrl,\n        nickName,\n      },\n    })\n\n    setIsLogin(false)\n  }\n\n  // return ...\n}</code></pre> \n<p>可以看到，上面的改动和之前在 ”普通登录“ 里面的改动类似：</p> \n<ul> \n <li>我们导出了 <code>useDispatch</code> 钩子</li> \n <li>导出了 <code>SET_LOGIN_INFO</code> 常量</li> \n <li>然后我们将之前调用父组件传下的 <code>setLoginInfo</code> 方法改成了 dispatch <code>type</code> 为 <code>SET_LOGIN_INFO</code> 的 action，因为我们的 <code>avatar</code> 和 <code>nickName</code> 状态已经在 <code>store</code> 中的 <code>user</code> 属性中定义了，所以我们修改也是需要通过 dispatch action 来修改，最后我们将之前定义在父组件中的 <code>Taro.setStorage</code> 设置缓存的方法移动到了子组件中，以保证相关信息的改动具有一致性。</li> \n</ul> \n<p>最后我们来搞定 ”支付宝登录“ 的 Redux 逻辑，打开 <code>src/components/AlipayLoginButton/index.js</code> 对文件内容作出对应的修改如下：</p> \n<pre><code class=\"js\">import Taro, { useState } from \'@tarojs/taro\'\nimport { Button } from \'@tarojs/components\'\nimport { useDispatch } from \'@tarojs/redux\'\n\nimport \'./index.scss\'\nimport { SET_LOGIN_INFO } from \'../../constants\'\n\nexport default function AlipayLoginButton(props) {\n  const [isLogin, setIsLogin] = useState(false)\n  const dispatch = useDispatch()\n\n  async function onGetAuthorize(res) {\n    setIsLogin(true)\n    try {\n      let userInfo = await Taro.getOpenUserInfo()\n\n      userInfo = JSON.parse(userInfo.response).response\n      const { avatar, nickName } = userInfo\n\n      await Taro.setStorage({\n        key: \'userInfo\',\n        data: { avatar, nickName },\n      })\n\n      dispatch({\n        type: SET_LOGIN_INFO,\n        payload: {\n          avatar,\n          nickName,\n        },\n      })\n    } catch (err) {\n      console.log(\'onGetAuthorize ERR: \', err)\n    }\n\n    setIsLogin(false)\n  }\n\n  // return ...\n}</code></pre> \n<p>可以看到，上面的改动和之前在 ”微信登录“ 里面的改动几乎一样，所以这里我们就不在重复讲解啦 :)</p> \n<h3>useSelector Hooks 来捧场</h3> \n<p>一路跟下来的同学可能有点明白我们正在使用 Redux 我们之前的代码，而我们重构的思路也是先从 <code>src/pages/mine/mine.jsx</code> 中的 <code>src/components/Header/index.jsx</code> 开始，搞定完 <code>Header.jsx</code> 里面的所有登录按钮之后，接下来应该就轮到 <code>Header.jsx</code> 内的最后一个组件 <code>src/components/LoggedMine/index.jsx</code> 了。</p> \n<p>因为在 <code>LoggedMine</code> 组件中我们要用到 useSelector Hooks，所以这里我们先来讲一下这个 Hooks。</p> \n<h4>useSelector Hooks</h4> \n<p><code>useSelector</code> 允许你使用 selector 函数从一个 Redux Store 中获取数据。</p> \n<p>Selector 函数大致相当于 <code>connect</code> 函数的 <code>mapStateToProps</code> 参数。Selector 会在组件每次渲染时调用。<code>useSelector</code> 同样会订阅 Redux store，在 Redux action 被 dispatch 时调用。</p> \n<p>但 <code>useSelector</code> 还是和 <code>mapStateToProps</code> 有一些不同：</p> \n<ul> \n <li>不像 <code>mapStateToProps</code> 只返回对象一样，Selector 可能会返回任何值。</li> \n <li>当一个 action dispatch 时，<code>useSelector</code> 会把 selector 的前后返回值做一次浅对比，如果不同，组件会强制更新。</li> \n <li>Selector 函数不接受 <code>ownProps</code> 参数。但 selector 可以通过闭包访问函数式组件传递下来的 props。</li> \n</ul> \n<p>好的，了解了 <code>useSelector</code> 的概念之后，我们马上来实操一下，打开 <code>src/components/LoggedMine/index.jsx</code> 文件，对其中的内容作出如下的修改：</p> \n<pre><code class=\"jsx\">import Taro from \'@tarojs/taro\'\nimport { View, Image } from \'@tarojs/components\'\nimport { useSelector } from \'@tarojs/redux\'\nimport { AtAvatar } from \'taro-ui\'\n\nimport \'./index.scss\'\n\nexport default function LoggedMine(props) {\n  const nickName = useSelector(state =&gt; state.user.nickName)\n  const avatar = useSelector(state =&gt; state.user.avatar)\n\n  function onImageClick() {\n    Taro.previewImage({\n      urls: [avatar],\n    })\n  }\n\n  return (\n    &lt;View className=\"logged-mine\"&gt;\n      {avatar ? (\n        &lt;Image src={avatar} className=\"mine-avatar\" onClick={onImageClick} /&gt;\n      ) : (\n        &lt;AtAvatar size=\"large\" circle text=\"雀\" /&gt;\n      )}\n      &lt;View className=\"mine-nickName\"&gt;{nickName}&lt;/View&gt;\n    &lt;/View&gt;\n  )\n}</code></pre> \n<p>可以看到，我们上面的代码主要有四处改动：</p> \n<ul> \n <li>首先我们从 <code>@tarojs/redux</code> 中导出了 <code>useSelector</code> Hooks。</li> \n <li>接着我们使用了两次 <code>useSelector</code> 分别从 Redux Store 里面获取了 <code>nickName</code> 和 <code>avatar</code>，它们位于 <code>state.user</code> 属性下。</li> \n <li>接着我们将之前从 <code>props</code> 里面获取到的 <code>nickName</code> 和 <code>avatar</code> 替换成我们从 Redux store 里面获取到状态，这里我们为了用户体验，从 <code>taro-ui</code> 中导出了一个 <code>AtAvatar</code> 组件用于展示在没有 <code>avatar</code> 时的默认头像。</li> \n <li>最后，在点击头像进行预览的 <code>onImageClick</code> 方法里面，我们使用从 Redux store 里面获取到的 <code>avatar</code>。</li> \n</ul> \n<p>是时候收割最后一波 ”韭菜“ 了，让我们彻底完成 <code>Header/index.js</code> 的 Redux 化，打开 <code>src/components/Header/index.js</code> ，对其中的内容做出相应的修改如下：</p> \n<pre><code class=\"js\">// ...\nimport { useSelector } from \'@tarojs/redux\'\n\n// import 各种组件 ...\n\nexport default function Header(props) {\n  const nickName = useSelector(state =&gt; state.user.nickName)\n\n  // 双取反来构造字符串对应的布尔值，用于标志此时是否用户已经登录\n  const isLogged = !!nickName\n\n  const isWeapp = Taro.getEnv() === Taro.ENV_TYPE.WEAPP\n  const isAlipay = Taro.getEnv() === Taro.ENV_TYPE.ALIPAY\n\n  return (\n    &lt;View className=\"user-box\"&gt;\n      &lt;AtMessage /&gt;\n      &lt;LoggedMine /&gt;\n      {!isLogged &amp;&amp; (\n        &lt;View className=\"login-button-box\"&gt;\n          &lt;LoginButton /&gt;\n          {isWeapp &amp;&amp; &lt;WeappLoginButton /&gt;}\n          {isAlipay &amp;&amp; &lt;AlipayLoginButton /&gt;}\n        &lt;/View&gt;\n      )}\n    &lt;/View&gt;\n  )\n}</code></pre> \n<p>可以看到，上面的代码主要有五处主要的变动：</p> \n<ul> \n <li>首先我们导出了 <code>useSelector</code> Hooks。</li> \n <li>接着我们使用 <code>useSelector</code> 中取到我们需要的 <code>nickName</code> 属性，用于进行双取反转换成布尔值 <code>isLogged</code>，表示是否登录。</li> \n <li>接着我们将之前从父组件获取的 <code>props.isLogged</code> 属性替换成新的从 <code>isLogged</code> 值</li> \n <li>接着，我们去掉 ”普通登录” 按钮上不再需要的 <code>handleClick</code> 属性和 “微信登录”、“支付宝登录” 上面不再需要的 <code>setLoginInfo</code> 属性。</li> \n <li>最后，我们去掉 <code>LoggedMine</code> 组件上不再需要的 <code>userInfo</code> 属性，因为我们已经在组件内部从使用 <code>useSelector</code> Hooks 从组件内部获取了。</li> \n</ul> \n<h3>小结</h3> \n<p>在这一篇文章中，我们讲解了 <code>user</code> 逻辑的状态管理的重构，受限于篇幅，我们的 <code>user</code> 逻辑还剩下 <code>Footer</code> 部分没有讲解，在下一篇中，我们将首先讲解使用 Hooks 版的 Redux 来重构 <code>Footer</code> 组件的状态管理，接着，我们再来讲解重构 <code>post</code> 部分的状态管理。</p> \n<blockquote>\n 想要学习更多精彩的实战技术教程？来\n <a href=\"https://tuture.co?utm_source=juejin_zhuanlan\" rel=\"nofollow noreferrer\">图雀社区</a>逛逛吧。\n <p>本文所涉及的源代码都放在了 <a href=\"https://github.com/tuture-dev/ultra-club\" rel=\"nofollow noreferrer\">Github</a> 上，如果您觉得我们写得还不错，希望您能给❤️这篇文章点赞+Github仓库加星❤️哦~</p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021974809\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p>', 'https://segmentfault.com/img/remote/1460000022164780', '6fbfa4aaad3a43458f21c8acf0038ac5', '3b375646301546259a8fb29d74ae4447,7506700dea5a42298b9ecb0ac0aaab41', '0', '3', '1', '2020-04-16 16:49:29', '2020-04-16 16:49:29');
INSERT INTO `tb_recommend` VALUES ('451979545df3493eaf524bec59fc1711', 'Taro Next H5 跨框架组件库架构演进与实践', '过去的 Taro 1 与 Taro 2 只能使用 React 语法进行开发，但下一代的 Taro 框架对整体架构进行了升级，支持使用 React、Vue、Nerv 等框架开发多端应用。', '<p>作者：凹凸曼 - JJ<br><a href=\"https://github.com/NervJS/taro\" rel=\"nofollow noreferrer\">Taro</a> 是一款多端开发框架。开发者只需编写一份代码，即可生成各小程序端、H5 以及 React Native 的应用。</p> \n<blockquote> \n <a href=\"http://taro-docs-in.jd.com/taro/next/docs/next/README.html\" rel=\"nofollow noreferrer\">Taro Next</a> 近期已发布 beta 版本，全面完善对小程序以及 H5 的支持，欢迎体验！\n</blockquote> \n<h2>背景</h2> \n<h3>Taro Next 将支持使用多框架开发</h3> \n<p>过去的 Taro 1 与 Taro 2 只能使用 React 语法进行开发，但下一代的 Taro 框架对整体架构进行了<a href=\"https://aotu.io/notes/2020/02/03/taro-next-alpha/\" rel=\"nofollow noreferrer\">升级</a>，支持使用 React、Vue、Nerv 等框架开发多端应用。</p> \n<p>为了支持使用多框架进行开发，Taro 需要对自身的各端适配能力进行改造。本文将重点介绍对 <strong>Taro H5 端组件库</strong>的改造工作。</p> \n<h3>Taro H5</h3> \n<p>Taro 遵循以微信小程序为主，其他小程序为辅的组件与 API 规范。</p> \n<p>但浏览器并没有小程序规范的组件与 API 可供使用，例如我们不能在浏览器上使用小程序的 <code>view</code> 组件和 <code>getSystemInfo</code> API。因此我们需要在 H5 端实现一套基于小程序规范的组件库和 API 库。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFYR3\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Taro H5 架构图\" title=\"Taro H5 架构图\"></span></p> \n<p>在 Taro 1 和 Taro 2 中，Taro H5 的组件库使用了 React 语法进行开发。但如果开发者在 Taro Next 中使用 Vue 开发 H5 应用，则不能和现有的 H5 组件库兼容。</p> \n<p>所以本文需要面对的核心问题就是：<strong>我们需要在 H5 端实现 React、Vue 等框架都可以使用的组件库</strong>。</p> \n<h3>方案选择</h3> \n<p>我们最先想到的是使用 Vue 再开发一套组件库，这样最为稳妥，工作量也没有特别大。</p> \n<p>但考虑到以下两点，我们遂放弃了此思路：</p> \n<ol> \n <li>组件库的可维护性和拓展性不足。每当有问题需要修复或新功能需要添加，我们需要分别对 React 和 Vue 版本的组件库进行改造。</li> \n <li>Taro Next 的目标是支持使用任意框架开发多端应用。倘若将来支持使用 Angular 等框架进行开发，那么我们需要再开发对应支持 Angular 等框架的组件库。</li> \n</ol> \n<p>那么是否存在着一种方案，使得只用一份代码构建的组件库能兼容所有的 web 开发框架呢？</p> \n<p>答案就是 <strong>Web Components</strong>。</p> \n<p>但在组件库改造为 Web Components 的过程并不是一帆风顺的，我们也遇到了不少的问题，故借此文向大家娓娓道来。</p> \n<h2>Web Components 简介</h2> \n<p><a href=\"https://www.webcomponents.org/introduction\" rel=\"nofollow noreferrer\">Web Components</a> 由一系列的技术规范所组成，它让开发者可以开发出浏览器原生支持的组件。</p> \n<h3>技术规范</h3> \n<p>Web Components 的主要技术规范为：</p> \n<ul> \n <li>Custom Elements</li> \n <li>Shadow DOM</li> \n <li>HTML Template</li> \n</ul> \n<p>Custom Elements 让开发者可以自定义带有特定行为的 HTML 标签。</p> \n<p>Shadow DOM 对标签内的结构和样式进行一层包装。</p> \n<p><code>&lt;template&gt;</code> 标签为 Web Components 提供复用性，还可以配合 <code>&lt;slot&gt;</code> 标签提供灵活性。</p> \n<h3>示例</h3> \n<p>定义模板：</p> \n<pre><code class=\"html\">&lt;template id=\"template\"&gt;\n  &lt;h1&gt;Hello World!&lt;/h1&gt;\n&lt;/template&gt;</code></pre> \n<p>构造 Custom Element：</p> \n<pre><code class=\"js\">class App extends HTMLElement {\n  constructor () {\n    super(...arguments)\n\n    // 开启 Shadow DOM\n    const shadowRoot = this.attachShadow({ mode: \'open\' })\n\n    // 复用 &lt;template&gt; 定义好的结构\n    const template = document.querySelector(\'#template\')\n    const node = template.content.cloneNode(true)\n    shadowRoot.appendChild(node)\n  }\n}\nwindow.customElements.define(\'my-app\', App)</code></pre> \n<p>使用：</p> \n<pre><code class=\"html\">&lt;my-app&gt;&lt;/my-app&gt;</code></pre> \n<h2>Stencil</h2> \n<p>使用原生语法去编写 Web Components 相当繁琐，因此我们需要一个框架帮助我们提高开发效率和开发体验。</p> \n<p>业界已经有很多成熟的 <a href=\"https://www.webcomponents.org/libraries\" rel=\"nofollow noreferrer\">Web Components 框架</a>，一番比较后我们最终选择了 <a href=\"https://stenciljs.com/docs/introduction\" rel=\"nofollow noreferrer\">Stencil</a>，原因有二：</p> \n<ol> \n <li>Stencil 由 Ionic 团队打造，被用于构建 Ionic 的组件库，证明经受过业界考验。</li> \n <li>Stencil 支持 JSX，能减少现有组件库的迁移成本。</li> \n</ol> \n<p>Stencil 是一个可以生成 Web Components 的编译器。它糅合了业界前端框架的一些优秀概念，如支持 Typescript、JSX、虚拟 DOM 等。</p> \n<h3>示例：</h3> \n<p>创建 Stencil Component：</p> \n<pre><code class=\"jsx\">import { Component, Prop, State, h } from \'@stencil/core\'\n\n@Component({\n  tag: \'my-component\'\n})\nexport class MyComponent {\n  @Prop() first = \'\'\n  @State() last = \'JS\'\n\n  componentDidLoad () {\n    console.log(\'load\')\n  }\n\n  render () {\n    return (\n      &lt;div&gt;\n        Hello, my name is {this.first} {this.last}\n      &lt;/div&gt;\n    )\n  }\n}</code></pre> \n<p>使用组件：</p> \n<pre><code class=\"html\">&lt;my-component first=\'Taro\' /&gt;</code></pre> \n<h2>在 React 与 Vue 中使用 Stencil</h2> \n<p>到目前为止一切都那么美好：使用 Stencil 编写出 Web Components，即可以在 React 和 Vue 中直接使用它们。</p> \n<p>但实际使用上却会出现一些问题，<a href=\"https://custom-elements-everywhere.com/\" rel=\"nofollow noreferrer\">Custom Elements Everywhere</a> 通过一系列的测试用例，罗列出业界前端框架对 Web Components 的兼容问题及相关 issues。下面将简单介绍 Taro H5 组件库分别对 React 和 Vue 的兼容工作。</p> \n<h3>兼容 React</h3> \n<h4>1. Props</h4> \n<h5>1.1 问题</h5> \n<p>React 使用 <code>setAttribute</code> 的形式给 Web Components 传递参数。当参数为原始类型时是可以运行的，但是如果参数为对象或数组时，由于 HTML 元素的 attribute 值只能为字符串或 null，最终给 WebComponents 设置的 attribute 会是 <code>attr=\"[object Object]\"</code>。</p> \n<blockquote>\n attribute 与 property \n <a href=\"https://stackoverflow.com/questions/6003819/what-is-the-difference-between-properties-and-attributes-in-html#answer-6004028\" rel=\"nofollow noreferrer\">区别</a> \n</blockquote> \n<h5>1.2 解决方案</h5> \n<p>采用 <strong>DOM Property</strong> 的方法传参。</p> \n<p>我们可以把 Web Components 包装一层高阶组件，把高阶组件上的 props 设置为 Web Components 的 property：</p> \n<pre><code class=\"js\">const reactifyWebComponent = WC =&gt; {\n  return class extends React.Component {\n    ref = React.createRef()\n\n    update () {\n      Object.entries(this.props).forEach(([prop, val]) =&gt; {\n        if (prop === \'children\' || prop === \'dangerouslySetInnerHTML\') {\n          return\n        }\n        if (prop === \'style\' &amp;&amp; val &amp;&amp; typeof val === \'object\') {\n          for (const key in val) {\n            this.ref.current.style[key] = val[key]\n          }\n          return\n        }\n        this.ref.current[prop] = val\n      })\n    }\n\n    componentDidUpdate () {\n      this.update()\n    }\n\n    componentDidMount () {\n      this.update()\n    }\n\n    render () {\n      const { children, dangerouslySetInnerHTML } = this.props\n      return React.createElement(WC, {\n        ref: this.ref,\n        dangerouslySetInnerHTML\n      }, children)\n    }\n  }\n}\n\nconst MyComponent = reactifyWebComponent(\'my-component\')</code></pre> \n<p>注意：</p> \n<ul> \n <li>children、dangerouslySetInnerHTML 属性需要透传。</li> \n <li>React 中 style 属性值可以接受对象形式，这里需要额外处理。</li> \n</ul> \n<h4>2. Events</h4> \n<h5>2.1 问题</h5> \n<p>因为 React 有一套<a href=\"https://reactjs.org/docs/events.html\" rel=\"nofollow noreferrer\">合成事件系统</a>，所以它不能监听到 Web Components 发出的自定义事件。</p> \n<p>以下 Web Component 的 onLongPress 回调不会被触发：</p> \n<pre><code class=\"html\">&lt;my-view onLongPress={onLongPress}&gt;view&lt;/my-view&gt;</code></pre> \n<h5>2.2 解决方案</h5> \n<p>通过 ref 取得 Web Component 元素，手动 <strong>addEventListener</strong> 绑定事件。</p> \n<p>改造上述的高阶组件：</p> \n<pre><code class=\"js\">const reactifyWebComponent = WC =&gt; {\n  return class Index extends React.Component {\n    ref = React.createRef()\n    eventHandlers = []\n\n    update () {\n      this.clearEventHandlers()\n\n      Object.entries(this.props).forEach(([prop, val]) =&gt; {\n        if (typeof val === \'function\' &amp;&amp; prop.match(/^on[A-Z]/)) {\n          const event = prop.substr(2).toLowerCase()\n          this.eventHandlers.push([event, val])\n          return this.ref.current.addEventListener(event, val)\n        }\n\n        ...\n      })\n    }\n\n    clearEventHandlers () {\n      this.eventHandlers.forEach(([event, handler]) =&gt; {\n        this.ref.current.removeEventListener(event, handler)\n      })\n      this.eventHandlers = []\n    }\n\n    componentWillUnmount () {\n      this.clearEventHandlers()\n    }\n\n    ...\n  }\n}</code></pre> \n<h4>3. Ref</h4> \n<h5>3.1 问题</h5> \n<p>我们为了解决 Props 和 Events 的问题，引入了高阶组件。那么当开发者向高阶组件传入 ref 时，获取到的其实是高阶组件，但我们希望开发者能获取到对应的 Web Component。</p> \n<p>domRef 会获取到 <code>MyComponent</code>，而不是 <code>&lt;my-component&gt;&lt;/my-component&gt;</code></p> \n<pre><code class=\"jsx\">&lt;MyComponent ref={domRef} /&gt;</code></pre> \n<h5>3.2 解决方案</h5> \n<p>使用 <a href=\"https://reactjs.org/docs/forwarding-refs.html#forwarding-refs-to-dom-components\" rel=\"nofollow noreferrer\">forwardRef</a> 传递 ref。</p> \n<p>改造上述的高阶组件为 forwardRef 形式：</p> \n<pre><code class=\"js\">const reactifyWebComponent = WC =&gt; {\n  class Index extends React.Component {\n    ...\n\n    render () {\n      const { children, forwardRef } = this.props\n      return React.createElement(WC, {\n        ref: forwardRef\n      }, children)\n    }\n  }\n  return React.forwardRef((props, ref) =&gt; (\n    React.createElement(Index, { ...props, forwardRef: ref })\n  ))\n}</code></pre> \n<h4>4. Host\'s className</h4> \n<h5>4.1 问题</h5> \n<p>在 Stencil 里我们可以使用 Host 组件为 host element 添加类名。</p> \n<pre><code class=\"js\">import { Component, Host, h } from \'@stencil/core\';\n\n@Component({\n  tag: \'todo-list\'\n})\nexport class TodoList {\n  render () {\n    return (\n      &lt;Host class=\'todo-list\'&gt;\n        &lt;div&gt;todo&lt;/div&gt;\n      &lt;/Host&gt;\n    )\n  }\n}</code></pre> \n<p>然后在使用 <code>&lt;todo-list&gt;</code> 元素时会展示我们内置的类名 “todo-list” 和 Stencil 自动加入的类名 “hydrated”：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFYR4\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>但如果我们在使用时设置了动态类名，如： <code>&lt;todo-list class={this.state.cls}&gt;</code>。那么在动态类名更新时，则会把内置的类名 “todo-list” 和 “hydrated” 抹除掉。</p> \n<p><strong>关于类名 “hydrated”：</strong></p> \n<p>Stencil 会为所有 Web Components 加上 <code>visibility: hidden;</code> 的样式。然后在各 Web Component 初始化完成后加入类名 “hydrated”，将 <code>visibility</code> 改为 <code>inherit</code>。如果 “hydrated” 被抹除掉，Web Components 将不可见。</p> \n<p>因此我们需要保证在类名更新时不会覆盖 Web Components 的内置类名。</p> \n<h5>4.2 解决方案</h5> \n<p>高阶组件在使用 ref 为 Web Component 设置 className 属性时，对内置 class 进行合并。</p> \n<p>改造上述的高阶组件：</p> \n<pre><code class=\"js\">const reactifyWebComponent = WC =&gt; {\n  class Index extends React.Component {\n    update (prevProps) {\n      Object.entries(this.props).forEach(([prop, val]) =&gt; {\n        if (prop.toLowerCase() === \'classname\') {\n          this.ref.current.className = prevProps\n            // getClassName 在保留内置类名的情况下，返回最新的类名\n            ? getClassName(this.ref.current, prevProps, this.props)\n            : val\n          return\n        }\n\n        ...\n      })\n    }\n\n    componentDidUpdate (prevProps) {\n      this.update(prevProps)\n    }\n\n    componentDidMount () {\n      this.update()\n    }\n\n    ...\n  }\n  return React.forwardRef((props, ref) =&gt; (\n    React.createElement(Index, { ...props, forwardRef: ref })\n  ))\n}</code></pre> \n<h3>兼容 Vue</h3> \n<p>不同于 React，虽然 Vue 在传递参数给 Web Components 时也是采用 <code>setAttribute</code> 的方式，但 v-bind 指令提供了 <a href=\"https://cn.vuejs.org/v2/api/#v-bind\" rel=\"nofollow noreferrer\">.prop</a> 修饰符，它可以将参数作为 DOM property 来绑定。另外 Vue 也能监听 Web Components 发出的自定义事件。</p> \n<p>因此 Vue 在 Props 和 Events 两个问题上都不需要额外处理，但在与 Stencil 的配合上还是有一些兼容问题，接下来将列出主要的三点。</p> \n<h4>1. Host\'s className</h4> \n<h5>1.1 问题</h5> \n<p>同上文兼容 React 第四部分，在 Vue 中更新 host element 的 class，也会覆盖内置 class。</p> \n<h5>1.2 解决方案</h5> \n<p>同样的思路，需要在 Web Components 上包装一层 Vue 的自定义组件。</p> \n<pre><code class=\"js\">function createComponent (name, classNames = []) {\n  return {\n    name,\n    computed: {\n      listeners () {\n        return { ...this.$listeners }\n      }\n    },\n    render (createElement) {\n      return createElement(name, {\n        class: [\'hydrated\', ...classNames],\n        on: this.listeners\n      }, this.$slots.default)\n    }\n  }\n}\n\nVue.component(\'todo-list\', createComponent(\'todo-list\', [\'todo-list\']))</code></pre> \n<p>注意：</p> \n<ul> \n <li>我们在自定义组件中重复声明了 Web Component 该有的内置类名。后续开发者为自定义组件设置类名时，Vue 将会<a href=\"https://cn.vuejs.org/v2/guide/components-props.html#%E6%9B%BF%E6%8D%A2-%E5%90%88%E5%B9%B6%E5%B7%B2%E6%9C%89%E7%9A%84-Attribute\" rel=\"nofollow noreferrer\">自动对类名进行合并</a>。</li> \n <li>需要把自定义组件上绑定的事件通过 <a href=\"https://cn.vuejs.org/v2/guide/components-custom-events.html#%E5%B0%86%E5%8E%9F%E7%94%9F%E4%BA%8B%E4%BB%B6%E7%BB%91%E5%AE%9A%E5%88%B0%E7%BB%84%E4%BB%B6\" rel=\"nofollow noreferrer\">&amp;dollar;listeners</a> 透传给 Web Component。</li> \n</ul> \n<h4>2. Ref</h4> \n<h5>2.1 问题</h5> \n<p>为了解决问题 1，我们给 Vue 中的 Web Components 都包装了一层自定义组件。同样地，开发者在使用 ref 时取到的是自定义组件，而不是 Web Component。</p> \n<h5>2.2 解决方案</h5> \n<p>Vue 并没有 forwardRef 的概念，只可简单粗暴地修改 <code>this.$parent.$refs</code>。</p> \n<p>为自定义组件增加一个 mixin：</p> \n<pre><code class=\"js\">export const refs = {\n  mounted () {\n    if (Object.keys(this.$parent.$refs).length) {\n      const refs = this.$parent.$refs\n\n      for (const key in refs) {\n        if (refs[key] === this) {\n          refs[key] = this.$el\n          break\n        }\n      }\n    }\n  },\n  beforeDestroy () {\n    if (Object.keys(this.$parent.$refs).length) {\n      const refs = this.$parent.$refs\n\n      for (const key in refs) {\n        if (refs[key] === this.$el) {\n          refs[key] = null\n          break\n        }\n      }\n    }\n  }\n}</code></pre> \n<p>注意：</p> \n<ul>\n <li>上述代码没有处理循环 ref，循环 ref 还需要另外判断和处理。</li>\n</ul> \n<h4>3. v-model</h4> \n<h5>3.1 问题</h5> \n<p>我们在自定义组件中使用了渲染函数进行渲染，因此对表单组件需要额外处理 <a href=\"https://cn.vuejs.org/v2/guide/render-function.html#v-model\" rel=\"nofollow noreferrer\">v-model</a>。</p> \n<h5>3.2 解决方案</h5> \n<p>使用自定义组件上的 <code>model</code> 选项，定制组件使用 <code>v-model</code> 时的 prop 和 event。</p> \n<p>改造上述的自定义组件：</p> \n<pre><code class=\"js\">export default function createFormsComponent (name, event, modelValue = \'value\', classNames = []) {\n  return {\n    name,\n    computed: {\n      listeners () {\n        return { ...this.$listeners }\n      }\n    },\n    model: {\n      prop: modelValue,\n      event: \'model\'\n    },\n    methods: {\n      input (e) {\n        this.$emit(\'input\', e)\n        this.$emit(\'model\', e.target.value)\n      },\n      change (e) {\n        this.$emit(\'change\', e)\n        this.$emit(\'model\', e.target.value)\n      }\n    },\n    render (createElement) {\n      return createElement(name, {\n        class: [\'hydrated\', ...classNames],\n        on: {\n          ...this.listeners,\n          [event]: this[event]\n        }\n      }, this.$slots.default)\n    }\n  }\n}\n\nconst Input = createFormsComponent(\'taro-input\', \'input\')\nconst Switch = createFormsComponent(\'taro-switch\', \'change\', \'checked\')\nVue.component(\'taro-input\', Input)\nVue.component(\'taro-switch\', Switch)</code></pre> \n<h2>总结</h2> \n<p>当我们希望创建一些不拘泥于框架的组件时，Web Components 会是一个不错的选择。比如跨团队协作，双方的技术栈不同，但又需要公用部分组件时。</p> \n<p>本次对 React 语法组件库进行 Web Components 化改造，工作量不下于重新搭建一个 Vue 组件库。但日后当 Taro 支持使用其他框架编写多端应用时，只需要针对对应框架与 Web Components 和 Stencil 的兼容问题编写一个胶水层即可，总体来看还是值得的。</p> \n<p>关于胶水层，业界兼容 React 的方案颇多，只是兼容 Web Components 可以使用 <a href=\"https://github.com/BBKolton/reactify-wc\" rel=\"nofollow noreferrer\">reactify-wc</a>，配合 Stencil 则可以使用官方提供的插件 <a href=\"https://github.com/ionic-team/stencil-ds-plugins/blob/master/README.md\" rel=\"nofollow noreferrer\">Stencil DS Plugin</a>。倘若 Vue 需要兼容 Stencil，或需要提高兼容时的灵活性，还是建议手工编写一个胶水层。</p> \n<p>本文简单介绍了 Taro Next、Web Components、Stencil 以及基于 Stencil 的组件库改造历程，希望能为读者们带来一些帮助与启迪。</p> \n<hr> \n<p>欢迎关注凹凸实验室博客：<a href=\"https://aotu.io/\" rel=\"nofollow noreferrer\">aotu.io</a></p> \n<p>或者关注凹凸实验室公众号（AOTULabs），不定时推送文章：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbA4t5\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"欢迎关注凹凸实验室公众号\" title=\"欢迎关注凹凸实验室公众号\"></span></p>', 'https://segmentfault.com/img/bVbFYR3', '1894b118d35d44cb8fe8009529c4154b', 'd79254c4ca5e45dca9d484307c935281,7506700dea5a42298b9ecb0ac0aaab41,3b375646301546259a8fb29d74ae4447', '0', '3', '1', '2020-04-16 16:49:24', '2020-04-16 16:49:24');
INSERT INTO `tb_recommend` VALUES ('456b9eb627d242f09ec9cc2f3d21736b', '滴滴大数据在汽车金融风控场景中的应用', '滴滴独有的出行场景大数据在金融领域有着非常广泛的应用前景，未来可与银行，保险，支付和理财等机构深入合作，帮助传统金融机构提升资源配置效率，降低获客和风险管理成本。出行场景大数据在交易欺诈识别、风险...', '<h2>导读：</h2> \n<p>滴滴独有的出行场景大数据在金融领域有着非常广泛的应用前景，未来可与银行，保险，支付和理财等机构深入合作，帮助传统金融机构提升资源配置效率，降低获客和风险管理成本。出行场景大数据在交易欺诈识别、风险定价、精准营销、全生命周期风险管理、增长运营等方面都有着重要商业价值。对于大数据的应用分析能力，正在成为金融机构未来发展的核心竞争要素。本文从汽车金融车贷产品的视角切入，将场景数据与传统信贷风控理念相结合，准确识别业务开展过程中的信用风险变化，对完善业务模式和重塑用户价值起到了积极的作用。</p> \n<h2>0.目录</h2> \n<ol> \n <li>汽车金融是什么？</li> \n <li>滴滴汽车金融在做什么？</li> \n <li> <p>滴滴大数据在汽车金融风控上的应用</p> \n  <ul> \n   <li>从资产端视角看存在问题和解决方案</li> \n   <li>从全流程风险管理视角看存在问题和解决方案</li> \n   <li>数据应用上的三个优化点</li> \n  </ul> </li> \n <li> <p>滴滴大数据在汽车金融风控场景下的应用前景</p> \n  <ul> \n   <li>企业信贷智能风控</li> \n   <li>零售信贷智能风控</li> \n  </ul> </li> \n</ol> \n<h2>1.汽车金融是什么？</h2> \n<p>汽车金融主要指与汽车产业相关的金融服务，是在汽车研发设计、生产、流通、消费等各个环节中所涉及到的资金融通方式。主要包括资金筹集、信贷分期、抵押贴现、金融租赁，以及相关保险、投资等活动。</p> \n<h3>▍商业模式</h3> \n<p>零售业务中，商业银行和融资租赁公司作为资金方，经销商/4S店/租赁公司作为销售渠道，汽车电商平台起到导流作用，共同为有购车需求的个人消费者提供分期购车金融产品和服务。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020120929\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>从竞争格局看，银行和厂商金融是零售市场的主要玩家，在资金成本和渠道获客上占有绝对优势。此外，汽车电商平台作为线上导流服务方，为传统金融机构提升获客效率，近几年也活跃在汽车金融市场。从产品类型上来看，售后回租为市场主流，直租有待快速发展。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020120930?w=1372&amp;h=570\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>2.滴滴汽车金融在做什么？</h2> \n<p>1）滴滴汽车金融业务现阶段定位为服务出行生态，一切从用户价值出发，为有购车需求的司机提供低成本购车金融方案。</p> \n<p>2）对内构建汽车金融风控体系，通过网约车场景数据的积累和应用，不断提升全面风险管理能力，生成优质网约车金融资产，逐步形成风险定价能力。</p> \n<p>3）对外向传统金融机构提供优质金融资产和系统化的风控能力输出，实现资金和资产高效匹配，积累金融资产管理能力。与此同时，作为连接资金和资产的双边平台，与主流金融机构建立长期合作伙伴关系，持续为网约车体系提供资金支持。</p> \n<p>未来滴滴汽车金融的业务范围会随着出行产业生态的发展不断丰富， 延伸至整个出行产业链，为汽车经销商、4S店、代理商等汽车销售者采购汽车和营运设备提供的金融服务， 以满足产业链上下游各环节的金融需求，逐步形成集信息流、资金流、物流于一体的汽车产业金融新业态。</p> \n<h2>3.滴滴大数据在汽车金融风控上的应用</h2> \n<p>传统信贷框架下，以贷款人央行征信判定还款能力的风控模式已经不再满足网约车金融的风险管理需求。网约车场景下，汽车金融风控对在贷资产的真实性、稳定性、以及风险预警的时效性提出了更高要求，基于大数据建立智能营销和智能风控决策体系显得尤为重要。</p> \n<h3>▍从资产端来看：</h3> \n<p>车贷C端问题： 贷前准入未使用场景内数据作为个人征信补充，贷中数据缺失，没有匹配的风险预警方案，贷后催收效率低，需要对网约车贷款人形成动态信用评分。</p> \n<p>解决方案：运用滴滴大数据补充传统零售评分卡模型，将场景中能够反映个人信用风险特征的数据应用到汽车金融领域，制定风控政策和准入标准。同时建立体系内有车群体的PD（probability of default）评分模型，关注PD参数的显著变化，提供大数据下的风险预警方案。逐步搭建网约车场景下的全面风险管理体系，提升全流程风险管理能力。</p> \n<p>车贷B端问题：传统金融机构对于CP（Car partners）征信数据的缺失，导致其不能有效识别渠道风险，尤其对于中小型CP来说，很难获得传统金融机构的授信。</p> \n<p>解决方案：借助滴滴平台大数据，支持资方对CP的授信审批。具体来说，是将渠道基础信息，以及能够反映其资产规模，资产使用效率，司机管理能力的数据维度进行系统化梳理，形成入模变量，同时不断积累体系内坏样本，建立CP半监督模型。模型输出结果即是CP信用评级综合分数，直观反映出CP的风险等级。目前汽车金融的CP评级为月度输出，可以动态反映出CP风险等级的变化。</p> \n<h3>▍从全流程风险管理来看：</h3> \n<p>在实际运营过程中，我们在零售车分期贷款的贷前，贷中和贷后三个阶段发现了以下问题。</p> \n<p>贷前准入风险：贷款申请人不是放款后实际运营该车辆的司机，也就是说A贷B还。这种问题通常发生在渠道进件环节。汽车金融产品销售过程中存在一定的操作风险，线下渠道销售人员为了提高成单率，找了信贷资质好，更容易通过贷前审核的人代替司机申请贷款，然而实际跑滴滴的司机信贷资产差，还款能力不足以支持月供，PD违约概率较高。那么这笔车分期贷款的信用风险就会在贷后的资产表现期内逐渐释放。</p> \n<h3>▍首次拉单时，贷款人和司机信息不符：</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020120931\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>贷中运营风险：贷款人在存续期内退车，车辆由租赁公司代偿，待租赁公司找到新司机后由新司机运营并继续还款。这种情况下， 传统风控在贷前准入对初始贷款人的判断，以及车辆GPS定位已经不再能够有效反映贷后运营车辆的风险变化。在贷车辆在存续期内先后匹配多个滴滴司机时，租赁公司在车辆运营管理，现金流管理和司机管理上面临很大挑战，有时多个司机集中退车会引起渠道集中性风险。</p> \n<h3>▍运营中一辆车在不同时点匹配多个司机：</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020120932?w=1568&amp;h=788\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>贷后逾期催收：传统信贷风控对于网约车贷后数据缺失，在无法获得贷款人收入以及营运行为数据的情况下，不能确定每笔逾期债项背后贷款人的还款能力和还款意愿，因而无法做到对收入还贷比高，有还款能力的贷款人进行优先催收。这种情况下，需要针对贷款人平台拉单数据以及贷款车辆营运数据制定催收评分卡，对催收进行分类管理。</p> \n<h3>▍滴滴大数据可以解决：</h3> \n<h4>网约车金融全面风险管理体系的搭建。</h4> \n<p>在零售数据准备和模型变量开发时，形成从贷款人信贷基础维度到涵盖城市、渠道、车辆四大风险因子的模型长清单，实现覆盖在贷资产全生命周期的动态监控。同时通过被投企业资产表现不断积累模型因变量（坏样本），有效把握风险等级变化，建立预警和响应机制，降低损失率。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020120933?w=576&amp;h=286\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>每个风险因子下钻形成多个风险指标，组合后形成风控策略。通过单一策略和多策略的综合应用，实现贷中预警和风险的及时防范。</p> \n<p>具体来说，优化方向有以下几点：</p> \n<p><strong>优化点1：从传统的放款时点贷款人风险评估，优化为全流程多维风险动态监测。</strong></p> \n<p>传统信贷风控只注重贷款人单一维度的信用风险计量，而在网约车场景下，城市政策合规、车辆运营状态、渠道管理能力都会在整个信贷流程中对信用风险的变化起到决定性作用。对此我们借助滴滴网约车场景数据和坏样本的持续积累，来补充传统信贷数据维度， 优化A卡和B卡。</p> \n<p>预警需求分析：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020120934\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>放款时点：</strong><br>反欺诈信息核实，数据维度包括但不限于平台侧核实司机、车辆、人车匹配、渠道基础信息，同时排查渠道进件风险。</p> \n<p>放款后，通过贷中监控实时反映贷款人信用风险变化，建立大数据风险预警体系。</p> \n<p>建立大数据内评验证治理架构，内评验证流程方法，提供不同层次的的优化策略和实时流程。预警模型中，典型贷中预警策略如下：</p> \n<p>司机维度策略：流水稳定性，收入能力，是否已办理人证等。<br>车辆维度策略：车辆在平台运营情况，车辆和司机的匹配情况，车辆行驶里程，是否已办理车证等。<br>CP渠道策略：渠道负面信息扫描，渠道集中性风险事件，合规比例，渠道集中性逾期等<br>城市合规策略：是否已获取网约车平台证，城市合规人证办理进度，是否分类管理等。</p> \n<p>随着数据维度不断丰富，四大风险因子的下钻维度会逐步增多。我们同时也在实际业务中逐一验证，并通过司机A卡B卡模型结果进行策略迭代。</p> \n<p><strong>贷后催收：</strong><br>优化催收评分模型。实时对逾期司机的逾期天数，拉单行为，月均收入进行分析和监控，得出每笔逾期债项对应的还款能力和还款意愿综合评分列表，帮助贷后催收提升效率。</p> \n<p><strong>优化点2：增加数据观测的时间宽度和时点观测深度，并在此基础上引入前瞻性。</strong></p> \n<p>通过对数据的长期观测，单一风险策略迭代以及多策略应用的持续验证，我们会得到司机信用风险变化的历史平均水平和规律，结合业务现阶段和未来发展趋势，在此基础上得到前瞻性调整后的PD（违约概率），对信用风险的显著变化进行定量和定性评估。</p> \n<p><strong>优化点3：依托大数据分析能力，形成对业务全局风险收益变化的综合判断。</strong></p> \n<p>通过C端融租车辆的全流程风险管理，逐步勾勒出了融租产品形态下的司机信贷画像和CP渠道画像， 快速识别汽车金融在业务模式和产品上的运营风险，比如融租包经租，CP代偿，集中性违约风险等。进而对车金融资产质量有清晰准确的计量，实现资产端和资金端风险收益的平衡。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020120935\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>4.滴滴大数据在汽车金融场景下的广泛应用前景</h2> \n<h3>▍企业信贷智能风控</h3> \n<p>方向：整个出行行业生态中，存在大量分散的中小企业服务商/渠道商，这些中小企业在滴滴平台上的日常经营数据反映了其经营能力、资金流动性管理和司机管理能力。多维度经营数据完全可以支持数据风控方式获得资金，为业务提供决策创新方案，包括识别客户异常行为、差异化授信审批、全流程风险管控和预警、限额设定等。</p> \n<p>进展：目前一些与滴滴平台合作方有业务往来的汽车金融持牌机构已经在与我们就数据风控的授信方式进行深入探讨，在平台不提供担保的情况下，通过司机余额代扣和平台多维度数据建立风控模型，为优质汽车租赁公司提供对公授信资金支持。</p> \n<h3>▍零售信贷智能风控</h3> \n<p>滴滴平台具有明显的双边效应，即供给侧和需求侧都通过平台完成交易，因此平台上会沉淀大量交易和运营数据。当汽车金融服务对象是体系内有车人群时，可通过滴滴大数据补充传统零售评分卡的不足， 将体系内非信贷数据应用到汽车金融业务场景下，比如用于制定产品级的风控政策和准入标准，输出自动化信用评分，反欺诈，风险敞口管理, 风险定价等。</p> \n<p>逐步建立网约车场景下的风险管理体系， 实现内评模型在数据、决策、和算法层面的创新。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020120936\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>包括：前筛客群、特征模型建立和训练、反欺诈规则设计、线上策略验证、与合作伙伴联合建模、线上贷后逾期管理等。</p> \n<p>随着大数据风控能力积累，不管产品形态是新车融资租赁还是车辆抵押贷款，都可以针对不同业务类型，建立智能风控体系。在此基础上，平台数据的动态监控能够帮助筛选资产表现良好的个人信贷用户，形成白名单，自动化审批放款，提升资产匹配效率。</p> \n<h2>本文作者：</h2> \n<p>唐佩<br>滴滴 | 汽车金融商业分析师</p> \n<p>一个有着金融业管理咨询背景的工科生，认为人生的意义和有价值的工作强相关，一直都在寻找聪明机智，有深度思考习惯，对商业高度敏感，视野广阔的合作伙伴加入队伍。 </p> \n<p>同时，也欢迎您关注滴滴技术公众号，我们会为您带来最新的开源信息和技术干货！</p> \n<h2>滴滴技术公众号：</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020120937\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p>', 'https://segmentfault.com/img/remote/1460000020120929', '6fbfa4aaad3a43458f21c8acf0038ac5', '277530c212aa4407b43c58c657fe8194,62f75a9c3455489e9e5128982e759700', '0', '3', '1', '2020-04-16 16:59:11', '2020-04-16 16:59:11');
INSERT INTO `tb_recommend` VALUES ('47915c194c794d048da55f8646532f34', '全栈后台管理系统脚手架 gin-vue-admin 2.0版本介绍', '项目文档 在线文档项目地址 前端UI框架：element-ui 后台框架：gin 1. 基本介绍 1.1 项目介绍 在线预览 Gin-vue-admin是一个基于vue和gin开发的全栈前后端分离的后台管理系统，集成jwt鉴权，动态路由，动态菜单，...', '<p><a href=\"https://camo.githubusercontent.com/6a2bd0693e4151c4b9d3e95f273db78cac12b7d2/687474703a2f2f716d706c7573696d672e68656e726f6e6779692e746f702f6776616c6f676f2e6a7067\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381859\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<h1>项目文档</h1> \n<p><a href=\"http://doc.henrongyi.top/\" rel=\"nofollow noreferrer\">在线文档</a><br><a href=\"https://github.com/flipped-aurora/gin-vue-admin\" rel=\"nofollow noreferrer\">项目地址</a></p> \n<ul> \n <li>前端UI框架：<a href=\"https://github.com/ElemeFE/element\" rel=\"nofollow noreferrer\">element-ui</a> </li> \n <li>后台框架：<a href=\"https://github.com/gin-gonic/gin\" rel=\"nofollow noreferrer\">gin</a> </li> \n</ul> \n<h2>1. 基本介绍</h2> \n<h3>1.1 项目介绍</h3> \n<p><a href=\"http://qmplus.henrongyi.top/\" rel=\"nofollow noreferrer\">在线预览</a></p> \n<blockquote>\n Gin-vue-admin是一个基于vue和gin开发的全栈前后端分离的后台管理系统，集成jwt鉴权，动态路由，动态菜单，casbin鉴权，表单生成器，代码生成器等功能，提供多种示例文件，让您把更多时间专注在业务开发上。\n</blockquote> \n<h3>1.2 贡献指南</h3> \n<p>Hi! 首先感谢你使用 gin-vue-admin。</p> \n<p>Gin-vue-admin 是一套为后台管理平台准备的一整套前后端分离架构式的开源框架，旨在快速搭建后台管理系统。</p> \n<p>Gin-vue-admin 的成长离不开大家的支持，如果你愿意为 gin-vue-admin 贡献代码或提供建议，请阅读以下内容。</p> \n<h4>1.2.1 Issue 规范</h4> \n<ul> \n <li>issue 仅用于提交 Bug 或 Feature 以及设计相关的内容，其它内容可能会被直接关闭。如果你在使用时产生了疑问，请到 Slack 或 <a href=\"https://gitter.im/ElemeFE/element\" rel=\"nofollow noreferrer\">Gitter</a> 里咨询。</li> \n <li>在提交 issue 之前，请搜索相关内容是否已被提出。</li> \n</ul> \n<h4>1.2.2 Pull Request 规范</h4> \n<ul> \n <li>请先 fork 一份到自己的项目下，不要直接在仓库下建分支。</li> \n <li>commit 信息要以<code>[文件名]: 描述信息</code> 的形式填写，例如 <code>README.md: fix xxx bug</code>。</li> \n <li>&lt;font color=red&gt;确保 PR 是提交到 <code>develop</code> 分支，而不是 <code>master</code> 分支。&lt;/font&gt;</li> \n <li>如果是修复 bug，请在 PR 中给出描述信息。</li> \n <li>合并代码需要两名维护人员参与：一人进行 review 后 approve，另一人再次 review，通过后即可合并。</li> \n</ul> \n<h3>1.3 版本列表</h3> \n<ul> \n <li>master: 2.0 dev code, for prod</li> \n <li>develop: 2.0 dev code, for test</li> \n <li> <a href=\"https://github.com/flipped-aurora/gin-vue-admin/tree/gin-vue-admin_v2_dev\" rel=\"nofollow noreferrer\">gin-vue-admin_v2.0_dev</a> （v2.0 不再兼容 v1.0）</li> \n <li> <a href=\"https://github.com/flipped-aurora/gin-vue-admin/tree/gin-vue-admin_v1_stable\" rel=\"nofollow noreferrer\">gin-vue-admin_v1.0_stable</a> （v1.0 稳定版，会持续更新和维护）</li> \n <li> <a href=\"https://github.com/flipped-aurora/gin-vue-admin/tree/gin-vue-admin_v1_dev\" rel=\"nofollow noreferrer\">gin-vue-admin_v1.0_dev</a> （v1.0 稳定版，会持续更新和维护）</li> \n</ul> \n<h2>2. 使用说明</h2> \n<pre><code>- node版本 &gt; v8.6.0\n- golang版本 &gt;= v1.11\n- IDE推荐：Golang\n- 各位在clone项目以后，把db文件导入自己创建的库后，最好前往七牛云申请自己的空间地址。\n- 替换掉项目中的七牛云公钥，私钥，仓名和默认url地址，以免发生测试文件数据错乱</code></pre> \n<h3>2.1 web端</h3> \n<pre><code class=\"bash\"># clone the project\ngit clone https://github.com/piexlmax/gin-vue-admin.git\n\n# enter the project directory\ncd web\n\n# install dependency\nnpm install\n\n# develop\nnpm run serve</code></pre> \n<h3>2.2 server端</h3> \n<pre><code class=\"bash\"># 使用 go.mod\n\n# 安装go依赖包\ngo list (go mod tidy)\n\n# 编译\ngo build</code></pre> \n<h3>2.3 生成swagger自动化API文档</h3> \n<h4>2.3.1 安装 swagger</h4> \n<h5>（1）可以翻墙</h5> \n<pre><code>go get -u github.com/swaggo/swag/cmd/swag</code></pre> \n<h5>（2）无法翻墙</h5> \n<p>由于国内没法安装 go.org/x 包下面的东西，需要先安装<code>gopm</code></p> \n<pre><code class=\"bash\"># 下载gopm包\ngo get -v -u github.com/gpmgo/gopm\n\n# 执行\ngopm get -g -v github.com/swaggo/swag/cmd/swag\n\n# 到GOPATH的/src/github.com/swaggo/swag/cmd/swag路径下执行\ngo install</code></pre> \n<h4>2.3.2 生成API文档</h4> \n<pre><code>cd server\nswag init</code></pre> \n<p>执行上面的命令后，server目录下会出现docs文件夹，登录<a href=\"http://localhost\" rel=\"nofollow noreferrer\">http://localhost</a>:8888/swagger/index.html，即可查看swagger文档</p> \n<h3>2.4 docker镜像</h3> \n<p>感谢 <a href=\"https://github.com/chenlinzhong\" rel=\"nofollow noreferrer\">@chenlinzhong</a>提供的docker镜像.</p> \n<pre><code># 启动容器\ndocker run -itd --net=host --name=go_container shareclz/go_node /bin/bash;\n\n# 进入容器\ndocker exec -it go_container /bin/bash;\ngit clone https://github.com/piexlmax/gin-vue-admin.git /data1/www/htdocs/go/admin;\n\n# 启动前端\ncd /data1/www/htdocs/go/admin/QMPlusVuePage;\ncnpm i ;\nnpm run serve;\n\n# 修改数据库配置\nvi /data1/www/htdocs/go/admin/QMPlusServer/static/dbconfig/config.json;\n\n# 启动后端\ncd /data1/www/htdocs/go/admin/QMPlusServer;z\ngo run main.go;</code></pre> \n<h2>3. 技术选型</h2> \n<ul> \n <li>前端：用基于<code>vue</code>的<code>Element-UI</code>构建基础页面。</li> \n <li>后端：用<code>Gin</code>快速搭建基础restful风格API，<code>Gin</code>是一个go语言编写的Web框架。</li> \n <li>数据库：采用<code>MySql</code>(5.6.44)版本，使用<code>gorm</code>实现对数据库的基本操作,已添加对sqlite数据库的支持。</li> \n <li>缓存：使用<code>Redis</code>实现记录当前活跃用户的<code>jwt</code>令牌并实现多点登录限制。</li> \n <li>API文档：使用<code>Swagger</code>构建自动化文档。</li> \n <li>配置文件：使用<code>fsnotify</code>和<code>viper</code>实现<code>yaml</code>格式的配置文件。</li> \n <li>日志：使用<code>go-logging</code>实现日志记录。</li> \n</ul> \n<h2>4. 项目目录</h2> \n<pre><code>    ├─server           （后端文件夹）\n    │  ├─api            （API）\n    │  ├─config         （配置包）\n    │  ├─core              （內核）\n    │  ├─db             （数据库脚本）\n    │  ├─docs              （swagger文档目录）\n    │  ├─global         （全局对象）\n    │  ├─initialiaze    （初始化）\n    │  ├─middleware     （中间件）\n    │  ├─model          （结构体层）\n    │  ├─resource       （资源）\n    │  ├─router         （路由）\n    │  └─utils            （公共功能）\n    └─web            （前端文件）\n        ├─public        （发布模板）\n        └─src           （源码包）\n            ├─api       （向后台发送ajax的封装层）\n            ├─assets    （静态文件）\n            ├─components（组件）\n            ├─router    （前端路由）\n            ├─store     （vuex 状态管理仓）\n            ├─style     （通用样式文件）\n            ├─utils     （前端工具库）\n            └─view      （前端页面）\n</code></pre> \n<h2>5. 主要功能</h2> \n<ul> \n <li>权限管理：基于<code>jwt</code>和<code>casbin</code>实现的权限管理</li> \n <li>文件上传下载：实现基于七牛云的文件上传操作（为了方便大家测试，我公开了自己的七牛测试号的各种重要token，恳请大家不要乱传东西）</li> \n <li>分页封装：前端使用mixins封装分页，分页方法调用mixins即可</li> \n <li>用户管理：系统管理员分配用户角色和角色权限。</li> \n <li>角色管理：创建权限控制的主要对象，可以给角色分配不同api权限和菜单权限。</li> \n <li>菜单管理：实现用户动态菜单配置，实现不同角色不同菜单。</li> \n <li>api管理：不同用户可调用的api接口的权限不同。</li> \n <li>配置管理：配置文件可前台修改（测试环境不开放此功能）。</li> \n <li>富文本编辑器：MarkDown编辑器功能嵌入。</li> \n <li>条件搜索：增加条件搜索示例。</li> \n <li>restful示例：可以参考用户管理模块中的示例API。</li> \n</ul> \n<pre><code>前端文件参考: src\\view\\superAdmin\\api\\api.vue \n后台文件参考: model\\dnModel\\api.go </code></pre> \n<ul> \n <li>多点登录限制：需要在<code>config.yaml</code>中把<code>system</code>中的<code>useMultipoint</code>修改为true(需要自行配置Redis和Config中的Redis参数，测试阶段，有bug请及时反馈)。</li> \n <li>分片长传：提供文件分片上传和大文件分片上传功能示例。</li> \n <li>表单生成器：表单生成器借助 <a href=\"https://github.com/JakHuang/form-generator\" rel=\"nofollow noreferrer\">@form-generator</a>。</li> \n <li>代码生成器：后台基础逻辑以及简单curd的代码生成器。</li> \n</ul> \n<h2>6. 计划任务</h2> \n<ul> \n <li>[ ] 导入，导出Excel</li> \n <li>[ ] Echart图表支持</li> \n <li>[ ] 工作流，任务交接功能开发</li> \n <li>[ ] 单独前端使用模式以及数据模拟</li> \n</ul> \n<h2>7. 更新日志</h2> \n<table> \n <thead>\n  <tr> \n   <th align=\"center\">日期</th> \n   <th>日志</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td align=\"center\">2020/01/07</td> \n   <td>角色增加数据资源功能 增加数据资源关联返回 演示环境代码已同步 开启了多点登录拦截 可能会被其他人挤掉</td> \n  </tr> \n  <tr> \n   <td align=\"center\">2020/01/13</td> \n   <td>增加了配置管理功能 此功能不发表至测试环境 待保护机制以及服务重启机制发开完成后才会发表值测试环境 请自行clone且导入sql体验</td> \n  </tr> \n  <tr> \n   <td align=\"center\">2020/02/21</td> \n   <td>修改了casbin的自定义鉴权方法，使其完全支持RESTFUL的/:params以及?query= 的接口模式</td> \n  </tr> \n  <tr> \n   <td align=\"center\">2020/03/17</td> \n   <td>增加了验证码功能 使用了 <a href=\"https://github.com/dchest/captcha\" rel=\"nofollow noreferrer\">@dchest/captcha</a>库</td> \n  </tr> \n  <tr> \n   <td align=\"center\">2020/03/30</td> \n   <td>代码生成器开发完成 表单生成器开发完成 使用了<a href=\"https://github.com/JakHuang/form-generator\" rel=\"nofollow noreferrer\">@form-generator</a> 库</td> \n  </tr> \n  <tr> \n   <td align=\"center\">2020/04/01</td> \n   <td>增加前端历史页签功能，增加（修改）条件查询示例，前端背景色调修改为白色。（如不需要此功能可以在<code>web/src/view/layout/index.vue</code>中屏蔽<code>HistoryComponent</code>背景色调，为本页260行&amp;.el-main中的<code>background</code>属性）</td> \n  </tr> \n  <tr> \n   <td align=\"center\">2020/04/04</td> \n   <td>启动2.x版本，项目文档规范化，日志功能改造，方法增加英文注释</td> \n  </tr> \n </tbody> \n</table> \n<h2>8. 团队博客</h2> \n<blockquote> \n <a href=\"https://blog.henrongyi.top\" rel=\"nofollow noreferrer\">https://blog.henrongyi.top</a>\n <p>内有前端框架教学视频。如果觉得项目对您有所帮助可以添加我的个人微信:shouzi_1994，欢迎您提出宝贵的需求。</p> \n</blockquote> \n<h2>9. 教学视频</h2> \n<h3>9.1 环境搭建</h3> \n<blockquote>\n Bilibili：\n <a href=\"https://www.bilibili.com/video/BV1Fg4y187Bw/\" rel=\"nofollow noreferrer\">https://www.bilibili.com/vide...</a> (v1.0版本视频，v2.0操作相同目录不同)\n</blockquote> \n<h3>9.2 模板使用</h3> \n<blockquote>\n Bilibili：\n <a href=\"https://www.bilibili.com/video/BV16K4y1r7BD/\" rel=\"nofollow noreferrer\">https://www.bilibili.com/vide...</a> (v1.0版本视频，v2.0操作相同目录不同)\n</blockquote> \n<h3>9.3 golang基础教学视频录制中...</h3> \n<blockquote>\n 地址：\n <a href=\"https://space.bilibili.com/322210472/channel/detail?cid=108884\" rel=\"nofollow noreferrer\">https://space.bilibili.com/32...</a> \n</blockquote> \n<h3>- QQ交流群：622360840</h3> \n<h3>- 微信交流群：可以添加上面任意一位开发者，备注\"加入gin-vue-admin交流群\"</h3> \n<h2>10. 开发者列表</h2> \n<table> \n <thead>\n  <tr> \n   <th>昵称</th> \n   <th>项目职务</th> \n   <th>姓</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td><a href=\"https://github.com/piexlmax\" rel=\"nofollow noreferrer\">@piexlmax</a></td> \n   <td>项目发起者</td> \n   <td>蒋</td> \n  </tr> \n  <tr> \n   <td><a href=\"https://github.com/granty1\" rel=\"nofollow noreferrer\">@granty1</a></td> \n   <td>后台开发</td> \n   <td>印</td> \n  </tr> \n  <tr> \n   <td><a href=\"https://github.com/Ruio9244\" rel=\"nofollow noreferrer\">@Ruio9244</a></td> \n   <td>全栈开发</td> \n   <td>严</td> \n  </tr> \n  <tr> \n   <td><a href=\"https://github.com/1319612909\" rel=\"nofollow noreferrer\">@1319612909</a></td> \n   <td>前端UI开发</td> \n   <td>杜</td> \n  </tr> \n  <tr> \n   <td><a href=\"https://github.com/krank666\" rel=\"nofollow noreferrer\">@krank666</a></td> \n   <td>前端开发</td> \n   <td>尹</td> \n  </tr> \n  <tr> \n   <td><a href=\"https://github.com/chen-chen-up\" rel=\"nofollow noreferrer\">@chen-chen-up</a></td> \n   <td>新手开发</td> \n   <td>宋</td> \n  </tr> \n </tbody> \n</table> \n<h2>11. 捐赠</h2> \n<p>如果你觉得这个项目对你有帮助，你可以请作者喝饮料 <span class=\"emoji emoji-tropical_drink\"></span></p>', 'https://segmentfault.com/img/remote/1460000022381859', 'f53014d680884163a5bd5ce762e90cdf', '63c4e1e7ec204b43a62065a3ced4c2ce,55723db96b9f4593bae02bc1e49f1e87,b350d9c92c524bb4b9feedd40e5eebcd,50952da4831a49c98a02a58ccc545509,1f222fff35904eafba3af5103e7f5121', '0', '3', '1', '2020-04-16 16:48:56', '2020-04-16 16:48:56');
INSERT INTO `tb_recommend` VALUES ('47c10d6eadf84278a2a5cea542e97744', '案例解读宜信如何运用区块链双链技术重构供应链金融服务', '近日,银保监会下发了《中国银保监会办公厅关于推动供应链金融服务实体经济的指导意见》(以下简称“《意见》”),该《意见》提出，鼓励银行保险机构将物联网、区块链等新技术嵌入交易环节，提升智能风控水平。', '<p>近日,银保监会下发了《中国银保监会办公厅关于推动供应链金融服务实体经济的指导意见》(以下简称“《意见》”),该《意见》提出，鼓励银行保险机构将物联网、区块链等新技术嵌入交易环节，提升智能风控水平。</p> \n<p>区块链技术具有去中心化、不可篡改、高透明度等多种特性，在供应链金融领域有天然优势，能够真正解决交易环节的信任问题，提升供应链上下游企业的融资效率与效果。<br>供应链金融模式早已有之，围绕核心企业来管理上下游中小企业的资金流和物流，将单个企业的不可控风险转变为供应链企业整体的可控风险。</p> \n<p>而事实上，供应链金融仍然不能彻底解决中小微企业融资难、融资贵的难题，近年来市场竞争日益激烈，中小微企业的资金周转和融资问题愈发凸显，缺少抵押品、征信记录及交易凭证等现实情况导致中小微企业很难从银行获得贷款。</p> \n<p>针对上述痛点，宜信公司推出Blockworm BaaS平台，自主研发区块链+供应链双链技术，双链模式能够将生产编号、出库订单、运输订单、签收订单等生产销售相关的数据上链，还可以将供应链全流程的资产生产和资产流转信息流上链，供应流程中的数据即可作为中小微企业融资的信托凭证。双链的结合真正实现了数据有信用、信用有价值，并帮助金融科技更好地服务于实体经济。</p> \n<h2>案例背景</h2> \n<p>供应链上下游企业中，中小企业不仅对信息流有一定的要求，而且对资产流也有不同程度的需求。传统的供应链金融由于信息不透明，不能及时掌握上下游的生产编号、出库订单、运输订单、签收订单、票据信息、保理服务等信息，所以核心企业的信用很难传递到整个链条中，进一步加剧了融资“难、贵、慢”等问题。</p> \n<h2>技术方案</h2> \n<p>供应链金融的基础就是供应链，宜信通过区块链技术打通供应链条中的相关协作方，首先可以提高整个供应链的协作效率，其次多方的参与还可以为交易的真实性增信。</p> \n<p>宜信Blockworm BaaS平台的双链技术，通过创建基于供应链的区块链环境，帮助客户打通系统间的数据壁垒。为了更好地实现交易闭环，还提供了翼融链小程序，买家可以基于翼融链对链上订单进行签收，并上传相应的凭证，整个过程所产生的数据都保存到区块链中。不仅如此，翼融链还记录了买家的位置信息、登录信息，为上层应用进行风险预警，为大数据分析提供了可信的基础数据。</p> \n<p>当中小微企业需要融资时，即可提供相应的订单编号到资产链上，双链的结合让信息流转化成了资产流。资金方会根据订单编号等信息，在供应链(区块链)上溯源整个交易过程，交叉验证交易的真实性，以及相关企业的协作信息等，这不仅起到了增信的作用，而且还降低了融资成本，提高了融资效率。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021522289\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>成功案例</h2> \n<p>某大宗电商撮合平台，买家下单后，卖家会去上游工厂采购商品，并通知物流公司安排运输，最终买家进行货物的签收。在整个协作过程中，会产生订单、出库单、运输单、签收单等单据，这些纸质单据都充当着信用传递和数据传递的媒介，任何一个环节出现了不可信的情况，都会对整个供应链造成风险。</p> \n<p>宜信Blockworm BaaS平台借助区块链双链技术，打通了各个参与方系统的数据壁垒，让每个参与方都在区块链上进行数据协作。由于区块链提供了可信的环境，整个过程中可以省去相应的协作单据，从而大大提高了供应链的协作效率。另外，通过资产产生信息和资产流转信息的交叉验证，结合参与方的身份信息和交易内容，共同作为金融机构进行风控和授信的依据，促进了资金的快速运转。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021522290\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>（供应链+资产链双链结构模式）</p> \n<h2>实现效果</h2> \n<p>区块链双链技术提高了整个供应链的协作效率，打通了信息流和资产流，不仅提高了数据的安全性和保密性，降低了融资的风险和成本，提高了融资效率，同时促进了资金的快速运转，也为金融科技助力实体经济的发展提供了新的尝试。</p> \n<blockquote>\n 作者：宜信区块链实验室张一杰\n <p>来源：宜信技术学院</p> \n</blockquote>', 'https://segmentfault.com/img/remote/1460000021522289', '1894b118d35d44cb8fe8009529c4154b', '7937aecb2ef543908ed511c9d5abceb3,affcefc3661947ccae893a1ed7dbca10,6aec6c8499c44483beecd569d05c7f4b', '0', '3', '1', '2020-04-16 16:59:09', '2020-04-16 16:59:09');
INSERT INTO `tb_recommend` VALUES ('48a333d4d02944d49db188b42c5af3bf', 'Microsoft Referral 微软内推', '大家好，很久没有更新文章了，也有很多文章的评论没有回复，一方面是因为想写好一篇文章要耗费很多精力，另一方面也确实因为太懒了。。。对那些关注我的人感到抱歉。', '<h2>前言</h2> \n<p>大家好，很久没有更新文章了，也有很多文章的评论没有回复，一方面是因为想写好一篇文章要耗费很多精力，另一方面也确实因为太懒了。。。对那些关注我的人感到抱歉。</p> \n<p>说回正题，本人现在在苏州微软工作（已经呆了一年多了其实。。。），所以可以提供微软的内推，今年因为疫情的影响，很多公司都在裁员，但是微软这边的headcount还是很多的，目前还有100+，所以有兴趣的小伙伴可以找我内推, 也欢迎大家扩散转发，期待与你成为同事。(￣▽￣)／</p> \n<h2>怎样获得内推</h2> \n<ol> \n <li>去<a href=\"https://careers.microsoft.com/\" rel=\"nofollow noreferrer\">微软官网</a>搜索你感兴趣的岗位</li> \n <li>提供你的中英文简历</li> \n <li>将你的简历和你感兴趣的岗位编号发到我的邮箱：<strong>chazhen@microsoft.com</strong> </li> \n</ol> \n<p>现在随便举个例子，假如你叫张三，你对职位<a href=\"https://careers.microsoft.com/i/us/en/job/752936/Software-Engineer-Office-365-Security-Team\" rel=\"nofollow noreferrer\">752936</a>感兴趣, 请以以下统一邮件格式将你的个人信息发给我：</p> \n<p><strong>邮件标题</strong>：Referral Request <br><strong>附件</strong>：你的中英文简历 <br><strong>邮件内容</strong>： <br>Name： 张三 <br>Job Number: 752936 </p> \n<p>PS:<br>请不要在邮件中询问关于薪资待遇之类的比较私人的问题，这个在例如知乎等平台上已经有很多人分享过了，对于邮件中非共性问题，我一般不会回答，尽请谅解。</p> \n<h2>FAQ</h2> \n<h4>1. 我能同时申请多个职位吗？</h4> \n<p>可以的，在邮件的Job Number处填多个就行，但是请按优先级排序，将最感兴趣的职位放在第一个。</p> \n<h4>2. 不知道选什么岗位/随便什么岗位都可以</h4> \n<p>这种情况下你只需要填你的目标职位就行，例如SE,SE2等，HR会根据你的简历将你推给合适的部门。</p> \n<h4>3. 有想要的岗位，但是在官网上搜不到</h4> \n<p>微软的很多岗位都是比较宽泛的，基本是招进来之后根据你的兴趣再去细分。如果你有很明确的方向，也可以直接描述你想做的事情或者方向，不需要提供具体的job number.</p> \n<h4>4. 通过你内推一定会拿到面试机会吗？</h4> \n<p>不一定。内推的作用只是更快的把你的简历送到HR面前，增加你被面试的机会，避免你的简历淹没在池子里。但是如果你的简历写的不是很好，也有可能直接被HR pass掉。所以大家还是要关注简历质量。</p> \n<h4>5. 我可以申请上海微软或者北京微软吗？</h4> \n<p>可以，但是我不知道其他城市的headcount有多少，至少目前而言，苏州是很多的。</p>', null, 'c56940aa8b004dab84568e86900b2ee6', '7e8a80ce2b624cf78c1048efc7c7a623,9d5eb002705648e2bc3d345fa34a8191,f4485e212bb64f2a8d2761524742e3d7,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 17:00:05', '2020-04-16 17:00:05');
INSERT INTO `tb_recommend` VALUES ('4d07dc9857eb44e089cbe9fe94631a73', 'GitHub 发了大福利后，羊毛党正在路上', '内容提要：GitHub 从今天起，面向全体个人和团队，免费提供不限制协作人数的私有仓库，所有核心功能也统统免费。不过，全面免费政策背后，也带来一些隐忧。', '<blockquote>\n 内容提要：GitHub 从今天起，面向全体个人和团队，免费提供不限制协作人数的私有仓库，所有核心功能也统统免费。不过，全面免费政策背后，也带来一些隐忧。\n</blockquote> \n<blockquote>\n 关键词：GitHub 团队 免费 滥用\n</blockquote> \n<p>重磅消息！GitHub 今天凌晨官宣，面向全体 GitHub 用户和团队，提供不限制协作人数的私有仓库，并且，GitHub 的全部核心功能现已对所有人免费提供。</p> \n<h2>喜大普奔，GitHub 发放超级福利</h2> \n<p>GitHub 的 CEO Nat Friedman 在官宣博客中说，到目前为止，如果任何组织要使用 GitHub 进行私有开发，都必须付费。但是每个开发人员都应该可以访问 GitHub，价格不应该成为障碍。</p> \n<p>现在，这一免费计划的公布，意味着团队现在可以在一个地方一起管理他们的工作：CI / CD，项目管理，代码审查，软件包等等。GitHub 希望每个人都能在平台上发布出色的软件。</p> \n<p>而需要高级功能（例如代码所有者）、企业功能（例如 SAML）或个性化支持的团队，可以进行付费升级。</p> \n<p>此外，付费团队月定价，也从 9 美元/人降低到 4 美元/人，立即生效。已付费用户怎么办？不用担心，GitHub 会在 30 天内退还差价。</p> \n<p>具体计划和价格变化如下：</p> \n<ul> \n <li>面向组织的 GitHub Free 立即可用，包括私有仓库将不再有人数限制；</li> \n <li>以前使用 Team for Open Source 的所有组织，现在都拥有 GitHub Free；</li> \n <li>面向个人开发人员的 GitHub Free 对协作组人数不作限制；</li> \n <li>使用 GitHub Free 的组织和个人，将获得 GitHub Community Support；</li> \n <li>GitHub Pro 现在将包括 2GB 的 Packages 存储和 10GB 的数据传输；每月价格从 7 美元降至 4 美元；</li> \n <li>GitHub Team 现在每个用户的月费降低为 4 美元，不设最低消费；</li> \n <li>自 5 月 14 日起，GitHub 团队每月将为私有仓库提供 3000 分钟的 actions 时间。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5yt\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"6c9fc1191544382709d9b8b952a7c240.jpg\" title=\"6c9fc1191544382709d9b8b952a7c240.jpg\"></span></p> \n<ul>\n <li><em>最新定价表，GitHub Free 新增面向团队私有仓库，GitHub Team 月定价由 9 美元降为 4 美元</em></li>\n</ul> \n<h2>用户：真香！感谢微软爸爸</h2> \n<p>Nat Friedman 在声明中写道，GitHub 上已经有超过 4000 万开发者，团队估计 2025 年这个数字会达到 1 个亿。</p> \n<p>也就是说，截至目前，就有超过 4000 万用户将享受到这些福利。</p> \n<p>在大家喜大普奔之余，都很好奇：GitHub 怎么这么有钱了？靠什么盈利呢？</p> \n<p>在今天 Hacker News 上 Nat Friedman 的在线答疑中，一位网友忍不住好奇直接发问，而 Friedman 的回答是，「我们的大型企业用户真的很多！」</p> \n<p>但是，事实是否真的如此？</p> \n<p>其实 GitHub 的盈利模式此前一直是大家探讨的热门话题。曾有人分析， GitHub 与 BitBucket、Gitlab 相比，盈利方面都没有竞争优势。比如，Gitlab 基于其开源版本之上的解决方案，可能更适合愿意支付高价的大企业。</p> \n<p>微软当初收购 GitHub 的目的，也并不是看中其盈利与否，而更在意 GitHub 带来的客户资源及其在未来创造的更大的价值。</p> \n<p>如此说来，GitHub 就可以只负责吸引更多用户，其它花钱什么的，交给财大气粗的微软爸爸就好。</p> \n<p>在 Nat Friedman 公布此消息的推文下面，清一色的欢呼叫好声，以及对微软爸爸的感恩。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5y8\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"c12f137d44b32fdf204a94c518315cb6.jpg\" title=\"c12f137d44b32fdf204a94c518315cb6.jpg\"></span></p> \n<p>微博上也满满的写着开心：有微软爸爸真好！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5zC\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"b1dfe970bd9bd128a84afb649f08c89d.jpg\" title=\"b1dfe970bd9bd128a84afb649f08c89d.jpg\"></span></p> \n<p>的确，GitHub 的一系列免费政策，都是在被微软收购之后。</p> \n<p>去年 1 月 8 日， GitHub 就宣布了面向个人开发者私有仓库免费，即 GitHub Free，同时提供 3 个免费协作人数的名额，如果需要更多的协作人数，则需要付费。</p> \n<p>这一宣布在当时已经被大家「真香」了，现在，GitHub 又大手一挥，直接面向团队开放 GitHub Free，一大批新用户可能正在赶来。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5zI\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"3903231a54485d52ad5c19ac57a5b57a.jpg\" title=\"3903231a54485d52ad5c19ac57a5b57a.jpg\"></span></p> \n<ul>\n <li><em>国内很多开发者还表示要去修墙</em></li>\n</ul> \n<h2>图床、矿机、云盘：福利也带来滥用风险</h2> \n<p>在微软财力支持下，GitHub 越来越良心，这对于大部分开发者来说是好事。</p> \n<p>但是，这也不免让人担忧它是否会被滥用？比如无限的云存储空间被当做免费网盘或图床来使用。</p> \n<p>知乎网友用 GitHub 来做轻量级网盘</p> \n<p>甚至还有开发者针对如何将 GitHub 变为无限云网盘写了教程：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5Ae\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"fff27ae6cfd192c40df544bce2232d30.jpg\" title=\"fff27ae6cfd192c40df544bce2232d30.jpg\"></span></p> \n<ul>\n <li><em>让微软为你的无限云存储买单</em></li>\n</ul> \n<p>今天 GitHub 福利刚发出来，可能一大波羊毛党就已经坐不住了。</p> \n<p>此外，还有黑客利用 GitHub 的免费网页代管服务 GitHub Pages 从事网钓攻击行动。</p> \n<p>这些担忧并不是多余的，免费服务被薅羊毛、滥用的例子已有之。比如 Google Colab 提供的免费 GPU 资源，就会被一些羊毛党用来挖矿。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5Ai\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"6682fbdfb07097fac40758d9c189ba79.jpg\" title=\"6682fbdfb07097fac40758d9c189ba79.jpg\"></span></p> \n<p>这些滥用操作只会对平台和用户造成伤害。不过，相信 GitHub 也会考虑到这些问题，出台相关限制政策，让平台更加良性地发展下去。</p> \n<p>&lt;完&gt;</p>', 'https://segmentfault.com/img/bVbF5yt', '3f69fcc9b13843d1910b3dac597f5215', '634b81d655c74cb0adc4d0aa362b8819,efd45535a5504d5595fba4d1dbbc489c', '0', '3', '1', '2020-04-16 16:55:34', '2020-04-16 16:55:34');
INSERT INTO `tb_recommend` VALUES ('4e7704ba385a4f59846c0173d0bb19a9', '2017-2020历年字节跳动Android面试真题解析', '早在2017年我们就建了第一个字节跳动的面试群给大家讨论面试的东西。期间累计有1825个群友分享了自己的Android面试真经，并提供了参考答案。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990298\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>大家好！给大家介绍一下，这是我们持续更新整理的2017-2020字节跳动历年Android面试真题解析！</strong></p> \n<p>早在2017年我们就建了第一个字节跳动的面试群给大家讨论面试的东西。期间累计有1825个群友分享了自己的Android面试真经，并提供了参考答案。</p> \n<p>这其中就有很多成员已经斩获今日头条、抖音等岗位的offer。有很多成员面试虽然失败了，但也分享了很多失败的经验教训。在这里一并对他们表示感谢！正是因为大家的奉献和支持，让我们的这份面试真题解析已经累计<strong>下载1082万次！</strong></p> \n<hr> \n<p><strong>字节跳动Android面试真题解析目录如下：</strong></p> \n<p><strong>第一章 计算机基础面试题</strong> </p> \n<p>1、网络面试题 1</p> \n<p>2、操作系统面试题 （⭐⭐⭐） 21</p> \n<p>3、数据库面试题 （⭐） 23</p> \n<p><strong>第二章 数据结构和算法面试题</strong></p> \n<p>数据结构与算法 25</p> \n<p><strong>第三章 Java面试题</strong></p> \n<p>1、Java基础面试题 33</p> \n<p>2、Java并发面试题 81</p> \n<p>3、Java虚拟机面试题 （⭐⭐⭐） 121</p> \n<p><strong>第四章 Android面试题</strong></p> \n<p>1、Android基础面试题 （⭐⭐⭐） 140</p> \n<p>2、Android高级面试题 （⭐⭐⭐） 208</p> \n<p><strong>第五章 其他扩展面试题</strong></p> \n<p>1、Kotlin （⭐⭐） 346</p> \n<p>2、大前端 （⭐⭐） 346</p> \n<p>3、脚本语言 （⭐⭐） 349</p> \n<p><strong>第六章 非技术面试题</strong></p> \n<p>1、高频题集 （⭐⭐⭐） 350</p> \n<p>2、次高频题集 （⭐⭐） 352</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990300\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>字节跳动Android面试真题解析目录</p> \n<p>每个问题我们都附上1个标准参考答案，都是我们反复摸索消化（真心花了很多时间），觉得写的比较好的文章作为答案。这样就可以节省大家自己去搜索的时间，把时间用在正确的东西上。</p> \n<p>其实我们也可以直接以简易的、群友分享的答案写出来，但是这并帮助不了同学们去深刻理解，三思之下还是采用标准答案作为参考。不明白或者想通俗了解的，可<strong>加入我们字节跳动面试交流q群</strong>一起讨论，加入我们字节跳动Android面试群给大家讨论长篇or精简的答案，希望大家理解。下面是我们每章知识点的概述：</p> \n<p><strong>第一章 计算机基础面试题</strong></p> \n<p>字节跳动面试也会考察计算机基础，主要考察我们是否系统的学习了操作系统和计算机组成原理，因为只有我们看完操作系统后才能系统的认识计算机的原理。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990297\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>第一章 计算机基础面试题</p> \n<p><strong>第二章 数据结构和算法面试题</strong></p> \n<p>对于算法面试准备，无疑就是刷《剑指Offer》+ LeetCode 效果最佳。刷《剑指Offer》是为了建立全面的算法面试思维，打下坚实的基础，刷LeetCode则是为了不断强化与开阔我们自己的算法思想。这两块 CS-Notes 中已经实现地很完美了，建议大家将《剑指Offer》刷完，然后再至少刷100道LeetCode题目以上。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990299\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span><br>《剑指Offer》</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990301\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span><br>LeetCode中文版</p> \n<p><strong>第三章 Java面试题</strong></p> \n<p>Java 是 Android App 开发默认的语言, Android Framework 也是默认使用 Java 语言，熟练掌握 Java 语言是 Android 开发者的必备技能。当然也是我们字节跳动青睐的考题选择方向！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990302\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>第三章 Java面试题</p> \n<p><strong>第四章 Android面试题</strong></p> \n<p>Android面试分为基础面试题+高级面试题两个部分。其中高级面试题部分的性能优化、Framework、三方源码属于我们考察的重点、难点方向！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990303\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>第四章 Android面试题</p> \n<p><strong>第五章、第六章 其他扩展面试题+非技术面试题</strong></p> \n<p>Google 几年前就开始走“Kotlin First”的路线，目前很多官方的文档和 Demo 都是使用 Kotlin 语言作为默认，Kotlin 的重要性不言而喻。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990305\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>第五章、第六章 其他扩展面试题+非技术面试题</p> \n<p><strong>简历制作+春招困惑解答+经典HR面试解析</strong></p> \n<p>以上是我们整理总结字节跳动Android面试遇到的历年真题解析，希望对大家有帮助；同时我们经常也会遇到很多关于简历制作，职业困惑、HR经典面试问题回答等有关面试的问题。同样的我们搜集整理了全套简历制作、春招困惑、HR面试等问题解析，我们在q群中，都提供了专业的解答（群号码：936903570）。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990307\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"img\" title=\"img\"></span></p> \n<h5><strong>如何做好面试突击，规划学习方向？</strong></h5> \n<p>面试题集可以帮助你查漏补缺，有方向有针对性的学习，为之后进大厂做准备。但是如果你仅仅是看一遍，而不去学习和深究。那么这份面试题对你的帮助会很有限。最终还是要靠资深技术水平说话。</p> \n<p>网上学习 Android的资料一大堆，但如果学到的知识不成体系，遇到问题时只是浅尝辄止，不再深入研究，那么很难做到真正的技术提升。建议先制定学习计划，根据学习计划把知识点关联起来，形成一个系统化的知识体系。</p> \n<p>学习方向很容易规划，但是如果只通过碎片化的学习，对自己的提升是很慢的。</p> \n<p>我们搜集整理过这几年字节跳动，以及腾讯，阿里，华为，小米等公司的面试题，把面试的要求和技术点梳理成一份大而全的“ Android架构师”面试 Xmind（实际上比预期多花了不少精力），包含知识脉络 + 分支细节。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990306\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>我们在搭建这些技术框架的时候，还整理了系统的高级进阶教程，会比自己碎片化学习效果强太多；</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990304\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h4> <strong>上述所有资料！均可免费分享！</strong><a href=\"http://wpa.qq.com/msgrd?v=3&amp;uin=2677509374&amp;site=qq&amp;menu=yes\" rel=\"nofollow noreferrer\">点击我</a> 领取</h4> \n<p><strong>扫码进群！联系管理员免费获取！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021990308\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"img\" title=\"img\"></span></p> \n<p>qq群号码：<strong>936903570</strong></p>', 'https://segmentfault.com/img/remote/1460000021990298', 'f53014d680884163a5bd5ce762e90cdf', '8dfc62f227ae4076888ea4872e03cddd,2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-16 16:54:52', '2020-04-16 16:54:52');
INSERT INTO `tb_recommend` VALUES ('4ec59df6d9d449a0aec0af0b94641626', 'Docker: CPU我劝你善良！！', '默认情况下容器可以使用的主机 CPU 资源是不受限制的。和内存资源的使用一样，如果不对容器可以使用的 CPU 资源进行限制，一旦发生容器内程序异常使用 CPU 的情况，很可能把整个主机的 CPU 资源耗尽，从而导致更...', '<p>默认情况下容器可以使用的主机 CPU 资源是不受限制的。和内存资源的使用一样，如果不对容器可以使用的 CPU 资源进行限制，一旦发生容器内程序异常使用 CPU 的情况，很可能把整个主机的 CPU 资源耗尽，从而导致更大的灾难。本文将介绍如何限制容器可以使用的 CPU 资源。 </p> \n<p>本文的 demo 中会继续使用《Docker: 限制容器可用的内存》一文中创建的 docker 镜像 u-stress 进行压力测试，文中就不再过多的解释了。</p> \n<h5>一、限制可用的 CPU 个数</h5> \n<p>在 docker 1.13 及更高的版本上，能够很容易的限制容器可以使用的主机 CPU 个数。只需要通过 --cpus 选项指定容器可以使用的 CPU 个数就可以了，并且还可以指定如 1.5 之类的小数。接下来我们在一台有四个 CPU 且负载很低的主机上进行 demo 演示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMNicib4iaibnN2Ml6dQHQSHnC8Dq0kGcMPme9NxJysicTllghBeuvd40qGLia9MITeCyyMrPDoUYhmbbO2A/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>通过下面的命令创建容器，--cpus=2 表示容器最多可以使用主机上两个 CPU：</p> \n<pre><code>$ docker run -it --rm --cpus=2 u-stress:latest /bin/bash</code></pre> \n<p>然后由 stress 命令创建四个繁忙的进程消耗 CPU 资源：</p> \n<pre><code># stress -c 4</code></pre> \n<p>我们先来看看 docker stats 命令的输出：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMNicib4iaibnN2Ml6dQHQSHnC8DHTVHsckGKIdAYttKZtCf4BQkDO71aCeEkol1ujwygXDnU2P09c35FQ/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>容器 CPU 的负载为 200%，它的含义为单个 CPU 负载的两倍。我们也可以把它理解为有两颗 CPU 在 100% 的为它工作。</p> \n<p>再让我们通过 top 命令看看主机 CPU 的真实负载情况：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMNicib4iaibnN2Ml6dQHQSHnC8DjI1J18F8lqTq9Wohp2rawCpAcibDR25dchIDJMFQyGdiag76OcYVYGQw/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>哈哈，有点大跌眼镜！实际的情况并不是两个 CPU 负载 100%，而另外两个负载 0%。四个 CPU 的负载都是 50%，加起来容器消耗的 CPU 总量就是两个 CPU 100% 的负载。</p> \n<p>看来对于进程来说是没有 CPU 个数这一概念的，内核只能通过进程消耗的 CPU 时间片来统计出进程占用 CPU 的百分比。这也是我们看到的各种工具中都使用百分比来说明 CPU 使用率的原因。</p> \n<p>严谨起见，我们看看 docker 的官方文档中是如何解释 --cpus 选项的：</p> \n<p><strong>Specify how much of the available CPU resources a container can use</strong>.</p> \n<p>果然，人家用的是 \"how much\"，不可数的！并且 --cpus 选项支持设为小数也从侧面说明了对 CPU 的计量只能是百分比。</p> \n<p>看来笔者在本文中写的 \"CPU 个数\" 都是不准确的。既然不准确，为什么还要用？当然是为了容易理解。况且笔者认为在 --cpus 选项的上下文中理解为 \"CPU 个数\" 并没有问题(有兴趣的同学可以读读&nbsp;--cpus 选项的由来，人家的初衷也是要表示 CPU 个数的)。</p> \n<p>虽然 --cpus 选项用起来很爽，但它毕竟是 1.13 才开始支持的。对于更早的版本完成同样的功能我们需要配合使用两个选项：--cpu-period 和 --cpu-quota(1.13 及之后的版本仍然支持这两个选项)。下面的命令实现相同的结果：</p> \n<pre><code>$ docker run -it --rm --cpu-period=100000  --cpu-quota=200000 u-stress:latest /bin/bash</code></pre> \n<p>这样的配置选项是不是让人很傻眼呀！100000 是什么？200000 又是什么？ 它们的单位是微秒，100000 表示 100 毫秒，200000 表示 200 毫秒。它们在这里的含义是：在每 100 毫秒的时间里，运行进程使用的 CPU 时间最多为 200 毫秒(需要两个 CPU 各执行 100 毫秒)。要想彻底搞明白这两个选项的同学可以参考：CFS BandWith Control。我们要知道这两个选项才是事实的真相，但是真相往往很残忍！还好 --cpus 选项成功的解救了我们，其实它就是包装了 --cpu-period 和 --cpu-quota。</p> \n<h5>二、指定固定的 CPU</h5> \n<p>通过 --cpus 选项我们无法让容器始终在一个或某几个 CPU 上运行，但是通过 --cpuset-cpus 选项却可以做到！这是非常有意义的，因为现在的多核系统中每个核心都有自己的缓存，如果频繁的调度进程在不同的核心上执行势必会带来缓存失效等开销。下面我们就演示如何设置容器使用固定的 CPU，下面的命令为容器设置了 --cpuset-cpus 选项，指定运行容器的 CPU 编号为 1：</p> \n<pre><code>$ docker run -it --rm --cpuset-cpus=\"1\" u-stress:latest /bin/bash</code></pre> \n<p>再启动压力测试命令：</p> \n<pre><code># stress -c 4</code></pre> \n<p>然后查看主机 CPU 的负载情况：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMNicib4iaibnN2Ml6dQHQSHnC8DEP03lXySLk9SYK0xTXTAzKdA3ye1GicmdhXE0ms8MPHcukHibN5OPPGw/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这次只有 Cpu1 达到了 100%，其它的 CPU 并未被容器使用。我们还可以反复的执行 stress -c 4 命令，但是始终都是 Cpu1 在干活。</p> \n<p>再看看容器的 CPU 负载，也是只有 100%：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMNicib4iaibnN2Ml6dQHQSHnC8DUAPKCW24ia0gMNf4DSoTQxKBnO8hMEtxUDdNc7jaia3JoHxC6ALdhhOA/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>--cpuset-cpus 选项还可以一次指定多个 CPU：</p> \n<pre><code>$ docker run -it --rm --cpuset-cpus=\"1,3\" u-stress:latest /bin/bash\n</code></pre> \n<p>这次我们指定了 1，3 两个 CPU，运行 stress -c 4 命令，然后检查主机的 CPU 负载：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMNicib4iaibnN2Ml6dQHQSHnC8DAlhaqHazpulsfA0hicpoWt1gF9mDiaZOdobI27ZTJcPU9FjicDlvYQIdw/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Cpu1 和 Cpu3 的负载都达到了 100%。 <br>容器的 CPU 负载也达到了 200%：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMNicib4iaibnN2Ml6dQHQSHnC8DJS7WgGKjr44gnfxsPTHqUjlsA1XR0SUHT0nw0zjk9ibvUia6ZRCWJIqg/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>--cpuset-cpus 选项的一个缺点是必须指定 CPU 在操作系统中的编号，这对于动态调度的环境(无法预测容器会在哪些主机上运行，只能通过程序动态的检测系统中的 CPU 编号，并生成 docker run 命令)会带来一些不便。</p> \n<h5>三、设置使用 CPU 的权重</h5> \n<p>==============</p> \n<p>当 CPU 资源充足时，设置 CPU 的权重是没有意义的。只有在容器争用 CPU 资源的情况下， CPU 的权重才能让不同的容器分到不同的 CPU 用量。--cpu-shares 选项用来设置 CPU 权重，它的默认值为 1024。我们可以把它设置为 2 表示很低的权重，但是设置为 0 表示使用默认值 1024。</p> \n<p>下面我们分别运行两个容器，指定它们都使用 Cpu0，并分别设置 --cpu-shares 为 512 和 1024：</p> \n<pre><code>$ docker run -it --rm --cpuset-cpus=\"0\"  --cpu-shares=512 u-stress:latest /bin/bash`\n    \n$ docker run -it --rm --cpuset-cpus=\"0\"  --cpu-shares=1024 u-stress:latest /bin/bash</code></pre> \n<p>在两个容器中都运行 stress -c 4 命令。</p> \n<p>此时主机 Cpu0 的负载为 100%：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMNicib4iaibnN2Ml6dQHQSHnC8D4tec0FakwCGgdiccSic9Ft731HDvVzduiaWr6uJIibhHtKRTu3bIF8YgVw/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>容器中 CPU 的负载为：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMNicib4iaibnN2Ml6dQHQSHnC8DFQOwxtBuZHGrZNeclNJQyOj9FvFUcbMqkV1IeM8lpBcHlvXMLJPOKQ/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>两个容器分享一个 CPU，所以总量应该是 100%。具体每个容器分得的负载则取决于 --cpu-shares 选项的设置！我们的设置分别是 512 和 1024，则它们分得的比例为 1:2。在本例中如果想让两个容器各占 50%，只要把&nbsp;--cpu-shares 选项设为相同的值就可以了。</p> \n<h5>四、总结</h5> \n<p>====</p> \n<p>相比限制容器用的内存，限制 CPU 的选项要简洁很多。但是简洁绝对不是简单，大多数把复杂东西整简单的过程都会丢失细节或是模糊一些概念，比如从 --cpu-period 和 --cpu-quota 选项到 --cpus 选项的进化。对于使用者来说这当然是好事，可以减缓我们的学习曲线，快速入手。</p>', 'https://mmbiz.qpic.cn/mmbiz_png/D727NicjCjMNicib4iaibnN2Ml6dQHQSHnC8Dq0kGcMPme9NxJysicTllghBeuvd40qGLia9MITeCyyMrPDoUYhmbbO2A/640?tp=webp&amp;wxfrom=5&amp;wx_lazy=1&amp;wx_co=1', 'c56940aa8b004dab84568e86900b2ee6', '646ad4ce7b3c43b89c17dcdea128af0b,50b1ead18a154fb9a3be3ed4bc61398b,753b5aee3913424e81fe2b5299626d8c,81a4561c1c294e0cae32c9fe6b5dc397,3820770e46ef414faee8ed89ce154fdc', '0', '3', '1', '2020-04-16 17:00:04', '2020-04-16 17:00:04');
INSERT INTO `tb_recommend` VALUES ('58be5d1e68f04d78b0df19b4b2fd4ef8', '【译】10个帮助你捕获更多Bug的TypeScript建议', '然而这个想法是错误的！因为TypeScript最终是被编译成JavaScript代码，并且浏览器中运行的也是JavaScript。此时（译者注：运行时）所有的类型信息都丢失了，所以TypeScript无法自动验证类型。', '<blockquote>\n 本文翻译自Miłosz Piechocki提供的TypeScript迷你书\n <a href=\"https://typescriptmasterclass.com\" rel=\"nofollow noreferrer\">https://typescriptmasterclass.com</a>（需要发送邮件获取）\n <p>其个人博客<a href=\"https://codewithstyle.info\" rel=\"nofollow noreferrer\">https://codewithstyle.info</a>也有许多关于TS的文章可以学习。</p> \n</blockquote> \n<h2>1. 对TypeScript提供运行时检查的思考</h2> \n<p>有一个对TypeScript常见的误解是：一个变量只要标注了类型，那么它总是会检查自己的数据类型是否与我们的预期一致。</p> \n<p>与该误解相呼应的想法会认为：对一个从后端返回的对象进行类型标注可以在代码运行时执行检查来确保对象类型的正确性。</p> \n<p>然而这个想法是错误的！因为TypeScript最终是被编译成JavaScript代码，并且浏览器中运行的也是JavaScript。此时（译者注：运行时）所有的类型信息都丢失了，所以TypeScript无法自动验证类型。</p> \n<p>理解这一点的一个好方法是查看编译后的代码：</p> \n<pre><code>interface Person {\n  name: string;\n  age: number;\n}\n\nfunction fetchFromBackend(): Promise&lt;Person&gt; {\n  return fetch(\'http://example.com\')\n      .then((res) =&gt; res.json())\n}\n\n// 编译后\nfunction fetchFromBackend() {\n  return fetch(\'http://example.com\')\n      .then(function(res) {\n        return res.json();\n      })\n}</code></pre> \n<p>可以看到接口定义在编译后已经完全消失了，而且这里也不会有任何验证性的代码。</p> \n<p>不过你最好可以自己去执行运行时校验，许多库（译者注：<a href=\"https://github.com/gcanti/io-ts\" rel=\"nofollow noreferrer\">io-ts</a>）能帮你做到这点。不过，请记住，这一定会带来性能开销。</p> \n<p><strong>* 考虑对所有外部提供的对象执行运行时检查（例如从后端获取的对象，JSON反序列化的对象等）</strong></p> \n<h2>2. 不要将类型定义为any</h2> \n<p>使用TypeScript时，可以将变量或函数参数的类型声明为any，但是这样做也意味着该变量脱离了类型安全保障。</p> \n<p>不过声明为any类型也会有好处，在某种场景下很有帮助（例如将类型逐步添加到现有的JavaScript代码库中，译者注：一般是将代码库从js升级到ts时）。但是它也像一个逃生舱口，会大大降低代码的类型安全性。</p> \n<p>当类型安全涵盖尽可能多的代码时，它是最有效的。否则，安全网中会存在漏洞，漏洞可能会通过漏洞传播。例如：如果函数返回any，则使用其返回值的所有表达式类型也将变成any。</p> \n<p>所以你应该尽量避免使用any类型。幸运的是，TypeScript3.0引入了类型安全的替代方案——unknown。可以将任何值赋给unknown类型的变量，但是不能将unknown类型的变量的值赋给任何变量（这点不同于any）。</p> \n<p>如果你的函数返回的是unknown类型的值，则调用方需要执行检查（使用类型保护），或至少将值显式转换为某个特定类型。（译者注：如果对这段不理解，可以参考下这篇文章，<a href=\"https://juejin.im/post/5d04ac745188250a8b1fd203\" rel=\"nofollow noreferrer\">unknown 类型</a> 中的示例部分）</p> \n<pre><code>let foo: any;\n\n// anything can be assigned to foo\nfoo = \'abc\';\n// foo can be assigned to anything\nconst x: number = foo;\n\n\nlet bar: unknown;\n\n// anything can be assigned to bar\nbar = \'abc\';\n// COMPILE ERROR! Type \'unknown\' is not assignable to type \'number\'.\nconst y: number = bar;</code></pre> \n<p>使用unknown类型有时会有些麻烦，但是这也会让代码更易于理解，并且让你在开发时更加注意。</p> \n<p>另外，你需要开启noImplicitAny，每当编译器推断某个值的类型为any时就会抛出错误。换句话说，它让你显式的标注出所有会出现any的场景。</p> \n<p>尽管最终目标还是消除有any的情况，但明确申明any仍然是有益的：例如在code review时可以更容易捕获他们。</p> \n<p><strong>* 不要使用any类型并开启noImplicitAny</strong></p> \n<h2>3. 开启strictNullChecks</h2> \n<p>你已经见过多少次这样的报错信息了？</p> \n<pre><code>TypeError: undefined is not an object</code></pre> \n<p>我打赌有很多次了，JavaScript（甚至是软件编程）中最常见的bug来源之一就是忘记处理空值。</p> \n<p>在JavaScript中用null或undefined来表示空值。开发者们经常乐观的认为给定的变量不会是空的，于是就忘记处理空值的情况。</p> \n<pre><code>function printName(person: Person) {\n  console.log(person.name.toUpperCase());\n}\n\n// RUNTIME ERROR!  TypeError: undefined is not an object   \n// (evaluating \'person.name\') \nprintName(undefined);</code></pre> \n<p>通过开启strictNullChecks，编译器会迫使你去做相关的检查，这对防止出现这种常见问题起到了重要的作用。</p> \n<p>默认情况下，typescript的每个类型都包含null和undefined这两个值。也就是说，null和undefined可以被赋值给任意类型的任何变量。</p> \n<p>而开启strictNullChecks会更改该行为。由于无法将undefined作为Person类型的参数传递，因此下方的代码会在编译时报错。</p> \n<pre><code>// COMPILE ERROR! \n// Argument of type \'undefined\' is not assignable to parameter of type \'Person\'. printName(undefined); </code></pre> \n<p>那如果你确实就想将<code>undefined</code>传递给printName怎么办？那你可以调整类型签名，但是仍然会要求你处理undefined的情况。</p> \n<pre><code>function printName(person: Person | undefined) {\n  // COMPILE ERROR!\n  // Object is possibly \'undefined\'. \n     console.log(person.name.toUpperCase());\n}</code></pre> \n<p>你可以通过确保person是被定义的来修复这个错误：</p> \n<pre><code>function printName(person: Person | undefined) { \n    if (person) {\n        console.log(person.name.toUpperCase());\n    }\n} </code></pre> \n<p>不幸的是，<code>strictNullChecks</code>默认是不开启的，我们需要在<code>tsconfig.json</code>中进行配置。</p> \n<p>另外，strictNullChecks是更通用的严格模式的一部分，可以通过strict标志启用它。你绝对应该这样做！因为编译器的设置越严格，你就可以尽早发现更多bug。</p> \n<p><strong>* 始终开启strictNullChecks</strong></p> \n<h2>4. 开启strictPropertyInitialization</h2> \n<p><code>strictPropertyInitialization</code>是属于严格模式标志集的另一个标志。尤其在使用Class时开启<code>strictPropertyInitialization</code>很重要，它其实有点像是对<code>strictNullChecks</code>的扩展。</p> \n<p>如果不开启<code>strictPropertyInitialization</code>的话，TS会允许以下的代码：</p> \n<pre><code>class Person {\n  name: string;\n  sayHello() {\n    // RUNTIME ERROR!\n    console.log( `Hello from ${this.name.toUpperCase()}`);\n  }\n} </code></pre> \n<p>这里有个很明显的问题：<code>this.name</code>没有被初始化，因此在运行时调用<code>sayHello</code>就会报错。</p> \n<p>造成这个错误的根本原因是这个属性没有在构造函数里或使用属性初始化器赋值，所以它（至少在最初）是undefined，因此他的类型就会变成string | undefined。</p> \n<p>开启<code>strictPropertyInitialization</code>会提示以下错误：</p> \n<pre><code>Property \'name\' has no initializer and is not assigned in the constructor. </code></pre> \n<p>当然，如果你在构造函数里或使用属性初始化器赋值了，这个错误也就会消失。</p> \n<p><strong>* 始终开启strictPropertyInitialization</strong></p> \n<h2>5. 记得指定函数的返回类型</h2> \n<p>TypeScript使你可以高度依赖类型推断，这意味着只要在TS能推断类型的地方，你就不需要标注类型。</p> \n<p>然而这就像一把双刃剑，一方面，它非常方便，并且减少了使用TypeScript的麻烦。而另一方面，有时推断的类型可能会和你的预期不一致，从而降低了使用静态类型提供的保障。</p> \n<p>在下方的例子中，我们没有注明返回类型，而是让TypeScript来推断函数的返回值。</p> \n<pre><code>interface Person {\n    name: string;\n    age: number;\n}\n\nfunction getName(person: Person | undefined) {\n    if (person &amp;&amp; person.name) {\n        return person.name;\n    } else if (!person) {\n        return \"no name\";\n    }\n}</code></pre> \n<p>乍看之下，我们可能认为我们的方法很安全，并且始终返回的是<code>string</code>类型，然而，当我们明确声明该函数的（预期）返回类型时就会发现报了一个错。</p> \n<pre><code>// COMPILE ERROR! \n// Function lacks ending return statement and return type does not include \'undefined\'. \nfunction getName(person: Person | undefined): string \n{\n    // ... \n}</code></pre> \n<p>顺便说一句，这个错误只有当你开启了<code>strictNullChecks</code>才会被检测出来。</p> \n<p>上述错误表明getName函数的返回值没有覆盖到一种情况：当<code>person</code>不为空，但是<code>person.name</code>为空的情况。这种情况所有if条件都不等于true，所以会返回undefined。</p> \n<p>因此，TypeScript推断此函数的返回类型为<code>string</code> | <code>underfined</code>，而我们声明的却是<code>string</code>。（译者注：所以主动声明函数返回值类型有助于帮我们提前捕捉一些不易察觉的bug）</p> \n<p><strong>* 始终标注函数的返回值类型</strong></p> \n<h2>6. 不要将隐式类型变量存储到对象中</h2> \n<p><strong>TypeScript的类型检查有时很微妙。</strong></p> \n<p>通常，当类型A至少具有和类型B相同的属性，那么TypeScript就允许将类型A的对象赋值给类型B的变量。这意味着它可以包含其他属性。</p> \n<pre><code>// 译者举例：\ntype A = {\n    name: string;\n    age: number;\n};\n\ntype B = {\n    name: string;\n};\n\nlet a: A = {\n    name: \'John\',\n    age: 12,\n};\n\nlet b: B;\n\n// compile success\nb = a;</code></pre> \n<p>然而如果直接传递的是对象字面量，其行为是不同的。只有目标类型包含相同的属性时，TypeScript才会允许它（传递）。此时不允许包含其他属性。</p> \n<pre><code>interface Person {\n    name: string;\n}\n\nfunction getName(person: Person): string | undefined {\n    // ...\n}\n\n// ok\ngetName({ name: \'John\' });\n\n// COMPILE ERROR\n// Argument of type \'{ name: string; age: number; }\' is not assignable to parameter of type \'Person\'.\ngetName({ name: \'John\', age: 30 });</code></pre> \n<p>如果我们不是直接传对象字面量，而是将对象存到常量里（再传递），这看起来没有什么区别。然而这却更改了类型检查的行为：</p> \n<pre><code>const person = { name: \'John\', age: 30 }; \n// OK \ngetName(person); </code></pre> \n<p>传递额外的属性可能会引起bug（例如当你想合并两个对象时）。了解这个行为并且在可能的情况下，直接传递对象字面量。</p> \n<p><strong>* 请注意如何将对象传递给函数并且始终要考虑传递额外的属性是否安全</strong></p> \n<h2>7. 不要过度使用类型断言</h2> \n<p>尽管TypeScript能对你的代码进行很多推断，但有时候你会比TypeScript更了解某个值的详细信息。这时你可以通过类型断言这种方式可以告诉编译器，“相信我，我知道自己在干什么”。</p> \n<p>比如说对一个从服务器请求回来的对象断言，或者将一个子类型的对象断言为父类型。</p> \n<p><strong>类型断言需要保守使用。</strong>比如绝对不能在函数传参类型不匹配时使用。</p> \n<p>有一种更安全的使用类型断言的方式：类型保护。类型保护是一个当返回true时能断言其参数类型的函数。它可以提供代码运行时的检测，让我们对传入的变量是否符合预期这点上更有信心。</p> \n<p>下面的代码中，我们需要使用类型断言，因为TypeScript不知道从后端返回的对象的类型。</p> \n<pre><code>interface Person {\n    name: string;\n    age: number;\n}\n\ndeclare const fetchFromBackend: (url: string) =&gt; Promise&lt;object&gt;;\n\ndeclare const displayPerson: (person: Person) =&gt; void;\n\nfetchFromBackend(\'/person/1\').then((person) =&gt; displayPerson(person as Person));</code></pre> \n<p>我们可以通过使用类型保护，提供一个简单的运行时检查来让代码更完善。我们假设一个对象只要拥有了<code>name</code>和<code>age</code>属性那么它的类型就是<code>Person</code>。</p> \n<pre><code>const isPerson = (obj: Object): obj is Person =&gt; \'name\' in obj &amp;&amp; \'age\' in obj;\n\nfetchFromBackend(\'/person/1\').then((person) =&gt; {\n  if(isPerson(person)) {\n    // Type of `person` is `Person` here!\n    displayPerson(person);\n  }\n})</code></pre> \n<p>你可以发现，多亏了类型保护，在if语句中person的类型已经可以被正确推断了。</p> \n<p><strong>* 考虑使用类型保护来替代类型断言</strong></p> \n<h2>8. 不要对Partial类型使用扩展运算符</h2> \n<p>Partial是一个非常有用的类型，它的作用是将源类型的每个属性都变成可选的。</p> \n<p>Partial有个好的实际使用场景：当你有一个表示配置或选项的对象类型，并且想要创建一个该配置对象的子集来覆写它。</p> \n<p>你可能会写出如下的代码：</p> \n<pre><code>interface Settings {\n  a: string;\n  b: number;\n}\n\nconst defaultSettings: Settings = { /* ... */ }; \n\nfunction getSettings(overrides: Partial&lt;Settings&gt;): Settings {\n  return { ...defaultSettings, ...overrides };\n}</code></pre> \n<p>这看起来还不错，但实际上揭示了TypeScript的类型系统中的一个漏洞。</p> \n<p>看下方的代码，<code>result</code>的类型是<code>Settings</code>，然而<code>result.a</code>的值却是<code>undefined</code>了。</p> \n<pre><code>const result = getSettings({ a: undefined, b: 2 });</code></pre> \n<p>由于扩展Partial是一种常见的模式，并且TypeScript的目标之一是在严格性和便利性之间取得平衡，所以可以说是TypeScript本身的设计带来了这种不一致性。但是，意识到该问题仍然非常重要。</p> \n<p><strong>* 除非你确定对象里不包含显式的undefined，否则不要对Parital对象使用扩展运算符</strong></p> \n<h2>9. 不要过于相信Record类型</h2> \n<p>这是TypeScript内置类型定义中的一个微妙情况的另一个示例。</p> \n<p>Record定义了一个对象类型，其中所有key具有相同的类型，所有value具有相同的类型。 这非常适合表示值的映射和字典。</p> \n<p>换句话说，<code>Record&lt;KeyType, ValueType&gt;</code> 等价于 <code>{ [key: KeyType]: ValueType }</code>。</p> \n<p>从下方代码你可以看出，通过访问record对象的属性返回的值的类型应该和ValueType保持一致。然而你会发现这不是完全正确的，因为abc的值会是undefined。</p> \n<pre><code>const languages: Record&lt;string, string&gt; = {\n    \'c++\': \'static\',\n    \'java\': \'static\',\n    \'python\': \'dynamic\',\n};\n\n\nconst abc: string = languages[\'abc\']; // undefined</code></pre> \n<p>这又是一个TypeScript选择了便利性而不是严格性的例子。虽然大多数例子中这样使用都是可以的，但是你仍然要小心些。</p> \n<p>最简单的修复方式就是使Record的第二个参数可选：</p> \n<pre><code>const languages: Partial&lt;Record&lt;string, string&gt;&gt; = {\n    \'c++\': \'static\',\n    \'java\': \'static\',\n    \'python\': \'dynamic\',\n};\n\nconst abc = languages[\'abc\']; // abc is infer to string | underfined</code></pre> \n<p><strong>* 除非你确保没问题，否则可以始终保持Record的值类型参数（第二个参数）可选</strong></p> \n<h2>10. 不要允许出现不合格的类型声明</h2> \n<p>在定义业务域对象的类型时，通常会遇到类似以下的情况：</p> \n<pre><code>interface Customer {\n    acquisitionDate: Date;\n    type: CustomerType;\n    firstName?: string;\n    lastName?: string;\n    socialSecurityNumber?: string;\n    companyName?: string;\n    companyTaxId?: number;\n}</code></pre> \n<p>这个对象包含很多可选的对象。其中一些对象是当Customer表示人时（<code>type === CustomerType.Individual</code>）才有意义且必填，另外的则是当Custormer表示公司时（<code>type === CustomerType.Institution</code>）必填。</p> \n<p>问题在于Customer类型不能反映这一点！ 换句话说，它允许属性的某些非法组合（例如，lastName和companyName都未定义）</p> \n<p>这确实是有问题的。 你要么执行额外的检查，要么使用类型断言来消除基于type属性值的某些字段的可选性。</p> \n<p>幸运的是,有一个更好的解决方案——辨析联合类型。辨析联合类型是在联合类型的基础上增加了一个功能：在运行时可以区分不同的方案。</p> \n<p>我们将Customer类型重写为两种类型：<code>Individual</code>和<code>Institution</code>的联合，各自包含一些特定的字段，并且有一个共有字段：<code>type</code>，它的值是一个字符串。此字段允许运行时检查，并且TypeScript知道可以专门处理它。</p> \n<pre><code>interface Individual {\n  kind: \'individual\';\n  firstName: string;\n  lastName: string;\n  socialSecurityNumber: number;\n}\n\ninterface Institution {\n  kind: \'institutional\';\n  companyName: string;\n  companyTaxId: number;\n}\n\ntype Customer = Individual | Institution;</code></pre> \n<p>辨析联合类型真正酷的地方是TypeScript提供了内置的类型保护，可以让你避免类型断言。</p> \n<pre><code>function getCustomerName(customer: Customer) {\n  if (customer.kind === \'individual\') {\n    // The type of `customer` id `Individual`\n    return customer.lastName;\n  } else {\n    // The type of `customer` id `Institution`\n    return customer.companyName;\n  }\n}</code></pre> \n<p><strong>* 当遇到复杂的业务对象时尽量考虑使用辨析联合类型。这可以帮你创建更贴合现实场景的类型</strong></p> \n<p>文章到此结束了！我希望这个列表可以像帮助我一样，帮助你捕获许多讨厌的bug。</p> \n<p><strong>接下来是这篇文章所有建议的总结：</strong></p> \n<ol> \n <li><strong>考虑对所有外部提供的对象执行运行时检查（例如从后端获取的对象，JSON反序列化的对象等）</strong></li> \n <li><strong>不使要用any类型并开启noImplicitAny</strong></li> \n <li><strong>始终开启strictNullChecks</strong></li> \n <li><strong>始终开启strictPropertyInitialization</strong></li> \n <li><strong>始终标注函数的返回值类型</strong></li> \n <li><strong>请注意如何将对象传递给函数并且始终要考虑传递额外的属性是否安全</strong></li> \n <li><strong>考虑使用类型保护来替代类型断言</strong></li> \n <li><strong>除非你确定对象里不包含显式的undefined，否则不要对Parital对象使用扩展运算符</strong></li> \n <li><strong>除非你确保没问题，否则可以始终保持Record的值类型参数（第二个参数）可选</strong></li> \n <li><strong>当遇到复杂的业务对象时尽量考虑使用辨析联合类型。</strong></li> \n</ol>', null, 'c56940aa8b004dab84568e86900b2ee6', '1062207552f54e86b0a1ad8dd7c0a888,d79254c4ca5e45dca9d484307c935281,63c4e1e7ec204b43a62065a3ced4c2ce,9cf3c6405733421e9693ef7c6e1885c8,fe12e28fbbf0499eb1f1008377ea09ff', '0', '3', '1', '2020-04-16 16:47:18', '2020-04-16 16:47:18');
INSERT INTO `tb_recommend` VALUES ('598f373208164cd9a44066367fabe421', 'Mozilla 开源支持项目发起 COVID-19 解决方案基金，接受全球项目申请', 'SegmentFault 思否消息：近日 Mozilla Open Source Support Program (MOSS）发起了COVID-19 Solutions Fund，将向响应疫情的开源技术项目提供最高 5 万美元的资金。MOSS 称它接受硬件、软件以及相关项目的申请。M...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022250952\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>SegmentFault 思否消息：近日 Mozilla Open Source Support Program (MOSS）发起了<a href=\"https://blog.mozilla.org/blog/2020/03/31/moss-launches-covid-19-solutions-fund/\" rel=\"nofollow noreferrer\">COVID-19 Solutions Fund</a>，将向响应疫情的开源技术项目提供最高 5 万美元的资金。MOSS 称它接受硬件、软件以及相关项目的申请。MOSS 是 Mozilla 在 2015 年发起了开源支持计划，向开源项目捐助开发资金，帮助开源项目可持续的发展。</p> \n<p>Mozilla 接受硬件（如开源呼吸机）、软件（如连接医院和能提供 3D 打印机打印开源呼吸机零部件的用户的平台），以及解决因 COVID-19 引起的二次效应的软件（如打击&nbsp;COVID-19 假信息的浏览器插件）等相关项目的申请。</p> \n<p><strong>几个关键细节：</strong></p> \n<ol> \n <li>优先考虑为合理成熟的项目提供资金，早期的想法不太可能获得资金。</li> \n <li>希望获奖者在获奖后三个月内使用所有资金。</li> \n <li>将在法律允许的范围内接受来自世界各地的申请。</li> \n <li>将接受任何类型的法律实体的申请，包括非政府组织、营利性医院或与受影响社区有密切联系的开发商团队。</li> \n <li>申请将被按照顺序轮流接受和审查。</li> \n <li>MOSS委员会将只考虑那些根据 FSF 的自由软件许可证或 OSI 的开源许可证公开发布的项目。未获得开放源代码许可使用许可的项目没有资格获得 MOSS 资助。</li> \n</ol> \n<p>申请地址：<a href=\"https://mozilla.fluxx.io/apply/MOSS\" rel=\"nofollow noreferrer\">https://mozilla.fluxx.io/apply/MOSS</a></p> \n<hr> \n<p>MOSS 官方声明原文：<a href=\"https://blog.mozilla.org/blog/2020/03/31/moss-launches-covid-19-solutions-fund/\" rel=\"nofollow noreferrer\"><strong>MOSS launches COVID-19 Solutions Fund</strong></a></p> \n<p>Mozilla is announcing today the creation of a COVID-19 Solutions Fund as part of the Mozilla Open Source Support Program (MOSS). Through this fund, we will provide awards of up to $50,000 each to open source technology projects which are responding to the COVID-19 pandemic in some way.</p> \n<p>The MOSS Program, created in 2015, broadens access, increases security, and empowers users by providing catalytic funding to open source technologists. We have already seen inspiring examples of open source technology being used to increase the capacity of the world’s healthcare systems to cope with this crisis. For example, just a few days ago, the University of Florida Center for Safety, Simulation, and Advanced Learning Technologies released an<a href=\"https://simulation.health.ufl.edu/technology-development/open-source-ventilator-project/\" rel=\"nofollow noreferrer\">open source ventilator</a>. We believe there are many more life-saving open source technologies in the world.</p> \n<p>As part of the COVID-19 Solutions Fund, we will accept applications that are hardware (e.g., an open source ventilator), software (e.g., a platform that connects hospitals with people who have 3D printers who can print parts for that open source ventilator), as well as software that solves for secondary effects of COVID-19 (e.g., a browser plugin that combats COVID related misinformation).</p> \n<p>A few key details of the program:</p> \n<ul> \n <li>We are generally looking to fund reasonably mature projects that can immediately deploy our funding, early stage ideas are unlikely to receive funding.</li> \n <li>We generally expect awardees to use all funds within three months of receiving the award.</li> \n <li>We will accept applications from anywhere in the world to the extent legally permitted.</li> \n <li>We will accept applications from any type of legal entity, including NGOs, for profit hospitals, or a team of developers with strong ties to an affected community.</li> \n <li>Applications will be accepted and reviewed on a rolling basis.</li> \n <li>The MOSS committee will only consider projects which are released publicly under a license that is either a free software license according to the FSF or an open source license according to the OSI. Projects which are not licensed for use under an open source license are not eligible for MOSS funding.</li> \n</ul> \n<p>To apply, please visit:<a href=\"https://mozilla.fluxx.io/apply/MOSS\" rel=\"nofollow noreferrer\">https://mozilla.fluxx.io/apply/MOSS</a></p> \n<p>For more information about the MOSS program, please visit:<a href=\"https://www.mozilla.org/moss\" rel=\"nofollow noreferrer\">Mozilla.org/moss</a>.</p> \n<p><strong>ABOUT MOSS</strong></p> \n<p><em>The Mozilla Open Source Support (MOSS) awards program, created in 2015, broadens access, increases security, and empowers users by providing catalytic funding to open source technologists. In addition to the COVID-19 Solutions Fund, MOSS has three tracks:</em></p> \n<ul> \n <li><em>Track I – Foundational Technology: supports open source projects that Mozilla relies on, either as an embedded part of our products or as part of our everyday work.</em></li> \n <li><em>Track II – Mission Partners: supports open source projects that significantly advance Mozilla’s mission.</em></li> \n <li><em>Track III – The Secure Open Source Fund: supports security audits for widely used open source software projects as well as any work needed to fix the problems that are found.</em></li> \n</ul> \n<p><em>Tracks I and II and this new COVID-19 Solutions Fund accept applications on a rolling basis. For more information about the MOSS program, please visit:<a href=\"https://www.mozilla.org/moss\" rel=\"nofollow noreferrer\">Mozilla.org/moss</a>.&nbsp;</em></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"sf.png\" title=\"sf.png\"></span></p>', 'https://segmentfault.com/img/remote/1460000022250952', '61cdf41d1e5e4f229b76f6a042e254b6', '7415188933514e5ab6d45d3645d83337,f3eb17e6e5664a97af3e9b1fca12b286,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-16 16:59:31', '2020-04-16 16:59:31');
INSERT INTO `tb_recommend` VALUES ('599e62da599941069f130638f336b3e4', '全球电信行业榜单发布，华为霸榜基建品牌，国内三大运营商均入榜', '近日，英国品牌评估机构 Brand Finance 发布《Telecoms 150 2020》年度报告，其中最具价值的电信品牌中，国内三大运营商均上榜；在电信基础设施品牌的两项榜单中，华为均高居榜首。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF15Z\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>近日，英国品牌评估机构 Brand Finance 发布《Telecoms 150 2020》年度报告，其中最具价值的电信品牌中，国内三大运营商均上榜；在电信基础设施品牌的两项榜单中，华为均高居榜首。</p> \n<h2>最有价值的 20 个品牌</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF14e\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>Verizon 现在是世界上最有价值的品牌，因其总体的性能、网络可靠性、网络速度、数据 性能、通话和短信性能目前价值 637 亿美元，超过其美国竞争对手 AT&amp;T (591亿美元) 。并且 AT&amp;T 也是此次跌幅最大的电信品牌，也是近一年来首次降至第二位。</p> \n<p>中国移动位列第三，排名较去年没有变动；中国电信排名第七，中国联通排名第十四。</p> \n<h2>最具实力的 20 个品牌</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF14D\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>除了衡量品牌的整体价值外，Brand Finance 还对品牌的相对实力进行了评估。基于营销投入等因素，熟悉度、忠诚度、员工满意度和企业的美誉度。在预测收入时，品牌实力是品牌价值的重要驱动力。</p> \n<p>根据这些标准，泰国的 AIS 是世界上最具实力的电信品牌，得分 92 分，AAA+。</p> \n<p>作为泰国最大的移动通信运营商，AIS 通过赞助泰国游戏展，充分利用了泰国蓬勃发展的移动游戏产业。AIS 近日还证实了一项转授权交易，已获权直播被推迟的 2020 年东京奥运会，2020年青年奥运会、2022 年北京冬奥会及 2022 年达喀尔青年奥运会。</p> \n<p>在品牌实力这一榜单中，中国移动排名第七，联通和电信未上榜。</p> \n<h2>电信基础设施排行榜</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF146\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>在全球十大最有价值和十大最具实力的电信基础设施品牌榜单中，华为均占据榜首，中国厂商 4 家入选。</p> \n<p>电信业下一个大的机会就是基础设施行业，5G 的发展让这一领域产生了激烈的竞争，华为也通过自身的实力开始扩张进入西方国家的市场。尽管引发了很多争议，但华为已经取得明显的进展，品牌价值也达到了 651 亿美元。</p> \n<hr> \n<p>更多榜单内容及报告完整版 PDF，可扫描下方二维码回复「电信行业」获取。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFPnI\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbF15Z', '5ca4567d892841b087fac5246effac40', 'cb77a1c04f4241b98e8f6d57d78e3e10,dced02b7f53045f9b0bc172e06ba8202,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-16 17:00:14', '2020-04-16 17:00:14');
INSERT INTO `tb_recommend` VALUES ('59f5946095554e2d92041df7d0b49db1', '面试问我，创建多少个线程合适？我该怎么说', '你有一个思想，我有一个思想，我们交换后，一个人就有两个思想 If you can NOT explain it simply, you do NOT understand it well enough', '<p>| <strong>如果好看，请给个赞</strong></p> \n<blockquote>\n <ul> \n  <li>你有一个思想，我有一个思想，我们交换后，一个人就有两个思想</li> \n  <li>If you can NOT explain it simply, you do NOT understand it well enough</li> \n </ul>\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIun\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>为什么要使用多线程？</h2> \n<blockquote>\n 防止并发编程出错最好的办法就是不写并发程序\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuo\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>既然多线程编程容易出错，为什么它还经久不衰呢？</p> \n<p><strong>A：那还用说，肯定在某些方面有特长呗，比如你知道的【它很快，非常快】</strong></p> \n<p>我也很赞同这个答案，但说的不够具体</p> \n<h2>并发编程适用于什么场景？</h2> \n<p>如果问你选择多线程的原因就是一个【快】字，面试也就不会出那么多幺蛾子了。你有没有问过你自己</p> \n<ol> \n <li>并发编程在所有场景下都是快的吗？</li> \n <li>知道它很快，何为快？怎样度量？</li> \n</ol> \n<p>想知道这两个问题的答案，我们需要一个从【定性】到【定量】的分析过程</p> \n<blockquote>\n 使用多线程就是在正确的场景下通过设置正确个数的线程来最大化程序的运行速度（我感觉你还是啥也没说）\n</blockquote> \n<p>将这句话翻译到硬件级别就是要充分的利用 CPU 和 I/O 的利用率</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIup\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>两个正确得到保证，也就能达到最大化利用 CPU 和 I/O的目的了。最关键是，如何做到两个【正确】？</p> \n<p>在聊具体场景的时候，我们必须要拿出我们的专业性来。送你两个名词 buff 加成</p> \n<ul> \n <li>CPU 密集型程序</li> \n <li>I/O 密集型程序</li> \n</ul> \n<h3>CPU 密集型程序</h3> \n<blockquote>\n 一个完整请求，I/O操作可以在很短时间内完成， CPU还有很多运算要处理，也就是说 CPU 计算的比例占很大一部分\n</blockquote> \n<p>假如我们要计算 1+2+....100亿 的总和，很明显，这就是一个 CPU 密集型程序</p> \n<p>在【单核】CPU下，如果我们创建 4 个线程来分段计算，即：</p> \n<ol> \n <li>线程1计算 <code>[1,25亿）</code> </li> \n <li>...... 以此类推</li> \n <li>线程4计算 <code>[75亿，100亿]</code> </li> \n</ol> \n<p>我们来看下图他们会发生什么？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuq\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>由于是单核 CPU，所有线程都在等待 CPU 时间片。按照理想情况来看，四个线程执行的时间总和与一个线程5独自完成是相等的，实际上我们还忽略了四个线程上下文切换的开销</p> \n<p><strong>所以，单核CPU处理CPU密集型程序，这种情况并不太适合使用多线程</strong></p> \n<p>此时如果在 4 核CPU下，同样创建四个线程来分段计算，看看会发生什么？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIur\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>每个线程都有 CPU 来运行，并不会发生等待 CPU 时间片的情况，也没有线程切换的开销。理论情况来看效率提升了 4 倍</p> \n<p><strong>所以，如果是多核CPU 处理 CPU 密集型程序，我们完全可以最大化的利用 CPU 核心数，应用并发编程来提高效率</strong></p> \n<h3>I/O密集型程序</h3> \n<blockquote>\n 与 CPU 密集型程序相对，一个完整请求，CPU运算操作完成之后还有很多 I/O 操作要做，也就是说 I/O 操作占比很大部分\n</blockquote> \n<p>我们都知道在进行 I/O 操作时，CPU是空闲状态，所以我们要最大化的利用 CPU，不能让其是空闲状态</p> \n<p>同样在单核 CPU 的情况下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIus\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>从上图中可以看出，每个线程都执行了相同长度的 CPU 耗时和 I/O 耗时，如果你将上面的图多画几个周期，CPU操作耗时固定，将 I/O 操作耗时变为 CPU 耗时的 3 倍，你会发现，CPU又有空闲了，这时你就可以新建线程 4，来继续最大化的利用 CPU。</p> \n<p>综上两种情况我们可以做出这样的总结：</p> \n<blockquote>\n <strong>线程等待时间所占比例越高，需要越多线程；线程CPU时间所占比例越高，需要越少线程。</strong>\n</blockquote> \n<p>到这里，相信你已经知道第一个【正确】使用多线程的场景了，那创建多少个线程是正确的呢？</p> \n<h2>创建多少个线程合适？</h2> \n<p>面试如果问到这个问题，这可是对你理论和实践的统考。想完全答对，你必须要【精通/精通/精通】<strong>小学算术</strong></p> \n<p>从上面知道，我们有 CPU 密集型和 I/O 密集型两个场景，不同的场景当然需要的线程数也就不一样了</p> \n<h3>CPU 密集型程序创建多少个线程合适？</h3> \n<p>有些同学早已经发现，对于 CPU 密集型来说，理论上 <code>线程数量 = CPU 核数（逻辑）</code> 就可以了，但是实际上，数量一般会设置为 <code>CPU 核数（逻辑）+ 1</code>， 为什么呢？</p> \n<p>《Java并发编程实战》这么说：</p> \n<blockquote>\n 计算密（CPU）集型的线程恰好在某时因为发生一个页错误或者因其他原因而暂停，刚好有一个“额外”的线程，可以确保在这种情况下CPU周期不会中断工作。\n</blockquote> \n<p>所以对于CPU密集型程序， <code>CPU 核数（逻辑）+ 1</code> 个线程数是比较好的经验值的原因了</p> \n<h3>I/O密集型程序创建多少个线程合适？</h3> \n<p>上面已经让大家按照图多画几个周期（你可以动手将I/O耗时与CPU耗时比例调大，比如6倍或7倍），这样你就会得到一个结论，对于 I/O 密集型程序：</p> \n<blockquote>\n 最佳线程数 = \n <code>(1/CPU利用率)</code> = \n <code>1 + (I/O耗时/CPU耗时)</code> \n</blockquote> \n<p>我这么体贴，当然担心有些同学不理解这个公式，我们将上图的比例手动带入到上面的公式中：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIut\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这是一个CPU核心的最佳线程数，如果多个核心，那么 I/O 密集型程序的最佳线程数就是：</p> \n<blockquote>\n 最佳线程数 = \n <code>CPU核心数</code> \n <em> <code>(1/CPU利用率)</code> = <code>CPU核心数</code> </em> \n <code>1 + (I/O耗时/CPU耗时)</code> \n</blockquote> \n<p>说到这，有些同学可能有疑问了，要计算 I/O 密集型程序，是要知道 CPU 利用率的，如果我不知道这些，那要怎样给出一个初始值呢？</p> \n<p>按照上面公式，假如几乎全是 I/O耗时，所以纯理论你就可以说是 <strong>2N（N=CPU核数），当然也有说 2N + 1的</strong>，（我猜这个 1 也是 backup），没有找到具体的推倒过程，在【并发编程实战-8.2章节】截图在此，大家有兴趣的可以自己看看</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuu\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>理论上来说，理论上来说，理论上来说</strong>，这样就能达到 CPU 100% 的利用率</p> \n<p>如果理论都好用，那就用不着实践了，也就更不会有调优的事出现了。<strong>不过在初始阶段，我们确实可以按照这个理论之作为伪标准， 毕竟差也可能不会差太多，这样调优也会更好一些</strong></p> \n<p>谈完理论，咱们说点实际的，公式我看懂了（定性阶段结束），但是我有两个疑问：</p> \n<ol> \n <li>我怎么知道具体的 I/O耗时和CPU耗时呢？</li> \n <li>怎么查看CPU利用率？</li> \n</ol> \n<p>没错，我们需要定量分析了</p> \n<p>幸运的是，我们并不是第一个吃螃蟹的仔儿，其实有很多 APM （Application Performance Manager）工具可以帮我们得到准确的数据，学会使用这类工具，也就可以结合理论，在调优的过程得到更优的线程个数了。我这里简单列举几个，具体使用哪一个，具体应用还需要你自己去调研选择，受篇幅限制，暂不展开讨论了</p> \n<ol> \n <li>SkyWalking</li> \n <li>CAT</li> \n <li>zipkin</li> \n</ol> \n<p>上面了解了基本的理论知识，那面试有可能问什么？又可能会以怎样的方式提问呢？</p> \n<h2>面试小问</h2> \n<h3>小问一</h3> \n<blockquote>\n 假设要求一个系统的 TPS（Transaction Per Second 或者 Task Per Second）至少为20，然后假设每个Transaction由一个线程完成，继续假设平均每个线程处理一个Transaction的时间为4s\n</blockquote> \n<p><strong>如何设计线程个数，使得可以在1s内处理完20个Transaction？</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuv\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>但是，但是，这是因为没有考虑到CPU数目。家里又没矿，一般服务器的CPU核数为16或者32，如果有80个线程，那么肯定会带来太多不必要的线程上下文切换开销（希望这句话你可以主动说出来），这就需要调优了，来做到最佳 balance</p> \n<h3>小问二</h3> \n<blockquote>\n 计算操作需要5ms，DB操作需要 100ms，对于一台 8个CPU的服务器，怎么设置线程数呢？\n</blockquote> \n<p>如果不知道请拿三年级期末考试题重新做（今天晚自习留下来），答案是：</p> \n<p><strong>线程数 = 8 * (1 + 100/5) = 168 (个)</strong></p> \n<blockquote>\n 那如果DB的 QPS（Query Per Second）上限是1000，此时这个线程数又该设置为多大呢？\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuw\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>同样，这是没有考虑 CPU 数目，接下来就又是细节调优的阶段了</p> \n<p>因为一次请求不仅仅包括 CPU 和 I/O操作，具体的调优过程还要考虑内存资源，网络等具体内容</p> \n<h2>增加 CPU 核数一定能解决问题吗？</h2> \n<p>看到这，有些同学可能会认为，即便我算出了理论线程数，但实际CPU核数不够，会带来线程上下文切换的开销，所以下一步就需要增加 CPU 核数，那我们盲目的增加 CPU 核数就一定能解决问题吗？</p> \n<p>在讲互斥锁的内容是，我故意遗留了一个知识:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIux\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>怎么理解这个公式呢？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFIuy\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这个结论告诉我们，假如我们的串行率是 5%，那么我们无论采用什么技术，最高也就只能提高 20 倍的性能。</p> \n<p>如何简单粗暴的理解串行百分比（其实都可以通过工具得出这个结果的）呢？来看个小 Tips：</p> \n<blockquote> \n <strong>Tips:</strong> 临界区都是串行的，非临界区都是并行的，用单线程执行临界区的时间/用单线程执行(临界区+非临界区)的时间就是串行百分比\n</blockquote> \n<p>现在你应该理解我在讲解 synchronized 关键字时所说的：</p> \n<blockquote>\n 最小化临界区范围，因为临界区的大小往往就是瓶颈问题的所在，不要像乱用try catch那样一锅端\n</blockquote> \n<h2>总结</h2> \n<p>多线程不一定就比但线程高效，比如大名鼎鼎的 Redis （后面会分析），因为它是基于内存操作，这种情况下，单线程可以很高效的利用CPU。而多线程的使用场景一般时存在相当比例的I/O或网络操作</p> \n<p>另外，结合小学数学题，我们已经了解了如何从定性到定量的分析的过程，在开始没有任何数据之前，我们可以使用上文提到的经验值作为一个伪标准，其次就是结合实际来逐步的调优（综合 CPU，内存，硬盘读写速度，网络状况等）了</p> \n<p>最后，盲目的增加 CPU 核数也不一定能解决我们的问题，这就要求我们严格的编写并发程序代码了</p> \n<h2>灵魂追问</h2> \n<ol> \n <li>我们已经知道创建多少个线程合适了，为什么还要搞一个线程池出来？</li> \n <li>创建一个线程都要做哪些事情？为什么说频繁的创建线程开销很大？</li> \n <li>多线程通常要注意共享变量问题，为什么局部变量就没有线程安全问题呢？</li> \n <li>......</li> \n</ol> \n<p>下一篇文章，我们就来说说，你熟悉又陌生的线程池问题</p> \n<h2>参考</h2> \n<p>感谢前辈们总结的精华，自己所写的并发系列好多都参考了以下资料</p> \n<ul> \n <li>Java 并发编程实战</li> \n <li>Java 并发编程之美</li> \n <li>码出高效</li> \n <li>Java 并发编程的艺术</li> \n <li>......</li> \n</ul> \n<p>日拱一兵 ｜ 原创</p>', 'https://segmentfault.com/img/bVbFIun', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-16 16:47:16', '2020-04-16 16:47:16');
INSERT INTO `tb_recommend` VALUES ('5a83140406ea451bab8ca00381ca7b36', '你也许不知道的javascript高级函数', '高阶函数是对其他函数进行操作的函数，可以将它们作为参数或通过返回它们。简单来说，高阶函数是一个函数，它接收函数作为参数或将函数作为输出返回。', '<h2>前言</h2> \n<p>高阶函数是对其他函数进行操作的函数，可以将它们作为参数或通过返回它们。简单来说，高阶函数是一个函数，它接收函数作为参数或将函数作为输出返回。</p> \n<p>例如<code>Array.prototype.map</code>，<code>Array.prototype.filter</code>，<code>Array.prototype.reduce</code> 都是一些高阶函数。</p> \n<p>本文源自我的掘金 <a href=\"https://juejin.im/post/5e96c3eee51d4546f5790df1\" rel=\"nofollow noreferrer\">https://juejin.im/post/5e96c3...</a><br>欢迎阅读其他js系列文章</p> \n<p><a href=\"https://juejin.im/post/5e23eae9f265da3e2a79230c\" rel=\"nofollow noreferrer\">JS基础总结（1）——数据类型</a><br><a href=\"https://juejin.im/post/5e25017a6fb9a030026e804e\" rel=\"nofollow noreferrer\">JS基础总结（2）——原型与原型链</a><br><a href=\"https://juejin.im/post/5e264f7d51882520c02c8f3e\" rel=\"nofollow noreferrer\">JS基础总结（3）——作用域和闭包</a><br><a href=\"https://juejin.im/post/5e33c069e51d4577794c11ed\" rel=\"nofollow noreferrer\">JS基础总结（4）——this指向及call/apply/bind</a><br><a href=\"https://juejin.im/post/5e37de90f265da3e413f6150\" rel=\"nofollow noreferrer\">JS基础总结（5）—— JS执行机制与EventLoopd</a></p> \n<h2>尾调用和尾递归</h2> \n<p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚。就是指某个函数的最后一步是调用另一个函数。</p> \n<pre><code>function g(x) {\n  console.log(x)\n}\nfunction f(x) {\n  return g(x)\n}\nconsole.log(f(1))\n//上面代码中，函数f的最后一步是调用函数g，这就是尾调用。</code></pre> \n<p>上面代码中，函数 f 的最后一步是调用函数 g，这就是尾调用。尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p> \n<p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生栈溢出错误。但是队伍尾递归来说，由于只存在一个调用帧，所以永远不会发生栈溢出错误。</p> \n<pre><code>function factorial(n) {\n  if (n === 1) {\n    return 1\n  }\n  return n * factorial(n - 1)\n}</code></pre> \n<p>上面代码是一个阶乘函数，计算 n 的阶乘，最多需要保存 n 个调用数据，复杂度为 O（n），如果改写成尾调用，只保留一个调用记录，复杂度为 O（1）。</p> \n<pre><code>function factor(n, total) {\n  if (n === 1) {\n    return total\n  }\n  return factor(n - 1, n * total)\n}</code></pre> \n<p>斐波拉切数列也是可以用于尾调用。</p> \n<pre><code>function Fibonacci(n) {\n  if (n &lt;= 1) {\n    return 1\n  }\n  return Fibonacci(n - 1) + Fibonacci(n - 2)\n}\n//尾递归\nfunction Fibona(n, ac1 = 1, ac2 = 1) {\n  if (n &lt;= 1) {\n    return ac2\n  }\n  return Fibona(n - 1, ac2, ac1 + ac2)\n}</code></pre> \n<h2>柯理化函数</h2> \n<p>在数学和计算机科学中，柯里化是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。<strong>所谓柯里化就是把具有较多参数的函数转换成具有较少参数的函数的过程。</strong> <br>举个例子</p> \n<pre><code>//普通函数\nfunction fn(a, b, c, d, e) {\n  console.log(a, b, c, d, e)\n}\n//生成的柯里化函数\nlet _fn = curry(fn)\n\n_fn(1, 2, 3, 4, 5) // print: 1,2,3,4,5\n_fn(1)(2)(3, 4, 5) // print: 1,2,3,4,5\n_fn(1, 2)(3, 4)(5) // print: 1,2,3,4,5\n_fn(1)(2)(3)(4)(5) // print: 1,2,3,4,5</code></pre> \n<p>柯理化函数的实现</p> \n<pre><code>// 对求和函数做curry化\nlet f1 = curry(add, 1, 2, 3)\nconsole.log(\'复杂版\', f1()) // 6\n\n// 对求和函数做curry化\nlet f2 = curry(add, 1, 2)\nconsole.log(\'复杂版\', f2(3)) // 6\n\n// 对求和函数做curry化\nlet f3 = curry(add)\nconsole.log(\'复杂版\', f3(1, 2, 3)) // 6\n\n// 复杂版curry函数可以多次调用，如下：\nconsole.log(\'复杂版\', f3(1)(2)(3)) // 6\nconsole.log(\'复杂版\', f3(1, 2)(3)) // 6\nconsole.log(\'复杂版\', f3(1)(2, 3)) // 6\n\n// 复杂版(每次可传入不定数量的参数，当所传参数总数不少于函数的形参总数时，才会执行)\nfunction curry(fn) {\n  // 闭包\n  // 缓存除函数fn之外的所有参数\n  let args = Array.prototype.slice.call(arguments, 1)\n  return function() {\n    // 连接已缓存的老的参数和新传入的参数(即把每次传入的参数全部先保存下来，但是并不执行)\n    let newArgs = args.concat(Array.from(arguments))\n    if (newArgs.length &lt; fn.length) {\n      // 累积的参数总数少于fn形参总数\n      // 递归传入fn和已累积的参数\n      return curry.call(this, fn, ...newArgs)\n    } else {\n      // 调用\n      return fn.apply(this, newArgs)\n    }\n  }\n}</code></pre> \n<h3>柯里化的用途</h3> \n<p>柯里化实际是把简答的问题复杂化了，但是复杂化的同时，我们在使用函数时拥有了更加多的自由度。 而这里对于函数参数的自由处理，正是柯里化的核心所在。 柯里化本质上是降低通用性，提高适用性。来看一个例子：</p> \n<p>我们工作中会遇到各种需要通过正则检验的需求，比如校验电话号码、校验邮箱、校验身份证号、校验密码等， 这时我们会封装一个通用函数 checkByRegExp ,接收两个参数，校验的正则对象和待校验的字符串</p> \n<pre><code>function checkByRegExp(regExp, string) {\n  return regExp.text(string)\n}\n\ncheckByRegExp(/^1\\d{10}$/, \'18642838455\') // 校验电话号码\ncheckByRegExp(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/, \'test@163.com\') // 校验邮箱</code></pre> \n<p>我们每次进行校验的时候都需要输入一串正则，再校验同一类型的数据时，相同的正则我们需要写多次， 这就导致我们在使用的时候效率低下，并且由于 checkByRegExp 函数本身是一个工具函数并没有任何意义。此时，我们可以借助柯里化对 checkByRegExp 函数进行封装，以简化代码书写，提高代码可读性。</p> \n<pre><code>//进行柯里化\nlet _check = curry(checkByRegExp)\n//生成工具函数，验证电话号码\nlet checkCellPhone = _check(/^1\\d{10}$/)\n//生成工具函数，验证邮箱\nlet checkEmail = _check(/^(\\w)+(\\.\\w+)*@(\\w)+((\\.\\w+)+)$/)\n\ncheckCellPhone(\'18642838455\') // 校验电话号码\ncheckCellPhone(\'13109840560\') // 校验电话号码\ncheckCellPhone(\'13204061212\') // 校验电话号码\n\ncheckEmail(\'test@163.com\') // 校验邮箱\ncheckEmail(\'test@qq.com\') // 校验邮箱\ncheckEmail(\'test@gmail.com\') // 校验邮箱</code></pre> \n<h3>柯里化函数参数 length</h3> \n<p>函数 currying 的实现中，使用了 fn.length 来表示函数参数的个数，那 fn.length 表示函数的所有参数个数吗？并不是。</p> \n<p>函数的 length 属性获取的是形参的个数，但是形参的数量不包括剩余参数个数，而且仅包括第一个具有默认值之前的参数个数，看下面的例子。</p> \n<pre><code>((a, b, c) =&gt; {}).length\n// 3\n\n((a, b, c = 3) =&gt; {}).length\n// 2\n\n((a, b = 2, c) =&gt; {}).length\n// 1\n\n((a = 1, b, c) =&gt; {}).length\n// 0\n\n((...args) =&gt; {}).length\n// 0\n\nconst fn = (...args) =&gt; {\n  console.log(args.length)\n}\nfn(1, 2, 3)\n// 3</code></pre> \n<h2>compose 函数</h2> \n<p>compose 就是组合函数，将子函数串联起来执行，一个函数的输出结果是另一个函数的输入参数，一旦第一个函数开始执行，会像多米诺骨牌一样推导执行后续函数。</p> \n<pre><code>const greeting = name =&gt; `Hello ${name}`\nconst toUpper = str =&gt; str.toUpperCase()\n\ntoUpper(greeting(\'Onion\')) // HELLO ONION</code></pre> \n<p>compose 函数的特点</p> \n<ul> \n <li>compose 接受函数作为参数，从右向左执行，返回类型函数</li> \n <li>fn()全部参数传给最右边的函数，得到结果后传给倒数第二个，依次传递</li> \n</ul> \n<p>compose 的实现</p> \n<pre><code>var compose = function(...args) {\n  var len = args.length // args函数的个数\n  var count = len - 1\n  var result\n  return function func(...args1) {\n    // func函数的args1参数枚举\n    result = args[count].call(this, args1)\n    if (count &gt; 0) {\n      count--\n      return func.call(null, result) // result 上一个函数的返回结果\n    } else {\n      //回复count初始状态\n      count = len - 1\n      return result\n    }\n  }\n}</code></pre> \n<p>举个例子</p> \n<pre><code>var greeting = (name) =&gt;  `Hello ${name}`\nvar toUpper = str =&gt; str.toUpperCase()\nvar fn = compose(toUpper, greeting)\nconsole.log(fn(\'jack\'))</code></pre> \n<p>大家熟悉的 webpack 里面的 loader 执行顺序是从右到左，是因为webpack 选择的是 compose 方式，从右到左依次执行 loader，每个 loader 是一个函数。</p> \n<pre><code>rules: [\n  { test: /\\.css$/, use: [\'style-loader\', \'css-loader\'] }\n]</code></pre> \n<p>如上，webpack 使用了 style-loader 和 css-loader，它是先用 css-loader 加载.css 文件，然后 style-loader 将内部样式注入到我们的 html 页面。</p> \n<p>webpack 里面的 compose 代码如下：</p> \n<pre><code>const compose = (...fns) =&gt; {\n  return fns.reduce(\n    (prevFn, nextFn) =&gt; {\n      return value =&gt;prevFn(nextFn(value)) \n    },\n    value =&gt; value\n  )\n}</code></pre> \n<h2>推荐文章</h2> \n<p><a href=\"https://juejin.im/post/5e7ab8325188255e3629a161\" rel=\"nofollow noreferrer\">总结javascript处理异步的方法</a><br><a href=\"https://juejin.im/post/5e4a0162f265da57133b2005\" rel=\"nofollow noreferrer\">总结移动端H5开发常用技巧（干货满满哦！）</a><br><a href=\"https://juejin.im/post/5db0fd1bf265da4d4216a9c5\" rel=\"nofollow noreferrer\">从零开始构建一个webpack项目</a><br><a href=\"https://juejin.im/post/5ddc8a6be51d4523275838db\" rel=\"nofollow noreferrer\">总结几个webpack打包优化的方法</a><br><a href=\"https://juejin.im/post/5ddf25546fb9a0715c2f9e1c\" rel=\"nofollow noreferrer\">总结前端性能优化的方法</a><br><a href=\"https://juejin.im/post/5e702c4c51882549052f6054\" rel=\"nofollow noreferrer\">总结vue知识体系之高级应用篇</a><br><a href=\"https://juejin.im/post/5e5f0ef8518825490b6489a2\" rel=\"nofollow noreferrer\">总结vue知识体系之实用技巧</a><br><a href=\"https://juejin.im/post/5de8ac566fb9a01658359501\" rel=\"nofollow noreferrer\">几种常见的JS递归算法</a><br><a href=\"https://juejin.im/post/5dc8c1cee51d45237f0c3b74\" rel=\"nofollow noreferrer\">封装一个toast和dialog组件并发布到npm</a><br><a href=\"https://juejin.im/post/5dae6ba1f265da5b981a8f5e\" rel=\"nofollow noreferrer\">一文读尽前端路由、后端路由、单页面应用、多页面应用</a><br><a href=\"https://juejin.im/post/5dc3716cf265da4d417652ff\" rel=\"nofollow noreferrer\">浅谈JavaScript的防抖与节流</a></p>', null, '692c6787030d4b8882077b2ab9279c52', 'd79254c4ca5e45dca9d484307c935281,c5c7574f5419441aba6a3361c81ef09e', '0', '3', '1', '2020-04-16 16:47:59', '2020-04-16 16:47:59');
INSERT INTO `tb_recommend` VALUES ('5babed956c9f44b89060c10d78c303e8', '闲鱼Flutter图片框架架构演进（超详细）底部有实战书籍赠送', '图片对一个端侧研发来说是一老生常谈的话题了。闲鱼作为业界在Flutter技术方向上最早一批投入的团队。从使用Flutter之初，图片就是我们核心关注和重点优化的功能。图片算是闲鱼业务场景下最为重要的内容表现形式...', '<p><strong>简介：</strong>flutter图片内存大？加载慢？本地资源利用率低？看这篇就够了</p> \n<p>作者：闲鱼技术-意境</p> \n<h2>1.那些年</h2> \n<p>图片对一个端侧研发来说是一老生常谈的话题了。闲鱼作为业界在Flutter技术方向上最早一批投入的团队。从使用Flutter之初，图片就是我们核心关注和重点优化的功能。图片算是闲鱼业务场景下最为重要的内容表现形式之一。图片展示体验的好坏会对闲鱼用户的使用体验产生巨大影响。你们是否也曾遇到过：</p> \n<ul> \n <li>图片加载内存占用过多？</li> \n <li>使用flutter以后本地资源重复，利用率不高？</li> \n <li>混合方案下Flutter原生图片加载效率不高？</li> \n</ul> \n<p>针对上述问题，从第一版Flutter业务上线开始，闲鱼对图片框架的优化就从未停止。从开始的原生优化，到后面黑科技的外接纹理；从内存占用，到包大小；文本会逐一介绍。希望其中的优化思路和手段，能给大家带去一些启发。</p> \n<h2>2. 原生模式</h2> \n<p>从技术层面看图片加载，其实简单来说，追求的是无非是加载的效率的最大化—用尽可能小的资源成本，尽可能快地加载尽可能多的图片。</p> \n<p>闲鱼图片的第一个版本其实基本上是纯原生的方案。如果你不想魔改很多底层的逻辑，原生方案肯定是最简单和经济的方案。原生方案的功能模块如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312435\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"原生图片方案的架构图\" title=\"原生图片方案的架构图\"></span></p> \n<p>如果你啥都没做直接上了，那么你可能会发现效果并没有达到你预期的那么美好。那么如果从原生的方案入手，我们有哪些具体的优化手段呢？</p> \n<h3>2.1. 设置图片缓存</h3> \n<p>没错猜对了，是<strong>缓存</strong>。对于图片加载，最能想到的方案就是使用缓存。首先原生Image的组件是支持自定义图片缓存的，具体的实现类是ImageCache。ImageCache的设置维度是两个方向： 1.缓存图片的张数。通过maximumSize设置。默认是1000张。2. 缓存空间的大小。 通过maximumSizeBytes 来设置。默认值100M。相比张数的限制，其实大小的设置方式更加符合我们的最终的预期。</p> \n<p>通过合理设置ImageCache的大小，能充分利用缓存机制加速图片加载。不仅如此，闲鱼在这个点上还做了额外两个重要优化：</p> \n<ol>\n <li>低端手机适配</li>\n</ol> \n<p>在上线以后，我们陆续收到线上舆情的反馈，发现全部机型设置同一个缓存大小的做法并非最优。特别是大缓存设置在低端机器上面，不仅会出现体验变差，甚至还会影响稳定性。基于实际情况，我们实现了一个能从Native侧获取机器基础信息的Flutter 插件。通过获取的信息，我们根据不同手机的配置设置不同的缓存策略。在低端机器上面适当降低图片缓存的大小，同时在高端手机上将其适当放大。这样能在不同配置的手机上获取最优的缓存性能。</p> \n<ol>\n <li>磁盘缓存</li>\n</ol> \n<p>熟悉APP开发的同学都知道，成熟的图片加载框架一般都有多级缓存。除了常见的内存缓存，一般都会配置一个文件缓存。从加载效率上来说，是通过空间换时间，提升加载速度。从稳定性来说，这又不会过分占用宝贵的内存资源，出现OOM。但是可惜的是，Flutter自带的图片加载框架并没有独立的磁盘缓存。所以我们在原生方案的基础上扩展了磁盘缓存能力。</p> \n<p>在具体的架构实现上，我们并没有完全自己撸一个磁盘缓存。我们的策略还是复用现有能力。首先我们将Native图片加载框架的磁盘缓存的功能通过接口暴露出来。然后通过桥接的方式，将Native 磁盘缓存能力嫁接到Flutter层。Flutter侧进行图片加载的时候，如果内存没有命中，就去磁盘缓存中进行二次搜索。如果都没有命中才会走网络请求。</p> \n<p>通过增加磁盘缓存，Flutter图片加载效率进一步提升。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312432\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"多级缓存\" title=\"多级缓存\"></span></p> \n<h3>2.2. 设置CDN优化</h3> \n<p>CDN 优化是另一个非常重要图片优化手段。CDN优化的效率提升主要是：最小化传输图片的大小。常见策略包括：</p> \n<ol>\n <li>根据显示大小裁剪</li>\n</ol> \n<p>简单来说，你要加载图片的真实尺寸，可能会大于你实际展示窗口的大小。那么你就没必要加载完整大图，你只需要加载一个能覆盖窗口大小的图片即可。通过这种方式，裁剪掉不需要的部分，就能最小化传输图片的大小。从端侧角度来说，一来可以提升加载速度，二来可以降低内存占用。</p> \n<ol>\n <li>适当压缩图片大小</li>\n</ol> \n<p>这里主要是根据实际情况增加图片压缩的比例。在不影响显示效果的情况下，通过压缩进一步降低图片的大小。</p> \n<ol>\n <li><strong>图片格式</strong></li>\n</ol> \n<p>建议优先使用webp这样格式，图片资源相对小。Flutter<strong>原生支持webp</strong>（包括动图）。这里特别强调一下webp动图不仅大小要比gif小很多，而且还对<strong>透明效果有更好的支持</strong>。webp动图是gif方案比较理想的一种替代方案。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312434\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"用图演示一下\" title=\"用图演示一下\"></span></p> \n<p>基于上述原因，闲鱼图片框架在Flutter侧实现了一套CDN尺寸匹配的算法。通过该算法，请求图片会根据实际显示的大小，自动匹配到最合适的尺寸上并适当压缩。如果图片格式允许，图片尽可能转化成webp格式下发。这样cdn图片的传输就能尽可能高效。</p> \n<h3>2.3. 其他优化</h3> \n<p>除了上面的策略，Flutter还有一些其他的手段可以优化图片的性能。</p> \n<ol>\n <li><strong>图片预加载</strong></li>\n</ol> \n<p>如果你想在展示的图片的尽可能的快，官方也提供了一套预加载的机制:<strong>precacheImage</strong>。precacheImage能预先将图片加载到内存，真正使用的时候就能秒出了。</p> \n<ol>\n <li><strong>Element复用优化</strong></li>\n</ol> \n<p>其实这个算是一个Flutter通用的优化方案。复写didWidgetUpdate方案，通过比较前后两次widget中针对图片的描述是否一致，来决定是否重新渲染Element。这样能避免同一个图片，不必要的反复渲染。</p> \n<ol>\n <li><strong>长列表优化</strong></li>\n</ol> \n<p>一般情况下，Listview是flutter最为常见的滚动容器。在Listview中的性能好坏，直接影响最终的用户体验。</p> \n<p>Flutter的Listview跟Native的实现思路并不相同。其最大的特点是有一个viewPort的概念。超出viewPort的部分会被强制回收掉。</p> \n<p>基于上述的原理，我们有两点建议：</p> \n<ol>\n <li>cell拆分</li>\n</ol> \n<p>尽量避免大型的cell出现，这样能大幅降低cell频繁创建过程中的性能损耗。其实这里影响的不仅仅是图片加载过程。文字，视频等其他组件也都应该避免cell过于复杂导致的性能问题。</p> \n<ol>\n <li>合理使用缓冲区</li>\n</ol> \n<p>ListView可以通过设置cacheExtent 来设置预先加载的内容大小。通过预先加载可以提升view渲染的速度。但是这个值需要合理设置，并非越大越好。因为预加载缓存越大，对页面整体内存的压力就越大。</p> \n<h3>2.4. 方案的不足</h3> \n<p>这里需要客观指出：如果是一个<strong>纯Flutter APP</strong>，<strong>原生方案是完善，够用的</strong>。但是如果从混合APP的角度来说，有如下两个缺陷：</p> \n<p><strong>1. 无法复用Native图片加载能力</strong></p> \n<p>毫无疑问，原生的图片方案是完全独立的图片加载方案。对于一个混合APP来说，原生方案和Native的图片框架相互独立，能力无法复用。例如CDN裁剪&amp;压缩等能力需要重复建设。特别是Native一些独特的图片解码能力，Flutter就很难使用。这会造成APP范围内的图片格式的支持不统一。</p> \n<p><strong>2. 内存性能不足</strong></p> \n<p>从整个APP的视角来说，采用原生图片方案的情况下，其实我们维护了两个大的缓存池：一个是Native的图片缓存，一个是Flutter侧的图片缓存。<strong>两个缓存无法互通</strong>，这无疑是一个巨大的浪费。特别是对内存的峰值内存性能产生了<strong>非常大的压力</strong>。</p> \n<h2>3. 打通Native</h2> \n<p>经过多轮优化，基于原生的方案已经获得了非常大的性能提升。但是整个APP的内存水位线依然比较高（特别是Ios端）。现实的压力迫使我们继续对图片框架进行更深度的优化。基于上述原生方案缺点的分析，我们有了一个大胆的想法：能否完全复用Native的图片加载能力？</p> \n<h3>3.1. 外接纹理</h3> \n<p>怎样打通Flutter和Native的图片能力？我们想到了外接纹理。外接纹理并非是Flutter自有的技术，他是音视频领域常用的一种性能优化手段。</p> \n<p>这个阶段我们基于shared-Context的方案实现了Flutter和Native的纹理外接。通过该方案，Flutter可以通过共享纹理的方式，拿到Native图片库加载好的图片并展示。为了实现这个纹理共享的通道，我们对engine层做了深度定制。细节过程如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312433\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>该方案不仅打通了Native和Flutter的图片架构，整个过程图片加载的性能也得到了优化。想要了解细节的同学可以继续阅读这篇文章：<a href=\"https://zhuanlan.zhihu.com/p/42566807\" rel=\"nofollow noreferrer\">万万没想到——Flutter外接纹理</a>。</p> \n<p>外接纹理是闲鱼图片方案的一次大跨越。通过该技术，我们不仅实现图片方案的本地能力复用，而且还能实现视频能力的纹理外接。这避免了大量重复的建设，提升了整个APP的性能。</p> \n<h3>3.2. 多页面内存优化</h3> \n<p>这个优化策略是真真被逼出来的。在对线上数据分析以后，我们发现Flutter页面栈有一个非常有意思的特点：</p> \n<p><strong>多页面栈情况下，底层的页面不会被释放</strong>。即便是在内存非常紧张的情况下，也不会执行回收。这样就会导致一个问题：随着页面的增多，内存消耗会线性增长。这里占比最高的就是图片资源的占比了。</p> \n<p>是不是可以在页面处于页面栈底层的时候直接回收掉该页面内的图片呢？</p> \n<p>在这个想法的驱动下，我们对图片架构进行了新一轮的优化。整个图片框架中的图片都会监听页面栈的变化。当方发现自己已经处于非栈顶的时候，就自动回收掉对应的图片纹理释放资源。这种方案能使图片占用的内存大小不会随着页面数的变多呈现持续线性增长。原理如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312437\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"TB1mF0NbZKfxu4jSZPfXXb3dXXa-780-558.png\" title=\"TB1mF0NbZKfxu4jSZPfXXb3dXXa-780-558.png\"></span></p> \n<p>需要注意的是：这个阶段页面判断位置其实是需要页面栈（具体来说就是混合栈）<strong>提供额外的接口</strong>来实现的。系统之间的耦合相对较高。</p> \n<h3>3.3. 意外收获包大小</h3> \n<p>打通Native和Flutter侧图片框架以后，我们发现了一个意外收获: Native和Flutter可以共用本地图片资源了。也就是说，我们不再需要将相同的图片资源在Flutter和Native侧各保留一份了。这样能大幅提升本地资源的复用率，从而降低整体的包大小。基于这个方案，我们实现了一套资源管理的功能，脚本能自动同步不同端的本地图片资源。通过这样提升本地资源利用率，降低包大小。</p> \n<h3>3.4. 其他优化</h3> \n<ol>\n <li><strong>PlaceHolder强化</strong></li>\n</ol> \n<p>原生的Image是没有PlaceHolder功能的。如果想用原生方案的话，需要使用FadeInImage。针对闲鱼的场景我们有很多定制，所以我们自己实现了一套PlaceHolder的机制。</p> \n<p>从核心功能上来说，我们引入了加载状态的概念分为： 1. 未初始化 2. 加载中 3. 加载完成 等。针对不同的状态，可以细粒度的控制PlaceHolder的展示逻辑。</p> \n<h3>3.5. 整体架构</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312436\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>3.6. 方案的不足</h3> \n<ol>\n <li><strong>毕竟改了engine</strong></li>\n</ol> \n<p>随着闲鱼业务的不断推进，engine的升级的成本是我们必须要考虑的事情。能否不改engine实现同样的功能是我们核心的述求。（PS: 我承认我们是贪心的）</p> \n<ol>\n <li><strong>通道性能还有优化空间</strong></li>\n</ol> \n<p>外接纹理的方案需要通过桥的方式跟native的能力做通信。这里包括图片请求的传递和图片加载各种状态的同步。特别是在listview快速滑动的时候，通过桥发送的数据量还是可观的。当前方案每个图片加载时都会单独进行桥的调用。在图片数量比较多的情况下，这显然会是一个瓶颈。</p> \n<ol>\n <li><strong>耦合过多</strong></li>\n</ol> \n<p>在实现图片回收方案的时候，目前方案需要栈提供是否在栈底层的接口。这里就产生方案耦合，很难抽象出一个独立干净的图片加载方案。</p> \n<h2>4. Clean&amp;Efficient</h2> \n<p>时间来到了2020年，随着对Flutter基础能力理解的逐步深入，我们实现了一个整体方案更优的图片框架。</p> \n<h3>4.1. 无侵入外接纹理</h3> \n<p>外接纹理可以不用修改engine么？答案是肯定的。</p> \n<p>其实Flutter是提供了官方的外接纹理方案的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312438\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>而且Native操作的texture和Flutter侧显示的texture在底层是同一对象，并<strong>没有产生额外的数据copy</strong>。这样就保证了纹理共享的足够高效。那为什么闲鱼之前会单独基于shared-Context自己实现一套呢？1.12版本之前，官方Ios的外接纹理方案有性能问题。每次渲染的过程中（不管纹理是否有更新）都会频繁获取CVPixelBuffer，造成不必要的性能损耗（过程有加锁损耗）。该问题已经在1.12版本中修复(<a href=\"https://github.com/flutter/flutter/commit/37a4af0ca8148adbda87bcae819ada044c72510d\" rel=\"nofollow noreferrer\">官方commit地址</a>)，这样官方方案也足够满足需求。在这样的背景下，我们重新启用官方方案来实现外接纹理功能。</p> \n<h3>4.2. 独立的内存优化</h3> \n<p>之前提到过，老版本的基于页面栈的图片资源回收需要强依赖栈功能的接口。一方面产生了不必要的依赖，更重要的是，整体方案无法独立成通用方案。为了解决这个问题，我们对Flutter底层进行了深入的研究。我们发现Flutter的layer层可以稳定感知到页面栈的变化。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312439\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"TB1bt7AzYr1gK0jSZR0XXbP8XXa-1710-796.png\" title=\"TB1bt7AzYr1gK0jSZR0XXbP8XXa-1710-796.png\"></span></p> \n<p>然后每个页面通过context获取的router对象作为标识对一个页面中的所有的图片对象进行重新组织。所有获取到同一个router对象的标识成同一个页面。这样就能以页面为单位对所有的图片进行管理。整体上通过LRU的算法来模拟虚拟页面栈结构。这样就能对栈底页面的图片资源实现回收了。</p> \n<h3>4.3. 其他优化</h3> \n<p><strong>1. 通道的高度复用</strong></p> \n<p>首先我们以一帧为单位对这一帧中的图片请求进行聚合，然后在一次通道请求中传递给Native的图片加载框架。这样能避免频繁的桥调用。特别在快速滚动等场景下优化效果尤为明显。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312441\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>2. 高效的纹理复用</strong></p> \n<p>使用外接纹理进行图片加载以后，我们发现复用纹理可以进一步提升性能。举一个简单的场景。我们知道电商场景中，商品展示经常会有标签，打底图这样的图片。这类图片往往在不同的商品上会出现大量重复。这时候，可以将已经渲染好的纹理，直接复用给不同的显示组件。这样能进一步优化GPU内存的占用，避免重复创建。为了精确对纹理进行管理，我们引入了引用计数的算法来管理纹理的复用。通过这些方案，我们实现了纹理跨页面高效复用。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312440\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>此外，我们将纹理和请求的映射关系移动到了Flutter侧。这样能在最短路径上完成纹理的复用，进一步减少了桥的通信的压力。</p> \n<h3>4.5. 整体架构</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312442\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>5. 优化效果</h2> \n<p>由于最新的版本目前还在灰度，具体数据后续会写文跟大家详细介绍。下属数据主要以<strong>方案二为主</strong>。</p> \n<ul>\n <li> <p>内存优化</p> \n  <ul> \n   <li>通过打通Native，相比于首次上线版本，在显示效果不变的情况下，Ios的abort率<strong>降低25%</strong>，用户体验明显提升。</li> \n   <li>多页面栈内存优化</li> \n  </ul> </li>\n</ul> \n<pre><code>多页面栈的内存优化，在多页面场景下对内存优化作用明显。我们做了一个极限试验效果如下：(**测试环境**，非闲鱼APP)\n\n</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022312443\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"TB1IK58AG61gK0jSZFlXXXDKFXa-868-473.png\" title=\"TB1IK58AG61gK0jSZFlXXXDKFXa-868-473.png\"></span></p> \n<p>​ 可见多页面栈的优化，可以将多Flutter页面的内存占用控制得更好。</p> \n<ul>\n <li>包大小减少</li>\n</ul> \n<p>通过接入外接纹理，本地资源得到了更好的复用，包大小<strong>降低1M</strong>。早期闲鱼接入Flutter，会以改造现有页面为切入点。资源重复情况比较严重，但是随着闲鱼Flutter 新业务越来越多。Flutter和Native的重复资源越来越少。外接纹理对包大小的影响已经逐步变弱。</p> \n<h2>6. 总结</h2> \n<p>本文介绍了闲鱼在Flutter图片框架方向上所做的持续优化。介绍了闲鱼不同时期，典型的图片技术方案的细节。希望可以给到读者一些启发。这是一场没有尽头的旅行，我们对闲鱼图片的优化还会持续。特别是我们最新的方案，受限篇幅，本文只是做了初步介绍。更多技术细节，包括测试数据，我们随后还会专门写文继续给大家做介绍。方案完善以后，我们也会逐步开源。</p> \n<h6> <strong>更多相关内容：</strong><a href=\"https://developer.aliyun.com/article/753993?utm_content=g_1000111457\" rel=\"nofollow noreferrer\"><strong>点击这里</strong></a>​</h6> \n<h5>福利：</h5> \n<h6>1.<a href=\"https://developer.aliyun.com/article/754410?utm\" rel=\"nofollow noreferrer\">点击这里</a>（电子书）</h6> \n<h6>2.<a href=\"https://weibo.com/3089100571/IDqvbue7y?ref=home&amp;type=comment#_rnd1586928793185\" rel=\"nofollow noreferrer\">点击这里</a>（实物书以及闲鱼周边）</h6>', 'https://segmentfault.com/img/remote/1460000022312435', '1894b118d35d44cb8fe8009529c4154b', '85ee959b27f74072b13cc763b9bbf77e,3b375646301546259a8fb29d74ae4447,14ab12176ade47da95ba97d7151eb1f9', '0', '3', '1', '2020-04-16 16:47:14', '2020-04-16 16:47:14');
INSERT INTO `tb_recommend` VALUES ('5bfc37903bea4010b681db615aabdfdf', '「开位」你所应该知道的HTTP——HTTPS篇', '前言 接上篇，本章主要讲解HTTPS相关知识点，重点是STL/SSL的握手。 《你所应该知道的HTTP》系列的其他篇章： 基础篇 进阶篇 缓存篇 拓展篇 优化篇 概述 HTTPS全称Secure Hypertext Transfer Protocol（安全超文...', '<h2>前言</h2> \n<p>接上篇，本章主要讲解HTTPS相关知识点，重点是STL/SSL的握手。</p> \n<p>《你所应该知道的HTTP》系列的其他篇章：</p> \n<ul> \n <li><a href=\"https://segmentfault.com/a/1190000022295229\">基础篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022322405\">进阶篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022336086\">缓存篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022374136\">拓展篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022384920\">优化篇</a></li> \n</ul> \n<h2>概述</h2> \n<p>HTTPS全称Secure Hypertext Transfer Protocol（安全超文本传输协议），是一个安全通信通道，用于在客户计算机和服务器之间交换信息。它使用安全套接字层进行信息交换，简单来说它是HTTP的安全版，是使用TLS/SSL加密的HTTP协议。</p> \n<pre><code>HTTPS = HTTP + TLS/SSL</code></pre> \n<p>HTTP协议采用明文传输信息，存在信息窃听、信息篡改和信息劫持的风险，而协议TLS/SSL具有身份验证、信息加密和完整性校验的功能，可以避免此类问题发生。<br>TLS全称Transport Layer Security（安全传输层协议）, 前身是SSL，故现在用TLS/SSL统称。是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p> \n<p>套用在TCP/IP四层模型里的结构如下：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFWHy\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"模型\" title=\"模型\"></span></p> \n<h2>TLS/SSL原理</h2> \n<p>TLS/SSL的功能实现主要依赖于三类基本算法：散列函数（Hash）、对称加密和非对称加密。<br>其利用非对称加密实现身份认证和密钥协商，对称加密算法采用协商的密钥对数据加密，基于散列函数验证信息的完整性。</p> \n<pre><code>TLS/SSL = 非对称加密 + 对称加密 + 散列算法</code></pre> \n<h3>非对称加密</h3> \n<p>加密和解密使用不同密钥的加密算法，也称为公私钥加密。密钥成对出现，一般称为公钥（publickey）和私钥（privatekey），公钥加密的信息只能私钥解开，私钥加密的信息只能公钥解开。即服务器持有私钥，客户端持有公钥，客户端要发送的信息经过公钥加密后传递给服务器，服务器用私钥解密得到明文信息。</p> \n<p>特点：</p> \n<ul> \n <li>可以实现1对多的通信；</li> \n <li>保密性比较好，只有公钥需要被传递，故私钥被劫持的概率很低；</li> \n <li>安全性高，保密性保证私钥安全，因此安全性仅依赖于算法本身；</li> \n <li>计算复杂，加密速度慢。</li> \n</ul> \n<p>在TLS/SSL中，非对称加密仅用于“身份认证”和“密钥协商”，不在后续正文数据传输中使用，这是安全性与性能之间的平衡取舍。</p> \n<h3>对称加密</h3> \n<p>加密和解密使用相同密钥的加密算法。即客户端与服务器所持有的密钥是相同的，客户端要发送的信息经过密钥加密后传递给服务器，服务器用相同密钥解密得到明文信息。</p> \n<p>特点：</p> \n<ul> \n <li>通信方式是1对1，为了足够安全，服务器和N个客户端通信，需要维持N个密码记录；</li> \n <li>安全性不仅取决于加密算法本身，密钥管理的安全性更是重要；</li> \n <li>计算量小、加密速度快、加密效率高；</li> \n <li>缺少吊销和修改密钥的机制。</li> \n</ul> \n<p>在TLS/SSL中，对称加密的密钥是通过非对称加密的“密钥协商”产生的，这样就最大限度的保证了密钥的安全。由于其效率高的特点，正文数据传输使用了该加密方式。</p> \n<h3>散列函数（Hash）</h3> \n<p>一种将任意长度的消息压缩到某一固定长度的消息摘要的函数，常用于防止信息篡改并验证数据的完整性。</p> \n<p>特点：</p> \n<ul> \n <li>单向不可逆；</li> \n <li>对输入非常敏感，即一点输入的改变都会导致结果不同；</li> \n <li>输出长度固定。</li> \n</ul> \n<p>在信息传输过程中，散列函数不能单独实现信息防篡改，因为明文传输，中间人可以修改信息之后重新计算信息摘要，因此需要对传输的信息以及信息摘要进行加密。<br>在TLS/SSL中，“密钥协商”的最后步骤和传输正文信息都会带上散列函数计算出的信息摘要，他们一起经过对称加密后传输，用来验证完整性。</p> \n<h2>PKI体系</h2> \n<h3>非对称加密的隐患</h3> \n<p>前面讲到“身份验证”和“密钥协商”是TLS/SSL的基础功能，要求的前提是合法的服务器掌握着对应的私钥。但非对称加密算法无法确保服务器身份的合法性，因为公钥并不包含服务器的信息。<br>假定出现以下的情况：</p> \n<ul> \n <li>客户端C和服务器S进行通信，中间节点M截获了二者的通信;</li> \n <li>节点M自己计算产生一对公钥pub_M和私钥pri_M;</li> \n <li>C向S请求公钥时，M把自己的公钥pub_M发给了C;</li> \n <li>C使用公钥pub_M加密的数据能够被M解密，因为M掌握对应的私钥pri_M，而C无法根据公钥信息判断服务器的身份，从而C和M之间建立了\"可信\"加密连接。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZka\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"中间人攻击.png\" title=\"中间人攻击.png\"></span></p> \n<p>如图，中间节点M和服务器S之间再建立合法的连接，因此C和S之间通信被M完全掌握，M可以进行信息的窃听、篡改等操作，这类攻击被称为“中间人攻击”。</p> \n<h3>身份验证CA和证书</h3> \n<p>为了解决上述的隐患，关键是确保获取公钥途径是合法的，能够验证服务器的身份信息，为此需要引入权威的第三方机构CA。<br>CA全称Certificate Authority（证书颁发机构），它负责核实公钥的拥有者的信息，并颁发认证\"证书\"，同时能够为使用者提供证书验证服务，即PKI体系。</p> \n<pre><code>证书 = 公钥 + 申请者与颁发者信息 + 有效时间 + 域名信息 + 签名</code></pre> \n<p>CA认证流程如下：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZp8\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"PKI.png\" title=\"PKI.png\"></span></p> \n<p>客户端会内置信任CA的证书信息（包含公钥），如果CA不被信任，则找不到对应CA的证书，证书也会被判定非法。<br>也可以这样理解，网站千千万，浏览器厂商没办法一家一家去认证，于是跟CA合作，通过维护一个CA列表，只要网站有经过这个列表里CA的认证，就可以信任该网站的证书。</p> \n<h2>TLS/SSL握手过程</h2> \n<p>TLS/SSL握手过程也就是所谓的HTTPS四次握手（不含证书验证步骤）。</p> \n<ol> \n <li>客户端发起请求，以明文传输请求信息，包含版本信息，加密套件候选列表，压缩算法候选列表，随机数random_C（明文），扩展字段等信息。</li> \n <li>服务端返回协商的信息结果，随机数random_S（明文），证书链等。</li> \n <li>对证书进行验证，包括证书可信性、有效性等，可能需要联系CA。</li> \n <li> <p>细分为四步：</p> \n  <ol> \n   <li>client_key_exchange：客户端计算产生随机数字Pre-master，并用证书公钥加密，发送给服务器;</li> \n   <li>客户端根据random_C、random_S以及Pre-master，计算得到协商密钥enc_key（即对称加密用的密钥）；</li> \n   <li>change_cipher_spec：客户端通知服务器后续的通信都采用协商的通信密钥和加密算法进行加密通信;</li> \n   <li>encrypted_handshake_message：结合之前所有通信参数的hash值与其它相关信息生成一段数据，采用协商密钥enc_key进行加密，然后发送给服务器用于数据与握手验证;</li> \n  </ol> </li> \n <li> <p>细分为四步：</p> \n  <ol> \n   <li>服务器使用私钥解密Pre-master，根据random_C、random_S以及Pre-master，计算得到协商密钥enc_key；</li> \n   <li>计算之前所有接收信息的hash值，然后解密客户端发送的encrypted_handshake_message，验证数据和密钥正确性；</li> \n   <li>change_cipher_spec：验证通过之后，服务器同样发送change_cipher_spec以告知客户端后续的通信都采用协商的密钥与算法进行加密通信;</li> \n   <li>encrypted_handshake_message：服务器也结合所有当前的通信参数信息生成一段数据并采用协商密钥enc_key加密并发送到客户端;</li> \n  </ol> </li> \n <li>握手结束，开始使用协商密钥enc_key进行对称加密通信（包含hash完整性验证）。</li> \n</ol> \n<p>示意图如下：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFZxx\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"TLS握手.png\" title=\"TLS握手.png\"></span></p> \n<h2>HTTPS的使用成本</h2> \n<ul> \n <li>证书费用及维护更新<br>一般正规CA颁发的证书都是需要付费购买的，并且到期后还得续费。</li> \n <li>增加了访问延迟<br>分析前面的握手过程，一次完整的握手至少需要两端依次来回两次通信，至少增加延时2RTT，利用会话缓存从而复用连接，延时也至少1RTT。</li> \n <li>消耗较多CPU资源<br>加解密是需要消耗性能的，前面也有提到非对称加密的特点，因此会成为性能瓶颈。</li> \n</ul> \n<h2>HTTPS的优化</h2> \n<h3>TLS False Start</h3> \n<p>在TLS/SSL协商第二阶段，也就是浏览器生成最后一个随机数并用公钥加密发送给服务器后，立即发送加密的应用层数据，而无需等待服务器的确认。</p> \n<h3>Session Identifier（会话标识符）</h3> \n<p>如果用户的一个业务请求包含了多条的加密流，客户端与服务器要反复握手，必定导致更多的时间损耗。或某些特殊情况导致会话中断，需要重新握手。<br>服务器为每一次的会话生成并记录一个sessionId，发送给客户端，客户端重新连接只需要提供这个id，不需要重新握手。</p> \n<h3>OCSP Stapling</h3> \n<p>OCSP全称Online Certificate Status Protocol。由web服务器向OCSP server周期性地查询证书状态，获得一个带有时间戳和签名的OCSP response并缓存它。当有客户端发起请求时，web服务器会把这个response在TLS握手过程中发给客户端。<br>（谷歌浏览器默认只使用内置列表检查，故这个优化对谷歌无效）</p> \n<h3>HSTS（HTTP Strict-Transport-Security）</h3> \n<p>一个报文头部字段，告诉浏览器，接下来的一段时间内，当前域名(及其子域名)的后续通信应该强制性使用HTTPS，直到超过有效期为止。</p> \n<p>形如：</p> \n<pre><code>Strict-Transport-Security: max-age=31536000;includeSubDomains</code></pre>', 'https://segmentfault.com/img/bVbFWHy', '5ca4567d892841b087fac5246effac40', 'f0e336796bd94b8299ef69b2b2529ec4,63c4e1e7ec204b43a62065a3ced4c2ce,f2fb7d236fec4c138cacd9162eb4488c', '0', '3', '1', '2020-04-16 16:58:53', '2020-04-16 16:58:53');
INSERT INTO `tb_recommend` VALUES ('5c6220c4947349c2b09a118d7aeb6450', '2020年十大最佳自动化测试工具', '对更快交付高质量软件（或\"快速质量\"）的需求要求组织以敏捷，持续集成（CI）和DevOps方法论来寻找解决方案。测试自动化是这些方面的重要组成部分。最新的《 2018-2019年世界质量报告》表明，测试自动化是实现\"快...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303938\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Best Automation Testing Tools for 2020</p> \n<p>对更快交付高质量软件（或\"快速质量\"）的需求要求组织以敏捷，持续集成（CI）和DevOps方法论来寻找解决方案。测试自动化是这些方面的重要组成部分。最新的《 2018-2019年世界质量报告》表明，测试自动化是实现\"快速质量\"的最大瓶颈，因为它是成功采用敏捷和DevOps的推动力。</p> \n<p>没有好的工具就无法实现测试自动化。因为它们决定了如何执行自动化以及是否可以实现自动化的好处。测试自动化工具是DevOps工具链中的关键组件。在应用人工智能和机器学习（AI / ML）来提供用于测试优化，智能测试生成，执行和报告的高级功能方面，当前的测试自动化趋势已经增长。有必要了解哪种工具最适合利用这些趋势。</p> \n<p>这些顶级的自动化测试工具被认为可以最好地解决未来几年自动化领域的挑战。从以下条件中选择此列表中包括的工具：</p> \n<ul> \n <li>支持API和服务测试</li> \n <li>提供一些AI / ML和分析功能</li> \n <li>知名度和成熟度</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303937\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Top 5 Automation Testing Tools for 2020</p> \n<h1>1.Selenium</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303939\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Selenium是测试自动化的家喻户晓的名字。它被认为是Web应用程序用户界面自动化测试的行业标准。根据\"测试自动化挑战调查\"显示，十分之九的测试人员中有近九位在其项目中使用或曾经使用过硒。</p> \n<p>对于具有编程和脚本编写经验和技能的开发人员和测试人员，Selenium提供了许多其他测试自动化工具和框架所不具备的灵活性。用户可以使用多种语言（例如Java，Groovy，Python，C＃，PHP，Ruby和Perl）编写测试脚本，这些脚本可以在多种系统环境（Windows，Mac，Linux）和浏览器（Chrome，Firefox，IE和 无头浏览器）。</p> \n<p>Selenium最近于2019年4月发布了其第一个alpha版本的Selenium。Selenium4正式版的发布尚未确定；目前，Selenium 4正式发布。但是您可以期望该版本将具有许多改进和丰富的功能。</p> \n<p>为了有效地使用Selenium，用户必须具备高级编程技能，并且需要花费大量时间来构建自动化所需的自动化框架和库。这是Selenium的主要缺点，可通过Katalon Studio等集成工具解决。</p> \n<p>许可证：开源</p> \n<h1>2. Katalon Studio</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303940\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Katalon Studio是功能强大且全面的自动化解决方案，用于测试API，Web，移动和桌面应用程序测试。它还为这些类型的测试提供了丰富的功能集，并支持包括Windows，macOS和Linux在内的多个平台。</p> \n<p>利用Selenium和Appium引擎，Katalon Studio为那些难以集成和部署不同框架和库以使用Selenium和Appium的测试人员以及已经熟悉这些引擎的测试人员提供了一个独特的集成环境。</p> \n<p>Katalon Studio赢得了Gartner Peer Insights客户的软件测试自动化大奖，获得了450多项正面评价，该评论获得了450多项正面评价，这再次证明该工具现在是市场上最大的公司之一。</p> \n<p>该工具的重点包括：</p> \n<ul> \n <li>API / Web服务，Web和移动应用程序的测试自动化的完整功能集</li> \n <li>同时支持SOAP和RESTful的API和服务测试</li> \n <li>数百个用于创建测试用例的内置关键字</li> \n <li>可用于自动化和探索性测试</li> \n <li>可以通过Katalon Store上的插件扩展测试功能，深入了解Katalon TestOps上的报告</li> \n</ul> \n<p>许可证：免费</p> \n<h1>3. UFT</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303942\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>UFT是测试桌面，Web和移动应用程序的流行商业工具。它已扩展为包括一组用于API测试的功能。通过为被测目标应用程序（AUT）支持多个平台，UFT提供了一种方便的选择来测试可在台式机，Web和移动设备上运行的AUT。</p> \n<p>UFT为智能对象检测，基于图像的对象检测和校正提供了几种高级功能。在2019年5月，Microfocus已发布具有新功能和增强功能的最新版UFT（v14.53）</p> \n<p>该工具的特点包括：</p> \n<ul> \n <li>直观的用户界面，用于创建，执行和报告API测试</li> \n <li>支持从WADL文档生成API测试</li> \n <li>测试的动作，活动和参数可以在图表中可视化</li> \n</ul> \n<p>许可证：每年3,200美元起。</p> \n<h1>4. TestComplete</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303941\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>今年，TestComplete凭借其强大，全面的Web，移动和桌面应用程序测试功能继续名列前茅。测试人员可以使用JavaScript，VBScript，Python或C ++ Script编写测试脚本。</p> \n<p>与UFT一样，TestComplete具有对象识别引擎，可以准确地检测动态用户界面元素。该引擎在具有动态且经常更改的用户界面的应用程序中特别有用。</p> \n<p>最新的TestComplete版本14.2包括与Jenkins的本机集成，以加速CI / CD流程，对Web测试组件（如Shadow DOM和自定义元素）的支持以及对所有最新浏览器版本和移动平台的支持。</p> \n<p>测试人员可以轻松使用TestComplete的记录和回放功能，例如Katalon Studio。他们可以将检查点插入测试步骤以验证结果。作为SmartBear的产品，TestComplete可以轻松地与SmartBear提供的其他产品集成。</p> \n<p>许可：每位用户每年$ 9,114起</p> \n<h1>5. SoapUI</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303943\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>SoapUI不是用于Web或移动应用程序测试的测试自动化工具；但是它可以作为测试API和服务的首选工具。它是专门为API测试而设计的无头功能测试工具。</p> \n<p>SoapUI支持REST和SOAP服务。API自动化测试人员可以使用开源版本或专业版。专业版具有友好的用户界面和一些高级功能，例如断言向导，表单编辑器和SQL查询生成器。SoapUI是SmartBear提供的ReadyAPI套件的工具。</p> \n<p>该工具为API测试提供了相当全面的功能集，其中包含许多高级功能，其中包括：</p> \n<ul> \n <li>拖放，点击即可轻松生成测试</li> \n <li>使用文件和数据库中的数据进行强大的数据驱动测试</li> \n <li>异步测试</li> \n <li>脚本可以轻松重用</li> \n <li>使用RESTful模拟创建模拟服务</li> \n</ul> \n<p>此外，SoapUI最近将SoapUI Pro的API Explorer功能引入了开源版本，从而使开发人员和测试人员可以立即调试其API的响应。</p> \n<p>许可：SoapUI打包和分发为两个版本，开源和Pro。后者的起价为每年659美元。</p> \n<p>请注意，SoapUI和Postman仅是此列表中几个顶级API测试工具的两个代表。要了解有关这些工具之间比较的更多信息，请参阅此文章。</p> \n<h1>6. IBM Rational Functional Tester（RFT）</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303944\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>IBM Rational Functional Tester是一个测试自动化工具，旨在测试使用不同语言和技术开发的应用程序，例如Web，.Net，Java，Visual Basic，Siebel，SAP，PowerBuilder，Adobe Flex和Dojo Toolkit。它也是用于功能和回归测试的数据驱动测试平台。</p> \n<p>RFT提供了一个称为\"故事板测试\"的功能，该功能可以使用自然语言和应用程序屏幕截图来可视化和编辑测试。RFT的ScriptAssure功能使测试人员能够生成可适应AUT用户界面变化的测试脚本。RFT还可以与其他IBM应用程序生命周期管理工具集成，例如IBM Rational Team Concert和Rational Quality Manager。</p> \n<p>执照：商业</p> \n<h1>7. Tricentis&nbsp;Tosca</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303946\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>有一些连续的测试平台可提供全面的工具集，以支持大多数（如果不是全部）测试活动，从测试设计和测试自动化到测试报告和分析。Tricentis Tosca是其中之一。</p> \n<p>该工具具有许多功能，例如仪表板，分析，集成和分布式执行，以支持持续集成和DevOps实践。此外，它提供了友好的用户界面和丰富的功能集，可用于设计，实施，执行，管理，优化API测试。</p> \n<p>该工具的其他一些亮点：</p> \n<ul> \n <li>可以轻松集成为DevOps流程的关键部分</li> \n <li>可以在浏览器，移动设备和平台上执行API测试</li> \n <li>启用了多种协议和标准，包括HTTP JMS，AMQP，Rabbit MQ，TIBCO EMS，SOAP，REST和IBM MQ</li> \n <li>一套很好的测试报告和分析功能</li> \n</ul> \n<p>Tricentis声称将大大减少回归测试（在数周至数分钟的时间内）。但是，此声明需要由测试团队仔细验证。</p> \n<p>执照：商业</p> \n<h1>8.Ranorex</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303945\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>已经存在很多年了，Ranorex为Web，移动，桌面和API测试提供了一套全面而专业的功能。利用其在基于桌面的测试自动化中的经验，Ranorex具有用于UI元素识别，编辑和管理的高级功能。</p> \n<p>与Katalon Studio一样，Ranorex友好而直观的GUI，记录/回放和脚本生成功能使测试人员可以轻松进行自动化测试。</p> \n<p>测试人员可以将Ranorex与Selenium Grid集成在一起，以实现分布式测试以及并行测试执行。</p> \n<p>许可：附加组件为690欧元，高级许可为2290欧元起。</p> \n<h1>9.Postman</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303947\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Postman是专为API测试设计的另一种自动化工具。用户可以在Mac，Linux，Windows上以浏览器扩展或桌面应用程序的形式安装此工具。它不仅在用于API测试自动化的测试人员中很流行，而且在使用该工具开发和测试API的开发人员中也很流行。实际上，它是用于开发和测试API的开发环境。</p> \n<p>该工具的一些亮点：</p> \n<ul> \n <li>用于设计，调试，测试，记录和发布API的综合功能集</li> \n <li>友好且易于使用的用户界面</li> \n <li>支持自动化和探索性测试</li> \n <li>接受Swagger和RAML API格式</li> \n <li>请求和应答者可以打包并与团队成员共享</li> \n</ul> \n<p>执照：商业</p> \n<h1>10. Apache JMeter</h1> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022303948\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>JMeter是设计用于测试加载和性能测量的开源工具-JMeter的两个功能是众所周知的。但是，该工具现在也用于API和服务测试，尤其是API性能。JMeter是第三种最受欢迎的测试自动化工具，在\"测试自动化挑战\"调查中有25％的受访者引用了JMeter的信息。</p> \n<p>该工具的重点包括：</p> \n<ul> \n <li>轻巧，具有简单易用的用户界面</li> \n <li>测试结果可以重播</li> \n <li>支持CSV文件来设置API参数的值</li> \n <li>支持与CI工具（例如Jenkins）集成。JMeter通常用作CI和DevOps工具链的一部分</li> \n</ul> \n<p>许可证：开源</p> \n<p>— — — —</p> \n<p>这里列出的顶级工具并不详尽。但是它代表了成熟，流行的最佳工具，并提供了使用AI / ML的功能来解决组织在交付\"快速质量\"时面临的挑战。此列表还包括仅支持API和服务测试对于成功进行敏捷和DevOps转换至关重要。</p> \n<p>您选择的测试工具不仅应满足您当前的需求，而且还应关注潜在的趋势和改进。体面的工具应支持基本优化，测试用例和数据生成的自动化，更智能的解决方案以及分析。</p> \n<p>随着增长的机会，将引入更多的工具；即使组织中的测试自动化水平低至14％到18％之间（WQR报告）。此外，很高兴看到现有和即将推出的工具如何应用AI / ML来应对未来的挑战。API和服务测试也是一种趋势，将来应该会得到进一步的发展。</p> \n<p>(本文翻译自Brian的文章《Best Automation Testing Tools for 2020 (Top 10 reviews)》，参考：<a href=\"https://medium.com/@briananderson2209/best-automation-testing-tools-for-2018-top-10-reviews-8a4a19f664d2)\" rel=\"nofollow noreferrer\">https://medium.com/@brianande...</a></p>', 'https://segmentfault.com/img/remote/1460000022303938', '61cdf41d1e5e4f229b76f6a042e254b6', 'd7416e100af54eb7a4d9274b9a462240,81a4561c1c294e0cae32c9fe6b5dc397,55723db96b9f4593bae02bc1e49f1e87,63c4e1e7ec204b43a62065a3ced4c2ce', '0', '3', '1', '2020-04-16 16:47:14', '2020-04-16 16:47:14');
INSERT INTO `tb_recommend` VALUES ('5eb94f78ff064995a3a429309f2d4191', '[宝宝也能看懂的活动篇][30-Day LeetCoding Challenge] 第十二天', '每一回合，从中选出两块 最重的 石头，然后将它们一起粉碎。假设石头的重量分别为 x 和 y，且 x <= y。那么粉碎的可能结果如下：', '<h1>最后一块石头的重量</h1> \n<p>Hi 大家好，我是张小猪。欢迎来到『宝宝也能看懂』系列特别篇 - 官方小活动 『30-Day LeetCoding Challenge』。</p> \n<p>这里是 4 月 12 号的题，也是题目列表中的第 1046 题 -- 『最后一块石头的重量』</p> \n<h2>题目描述</h2> \n<p>有一堆石头，每块石头的重量都是正整数。</p> \n<p>每一回合，从中选出两块 <strong>最重的</strong> 石头，然后将它们一起粉碎。假设石头的重量分别为&nbsp;<code>x</code> 和&nbsp;<code>y</code>，且&nbsp;<code>x</code> &lt;= <code>y</code>。那么粉碎的可能结果如下：</p> \n<ul> \n <li>如果&nbsp;<code>x == y</code>，那么两块石头都会被完全粉碎；</li> \n <li>如果&nbsp;<code>x != y</code>，那么重量为&nbsp;<code>x</code>&nbsp;的石头将会完全粉碎，而重量为&nbsp;<code>y</code>&nbsp;的石头新重量为&nbsp;<code>y-x</code>。</li> \n</ul> \n<p>最后，最多只会剩下一块石头。返回此石头的重量。如果没有石头剩下，就返回 <code>0</code>。</p> \n<p>示例：</p> \n<pre><code class=\"shell\">输入：[2,7,4,1,8,1]\n输出：1\n解释：\n先选出 7 和 8，得到 1，所以数组转换为 [2,4,1,1,1]，\n再选出 2 和 4，得到 2，所以数组转换为 [2,1,1,1]，\n接着是 2 和 1，得到 1，所以数组转换为 [1,1,1]，\n最后选出 1 和 1，得到 0，最终数组转换为 [1]，这就是最后剩下那块石头的重量。</code></pre> \n<p>提示：</p> \n<ul> \n <li><code>1 &lt;= stones.length &lt;= 30</code></li> \n <li><code>1 &lt;= stones[i] &lt;= 1000</code></li> \n</ul> \n<h2>官方难度</h2> \n<p>EASY</p> \n<h2>解决思路</h2> \n<p>看起来描述挺长，但其实就是一个大值依次互相抵消求最后剩余的小游戏。小猪没有想到什么数学方式，所以就正常的根据游戏流程来求最终结果吧。</p> \n<h3>直接方案</h3> \n<p>由于数字是无序的，所以我们先进行一个排序。然后按照游戏流程，把两个最大值进行抵消，如果存在余量则通过插入排序的方式放入合适的位置。这样直到最后剩余 0 个或者 1 个数字，便得到了结果。</p> \n<p>具体代码如下：</p> \n<pre><code class=\"js\">const lastStoneWeight = stones =&gt; {\n  stones.sort((a, b) =&gt; a - b);\n  while (stones.length &gt; 1) {\n    const x = stones.pop();\n    const y = stones.pop();\n    if (x === y) continue;\n    const d = Math.abs(x - y);\n    let idx = stones.length;\n    while (idx &gt; 0) {\n      if (stones[idx - 1] &lt;= d) break;\n      stones[idx] = stones[idx - 1];\n      --idx;\n    }\n    stones[idx] = d;\n  }\n  return stones.length === 1 ? stones[0] : 0;\n};</code></pre> \n<h3>优化</h3> \n<p>上面的方案最开始使用了一个全局的排序，随后在遍历中也对余量使用了一次基于遍历的插入行为。那么这里优化方案非常明显，我们可以优化排序的方式，从而简化整个流程。</p> \n<p>由于输入数据的范围是 <code>[1, 1000]</code>，所以我们可以非常轻松的用桶排序来完成最初的排序，并且后续的余量处理也会变得更加容易。具体代码如下：</p> \n<pre><code class=\"js\">const lastStoneWeight = stones =&gt; {\n  const buckets = new Uint8Array(1001);\n  let t = 0;\n  for (const val of stones) ++buckets[val];\n  for (let i = 1000; i &gt; 0; --i) {\n    if (!buckets[i]) continue;\n    if (!t) { buckets[i] % 2 &amp;&amp; (t = i); continue; }\n    const d = Math.abs(t - i);\n    t = d &gt;= i ? d : (++buckets[d], 0);\n    --buckets[i++];\n  }\n  return t;\n};</code></pre> \n<h2>总结</h2> \n<p>又是一个基于桶排序完成的优化，在特定的场景下还是『真香』的。希望能帮助到有需要的小伙伴。</p> \n<p>如果觉得不错的话，记得『三连』哦。小猪爱你们哟~</p> \n<h2>相关链接</h2> \n<ul> \n <li><a href=\"https://github.com/poppinlp/leetcode#30-day-leetcoding-challenge\" rel=\"nofollow noreferrer\">活动题目列表</a></li> \n <li><a href=\"https://github.com/poppinlp/leetcode\" rel=\"nofollow noreferrer\">leetcode 题解 repo</a></li> \n <li><a href=\"https://segmentfault.com/blog/zxzfbz\">我的 segmentfault 专栏</a></li> \n <li><a href=\"https://zhuanlan.zhihu.com/zxzfbz\" rel=\"nofollow noreferrer\">我的知乎专栏</a></li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCAAa\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"qrcode_green.jpeg\" title=\"qrcode_green.jpeg\"></span></p>', 'https://segmentfault.com/img/bVbCAAa', '1894b118d35d44cb8fe8009529c4154b', '3921afbb134d45f6aa368b52d2670e7b,faf36da502544b51be926ab85450c40d,789898341cc64d45a1f44e26daab183f,63c4e1e7ec204b43a62065a3ced4c2ce,55723db96b9f4593bae02bc1e49f1e87', '0', '3', '1', '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_recommend` VALUES ('5ed03e0b0a23449b8e07fc563ec988af', '十分钟完成Bash 脚本进阶！列举Bash经典用法及其案例', '前言：在linux中，Bash脚本是很基础的知识，大家可能一听脚本感觉很高大上，像小编当初刚开始学一样，感觉会写脚本的都是大神。虽然复杂的脚本是很烧脑，但是，当我们熟练的掌握了其中的用法与技巧，再多加练习，...', '<p>前言：在linux中，Bash脚本是很基础的知识，大家可能一听脚本感觉很高大上，像小编当初刚开始学一样，感觉会写脚本的都是大神。虽然复杂的脚本是很烧脑，但是，当我们熟练的掌握了其中的用法与技巧，再多加练习，总有一天也会成为得心应手的脚本大神。脚本在生产中的作用，想必小编我不说，大家也都知道，脚本写的6，可以省下很多复杂的操作，减轻自己的工作压力。</p> \n<p>好了，废话不多说，接下来，就是Bash脚本的用法展示。</p> \n<p>一、条件选择、判断（if·、case）</p> \n<p>二、四个循环（for、while、until、select）</p> \n<p>三、循环里的一些命令与技巧（continue、break、shift...）</p> \n<p>四、信号捕获trap</p> \n<p>一、条件选择、判断</p> \n<blockquote> \n <strong>（1）条件选择</strong>if\n <em>*</em>*\n</blockquote> \n<p><strong>1、用法格式</strong></p> \n<p><strong>if</strong>&nbsp;判断条件 1<strong>&nbsp;; then</strong></p> \n<p>　　条件为真的分支代码</p> \n<p><strong>elif</strong>&nbsp;判断条件 2<strong>&nbsp;; then</strong></p> \n<p>　　条件为真的分支代码</p> \n<p>elif 判断条件 3 ; then</p> \n<p>　　条件为真的分支代码</p> \n<p><strong>else</strong></p> \n<p>　　以上条件都为假的分支代码</p> \n<p><strong>fi</strong></p> \n<p>逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if。</p> \n<p><strong>2、经典案例：</strong></p> \n<p>① 判断年纪</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381505\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分析：请输入年纪，先判断输入的是否含有除数字以外的字符，有，就报错；没有，继续判断是否小于150，是否大于18。</p> \n<p>② 判断分数</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381506\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分析：请输入成绩，先判断输入的是否含有除数字以外的字符，有，就报错；没有，继续判断是否大于100，是否大于85，是否大于60。</p> \n<blockquote> \n <strong>（2）条件判断&nbsp;</strong>case\n <em>*</em>*\n</blockquote> \n<p><strong>1、用法格式</strong></p> \n<p><strong>case</strong>&nbsp;$name<strong>&nbsp;in;</strong></p> \n<p><strong>PART1)</strong></p> \n<p>　　cmd</p> \n<p>　　<strong>;;</strong></p> \n<p>PART2)</p> \n<p>　　cmd</p> \n<p>　<strong>　;;</strong></p> \n<p><strong>*)</strong></p> \n<p>　　cmd</p> \n<p>　　<strong>;;</strong></p> \n<p><strong>esac</strong></p> \n<p>注意：case 支持glob 风格的通配符：</p> \n<p>　　*: 任意长度任意字符</p> \n<p>　　?: 任意单个字符</p> \n<p>　　[] ：指定范围内的任意单个字符</p> \n<p>　　a|b: a 或b</p> \n<p><strong>2、案例：</strong></p> \n<p>判断yes or no</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381507\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分析：请输入yes or no，回答Y/y、yes各种大小写组合为yes；回答N/n、No各种大小写组合为no。 </p> \n<p>二、四个循环</p> \n<blockquote> \n <strong>（1）</strong>for\n <em>*</em>*\n</blockquote> \n<p><strong>1、用法格式</strong></p> \n<p><strong>① for</strong>&nbsp;<strong>name in</strong>&nbsp;列表<strong>&nbsp;;do</strong></p> \n<p>　　循环体</p> \n<p><strong>done</strong></p> \n<p>②&nbsp;<strong>for (( exp1; exp2; exp3 )) ;do</strong></p> \n<p>　　cmd</p> \n<p><strong>done</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381504\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>exp1只执行一次，相当于在for里嵌了while&nbsp;</p> \n<p>③ 执行机制：依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直到列表中的元素耗尽，循环结束</p> \n<p>列表的表示方法，可以glob 通配符，如{1..10} 、*.sh ；也可以变量引用，如： `seq 1 $name`</p> \n<p><strong>2、案例：</strong></p> \n<p>① 求出（1+2+...+n）的总和</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381509\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分析：sum初始值为0，请输入一个数，先判断输入的是否含有除数字以外的字符，有，就报错；没有判断是否为0，不为0进入for循环，i的范围为1~输入的数，每次的循环为sum=sum+i，循环结束，最后输出sum的值。</p> \n<p>② 求出（1+2+...+100）的总和</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381508\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分析：i=1,num=0；当i&lt;=100，进入循环，若i÷2取余=1，则sum=sum+i，i=i+1。</p> \n<blockquote>\n <strong>（2）while</strong>\n</blockquote> \n<p><strong>1、用法格式</strong></p> \n<p><strong>while</strong>&nbsp;循环控制条件<strong>&nbsp;;do</strong></p> \n<p>　　循环</p> \n<p><strong>done</strong></p> \n<p>&nbsp;循环控制条件；进入循环之前，先做一次判断；每一次循环之后会再次做判断；条件为“true” ，则执行一次循环；直到条件测试状态为“false” 终止循环</p> \n<p><strong>2、特殊用法（遍历文件的每一行）：</strong></p> \n<p>while read line; do控制变量初始化</p> \n<p>　　循环体</p> \n<p>done&nbsp;<strong>&lt;</strong>&nbsp;/PATH/FROM/SOMEFILE</p> \n<p>或<strong>cat</strong>&nbsp;/PATH/FROM/SOMEFILE<strong>&nbsp;|</strong>&nbsp;while read line; do</p> \n<p>　　循环体</p> \n<p>done</p> \n<p>依次读取/PATH/FROM/SOMEFILE文件中的每一行，且将行赋值给变量line</p> \n<p><strong>3、案例：</strong></p> \n<p>① 100以内所有正奇数之和</p> \n<p><img alt=\"\" title=\"\"></p> \n<p>分析：sum初始值为0，i的初始值为1；请输入一个数，先判断输入的是否含有除数字以外的字符，有，就报错；没有当i&lt;100时，进入循环，判断 i÷2取余 是否不为0，不为0时为奇数，sum=sum+i，i+1，为0，i+1；循环结束，最后输出sum的值。</p> \n<blockquote> \n <strong>（3）</strong>until\n <strong>&nbsp;循环</strong> \n</blockquote> \n<p><strong>1、用法</strong></p> \n<p><strong>unitl</strong>&nbsp;循环条件<strong>&nbsp;;do</strong></p> \n<p>　　循环</p> \n<p><strong>done</strong></p> \n<p>进入条件：循环条件为true ；退出条件：循环条件为false；刚好<strong>和while相反</strong>，所以不常用，用while就行。</p> \n<p><strong>&nbsp;2、案例</strong></p> \n<p>监控xiaoming用户，登录就杀死</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381510\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分析：每隔0.5秒扫描，直到发现xiaoming用户登录，杀死这个进程，退出脚本，用于监控用户登录。</p> \n<blockquote> \n <strong>（4）</strong>select\n <strong>&nbsp;循环与菜单</strong> \n</blockquote> \n<p><strong>1、用法</strong></p> \n<p><strong>select</strong>&nbsp;variable&nbsp;<strong>in</strong>&nbsp;list</p> \n<p><strong>do</strong></p> \n<p>　　循环体命令</p> \n<p><strong>done</strong></p> \n<p>① select 循环主要用于创建菜单，按数字顺序排列的示菜单项将显示在标准错误上，并显示PS3 提示符，等待用户输入</p> \n<p>② 用户输入菜单列表中的某个数字，执行相应的命令</p> \n<p>③ 用户输入被保存在内置变量 REPLY 中</p> \n<p>④ select 是个无限循环，因此要记住用 break 命令退出循环，或用 exit 按 命令终止脚本。也可以按 ctrl+c退出循环</p> \n<p>⑤ select 和 经常和 case 联合使用</p> \n<p>⑥ 与for循环类似，可以省略 in list， 此时使用位置参量</p> \n<p><strong>2、案例：</strong></p> \n<p>生成菜单，并显示选中的价钱</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381511\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分析：PS3是select的提示符，自动生成菜单，选择5break退出循环。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381512\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>三、循环里的一些用法</p> \n<blockquote>\n <strong>（1）循环控制语句</strong>\n</blockquote> \n<p><strong>continue</strong>&nbsp;[N]：提前结束<strong>第N层的本轮</strong>循环，而直接进入下一轮判断；最内层为第1层</p> \n<p><strong>break</strong>&nbsp;[N]：提前结束<strong>第N层</strong>循环，最内侧为第1层</p> \n<p>&nbsp;例：while CONDTITON1; do</p> \n<p>　　CMD1</p> \n<p>if CONDITION2; then</p> \n<p>　　continue / break</p> \n<p>fi</p> \n<p>　　CMD2</p> \n<p>done</p> \n<p><strong>2、案例：</strong></p> \n<p>① 求（1+3+...+49+53+...+100）的和</p> \n<p><img alt=\"\" title=\"\"></p> \n<p>分析：做1+2+...+100的循环，当i=51时，跳过这次循环，但是继续整个循环，结果为：sum=2449</p> \n<p>②&nbsp;求（1+3+...+49）的和</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381514\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分析：做1+2+...+100的循环，当i=51时，跳出整个循环，结果为：sum=625</p> \n<blockquote>\n <strong>（2）循环控制shift命令</strong>\n</blockquote> \n<p><strong>1、作用</strong></p> \n<p>用于将参数列表list左移指定次数，最左端的那个参数就从列表中删除，其后边的参数继续进入循环</p> \n<p><strong>2、案例：</strong></p> \n<p>① 创建指定的多个用户</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381513\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分析：如果没有输入参数（参数的总数为0），提示错误并退出；反之，进入循环；若第一个参数不为空字符，则创建以第一个参数为名的用户，并移除第一个参数，将紧跟的参数左移作为第一个参数，直到没有第一个参数，退出。</p> \n<p>② 打印直角三角形的字符</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381516\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><img alt=\"\" title=\"\"></p> \n<blockquote>\n <strong>（3）返回值结果</strong>\n</blockquote> \n<p><strong>true</strong>&nbsp;永远返回成功结果</p> \n<p><strong>:</strong>&nbsp;null command ,什么也不干，返回成功结果</p> \n<p><strong>false</strong>&nbsp;永远返回错误结果</p> \n<p>创建无限循环</p> \n<p>while true ;do</p> \n<p>　　循环体</p> \n<p>done</p> \n<blockquote>\n <strong>（4）循环中可并行执行，使脚本运行更快</strong>\n</blockquote> \n<p><strong>1、用法</strong></p> \n<p>for&nbsp;name in&nbsp;列表&nbsp;;do</p> \n<p>　　<strong>{</strong></p> \n<p>　　循环体</p> \n<p>　　<strong>}&amp;</strong></p> \n<p>done</p> \n<p><strong>wait</strong></p> \n<p><strong>2、实例：</strong></p> \n<p>搜寻自己指定ip（子网掩码为24的）的网段中，UP的ip地址</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381515\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分析：请输入一个IP地址例192.168.37.234，如果格式不是0.0.0.0 则报错退出；正确则进入循环，IP变量的值为192.168.37. &nbsp;i的范围为1-254，并行ping&nbsp;192.168.37.1-154，ping通就输出此IP为UP。直到循环结束。</p> \n<p>四、信号捕获trap</p> \n<p><strong>1、用法格式</strong></p> \n<p><strong>trap \' 触发指令\'</strong>&nbsp;信号，自定义进程收到系统发出的指定信号后，将执行触发指令，而不会执行原操作</p> \n<p><strong>trap \'\'</strong>&nbsp;信号，忽略信号的操作</p> \n<p><strong>trap \'-\'</strong>&nbsp;信号，恢复原信号的操作</p> \n<p><strong>trap -p</strong>，列出自定义信号操作</p> \n<p>信号可以3种表达方法：信号的数字2、全名SIGINT、缩写INT</p> \n<p><strong>2、常用信号：</strong></p> \n<p>1) SIGHUP: 无须关闭进程而让其重读配置文件</p> \n<p>2) SIGINT: 中止正在运行的进程；相当于Ctrl+c</p> \n<p>3) SIGQUIT: 相当于ctrl+\\</p> \n<p>9) SIGKILL: 强制杀死正在运行的进程</p> \n<p>15) SIGTERM ：终止正在运行的进程（默认为15）</p> \n<p>18) SIGCONT ：继续运行</p> \n<p>19) SIGSTOP ：后台休眠</p> \n<p><strong>9 信号，强制杀死，捕获不住</strong></p> \n<p><strong>3、案例：</strong></p> \n<p>① 打印0-9，ctrl+c不能终止</p> \n<p><img alt=\"\" title=\"\"></p> \n<p>分析：i=0，当i&lt;10，每休眠1秒，i+1，捕获2信号，并执行echo press ctrl+c</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381517\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>② 打印0-3，ctrl+c不能终止，3之后恢复，能终止</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381518\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分析：i=0，当i&lt;3，每休眠1秒，i+1，捕获2信号；i&gt;3时，解除捕获2信号。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381519\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>五、脚本小知识（持续更新）</p> \n<p>**1、生成随机字符 cat /dev/urandom <br>**</p> \n<p>　　生成8个随机大小写字母或数字 cat /dev/urandom |tr -dc [:alnum:] |head -c 8</p> \n<p><strong>2、生成随机数 echo $RANDOM</strong></p> \n<p>　　确定范围 echo $[RANDOM%7] 随机7个数（0-6）</p> \n<p>　　　　　　&nbsp;echo $\\[$[RANDOM%7]+31] 随机7个数（31-37）</p> \n<p><strong>3、echo打印颜色字</strong></p> \n<p>echo -e \"\\033[31malong\\033[0m\" 显示红色along</p> \n<p>echo -e \"\\033[1;31malong\\033[0m\" 高亮显示红色along</p> \n<p>echo -e \"\\033[41malong\\033[0m\" 显示背景色为红色的along</p> \n<p>echo -e \"\\033[31;5malong\\033[0m\" 显示闪烁的红色along</p> \n<p>color=$\\[$[RANDOM%7]+31]</p> \n<p>echo -ne \"\\033[1;${color};5m*\\033[0m\" 显示闪烁的随机色along</p> \n<p>六、分享几个有意思的小脚本</p> \n<p><strong>1、9x9乘法表</strong> </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381521\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381523\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>2、彩色等腰三角形</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381522\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381520\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>3、国际象棋棋盘</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381524\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381525\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>好了，今天的内容就到这里了，其实小编的脚本功底也是小白级别的，大家一起努力，争取进阶为脚本大神！！！</p>', 'https://segmentfault.com/img/remote/1460000022381505', 'c56940aa8b004dab84568e86900b2ee6', 'd7416e100af54eb7a4d9274b9a462240,753b5aee3913424e81fe2b5299626d8c,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 17:00:02', '2020-04-16 17:00:02');
INSERT INTO `tb_recommend` VALUES ('5ee105932837498c9b6935ab5ad38189', '【思否编程公开课】游戏制作人招募（兼职），Reworld教你简单开发好玩的游戏', 'Reworld 物理引擎是一款极具创造性的 3D 游戏创作工具，游戏类型不受限制；具有天然物理属性，将现实中的力和约束拟真到游戏中；其内置商店有免费美术、特效、音频、模型等海量素材，在创作中按需拖拽即可；这些...', '<p><em>思否编程 联合<strong>代码乾坤</strong>，邀请<strong>原卓越游戏副总裁，重启世界联合创始人 董钰鹏（飞月）</strong>为大家带来了技术公开课。<strong>大咖坐镇，限时免费！</strong></em></p> \n<hr> \n<h5>直播主题：</h5> \n<p>游戏制作人招募（兼职），Reworld 教你简单开发好玩的游戏</p> \n<h5>内容介绍：</h5> \n<p>如果你会编程，热爱游戏，有创作游戏的想法，现在只需要一台电脑和创意即可轻松做出好玩的游戏。</p> \n<p>Reworld 物理引擎是一款极具创造性的 3D 游戏创作工具，游戏类型不受限制；具有天然物理属性，将现实中的力和约束拟真到游戏中；其内置商店有免费美术、特效、音频、模型等海量素材，在创作中按需拖拽即可；这些功能旨在能够很大程度降低游戏开发难度，提升效率，使游戏创作更简单有趣。使用 Reworld 物理引擎创作的游戏，上传到游戏平台后可以在 PC、安卓、iOS 平台完美运行。</p> \n<p>本次直播中除了 Reworld 物理引擎功能介绍，还将现场展示开发出一款好玩的游戏，观看直播的开发者也可以参与进来，感受创作游戏的乐趣。</p> \n<p><strong>直播主要内容：</strong></p> \n<ul> \n <li>游戏及游戏行业的概述</li> \n <li>游戏开发的乐趣：简单的游戏机制</li> \n <li>Reworld游戏制作人招募</li> \n</ul> \n<h5>直播时间：</h5> \n<p>2020 年 3 月 13 日（周五）晚上 8：00</p> \n<h5>讲师介绍：</h5> \n<p><strong>董钰鹏（飞月）</strong>，原卓越游戏副总裁，重启世界联合创始人，先后负责游戏项目包括《成吉思汗》、《画皮》、《我叫MT》、《我叫MT3》的运营工作，专注于游戏行业从业15年，拥有丰富的游戏开发经验和游戏项目的运营经验，同时也是一位热爱游戏的知识分享者。</p> \n<h5>直播地址：扫码入群看直播</h5> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEmgF\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"海报(4).png\" title=\"海报(4).png\"></span></p>', 'https://segmentfault.com/img/bVbEmgF', '5ca4567d892841b087fac5246effac40', '9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-16 16:57:48', '2020-04-16 16:57:48');
INSERT INTO `tb_recommend` VALUES ('5fb5763b9c0846c6ba64a9fe52a88151', '目标是最完善的微前端解决方案 - qiankun 2.0', '2019 年 6 月，微前端框架 qiankun 正式发布了 1.0 版本，在这一年不到的时间内，我们收获了 4k+ star，收获了来自 single-spa 官方团队的问候，支撑了阿里 200+ 线上应用，也成为社区很多团队选用的微前端解决方...', '<blockquote> \n <a href=\"https://zhuanlan.zhihu.com/p/131022025\" rel=\"nofollow noreferrer\">原文地址</a>\n <br>距 qiankun 开源已过去了 11 个月，距上次官方 \n <a href=\"https://zhuanlan.zhihu.com/p/78362028\" rel=\"nofollow noreferrer\">发声</a> 已过去 8 个月。\n</blockquote> \n<p><strong>Announcing qiankun@2.0</strong></p> \n<p>2019 年 6 月，微前端框架 <a href=\"https://github.com/umijs/qiankun\" rel=\"nofollow noreferrer\">qiankun</a> 正式发布了 1.0 版本，在这一年不到的时间内，我们收获了 4k+ star，收获了来自 single-spa 官方团队的问候，支撑了阿里 200+ 线上应用，也成为社区很多团队选用的微前端解决方案。</p> \n<p>在今天，qiankun 将正式发布 2.0 版本。</p> \n<p><em>qiankun@2.0 带来了一些新能力的同时，只做了很小的 API 调整，1.x 的用户可以很轻松的迁移到 2.x 版本，详细信息见下方 升级指南 小节。</em></p> \n<h2>qiankun 简介</h2> \n<p>可能有的朋友还不太了解 微前端 和 qiankun 是什么。</p> \n<p>微前端是最近一年国内前端领域被频繁提及的关键字，虽然它并不是一个全新的领域/技术，但很显然在当今越来越多的前端应用即将步入第 3 个、第 5 个甚至更久的年头的背景下，如何给 巨石应用/遗产应用 注入新鲜的技术血液已经成为我们不得不正视的问题，而微前端正是解决这类问题的一个非常合适的解决方案。</p> \n<p>qiankun 是一个生产可用的微前端框架，它基于 single-spa，具备 js 沙箱、样式隔离、HTML Loader、预加载 等微前端系统所需的能力。qiankun 可以用于任意 js 框架，微应用接入像嵌入一个 iframe 系统一样简单。</p> \n<p>更多信息可以查阅我们的 <a href=\"https://qiankun.umijs.org/\" rel=\"nofollow noreferrer\">官方站点</a></p> \n<h2>定位变化</h2> \n<p>qiankun 2.0 带来的最大变化便是 qiankun 的定位将由 <strong>微前端框架</strong> 转变为 <strong>微应用加载器</strong>。</p> \n<p>此前 qiankun 的典型应用场景是 route-based 的控制台应用，做为一个微应用的聚合框架而被使用。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391065\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image-20200415232001094\" title=\"image-20200415232001094\"></span></p> \n<p>如上图所示，在这种场景下，一个负责聚合与切换的主应用 与 多个相互独自的微应用 一起构成了整个大的微前端应用，一般来说页面上活跃着的也往往只有一个微应用。</p> \n<p>而这是微前端的场景之一，在另外一些场景下，你应该可以在同一个页面中，加载多个不同的微应用，每个微应用都是主应用的组成部分 或者是 提供一些增强能力，这种场景可以说是微应用粒度的前端组件化。</p> \n<p>因此，qiankun@2.0 将跳出 route-based 的微前端场景，<strong>提供更加通用的微应用加载能力</strong>，让用户可以更加自由的组合微应用来搭建产品。</p> \n<h2>本次升级带来了什么？</h2> \n<p>新功能</p> \n<ul> \n <li>支持多应用并行及多实例沙箱</li> \n <li>支持手动 加载/卸载 微应用</li> \n <li>支持 IE11 沙箱兼容</li> \n <li>官方的极简微应用通信方案</li> \n <li>支持基于 Shadow DOM 的样式隔离</li> \n</ul> \n<p>此外我们还做了</p> \n<ul> \n <li>升级 single-spa 到 5.x 版本</li> \n <li>更灵活的 prefetch 的定制策略</li> \n <li>配套的 webpack 插件</li> \n <li>更友好的部署场景支持，如自动为微应用注入运行时 publicPath 等</li> \n <li>更简单易懂的 API，重构了许多代码，使其更清晰和更具扩展性</li> \n <li>修复了一些 bug</li> \n</ul> \n<p>另外我们还升级了相应的 <a href=\"https://github.com/umijs/plugins/blob/master/packages/plugin-qiankun/README.md\" rel=\"nofollow noreferrer\">umi qiankun plugin</a>，在 umi 场景下你可以这样去加载一个微应用：</p> \n<pre><code class=\"tsx\">import { MicroApp } from \'umi\';\n\nfunction MyPage() {\n  return (\n      &lt;div&gt;\n      &lt;MicroApp name=\"qiankun\"/&gt;\n    &lt;/div&gt;\n  );\n}</code></pre> \n<p><a href=\"https://github.com/umijs/qiankun/releases\" rel=\"nofollow noreferrer\">发布日志</a></p> \n<h3>多应用支持</h3> \n<p>在 qiankun@1.x 中，我们的沙箱、样式隔离等机制只能对单一微应用场景生效，多个微应用共存的支持能力尚不完备。</p> \n<p>而在 2.0 版本中，我们终于完善了这一功能，现在，你可以同时激活多个微应用，而微应用之间可以保持互不干扰。</p> \n<p><strong>在多应用场景下，每个微应用的沙箱都是相互隔离的，也就是说每个微应用对全局的影响都会局限在微应用自己的作用域内。</strong>比如 A 应用在 <code>window</code> 上新增了个属性 <code>test</code>，这个属性只能在 A 应用自己的作用域通过 <code>window.test</code> 获取到，主应用或者其他微应用都无法拿到这个变量。</p> \n<blockquote>\n 但是注意，页面上不能同时显示多个依赖于路由的微应用，因为浏览器只有一个 url，如果有多个依赖路由的微应用同时被激活，那么大概率会导致其中一个 404。\n</blockquote> \n<p>为了更方便的同时装载多个微应用，我们提供了一个全新的 API <code>loadMicroApp</code> ，用于手动控制微应用：</p> \n<pre><code class=\"ts\">import { loadMicroApp } from \'qiankun\';\n\n/** 手动加载一个微应用 */\nconst microApp = loadMicroApp(\n  {\n    name: \"microApp\",\n    entry: \"https://localhost:7001/micro-app.html\",\n    container: \"#microApp\"\n  }\n)\n\n// 手动卸载\nmicroApp.mountPromise.then(() =&gt; microApp.unmount());</code></pre> \n<p>这也是 qiankun 作为一个应用加载器的使用方式。</p> \n<p>基于这个 api，你可以很容易的封装一个自己的微应用容器组件，比如：</p> \n<pre><code class=\"tsx\">class MicroApp extends React.Component {\n  \n  microAppRef = null;\n  \n  componentDidMount() {\n    const { name, entry } = this.props;\n    this.microAppRef = loadMicroApp({ name, entry, container: \'#container\' });\n  }\n  \n  componentWillUnmount() {\n    this.microAppRef.mountPromise.then(() =&gt; this.microAppRef.unmount());\n  }\n  \n  render() {\n    return &lt;div id=\"container\"/&gt;;\n  }\n}</code></pre> \n<h3>兼容 IE11 的沙箱能力</h3> \n<p>在 qiankun issue 区域呼声最高的就是 <a href=\"https://github.com/umijs/qiankun/issues/182\" rel=\"nofollow noreferrer\">IE 的兼容</a>，有不少小伙伴都期待 qiankun 能够在 IE 下使用。</p> \n<p>qiankun 1.x 在 IE 使用的主要阻碍就是 qiankun 的沙箱使用了 ES6 的 Proxy，而这无法通过 ployfill 等方式弥补。这导致 IE 下的 qiankun 用户无法开启 qiankun 的沙箱功能，导致 js 隔离、样式隔离这些能力都无法启用。</p> \n<p>为此，我们实现了一个 IE 特供的快照沙箱，用于这些不支持 Proxy 的浏览器；这不需要用户手动开启，在代理沙箱不支持的环境中，我们会自动降级到快照沙箱。</p> \n<blockquote>\n 注意，由于快照沙箱不能做到互相之间的完全独立，所以 IE 等环境下我们不支持多应用场景， \n <code>singlur</code> 会被强制设为 true。\n</blockquote> \n<h3>基于 shadow DOM 的样式隔离</h3> \n<p>样式隔离也是微前端面临的一个重要问题，在 qiankun@1.x 中，我们支持了微应用之间的样式隔离（仅沙箱开启时生效），这尚存一些问题：</p> \n<ol> \n <li>主子应用之间的样式隔离依赖手动配置插件处理</li> \n <li>多应用场景下微应用之间的样式隔离亟待处理</li> \n</ol> \n<p>为此，我们引入了一个新的选项， <code>sandbox: { strictStyleIsolation?: boolean }</code> 。</p> \n<p>在该选项开启的情况下，我们会以 Shadow DOM 的形式嵌入微应用，以此来做到应用样式的真正隔离：</p> \n<pre><code class=\"ts\">import { loadMicroApp } from \'qiankun\'\n\nloadMicroApp({xxx}, { sandbox: { strictStyleIsolation: true } });</code></pre> \n<p>Shadow DOM 可以做到样式之间的真正隔离（而不是依赖分配前缀等约定式隔离），其形式如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391064\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<blockquote>\n 图片来自 \n <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components/Using_shadow_DOM\" rel=\"nofollow noreferrer\">MDN</a> \n</blockquote> \n<p>在开启 <code>strictStyleIsolation</code> 时，我们会将微应用插入到 qiankun 创建好的 Shadow Tree 中，微应用的样式（包括动态插入的样式）都会被挂载到这个 Shadow Host 节点下，因此微应用的样式只会作用在 Shadow Tree 内部，这样就做到了样式隔离。</p> \n<p>但是开启 Shadow DOM 也会引发一些别的问题：</p> \n<p>一个典型的问题是，一些组件可能会越过 Shadow Boundary 到外部 Document Tree 插入节点，而这部分节点的样式就会丢失；比如 antd 的 <code>Modal</code> 就会渲染节点至 <code>ducument.body</code> ，引发样式丢失；针对刚才的 antd 场景你可以通过他们提供的 <code>ConfigProvider.getPopupContainer</code> API 来指定在 Shadow Tree 内部的节点为挂载节点，但另外一些其他的组件库，或者你的一些代码也会遇到同样的问题，需要你额外留心。</p> \n<p>此外 Shadow DOM 场景下还会有一些额外的事件处理、边界处理等问题，后续我们会逐步更新官方文档指导用户更顺利的开启 Shadow DOM。</p> \n<p>所以请根据实际情况来选择是否开启基于 shadow DOM 的样式隔离，并做好相应的检查和处理。</p> \n<h2>官方的极简通信方案</h2> \n<p>微前端场景下，我们认为最合理的通信方案是通过 URL 及 CustomEvent 来处理。但在一些简单场景下，基于 props 的方案会更直接便捷，因此我们为 qiankun 用户提供这样一组 API 来完成应用间的通信：</p> \n<p>主应用创建共享状态：</p> \n<pre><code class=\"ts\">import { initGloabalState } from \'qiankun\';\n\ninitGloabalState({ user: \'kuitos\' });</code></pre> \n<p>微应用通过 props 获取共享状态并监听：</p> \n<pre><code class=\"ts\">export function mount(props) {\n  props.onGlobalStateChange((state, prevState) =&gt; {\n    console.log(state, prevState);\n  });\n};</code></pre> \n<p>更详细的 API 介绍可以查看<a href=\"https://qiankun.umijs.org/zh/api/#initgloabalstate-state\" rel=\"nofollow noreferrer\">官方文档</a>。</p> \n<h2>我们会继续为大家带来什么</h2> \n<p>除了基本的日常维护、bugfix 之外，我们还会尝试走的更远：</p> \n<ol> \n <li>官方支持的 qiankun webpack 插件，解决一些由于配置不当出现的问题</li> \n <li>自定义的沙箱规则</li> \n <li>微应用嵌套支持</li> \n <li>更友好的调试体验</li> \n <li>与 Webpack5 Module Federation 的结合，提供官方的使用指导或插件</li> \n <li>更多的实验性（experimental）尝试，如基于原生 <a href=\"https://github.com/WICG/portals/blob/master/explainer.md\" rel=\"nofollow noreferrer\">Portal</a> 标签的微应用渲染，基于运行时的更轻量的样式隔离方案。</li> \n</ol> \n<h2>升级指南</h2> \n<p>2.0 版本 调整了相当多的内部 API 名字，但大家使用的外部 API 变化并不大（基本完全兼容 1.x），你可以在十分钟内完成升级。</p> \n<h3>render 更改为 container</h3> \n<pre><code class=\"diff\">import { registerMicroApps } from \'qiankun\'\n\nregisterMicroApps(\n  [\n    {\n      name: \'react16\',\n      entry: \'//localhost:7100\',\n-     activeRule: location =&gt; location.pathname.startsWith(\'/react\'),\n+     activeRule: \'/react\',\n-     render: renderFn,\n+     container: \'#subapp-viewport\',\n    },\n  ]\n)</code></pre> \n<p>现在你可以简单的指定一个挂载节点即可，而不用自己手写对应的 render 函数了。简单场景下 <code>activeRule</code> 配置也不需要再手写函数了（当然还是支持自定义函数），只需要给出一个前缀规则字符串即可，同时支持 react-router 类的动态规则，如 <code>/react/:appId/name</code> （来自 single-spa 5.x 的支持）。</p> \n<p>同时，微应用收到的 <code>props</code> 中会新增一个 <code>container</code> 属性，这就是你的挂载节点的 DOM，这对处理动态添加的容器以及开启了 Shadow DOM 场景下非常有用。</p> \n<blockquote>\n 注意，旧的 render 配置依然可以使用，我们做了兼容处理方便不想升级的用户；但 render 存在时，container 就不会生效。\n</blockquote> \n<h3>start 的配置变化</h3> \n<p>因为我们引入了一些新的能力，因为 start 的配置也发生了一些变化：</p> \n<pre><code class=\"diff\">import { start } from \'qiankun\'\n\nstart({\n-  jsSandbox: true,\n+  sandbox: {\n+    strictStyleIsolation: true\n+  }\n})</code></pre> \n<h3>新的 API <code>loadMicroApp</code> </h3> \n<p>这个 API 用于手动挂载一个微应用</p> \n<pre><code>/** 用于加载一个微应用 */\nloadMicroApp(app: LoadableApp, configuration?: FrameworkConfiguration)</code></pre> \n<p>使用详情可见上面 多应用支持 小节。</p>', 'https://segmentfault.com/img/remote/1460000022391065', '3f69fcc9b13843d1910b3dac597f5215', '63c4e1e7ec204b43a62065a3ced4c2ce,d79254c4ca5e45dca9d484307c935281,7bdbb73fad864154bd1b93c965c3ea62', '0', '3', '1', '2020-04-16 16:48:01', '2020-04-16 16:48:01');
INSERT INTO `tb_recommend` VALUES ('64ea134b1ab64bf7ad8a10a3523c79ba', '华为云回应：目前华为云故障基本修复，部分客户的业务正在配合恢复中', '技术编辑：鸣飞 发自北京 SegmentFault 思否报道 | 公众号：SegmentFault SegmentFault 思否消息：4月10日早，据多位开发者反映，华为云登录、管理后台无法访问，ssh 连接不上。 目前华为云官方在微博上回应：4月...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<hr> \n<p>SegmentFault 思否消息：4月10日早，据多位开发者反映，华为云登录、管理后台无法访问，ssh 连接不上。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQjv\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"据多位开发者在微博上反映，华为云登录、管理后台无法访问。\" title=\"据多位开发者在微博上反映，华为云登录、管理后台无法访问。\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQjB\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"华为云.png\" title=\"华为云.png\"></span></p> \n<p><strong>目前华为云官方在微博上回应：</strong>4月10日上午检测到部分主机异常，目前故障基本修复，部分客户的业务正在配合恢复中。感谢您对华为云的支持！ ​​​​</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQjJ\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"华为云在微博上的回应：目前华为云故障基本修复，部分客户的业务正在配合恢复中。\" title=\"华为云在微博上的回应：目前华为云故障基本修复，部分客户的业务正在配合恢复中。\"></span></p> \n<p>至于是什么原因导致此次故障还不清楚，我们也正在与华为云官方沟通，我们会持续跟进最新消息。</p> \n<p>相信华为云团队能解决好这次技术故障问题。</p> \n<hr> \n<p><strong>近年来，云计算的落地一直在推进中，政策红利也不断释放。</strong></p> \n<p>例如，工信部就先后印发了《云计算发展三年行动计划(2017-2019 年)》和《推动企业上云实施指南(2018-2020 年)》(以下简称《实施指南》)，并提出了到 2020 年，全国新增上云企业 100 万家的目标。</p> \n<p>国内云计算市场的整体加速爆发。同时，随着数据电子化的实现、对安全性要求的提高，云计算国产化也是历史的选择，华为云、阿里云、腾讯云等国内企业占据了中国大部分市场。</p> \n<p>根据IDC报告，2019年上半年，从IaaS市场来看，阿里、腾讯、中国电信、AWS、华为位居前五，占据总体75.3%的市场份额；从IaaS+PaaS市场来看，阿里、腾讯、AWS、中国电信、华为共同占据74%的市场份额。</p> \n<p>2019年上半年，华为云在中国公有云IaaS+PaaS市场增速超过350%，在TOP厂商中位列第一；IaaS市场营收增长高达368%，排名跃升至第四。2019年，华为云驶入发展快车道，上半年业务收入同比增长500%，客户数规模同比增长达33倍。</p> \n<p><strong>接下来，巨头间的硬核投资和技术竞争还将持续。</strong></p> \n<p>其次，在历经十多年的发展后，云计算已经下沉到各个行业应用，从互联网领域拓展到政企等非互联网领域，进入第二产业、第三产业当中。这也开启了云计算市场的新角逐，在技术和基础设施外，云服务厂商们开始构筑自家生态体系。从芯片、数据中心，到平台、上层应用，再到市场渠道等等，都在考验厂商的综合能力。</p> \n<p>Gartner的数据显示，目前估值超过10亿美元的云计算公司已近百家，2019年全球公有云服务市场预计增长至2143亿美元，同比2018年增长17.5%。预测到2022年，云服务行业的增长速度将是整个IT行业增长速度的三倍。</p> \n<p>目前来看，每一家云服务商也各有特色，都通过差异化来争夺细分市场。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFmMq\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"思否公众号\" title=\"思否公众号\"></span></p>', 'https://segmentfault.com/img/bVbFQjv', '692c6787030d4b8882077b2ab9279c52', '581c0fef5c3347b8bedbf8c2421d911b,e80d97c3472e428dabdaf417adac7a3c,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-16 16:56:34', '2020-04-16 16:56:34');
INSERT INTO `tb_recommend` VALUES ('65f4cb10b9294f2da16e384223f4fa47', '值得收藏！Kubernetes 常见运维技巧总结', '注：节选自《Kubernetes权威指南》，主要对常用的Kubernetes系统运维操作和技巧进行详细说明。 1、Node的隔离和恢复 {代码...} 然后，通过kubectl replace命令完成对Node状态的修改： {代码...} 查看Node的状态，...', '<blockquote>\n 注：节选自《Kubernetes权威指南》，主要对常用的Kubernetes系统运维操作和技巧进行详细说明。\n</blockquote> \n<p><strong>1、Node的隔离和恢复</strong></p> \n<hr> \n<pre><code>apiVersion: v1\nkind: Node\nmetadata:  \n  name: kubernetes-minion1  \n  labels:    \n   kubernetes.io/hostname: kubernetes-minion1\nspec:  \n   unschedulable: true</code></pre> \n<p>然后，通过kubectl replace命令完成对Node状态的修改：</p> \n<pre><code>$ kubectl replace -f unschedule_node.yaml \nnodes/kubernetes-minion1</code></pre> \n<p>查看Node的状态，可以观察到在Node的状态中增加了一项SchedulingDisabled：</p> \n<pre><code>$ kubectl get nodes\nNAME                 LABELS                                      STATUS\nkubernetes-minion1   kubernetes.io/hostname=kubernetes-minion1   Ready, SchedulingDisabled</code></pre> \n<p>对于后续创建的Pod，系统将不会再向该Node进行调度。</p> \n<p>另一种方法是不使用配置文件，直接使用kubectl patch命令完成：</p> \n<pre><code>$ kubectl patch node kubernetes-minion1 -p \'{＂spec＂:{＂unschedulable＂:true}}\'</code></pre> \n<p>需要注意的是，将某个Node脱离调度范围时，在其上运行的Pod并不会自动停止，管理员需要手动停止在该Node上运行的Pod。 </p> \n<p>同样，如果需要将某个Node重新纳入集群调度范围，则将unschedulable设置为false，再次执行kubectl replace或kubectl patch命令就能恢复系统对该Node的调度。</p> \n<h2><strong>2、Node的扩容</strong></h2> \n<p>在实际生产系统中会经常遇到服务器容量不足的情况，这时就需要购买新的服务器，然后将应用系统进行水平扩展来完成对系统的扩容。</p> \n<p>在Kubernetes集群中，对于一个新Node的加入是非常简单的。可以在Node节点上安装Docker、Kubelet和kube-proxy服务，然后将Kubelet和kube-proxy的启动参数中的Master URL指定为当前Kubernetes集群Master的地址，最后启动这些服务。基于Kubelet的自动注册机制，新的Node将会自动加入现有的Kubernetes集群中，如图1所示。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393273\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span><br>图1 新节点自动注册完成扩容</p> \n<p>Kubernetes Master在接受了新Node的注册之后，会自动将其纳入当前集群的调度范围内，在之后创建容器时，就可以向新的Node进行调度了。 </p> \n<p>通过这种机制，Kubernetes实现了集群的扩容。</p> \n<h2><strong>3、Pod动态扩容和缩放</strong></h2> \n<p>在实际生产系统中，我们经常会遇到某个服务需要扩容的场景，也可能会遇到由于资源紧张或者工作负载降低而需要减少服务实例数的场景。此时我们可以利用命令kubectl scale rc来完成这些任务。以redis-slave RC为例，已定义的最初副本数量为2，通过执行下面的命令将redis-slave RC控制的Pod副本数量从初始的2更新为3：</p> \n<pre><code>$ kubectl scale rc redis-slave --replicas=3\nscaled</code></pre> \n<p>执行kubectl get pods命令来验证Pod的副本数量增加到3：</p> \n<pre><code>$ kubectl get pods\nNAME                READY     STATUS    RESTARTS AGE\nredis-slave-4na2n    1/1     Running      0      1h\nredis-slave-92u3k    1/1       Running    0      1h\nredis-slave-palab    1/1       Running    0      2m</code></pre> \n<p>将--replicas设置为比当前Pod副本数量更小的数字，系统将会“杀掉”一些运行中的Pod，即可实现应用集群缩容：</p> \n<pre><code>$ kubectl scale rc redis-slave --replicas=1\nscaled\n\n$ kubectl get pods\nNAME               READY         STATUS    RESTARTS   AGE\nredis-slave-4na2n    1/1           Running   0          1h</code></pre> \n<h2><strong>4、更新资源对象的Label</strong></h2> \n<p>Label（标签）作为用户可灵活定义的对象属性，在已创建的对象上，仍然可以随时通过kubectl label命令对其进行增加、修改、删除等操作。 </p> \n<p>例如，我们要给已创建的Pod“redis-master-bobr0”添加一个标签role=backend：</p> \n<pre><code>$ kubectl label pod redis-master-bobr0 role=backend</code></pre> \n<p>查看该Pod的Label：</p> \n<pre><code>$ kubectl get pods -Lrole\nNAME               READY     STATUS    RESTARTS   AGE  ROLE\nredis-master-bobr0   1/1       Running   0       3m        backend</code></pre> \n<p>删除一个Label，只需在命令行最后指定Label的key名并与一个减号相连即可：</p> \n<pre><code>$ kubectl label pod redis-master-bobr0 role-</code></pre> \n<p>修改一个Label的值，需要加上--overwrite参数：</p> \n<pre><code>$ kubectl label pod redis-master-bobr0 role=master --overwrite</code></pre> \n<h2><strong>5、将Pod调度到指定的Node</strong></h2> \n<p>我们知道，Kubernetes的Scheduler服务（kube-scheduler进程）负责实现Pod的调度，整个调度过程通过执行一系列复杂的算法最终为每个Pod计算出一个最佳的目标节点，这一过程是自动完成的，我们无法知道Pod最终会被调度到哪个节点上。有时我们可能需要将Pod调度到一个指定的Node上，此时，我们可以通过Node的标签（Label）和Pod的nodeSelector属性相匹配，来达到上述目的。 </p> \n<p>首先，我们可以通过kubectl label命令给目标Node打上一个特定的标签，下面是此命令的完整用法：</p> \n<pre><code>kubectl label nodes &lt;node-name&gt; &lt;label-key&gt;=&lt;label-value&gt;</code></pre> \n<p>这里，我们为kubernetes-minion1节点打上一个zone=north的标签，表明它是“北方”的一个节点：</p> \n<pre><code>$ kubectl label nodes kubernetes-minion1 zone=north\nNAME                 LABELS                                                 STATUS\nkubernetes-minion1   kubernetes.io/hostname=kubernetes-minion1,zone=north   Ready</code></pre> \n<p>上述命令行操作也可以通过修改资源定义文件的方式，并执行kubectl replace -f xxx.yaml命令来完成。 </p> \n<p>然后，在Pod的配置文件中加入nodeSelector定义，以redis-master-controller.yaml为例：</p> \n<pre><code>apiVersion: v1\nkind: ReplicationController\nmetadata:  \nname: redis-master  \nlabels:    \n   name: redis-master\nspec:  \n   replicas: 1  \n   selector:    \n     name: redis-master  \n     template:    \n       metadata:      \n       labels:        \n       name: redis-master    \n  spec:      \n     containers:      \n        - name: master        \n     image: kubeguide/redis-master        \n     ports:        \n       - containerPort: 6379      \n       nodeSelector:        \n          zone: north</code></pre> \n<p>运行kubectl create -f命令创建Pod，scheduler就会将该Pod调度到拥有zone=north标签的Node上去。 </p> \n<p>使用kubectl get pods -o wide命令可以验证Pod所在的Node：</p> \n<pre><code># kubectl get pods -o wide\nNAME                 READY     STATUS    RESTARTS   AGE       NODE\nredis-master-f0rqj   1/1       Running   0          19s       kubernetes-minion1</code></pre> \n<p>如果我们给多个Node都定义了相同的标签（例如zone=north），则scheduler将会根据调度算法从这组Node中挑选一个可用的Node进行Pod调度。 </p> \n<p>这种基于Node标签的调度方式灵活性很高，比如我们可以把一组Node分别贴上“开发环境”“测试验证环境”“用户验收环境”这三组标签中的一种，此时一个Kubernetes集群就承载了3个环境，这将大大提高开发效率。 </p> \n<p>需要注意的是，如果我们指定了Pod的nodeSelector条件，且集群中不存在包含相应标签的Node时，即使还有其他可供调度的Node，这个Pod也最终会调度失败。</p> \n<h2><strong>6、应用的滚动升级</strong></h2> \n<p>当集群中的某个服务需要升级时，我们需要停止目前与该服务相关的所有Pod，然后重新拉取镜像并启动。如果集群规模比较大，则这个工作就变成了一个挑战，而且先全部停止然后逐步升级的方式会导致较长时间的服务不可用。Kubernetes提供了rolling-update（滚动升级）功能来解决上述问题。 </p> \n<p>滚动升级通过执行kubectl rolling-update命令一键完成，该命令创建了一个新的RC，然后自动控制旧的RC中的Pod副本数量逐渐减少到0，同时新的RC中的Pod副本数量从0逐步增加到目标值，最终实现了Pod的升级。需要注意的是，系统要求新的RC需要与旧的RC在相同的命名空间（Namespace）内，即不能把别人的资产偷偷转移到自家名下。 </p> \n<p>以redis-master为例，假设当前运行的redis-master Pod是1.0版本，则现在需要升级到2.0版本。 </p> \n<p>创建redis-master-controller-v2.yaml的配置文件如下：</p> \n<pre><code>apiVersion: v1  \nkind: ReplicationController  \nmetadata:  \n  name: redis-master-v2  \n  labels:  \n   name: redis-master  \nversion: v2  \nspec:  \n  replicas: 1  \n  selector:  \n    name: redis-master  \n    version: v2  \ntemplate:  \n  metadata:  \n  labels:  \n    name: redis-master  \n    version: v2  \nspec:  \ncontainers:  \n- name: master  \n  image: kubeguide/redis-master:2.0  \nports:  \n- containerPort: 6379</code></pre> \n<p>在配置文件中有几处需要注意： <br>（1）RC的名字（name）不能与旧的RC的名字相同； <br>（2）在selector中应至少有一个Label与旧的RC的Label不同，以标识其为新的RC。 </p> \n<p>本例中新增了一个名为version的Label，以与旧的RC进行区分。 </p> \n<p>运行kubectl rolling-update命令完成Pod的滚动升级：</p> \n<pre><code>kubectl rolling-update redis-master -f redis-master-controller-v2.yaml</code></pre> \n<p>Kubectl的执行过程如下：</p> \n<pre><code>Creating redis-master-v2  \nAt beginning of loop: redis-master replicas: 2, redis-master-v2 replicas: 1  \nUpdating redis-master replicas: 2, redis-master-v2 replicas: 1  \nAt end of loop: redis-master replicas: 2, redis-master-v2 replicas: 1  \nAt beginning of loop: redis-master replicas: 1, redis-master-v2 replicas: 2  \nUpdating redis-master replicas: 1, redis-master-v2 replicas: 2  \nAt end of loop: redis-master replicas: 1, redis-master-v2 replicas: 2  \nAt beginning of loop: redis-master replicas: 0, redis-master-v2 replicas: 3  \nUpdating redis-master replicas: 0, redis-master-v2 replicas: 3  \nAt end of loop: redis-master replicas: 0, redis-master-v2 replicas: 3  \nUpdate succeeded. Deleting redis-master  \nredis-master-v2</code></pre> \n<p>等所有新的Pod启动完成后，旧的Pod也被全部销毁，这样就完成了容器集群的更新。 </p> \n<p>另一种方法是不使用配置文件，直接用kubectl rolling-update命令，加上--image参数指定新版镜像名称来完成Pod的滚动升级：</p> \n<pre><code>kubectl rolling-update redis-master --image=redis-master:2.0</code></pre> \n<p>与使用配置文件的方式不同，执行的结果是旧的RC被删除，新的RC仍将使用旧的RC的名字。 </p> \n<p>Kubectl的执行过程如下：</p> \n<pre><code>Creating redis-master-ea866a5d2c08588c3375b86fb253db75  \nAt beginning of loop: redis-master replicas: 2, redis-master-ea866a5d2c08588c 3375b86fb253db75 replicas: 1  \nUpdating redis-master replicas: 2, redis-master-ea866a5d2c08588c3375b86fb253db 75 replicas: 1  \nAt end of loop: redis-master replicas: 2, redis-master-ea866a5d2c08588c3375b86fb 253db75 replicas: 1  \nAt beginning of loop: redis-master replicas: 1, redis-master-ea866a5d2c08588c 3375b86fb253db75 replicas: 2  \nUpdating redis-master replicas: 1, redis-master-ea866a5d2c08588c3375b86fb 253db75 replicas: 2  \nAt end of loop: redis-master replicas: 1, redis-master-ea866a5d2c08588c3375b86fb 253db75 replicas: 2  \nAt beginning of loop: redis-master replicas: 0, redis-master-ea866a5d2c08588c 3375b86fb253db75 replicas: 3  \nUpdating redis-master replicas: 0, redis-master-ea866a5d2c08588c3375b86fb253db 75 replicas: 3  \nAt end of loop: redis-master replicas: 0, redis-master-ea866a5d2c08588c3375b86fb 253db75 replicas: 3  \nUpdate succeeded. Deleting old controller: redis-master  \nRenaming redis-master-ea866a5d2c08588c3375b86fb253db75 to redis-master  \nredis-master</code></pre> \n<p>可以看到，Kubectl通过新建一个新版本Pod，停掉一个旧版本Pod，逐步迭代来完成整个RC的更新。 </p> \n<p>更新完成后，查看RC：</p> \n<pre><code>$ kubectl get rc    \nCONTROLLER     CONTAINER(S)   IMAGE(S)            SELECTOR        REPLICAS\nredis-master   master         kubeguide/redis-master:2.0              deployment= ea866a5d2c08588c3375b86fb253db75,name=redis-master,version=v1   3</code></pre> \n<p>可以看到，Kubectl给RC增加了一个key为“deployment”的Label（这个key的名字可通过--deployment-label-key参数进行修改），Label的值是RC的内容进行Hash计算后的值，相当于签名，这样就能很方便地比较RC里的Image名字及其他信息是否发生了变化，它的具体作用可以参见第6章的源码分析。 </p> \n<p>如果在更新过程中发现配置有误，则用户可以中断更新操作，并通过执行Kubectl rolling-update –rollback完成Pod版本的回滚：</p> \n<pre><code>$ kubectl rolling-update redis-master --image=kubeguide/redis-master:2.0 --rollback  \nFound existing update in progress (redis-master-fefd9752aa5883ca4d53013a7b 583967), resuming.  \nFound desired replicas.Continuing update with existing controller redis-master.  \nAt beginning of loop: redis-master-fefd9752aa5883ca4d53013a7b583967 replicas: 0, redis-master replicas: 3  \nUpdating redis-master-fefd9752aa5883ca4d53013a7b583967 replicas: 0, redis-master replicas: 3  \nAt end of loop: redis-master-fefd9752aa5883ca4d53013a7b583967 replicas: 0, redis-master replicas: 3  \nUpdate succeeded. Deleting redis-master-fefd9752aa5883ca4d53013a7b583967  \nredis-master</code></pre> \n<p>到此，可以看到Pod恢复到更新前的版本了。</p> \n<h2><strong>7、Kubernetes集群高可用方案</strong></h2> \n<p>Kubernetes作为容器应用的管理中心，通过对Pod的数量进行监控，并且根据主机或容器失效的状态将新的Pod调度到其他Node上，实现了应用层的高可用性。针对Kubernetes集群，高可用性还应包含以下两个层面的考虑：etcd数据存储的高可用性和Kubernetes Master组件的高可用性。 </p> \n<p>**7.1 etcd高可用性方案 <br>**</p> \n<p>etcd在整个Kubernetes集群中处于中心数据库的地位，为保证Kubernetes集群的高可用性，首先需要保证数据库不是单故障点。一方面，etcd需要以集群的方式进行部署，以实现etcd数据存储的冗余、备份与高可用性；另一方面，etcd存储的数据本身也应考虑使用可靠的存储设备。 </p> \n<p>etcd集群的部署可以使用静态配置，也可以通过etcd提供的REST API在运行时动态添加、修改或删除集群中的成员。本节将对etcd集群的静态配置进行说明。关于动态修改的操作方法请参考etcd官方文档的说明。 </p> \n<p>首先，规划一个至少3台服务器（节点）的etcd集群，在每台服务器上安装好etcd。 </p> \n<p>部署一个由3台服务器组成的etcd集群，其配置如表1所示，其集群部署实例如图2所示。 <br>表1 etcd集群的配置 <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393276\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393275\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>然后修改每台服务器上etcd的配置文件/etc/etcd/etcd.conf。 </p> \n<p>以etcd1为创建集群的实例，需要将其ETCD_INITIAL_CLUSTER_STATE设置为“new”。etcd1的完整配置如下：</p> \n<pre><code># [member]  \nETCD_NAME=etcd1 #etcd实例名称  \nETCD_DATA_DIR=＂/var/lib/etcd/etcd1＂ #etcd数据保存目录  \nETCD_LISTEN_PEER_URLS=＂http://10.0.0.1:2380＂ #集群内部通信使用的URL  \nETCD_LISTEN_CLIENT_URLS=＂http://10.0.0.1:2379＂ #供外部客户端使用的URL  \n……  \n#[cluster]  \nETCD_INITIAL_ADVERTISE_PEER_URLS=＂http://10.0.0.1:2380＂ #广播给集群内其他成员使用的URL  \nETCD_INITIAL_CLUSTER=＂etcd1=http://10.0.0.1:2380,etcd2=http://10.0.0.2:2380, etcd3=http://10.0.0.3:2380＂ #初始集群成员列表  \nETCD_INITIAL_CLUSTER_STATE=＂new＂ #初始集群状态，new为新建集群  \nETCD_INITIAL_CLUSTER_TOKEN=＂etcd-cluster＂ #集群名称  \nETCD_ADVERTISE_CLIENT_URLS=＂http://10.0.0.1:2379＂ #广播给外部客户端使用的URL</code></pre> \n<p>启动etcd1服务器上的etcd服务：</p> \n<pre><code>$ systemctl restart etcd</code></pre> \n<p>启动完成后，就创建了一个名为etcd-cluster的集群。 </p> \n<p>etcd2和etcd3为加入etcd-cluster集群的实例，需要将其ETCD_INITIAL_CLUSTER_STATE设置为“exist”。etcd2的完整配置如下（etcd3的配置略）：</p> \n<pre><code># [member]  \nETCD_NAME=etcd2 #etcd实例名称  \nETCD_DATA_DIR=＂/var/lib/etcd/etcd2＂ #etcd数据保存目录  \nETCD_LISTEN_PEER_URLS=＂http://10.0.0.2:2380＂ #集群内部通信使用的URL  \nETCD_LISTEN_CLIENT_URLS=＂http://10.0.0.2:2379＂ #供外部客户端使用的URL  \n……  \n#[cluster]  \nETCD_INITIAL_ADVERTISE_PEER_URLS=＂http://10.0.0.2:2380＂ #广播给集群内其他成员使用的URL  \nETCD_INITIAL_CLUSTER=＂etcd1=http://10.0.0.1:2380,etcd2=http://10.0.0.2:2380,etcd3=http://10.0.0.3:2380＂ #初始集群成员列表  \nETCD_INITIAL_CLUSTER_STATE=＂exist＂ # existing表示加入已存在的集群  \nETCD_INITIAL_CLUSTER_TOKEN=＂etcd-cluster＂ #集群名称  \nETCD_ADVERTISE_CLIENT_URLS=＂http://10.0.0.2:2379＂ #广播给外部客户端使用的URL</code></pre> \n<p>启动etcd2和etcd3服务器上的etcd服务：</p> \n<pre><code>$ systemctl restart etcd</code></pre> \n<p>启动完成后，在任意etcd节点执行etcdctl cluster-health命令来查询集群的运行状态：</p> \n<pre><code>$ etcdctl cluster-health\ncluster is healthy\nmember ce2a822cea30bfca is healthy\nmember acda82ba1cf790fc is healthy\nmember eba209cd0012cd2 is healthy</code></pre> \n<p>在任意etcd节点上执行etcdctl member list命令来查询集群的成员列表：</p> \n<pre><code>$ etcdctl member list\nce2a822cea30bfca: name=default peerURLs=http://10.0.0.1:2380,http://10.0.0.1: 7001 clientURLs=http://10.0.0.1:2379,http://10.0.0.1:4001\nacda82ba1cf790fc: name=default peerURLs=http://10.0.0.2:2380,http://10.0.0.2: 7001 clientURLs=http://10.0.0.2:2379,http://10.0.0.2:4001\neba209cd40012cd2: name=default peerURLs=http://10.0.0.3:2380,http://10.0.0.3: 7001 clientURLs=http://10.0.0.3:2379,http://10.0.0.3:4001</code></pre> \n<p>至此，一个etcd集群就创建成功了。 </p> \n<p>以kube-apiserver为例，将访问etcd集群的参数设置为：</p> \n<pre><code>--etcd-servers=http://10.0.0.1:4001,http://10.0.0.2:4001,http://10.0.0.3:4001</code></pre> \n<p>在etcd集群成功启动之后，如果需要对集群成员进行修改，则请参考官方文档的详细说明：点击此处6 </p> \n<p>对于etcd中需要保存的数据的可靠性，可以考虑使用RAID磁盘阵列、高性能存储设备、NFS网络文件系统，或者使用云服务商提供的网盘系统等来实现。 </p> \n<p><strong>7.2 Kubernetes Master组件的高可用性方案</strong> </p> \n<p>在Kubernetes体系中，Master服务扮演着总控中心的角色，主要的三个服务kube-apiserver、kube-controller-mansger和kube-scheduler通过不断与工作节点上的Kubelet和kube-proxy进行通信来维护整个集群的健康工作状态。如果Master的服务无法访问到某个Node，则会将该Node标记为不可用，不再向其调度新建的Pod。但对Master自身则需要进行额外的监控，使Master不成为集群的单故障点，所以对Master服务也需要进行高可用方式的部署。 </p> \n<p>以Master的kube-apiserver、kube-controller-mansger和kube-scheduler三个服务作为一个部署单元，类似于etcd集群的典型部署配置。使用至少三台服务器安装Master服务，并且使用Active-Standby-Standby模式，保证任何时候总有一套Master能够正常工作。 </p> \n<p>所有工作节点上的Kubelet和kube-proxy服务则需要访问Master集群的统一访问入口地址，例如可以使用pacemaker等工具来实现。图3展示了一种典型的部署方式。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393274\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span><br>图3 Kubernetes Master高可用部署架构</p>', 'https://segmentfault.com/img/remote/1460000022393273', '1894b118d35d44cb8fe8009529c4154b', 'd7416e100af54eb7a4d9274b9a462240,753b5aee3913424e81fe2b5299626d8c,3820770e46ef414faee8ed89ce154fdc,81a4561c1c294e0cae32c9fe6b5dc397,d3d03b3c361b4e3f9148f6ae02761c29', '0', '3', '1', '2020-04-16 16:59:59', '2020-04-16 16:59:59');
INSERT INTO `tb_recommend` VALUES ('6aff19fb2bf643aeb3cbabe3bdec8735', '有了这款产品，APP实现秒级登录不是梦！用户：极度舒适', '近年来，验证领域迎来一个黑科技——用户在APP上进行账号注册或者号码绑定时，不需要接收短信验证码，直接可以以本机号码实现秒级验证。这种新颖且便捷的验证方式称为“一键认证”。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021911803\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>近年来，验证领域迎来一个黑科技——用户在APP上进行账号注册或者号码绑定时，不需要接收短信验证码，直接可以以本机号码实现秒级验证。这种新颖且便捷的验证方式称为“一键认证”。</p> \n<p>一键认证大幅度地简化了用户注册/登录流程，且提升了账号安全性，逐步成为新一代的主流验证登录方式。<strong>什么是一键认证，它的实现条件是什么，又有哪些功能优势呢</strong>？接下来，个推君将为大家一一解答。</p> \n<h1>一、什么是一键认证</h1> \n<p>一键认证是依托运营商的移动数据网络，采用“通信网关取号”及SIM卡识别等技术实现的一种移动互联网身份认证方法。</p> \n<p>它主要有两个形式，一是“<strong>一键登录</strong>”，一键登录具备授权页面，APP开发者经用户授权后可获得号码，适用于注册、登录等场景；二是“<strong>本机号码校验</strong>”，本机号码校验不返回号码，仅返回待校验号码与本机号码是否一致的结果，适用于基于手机号码的安全风控场景。</p> \n<p>对于用户来说，无论是一键登录还是本机号码校验，都无需经历输入密码或者等待短信验证码的过程，可以真正体验到“秒级验证”的快感。</p> \n<h1>二、一键认证的能力优势</h1> \n<p>传统的验证登录方式，如“手机+验证码”登录，存在登录时间长、短信验证码接收慢等问题。而现在较为普及的第三方帐号登录，表面简化了流程，但多数APP会在用户授权后要求捆绑手机号码，不仅未能缩短用户登录时长，还容易造成“一人多号”的情况。</p> \n<p>区别于以上几种验证方式，一键认证的主要优势在于：</p> \n<ol> \n <li> <strong>简化了注册/登录的流程</strong>，减少了用户的等待时间；</li> \n <li> <strong>避免出现短信验证码收不到或接收慢的问题</strong>，优化用户体验；</li> \n <li> <strong>降低了注册/登录门槛</strong>，用户不必为记忆各种账号和密码而困扰，提升了注册登录率。</li> \n</ol> \n<h1>三、一键认证的实现条件</h1> \n<p>由于运营商的取号能力是通过数据网关实现的，在手机未打开流量或未插入SIM卡的情况下，运营商无法进行取号。</p> \n<p>“一键认证”的基本实现条件如下：</p> \n<ol> \n <li> <strong>需要打开数据网络</strong>，目前支持的网络环境是：移动：2G、3G、4G；联通：3G、4G；电信：4G；</li> \n <li>手机需<strong>插入SIM卡</strong>，且通话和网络的SIM卡必须为同一张卡，否则会导致验证失败；</li> \n <li>对于wifi环境，在数据网络开通的情况下，会使用数据网络触发网关请求，若未开通则无法校验；</li> \n <li> <strong>支持双卡手机</strong>，以开启数据流量的SIM卡进行认证。</li> \n</ol> \n<p>APP可自定义预登录操作（如用户点击“我要登录”、进入个人中心“我的”等）提前判断用户当前网络环境是否支持一键登录，若不支持，可向用户切换其他登录方式。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021911804\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h1>四、个推“一键认证”SDK</h1> \n<p>个推作为深耕移动互联网领域多年的数据智能服务商，在持续打磨开发者服务的道路上从未停歇。个推面向开发者推出的“一键认证”产品——个验，旨在通过专业的技术和服务，帮助开发者简化APP登录流程，有效减少用户流失，大幅度提升用户转化与帐号安全。</p> \n<p>个验不仅整合了三大运营商的网关认证能力，并且兼容iOS和Android智能手机，覆盖了全网用户，大幅提升了用户的验证通过率。此外，个验为用户首次登录APP提供了畅通无阻的通道，帮助用户迅速与APP建立起连接。</p> \n<p>最重要的一点是，个验兼备<strong>反欺诈能力和动画验证码</strong>的功能，可以帮助APP开发者有效识别风险设备、保障业务安全。</p> \n<h2>1. 反欺诈能力</h2> \n<p>依托个推海量的数据沉淀和强大的算法建模能力，个验SDK创建了反欺诈防护体系，并设置了数千个指标、数百个风控规则，旨在帮助APP开发者全面提升大数据风控能力。</p> \n<p>APP开发者可以根据个验构建的反欺诈模型有效识别和评估各种作弊行为和风险设备，针对不同风险等级的设备实施不同的应对和防护措施，实现业务安全和账号安全双保障。</p> \n<h2>2. 动画验证码</h2> \n<p>动画验证码可以有效区分人类和机器，可用于防范短信轰炸、机器秒杀、评论注水、在线刷票等场景。</p> \n<p>目前动画验证码有两种模式：智能无感模式和动画验证模式。前者会智能判定设备风险等级，可信设备无感验证通过，怀疑设备则弹出动画验证码进行校验；而后者对所有设备都会进行动画验证。动画验证码的展现形式丰富，可通过图层叠加、控制播放速度等措施迷惑攻击者，大幅度保障设备的安全性。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021911805\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>对于APP开发者来说，“一键认证”产品免去了诸如短信验证、输入密码等复杂的交互环节的设计过程，是APP增加用户黏性、提高留存的有效工具。更重要的是，基于个推海量数据积累和强大的分析能力，“一键认证”具备了强大的“反欺诈能力”，这为APP识别风险设备、保障业务安全提供了强有力的支撑。</p> \n<p>相信在不久的未来，随着5G的全面普及和大数据的不断加持，这种新型的技术会成为APP稳步健康发展的利器。</p>', 'https://segmentfault.com/img/remote/1460000021911803', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', 'b7460efd3f3b4d6ea78254959a2aebff,8dfc62f227ae4076888ea4872e03cddd,85ee959b27f74072b13cc763b9bbf77e', '0', '3', '1', '2020-04-16 16:50:20', '2020-04-16 16:50:20');
INSERT INTO `tb_recommend` VALUES ('6c498f5c494d4797a7a17a0503ddd1d5', '除了经典怀旧服，还有什么能重新激活《魔兽世界》', '在昨天早上 6：00 开服的那一刻，就涌入了大批前来追忆经典的游戏玩家，甚至在斗鱼等游戏直播平台，仅一个上午，就有近 3000 名魔兽世界的主播，同时直播。', '<blockquote>\n 自 2004 年公测的《魔兽世界》已经经历了 PC 时代、移动时代、VR 时代，在正在来临的 人工智能 时代，这款经典会如何续写。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYNT?w=650&amp;h=437\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span><br>《魔兽世界》经典怀旧服在昨天开服了！</p> \n<p>在昨天早上 6：00 开服的那一刻，就涌入了大批前来追忆经典的游戏玩家，甚至在斗鱼等游戏直播平台，仅一个上午，就有近 3000 名魔兽世界的主播，同时直播。</p> \n<p>《魔兽世界》是否有机会借助当下人工智能之势，找出自己与人工智能结合的道路？</p> \n<h1>永不磨灭的经典：为了部落</h1> \n<p>其实，早在今天的凌晨 5 点 55 分时，客户端显示的排队人数就已经高达了 1 万 8 千人。</p> \n<p>更有些热门服务器，比如「范克里夫」服务器的排队人数高达 2 万 6 千人，也就是需要等待 5 个多小时才有机会进入游戏。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYN2?w=815&amp;h=476\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<blockquote>\n <em>6：00 开服后就十分火爆</em>\n</blockquote> \n<p>《魔兽世界》在 2005 年进入国内之后，一度是网络游戏领域的霸主，在 2008 年年底，在发布了《巫妖王之怒》资料片后不久，暴雪宣布全球用户数量达到 1150 万人。</p> \n<h1>没落的黄金一代</h1> \n<p>在最巅峰的 2011 年，《魔兽世界》全球用户数曾触达 1200 万。此后的几年里，用户数就再难以为继，持续滑落至 900 多万。</p> \n<p>2012 年，在《熊猫人之谜》资料片之后，游戏用户数重回 1000 万大关。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYOh?w=2352&amp;h=804\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<blockquote>\n <em>2015 年第三季度之后，暴雪就再没有公布过《魔兽世界》具体的玩家数量</em>\n</blockquote> \n<p>但此后的几个新的资料片《德拉诺之王》、《军团再临》和《争霸艾泽拉斯》并没能挽回暴雪的颓势。</p> \n<p>《魔兽世界》这些年的辉煌和近年的衰落有目共睹。这一类 MMORPG（大型多人在线）游戏在近几年的发展中，逐渐失去竞争力。</p> \n<p>在全球的游戏市场中，《魔兽世界》前有 DOTA 、LOL 这些经典 MOBA（多人在线战术竞技）游戏的竞争，后有 《绝地求生》、《APEX 英雄》这类生存射击游戏的追赶，更别提移动端游戏 《王者荣耀》、《和平精英》在 90、00 后人群里的绝对优势了。</p> \n<h1>魔兽世界：能靠 AI 创造更好的体验么？</h1> \n<p>其实在《魔兽世界》里，就已经增加入了基于人工智能技术的 NPC。</p> \n<p>一个叫做莫克西·开锁的 NPC 会流窜于联盟的各个主城，去银行偷窃。有玩家曾在伯拉勒斯港银行遇到了这个 NPC。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYO1?w=640&amp;h=377\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<blockquote>\n <em>这个 NPC 会根据环境的情况，选择是否偷窃，还会与周围的玩家进行对话</em>\n</blockquote> \n<p>不仅如此，《魔兽世界》的岛屿探险模式里，还加入的敌对 NPC 。</p> \n<p>这些敌人 NPC 会模仿人类玩家的操作风格：比如 NPC 可以通过玩家行为来判断玩家的目的，从而进行下一步策略：是盗取玩家的背包里的资源，还是打断玩家的治疗进程。</p> \n<h2>游戏环境：是 AI 整体发展的加速器</h2> \n<p>游戏，是完美的 AI 测试平台。游戏有方便处理的数据，固定的规则，多种可假设的策略，游戏也就是模拟场景，它对于人工智能的研发来说是一个非常理想的场所。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYRD?w=1920&amp;h=1080\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<blockquote>\n <em>星际这类 RTS 游戏：背后有着复杂的策略和数据</em>\n</blockquote> \n<p>纽约大学游戏研究中心副教授 Julian Togelius 说，「我们还没有看到很多东西是通过游戏训练，然后再转移到现实世界的。但我们已经看到，为玩游戏而发明的方法，转移到了现实世界。」</p> \n<h2>游戏 AI ：是人类玩家最好的老师和对手</h2> \n<p>一方面，AI 可以帮助发现一些更完美的策略，提高人类玩家竞技技能。柯洁就认为和 AlphaGo 的对战，打开了思路，提高了围棋水平；</p> \n<p>另一方面， AI 的介入，可以为玩家打造更适配的对手，经过调整的 AI，不仅能够成为人类玩家的教练，适配不同玩家的水平与之对战。</p> \n<p>还能够避免如今游戏里的人类玩家动辄相互发飙，如果有一个佛系 AI 在你的对面，一定能维持一个更加文明的游戏环境。</p> \n<p>希望《魔兽世界》能够多多跟上时代的步伐，抓住技术的潮流，创造更好的游戏体验和玩家互动环境，让年轻人也有意愿去体验 80、90 后的共同记忆。</p> \n<p>为了游戏玩家，为了共同的青春记忆，也为了艾泽拉斯。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbwYQG?w=290&amp;h=160\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p>', 'https://segmentfault.com/img/bVbwYNT?w=650&amp;h=437', '692c6787030d4b8882077b2ab9279c52', '2a09bf1afefd4d659606f43445741ee3,a4f4fd7a73b84a7298db0174165eeaac,14b1d605b9c340139163c4f22f384a7f', '0', '3', '1', '2020-04-16 16:57:53', '2020-04-16 16:57:53');
INSERT INTO `tb_recommend` VALUES ('6c63d47c2269428bab45dce243f9f4e1', '我用php构建了魔兽世界服务器,只为证明php是世界上最好的语言', '作为一个魔兽老玩家，最近看着暴雪开了怀旧服，早已寂灭的心又开始躁动不安了，我正式入坑是网易接替九城那会，号称万年TBC, 对于那个时代，用一句话表达就是“我站在暴风城的广场上，听着港口涛声，幻想着诺森德...', '<p>我用php构建了魔兽世界服务器</p> \n<pre><code>--只为证明php是世界上最好的语言\n</code></pre> \n<p>作为一个魔兽老玩家，最近看着暴雪开了怀旧服，早已寂灭的心又开始躁动不安了，我正式入坑是网易接替九城那会，号称万年TBC, 对于那个时代，用一句话表达就是“我站在暴风城的广场上，听着港口涛声，幻想着诺森德天气多么寒冷…”，你懂的~<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRss?w=500&amp;h=300\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"0.jpg\" title=\"0.jpg\"></span><br>那时候刚上大学,对于涉世未深的我来说,魔兽的差点让我变成网瘾少年，直到毕业步入社会，才慢慢淡绝了对魔兽的念想，但无论过去多久，那段在网吧通宵鏖战，跟同学朋友在副本、战场度过无数日子的青春一直烙印在心底深处，无法忘怀！</p> \n<p>好了，废话不多说，开始进入正题<br>———————————————————————————————————————<br>大家都知道，php作为一门脚本语言，对于没什么基础的人来说比较容易上手，但是很难精通，随着互联网的逐步兴起，php也火热起来，在这种需求的催动下，大量人员涌入到php的开发中来，多年之后，一度让人认为php只能写写网站、脚本、接口，随后而来的就是语言鄙视链，写汇编语言的工程师都鄙视写C语言的工，写C语言的工程师都鄙视写C++的， C++工程师鄙视写Java的和写C#的， Java工程师和C#工程师则相互鄙视，然而，所有的工程师都鄙视PHP工程师，于是这句著名的自嘲式的“php是世界上最好的语言”在互联网圈子流传开来~~</p> \n<p>SO, 假定“php是世界上最好的语言”这句话为真，那我们用它来构建一个游戏服务端怎么样？<br>“真的吗？”<br>“可以吗”<br>“真的！”<br>“可以！”</p> \n<p>小打小闹的什么页游啊、棋牌啊直接忽视，来个挑战高的，难度大的！那就魔兽世界吧！ 哈哈哈哈哈哈哈哈哈哈~</p> \n<p>但是写游戏服务端我们要做些什么呢，我也不知道，我也不敢问啊，让别人知道你想用php写魔兽世界服务端，会招来各种花式嘲讽的！<br>于是偷偷的装了抓包工具，偷偷的研究起了魔兽世界游戏的逻辑，得出结论，</p> \n<p>1魔兽世界服务端需要一个用户登录(authserver)服务器用来处理用户登录鉴权，客户端与服务端使用TCP协议,端口号为3724</p> \n<p>2需要一个世界(worldserver)服务器来处理游戏逻辑，包含角色的创建，地图的加载，npc和生物的构建及各种眼花缭乱的物品和技能等等~同样是TCP协议，这里的端口号为8085</p> \n<p><strong>第一步： 用php 构建用户登录服务器-AuthServer</strong><br>我这里采用Swoole扩展(不知道的自行百度)创建了TCP服务监听了本机的3724端口</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRsq?w=1083&amp;h=615\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"1.png\" title=\"1.png\"></span></p> \n<p>用户登录服务器主要的逻辑是： wow客户端发送账户信息给服务端，服务端验证账户并告知客户端鉴权结果，结果中包含世界服务器的地址及端口。</p> \n<p>偷偷说一句，魔兽的客户端在登录的时候只会发送一些基本信息，并不包含明文密码，而是使用SRP认证<br>SRP简化后的原理是：</p> \n<ol> \n <li>服务器不保存密码或密码的散列值，防止字典攻击， 而只是保存验证因子(verifier)</li> \n <li>客户端和服务器可以各自计算出一个会话秘钥(session key)，其值相同 防止窃听</li> \n</ol> \n<p><strong>第二步 构建世界服务器-WorldServer</strong><br>与上面一样，需要绑定本机的8085端口</p> \n<p>小提示: 3724和8085的TCP/UDP已经被暴雪注册了…简单说，暴雪注册了专有的端口号用于专门的战网通信以及魔兽世界的通信。以前大家（数据包）都从一个门（端口）进进出出，现在暴雪大爷有钱了，弄了个专门的门，以后爷走这个门，你们都不许走。牛逼吧!</p> \n<p>魔兽客户端在用户登录服务器鉴权成功后就会连接到世界服务器，首次接入服务端会向客户端发起鉴权数据包，其中带有服务器随机密钥，客户端收到之后根据密钥和sessionkey计算出client_hash，并发送给服务端，服务端使用相同公式计算出server_hash判断是否一致</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtv?w=1233&amp;h=363\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"2.png\" title=\"2.png\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRty?w=1576&amp;h=825\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"3.jpg\" title=\"3.jpg\"></span></p> \n<p>服务端鉴权完成后的所有数据包都将进行加密<br>先使用hash_hmac对sessionkey生成指定的哈希运算规则数据,</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtB?w=731&amp;h=86\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"4.png\" title=\"4.png\"></span></p> \n<p>然后根据数据包的Opcode生成数据包头，然后发送结果给客户端</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtH?w=718&amp;h=597\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"5.png\" title=\"5.png\"></span></p> \n<p>客户端收到鉴权成功结果后，会发送获取角色信息的数据包，服务端进行处理，获取角色信息并发送给客户端</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtJ?w=1233&amp;h=867\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"6.png\" title=\"6.png\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtN?w=1585&amp;h=815\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"7.jpg\" title=\"7.jpg\"></span></p> \n<p>客户端点击进入魔兽世界后，发送CMSG_PLAYER_LOGIN操作码。服务端接收并处理</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRtV?w=840&amp;h=422\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"8.png\" title=\"8.png\"></span></p> \n<p>还挺多的~就不一一详细写了<br>进入魔兽世界后就是这个样子</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRt2?w=1585&amp;h=823\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"9.jpg\" title=\"9.jpg\"></span></p> \n<p>完整运行视频(Swoole创始人韩天峰的微博): <a href=\"https://weibo.com/tv/v/I7Hu7dVxG?fid=1034:4418354417756012\" rel=\"nofollow noreferrer\">https://weibo.com/tv/v/I7Hu7dVxG?fid=1034:4418354417756012</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbyRup?w=754&amp;h=721\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"10.png\" title=\"10.png\"></span></p> \n<p>到此一个简单的魔兽世界服务器就构建完了! 怎么样? 哈哈哈,php是不是世界上最好的语言!</p> \n<p>不过话说回来，我目前做到的也是一些很基础的东西，毕竟魔兽世界那么大，想要一一实现靠一个人或一门语言是不可能的，可以做和不能做完全是两个概念，使用php是比较方便，高效且便捷，但是性能我无法完全保证，不过使用swoole和php7之后，这点就不是我去考虑的了，够用，还可以！</p> \n<p>代码我已经开源，地址是：<a href=\"https://github.com/fan3750060/wpcore\" rel=\"nofollow noreferrer\">https://github.com/fan3750060...</a></p> \n<p>谢谢！来！让我们一起说 ： php是世界上最好的语言!</p>', 'https://segmentfault.com/img/bVbyRss?w=500&amp;h=300', '1c5851dc916d4e70a60f0c957f548876', '9424c753324d4c6198c85fff4f681dd4,6dcac97ec78c41b3a5f265d015ca34f5,6bc7339a27854278b1489eb30425aa1b,6db071127bc8442497d14d9527082793,84e1fca09c4340be87d5c1ef4601b026', '0', '3', '1', '2020-04-16 16:57:52', '2020-04-16 16:57:52');
INSERT INTO `tb_recommend` VALUES ('6c71a057b08f470a9f1b048bc63d2135', 'Dart 学习之开发语言概览，带思维导图', '之前在学习flutter，本以为自己可以轻松上手掌握dart，结果发现经常有不懂的语法。所以决定踏踏实实的学习一遍dart。网上有很多相关学习资料.我主要从官网来学习，然后又找了一个视频来补充学习。', '<p>之前在学习flutter，本以为自己可以轻松上手掌握dart，结果发现经常有不懂的语法。所以决定踏踏实实的学习一遍dart。网上有很多相关学习资料.我主要从官网来学习，然后又找了一个视频来补充学习。</p> \n<p>文章中涉及的代码，可以从我的<a href=\"https://github.com/siberiawolf/dart_study\" rel=\"nofollow noreferrer\">Github</a>上找到。</p> \n<ul> \n <li>第一遍先看中文文档。毕竟母语是汉语，有利于快速了解。大概掌握自己哪里是之前就会的知识，哪里是新知识。这一遍只看，不进行代码编写。</li> \n <li>制作思维导图。在看第一遍的时候，可以用思维导图制作一个清晰的脉络图。也不需要太复杂，只需要将每个大标题、小标题添加上就行。等接下来再去补充。</li> \n <li>第二遍就看英文文档。因为第一遍的时候，对文档已经都有印象了，再看英文文档就会比较容易。主要是为了加强自己的英文阅读的能力，这样看得多了，慢慢也就记得多了。</li> \n <li>第二遍的时候，遇到不会的生单词，或者高频的单词，记下来，扩大自己的词汇量。就算现在记不住，也先混个脸熟。</li> \n <li>第二遍还要进行代码的演练。光看文档的话，我可没有那么强的天赋，能全都理解，毕竟文档只是给出了部分代码示例，或者说是<strong>伪代码</strong>。所以这一遍将文档中所涉及的代码全部进行一遍演练。</li> \n <li>第二遍的时候，还要顺手做两件事情。其中一件就是补充之前做的思维导图，将其完整化。另一件就是，整理一下学习笔记，也就是现在写的这篇笔记。笔记的内容主要记录自己的学习内容即可。</li> \n <li>第三遍，观看视频。这最后一遍，就是查漏补缺，有时候文档里面没有的，在视频中还能涉及不少，及时补充。另外视频最重要的一点，就是有些地方看文档、写代码并没有明白，视频中刚好涉及了，稍微一听，也就明白了。当然了，视频比较长，只要是之前学过了，就可以跳步看。</li> \n</ul> \n<p>其实这样学下来的话，是比较耗时间的，但是我想还是扎实一下基础吧，磨刀不误砍柴工。往往有时候做项目的话，遇到一些细节，就会模棱两可，含糊不清。甚至有时候看到一块代码，并没有接触过，然后去百度、查文档，虽然当时有印象了，但知识并不系统。</p> \n<h1>环境搭建</h1> \n<h3>1. 安装Dart SDK</h3> \n<p>我的电脑是Mac系统，所以需要安装<a href=\"https://brew.sh/\" rel=\"nofollow noreferrer\">Homebrew</a>。这里我遇到的问题是始终下载失败。最后是通过科学上网以后才下载成功。</p> \n<p>接着按照<a href=\"http://www.dartdoc.cn/get-dart\" rel=\"nofollow noreferrer\">官网</a>给出的示例，安装dart。</p> \n<p>最后在终端中输入<code>dart --version</code>显示dart版本号就说明安装成功了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022086546\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"dart安装成功\" title=\"dart安装成功\"></span></p> \n<h3>2. 配置编辑器的Dart插件</h3> \n<p>Dart环境我使用的是VS Code，非常简单，只需要安装Dart的插件即可。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022086547\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li>Code Runner: 是在VS Code中运行Dart插件</li> \n <li>Dart:是核心插件</li> \n</ul> \n<p>编写一个测试文件：<strong>test.dart</strong></p> \n<pre><code class=\"dart\">void main(){\n  // dart类似java，需要一个入口main函数\n  print(\'123\');\n}</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022086549\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>运行结果如上，说明Dart环境已经配置好了。</p> \n<p><strong>注意：</strong></p> \n<ul>\n <li>dart中的文件命名规范是使用下划线分隔符，例如<code>test_hello</code>，而不要使用驼峰命名了。可以去查看官方规范手册。</li>\n</ul> \n<h1>重要概念</h1> \n<ul> \n <li>所有变量引用的都是 对象，每个对象都是一个 类 的实例。数字、函数以及 null 都是对象。所有的类都继承于 Object 类。</li> \n <li>尽管 Dart 是强类型语言，但是在声明变量时指定类型是可选的，因为 Dart 可以进行类型推断。在上述代码中，变量 number 的类型被推断为 int 类型。如果想显式地声明一个不确定的类型，可以使用特殊类型 dynamic。</li> \n <li>Dart 支持泛型，比如 List&lt;int&gt;（表示一组由 int 对象组成的列表）或 List&lt;dynamic&gt;（表示一组由任何类型对象组成的列表）。</li> \n <li>Dart 支持顶级函数（例如 main 方法），同时还支持定义属于类或对象的函数（即 静态 和 实例方法）。你还可以在函数中定义函数（嵌套 或 局部函数）。</li> \n <li>Dart 支持顶级 变量，以及定义属于类或对象的变量（静态和实例变量）。实例变量有时称之为域或属性。</li> \n <li>Dart 没有类似于 Java 那样的 public、protected 和 private 成员访问限定符。如果一个标识符以下划线 (_) 开头则表示该标识符在库内是私有的。可以查阅 库和可见性 获取更多相关信息。</li> \n <li>标识符 可以以字母或者下划线 (_) 开头，其后可跟字符和数字的组合。</li> \n <li>Dart 中 表达式 和 语句 是有区别的，表达式有值而语句没有。比如条件表达式 expression condition ? expr1 : expr2 中含有值 expr1 或 expr2。与 if-else 分支语句相比，if-else 分支语句则没有值。一个语句通常包含一个或多个表达式，但是一个表达式不能只包含一个语句。</li> \n <li>Dart 工具可以显示 警告 和 错误 两种类型的问题。警告表明代码可能有问题但不会阻止其运行。错误分为编译时错误和运行时错误；编译时错误代码无法运行；运行时错误会在代码运行时导致异常。</li> \n</ul> \n<h1>变量</h1> \n<p><strong>变量定义</strong></p> \n<pre><code class=\"dart\">//变量仅存储对象的引用\nvar name = \'Bob\'; \n\n// 未初始化的变量拥有一个默认的初始化值：null。即便数字也是如此，因为在 Dart 中一切皆为对象，数字也不例外。\nint lineCount;\nassert(lineCount == null);\n</code></pre> \n<p><strong>final和const</strong></p> \n<pre><code class=\"dart\">final name = \'Bob\'; // Without a type annotation\nfinal String nickname = \'Bobby\';\n\n// const 关键字不仅仅可以用来定义常量，还可以用来创建 常量值\nvar foo = const [];\nfinal bar = const [];\nconst baz = []; // 相当于 `const []` (Equivalent to `const []`)\n\n// 还可以在变量中使用类型检查\n\n// Valid compile-time constants as of Dart 2.5.\nconst Object i = 3; // Where i is a const Object with an int value...\nconst list = [i as int]; // Use a typecast.\nconst map = {if (i is int) i: \"int\"}; // Use is and collection if.\nconst set = {if (list is List&lt;int&gt;) ...list}; // ...and a spread\n</code></pre> \n<h1>内置类型</h1> \n<h2>Numbers</h2> \n<p>Dart 两种数据类型:<code>int</code>和<code>double</code></p> \n<p>下面是字符串和数字之间转换的方式：</p> \n<pre><code class=\"dart\">// String -&gt; int\nvar one = int.parse(\'1\');\nassert(one == 1);\n\n// String -&gt; double\nvar onePointOne = double.parse(\'1.1\');\nassert(onePointOne == 1.1);\n\n// int -&gt; String\nString oneAsString = 1.toString();\nassert(oneAsString == \'1\');\n\n// double -&gt; String 并且保留了指定的小数\nString piAsString = 3.14159.toStringAsFixed(2);\nassert(piAsString == \'3.14\');</code></pre> \n<h2>Strings</h2> \n<p>使用单引号或双引号定义</p> \n<pre><code class=\"dart\">var s1 = \'Single quotes work well for string literals.\';\nvar s2 = \"Double quotes work just as well.\";\nvar s3 = \'It\\\'s easy to escape the string delimiter.\';\nvar s4 = \"It\'s even easier to use the other delimiter.\";</code></pre> \n<p>字符串拼接可以使用<code>+</code>或者直接挨在一起的方式</p> \n<pre><code class=\"dart\">var s1 = \'String \'\n    \'concatenation\'\n    \" works even over line breaks.\";\n    \nvar s2 = \'The + operator \' + \'works, as well.\';</code></pre> \n<p>可以使用三个单引号或者三个双引号创建多行字符串：</p> \n<pre><code class=\"dart\">var s1 = \'\'\'\n你可以像这样创建多行字符串。\n\'\'\';\n\nvar s2 = \"\"\"这也是一个多行字符串。\"\"\";</code></pre> \n<p>只要是编译时常量都可以作为字符串字面量的插值表达式</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n// These work in a const string.\nconst aConstNum = 0;\nconst aConstBool = true;\nconst aConstString = \'a constant string\';\n\n// These do NOT work in a const string.\nvar aNum = 0;\nvar aBool = true;\nvar aString = \'a string\';\nconst aConstList = [1, 2, 3];\n\nconst validConstString = \'$aConstNum $aConstBool $aConstString\';\nprint(validConstString);\n\n// 非编译时变量，不可以赋值\n// const invalidConstString = \'$aNum $aBool $aString $aConstList\';\n\nvar invalidConstString = \'$aNum $aBool $aString $aConstList\'; // 编译时变量，可以赋值\n\n}</code></pre> \n<p>string常用属性：</p> \n<ul> \n <li>length</li> \n <li>isEmpty</li> \n <li>isNotEmpty</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  String a = \'123\'; \n  print(a.length); // 3\n \n  print(a.isEmpty); // false\n\n  print(a.isNotEmpty);  // true\n}</code></pre> \n<p>string常用属性</p> \n<ul> \n <li>contains</li> \n <li>subString</li> \n <li>startsWith</li> \n <li>endsWith</li> \n <li>indexOf</li> \n <li>lastIndexOf</li> \n <li>toLowerCase</li> \n <li>toUpperCase</li> \n <li>trim</li> \n <li>trimLeft</li> \n <li>trimRight</li> \n <li>split</li> \n <li>replaceXXX</li> \n</ul> \n<h2>Booleans</h2> \n<p>布尔类型只有<code>true</code>和<code>false</code>。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var test;\n\n  // dart中一切皆是对象，所以要显示判断是否为null\n  if(test == null){\n    print(\'test is null\');\n  }\n}</code></pre> \n<h2>List</h2> \n<p>Dart中数组用<code>List</code>对象表示。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 1.可以混合的list\n  var list1 = [1, 2, 3, \'4\'];\n  print(list1);\n\n  // 2.只可以是指定类型的list\n  List&lt;int&gt; list2 = [1, 2, 3];\n  print(list2);\n\n  // 3.用const关键字定义一个编译时数组常量\n  List&lt;int&gt; list3 = const [1, 2, 3];\n  print(list3);\n\n  list3[1] = 4; // 编译时出错，不可以修改\n\n  // 4.通过构造方式创建数组\n\n  List fixedLengthList = new List(3);\n  print(fixedLengthList.length); // 3\n\n}\n</code></pre> \n<p>Dart中数组长度类似JavaScript语法。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var list = [1, 2, 3, 4];\n\n  print(list.length); // true\n\n  print(list[1] == 2);  // true\n\n  list[2] = 4;\n  print(list);  // [1, 2, 4, 4]\n}</code></pre> \n<p>Dart中新增扩展操作符</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var list1 = [1, 2, 3, 4, 5];\n  var nullList;\n  // 使用 ... 扩展list插入到另一个list\n  var list2 = [0, ...list1];\n\n  print(list2); // [0, 1, 2, 3, 4, 5]\n\n  // 使用 ...? 如果nullList为空，则不插入\n  var list3 = [0, ...?nullList];\n\n  print(list3);\n}</code></pre> \n<p>Dart 还可以使用<code>Collection If </code>和<code>Collection for </code>来根据条件创建数组。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n\n  /// 可以根据test条件，动态创建数组\n  var test = true;\n\n  var list = [\n    1, \n    2,\n    3,\n    if(test) 4\n  ];\n\n  print(list);    // [1, 2, 3, 4]\n\n  /// 也可以用循环遍历另一个数组创建一个数组\n  var arrays = [1,2,3,4];\n\n  var location = [\n    \'#0\',\n    for(var i in arrays) \'#$i\'\n  ];\n\n  print(location);    // [#0, #1, #2, #3, #4]\n}</code></pre> \n<p>List常用的操作</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var a = [1, 2, 3];\n  a.add(4);\n  print(a); // [1, 2, 3, 4]\n\n  a.insert(1, 100);\n  print(a);   // [1, 100, 2, 3, 4]\n\n  a.remove(4);\n  print(a);   // [1, 100, 2, 3]\n\n  // 打乱顺序\n  a.shuffle();\n  print(a); // [2, 3, 100, 1]\n\n  print(a.asMap()); // {0: 1, 1: 100, 2: 2, 3: 3}\n\n  // 排序\n  List&lt;String&gt; numbers = [\'two\', \'three\', \'four\'];\n  // Sort from shortest to longest.\n  numbers.sort((a, b) =&gt; a.length.compareTo(b.length));\n  print(numbers);  // [two, four, three]\n  \n  // 截取\n  a.sublist(1);\n  print(a);\n\n  // 可以调用print直接打印，或者自定义其他函数\n  numbers.forEach(print);\n}\n</code></pre> \n<h2>Sets</h2> \n<p>创建sets</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var names = &lt;String&gt;{}; // 类型+{}的形式创建Set。\n  Set&lt;String&gt; names2 = {}; // 声明类型变量的形式创建 Set (This works, too).\n  var names3 = {}; // 这样的形式将创建一个 Map 而不是 Set (Creates a map, not a\n\n  print(names.runtimeType); // _CompactLinkedHashSet&lt;String&gt;\n  print(names3.runtimeType); // _InternalLinkedHashMap&lt;dynamic, dynamic&gt;\n}</code></pre> \n<p><strong>注意：</strong><br>如果忘记在 <code>{}</code> 上注释类型或赋值到一个未声明类型的变量上，那么 Dart 会创建一个类型为 <code>Map&lt;dynamic, dynamic&gt;</code> 的对象。</p> \n<h2>Maps</h2> \n<p>创建Map</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n\n  // 相当于 Map&lt;String, String&gt; test = {}\n  var test = {\n    \'a\': \'1\',\n    \'b\': \'2\',\n    \'c\': \'3\'\n  };\n\n  // 可以不使用关键字New实例化一个对象\n  var gifts = Map();\n  gifts[\'first\'] = \'partridge\';\n  gifts[\'second\'] = \'turtledoves\';\n  gifts[\'fifth\'] = \'golden rings\';\n\n}</code></pre> \n<p>操作Map</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var map = {\'a\': 1, \'b\': 2, \'c\': 3};\n\n  print(map.length); // 3\n\n  print(map.isNotEmpty); // true\n\n  print(map.isEmpty); // false\n\n  print(map.keys); // (a, b, c)\n\n  print(map.values); // (1, 2, 3)\n\n  print(map.containsKey(\'c\')); // true\n\n  print(map.containsValue(4)); // false\n\n  // 移除\n  map.remove(\'a\'); // {b: 2, c: 3}\n  print(map);\n\n  map.forEach((key, value) {\n    print(\'key = $key, value = $value\');\n    // key = b, value = 2\n    // key = c, value = 3\n  });\n}\n</code></pre> \n<h1>运算符</h1> \n<h2>算术运算符</h2> \n<p>以前我没用过取整运算符，这里记一下。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  print(2 + 3 == 5);\n  print(2 - 3 == -1);\n  print(2 * 3 == 6);\n  // 除\n  print(5 / 2 == 2.5); // 结果是一个浮点数\n  // 取整\n  print(5 ~/ 2 == 2); // 结果是一个整数\n  // 取余\n  print(5 % 2 == 1); // 取余\n  \n  print(\'5/2 = ${5 ~/ 2} r ${5 % 2}\' == \'5/2 = 2 r 1\');\n}\n</code></pre> \n<p><strong>自增与自减</strong></p> \n<p>文档中的自增与自减解释很棒。</p> \n<ul> \n <li>++var和--var，先对var变量进行计算，然后再赋值给另一个变量</li> \n <li>var++和var--，先将var变量赋值给另外一个变量，然后再对自身进行操作</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var a, b;\n\n  a = 0;\n  b = ++a; // 在 b 赋值前将 a 增加 1。\n  print(a == b); // 1 == 1  \n\n  a = 0;\n  b = a++; // 在 b 赋值后将 a 增加 1。\n  print(a != b); // 1 != 0, a = 1\n\n  a = 0;\n  b = --a; // 在 b 赋值前将 a 减少 1。\n  print(a == b); // -1 == -1, a = -1\n\n  a = 0;\n  b = a--; // 在 b 赋值后将 a 减少 1。\n  print(a != b); // -1 != 0\n}\n</code></pre> \n<h2>关系运算符</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n\n  \n  print(2 == 2);\n  print(2 != 3);\n  print(3 &gt; 2);\n  print(2 &lt; 3);\n  print(3 &gt;= 3);\n  print(2 &lt;= 3);\n}\n</code></pre> \n<h2>类型判断运算符</h2> \n<p>当且仅当 <code>obj</code> 实现了 <code>T </code>的接口，<code>obj is T</code> 才是 true。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Emp emp = Emp();\n  Person p = Person(\'张三\');\n    \n  print(emp is Person);   // true\n\n}\nclass Person{\n  final _name;\n\n  Person(this._name);\n}\nclass Emp implements Person{\n  // 必须实现\n  get _name =&gt; \'\';\n}\n</code></pre> \n<h2>赋值运算符</h2> \n<ul> \n <li>使用 <code>=</code> 来赋值</li> \n <li> <code>??=</code> 来为值为 null 的变量赋值</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var a;\n  var b;\n\n  a = 1;\n  //  当且仅当 b 为 null 时才赋值\n  b ??= 2;\n\n  print(a); // 1\n  print(b); // 2\n\n\n  var c = 9;\n  c ~/= 2;\n\n  print(c); // 4\n\n}</code></pre> \n<h2>逻辑运算符</h2> \n<p>使用逻辑运算符你可以反转或组合布尔表达式</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var flag = true;\n  const tab = 0;\n\n  if (flag &amp;&amp; (tab == 3 || tab == 0)) {\n    print(\'hello\'); // hello\n  }\n}\n</code></pre> \n<h2>条件表达式</h2> \n<ul> \n <li>如果赋值是根据布尔表达式则考虑使用 <code>?:</code> </li> \n <li>如果赋值是根据判定是否为 null 则考虑使用 <code>??</code> </li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 三目运算符写法 good\n  String playName(String name) =&gt; name != null ? name : \'Tom\';\n\n  // ??写法  best\n  String playName3(String name) =&gt; name ?? \'Tom\';\n\n  // if - else 写法  bad\n  String playName2(String name) {\n    if (name != null) {\n      return name;\n    } else {\n      return \'Tom\';\n    }\n  }\n}\n</code></pre> \n<h2>级联运算符</h2> \n<p>级联运算符<code>（..）</code>可以让你在同一个对象上连续调用多个对象的变量或方法。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 级联运算符严格意义上说并不是一个操作符，而是dart的特殊语法\n  var p = Person()\n  ..name = \'tom\'\n  ..age = 1\n  ..say(); // name = tom, age = 1\n  // 最后直接调用了say方法\n}\n\nclass Person{\n  String name;\n  int age;\n\n  void say(){\n    print(\'name = $name, age = $age\');  \n  }\n}</code></pre> \n<h1>流程控制语句</h1> \n<p>与 JavaScript 不同的是，Dart 的 if 语句中的条件必须是一个布尔值，不能是其它类型</p> \n<h2>if和else</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var bar = false;\n  if (bar ==false){\n    print(\'false\');\n  }else if( bar == true){\n    print(\'true\');\n  }else{\n    print(\'not true or false\');\n  }\n}</code></pre> \n<h2>for 循环</h2> \n<p>Dart在循环中的闭包会自动捕获。下面的例子在JavaScript中就会输出两个2。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n\n  // for 循环中的闭包会自动捕获循环的 索引值 以避免 JavaScript 中一些常见的陷阱\n  var list = [];\n  for(var i =0; i&lt;2; i++){\n    list.add(()=&gt;print(i));\n  }\n  list.forEach((v) =&gt; v());\n}</code></pre> \n<p>不需要数组索引时，使用forEach即可</p> \n<pre><code class=\"dart\">  var prints = [1, 2,3];\n  prints.forEach((v)=&gt;print(v));</code></pre> \n<p>List和Set支持for-in</p> \n<pre><code class=\"dart\">  // List和Set支持for-in\n  var collections = [1, 2, 3, 4];\n  for (var i in collections) {\n    print(\'i = $i\');\n    print(i);\n  }</code></pre> \n<h2>while和do-while</h2> \n<ul> \n <li>while 循环会在执行循环体前先判断条件</li> \n <li>do-while 循环则会先执行一遍循环体 再 判断条件：</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var i = 0;\n  while (true) {\n    ++i;\n    print(i); // 1 2 3\n    if (i == 3) break;\n  }\n  print(\'i = $i\');\n  do {\n    i++;\n    print(i); // 4 5 6\n    if(i == 6)break;\n  } while (true);\n}\n</code></pre> \n<h2>break 和 continue</h2> \n<ul> \n <li>break 跳出循环</li> \n <li>continue 继续循环</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  for(var i = 0; i&lt;3; i++){\n    print(i); // 输出0 1\n    if(i ==1  ){ // 跳出循环\n      break;\n    }\n    print(\'hi 我被执行了\'); // 只输出一次\n  }\n\n  for(var i = 0; i&lt;3; i++){\n    print(i);// 输出 0 1 2\n    if(i ==1  ){ // 继续循环\n      continue;\n    }\n    print(\'hi 我被执行了\'); // 输出2次，第二次被跳过了，循环继续\n  }\n\n  \n\n}</code></pre> \n<h2>switch 和 case</h2> \n<ul> \n <li>Switch 语句在 Dart 中使用 == 来比较整数、字符串或编译时常量，比较的两个对象必须是同一个类型且不能是子类并且没有重写 == 操作符</li> \n <li>每一个非空的 case 子句都必须有一个 break 语句</li> \n <li>当没有 case 语句匹配时，可以使用 default 子句来匹配这种情况</li> \n <li> <code>case</code>如果为空，则采用<code>fall-through</code>形式</li> \n <li> <code>case</code>如果为非空，则采用<code>continue</code>和label标签</li> \n <li>case中的变量为局部变量</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var name = \'annie\';\n  switch (name) {\n    case \'tim\':\n      print(\'tim\');\n      break;\n    case \'peter\':\n      print(\'peter\');\n      break;\n    case \'jack\': // fall-through 形式\n    case \'tom\':\n      print(\'jack and tom\');\n      break;\n    case \'annie\':\n      print(\'annie\');\n      continue ruth; // 继续执行标签为ruth的语句\n\n    ruth:\n    case \'ruth\':\n      print(\'ruth\');\n      break;\n    case \'wilson\':\n      var test = \'test\'; // 局部变量\n      print(test);\n      break;\n  }\n  \n}\n</code></pre> \n<h2>断言</h2> \n<ul> \n <li>在开发环境下，添加断言来打断代码的执行</li> \n <li> <code>assert</code> 是否生效依赖开发工具和使用的框架，在命令行中可以执行<code>dart</code>命令</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var num = 100;\n  // 命令行中执行 dart --enable-asserts 断言.dart \n  // 然后就会报错，后面的所有内容不再执行\n  assert(num &lt; 10);\n\n  // 第二个参数可以指定异常错误信息\n  assert(num &lt; 90,\n    \'异常： ($num) 不小于90\');\n\n    // 如果直接执行 dart 断言.dart 因为是在生产环境，所以不会出现错误\n}</code></pre> \n<h1>函数</h1> \n<h2>函数定义</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n  // 函数最好定义返回值\n  bool isBool(bool flag){\n    var test = false;\n    return test;\n  }\n  \n  // 不写返回值倒是也行\n  isBool2(bool flag){\n    var test = false;\n    return test;\n  }\n\n  // 使用箭头函数\n  isBool3(bool flag) =&gt; flag = false;\n}</code></pre> \n<h2>命名可选参数</h2> \n<p>虽然参数是可选，但是也可以指定某个参数为必传，使用<code>@required</code>。</p> \n<pre><code class=\"dart\">import \'package:meta/meta.dart\';\n\nvoid main(List&lt;String&gt; args) {\n  // 定义一个可选命名参数\n  void saySomething({String name, int age}){\n    print(\'name = $name, age = $age\');\n  }\n\n  // 调用可选命名参数时，不需要写{}\n  saySomething(name: \'tom\', age: 12); // name = tom, age = 12\n  saySomething(name: \'cook\'); // name = cook, age = null\n\n  // time参数必须传递\n  // 使用@required 注解必须导入meta包\n  // 导入meta.dart包，则必须在pubspec.yaml 文件中进行声明\n  void playGame({String name,@required int time}){\n    print(\'name = $name, age = $time\');\n  }\n\n  // 虽然使用了@required 注解，并不会对应用程序报错，而是发出警告\n  playGame(name: \'和平精英\');\n}</code></pre> \n<h2>位置可选参数</h2> \n<p>位置可选参数用 <code>[]</code>表示</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n  void say(String name, int age, [String address]){\n    if(address == null){\n      print(\'name = $name, age = $age\');\n    }else{\n      print(\'name = $name, age = $age, address = $address\');\n    }    \n  }\n  say(\'tom\', 123);  // name = tom, age = 123\n  say(\'tim\', 34, \'北京\');   // name = tim, age = 34, address = 北京\n\n \n}</code></pre> \n<h2>默认值</h2> \n<p>可以使用<code>=</code>给可选参数设置默认值</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  void startEng({bool oil = true, bool state = false}){\n    return print(oil &amp;&amp; state);\n  }\n\n  startEng(); // 默认false\n  startEng(state:true); // true\n  startEng(oil:true,state:true); // true\n\n  // 如果name使用默认值，但是传递 age 呢？\n  String say(String start, String end, [String name = \'jack\', int age]){\n    if(name != null){ // 永远不为null\n      print(\'start = $start, end = $end, name = $name\');\n    }\n    if(age!=null){\n     print(\'start = $start, end = $end, name = $name, age = $age\');\n    }\n  }\n\n  say(\'北京\',\'上海\', \'张三\');\n  say(\'河南\',\'河北\', \'jack\', 22);\n}</code></pre> \n<h2>main函数</h2> \n<ul> \n <li>所有Dart程序都必须有一个入口<code>main</code>函数</li> \n <li>可以在命令行中传递参数</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  print(args);\n\n  // 命令行中没有传递参数时\n  if(args.length == 0)return;\n\n  // 命令行中执行  dart main函数.dart 1 test\n  if(int.parse(args[0]) == 1){\n    print(\'第一个参数为 ${args[0]}\');\n  }\n\n  if(args.length == 2){\n    print(\'参数的个数是 ${args.length}\');\n  }\n}</code></pre> \n<h2>函数作为一级对象</h2> \n<ul> \n <li>将函数作为参数传递给另一个函数</li> \n <li>将函数作为一个变量</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  void say(int num){\n    print(\'hello dart, and num is $num\');\n  }\n\n  List&lt;int&gt; list = const [1,2,3,4];\n\n  // 将函数作为参数传递给另一个函数\n  list.forEach(say);\n\n  // 将函数作为一个变量\n  var printName = (v)=&gt;print(\'you are print $v\');\n  printName(\'jack\');  // you are print jack\n\n  var printName2 = (v){ return print(\'another print name function $v\');};\n  printName2(\'tom\');  // another print name function tom\n}</code></pre> \n<h2>匿名函数</h2> \n<ul> \n <li>匿名函数就是没有函数名称的函数</li> \n <li>函数体只有单行时，可以使用箭头函数</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var list = [1, 2, 3, 4];\n\n  // 匿名函数\n  list.forEach((v) {\n    print(v);\n  });\n  // 箭头函数\n  list.forEach((v) =&gt; print(v));\n\n  List&lt;String&gt; getTime(List list, String times(str)) {\n    List&lt;String&gt; tmp = [];\n    list.forEach((v) {\n      tmp.add(times(v));\n    });\n    return tmp;\n  }\n\n  String times(str) {\n    return str * 3;\n  }\n\n  var list2 = [\'h\', \'e\', \'l\', \'l\', \'o\'];\n  // 这里调用 times 时不需要写()，否则就变成了执行函数了\n  print(getTime(list2, times)); // [hhh, eee, lll, lll, ooo]\n}\n</code></pre> \n<h2>词法作用域</h2> \n<pre><code class=\"dart\">bool topLevel = true;\n\nvoid main() {\n  var insideMain = true;\n\n  void myFunction() {\n    var insideFunction = true;\n\n    // 内部函数可以逐级向上访问外部函数变量\n    void nestedFunction() {\n      var insideNestedFunction = true;\n\n      print(topLevel);\n      print(insideMain);\n      print(insideFunction);\n      print(insideNestedFunction);\n    }\n  }\n\n}</code></pre> \n<h2>闭包</h2> \n<ul> \n <li>函数对象的调用在它原始作用域之外，能够访问在它词法作用域内的变量</li> \n <li>函数可以封闭定义到它作用域内的变量</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 闭包就是一个函数对象\n  // 函数可以封闭它作用域内的变量，即使是函数在外部调用\n  Function sum(int add){ // 注意返回值类型是函数\n    return (i) =&gt; add + i;\n  }\n\n  // 这个1就是add，然后被封闭了起来\n  var sumAll = sum(1); \n\n  print(sumAll(1)); // 2\n\n\n  // 闭包就是在一个函数中返回另一个函数\n  a(){\n\n    var count = 0;\n    void printCount(){\n        print(count ++);\n    }\n    return printCount;\n  }\n\n  var fun = a();\n\n  // 想访问方法中的局部变量时，就使用闭包\n  fun(); // 0\n  fun(); // 1\n}</code></pre> \n<h2>函数相等性测试</h2> \n<ul> \n <li>不同实例的函数之间不相等</li> \n <li>静态方法、顶级函数，都相等</li> \n</ul> \n<pre><code class=\"dart\">void foo() {} // 定义顶层函数 (A top-level function)\n\nclass A {\n  static void bar() {} // 定义静态方法\n  void baz() {} // 定义实例方法\n}\n\nvoid main() {\n  var x;\n\n  // 比较顶层函数是否相等。\n  x = foo;\n  assert(foo == x);\n\n  // 比较静态方法是否相等。\n  x = A.bar;\n  assert(A.bar == x);\n\n  // 比较实例方法是否相等。\n  var v = A(); // A 的实例 #1\n  var w = A(); // A 的实例 #2\n  var y = w;\n  x = w.baz;\n\n  // 这两个闭包引用了相同的实例对象，因此它们相等。\n  assert(y.baz == x);\n\n  // 这两个闭包引用了不同的实例对象，因此它们不相等。\n  assert(v.baz != w.baz);\n}</code></pre> \n<h2>返回值</h2> \n<ul> \n <li>所有函数都有返回值</li> \n <li>如果没有指定就返回null</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 这里没有指定函数返回值\n  // 实际上，如果指定了，编辑器就会报错\n  foo(){}\n\n  var test = foo();\n\n  print(test); // null\n}</code></pre> \n<h1>库和可见性</h1> \n<ul> \n <li>使用<code>import</code>关键字导入</li> \n <li>dart内置库，使用<code>dart:xxxx</code> </li> \n <li>其他库，<code>package:xxxx</code> </li> \n <li>以下划线（_）开头的成员仅在代码库中可见</li> \n <li>每个 Dart 程序都是一个库，即便没有使用关键字 library 指定</li> \n</ul> \n<h2>库前缀</h2> \n<p>如果两个库代码有冲突，可以指定库前缀</p> \n<pre><code class=\"dart\">import \'package:lib1/lib1.dart\';\nimport \'package:lib2/lib2.dart\' as lib2;\n\n// 使用 lib1 的 Element 类。\nElement element1 = Element();\n\n// 使用 lib2 的 Element 类。\nlib2.Element element2 = lib2.Element();</code></pre> \n<h2>导入库的一部分</h2> \n<p>只想使用代码库中的一部分，你可以有选择地导入代码库</p> \n<pre><code class=\"dart\">// 只导入 lib1 中的 foo。(Import only foo).\nimport \'package:lib1/lib1.dart\' show foo;\n\n// 导入 lib2 中除了 foo 外的所有。\nimport \'package:lib2/lib2.dart\' hide foo;</code></pre> \n<h1>注释</h1> \n<h2>单行注释</h2> \n<p>单行注释以 <code>//</code> 开始。所有在 <code>//</code> 和该行结尾之间的内容被编译器忽略。</p> \n<pre><code class=\"dart\">// 单行注释</code></pre> \n<h2>多行注释</h2> \n<ul> \n <li>不会忽略文档注释</li> \n <li>多行注释可以嵌套</li> \n <li>多行注释以 <code>/*</code> 开始，以 <code>*/</code> 结尾。所有在 <code>/*</code> 和 <code>*/</code> 之间的内容被编译器忽略</li> \n</ul> \n<pre><code class=\"dart\">void main() {\n  /*\n   * This is a lot of work. Consider raising chickens.\n\n  Llama larry = Llama();\n  larry.feed();\n  larry.exercise();\n  larry.clean();\n   */\n}</code></pre> \n<h2>文档注释</h2> \n<ul>\n <li>在文档注释中，除非用中括号括起来，否则 Dart 编译器会忽略所有文本。</li>\n</ul> \n<pre><code class=\"dart\">/// A domesticated South American camelid (Lama glama).\n///\n/// Andean cultures have used llamas as meat and pack\n/// animals since pre-Hispanic times.\nclass Llama {\n  String name;\n\n  /// Feeds your llama [Food].\n  ///\n  /// The typical llama eats one bale of hay per week.\n  void feed(Food food) {\n    // ...\n  }\n\n  /// Exercises your llama with an [activity] for\n  /// [timeLimit] minutes.\n  void exercise(Activity activity, int timeLimit) {\n    // ...\n  }\n}</code></pre> \n<p>在生成的文档中，[Food] 会成为一个链接，指向 Food 类的 API 文档。</p> \n<p>也就是说，在生成的文档中[Food]这个标识符就可以显示一个链接。</p> \n<h1>类型定义</h1> \n<ul> \n <li>使用typedef显示保留类型信息</li> \n <li>目前类型定义只能在函数上</li> \n</ul> \n<pre><code class=\"dart\">// 自定义一个类型\ntypedef Compare = int Function(Object a, Object b);\n\n/// 使用类型定义的情况\nclass SortedCollection {\n  Compare compare;  // 自定义类型\n\n  SortedCollection(this.compare);\n}\n\n// 简单的不完整实现。\nint sort(Object a, Object b) =&gt; 0;\n\nvoid main() {\n  SortedCollection coll = SortedCollection(sort);\n  print(coll.compare is Function); // true\n  print(coll.compare is Compare); // true\n}</code></pre> \n<h1>类</h1> \n<h2>声明类</h2> \n<ul> \n <li>使用class声明</li> \n <li>使用new创建一个对象，new可以省略</li> \n <li>所有对象都是一个类的实例</li> \n <li>所有的类都继承自 Object 类</li> \n</ul> \n<h2>使用类成员</h2> \n<ul> \n <li>类的成员包括函数和数据</li> \n <li>使用(.)来访问变量和方法</li> \n <li>使用<code>(?.)</code>避免表达式为null</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Person p = Person();\n  p.name = \'tom\';\n  p.age = 12;\n  print(p.name); // tom\n\n  /// ?. \n  // 因为p2是null，所以无法设置并且打印\n  // 但是使用了?.以后就不会报错了。\n  Person p2;\n  p2?.name = \'jack\';\n  p2?.age = 13;\n  print(p2?.name);  // null\n}\n\nclass Person{\n  String name;\n  int age;\n}</code></pre> \n<h2>使用构造函数</h2> \n<ul> \n <li>使用类名</li> \n <li>使用类名.标识符</li> \n <li>使用identical函数判断两个类的实例是否相等</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 通过 类 创建实例\n  Person p = Person(\'tom\', 12);\n  print(p.name);  // tom\n  print(p.age); // 12\n\n  // 通过 类名.标识符 创建实例\n  Person p2 = Person.fromJson({\'name\': \'jack\', \'age\': 13})  ;\n  print(p2.name); // jack\n  print(p2.age); // 13\n\n  Animal a = const Animal(\'titi\', 2);\n  Animal b  = const Animal(\'titi\', 2);\n  print(a.name);\n  print(a.age);\n\n  print(b.name);\n\n  // 两个实例相等\n  print(identical(a,b));  // true\n\n\n}\n\nclass Person{\n  String name;\n  int age;\n\n  Person(this.name, this.age);\n\n  Person.fromJson(Map&lt;String, dynamic&gt; json){\n    name = json[\'name\'];\n    age = json[\'age\'];\n  }\n}\n\n// 常量构造函数\nclass Animal{\n  final String name;\n  final int age;\n\n  const Animal(this.name, this.age);\n}</code></pre> \n<h2>实例变量</h2> \n<ul> \n <li>所有未初始化的变量均会被设置为null</li> \n <li>所有实例变量均会隐式地声明一个 Getter 方法</li> \n <li>所有 非 final 变量均会隐式声明一个 Setter方法</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Point p = Point();\n  print(p.x); // 调用x的 Getter\n\n  p.y = 1; // 调用y的 Setter\n  print(p.y); // 调用y的 Getter\n}\nclass Point{\n  int x,y;\n}</code></pre> \n<h2>命名式构造函数</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Point p = Point.origin();\n\n  print(p.x); // 0\n  print(p.y); // 1\n}\nclass Point{\n  int x,y;\n  Point(this.x, this.y);\n\n  // 命名式构造函数\n  Point.origin(){\n    x = 0;\n    y = 1;\n  }\n}</code></pre> \n<h2>调用父类非默认构造函数</h2> \n<p>调用顺序</p> \n<ul> \n <li>1.初始化列表</li> \n <li>2.父类的无参数构造函数</li> \n <li>3.当前类的构造函数</li> \n</ul> \n<p>传递给父类构造函数的参数不能使用 this 关键字。</p> \n<p>使用(:)为子类的构造函数指定一个父类的构造函数。</p> \n<pre><code class=\"dart\">class Person {\n  String firstName;\n\n  Person.fromJson(Map data) {\n    print(\'in Person\');\n  }\n}\n\nclass Employee extends Person {.\n  // Person没有默认构造函数\n  // 需要通过 super.fromJson 来显示调用\n  Employee.fromJson(Map data) : super.fromJson(data) {\n    print(\'in Employee\');\n  }\n}\n\nmain() {\n  var emp = new Employee.fromJson({});\n\n  // 打印:\n  // in Person  先执行父类的构造\n  // in Employee\n  if (emp is Person) {  // emp类继承了Person\n    emp.firstName = \'Bob\';\n  }\n  print(emp.firstName); // Bob\n  (emp as Person).firstName = \'Jack\';\n  print(emp.firstName);   // Jack\n}</code></pre> \n<h2>初始化列表</h2> \n<ul> \n <li>在构造函数体执行前初始化变量</li> \n <li>初始化列表用来设置 final 字段是非常好用的</li> \n</ul> \n<pre><code class=\"dart\">class Person {\n  String firstName;\n\n  // 初始化列表 会比 构造函数优先执行\n  Person.fromJson(Map data): firstName = data[\'firstName\'] {\n    print(firstName);\n  }\n}\n\nmain() {\n  Person p = Person.fromJson({ \'firstName\': \'zhangsan\'});\n\n}</code></pre> \n<p>设置final 字段</p> \n<pre><code class=\"dart\">import \'dart:math\';\n\nclass Point {\n  final num x;\n  final num y;\n  final num distanceFromOrigin;\n\n  // 初始化列表设置final属性，非常好用\n  Point(x, y)\n      : x = x,\n        y = y,\n        distanceFromOrigin = sqrt(x * x + y * y);\n}\n\nmain() {\n  var p = new Point(2, 3);\n  print(p.distanceFromOrigin);  // 3.605551275463989\n}</code></pre> \n<h2>重定向构造函数</h2> \n<ul> \n <li>调用自己类中其它的构造函数</li> \n <li>没有函数体</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {}\n\nclass Point {\n  int x, y;\n  Point(this.x, this.y);\n\n  // 重定向构造函数\n  // 在函数中调用另一个构造函数的形式\n  Point.origin(int num) : this(num, 0);\n}\n</code></pre> \n<h2>常量构造函数</h2> \n<ul> \n <li>属性用final定义为常量属性</li> \n <li>构造函数用const定义为常量构造函数</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Point p = const Point(0, 0);\n  Point p2 = const Point(0, 0);\n\n  Point p3 = Point(0, 0);\n\n  // 这两个实例对象是相同的\n  print(identical(p, p2)); // true\n\n  // 如果不使用const声明实例，则不会相等\n  print(identical(p, p3)); // false\n}\n\nclass Point {\n  // 变量必须用final 定义\n  final num x, y;\n  const Point(this.x, this.y); // 构造函数也是常量\n}\n</code></pre> \n<h2>工厂构造函数</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Person p = Person(\'tom\');\n  p.say();    // tom\n\n}\n class Person{\n   String name;\n\n  // 必须static 定义\n  static final Map&lt;String, dynamic&gt; _cach = Map&lt;String, dynamic&gt;();\n\n   factory Person(String name){\n     return _cach.putIfAbsent(name, () =&gt; Person._init(name));\n   } \n\n   Person._init(this.name);\n\n   void say(){\n     print(name);\n   }\n\n }</code></pre> \n<h1>方法</h1> \n<h2>实例方法</h2> \n<p>对象的实例方法可以访问实例变量和<code>this</code> 。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Person p = Person(\'tom\', \'hello title\');\n  p.say();\n}\n\nclass Person{\n  String name;\n  String title;\n\n  Person(this.name, this.title);\n\n  void say(){\n    // 可以访问变量\n    print(\'name is $name\');\n    // 也可以访问this\n    print(this.name);\n  }\n}</code></pre> \n<h2>Getter和Setter</h2> \n<p>你可以使用 get 和 set 关键字为额外的属性添加 Getter 和 Setter 方法</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Point p = Point(1, 2, 3);\n  print(p.point); // 6\n\n  p.point = 0;\n  print(p.point);\n  print(p.z);\n}\n\nclass Point {\n  int x, y, z;\n\n  Point(this.x, this.y, this.z);\n\n  get point =&gt; x + y + z;\n  // TODO： 这里为啥设置point 却返回z的值？\n  set point(int num) =&gt; z = num + x;\n}\n</code></pre> \n<h2>抽象方法</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n}\n// 定义抽象类\nabstract class Person{\n  // 定义抽象方法\n  void doSomething();\n}\n\nclass Zhangsan extends Person{\n  // 实现具体的方法\n  void doSomething(){\n\n  }\n}</code></pre> \n<h2>抽象类</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var me = Me();\n  me.sayHello();\n}\n\nabstract class Person{\n  String name;\n  int age;\n  \n  void sayHello();\n}\n\nclass Me extends Person{\n  void sayHello(){\n    print(\'hello\');\n  }\n}</code></pre> \n<h2>隐式接口</h2> \n<p>一个类可以通过关键字 implements 来实现一个或多个接口并实现每个接口定义的 API。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n\n  print(saySomething(Person(\'张三\')));\n\n  print(saySomething(Man()));\n\n}\n\nString saySomething(Person person) =&gt; person.sayName(\'李四\');\n\nclass Person {\n  String _name;\n\n  Person(this._name);\n\n  String sayName(String name) =&gt; \'$_name，你好。我是$name\';\n}\n\nclass Man implements Person {\n  get _name =&gt; \'谁也不是\';\n\n  set _name(String name) =&gt; \'\'; // 因为存在隐式的setter，所以这个也要定义\n\n  String sayName(String name) =&gt; \'$_name，你好。我是$name\';\n}</code></pre> \n<h2>扩展一个类</h2> \n<ul> \n <li>使用extends来扩展一个类</li> \n <li>使用super来引用一个父类</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Man man = Man();\n  man.sayName();\n}\n\nclass Person{\n\n  void sayName() =&gt; print(\'hello person\');\n}\n\nclass Man extends Person{\n\n  void sayName() =&gt; super.sayName();  // 调用父类方法\n}</code></pre> \n<p><strong>重写类成员</strong></p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Man man = Man();\n  man.sayName();\n}\n\nclass Person{\n\n  void sayName() =&gt; print(\'hello person\');\n}\n\nclass Man extends Person{\n\n  @override\n  void sayName() =&gt; print(\'hello man\'); // 重写实例方法\n}</code></pre> \n<p><strong>重写运算符</strong></p> \n<pre><code class=\"dart\">class Vector {\n  final int x, y;\n\n  Vector(this.x, this.y);\n\n  Vector operator +(Vector v) =&gt; Vector(x + v.x, y + v.y);\n  Vector operator -(Vector v) =&gt; Vector(x - v.x, y - v.y);\n\n  // 运算符 == 和 hashCode 的实现未在这里展示，详情请查看下方说明。\n  // ···\n}\n\nvoid main() {\n  final v = Vector(2, 3);\n  final w = Vector(2, 2);\n\n  assert(v + w == Vector(4, 5));\n  assert(v - w == Vector(0, 1));\n}</code></pre> \n<p><strong>noSuchMethod</strong></p> \n<blockquote>\n 这个地方没有看明白\n</blockquote> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Man man = Man();\n  // man.name;\n  // todo 怎么使用？？\n}\n\nclass Person {\n  void sayName() =&gt; print(\'hello person\');\n}\n\nclass Man extends Person {\n  void sayName() =&gt; super.sayName(); // 调用父类方法\n\n  @override\n  void noSuchMethod(Invocation invocation) {\n    print(\'你尝试使用一个不存在的成员：\' + \'${invocation.memberName}\');\n  }\n}\n</code></pre> \n<h2>枚举</h2> \n<ul> \n <li>使用enmu定义</li> \n <li>每个枚举值都有index</li> \n <li>使用values获取所有枚举</li> \n <li>枚举不能成为子类</li> \n <li>枚举不可以mixin</li> \n <li>不可以实现一个枚举</li> \n <li>不可以显示实例化一个枚举</li> \n</ul> \n<p><strong>使用枚举</strong></p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n  print(Color.blue);  // 获取枚举\n\n  print(Color.red.index);   // 获取枚举下标\n\n  List&lt;Color&gt; colors = Color.values;  // 获取全部枚举\n\n  print(colors[2]);\n\n}\n\nenum Color{ // 定义枚举\n  red, blue, green\n}</code></pre> \n<p><strong>switch枚举</strong></p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var aColor = Color.red;\n  // 如果使用switch 则枚举中的每一个成员都得用case判断\n  // 否则就会发出警告\n  switch (aColor) {\n    case Color.red:\n      print(\'红色\');\n      break;\n    case Color.blue:\n      print(\'蓝色\');\n      break;\n    case Color.green:\n      print(\'绿色\');\n      break;\n  }\n}\n\nenum Color {\n  // 定义枚举\n  red,\n  blue,\n  green\n}\n</code></pre> \n<h2>使用mixin为类添加功能</h2> \n<ul> \n <li>Mixin 是一种在多重继承中复用某个类中代码的方法模式</li> \n <li>使用with关键字</li> \n <li>使用mixin定义</li> \n <li>使用on规定哪个类可以使用</li> \n</ul> \n<p>覆写操作符基本格式：</p> \n<pre><code>返回类型 operator 操作符(参数1，参数2...){\n    实现体...\n    return 返回值\n}</code></pre> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  Musical musical = Musical();\n  musical.doSomethin();\n}\nmixin Person {\n  bool canCook = true;\n  bool canSay = false;\n\n  // mixin 模式不可以定义构造函数\n  // Person();\n\n  void doSomethin() {\n    if (canCook == true) {\n      print(\'可以做饭\');\n    } else if (canSay == true) {\n      print(\'可以说话\');\n    }\n  }\n}\nclass Musical with Person{\n  @override\n  void doSomethin() {\n    // TODO: implement doSomethin\n    super.doSomethin();   // 直接调用父类\n    print(\'我是子类哦\');\n  }\n}\n</code></pre> \n<h2>类变量和方法</h2> \n<p><strong>静态变量</strong></p> \n<ul>\n <li>静态变量在其首次被使用的时候才被初始化</li>\n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  print(Person.name); // test static\n}\nclass Person{\n  static final String name = \'test static\';\n\n}</code></pre> \n<p><strong>静态方法</strong></p> \n<ul> \n <li>对于一些通用或常用的静态方法，应该将其定义为顶级函数而非静态方法</li> \n <li>可以将静态方法作为编译时常量</li> \n</ul> \n<pre><code class=\"dart\">import \'dart:math\';\n\nclass Point {\n  num x, y;\n  Point(this.x, this.y);\n\n  static num distanceBetween(Point a, Point b) {\n    var dx = a.x - b.x;\n    var dy = a.y - b.y;\n    return sqrt(dx * dx + dy * dy);\n  }\n}\n\nvoid main() {\n  var a = Point(2, 2);\n  var b = Point(4, 4);\n  // 对于一些通用或常用的静态方法，应该将其定义为顶级函数而非静态方法。\n  var distance = Point.distanceBetween(a, b);\n  assert(2.8 &lt; distance &amp;&amp; distance &lt; 2.9);\n  print(distance);\n}</code></pre> \n<h1>泛型</h1> \n<h2>为什么使用泛型</h2> \n<ul> \n <li>通常使用一个字母来代表类型参数，比如E、T、S、K 和 V 等等</li> \n <li>适当地指定泛型可以更好地帮助代码生成</li> \n <li>使用泛型可以减少代码重复</li> \n</ul> \n<p><strong>代码错误提示</strong></p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var names = List&lt;String&gt;(); // 声明为字符串数组，一旦不是则报错\n  names.addAll([\'Seth\', \'Kathy\', \'Lars\']);\n  // 提示报错\n  // names.add(42); // Error\n}\n</code></pre> \n<p><strong>减少重复代码</strong><br>使用泛型声明一个类，让不同类型的缓存实现该类做出不同的具体实现。</p> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {}\n\nabstract class Cache&lt;T&gt; {\n  T getByKey(String key);\n  void setByKey(String key, T value);\n}\n\nclass Acache extends Cache&lt;String&gt; {\n  String getByKey(String key) {\n    // 具体实现时指定\n    return \'hello\';\n  }\n\n  void setByKey(String key, String value) {\n    // 具体实现时指定\n    print(11);\n  }\n}\n</code></pre> \n<h2>使用集合字面量</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  List list = &lt;String&gt;[\'1\', \'2\', \'3\'];  // 字符串集合\n  Set set = &lt;String&gt;{\'1\',\'2\',\'3\'}; // 字符串集合\n  Map map = &lt;String, int&gt;{\'age\': 1, \'size\':12}; // Map\n}</code></pre> \n<h2>使用类型参数化的构造函数</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  // 与字面量相对应，也可以通过构造函数的方式使用泛型\n  Map map = Map&lt;String, int&gt;();\n}</code></pre> \n<h2>泛型集合以及他们所包含的类型</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  List list = List&lt;String&gt;();\n  // list.addAll([\'1\',\'2\']); \n  // 如果此时使用addAll则会报错\n  list.add(\'1\');\n  list.add(\'2\');\n  print(list is List&lt;String&gt;); // true\n\n  var names = List&lt;String&gt;();\n  names.addAll([\'小芸\', \'小芳\', \'小民\']);\n  print(names is List&lt;String&gt;); // true\n}</code></pre> \n<h2>限制参数化类型</h2> \n<ul> \n <li>指定参数类型</li> \n <li>不指定参数类型，使用默认类型</li> \n <li>错误参数类型，编译报错</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var someBaseClassFoo = Foo&lt;SomeBaseClass&gt;();\n  var extenderFoo = Foo&lt;Extender&gt;();\n\n  print(someBaseClassFoo.toString()); // \'Foo&lt;SomeBaseClass&gt;\' 的实例\n  print(extenderFoo.toString()); // \'Foo&lt;Extender&gt;\' 的实例\n\n  // 如果不指定泛型，默认是SomeBaseClass\n  var foo = Foo();\n  print(foo);\n  // 将非 SomeBaseClass 的类型作为泛型参数则会导致编译错误\n  // var foo = Foo&lt;Object&gt;(); \n}\n\nclass SomeBaseClass {}\n\n// 这里的T，其实可以随意指定。一般是T、E、S、K等\nclass Foo&lt;T extends SomeBaseClass&gt; {\n  // 具体实现……\n  String toString() =&gt; \"\'Foo&lt;$T&gt;\' 的实例\";\n}\n\nclass Extender extends SomeBaseClass {}\n</code></pre> \n<h2>使用泛型方法</h2> \n<ul> \n <li>函数的返回类型&lt;T&gt;</li> \n <li>参数的类型List&lt;T&gt;</li> \n <li>局部变量的类型&lt;T&gt;</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  var list = List&lt;String&gt;();\n  list.addAll([\'1\',\'2\']);\n\n  var firstValue = first(list);\n  print(firstValue);  // 1\n}\nT first&lt;T&gt;(List&lt;T&gt; ts) {\n  // 处理一些初始化工作或错误检测……\n  T tmp = ts[0];\n  // 处理一些额外的检查……\n  return tmp;\n}</code></pre> \n<h1>异步支持</h1> \n<h2>处理Future</h2> \n<ul> \n <li>使用 async 和 await 的代码是异步的，但是看起来有点像同步代码</li> \n <li>必须在带有 async 关键字的 异步函数 中使用 await</li> \n <li>使用 try、catch 以及 finally 来处理使用 await 导致的异常</li> \n <li>await 表达式的返回值是一个 Future 对象</li> \n <li>Future 对象代表一个“承诺”，await 表达式会阻塞直到需要的对象返回</li> \n</ul> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {}\n// async 与 await同时使用\nFuture checkVersion() async {\n  // 通过 try-catch 捕获异常\n  try {\n    var version = await lookUpVersion();\n  } catch (e) {\n    // 无法找到版本时做出的反应\n  }\n}\n\nvoid lookUpVersion() {}\n</code></pre> \n<h2>异步函数</h2> \n<pre><code class=\"dart\">void main(List&lt;String&gt; args) {\n  \n}\n// 普通函数直接添加async关键字即可\nFuture&lt;String&gt; lookUpVersion() async =&gt; \'1.0.0\';\n\n</code></pre> \n<h2>处理Stream</h2> \n<ul> \n <li>使用async和await for循环</li> \n <li>使用Stream API</li> \n <li>表达式 的类型必须是 Stream</li> \n <li>使用 break 和 return 语句停止接收 Stream 数据，跳出循环</li> \n <li>1.等待直到 Stream 返回一个数据</li> \n <li>2.使用 1 中 Stream 返回的数据执行循环体</li> \n <li>3.重复 1、2 过程直到 Stream 数据返回完毕</li> \n</ul> \n<h1>可调用类</h1> \n<p>通过实现类的 call() 方法，允许使用类似函数调用的方式来使用该类的实例。</p> \n<pre><code class=\"dart\">// WannabeFunction 类定义了一个 call() 函数，函数接受三个字符串参数，函数体将三个字符串拼接，字符串间用空格分割，并在结尾附加了一个感叹号\n\nclass WannabeFunction {\n  String call(String a, String b, String c) =&gt; \'$a $b $c!\';\n}\n\nvar wf = WannabeFunction();\nvar out = wf(\'Hi\', \'there,\', \'gang\');\n\nmain() =&gt; print(out);\n</code></pre> \n<h1>思维导图</h1> \n<p>制作的思维导图，加深学习印象。如有错误欢迎指正。</p> \n<p>原始图片比较大，为了保证打开速度只上传了一张截图。如果需要高清图片可以在我的<a href=\"https://github.com/siberiawolf/dart_study\" rel=\"nofollow noreferrer\">源码</a>文件中找到。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022088868\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"思维导图\" title=\"思维导图\"></span></p> \n<hr> \n<p>参考资料：</p> \n<ul> \n <li><a href=\"https://www.jianshu.com/p/9e5f4c81cc7d\" rel=\"nofollow noreferrer\">Dart语法学习</a></li> \n <li><a href=\"http://www.dartdoc.cn/guides/language/language-tour\" rel=\"nofollow noreferrer\">官方文档中文版</a></li> \n <li><a href=\"https://dart.dev/guides/language/language-tour\" rel=\"nofollow noreferrer\">官网文档英文版</a></li> \n <li><a href=\"http://www.shutongye.com/dartapi/index.html\" rel=\"nofollow noreferrer\">Dart SDK API 中文版</a></li> \n <li><a href=\"https://www.imooc.com/learn/1035\" rel=\"nofollow noreferrer\">Flutter开发第一步-Dart编程语言入门</a></li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022061753\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p>', 'https://segmentfault.com/img/remote/1460000022086546', '1894b118d35d44cb8fe8009529c4154b', '45a9e20bf502451396f25c51ff9f7972,14ab12176ade47da95ba97d7151eb1f9,8dfc62f227ae4076888ea4872e03cddd,85ee959b27f74072b13cc763b9bbf77e,63c4e1e7ec204b43a62065a3ced4c2ce', '0', '3', '1', '2020-04-16 16:50:18', '2020-04-16 16:50:18');
INSERT INTO `tb_recommend` VALUES ('70a4ee3c74b349d291a24e156481d403', '以图搜图系统概述及工程实践（上）', '以图搜图系统概述 以图搜图指的是根据图像内容搜索出相似内容的图像。 构建一个以图搜图系统需要解决两个最关键的问题：首先，提取图像特征；其次，特征数据搜索引擎，即特征数据构建成数据库并提供相似性搜索的...', '<h2>以图搜图系统概述</h2> \n<p>以图搜图指的是根据图像内容搜索出相似内容的图像。</p> \n<p>构建一个以图搜图系统需要解决两个最关键的问题：首先，提取图像特征；其次，特征数据搜索引擎，即特征数据构建成数据库并提供相似性搜索的功能。</p> \n<h2>图像特征表示</h2> \n<p>介绍三种方式。</p> \n<p><strong>图像哈希</strong></p> \n<p>图像通过一系列的变换和处理最终得到的一组哈希值称之为图像的哈希值，而中间的变换和处理过程则称之为哈希算法。</p> \n<p>图像的哈希值是对这张图像的整体抽象表示。</p> \n<p>比如 Average Hash 算法的计算过程：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022380654\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>1.Reduce size : 将原图压缩到 8 x 8 即 64 像素大小，忽略细节。</p> \n<p>2.Reduce color : 灰度处理得到 64 级灰度图像。</p> \n<p>3.Average the colors : 计算 64 级灰度均值。</p> \n<p>4.Compute the bits : 二值化处理，将每个像素与上一步均值比较并分别记为 0 或者 1 。</p> \n<p>5.Construct the hash : 根据上一步结果矩阵构成一个 64 bit 整数，比如按照从左到右、从上到下的顺序。最后得到的就是图像的均值哈希值。</p> \n<p>参考：</p> \n<p><a href=\"http://www.hackerfactor.com/blog/?/archives/432-Looks-Like-It.html\" rel=\"nofollow noreferrer\">http://www.hackerfactor.com/b...</a></p> \n<p>图像哈希算法有很多种，包含但不限于:</p> \n<ul> \n <li>AverageHash: 也叫 Different Hash</li> \n <li>PHash: Perceptual</li> \n <li>MarrHildrethHash: Marr-Hildreth Operator Based Hash</li> \n <li>RadialVarianceHash: Image hash based on Radon transform</li> \n <li>BlockMeanHash: Image hash based on block mean</li> \n <li>ColorMomentHash : Image hash based on color moments</li> \n</ul> \n<p>我们最常见可能就是 PHash。</p> \n<p>图像哈希可以对抗一定程度的水印、压缩、噪声等影响，即通过对比图像哈希值的 Hamming distance （汉明距离）可以判断两幅图像的内容是否相似。</p> \n<p>图像的哈希值是对这张图像的整体抽象表示，局限性也很明显，由于是对图像整体进行的处理，一旦我们对整体性进行了破坏，比如在原图加一个黑边就几乎无法判断相似性了。</p> \n<p><strong>传统特征</strong></p> \n<p>在计算机视觉领域早期，创造了很多经典的特征算法，比如 SIFT</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022380653\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>如上图所示，通过 SIFT 算法提取出来的一系列的特征点。</p> \n<p>一幅图像提取出来的特征点有多个，且每一个特征点都是一个多维的局部向量，为了进行相似性计算，通常需要先将这一系列特征点融合编码为一个全局特征，也就是局部特征向量融合编码为一个全局特征向量（用这个全局特征向量表示一幅图像），融合编码相关的算法包括但不限于:</p> \n<ul> \n <li>BOW</li> \n <li>Fisher vector</li> \n <li>VLAD</li> \n</ul> \n<p><strong>CNN 特征</strong></p> \n<p>人工智能兴起之后，基于 CNN 卷积神经网络提取图像特征越来越主流。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022380655\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>搜索引擎</h2> \n<p>由于将图像转换为了特征向量，因此搜索引擎所要做的就是其实就是向量检索。</p> \n<p>这里直接推荐 Milvus ( <a href=\"https://www.milvus.io/\" rel=\"nofollow noreferrer\">https://www.milvus.io/</a> )，刚开源不久，可以很方便快捷的使用在工程项目上，具体的相关内容直接查阅官方文档即可。</p> \n<h6>推荐阅读</h6> \n<p><a href=\"https://www.upyun.com/tech/article/537/OUT%20%E5%95%A6%EF%BC%81%E4%BD%A0%E7%9A%84%20App%20%E8%BF%98%E4%B8%8D%E6%94%AF%E6%8C%81%E4%B8%80%E9%94%AE%E7%99%BB%E5%BD%95%E5%90%97%EF%BC%9F.html\" rel=\"nofollow noreferrer\">OUT 啦！你的 App 还不支持一键登录吗？</a></p> \n<p><a href=\"https://www.upyun.com/tech/article/523/%E4%BA%8C%E7%8B%97%E5%AD%90%20%E3%80%81%E5%88%9D%E6%81%8B%E5%8F%8AHTTPS.html\" rel=\"nofollow noreferrer\">二狗子 、初恋及HTTPS</a></p>', 'https://segmentfault.com/img/remote/1460000022380654', '61cdf41d1e5e4f229b76f6a042e254b6', 'cc944f24ed5e4383a975481674f255e0,f831bc1c03f94b4b9e49390a3a354a3e,60e459d5028e400894856f94e826804c,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-16 16:55:35', '2020-04-16 16:55:35');
INSERT INTO `tb_recommend` VALUES ('70cb6662b1ef42de884c7679f0949b7b', '谷歌最新开源软件库， 5 行代码构建无限宽度网络集成模型', '近日，谷歌开源了一个用 JAX 编写的软件库 Neural Tangents，这是一个用于高性能机器学习研究的系统，只在帮助同时构建宽度可变的 AI 模型。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFTta\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"google.jpg\" title=\"google.jpg\"></span></p> \n<p>技术编辑：王治治丨发自 思否疗养院 <br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>近日，谷歌开源了一个用 JAX 编写的软件库 Neural Tangents，这是一个用于高性能机器学习研究的系统，只在帮助同时构建宽度可变的 AI 模型。</p> \n<p>最厉害的是，它让数据科学家们只需使用五行代码就可以一次性构建和训练无限宽网络的集成模型。谷歌表示，这可以让人们对模型的行为有“前所未有的 洞察力，并帮助打开机器学习的黑匣子”。</p> \n<hr> \n<p>正如谷歌高级研究科学家 Samuel S. Schoenholz 和研究工程师 Roman Novak 在一篇文章中所解释的那样，使人工智能研究取得进展的关键洞察力之一是，增加模型的宽度会导致更多的行为规律性，并使其更容易理解。</p> \n<p>通过重复实验，所有的神经网络模型都包含以相互连接的层级排列的神经元（数学函数），它们从输入数据中传输信号，并缓慢调整每个连接的突触强度（权重）。这就是它们如何提取特征并学习进行预测的方式。</p> \n<p>而允许无限宽的机器学习模型倾向于收敛到另一类更简单的模型，称为高斯过程。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFTs8\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"v2-8b87de6a30a238328d74a69d20d6f050_1200x500.jpg\" title=\"v2-8b87de6a30a238328d74a69d20d6f050_1200x500.jpg\"></span></p> \n<p>在这个极限中，复杂的现象归结为简单的线性代数方程，可以作为研究人工智能的透镜。但是，推导出无限宽极限的有限模型需要数学专业知识，必须针对每个架构分别求出。而且，一旦推导出无限宽模型后，要想出一个高效、可扩展的实现，需要工程上的熟练程度，可能需要几个月的时间。</p> \n<p>此次谷歌开源的软件库 Neural Tangents，则可以大幅降低操作难度和时间，让数据科学家们只需使用 5 行代码就可以一次性的构建和训练无限宽度网络的集成模型。并且根据谷歌工作人员表示，所构建的模型基本可以应用于任何的常模模型问题。</p> \n<p>\"我们看到，模仿有限神经网络、无限宽网络的性能遵循类似的层次结构，全连接网络的性能比卷积网络差，而卷积网络的性能又比宽残差网络差，\"研究人员写道。\"然而，与常规训练不同的是，这些模型的学习动态是完全可牵引的闭合形式，这使得人们可以对其行为有新的洞察力。\"</p> \n<hr> \n<p>GitHub 地址：<br><a href=\"https://github.com/google/neural-tangents\" rel=\"nofollow noreferrer\">https://github.com/google/neu...</a></p> \n<p>Google Colaboratory 笔记：<br><a href=\"https://colab.research.google.com/github/google/neural-tangents/blob/master/notebooks/neural_tangents_cookbook.ipynb\" rel=\"nofollow noreferrer\">https://colab.research.google...</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFyLB\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFTta', '3f69fcc9b13843d1910b3dac597f5215', '6224a68b52f54990a07d51854b320f32,efd45535a5504d5595fba4d1dbbc489c,603c056cdb7840da9242d2c0844d5c0f,674b70b62fa24c7ca9a671f8e54b8d15', '0', '3', '1', '2020-04-16 16:55:40', '2020-04-16 16:55:40');
INSERT INTO `tb_recommend` VALUES ('7831f1b99cfb4abba895e12b97a2b811', 'Apache Doris在美团外卖数仓中的应用实践', '美团外卖数据仓库技术团队负责支撑日常业务运营及分析师的日常分析，由于外卖业务特点带来的数据生产成本较高和查询效率偏低的问题，他们通过引入Apache Doris引擎优化生产方案，实现了低成本生产与高效查询的平...', '<h2>序言</h2> \n<p>美团外卖数据仓库技术团队负责支撑日常业务运营及分析师的日常分析，由于外卖业务特点带来的数据生产成本较高和查询效率偏低的问题，他们通过引入Apache Doris引擎优化生产方案，实现了低成本生产与高效查询的平衡。并以此分析不同业务场景下，基于Kylin的MOLAP模式与基于Doris引擎的ROLAP模式的适用性问题。希望能对大家有所启发或者帮助。</p> \n<p>本文侧重于以Doris引擎为“发动机”的数仓生产架构的改进与思考。在开源的大环境下，各种数据引擎百花齐放，但由于业务的复杂性与多样性，目前并没有哪个引擎能够适配所有业务场景，因此希望通过我们的业务实践与思考为大家提供一些经验参考。美团外卖数仓技术团队致力于将数据应用效率最大化，同时兼顾研发、生产与运维成本的最小化，建设持续进步的数仓能力，也欢迎大家多给我们提出建议。</p> \n<h2>数仓交互层引擎的应用现状</h2> \n<p>目前，互联网业务规模变得越来越大，不论是业务生产系统还是日志系统，基本上都是基于Hadoop/Spark分布式大数据技术生态来构建数据仓库，然后对数据进行适当的分层、加工、管理。而在数据应用交互层面，由于时效性的要求，数据最终的展现查询还是需要通过DBMS（MySQL）、MOLAP（Kylin）引擎来进行支撑。如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345427\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>汇总数据的交互</h2> \n<p>业务团队日常经营分析最典型的场景就是各种维度下的自定义查询，面对如此灵活可变、所见即所得的应用场景，美团平台使用Kylin作为公司的主要MOLAP引擎。MOLAP是预计算生产，在增量业务，预设维度分析场景下表现良好，但在变化维的场景下生产成本巨大。例如，如果使用最新商家类型回溯商家近三个月的表现，需要重新计算三个月的Cube，需花费几个小时，来计算近TB的历史数据。另外，应对非预设维度分析，MOLAP模型需要重新进行适配计算，也需要一定的迭代工作。</p> \n<p><strong>明细数据的交互</strong></p> \n<p>业务分析除了宏观数据之外，对明细数据查询也是一种刚需。通常大家会选择MySQL等关系型DB作为明细数据的快速检索查询，但当业务成长较快时，很快就会遇到性能瓶颈，并且运维成本也很高。例如，大数据量的同步、新增字段、历史数据更新等操作，它们的维护成本都非常高。</p> \n<p><strong>外卖运营业务特点</strong></p> \n<p>美团的使命是“帮大家吃得更好，生活更好”。外卖业务为大家提供送餐服务，连接商家与用户，这是一个劳动密集型的业务，外卖业务有上万人的运营团队来服务全国几百万的商家，并以“商圈”为单元，服务于“商圈”内的商家。“商圈”是一个组织机构维度中的最小层级，源于外卖组织的特点，“商圈”及其上层组织机构是一个变化维度，当“商圈”边界发生变化时，就导致在往常日增量的业务生产方式中，历史数据的回溯失去了参考意义。在所有展现组织机构数据的业务场景中，组织机构的变化是一个绕不开的技术问题。此外，商家品类、类型等其它维度也存在变化维的问题。如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345426\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>数据生产面临的挑战</h2> \n<p>数据爆炸，每日使用最新维度对历史数据进行回溯计算。在Kylin的MOLAP模式下存在如下问题：</p> \n<ul> \n <li>历史数据每日刷新，失去了增量的意义。</li> \n <li>每日回溯历史数据量大，10亿+的历史数据回溯。</li> \n <li>数据计算耗时3小时+，存储1TB+，消耗大量计算存储资源，同时严重影响SLA的稳定性。</li> \n <li>预计算的大量历史数据实际使用率低下，实际工作中对历史的回溯80%集中在近1个月左右，但为了应对所有需求场景，业务要求计算近半年以上的历史。</li> \n <li>不支持明细数据的查询。</li> \n</ul> \n<h2>解决方案：引入MPP引擎，数据现用现算</h2> \n<p>既然变化维的历史数据预计算成本巨大，最好的办法就是现用现算，但现用现算需要强大的并行计算能力。OLAP的实现有MOLAP、ROLAP、HOLAP三种形式，MOLAP以Cube为表现形式，但计算与管理成本较高。ROLAP需要强大的关系型DB引擎支撑。长期以来，由于传统关系型DBMS的数据处理能力有限，所以ROLAP模式受到很大的局限性。随着分布式、并行化技术成熟应用，MPP引擎逐渐表现出强大的高吞吐、低时延计算能力，号称“亿级秒开”的引擎不在少数，ROLAP模式可以得到更好的延伸。单从业务实际应用考虑，性能在千万量级关联查询现场计算秒开的情况下，已经可以覆盖到很多应用场景，具备应用的可能性。例如：日数据量的ROLAP现场计算，周、月趋势的计算，以及明细数据的浏览都可以较好的应对。</p> \n<p>下图是MOLAP模式与ROLAP模式下应用方案的比较：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345425\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>MOLAP模式的劣势</strong></p> \n<ol> \n <li>应用层模型复杂，根据业务需要以及Kylin生产需要，还要做较多模型预处理。这样在不同的业务场景中，模型的利用率也比较低。</li> \n <li>Kylin配置过程繁琐，需要配置模型设计，并配合适当的“剪枝”策略，以实现计算成本与查询效率的平衡。</li> \n <li>由于MOLAP不支持明细数据的查询，在“汇总+明细”的应用场景中，明细数据需要同步到DBMS引擎来响应交互，增加了生产的运维成本。</li> \n <li>较多的预处理伴随着较高的生产成本。</li> \n</ol> \n<p><strong>ROLAP模式的优势</strong></p> \n<ol> \n <li>应用层模型设计简化，将数据固定在一个稳定的数据粒度即可。比如商家粒度的星形模型，同时复用率也比较高。</li> \n <li>App层的业务表达可以通过视图进行封装，减少了数据冗余，同时提高了应用的灵活性，降低了运维成本。</li> \n <li>同时支持“汇总+明细”。</li> \n <li>模型轻量标准化，极大的降低了生产成本。</li> \n</ol> \n<p>综上所述，在变化维、非预设维、细粒度统计的应用场景下，使用MPP引擎驱动的ROLAP模式，可以简化模型设计，减少预计算的代价，并通过强大的实时计算能力，可以支撑良好的实时交互体验。</p> \n<h2>双引擎下的应用场景适配问题</h2> \n<p>架构上通过MOLAP+ROLAP双引擎模式来适配不同应用场景，如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345422\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>技术权衡</strong></p> \n<p><strong>MOLAP</strong>：通过预计算，提供稳定的切片数据，实现多次查询一次计算，减轻了查询时的计算压力，保证了查询的稳定性，是“空间换时间”的最佳路径。实现了基于Bitmap的去重算法，支持在不同维度下去重指标的实时统计，效率较高。<br><strong>ROLAP</strong>：基于实时的大规模并行计算，对集群的要求较高。MPP引擎的核心是通过将数据分散，以实现CPU、IO、内存资源的分布，来提升并行计算能力。在当前数据存储以磁盘为主的情况下，数据Scan需要的较大的磁盘IO，以及并行导致的高CPU，仍然是资源的短板。因此，高频的大规模汇总统计，并发能力将面临较大挑战，这取决于集群硬件方面的并行计算能力。传统去重算法需要大量计算资源，实时的大规模去重指标对CPU、内存都是一个巨大挑战。目前Doris最新版本已经支持Bitmap算法，配合预计算可以很好地解决去重应用场景。</p> \n<p><strong>业务模型适配</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345423\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>MOLAP</strong>： 当业务分析维度相对固化，并在可以使用历史状态时，按照时间进行增量生产，加工成本呈线性增长状态，数据加工到更粗的粒度（如组织单元），减少结果数据量，提高交互效率。如上图所示，由A模型预计算到B模型，使用Kylin是一个不错的选择。</p> \n<p><strong>ROLAP</strong>： 当业务分析维度灵活多变或者特定到最新的状态时（如上图A模型中，始终使用最新的商家组织归属查看历史），预计算回溯历史数据成本巨大。在这种场景下，将数据稳定在商家的粒度，通过现场计算进行历史数据的回溯分析，实现现用现算，可以节省掉预计算的巨大成本，并带来较大的应用灵活性。这种情况下适合MPP引擎支撑下的ROLAP生产模式。</p> \n<h2>MPP引擎的选型</h2> \n<p>目前开源的比较受关注的OLAP引擎很多，比如Greenplum、Apache Impala、Presto、Doris、ClickHouse、Druid、TiDB等等，但缺乏实践案例的介绍，所以我们也没有太多的经验可以借鉴。于是，我们就结合自身业务的需求，从引擎建设成本出发，并立足于公司技术生态融合、集成、易用性等维度进行综合考虑，作为选型依据，最终我们平台部门选择了2018年刚进入Apache社区的Doris。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345424\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>Doris简介及特点</h2> \n<p>Doris是基于MPP架构的OLAP引擎，主要整合了Google Mesa（数据模型）、Apache Impala（MPP Query Engine）和Apache ORCFile （存储格式，编码和压缩）的技术。</p> \n<p>Doris的系统架构如下，主要分为FE和BE两个组件，FE主要负责查询的解析、编译、优化、调度和元数据管理；BE主要负责查询的执行和数据存储。关于Doris的更多技术细节，可参考其<a href=\"http://doris.apache.org/documentation/cn/internal/metadata-design.html\" rel=\"nofollow noreferrer\">官方文档</a>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345428\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"整体架构\" title=\"整体架构\"></span></p> \n<p><strong>Doris的特点：</strong></p> \n<ul> \n <li>同时支持高并发点查询和高吞吐的Ad-hoc查询。</li> \n <li>同时支持离线批量导入和实时数据导入。</li> \n <li>同时支持明细和聚合查询。</li> \n <li>兼容MySQL协议和标准SQL。</li> \n <li>支持Rollup Table和Rollup Table的智能查询路由。</li> \n <li>支持较好的多表Join策略和灵活的表达式查询。</li> \n <li>支持Schema在线变更。</li> \n <li>支持Range和Hash二级分区。</li> \n</ul> \n<h2>Doris在外卖数仓中的应用效率</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345435\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>上图是我们在一个分析项目改造中的评估项目收益，整体在查询效率不变的情况下，生产耗能及存储成本都有较大收益。</p> \n<p>以20台BE+3FE的Doris环境，效率、性能表现情况如下：</p> \n<ul> \n <li>支撑数据分析产品数十个以上，整体响应达到ms级。</li> \n <li>支持百万、千万级大表关联查询，同时进行维表关联的雪花模型，经过Colocate Join特性优化，可以实现秒级响应。</li> \n <li>日级别，基于商家明细现场计算，同时满足汇总及下钻明细查询，查询时效基本都可以控制在秒级。</li> \n <li>7日趋势分析，2~3秒。由于数据量较大，根据集群规模不同查询性能有所区别，但数据量较大时，调动的集群资源较多，因此MPP的并发性能受限于集群的性能。一般原则是并发较高的业务，需要严格控制查询时效（基本在毫秒级），对于并发不高的业务，允许进行较大的查询，但也要考虑集群的承受能力。</li> \n <li>通过一年来的应用以及Doris的不断改进升级，Doris的高可靠、高可用、高可扩展性也得到进一步验证，服务稳定可靠。</li> \n</ul> \n<h2>准实时场景下的应用</h2> \n<p>离线业务分析大多基于T+1的离线数据，但在营销活动场景下，外卖团队往往需要当日的实时数据进行业务变化的监控与分析，通常情况下会采用实时流计算来实现。</p> \n<p>外卖实时业务监控有如下特点：</p> \n<ul> \n <li>避免分钟级的生产波动影响，业务上10、15分钟准实时数据可以满足分析需要。</li> \n <li>实时数据需要与离线数据进行日环比与周同比的比对。</li> \n <li>订单业务需要事件时间，体验业务需要生产时间，业务对齐逻辑复杂。</li> \n <li>不同业务线需求差异大，指标需要良好扩展性。</li> \n</ul> \n<p>由于业务上的复杂性，实时流计算中，需要考虑诸多业务口径的对齐，业务ER模型在合流处理中开发成本较高，资源占用较大，通过设计基于Doris的准实时生产数仓，可以灵活地实现业务微批处理，且开发生产成本都比较低。以下为基于Doris的准实时数仓架构设计，是典型的实时Lambda生产架构：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345437\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>实现准实时计算方案，需要以下能力的支撑：</strong></p> \n<p><strong>实时的写入能力</strong>：目前支持Kafka To Doris秒级延迟。在可靠性、稳定性建设方面仍需进一步提升。<br><strong>引擎建设</strong>：短平快的计算+高效的存储性能。目前Doris引擎性能仍有进步空间，2020年将有较大改进提升，随着后续Page Cache，内存表等能力的上线，IO将不再拖后腿，并发能力将有较大提升。<br><strong>可靠的调度能力</strong>：提供5、10、15、30分钟的调度保障能力。<br><strong>Lambda架构简化</strong>：实时数据与离线数据更好的在Doris中进行融合，灵活支撑应用。<br><strong>高效的OLAP交互</strong>：支撑业务的灵活查询访问，业务层通过视图进行逻辑封装直接复用汇总层多维模型，提高了开发效率，减少了运维成本。</p> \n<p>相比Storm、Flink中的窗口计算，准实时DB微批的优势：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345429\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>Doris引擎在美团的重要改进</h2> \n<p><strong>Join 谓词下推的传递性优化</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345430\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>如上图所示，对于下面的 SQL：</p> \n<pre><code>select * from t1 join t2 on t1.id = t2.id where t1.id = 1</code></pre> \n<p>Doris开源版本默认会对t2表进行全表Scan，这样会导致上面的查询超时，进而导致外卖业务在Doris上的第一批应用无法上线。</p> \n<p>于是我们在Doris中实现了第一个优化：Join谓词下推的传递性优化（MySQL和TiDB中称之为Constant Propagation）。Join谓词下推的传递性优化是指：基于谓词t1.id = t2.id和t1.id = 1, 我们可以推断出新的谓词t2.id = 1，并将谓词t2.id = 1下推到t2的Scan节点。 这样假如t2表有数百个分区的话，查询性能就会有数十倍甚至上百倍的提升，因为t2表参与Scan和Join的数据量会显著减少。</p> \n<p><strong>查询执行多实例并发优化</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345431\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>如上图所示，Doris默认在每个节点上为每个算子只会生成1个执行实例。这样的话，如果数据量很大，每个执行实例的算子就需要处理大量的数据，而且无法充分利用集群的CPU、IO、内存等资源。</p> \n<p>一个比较容易想到的优化手段是，我们可以在每个节点上为每个算子生成多个执行实例。这样每个算子只需要处理少量数据，而且多个执行实例可以并行执行。</p> \n<p>下图是并发度设置为5的优化效果，可以看到对于多种类型的查询，会有3到5倍的查询性能提升：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345438\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>Colocate Join</strong></p> \n<p>Colocate Join（Local Join）是和Shuffle Join、Broadcast Join相对的概念，即将两表的数据提前按照Join Key Shard，这样在Join执行时就没有数据网络传输的开销，两表可以直接在本地进行Join。</p> \n<p><strong>整个Colocate Join在Doris中实现的关键点如下：</strong></p> \n<ul> \n <li>数据导入时保证数据本地性。</li> \n <li>查询调度时保证数据本地性。</li> \n <li>数据Balance后保证数据本地性。</li> \n <li>查询Plan的修改。</li> \n <li>Colocate Table元数据的持久化和一致性。</li> \n <li>Hash Join的粒度从Server粒度变为Bucket粒度。</li> \n <li>Colocate Join的条件判定。</li> \n</ul> \n<p>关于Doris Colocate Join的更多实现细节，可以参考《Apache Doris Colocate Join 原理与实践》。</p> \n<p>对于下面的SQL，Doris Colocate Join和Shuffle Join在不同数据量下的性能对比如下：</p> \n<pre><code>select count(*) FROM A t1 INNER JOIN [shuffle] B t5    ON ((t1.dt = t5.dt) AND (t1.id = t5.id)) INNER JOIN [shuffle] C t6    ON ((t1.dt = t6.dt) AND (t1.id = t6.id)) where t1.dt in (xxx days);</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345433\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>Bitmap 精确去重</strong></p> \n<p>Doris之前实现精确去重的方式是现场计算的，实现方法和Spark、MapReduce类似：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345434\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>对于上图计算PV的SQL，Doris在计算时，会按照下图的方式进行计算，先根据page列和user_id列group by，最后再Count：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345436\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图中是6行数据在2个BE节点上计算的示意图\" title=\"图中是6行数据在2个BE节点上计算的示意图\"></span></p> \n<p>显然，上面的计算方式，当数据量越来越大，到几十亿几百亿时，使用的IO资源、CPU资源、内存资源、网络资源会变得越来越多，查询也会变得越来越慢。</p> \n<p>于是我们在Doris中新增了一种Bitmap聚合指标，数据导入时，相同维度列的数据会使用Bitmap聚合。有了Bitmap后，Doris中计算精确去重的方式如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022345432\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>可以看到，当使用Bitmap之后，之前的PV计算过程会大幅简化，现场查询时的 IO、CPU、内存，网络资源也会显著减少，并且不再会随着数据规模而线性增加。</p> \n<h2>总结与思考</h2> \n<p>在外卖运营分析的业务实践中，由于业务的复杂及应用场景的不同，没有哪一种数据生产方案能够解决所有业务问题。数据库引擎技术的发展，为我们提供更多手段提升数据建设方案。实践证明，以Doris引擎为驱动的ROLAP模式可以较好地处理汇总与明细、变化维的历史回溯、非预设维的灵活应用、准实时的批处理等场景。而以Kylin为基础的MOLAP模式在处理增量业务分析，固化维度场景，通过预计算以空间换时间方面依然重要。</p> \n<p>业务方面，通过外卖数仓Doris的成功实践以及跨BG的交流，美团已经有更多的团队了解并尝试使用Doris方案。而且在平台同学的共同努力下，引擎性能还有较大提升空间，相信以Doris引擎为驱动的ROLAP模式会为美团的业务团队带来更大的收益。从目前实践效果看，其完全有替代Kylin、Druid、ES等引擎的趋势。</p> \n<p>目前，数据库技术进步飞速，近期柏睿数据发布全内存分布式数据库RapidsDB v4.0支持TB级毫秒响应（处理千亿数据可实现毫秒级响应）。可以预见，数据库技术的进步将大大改善数仓的分层管理与应用支撑效率，业务将变得“定义即可见”，也将极大地提升数据的价值。</p> \n<h2>参考资料</h2> \n<ul> \n <li><a href=\"https://github.com/apache/incubator-doris\" rel=\"nofollow noreferrer\">Doris文档和源码</a></li> \n <li><a href=\"https://blog.bcmeng.com/post/apache-kylin-vs-baidu-palo.html\" rel=\"nofollow noreferrer\">Apache Kylin VS Apache Doris</a></li> \n</ul> \n<h2>作者简介</h2> \n<ul> \n <li>朱良，美团外卖数据仓库工程师。</li> \n <li>凯森，美团大数据工程师，Apache Kylin Committer。</li> \n</ul> \n<h2>招聘信息</h2> \n<p>美团外卖数据智能组长期招聘数据仓库、数据挖掘、机器学习、计算机视觉、搜索推荐算法工程师，坐标北京。欢迎感兴趣的同学发送阅历到：tech@metuan.com（邮件标题注明：外卖数据智能组）</p> \n<p><strong>阅读更多技术文章，请扫码关注微信公众号-美团技术团队！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021702131\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p>', 'https://segmentfault.com/img/remote/1460000022345427', '692c6787030d4b8882077b2ab9279c52', 'f3eb17e6e5664a97af3e9b1fca12b286,d986ab02dd4345098381ef8b01db7e4d,d1d122dcdca34dceaad794efaef79d56', '0', '3', '1', '2020-04-16 16:59:29', '2020-04-16 16:59:29');
INSERT INTO `tb_recommend` VALUES ('7a90f041e17644479234ed30f395f9e0', '「开位」你所应该知道的HTTP——优化篇', '这是本系列的终章，主要讲解有关HTTP在实践中的优化方案。采用遇到问题、分析问题、解决问题的思路进行叙述。无特别说明均基于HTTP/1.x（简称H1）进行讨论，后面也会提到HTTP/2.0（简称H2）相关的反模式。', '<h2>前言</h2> \n<p>这是本系列的终章，主要讲解有关HTTP在实践中的优化方案。采用遇到问题、分析问题、解决问题的思路进行叙述。<br>无特别说明均基于HTTP/1.x（简称H1）进行讨论，后面也会提到HTTP/2.0（简称H2）相关的反模式。</p> \n<p>《你所应该知道的HTTP》系列的其他篇章：</p> \n<ul> \n <li><a href=\"https://segmentfault.com/a/1190000022295229\">基础篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022322405\">进阶篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022336086\">缓存篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022362157\">HTTPS篇</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022374136\">拓展篇</a></li> \n</ul> \n<h2>握手延迟</h2> \n<p>握手延迟是指开始HTTP通信之前所花费的时间，这里的影响因素是很多的。<br>握手延迟主要来自三方面：DNS查询、TCP三次握手和TLS四次握手。<br>DNS查询也叫域名解析，是域名转换到IP地址的过程，现在基本上都是使用域名进行URI的表示，因此DNS查询是必须的步骤。<br>HTTP是基于TCP的协议，因此TCP的三次握手也是不可避免的步骤。<br>TLS四次握手的优化已经在HTTPS篇讲过，故此处不再重复。<br>我们优化的目标就是要尽量降低握手延迟，可用方案如下：</p> \n<h3>DNS查询优化</h3> \n<ul> \n <li>限制不同域名的数量：<br>每一个域名，就意味着可能需要一次DNS查询，减少域名数量自然有助于减少查询次数。</li> \n <li>使用最近的DNS服务器：<br>将物理距离的影响尽量降低，可以优化DNS服务的建设部署或购买靠谱的第三方服务。</li> \n <li>在主体页面HTML中使用DNS预取指令：<br>DNS-Prefetching是让具有此属性的域名不需要用户点击链接就在后台解析，待用户真的点击链接，就可以少去DNS查询的步骤，从而提高用户体验。</li> \n</ul> \n<p>形如：</p> \n<pre><code>&lt;link rel=\"dns-prefetch\" href=\"//ajax.googleapis.com\"&gt;</code></pre> \n<h3>优化TCP连接</h3> \n<ul> \n <li>借助CDN网络尽早响应：<br>将物理距离的影响尽量降低，可以自行建设部署CDN网络或购买靠谱的第三方服务。</li> \n <li>使用connection:keep-alive：<br>这样能一定程度复用TCP，减少TCP连接的建立。</li> \n <li>在主体页面HTML中使用preconnect指令：<br>向浏览器提供提示，建议浏览器提前打开与链接网站的连接，以便在跟随链接时可以更快地获取链接内容。但不可滥用，同样会占用浏览器的连接数。</li> \n</ul> \n<p>形如：</p> \n<pre><code>&lt;link rel=\"preconnect\" href=\"//font.example.com\" crossorigin&gt;</code></pre> \n<h3>避免重定向</h3> \n<p>重定向是需要在建立完TCP连接后，服务器才以301或302的状态码告知客户端，这时候通常需要重新建立TCP连接。<br>因此最好的解决方案当然是彻底不要重定向。当然，非要重定向也可以考虑使用下面两个变通办法。</p> \n<ul> \n <li>利用CDN代替客户端在云端实现重定向；</li> \n <li>如果是同一个域名的重定向，使用web服务器的rewrite规则，避免浏览器跳转。</li> \n</ul> \n<h3>减少请求需要</h3> \n<p>这是最直接的解决办法，不需要那么多的请求需求，自然就没有延迟。主要思路不外乎合并外联资源，但这要适度，因为如果合并的文件过大，反而会降低了加载速度。</p> \n<ul> \n <li>CSS Sprites（精灵图）：<br>即将多张图片合并成一张，原本需要多个请求获取的图片，现在只需要一次请求就能获取到。</li> \n <li>内联图片：<br>使用data：URL模式，就是把图片编码为字串直接嵌入网页。</li> \n <li>合并或内联脚本和样式表：<br>减少外联的js和css文件自然会减少请求，但内联有助于缓存，这需要平衡考虑。</li> \n <li>缓存：<br>参见缓存篇提到的Expires或Cache-Control。</li> \n</ul> \n<h2>队头阻塞</h2> \n<p>进阶篇中讲到H1的连接管理模型并未提供机制来同时请求多个资源。也就是说它需要发起请求、等待响应，之后才能发起下一个请求。资源将排队等待一问一答的加载，如果中间出现任何状况，都会导致剩下的工作被阻塞<br>我们优化的目标就是要尽量提高并发，减少队头阻塞的影响，可用方案如下：</p> \n<h3>域名拆分</h3> \n<p>现代浏览器为了解决这个问题会对单个域名开启6个左右的连接，通过各个连接分别发送请求。它实现了某种程度上的并行，但每个连接仍会受到“队头阻塞”的影响。<br>我们可以利用这一机制，将资源分布在多个域名下，这样一个域名6个请求，两个域名就能有12个请求。但这里也涉及到增加了dns查询、TCP连接增加的问题，故需要达到一个最佳平衡，不可盲目。<br>Yahoo研究表明，一个网站使用2个主机名进行资源加载可达到最优。</p> \n<h2>低效的TCP利用</h2> \n<p>TCP的设计思路：对假设情况很保守，并能够公平对待同一网络的不同流量的应用。它的成功并不是因为传输速度快，而是因为它是最可靠的协议之一。<br>TCP的通过慢启动，探索当前连接拥塞窗口的合适大小。即先发送少量数据包，如果接收到响应且无丢包，就在下一次发送多一倍的数据包，直到发包上限。也就是说说TCP的传输速度是逐步加快的，并不能一下子满速的。</p> \n<blockquote>\n 拥塞窗口（congestion window）\n <br>拥塞窗口是指，在接收方确认数据包之前，发送方可以发出的TCP包的数量。\n <br>例如：如果拥塞窗口为1，则发送方发出1个数据包之后，只有接收方确认了那个包，才能发送下一个。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF5y4\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"拥塞控制.png\" title=\"拥塞控制.png\"></span></p> \n<p>而页面文件数据量本来就不大，建立TCP连接往往还没到最佳速度就结束了，即使多条连接并发也不能保证它们性能最优。<br>我们优化的目标就是要尽量复用TCP连接，可用方案如下：</p> \n<h3>使用长连接</h3> \n<p>使用connection:keep-alive是H1仅有的提高TCP使用率的办法。</p> \n<h2>臃肿的消息首部</h2> \n<p>H1虽然提供了压缩请求内容（body）的机制，但是消息首部却无法压缩。特别是其中的cookie有时很大，这样就自然增加了每次重复的数据量传输，而且自定义头部的增加，这种情况越来越严重。<br>我们优化的目标就是要尽量减少消息首部，可用方案如下：</p> \n<h3>减少cookie</h3> \n<p>cookie虽然保存在本地，但每次请求都会被发送到服务器，需要尽量减小cookie大小。需要较大的信息存储时，可以考虑使用其他客户端的缓存，比如：WebStorage、WebDatabases等。</p> \n<h3>分离资源域名与ajax域名</h3> \n<p>资源传输一般都不需要cookie，故可以在这类域名上设置cookie禁用。</p> \n<h2>受限的优先级设置</h2> \n<p>H1基本没有关于优先级的设计，单纯由浏览器决定，浏览器的有些解析过程还会阻塞资源的请求。<br>我们优化的目标就是使用浏览器的特性手动安排优先级，可用方案如下：</p> \n<h3>合理安排资源加载</h3> \n<ul> \n <li>JS放HTML文档末尾可以防止阻塞其他资源加载；</li> \n <li>如果JS执行顺序无关紧要，并且必须在onload事件触发之前执行，可以设置asyn属性；</li> \n <li>如果JS执行顺序很重要，并且允许脚本在dom加载完后执行，可以设置defer属性；</li> \n <li>对不会影响页面初次渲染的JS脚本，可以在onload事件之后再通过动态新建标签请求加载。</li> \n</ul> \n<h2>升级到HTTP/2.0</h2> \n<p>升级到H2可以解决大部分上面提到的有关H1的性能问题，上面提到的“队头阻塞”和“低效的TCP利用”会被H2的多路复用解决，“臃肿的消息首部”会被首部表和首部压缩解决，“受限的优先级设置”会被请求优先级解决。<br>那前面提到的一些优化方案是否还需要保留呢？答案是否定的，一些优化方案不单没有效果反而会成为反模式，这里需要注意：</p> \n<h3>反模式：生成精灵图和资源合并/内联</h3> \n<p>单个文件都是可以被缓存的，合并/内联实际上会失去缓存的特性。在H1的是时代牺牲缓存减少请求数是划算的，但H2时代所有资源都可并发，并且只有一个连接，所以缓存的优势会更大。</p> \n<h3>反模式：域名拆分</h3> \n<p>为了增加并发请求数，H1时代会将资源分散到多个域名下，但H2时代只有一个连接，并且都可并行请求，所以多个域名只会增加DNS解析的代价和建立连接的耗时。</p> \n<h3>反模式：禁用cookie的域名</h3> \n<p>H1时代一些不需要cookie的资源可以放在禁用cookie的域名下减少请求大小，但H2时代的头部是压缩处理的，所以将资源的域名都与主页面一致反而可以减少DNS解析。</p>', 'https://segmentfault.com/img/bVbF5y4', '1c5851dc916d4e70a60f0c957f548876', 'f0e336796bd94b8299ef69b2b2529ec4,63c4e1e7ec204b43a62065a3ced4c2ce', '0', '3', '1', '2020-04-16 16:48:05', '2020-04-16 16:48:05');
INSERT INTO `tb_recommend` VALUES ('7bf9e28092f442418e0966d4f67a7e87', '译文丨谈论我的时代：开发者的工具是如何改变的', '如果你是 20 世纪 90 年代或 2000 年代的开发者，你的工具集是相当简单的。你可能使用了一个 IDE 和一个调试器，也许你还也有一些基本的测试工具，而这些可能就是你完成工作所需要的所有工具了。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT6K\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>作者：Christopher Tozzi<br>编译：徐九<br>原文链接：<a href=\"https://www.itprotoday.com/devops-and-software-development/talkin-bout-my-generation-how-programmer-tools-have-changed\" rel=\"nofollow noreferrer\">https://www.itprotoday.com/de...</a></p> \n<hr> \n<p>如果你是 20 世纪 90 年代或 2000 年代的开发者，你的工具集是相当简单的。你可能使用了一个 IDE 和一个调试器，也许你还也有一些基本的测试工具，而这些可能就是你完成工作所需要的所有工具了。</p> \n<p>但今天这一代的开发人员就更难了。现在的开发者需要学习各种不同类型的编程工具。作为一名开发人员，只需要写好代码就可以结束工作的日子已经一去不复返了。</p> \n<p>今天，就让我们来看看那些对今天的开发人员来说是必不可少，但在这一代人之前可能还闻所未闻的编程工具。</p> \n<h2>Git</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT5W\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>首先，以 Git 为例，它是一个广泛使用的版本控制工具。Git 发布于 2000 年中期，但它并不是第一个版本控制工具。像 RCS 和 CVS 这样的源代码管理工具早在 1980 年代就已经出现了，但除非是在做一个大型复杂的企业软件项目，否则几乎不会用到它们。</p> \n<p>相比之下，Git 已经成为现在大部分程序员都在使用的源代码管理工具，哪怕是个人开发者都在使用。</p> \n<p>这要归功于基于 Web 的 Git 接口的兴起，尤其是 GitHub，它让编码工作变得更加大众化。任何一个人，只要是编码界的人，都应该拥有一个 GitHub 的账号，并了解如何使用 Git 来分享和管理源代码。</p> \n<p>更重要的是，所谓的 GitOps（一种实现持续交付的模型，它的核心思想是将应用系统的声明性基础架构和应用程序存放在 Git 的版本控制库中。）趋势已经使 Git 不仅仅是一个源代码管理工具，而是一个端到端的项目管理平台。现在，开发者们都希望能够使用 Git 来跟踪任务、简化沟通等等。</p> \n<p>而早期的程序员们使用的源代码管理器都不是这样的。</p> \n<h2>容器</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT53\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>容器是另一个例子，这类工具在我们这一代人之前很少有程序员想到过，但现在却随处可见。</p> \n<p>容器的历史悠久，可以追溯到几十年前。然而，直到 2013 年 Docker 的容器平台首次亮相，容器才开始进入主流。</p> \n<p>Docker 早期的卖点之一是，容器可以通过提供一个跨开发管道所有阶段的通用应用托管环境来简化开发流程。早期的容器平台还没有推广这种用例。</p> \n<p>今天，知道如何在容器内打包代码对许多程序员来说是必不可少的。熟悉容器平台（如Kubernetes）也是如此，Kubernetes 提供了一种创建应用程序开发/测试环境的方法，因此它已经变得非常流行。</p> \n<h2>持续集成服务器</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT59\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>和容器一样，持续集成（CI）服务器的历史比我们想象的要长。这个概念可以追溯到 20 世纪 90 年代初，但到了 90 年代末，它才在一些开发者圈子里找到了追随者 -- 尤其是极端编程社区。</p> \n<p>但直到 2010 年左右，CI 工具才开始在各种类型的程序员中广泛使用。今天，很少有软件项目不使用像 Jenkins、Ansible、TeamCity 或其他无数 CI 平台的工具来做 CI 的。</p> \n<p>这对今天的程序员来说意味着，熟悉 CI 服务器是至关重要的。</p> \n<h2>APIs</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT6a\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>API 也已经以这样或那样的形式存在了几十年了。但直到云时代的到来，API 才成为许多应用架构的一部分。今天，很难找到一个应用程序不以这样或那样的方式依赖 API。</p> \n<p>因此，今天的程序员必须对 API 的工作原理和有哪些不同类型的 API 架构具备深刻的理解。他们还必须经常能够使用 API 测试和模拟工具，这在开发依赖 API 的应用程序时非常重要。</p> \n<h2>公有云</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFT6p\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>虽然把云放在了最后，但这不代表它不重要。在 AWS 在 2000 年代中期推出之前，很少有开发者使用类似于今天所谓的公有云的东西。</p> \n<p>然而，快步走到现在，如果你想成为一名开发者，知道如何使用公有云的所有工具是相当重要的。如果你不了解如何在至少一两个主要的公有云平台上使用 IAM、监控、部署和配置工具，你的技术之路估计不会走得很远。</p> \n<h2>结论</h2> \n<p>与前代人相比，现在的开发人员需要掌握更多的编程工具来完成自己的工作。现在开发人员日常使用的许多工具类型其实并不新鲜。但它们已经从某些社区的程序员使用的小众解决方案，变成了几乎每个开发者的必备工具。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyLB\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFT6K', '61cdf41d1e5e4f229b76f6a042e254b6', '66d1b6953b664c409cf7283cdb6c6566,db6b58ae709645f2b64166fd73f2f705,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-16 16:59:44', '2020-04-16 16:59:44');
INSERT INTO `tb_recommend` VALUES ('7c5ac67e2f1848b2876b499180d3296b', 'Google 推出 Android 系统盲文键盘 APP，更新无障碍套件即可使用', '谷歌于 4 月 10 日宣布推出了适用于 Android 系统的虚拟盲文键盘，该盲文键盘旨在使视力低下或失明的人无需额外的硬件即可在手机上打字。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFPln\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>谷歌于 4 月 10 日宣布推出了适用于 Android 系统的虚拟盲文键盘，该盲文键盘旨在使视力低下或失明的人无需额外的硬件即可在手机上打字。</p> \n<p>谷歌表示，它与盲文开发人员和用户合作创建了它，并确保可以在用户常用任何的键入场景使用它，包括社交媒体、文本消息和电子邮件应用程序。</p> \n<p>根据世界卫生组织的数据，全球至少有 22 亿人患有视力障碍或失明。为了满足他们的需求，Google 先前开发并发布了 BrailleBack，这是一种 Android 辅助功能，可帮助用户使用盲文设备，但 BrailleBack 不提供屏幕打字功能。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFPlz\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>虽然当前已经有实体的盲文键盘来帮助盲人和视力受损的人在手机、平板电脑与电脑上打字。然而 Google 指出，在手机等移动设备上，「每次想要快速输入内容时，连接外部设备都可能很耗时」。</p> \n<p>而 Google 此次提出的解决方案是将虚拟盲文键盘集成到 Android 操作系统中，基于屏幕实现一个典型的盲文键盘 6 键的布局。它可以「用在任何你通常会输入文字的地方使用，让你可以方便地删除字母和单词，添加回车，并发送文本。」，不过略显遗憾的是，目前这款盲文输入法还尚不能原生支持中文。</p> \n<p>目前，这项更新已经面向所有的 Android 版本 5.0 以上的设备推出；对于有需求的用户，可以在 Google Play Store 中将「Android 无障碍套件」应用更新至最新的版本即可尝试体验。</p> \n<blockquote> \n <strong>参考资料：</strong>\n <br>\n <a href=\"https://venturebeat.com/2020/04/09/google-launches-braille-keyboard-for-android-devices/\" rel=\"nofollow noreferrer\">https://venturebeat.com/2020/...</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFPlO\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFPkW\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFPln', '61cdf41d1e5e4f229b76f6a042e254b6', '6224a68b52f54990a07d51854b320f32,8dfc62f227ae4076888ea4872e03cddd', '0', '3', '1', '2020-04-16 16:54:49', '2020-04-16 16:54:49');
INSERT INTO `tb_recommend` VALUES ('8196c1bfa3024ce3973b602555353408', 'Ant Design核心作者谈4.0版本更新背后的故事', 'Ant Design 是蚂蚁金服推出的一套企业级 UI 设计语言和 React 组件库，从 2015 年推出开始便受到广泛的关注与使用，目前在 GitHub 上已收获超过 5.7 万个 star。近日，Ant Design 发布了 4.0 版本，带来了一些重...', '<blockquote>\n Ant Design 是蚂蚁金服推出的一套企业级 UI 设计语言和 React 组件库，从 2015 年推出开始便受到广泛的关注与使用，目前在 GitHub 上已收获超过 5.7 万个 star。近日，Ant Design 发布了 4.0 版本，带来了一些重大更新。前端之巅采访了 Ant Design 团队的核心作者之一的蒋吉麟，聊了聊 4.0 版本更新背后的一些故事。\n</blockquote> \n<p><strong>Ant Design 4.0 发布了，这次带来了哪些重磅的更新？</strong></p> \n<p>​本次发布了一些重大更新。比如我们添加了暗黑主题，无边框组件，RTL 国际化支持，Table 、Form、Select 等等的组件重做从而大幅提升性能。由于内容非常多 ，避免直接变成发布文档。欢迎移步至语雀查看完整更新：《Ant Design 正式版来了！》</p> \n<p><strong>经过多年发展，Ant Design 已经成为一个生态，请介绍下这个生态包括哪些重要成员，生态今后的演进方向是什么？</strong></p> \n<p>Ant Design（以下简称 antd） 作为一个设计体系，包含的不仅仅是一个组件库。除了耳熟能详的 Ant Design React 外，还有 Angular 版本的 NG-ZORRO、Ant Desin Mobile、Ant Design Landing、HiTu React，以及来自社区志愿者的 Ant Design Vue。垂直方向开箱即用的中台前端 / 设计解决方案 Ant Design Pro 和对应的区块市场，以及衍生组件库 Pro Layout 和 Pro Table。设计上也提供了非常多的规范文档以及相关的设计资产。</p> \n<p>Ant Design 像是一颗树，在其之上开枝散叶非常的有想象空间。未来首先还是会继续基于设计体系进行深耕，其次会跟随相关框架一同进步。同时 Ant Design 还会立足于真实的业务需求，来丰富生态产品。</p> \n<p><strong>在从 3.0 到 4.0 的过程中，antd 团队攻克的最大难题是什么？最自豪的新特性是什么？</strong></p> \n<p>v4 版本和社区同学一起重构了大量的底层组件，从而大幅提升了组件渲染性能。举个例子，v3 版本中 Form 组件的字段更新会使得整个 Form 重新渲染，这在大型表单中会有严重的性能问题。在 v4 中，Form 只会更新相关的字段组件，从而大大降低了渲染时长。在 Tree、Select、TreeSelect 等组件内置虚拟滚动，从而大幅减少了实际渲染的元素。</p> \n<p>说到比较难的，就是这次重构由于支持虚拟滚动，所以需要处理基于虚拟滚动的动画收缩伸展方案。举个例子，Tree 组件在 v3 版本中，缩放可以通过原生的 transition 与 height 来实现收缩伸展效果。但是在虚拟滚动中，每个元素其实是独立的元素，所以缩放时如果要达到和 v3 一致的动画效果，就需要将与之相关的算法自行实现。因而我们将其划分为多个阶段，在不同的阶段处理不同的逻辑，从而组合出支持虚拟滚动的动画实现。具体实现逻辑比较复杂，如果感兴趣可以查看 rc-virtual-list 的相关代码。</p> \n<p><strong>antd 在设计上是如何权衡效率、性能 / 体验和质量三者的？</strong></p> \n<p>个人角度看，后三者者其实并不矛盾。Ant Design 的组件开发一般有以下几个步骤：</p> \n<ol> \n <li>设计师设计视觉、交互稿；</li> \n <li>工程师进行开发；</li> \n <li>Code Review &amp; 设计师评审。</li> \n</ol> \n<p>中间每个环节都会认真负责地完成，其中 Code Review 部分也是最漫长的阶段。Code Review 环节会对 API 以及代码实现反复修正，设计与开发者共同参与，从而达到 1 + 1 &gt; 2 的效果。组件的开发并不能一味地追求效率，从设计到实现都需要慢慢打磨。举个例子，Typography 这个组件作为排版组件，看起来非常简单，但是从设计到开发完成前前后后花了一个月的时间，API 经过了反复调整力求以最精简的方式简化开发者的记忆成本，同时也兼顾了拓展性。设计层面也是反复斟酌以达到中英文语境下都有很好的视觉效果。</p> \n<p>在 v3 版本中，组件的性能问题主要出在对旧版 IE 的兼容性需求上，因而不少实现只能使用比较黑的方式，下面的问题会提到所以不重复提了。由于 v4 版本 IE 最低兼容版本改成了 IE 11，这些不再是限制，从而使得我们有能力去逐渐更新，更好地提升性能。</p> \n<p><strong>在对 IE 的兼容性方面做了一些取舍，原因是什么？兼容 IE 的难点都有哪些？</strong></p> \n<p>v3 版本为了兼容旧版 IE，不得不做一些妥协。比如说 flex 布局不能用，我们就用 float 和 table 来搞；不能用 sticky，Table 为了实现固定列不得不额外再渲染一个 Table 达到固定列的效果。最近几年，随着 windows 系统的升级，旧版 IE 的占比已经越来越小。这也是一个契机，让我们在 v4 版本可以舍弃过于陈旧的 IE 版本，从而轻装上阵。</p> \n<p>兼容 IE 的难点在于很多行为是非预期的，往往代码没有什么问题，但是页面渲染就是不正常。对于这种情况，就需要做不少的黑科技。比如说让组件强制刷新、使用 IE only 的 css hack 等等。此外前面提到的很多 HTML 新特性在 IE 环境下无法使用，只能自行模拟导致严重的性能损耗。</p> \n<p><strong>你认为 antd 目前对 TypeScript 的支持到位了吗？如果还有欠缺，主要在哪些地方，将怎么解决？</strong></p> \n<p>在 v3 版本中，我们大量底层组件是通过 js 编写，因而 ts 的类型定义是在 antd 上额外做的，这样的缺点就是和底层的组件并不完全匹配。在 v4 版本中，我们将大量底层组件也转成了 ts 版本，在 antd 端直接使用这些定义，从而避免了过去定义不匹配的情况。当然，这个过程也不是一蹴而就的，还有一分部底层组件还没有完成转，欢迎社区的同学一同帮助让 ts 定义做得更好。</p> \n<p>除此之外，我们也遇到一些有趣而恼人的问题——那就是由于 typescript 和 @types/react 本体的升级，导致原本的 ts 定义失效。过去有过一段时间，antd 的 Button 每周都在更新 ts 定义来适配最新的 @types/react。这种情况在所难免，保持更新即可。</p> \n<p><strong>在发布公告里专门提到了 @saeedrahimi @shaodahong 两位社区同学的贡献，能否具体介绍下这里面的故事？</strong></p> \n<p>@saeedrahimi 同学他为 v4 贡献了全部组件的 RTL 国际化能力，改了数千行代码。这个功能非常大，过一次 PR 可以看到眼花。就这样我们一遍遍地 Review &amp; Update，最终将其实现，中间非常不容易。</p> \n<p>@shaodahong 其实在 v3 时就已经是热心志愿者了，在 v4 的发布中，也帮助做了很多的工作，其中兼容包的开发主要是由他完成的。通过兼容包，开发者可以以尽可能小的成本来将 antd 从 v3 升级到 v4。</p> \n<p>当然，除了这两位同学外，还有非常多的志愿者参与了 v4 的开发工作。借这个机会，再次向各位志愿者表示感谢！</p> \n<p><strong>有部分用户反馈社区反哺困难，源码使用 rc-* 封装实现，导致开发者想帮忙修复 bug 却望而却步，这方面有考虑如何解决吗？antd 团队是怎样看待与社区开发者之间的联系和交互的？</strong></p> \n<p>rc 组件的设计思想是简单且灵活，因而它不会对样式有强依赖。而 antd 除了组件功能外，还有着自己的设计体系，所以在 UI Design 上也会更重一些。这种划分，使得如果用户只想用组件的功能却不需要它的样式就可以直接基于 rc 组件进行封装。举个例子，Form 的底层组件 rc-field-form 本身完全不带样式，而在 antd 出则是封装出带样式的 Form 和 Form.Item 且不暴露底层的 Field 组件。其实在 v4 发布前，已经有不少的社区同学基于 rc-field-form 封装出自己的组件了。两者从设计思想上是不同的，因而在未来也不会合并。</p> \n<p>从发 PR 角度看，其实不必有太多的心理负担。组件各司其职，不会因为底层多一个 rc 组件库就望而却步。其实从平时的维护看，志愿者给 antd 和 rc 发 PR 的热情是一样的，不存在有 bug 因为在 rc 组件里就修不了的情况。甚至有时候反过来，有的用户只用了 rc 组件，因而给 rc 组件发了很多的 PR 来帮助改进，这也使得这些 PR 同样反哺给了 antd。</p> \n<p><strong>后续的版本规划是怎样的？未来还将有哪些值得期待的新特性？</strong></p> \n<p>v4 版本在发布后，由于大量组件的重构，主要精力暂时会聚焦于 bug fix 上。待其稳定后，我们会为 React 未来的 Concurrent 模式做好准备。此外，也有计划为了 css in js 做一下调研，以支持动态切换主题的能力。当然，就像刚刚说的，目前的首要任务还是聚焦在 bug fix 上。</p> \n<p><strong>作为被广泛使用的前端明星开源项目，你认为 antd 发展至今取得成功的原因是什么？开源这几年最大的收获和教训是什么？</strong></p> \n<p>Ant Design 受欢迎离不开社区同学的支持，是大家的认可才使得 Ant Design 能够走到今天。一个开源项目的成活，除了维护者的保持更新外，也需要来自社区的力量。开源界中，你会看到非常多的优秀项目。但是随着时间推移，逐渐不再维护。因而如何保持项目的活力是重中之重。</p> \n<p>Ant Design 从 2015 年写下第一行代码至今走过了不少年头。最大的收获就是来自社区同学的帮助，来一起把 Ant Design 打造成一流的前端组件库。而同时作为开源项目，也必须按照开源的方式来公开透明的维护项目。从而不辜负社区同学的信任。</p>', null, '6fbfa4aaad3a43458f21c8acf0038ac5', '4c5f061cd88a451d91f4d1f0d52f3ed0,6e99f9fefb2d45f59288b87ccf651628,63c4e1e7ec204b43a62065a3ced4c2ce,e1461b476a0f4662aa26c90ecff5579b,6aec6c8499c44483beecd569d05c7f4b', '0', '3', '1', '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_recommend` VALUES ('88d2ea25c96b491788b2b710ac8513d5', '后端程序员必备：书写高质量SQL的30条建议', '后端程序员必备：书写高质量SQL的30条建议 本文将结合实例demo，阐述30条有关于优化SQL的建议，多数是实际开发中总结出来的，希望对大家有帮助。 前言 本文将结合实例demo，阐述30条有关于优化SQL的建议，多数是...', '<h2>后端程序员必备：书写高质量SQL的30条建议</h2> \n<p>本文将结合实例demo，阐述30条有关于优化SQL的建议，多数是实际开发中总结出来的，希望对大家有帮助。</p> \n<p><strong>前言</strong></p> \n<p>本文将结合实例demo，阐述30条有关于优化SQL的建议，多数是实际开发中总结出来的，希望对大家有帮助。</p> \n<p><strong>1、查询SQL尽量不要使用select *，而是select具体字段。</strong></p> \n<p>反例子：</p> \n<pre><code>select&nbsp;*&nbsp;from&nbsp;employee;&nbsp;\n</code></pre> \n<p>正例子：</p> \n<pre><code>select&nbsp;id，name&nbsp;from&nbsp;employee;&nbsp;\n</code></pre> \n<p>理由：</p> \n<ul> \n <li>&nbsp;只取需要的字段，节省资源、减少网络开销。</li> \n <li>&nbsp;select * 进行查询时，很可能就不会使用到覆盖索引了，就会造成回表查询。</li> \n</ul> \n<p><strong>2、如果知道查询结果只有一条或者只要最大/最小一条记录，建议用limit 1</strong></p> \n<p>假设现在有employee员工表，要找出一个名字叫jay的人.&nbsp;</p> \n<pre><code>CREATE TABLE `employee` (  \n      `id` int(11) NOT NULL,  \n      `name` varchar(255) DEFAULT NULL,  \n      `age` int(11) DEFAULT NULL,  \n      `date` datetime DEFAULT NULL,  \n      `sex` int(1) DEFAULT NULL,  \n      PRIMARY KEY (`id`)  \n    ) ENGINE=InnoDB DEFAULT CHARSET=utf8; </code></pre> \n<p>反例：&nbsp;</p> \n<pre><code>select&nbsp;id，name&nbsp;from&nbsp;employee&nbsp;where&nbsp;name\\=\'jay\'\n</code></pre> \n<p>正例</p> \n<pre><code>select&nbsp;id，name&nbsp;from&nbsp;employee&nbsp;where&nbsp;name=\'jay\'&nbsp;limit&nbsp;1;&nbsp;\n</code></pre> \n<p>理由：</p> \n<ul> \n <li>&nbsp;加上limit 1后,只要找到了对应的一条记录,就不会继续向下扫描了,效率将会大大提高。</li> \n <li>&nbsp;当然，如果name是唯一索引的话，是不必要加上limit 1了，因为limit的存在主要就是为了防止全表扫描，从而提高性能,如果一个语句本身可以预知不用全表扫描，有没有limit ，性能的差别并不大。</li> \n</ul> \n<p><strong>3、应尽量避免在where子句中使用or来连接条件</strong></p> \n<p>新建一个user表，它有一个普通索引userId，表结构如下：&nbsp;</p> \n<pre><code>CREATE TABLE `user` (  \n      `id` int(11) NOT NULL AUTO_INCREMENT,  \n      `userId` int(11) NOT NULL,  \n      `age` int(11) NOT NULL,  \n      `name` varchar(255) NOT NULL, \n      PRIMARY KEY (`id`),  \n      KEY `idx_userId` (`userId`)  \n    ) ENGINE=InnoDB DEFAULT CHARSET=utf8; </code></pre> \n<p>假设现在需要查询userid为1或者年龄为18岁的用户，很容易有以下SQL</p> \n<p>反例:&nbsp;</p> \n<pre><code>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;userid=1&nbsp;or&nbsp;age&nbsp;=18\n</code></pre> \n<p>正例：</p> \n<pre><code>//使用union all  \n  select * from user where userid=1   \n  union all  \n  select * from user where age = 18  \n  //或者分开两条sql写：  \n  select * from user where userid=1  \n  select * from user where age = 18 </code></pre> \n<p>理由：</p> \n<ul>\n <li>&nbsp;使用or可能会使索引失效，从而全表扫描。</li>\n</ul> \n<p>对于or+没有索引的age这种情况，假设它走了userId的索引，但是走到age查询条件时，它还得全表扫描，也就是需要三步过程：全表扫描+索引扫描+合并如果它一开始就走全表扫描，直接一遍扫描就完事。mysql是有优化器的，处于效率与成本考虑，遇到or条件，索引可能失效，看起来也合情合理。</p> \n<p><strong>4、优化limit分页</strong></p> \n<p>我们日常做分页需求时，一般会用 limit 实现，但是当偏移量特别大的时候，查询效率就变得低下。</p> \n<p>反例：&nbsp;</p> \n<pre><code>select&nbsp;id，name，age&nbsp;from&nbsp;employee&nbsp;limit&nbsp;10000，10&nbsp;\n</code></pre> \n<p>正例：</p> \n<pre><code>//方案一 ：返回上次查询的最大记录(偏移量)  \nselect id，name from employee where id&gt;10000 limit 10.  \n//方案二：order by + 索引  \nselect id，name from employee order by id  limit 10000，10  \n//方案三：在业务允许的情况下限制页数：</code></pre> \n<p>理由：</p> \n<ul> \n <li>&nbsp;当偏移量最大的时候，查询效率就会越低，因为Mysql并非是跳过偏移量直接去取后面的数据，而是先把偏移量+要取的条数，然后再把前面偏移量这一段的数据抛弃掉再返回的。</li> \n <li>&nbsp;如果使用优化方案一，返回上次最大查询记录（偏移量），这样可以跳过偏移量，效率提升不少。</li> \n <li>&nbsp;方案二使用order by+索引，也是可以提高查询效率的。</li> \n <li>&nbsp;方案三的话，建议跟业务讨论，有没有必要查这么后的分页啦。因为绝大多数用户都不会往后翻太多页。</li> \n</ul> \n<p><strong>5、优化你的like语句</strong></p> \n<p>日常开发中，如果用到模糊关键字查询，很容易想到like，但是like很可能让你的索引失效。</p> \n<p>反例：</p> \n<pre><code>select&nbsp;userId，name&nbsp;from&nbsp;user&nbsp;where&nbsp;userId&nbsp;like&nbsp;\'%123\';&nbsp;\n</code></pre> \n<p>正例：</p> \n<pre><code>select&nbsp;userId，name&nbsp;from&nbsp;user&nbsp;where&nbsp;userId&nbsp;like&nbsp;\'123%\';&nbsp;\n</code></pre> \n<p>理由：</p> \n<ul>\n <li>&nbsp;把%放前面，并不走索引，如下：&nbsp;&nbsp; &nbsp;</li>\n</ul> \n<p><a href=\"https://s3.51cto.com/oss/202004/10/570b4dceb3ce9f5730e9f7e09bce7b2a.jpg-wh_651x-s_13395285.jpg\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389744\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<ul>\n <li>把% 放关键字后面，还是会走索引的。如下：&nbsp;</li>\n</ul> \n<p><a href=\"https://s4.51cto.com/oss/202004/10/7c98a35efec99b61e8188366ab1af905.jpg\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389745\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p><strong>6、使用where条件限定要查询的数据，避免返回多余的行</strong></p> \n<p>假设业务场景是这样：查询某个用户是否是会员。曾经看过老的实现代码是这样。。。</p> \n<p>反例：</p> \n<pre><code>List&lt;Long&gt; userIds = sqlMap.queryList(\"select userId from user where isVip=1\");  \n boolean isVip = userIds.contains(userId); </code></pre> \n<p>正例：&nbsp;</p> \n<pre><code>Long userId = sqlMap.queryObject(\"select userId from user where userId=\'userId\' and isVip=\'1\' \")  \n   boolean isVip = userId！=null; </code></pre> \n<p>理由：</p> \n<ul>\n <li>&nbsp;需要什么数据，就去查什么数据，避免返回不必要的数据，节省开销。</li>\n</ul> \n<p><strong>7、尽量避免在索引列上使用mysql的内置函数</strong></p> \n<p>业务需求：查询最近七天内登陆过的用户(假设loginTime加了索引)</p> \n<p>反例：&nbsp;</p> \n<pre><code>select&nbsp;userId,loginTime&nbsp;from&nbsp;loginuser&nbsp;where&nbsp;Date\\_ADD(loginTime,Interval&nbsp;7&nbsp;DAY)&nbsp;\\&gt;\\=now();\n</code></pre> \n<p>正例：&nbsp;</p> \n<pre><code>explain&nbsp;&nbsp;select&nbsp;userId,loginTime&nbsp;from&nbsp;loginuser&nbsp;where&nbsp;&nbsp;loginTime&nbsp;\\&gt;\\=&nbsp;Date\\_ADD(NOW(),INTERVAL&nbsp;-&nbsp;7&nbsp;DAY);</code></pre> \n<p>理由：</p> \n<ul>\n <li>&nbsp;索引列上使用mysql的内置函数，索引失效&nbsp;</li>\n</ul> \n<p><a href=\"https://s2.51cto.com/oss/202004/10/f1e082281ea96eb465706403a31a84c4.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389747\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<ul>\n <li>如果索引列不加内置函数，索引还是会走的。&nbsp;</li>\n</ul> \n<p><a href=\"https://s4.51cto.com/oss/202004/10/0625708e85f39ada4211708beab2fc9a.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389746\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p><strong>8、应尽量避免在where子句中对字段进行表达式操作，这将导致系统放弃使用索引而进行全表扫</strong></p> \n<p>反例：&nbsp;</p> \n<pre><code>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;age-1&nbsp;=10；&nbsp;\n</code></pre> \n<p>正例：&nbsp;</p> \n<pre><code>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;age&nbsp;=11；&nbsp;\n</code></pre> \n<p>理由：</p> \n<ul>\n <li>&nbsp;虽然age加了索引，但是因为对它进行运算，索引直接迷路了。。。&nbsp;</li>\n</ul> \n<p><a href=\"https://s2.51cto.com/oss/202004/10/a64a400a9374688d54fae02052a33e74.jpg\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389748\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p><strong>9、Inner join 、left join、right join，优先使用Inner join，如果是left join，左边表结果尽量小</strong></p> \n<ul> \n <li>&nbsp; Inner join 内连接，在两张表进行连接查询时，只保留两张表中完全匹配的结果集</li> \n <li>&nbsp; left join 在两张表进行连接查询时，会返回左表所有的行，即使在右表中没有匹配的记录。</li> \n <li>&nbsp; right join 在两张表进行连接查询时，会返回右表所有的行，即使在左表中没有匹配的记录。</li> \n</ul> \n<p>都满足SQL需求的前提下，推荐优先使用Inner join（内连接），如果要使用left join，左边表数据结果尽量小，如果有条件的尽量放到左边处理。</p> \n<p>反例:</p> \n<pre><code>select&nbsp;*&nbsp;from&nbsp;tab1&nbsp;t1&nbsp;left&nbsp;join&nbsp;tab2&nbsp;t2&nbsp;&nbsp;on&nbsp;t1.size&nbsp;=&nbsp;t2.size&nbsp;where&nbsp;t1.id&gt;2;</code></pre> \n<p>正例：</p> \n<pre><code>select&nbsp;*&nbsp;from&nbsp;(select&nbsp;*&nbsp;from&nbsp;tab1&nbsp;where&nbsp;id&nbsp;&gt;2)&nbsp;t1&nbsp;left&nbsp;join&nbsp;tab2&nbsp;t2&nbsp;on&nbsp;t1.size&nbsp;=&nbsp;t2.size;</code></pre> \n<p>理由：</p> \n<ul> \n <li>&nbsp;如果inner join是等值连接，或许返回的行数比较少，所以性能相对会好一点。</li> \n <li>&nbsp;同理，使用了左连接，左边表数据结果尽量小，条件尽量放到左边处理，意味着返回的行数可能比较少。</li> \n</ul> \n<p><strong>10、应尽量避免在where子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</strong></p> \n<p>反例：&nbsp;</p> \n<pre><code>select&nbsp;age,name&nbsp;&nbsp;from&nbsp;user&nbsp;where&nbsp;age&nbsp;&lt;&gt;18;&nbsp;\n</code></pre> \n<p>正例：&nbsp;</p> \n<pre><code>    select age,name  from user where age &lt;18;  \n    select age,name  from user where age &gt;18; </code></pre> \n<p>理由：</p> \n<ul>\n <li>&nbsp;使用!=和&lt;&gt;很可能会让索引失效</li>\n</ul> \n<p><a href=\"https://s1.51cto.com/oss/202004/10/078f94d947d4ae5b85e3bc06d7e2852e.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389757\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p><strong>11、使用联合索引时，注意索引列的顺序，一般遵循最左匹配原则。</strong></p> \n<p>表结构：（有一个联合索引idxuseridage，userId在前，age在后）&nbsp;</p> \n<pre><code>CREATE TABLE `user` (  \n      `id` int(11) NOT NULL AUTO_INCREMENT,  \n      `userId` int(11) NOT NULL,  \n      `age` int(11) DEFAULT NULL,  \n      `name` varchar(255) NOT NULL,  \n      PRIMARY KEY (`id`),  \n      KEY `idx_userid_age` (`userId`,`age`) USING BTREE  \n    ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8; </code></pre> \n<p>反例：</p> \n<pre><code>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;age&nbsp;=&nbsp;10;&nbsp;\n</code></pre> \n<p><a href=\"https://s4.51cto.com/oss/202004/10/b4893757329d22f98558839af6a9d8b6.jpg\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389749\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p>正例：&nbsp;</p> \n<ol> \n <li>//符合最左匹配原则&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;//符合最左匹配原则&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;userid&nbsp;=10;&nbsp;</li> \n</ol> \n<p><a href=\"https://s4.51cto.com/oss/202004/10/ffbaa8c62bc57ada3e06d75425f0e970.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389752\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p><a href=\"https://s3.51cto.com/oss/202004/10/f12d7d31b515ca536d7f45796d7068da.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389750\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p>理由：</p> \n<ul> \n <li>&nbsp;当我们创建一个联合索引的时候，如(k1,k2,k3)，相当于创建了（k1）、(k1,k2)和(k1,k2,k3)三个索引，这就是最左匹配原则。</li> \n <li>&nbsp;联合索引不满足最左原则，索引一般会失效，但是这个还跟Mysql优化器有关的。</li> \n</ul> \n<p><strong>12、对查询进行优化，应考虑在where及order by涉及的列上建立索引，尽量避免全表扫描。</strong></p> \n<p>反例：</p> \n<ol>\n <li>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;address&nbsp;=\'深圳\'&nbsp;order&nbsp;by&nbsp;age&nbsp;;&nbsp;</li>\n</ol> \n<p><a href=\"https://s2.51cto.com/oss/202004/10/2ac539666a8f988323d7d94560cd1abe.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389751\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p>正例：&nbsp;</p> \n<ol> \n <li>添加索引&nbsp;&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;alter&nbsp;table&nbsp;user&nbsp;add&nbsp;index&nbsp;idx_address_age&nbsp;(address,age)&nbsp;</li> \n</ol> \n<p><a href=\"https://s3.51cto.com/oss/202004/10/75ca542476884b206eb58dcee139c2c3.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389753\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p><strong>13、如果插入数据过多，考虑批量插入。</strong></p> \n<p>反例：</p> \n<ol> \n <li>for(User&nbsp;u&nbsp;:list){&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;INSERT&nbsp;into&nbsp;user(name,age)&nbsp;values(#name#,#age#)&nbsp;</li> \n <li>&nbsp;&nbsp;}&nbsp;</li> \n</ol> \n<p>正例：&nbsp;</p> \n<ol> \n <li>//一次500批量插入，分批进行&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;insert&nbsp;into&nbsp;user(name,age)&nbsp;values&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&lt;foreachcollection=\"list\"item=\"item\"index=\"index\"separator=\",\"&gt;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(#{item.name},#{item.age})&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&lt;/foreach&gt;</li> \n</ol> \n<p>理由：</p> \n<ul>\n <li>&nbsp;批量插入性能好，更加省时间</li>\n</ul> \n<p>打个比喻:假如你需要搬一万块砖到楼顶,你有一个电梯,电梯一次可以放适量的砖（最多放500）,你可以选择一次运送一块砖,也可以一次运送500块砖,你觉得哪个时间消耗大?</p> \n<p><strong>14、在适当的时候，使用覆盖索引。</strong></p> \n<p>覆盖索引能够使得你的SQL语句不需要回表，仅仅访问索引就能够得到所有需要的数据，大大提高了查询效率。</p> \n<p>反例：&nbsp;</p> \n<ol> \n <li>//&nbsp;like模糊查询，不走索引了&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;userid&nbsp;like&nbsp;\'%123%\'&nbsp;</li> \n</ol> \n<p><a href=\"https://s4.51cto.com/oss/202004/10/1af8fc5fc52b6b0d3d8085f4d2295160.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389760\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p>正例：</p> \n<ol> \n <li>//id为主键，那么为普通索引，即覆盖索引登场了。&nbsp;</li> \n <li>&nbsp;&nbsp;select&nbsp;id,name&nbsp;from&nbsp;user&nbsp;where&nbsp;userid&nbsp;like&nbsp;\'%123%\';&nbsp;</li> \n</ol> \n<p><a href=\"https://s1.51cto.com/oss/202004/10/6f5740a6799be3e84a8a070ca59ddccd.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389755\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p><strong>15、慎用distinct关键字</strong></p> \n<p>distinct 关键字一般用来过滤重复记录，以返回不重复的记录。在查询一个字段或者很少字段的情况下使用时，给查询带来优化效果。但是在字段很多的时候使用，却会大大降低查询效率。</p> \n<p>反例：&nbsp;</p> \n<ol>\n <li>SELECT&nbsp;DISTINCT&nbsp;*&nbsp;from&nbsp;&nbsp;user;&nbsp;</li>\n</ol> \n<p>正例：&nbsp;</p> \n<ol>\n <li>select&nbsp;DISTINCT&nbsp;name&nbsp;from&nbsp;user;&nbsp;</li>\n</ol> \n<p>理由：</p> \n<ul>\n <li>&nbsp;带distinct的语句cpu时间和占用时间都高于不带distinct的语句。因为当查询很多字段时，如果使用distinct，数据库引擎就会对数据进行比较，过滤掉重复数据，然而这个比较、过滤的过程会占用系统资源，cpu时间。</li>\n</ul> \n<p><strong>16、删除冗余和重复索引</strong></p> \n<p>反例：&nbsp; &nbsp;</p> \n<ol> \n <li>KEY&nbsp;`idx_userId`&nbsp;(`userId`)&nbsp;&nbsp;&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KEY&nbsp;`idx_userId_age`&nbsp;(`userId`,`age`)&nbsp;</li> \n</ol> \n<p>正例:&nbsp; &nbsp;</p> \n<ol> \n <li>//删除userId索引，因为组合索引（A，B）相当于创建了（A）和（A，B）索引&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;KEY&nbsp;`idx_userId_age`&nbsp;(`userId`,`age`)&nbsp;</li> \n</ol> \n<p>理由：</p> \n<ul>\n <li>&nbsp;重复的索引需要维护，并且优化器在优化查询的时候也需要逐个地进行考虑，这会影响性能的。</li>\n</ul> \n<p><strong>17、如果数据量较大，优化你的修改/删除语句。</strong></p> \n<p>避免同时修改或删除过多数据，因为会造成cpu利用率过高，从而影响别人对数据库的访问。</p> \n<p>反例：&nbsp;</p> \n<ol> \n <li>//一次删除10万或者100万+？&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;delete&nbsp;from&nbsp;user&nbsp;where&nbsp;id&nbsp;&lt;100000;&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;//或者采用单一循环操作，效率低，时间漫长&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;for（User&nbsp;user：list）{&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;delete&nbsp;from&nbsp;user；&nbsp;&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;}&nbsp;</li> \n</ol> \n<p>正例：</p> \n<ol> \n <li>//分批进行删除,如每次500&nbsp;</li> \n <li>&nbsp;&nbsp;delete&nbsp;user&nbsp;where&nbsp;id&lt;500</li> \n <li>&nbsp;&nbsp;delete&nbsp;product&nbsp;where&nbsp;id&gt;=500&nbsp;and&nbsp;id&lt;1000；&nbsp;</li> \n</ol> \n<p>理由：</p> \n<ul>\n <li>&nbsp;一次性删除太多数据，可能会有lock wait timeout exceed的错误，所以建议分批操作。</li>\n</ul> \n<p><strong>18、where子句中考虑使用默认值代替null。</strong></p> \n<p>反例：&nbsp;</p> \n<ol>\n <li>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;age&nbsp;is&nbsp;not&nbsp;null;&nbsp;</li>\n</ol> \n<p><a href=\"https://s2.51cto.com/oss/202004/10/7ab17727fed2cd239afc9098f2e492e4.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389754\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p>正例：</p> \n<ol> \n <li>//设置0为默认值&nbsp;</li> \n <li>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;age&gt;0;&nbsp;</li> \n</ol> \n<p><a href=\"https://s4.51cto.com/oss/202004/10/2030845734e792bc782337db9261c03d.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389758\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p>理由：</p> \n<ul>\n <li>&nbsp;并不是说使用了is null 或者 is not null 就会不走索引了，这个跟mysql版本以及查询成本都有关。</li>\n</ul> \n<p>如果mysql优化器发现，走索引比不走索引成本还要高，肯定会放弃索引，这些条件 ！=，&gt;isnull，isnotnull经常被认为让索引失效，其实是因为一般情况下，查询的成本高，优化器自动放弃索引的。</p> \n<ul>\n <li>&nbsp;如果把null值，换成默认值，很多时候让走索引成为可能，同时，表达意思会相对清晰一点。</li>\n</ul> \n<p><strong>19、不要有超过5个以上的表连接</strong></p> \n<ul> \n <li>&nbsp;连表越多，编译的时间和开销也就越大。</li> \n <li>&nbsp;把连接表拆开成较小的几个执行，可读性更高。</li> \n <li>&nbsp;如果一定需要连接很多表才能得到数据，那么意味着糟糕的设计了。</li> \n</ul> \n<p><strong>20、exist&amp;in的合理利用</strong></p> \n<p>假设表A表示某企业的员工表，表B表示部门表，查询所有部门的所有员工，很容易有以下SQL:&nbsp;</p> \n<ol>\n <li>select&nbsp;*&nbsp;from&nbsp;A&nbsp;where&nbsp;deptId&nbsp;in&nbsp;(select&nbsp;deptId&nbsp;from&nbsp;B);&nbsp;</li>\n</ol> \n<p>这样写等价于：</p> \n<p>先查询部门表B</p> \n<p>select deptId from B</p> \n<p>再由部门deptId，查询A的员工</p> \n<p>select * from A where A.deptId = B.deptId</p> \n<p>可以抽象成这样的一个循环：&nbsp; &nbsp; &nbsp;</p> \n<ol> \n <li>List&lt;&gt;&nbsp;resultSet&nbsp;;&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;B.length;i++)&nbsp;{&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;A.length;j++)&nbsp;{&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(A[i].id==B[j].id)&nbsp;{&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultSet.add(A[i]);&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;</li> \n</ol> \n<p>显然，除了使用in，我们也可以用exists实现一样的查询功能，如下：&nbsp;</p> \n<ol>\n <li>select&nbsp;*&nbsp;from&nbsp;A&nbsp;where&nbsp;exists&nbsp;(select&nbsp;1&nbsp;from&nbsp;B&nbsp;where&nbsp;A.deptId&nbsp;=&nbsp;B.deptId);&nbsp;</li>\n</ol> \n<p>因为exists查询的理解就是，先执行主查询，获得数据后，再放到子查询中做条件验证，根据验证结果（true或者false），来决定主查询的数据结果是否得意保留。</p> \n<p>那么，这样写就等价于：</p> \n<p>select * from A,先从A表做循环</p> \n<p>select * from B where A.deptId = B.deptId,再从B表做循环.</p> \n<p>同理，可以抽象成这样一个循环：&nbsp; &nbsp; &nbsp;</p> \n<ol> \n <li>List&lt;&gt;&nbsp;resultSet&nbsp;;&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;i=0;i&lt;A.length;i++)&nbsp;{&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(int&nbsp;j=0;j&lt;B.length;j++)&nbsp;{&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(A[i].deptId==B[j].deptId)&nbsp;{&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;resultSet.add(A[i]);&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;break;&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;</li> \n</ol> \n<p>数据库最费劲的就是跟程序链接释放。假设链接了两次，每次做上百万次的数据集查询，查完就走，这样就只做了两次；相反建立了上百万次链接，申请链接释放反复重复，这样系统就受不了了。即mysql优化原则，就是小表驱动大表，小的数据集驱动大的数据集，从而让性能更优。</p> \n<p>因此，我们要选择最外层循环小的，也就是，如果B的数据量小于A，适合使用in，如果B的数据量大于A，即适合选择exist。</p> \n<p><strong>21、尽量用union all替换 union</strong></p> \n<p>如果检索结果中不会有重复的记录，推荐union all 替换 union。</p> \n<p>反例：</p> \n<ol> \n <li>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;userid=1</li> \n <li>&nbsp;union&nbsp;&nbsp;&nbsp;</li> \n <li>&nbsp;select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;age&nbsp;=&nbsp;10</li> \n</ol> \n<p>正例：</p> \n<ol> \n <li>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;userid=1</li> \n <li>union&nbsp;all&nbsp;</li> \n <li>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;age&nbsp;=&nbsp;10</li> \n</ol> \n<p>理由：</p> \n<ul>\n <li>&nbsp;如果使用union，不管检索结果有没有重复，都会尝试进行合并，然后在输出最终结果前进行排序。如果已知检索结果没有重复记录，使用union all 代替union，这样会提高效率。</li>\n</ul> \n<p><strong>22、索引不宜太多，一般5个以内。</strong></p> \n<ul> \n <li>&nbsp;索引并不是越多越好，索引虽然提高了查询的效率，但是也降低了插入和更新的效率。</li> \n <li>&nbsp;insert或update时有可能会重建索引，所以建索引需要慎重考虑，视具体情况来定。</li> \n <li>&nbsp;一个表的索引数最好不要超过5个，若太多需要考虑一些索引是否没有存在的必要。</li> \n</ul> \n<p><strong>23、尽量使用数字型字段，若只含数值信息的字段尽量不要设计为字符型</strong></p> \n<p>反例：&nbsp;</p> \n<ol>\n <li>`king_id`&nbsp;varchar（20）&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;\'守护者Id\'&nbsp;</li>\n</ol> \n<p>正例：&nbsp;</p> \n<ol>\n <li>`king_id`&nbsp;int(11)&nbsp;NOT&nbsp;NULL&nbsp;COMMENT&nbsp;\'守护者Id\'&nbsp;</li>\n</ol> \n<p>理由：</p> \n<ul>\n <li>&nbsp;相对于数字型字段，字符型会降低查询和连接的性能，并会增加存储开销。</li>\n</ul> \n<p><strong>24、索引不适合建在有大量重复数据的字段上，如性别这类型数据库字段。</strong></p> \n<p>因为SQL优化器是根据表中数据量来进行查询优化的，如果索引列有大量重复数据，Mysql查询优化器推算发现不走索引的成本更低，很可能就放弃索引了。</p> \n<p><strong>25、尽量避免向客户端返回过多数据量。</strong></p> \n<p>假设业务需求是，用户请求查看自己最近一年观看过的直播数据。</p> \n<p>反例：</p> \n<ol> \n <li>//一次性查询所有数据回来&nbsp;</li> \n <li>&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;LivingInfo&nbsp;where&nbsp;watchId&nbsp;=useId&nbsp;and&nbsp;watchTime&nbsp;&gt;=&nbsp;Date_sub(now(),Interval&nbsp;1&nbsp;Y)&nbsp;</li> \n</ol> \n<p>正例：&nbsp;</p> \n<ol> \n <li>//分页查询&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;LivingInfo&nbsp;where&nbsp;watchId&nbsp;=useId&nbsp;and&nbsp;watchTime&gt;=&nbsp;Date_sub(now(),Interval&nbsp;1&nbsp;Y)&nbsp;limit&nbsp;offset，pageSize&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;//如果是前端分页，可以先查询前两百条记录，因为一般用户应该也不会往下翻太多页，&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;select&nbsp;*&nbsp;from&nbsp;LivingInfo&nbsp;where&nbsp;watchId&nbsp;=useId&nbsp;and&nbsp;watchTime&gt;=&nbsp;Date_sub(now(),Interval&nbsp;1&nbsp;Y)&nbsp;limit&nbsp;200&nbsp;;&nbsp;</li> \n</ol> \n<p><strong>26、当在SQL语句中连接多个表时,请使用表的别名，并把别名前缀于每一列上，这样语义更加清晰。</strong></p> \n<p>反例：</p> \n<ol> \n <li>select&nbsp;&nbsp;*&nbsp;from&nbsp;A&nbsp;inner&nbsp;</li> \n <li>join&nbsp;B&nbsp;on&nbsp;A.deptId&nbsp;=&nbsp;B.deptId;&nbsp;</li> \n</ol> \n<p>正例：&nbsp;</p> \n<ol> \n <li>select&nbsp;&nbsp;memeber.name,deptment.deptName&nbsp;from&nbsp;A&nbsp;member&nbsp;inner&nbsp;</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;join&nbsp;B&nbsp;deptment&nbsp;on&nbsp;member.deptId&nbsp;=&nbsp;deptment.deptId;&nbsp;</li> \n</ol> \n<p><strong>27、尽可能使用varchar/nvarchar 代替 char/nchar。</strong></p> \n<p>反例：&nbsp;</p> \n<ol>\n <li>`deptName`&nbsp;char(100)&nbsp;DEFAULT&nbsp;NULL&nbsp;COMMENT&nbsp;\'部门名称\'&nbsp;</li>\n</ol> \n<p>正例：</p> \n<ol>\n <li>`deptName`&nbsp;varchar(100)&nbsp;DEFAULT&nbsp;NULL&nbsp;COMMENT&nbsp;\'部门名称\'&nbsp;</li>\n</ol> \n<p>理由：</p> \n<ul> \n <li>&nbsp;因为首先变长字段存储空间小，可以节省存储空间。</li> \n <li>&nbsp;其次对于查询来说，在一个相对较小的字段内搜索，效率更高。</li> \n</ul> \n<p><strong>28、为了提高group by 语句的效率，可以在执行到该语句前，把不需要的记录过滤掉。</strong></p> \n<p>反例：&nbsp;</p> \n<ol> \n <li>select&nbsp;job，avg（salary）&nbsp;from&nbsp;employee&nbsp;&nbsp;group&nbsp;by&nbsp;job&nbsp;having&nbsp;job&nbsp;=\'president\'</li> \n <li>&nbsp;&nbsp;&nbsp;&nbsp;or&nbsp;job&nbsp;=&nbsp;\'managent\'</li> \n</ol> \n<p>正例：&nbsp;</p> \n<ol> \n <li>select&nbsp;job，avg（salary）&nbsp;from&nbsp;employee&nbsp;where&nbsp;job&nbsp;=\'president\'</li> \n <li>&nbsp;&nbsp;&nbsp;or&nbsp;job&nbsp;=&nbsp;\'managent\'&nbsp;group&nbsp;by&nbsp;job；&nbsp;</li> \n</ol> \n<p><strong>29、如果字段类型是字符串，where时一定用引号括起来，否则索引失效</strong></p> \n<p>反例：</p> \n<ol>\n <li>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;userid&nbsp;=123;&nbsp;</li>\n</ol> \n<p><a href=\"https://s2.51cto.com/oss/202004/10/d94cbdb6ccd459740db6bbd7339820a1.jpg\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389756\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p>正例：</p> \n<ol>\n <li>select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;userid&nbsp;=\'123\';&nbsp;</li>\n</ol> \n<p><a href=\"https://s1.51cto.com/oss/202004/10/4b389a3f8c31a31561dab62345c3ef18.jpg\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389759\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p> \n<p>理由：</p> \n<ul>\n <li>&nbsp;为什么第一条语句未加单引号就不走索引了呢？这是因为不加单引号时，是字符串跟数字的比较，它们类型不匹配，MySQL会做隐式的类型转换，把它们转换为浮点数再做比较。</li>\n</ul> \n<p><strong>30、使用explain 分析你SQL的计划</strong></p> \n<p>日常开发写SQL的时候，尽量养成一个习惯吧。用explain分析一下你写的SQL，尤其是走不走索引这一块。&nbsp;</p> \n<ol>\n <li>explain&nbsp;select&nbsp;*&nbsp;from&nbsp;user&nbsp;where&nbsp;userid&nbsp;=10086&nbsp;or&nbsp;age&nbsp;=18;&nbsp;</li>\n</ol> \n<p><a href=\"https://s5.51cto.com/oss/202004/10/30086e4b3e16cc39353b1b8c4429ce57.png\" rel=\"nofollow noreferrer\"><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022389761\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></a></p>', 'https://segmentfault.com/img/remote/1460000022389744', '3f69fcc9b13843d1910b3dac597f5215', '34b18c0fcab44fec86f4a5d8f9845545,1a77ff8ac4c54e58b5e6b22210cff64f', '0', '3', '1', '2020-04-16 16:48:55', '2020-04-16 16:48:55');
INSERT INTO `tb_recommend` VALUES ('8b639ad7aa9c4b99ae4f251d259ac8e5', '通过语音检测新冠？新方式还有待验证', '近日两所知名的高校，卡内基梅隆大学（CMU）和剑桥大学，不约而同地使用了一种新的方式：通过 AI 系统分析声音信息，来检测被 COVID-19 感染的风险。', '<p>新冠肺炎疫情在海外迎来了爆发之势，而检测手段的繁琐和设备的短缺，也成了疫情防控过程中的拦路虎。</p> \n<p>许多媒体都报道，检测不力是多国无法有效追踪疫情，导致病例迅速激增的一个原因。</p> \n<p>近日两所知名的高校，卡内基梅隆大学（CMU）和剑桥大学，不约而同地使用了一种新的方式：通过 AI 系统分析声音信息，来检测被 COVID-19 感染的风险。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXpf\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"截屏2020-04-02 上午10.48.07.png\" title=\"截屏2020-04-02 上午10.48.07.png\"></span></p> \n<h2>CMU：几分钟就可给出结果</h2> \n<p>在卡内基梅隆大学给出的测试器 COVID Voice Detector 中，需要完成几种声音的录制，仅需几分钟即可得到感染风险的结果。</p> \n<p>进入网站注册后，需要进入个人情况的填写。其中涉及的信息包括人种，年龄，健康状况，是否确诊或确诊过等信息。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrE\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"b8280c86652752577b4e6b1fe53cfd99.jpg\" title=\"b8280c86652752577b4e6b1fe53cfd99.jpg\"></span></p> \n<ul>\n <li><em>需要填入身体健康状况的信息</em></li>\n</ul> \n<p>上述信息填写完毕后，需要录制咳嗽、英文元音的发音，数字和字母表朗读等语音信息。</p> \n<p>而模型经过了确诊者和正常测试者的一些数据的训练，可以对新输入的声音进行分类的匹配。</p> \n<p>最终会返回一个分数，表明所录制的声音，和收集到的 COVID-19 患者数据相比，感染特征相符合的程度。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrK\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"截屏2020-04-02 上午10.49.36.png\" title=\"截屏2020-04-02 上午10.49.36.png\"></span></p> \n<ul>\n <li><em>最终呈现出来的结果</em></li>\n</ul> \n<p>为了让系统的判断尽可能准确，必须拥有足够多的训练数据，而且还要涵盖多元化的信息，研究人员正在倡议更多的志愿者参与进来。</p> \n<p>此外，他们称系统具备可扩展性，如声音来自其他呼吸系统疾病的人，算法就可学到该类疾病的声音特征。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrL\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"0003KQXQA9IRA768-C324-F4.jpg\" title=\"0003KQXQA9IRA768-C324-F4.jpg\"></span></p> \n<ul>\n <li><em>新闻报道中的音源也被采用</em></li>\n</ul> \n<p>测试器地址：<br><a href=\"https://cvd.lti.cmu.edu/cvd/\" rel=\"nofollow noreferrer\">https://cvd.lti.cmu.edu/cvd/</a></p> \n<p>发稿前访问该网站，提示因为在更新和维护的原因暂时关闭，相关负责人表示，有望在本周末再次上线。</p> \n<h2>剑桥大学：还仅仅是收集数据</h2> \n<p>和卡内基梅隆大学类似，剑桥大学也推出了用声音检测 COVID-19 的项目。但稍有不同的是，剑桥大学仅仅还是只是收集数据，还不提供检测的结果。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrN\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"截屏2020-04-09 下午6.15.38.png\" title=\"截屏2020-04-09 下午6.15.38.png\"></span></p> \n<ul>\n <li><em>项目网页的提示：贡献声音，助力科学，保证安全</em></li>\n</ul> \n<p>系统收集数据的方式相差不大，需要填写基本资料和医疗信息，并通过手机麦克风采集语音信息作为训练样本。</p> \n<p>同样地，系统也会调查用户的身体健康情况，比如是否发烧、是否感染过等信息。需录制的项目有呼气声、咳嗽声和阅读文本的声音。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrV\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"截屏2020-04-09 下午6.30.50.png\" title=\"截屏2020-04-09 下午6.30.50.png\"></span></p> \n<ul>\n <li><em>需要录制的声音内容</em></li>\n</ul> \n<p>项目负责人 Cecilia Mascolo 教授解释说，由于该项研究的大型数据集非常少，为了提供更好的算法以用于早期检测，需要收集到足够多的数据量。</p> \n<p>他还表示到，数据量累计之后，即便没有足够冠状病毒阳性病例，还可以找到与其他呼吸道疾病有关的信息。</p> \n<p>该项目的最终目标是，开发出可自动检测疾病的机器学习算法，以可推广使用的检测 App 来呈现。</p> \n<p>项目地址：<br><a href=\"https://www.covid-19-sounds.org/zh/index.html\" rel=\"nofollow noreferrer\">https://www.covid-19-sounds.o...</a></p> \n<h2>语音取证，能够精准识别吗？</h2> \n<p>两个项目彼此独立，但使用的方式和原理拥有着一些共性。而对于项目的具体原理，双方却都没有给出太多信息。</p> \n<p>卡内基梅隆大学的研究团队，曾长期致力于语音取证技术。他们认为人的声音，受到器官机构状况和健康程度的影响，能揭示生理，心理甚至医学数据。</p> \n<p>受肺炎病毒感染的患者，肺部会发生一些病变，其呼吸模式等参数会受到影响，导致发出的声音出现一些异常特征，对算法而言是一个能够抓取的特点。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrX\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"farge-004.jpg\" title=\"farge-004.jpg\"></span></p> \n<ul>\n <li><em>医生正在检查肺部 CT </em></li>\n</ul> \n<p>剑桥大学的团队，也是由多位专家、博士组成。在项目介绍中他们表示到，新冠肺炎作为一种呼吸系统疾病，感染疾病的人发出的声音会存在一些特征，包括声音，呼吸间隔和咳嗽声等。</p> \n<p>虽然这种方式很新颖，但两个项目都处于初期阶段，在 BBC 的一篇报道中，还使用了「Teething problems」（出牙痛，指代初期困难）来表明此方案的困难。</p> \n<p>不过在之前的研究中，用声音来诊断疾病的案例中，出现了一些成功的案例。</p> \n<p>比如，成立于 2014 年的 ResApp Health，就专注使用机器学习算法来分析咳嗽声，来诊断和测量各种慢性和急性疾病的严重程度。目前取得了一些成果，可对哮喘，肺炎和毛细支气管炎等疾病进行判断。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXrZ\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"ResApp.png\" title=\"ResApp.png\"></span></p> \n<ul>\n <li><em>目前应用已经成熟并投入了使用</em></li>\n</ul> \n<p>另一个叫 Sonde 的公司，在去年还获得了一项语音诊断的美国专利。他们开发的一个平台，通过感测和分析语音中的细微变化，可从讲话中判断患者的健康状况，辅助医生进行诊断抑郁症、痴呆症等病症。</p> \n<p>用声音诊断 COVID-19 的项目，相比已经成熟的研究，除了时间紧迫之外，关于疾病的声音数据也少之又少，所以难度和挑战也不小。</p> \n<h2>存在争议，是否有效还待验证</h2> \n<p>对于两个项目来说，研究没有经过 FDA 或 CDC 的批准，还不能用于正规的医学诊断。</p> \n<p>现阶段的最大目的在于，呼吁更多人（包括确诊者和正常人）贡献自己的声音数据，以推动该研究项目的进展，进而去帮助对新冠等流行病的控制。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXsj\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"GKkKVJoSiLgonX6eCRZGcB (1).jpeg\" title=\"GKkKVJoSiLgonX6eCRZGcB (1).jpeg\"></span></p> \n<ul>\n <li><em>手机使用检测程序时的界面</em></li>\n</ul> \n<p>关于这些研究，也出现了是否会有效的争议。比如不同地区疫情的程度不同，会不会带来模型的分析偏见。而简单的语音录制，虽然方便但收集的语音信息，是否达到了科学分析的要求。</p> \n<p>现在看来，关于系统的专业性和准确度，还需要等待后续的验证。在此之前，没人知道前方的道路，但另一方面，这正是科学探索的魅力所在。</p>', 'https://segmentfault.com/img/bVbFXpf', 'c56940aa8b004dab84568e86900b2ee6', 'c7913adc87544598962767df48355990,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-16 16:55:37', '2020-04-16 16:55:37');
INSERT INTO `tb_recommend` VALUES ('8bde5f4cb8c141f09566296984fed0ff', '宜信技术学院上榜「2019中国技术品牌影响力企业榜」', '12月25日，中国最大的新一代开发者社区和专业技术媒体SegmentFault发布了2019 中国技术品牌影响力企业榜。凭借过去一年对宜信科技成果和技术实践的传播以及在金融科技领域探索方面的积极努力，宜信技术学院登上榜...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbB0rS\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"思否技术品牌影响力企业证书.png\" title=\"思否技术品牌影响力企业证书.png\"></span></p> \n<p>12月25日，中国最大的新一代开发者社区和专业技术媒体SegmentFault发布了2019 中国技术品牌影响力企业榜。凭借过去一年对宜信科技成果和技术实践的传播以及在金融科技领域探索方面的积极努力，宜信技术学院登上榜单前10。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021407202\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>SegmentFault作为中国最大的新一代开发者社区和专业技术媒体，是国内 DGC (Developer Generated Content) 内容最丰富、技术问答板块最活跃的开发者社区。目前已经覆盖和服务了超过 300 万开发者、1000 家科技企业，帮助开发者解决了超过数十万个技术问题，每日增长数千条问答数据。用户原创产生的优质技术文章已累积超过10万篇，上百家科技企业技术团队入驻。每月开发者访问流量超千万，Alexa国内网站排名90位。</p> \n<p>「SF·中国技术品牌影响力企业」是由SegmentFault独家策划，依据社区数百万用户行为数据及技术品牌在国内市场的行为大数据进行分析得出最终榜单排行。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021407203\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>宜信技术学院成立于2017年，专注于分享与传播宜信技术团队的研发实践成果与技术解决方案。经过多年的探索和实践，宜信技术团队沉淀了海量的软件研发经验，特别是在金融科技领域，积极探索软件技术在金融服务与金融安全保障方面的智能化、创新性的技术解决方案，并取得了非常多的技术成果。2019年，围绕“科技支持、科技赋能、科技引领”的理念，宜信技术团队通过数据中台、AI中台等中台化产品的落地，开发出智能聊天机器人等AI产品，对实际业务场景中的用户体验提升起到了非常大的作用。宜信技术学院通过宜信技术成果开源、研发实践经验分享、技术沙龙活动3大核心模块对外输出这些优秀的经验与成果。</p> \n<p>宜信技术学院作为宜信技术团队在软件研发实践经验上的传播窗口，持续专注于宜信技术实践经验的萃取、沉淀与传播，面向金融科技行业及软件研发行业，分享软件技术在宜信业务场景中落地的经验与思路，最终实现技术赋能业务发展和服务升级的目标。</p>', 'https://segmentfault.com/img/bVbB0rS', '1c5851dc916d4e70a60f0c957f548876', '6aec6c8499c44483beecd569d05c7f4b', '0', '3', '1', '2020-04-16 16:59:09', '2020-04-16 16:59:09');
INSERT INTO `tb_recommend` VALUES ('8e2ecf8b34774ec6920c44a1b685a123', '构建微服务开源生态，TARS项目将成立基金会', '在20世纪60至70年代，软件开发人员通常在大型机和小型机上使用单体架构进行软件开发，没有一个应用程序能够满足大多数最终用户的需求。垂直行业使用的软件代码量更小，与其他应用程序的接口更简单，而可伸缩性在...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022016741\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"构建微服务开源生态，TARS项目将成立基金会\" title=\"构建微服务开源生态，TARS项目将成立基金会\"></span></p> \n<h2>导语</h2> \n<p>在20世纪60至70年代，软件开发人员通常在大型机和小型机上使用单体架构进行软件开发，没有一个应用程序能够满足大多数最终用户的需求。垂直行业使用的软件代码量更小，与其他应用程序的接口更简单，而可伸缩性在当时并不是优先考虑的。</p> \n<p>随着互联网的发展，开发人员逐渐将服务层从单体架构中分离出来，逐步产生RPC和C/S架构。但是，当时的架构依旧无法应对不断增长的数据流量，更无法满足大型企业的需求。从20世纪90年代中期开始，分布式架构开始流行起来，面向服务的架构(SOA)越来越占主导地位。在21世纪初，微服务开始出现，一系列基于微服务架构的框架涌现，而TARS于2008年出现。经过10年的大规模使用和迭代，TARS于2018年成为Linux基金会的项目。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022016740\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>图1. 搜索趋势证明对微服务的兴趣呈指数增长</p> \n<h2><strong>关于TARS基金会</strong></h2> \n<p>2020年3月10日，Linux基金会正式宣布，旗下的TARS开源项目将成立TARS基金会。TARS基金会是一个专注于微服务领域的开源基金会，致力于构建一个健康并且开放的微服务开源生态。</p> \n<p><em><a href=\"https://link.zhihu.com/?target=https%3A//v.qq.com/x/page/w0932r98lfj.html\" rel=\"nofollow noreferrer\">点击查看详情视频</a></em></p> \n<h2><strong>一个中立的微服务开源基金会</strong></h2> \n<p>TARS基金会是一个非盈利性的开源基金会，它致力于帮助企业在拓展新领域时拥抱微服务体系架构。它将继续支持自2018年以来在Linux基金会下运作的TARS项目及其社区。Linux基金会为基础设施、开放治理和社区参与支持提供了一个中立的组织，帮助开源微服务项目，使任何行业都能够迅速实现自己的想法。TARS基金会正致力于解决在使用微服务方面可能出现的问题，包括减少开发和服务治理的难度。它旨在解决多编程语言的互通、数据传输、数据存储一致性问题，并在支持海量请求的同时保证高性能。TARS基金会希望吸纳上下游的开源项目，以建立更好的微服务生态。包含但不限于基础设施、存储、开发框架、服务治理、DevOps和基于任何编程语言的应用。</p> \n<h2><strong>它始于成熟的微服务框架</strong></h2> \n<p>现代企业需要一个更好的微服务平台，以更好地实现DevOps实践、更全面的服务治理、更高性能的数据传输、以及面对大量数据请求的存储自动扩缩容以及内置的跨语言互操作性(例如Golang、Java、C++、PHP、Node.js)。为了支持这些不断增长的需求，开发自腾讯 (<a href=\"https://link.zhihu.com/?target=http%3A//0700.HK\" rel=\"nofollow noreferrer\">http://0700.HK</a>)的TARS项目提供了一个成熟的、高性能的RPC框架。除腾讯外，也有其他许多公司为扩展该平台的功能和价值做出了重大贡献。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022016742\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>图2. TARS项目的微服务开源生态</p> \n<p>TARS可以在考虑到易用性和高性能的同时快速构建系统并自动生成代码。TARS支持多种编程语言，包括C++、Golang、Java、Node.js、PHP和Python。TARS可以帮助开发人员和企业以微服务的方式快速构建自己稳定可靠的分布式应用，从而令开发人员只关注业务逻辑，提高运营效率。多语言、敏捷研发、高可用和高效运营的特性使TARS成为企业级产品。TARS在腾讯经过10多年的大规模使用和迭代，广泛应用于腾讯的在线社交、金融服务、边缘计算、汽车、视频、游戏、地图、应用市场和安全等数百项核心业务中。微服务的规模已经超过百万节点，完善了业界标准的DevOps理念和腾讯的海量服务之道。</p> \n<h2><strong>为什么应该加入TARS基金会？</strong></h2> \n<p>加入TARS基金会将为成员组织和项目带来以下好处：</p> \n<h3><strong>社区参与</strong></h3> \n<ul>\n <li>TARS基金会将组织开展一系列活动。TARS基金会的成员将获得更多机会参与开源项目和社区的生态建设，并分享他们的想法和实践案例。</li>\n</ul> \n<h3><strong>思想领袖</strong></h3> \n<ul>\n <li>TARS基金会的成员将能够形成一个圈子，一起帮助基金会打造不断发展的微服务生态。</li>\n</ul> \n<h3><strong>提升营销和品牌影响力</strong></h3> \n<ul>\n <li>会员可以通过TARS基金会的营销计划来扩大在社区中的覆盖面和知名度。</li>\n</ul> \n<p>建立TARS基金会是为了发展和促进开放的微服务生态，它将建立不同的技术兴趣小组以支持其用户社区。TARS基金会还将建立一系列新项目孵化和发展机制。在项目同意加入基金会后，将根据项目情况量身定做合适的孵化和发展路线。在满足所有孵化要求后，TARS基金会将宣布该项目毕业。除了提供技术监督委员会和用户社区外，董事会还会根据项目的实际情况，决策项目发展战略以协助其发展。</p> \n<h2><strong>TARS基金会合作伙伴</strong></h2> \n<p>TARS基金会的目标是助力各垂直行业通过应用微服务来实现他们的想法。截至目前，TARS已经与许多行业建立合作，包括金融科技、游戏、边缘计算、视频、电商和教育等。同时，许多在各行业具有领先水平的公司，如腾讯、Arm、AfterShip、Ampere、API7、Kong和Zenlayer已经成为TARS基金会的成员和合作伙伴。</p> \n<h3><strong>腾讯</strong></h3> \n<p>TARS在腾讯经过10年的大规模使用和迭代，广泛应用于腾讯的在线社交、金融服务、边缘计算、汽车、视频、游戏、地图、应用市场和安全等数百项核心业务中。微服务的规模已经超过百万节点，完善了业界标准的DevOps理念和腾讯的海量服务之道。</p> \n<h3><strong>Arm</strong></h3> \n<p>Arm是世界领先的半导体知识产权(IP)供应商，在过去一年里一直与腾讯合作，将TARS微服务完全移植到Arm架构中。目前移植工作已经完成，并可发布于Akraino Blueprint。AR/VR以及供腾讯内部使用的自动驾驶案例是Arm和腾讯合作的开始。</p> \n<p><strong><em>“我们希望在微服务领域能发挥积极的作用，因此我们选择成为TARS基金会的初始成员。”</em></strong></p> \n<h3><strong>AfterShip</strong></h3> \n<p>AfterShip是一家香港初创公司，通过SaaS模式提供物流跟踪，并支持全球400多项物流服务。</p> \n<p><strong><em>\"我们相信微服务将成为我们产品的一个新概念，TARS基金会可以帮助我们使用微服务技术。\"</em></strong></p> \n<h3><strong>Ampere</strong></h3> \n<p>Ampere专注于云原生硬件的研制开发。Ampere 的愿景是为云和边缘服务器建立新的标准，它需要确保有相应软件可以在其硬件上完美运行，以满足客户的需求。</p> \n<p><strong><em>\"近几年微服务变得非常流行，所以我们选择加入TARS基金会并专注于微服务技术，这将我们离愿景更近一步。\"</em></strong></p> \n<h3><strong>API7（支流科技）</strong></h3> \n<p>API7是一家初创的开源商业化公司，提供云原生微服务API网关，旨在为所有API和微服务提供开源的、高性能、安全，可扩展的平台。</p> \n<p><strong><em>“我们特别愿意参与到开源社区的生态建设中去，和其他成员一起打造微服务的生态系统。”</em></strong></p> \n<h3><strong>Kong</strong></h3> \n<p>Kong是全球最受欢迎的开源微服务API网关，用于保护、管理和编排微服务API。</p> \n<p><em><strong>\"我们期待与TARS基金会的成员合作，一起推动所有行业的微服务使用和创新。\"</strong></em></p> \n<h3><strong>Zenlayer</strong></h3> \n<p>Zenlayer是一家边缘云服务提供商，目标是让企业能够在全球范围内，特别是在新兴市场中，快速改善数字用户的体验。</p> \n<p><strong><em>\"微服务与边缘计算的集成已经很普遍，我们希望与TARS基金会在这方面做更多的研究。\"</em></strong></p> \n<h2><strong>结语</strong></h2> \n<p>TARS基金将会助力构建出一个高效的微服务生态。随着越来越多的技术公司在生产中部署微服务，我们期待推动更多传统行业成功转型。TARS基金会欢迎有更多的公司和个人参与，共同建设更好、更开放的微服务生态。</p> \n<p><strong><em>“TARS基金会将通过开放的管理模式加速微服务生态的创新。Linux基金会非常乐意支持这项事业，并促进它不断的发展。”——Linux基金会执行董事，Jim Zemlin</em></strong></p>', 'https://segmentfault.com/img/remote/1460000022016741', '1894b118d35d44cb8fe8009529c4154b', 'f3eb17e6e5664a97af3e9b1fca12b286,dc85b19b1d3742cabe11b25cce8f79b2', '0', '3', '1', '2020-04-16 16:59:35', '2020-04-16 16:59:35');
INSERT INTO `tb_recommend` VALUES ('8e9d40957be044c9864c0c19c3fb6972', '京喜小程序的高性能打造之路', '京喜小程序自去年双十一上线微信购物一级入口后，时刻迎接着亿级用户量的挑战，细微的体验细节都有可能被无限放大，为此，“极致的页面性能”、“友好的产品体验” 和 “稳定的系统服务” 成为了我们开发团队的最基本执...', '<h2>背景</h2> \n<p>京喜小程序自去年双十一上线微信购物一级入口后，时刻迎接着亿级用户量的挑战，细微的体验细节都有可能被无限放大，为此，“极致的页面性能”、“友好的产品体验” 和 “稳定的系统服务” 成为了我们开发团队的最基本执行原则。</p> \n<p>首页作为小程序的门户，其性能表现和用户留存率息息相关。因此，我们对京喜首页进行了一次全方位的升级改造，从加载、渲染和感知体验几大维度深挖小程序的性能可塑性。</p> \n<p>除此之外，京喜首页在微信小程序、H5、APP 三端都有落地场景，为了提高研发效率，我们使用了 <a href=\"https://taro.aotu.io/\" rel=\"nofollow noreferrer\">Taro</a> 框架实现多端统一，因此下文中有部分内容是和 Taro 框架息息相关的。</p> \n<h2>怎么定义高性能？</h2> \n<p>提起互联网应用性能这个词，很多人在脑海中的词法解析就是，“是否足够快？”，似乎加载速度成为衡量系统性能的唯一指标。但这其实是不够准确的，试想一下，如果一个小程序加载速度非常快，用户花费很短时间就能看到页面的主体内容，但此时搜索框却无法输入内容，功能无法被流畅使用，用户可能就不会关心页面渲染有多快了。所以，我们不应该单纯考虑速度指标而忽略用户的感知体验，而应该全方位衡量用户在使用过程中能感知到的与应用加载相关的每个节点。</p> \n<p>谷歌为 Web 应用定义了以用户为中心的性能指标体系，每个指标都与用户体验节点息息相关：</p> \n<table> \n <thead>\n  <tr> \n   <th>体验</th> \n   <th>指标</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>页面能否正常访问？</td> \n   <td>首次内容绘制 (First Contentful Paint, <strong>FCP</strong>)</td> \n  </tr> \n  <tr> \n   <td>页面内容是否有用？</td> \n   <td>首次有效绘制 (First Meaningful Paint, <strong>FMP</strong>)</td> \n  </tr> \n  <tr> \n   <td>页面功能是否可用？</td> \n   <td>可交互时间 (Time to Interactive, <strong>TTI</strong>)</td> \n  </tr> \n </tbody> \n</table> \n<p>其中，“是否有用？” 这个问题是非常主观的，对于不同场景的系统可能会有完全不一样的回答，所以 <strong>FMP</strong> 是一个比较模糊的概念指标，不存在规范化的数值衡量。</p> \n<p>小程序作为一个新的内容载体，衡量指标跟 Web 应用是非常类似的。对于大多数小程序而言，上述指标对应的含义为：</p> \n<ul> \n <li>FCP：白屏加载结束；</li> \n <li>FMP：首屏渲染完成；</li> \n <li>TTI：所有内容加载完成；</li> \n</ul> \n<p>综上，我们已基本确定了高性能的概念指标，接下来就是如何利用数值指标来描绘性能表现。</p> \n<h3>小程序官方性能指标</h3> \n<p>小程序官方针对小程序性能表现制订了权威的数值指标，主要围绕 <strong>渲染表现</strong>、<strong><code>setData</code> 数据量</strong>、<strong>元素节点数</strong> 和 <strong>网络请求延时</strong> 这几个维度来给予定义（下面只列出部分关键指标）：</p> \n<ul> \n <li>首屏时间不超过 5 秒；</li> \n <li>渲染时间不超过 500ms；</li> \n <li>每秒调用 <code>setData</code> 的次数不超过 20 次；</li> \n <li> <code>setData</code> 的数据在 <code>JSON.stringify</code> 后不超过 256kb；</li> \n <li>页面 WXML 节点少于 1000 个，节点树深度少于 30 层，子节点数不大于 60 个；</li> \n <li>所有网络请求都在 1 秒内返回结果；</li> \n</ul> \n<blockquote>\n 详见 \n <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/audits/performance.html\" rel=\"nofollow noreferrer\">小程序性能评分规则</a> \n</blockquote> \n<p>我们应该把这一系列的官方指标作为小程序的性能及格线，不断地打磨和提升小程序的整体体验，降低用户流失率。另外，这些指标会直接作为小程序体验评分工具的性能评分规则（体验评分工具会根据这些规则的权重和求和公式计算出体验得分）。</p> \n<p>我们团队内部在官方性能指标的基础上，进一步浓缩优化指标系数，旨在对产品体验更高要求：</p> \n<ul> \n <li>首屏时间不超过 2.5 秒；</li> \n <li> <code>setData</code> 的数据量不超过 100kb；</li> \n <li>所有网络请求都在 1 秒内返回结果；</li> \n <li>组件滑动、长列表滚动无卡顿感；</li> \n</ul> \n<h3>体验评分工具</h3> \n<p>小程序提供了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/audits/audits.html\" rel=\"nofollow noreferrer\">体验评分工具（<code>Audits</code> 面板）</a> 来测量上述的指标数据，其集成在开发者工具中，在小程序运行时实时检查相关问题点，并为开发者给出优化建议。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFacd\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"体验评分面板\" title=\"体验评分面板\"></span></p> \n<blockquote>\n 以上截图均来自小程序官方文档\n</blockquote> \n<p>体验评分工具是目前检测小程序性能问题最直接有效的途径，我们团队已经把体验评分作为页面/组件是否能达到精品门槛的重要考量手段之一。</p> \n<h3>小程序后台性能分析</h3> \n<p>我们知道，体验评分工具是在本地运行小程序代码时进行分析，但性能数据往往需要在真实环境和大数据量下才更有说服力。恰巧，<strong>小程序管理平台</strong> 和 <strong>小程序助手</strong> 为开发者提供了大量的真实数据统计。其中，性能分析面板从 <strong>启动性能</strong>、<strong>运行性能</strong> 和 <strong>网络性能</strong> 这三个维度分析数据，开发者可以根据客户端系统、机型、网络环境和访问来源等条件做精细化分析，非常具有考量价值。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFace\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"小程序助手性能分析\" title=\"小程序助手性能分析\"></span></p> \n<blockquote>\n 其中，启动总耗时 = 小程序环境初始化 + 代码包加载 + 代码执行 + 渲染耗时\n</blockquote> \n<h3>第三方测速系统</h3> \n<p>很多时候，宏观的耗时统计对于性能瓶颈点分析往往是杯水车薪，作用甚少，我们需要更细致地针对某个页面某些关键节点作测速统计，排查出暴露性能问题的代码区块，才能更有效地针对性优化。京喜小程序使用的是内部自研的测速系统，支持对地区、运营商、网络、客户端系统等多条件筛选，同时也支持数据可视化、同比分析数据等能力。京喜首页主要围绕 <strong>页面 <code>onLoad</code></strong>、<strong><code>onReady</code></strong>、<strong>数据加载完成</strong>、<strong>首屏渲染完成</strong>、<strong>各业务组件首次渲染完成</strong> 等几个关键节点统计测速上报，旨在全链路监控性能表现。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFacf\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"内部测速系统\" title=\"内部测速系统\"></span></p> \n<blockquote>\n 另外，微信为开发者提供了 \n <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/performanceReport/\" rel=\"nofollow noreferrer\">测速系统</a>，也支持针对客户端系统、网络类型、用户地区等维度统计数据，有兴趣的可以尝试。\n</blockquote> \n<h2>了解小程序底层架构</h2> \n<p>为了更好地为小程序制订性能优化措施，我们有必要先了解小程序的底层架构，以及与 web 浏览器的差异性。</p> \n<p>微信小程序是大前端跨平台技术的其中一种产物，与当下其他热门的技术 React Native、Weex、Flutter 等不同，小程序的最终渲染载体依然是浏览器内核，而不是原生客户端。</p> \n<p>而对于传统的网页来说，UI 渲染和 JS 脚本是在同一个线程中执行，所以经常会出现 “阻塞” 行为。微信小程序基于性能的考虑，启用了<strong>双线程模型</strong>：</p> \n<ul> \n <li> <strong>视图层</strong>：也就是 webview 线程，负责启用不同的 webview 来渲染不同的小程序页面；</li> \n <li> <strong>逻辑层</strong>：一个单独的线程执行 JS 代码，可以控制视图层的逻辑；</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbioD3\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"双线程模型图\" title=\"双线程模型图\"></span></p> \n<blockquote>\n 上图来自小程序官方开发指南\n</blockquote> \n<p>然而，<strong>任何线程间的数据传输都是有延时的</strong>，这意味着逻辑层和视图层间通信是异步行为。除此之外，微信为小程序提供了很多客户端原生能力，在调用客户端原生能力的过程中，微信主线程和小程序双线程之间也会发生通信，这也是一种异步行为。这种异步延时的特性会使运行环境复杂化，稍不注意，就会产出效率低下的编码。</p> \n<p>作为小程序开发者，我们常常会被下面几个问题所困扰：</p> \n<ul> \n <li>小程序启动慢；</li> \n <li>白屏时间长；</li> \n <li>页面渲染慢；</li> \n <li>运行内存不足；</li> \n</ul> \n<p>接下来，我们会结合小程序的底层架构分析出这些问题的根本原因，并针对性地给出解决方案。</p> \n<h2>小程序启动太慢？</h2> \n<p>小程序启动阶段，也就是如下图所示的展示加载界面的阶段。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFacg\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"小程序加载界面\" title=\"小程序加载界面\"></span></p> \n<p>在这个阶段中（包括启动前后的时机），微信会默默完成下面几项工作：</p> \n<p><strong>1. 准备运行环境：</strong></p> \n<p>在小程序启动前，微信会先启动双线程环境，并在线程中完成小程序基础库的初始化和预执行。</p> \n<blockquote>\n 小程序基础库包括 WebView 基础库和 AppService 基础库，前者注入到视图层中，后者注入到逻辑层中，分别为所在层级提供其运行所需的基础框架能力。\n</blockquote> \n<p><strong>2. 下载小程序代码包：</strong></p> \n<p>在小程序初次启动时，需要下载编译后的代码包到本地。如果启动了小程序分包，则只有主包的内容会被下载。另外，代码包会保留在缓存中，后续启动会优先读取缓存。</p> \n<p><strong>3. 加载小程序代码包：</strong></p> \n<p>小程序代码包下载好之后，会被加载到适当的线程中执行，基础库会完成所有页面的注册。</p> \n<blockquote>\n 在此阶段，主包内的所有页面 JS 文件及其依赖文件都会被自动执行。\n <p>在页面注册过程中，基础库会调用页面 JS 文件的 Page 构造器方法，来记录页面的基础信息（包括初始数据、方法等）。</p> \n</blockquote> \n<p><strong>4. 初始化小程序首页：</strong></p> \n<p>在小程序代码包加载完之后，基础库会根据启动路径找到首页，根据首页的基础信息初始化一个页面实例，并把信息传递给视图层，视图层会结合 WXML 结构、WXSS 样式和初始数据来渲染界面。</p> \n<p>综合考虑，为了节省小程序的“点点点”时间（小程序的启动动画是三个圆点循环跑马灯），除了给每位用户发一台高配 5G 手机并顺带提供千兆宽带网络之外，还可以尽量 <strong>控制代码包大小</strong>，缩小代码包的下载时间。</p> \n<h3>无用文件、函数、样式剔除</h3> \n<p>经过多次业务迭代，无可避免的会存在一些弃用的组件/页面，以及不被调用的函数、样式规则，这些冗余代码会白白占据宝贵的代码包空间。而且，目前小程序的打包会将工程下所有文件都打入代码包内，并没有做依赖分析。</p> \n<p>因此，我们需要及时地剔除不再使用的模块，以保证代码包空间利用率保持在较高水平。通过一些工具化手段可以有效地辅助完成这一工作。</p> \n<ul>\n <li><strong>文件依赖分析</strong></li>\n</ul> \n<p>在小程序中，所有页面的路径都需要在小程序代码根目录 <code>app.json</code> 中被声明，类似地，自定义组件也需要在页面配置文件 <code>page.json</code> 中被声明。另外，WXML、WXSS 和 JS 的模块化都需要特定的关键字来声明依赖引用关系。</p> \n<p>WXML 中的 <code>import</code> 和 <code>include</code>：</p> \n<pre><code class=\"jsx\">&lt;!-- A.wxml --&gt;\n&lt;template name=\'A\'&gt;\n  &lt;text&gt;{{text}}&lt;/text&gt;\n&lt;/template&gt;\n\n&lt;!-- B.wxml --&gt;\n&lt;import src=\"A.wxml\"/&gt;\n&lt;template is=\"A\" data=\"{{text: \'B\'}}\"/&gt;</code></pre> \n<pre><code class=\"jsx\">&lt;!-- A.wxml --&gt;\n&lt;text&gt; A &lt;/text&gt;\n\n&lt;!-- B.wxml --&gt;\n&lt;include src=\"A.wxml\"/&gt;\n&lt;text&gt; B &lt;/text&gt;</code></pre> \n<p>WXSS 中的 <code>@import</code>：</p> \n<pre><code class=\"css\">@import \'./A.wxss\'</code></pre> \n<p>JS 中的 <code>require</code>/<code>import</code>：</p> \n<pre><code class=\"js\">const A = require(\'./A\')</code></pre> \n<p>所以，可以说小程序里的所有依赖模块都是有迹可循的，我们只需要利用这些关键字信息递归查找，遍历出文件依赖树，然后把没用的模块剔除掉。</p> \n<ul>\n <li><strong>JS、CSS Tree-Shaking</strong></li>\n</ul> \n<p><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking\" rel=\"nofollow noreferrer\">JS Tree-Shaking</a> 的原理就是借助 <code>Babel</code> 把代码编译成抽象语法树（AST），通过 AST 获取到函数的调用关系，从而把未被调用的函数方法剔除掉。不过这需要依赖 ES module，而小程序最开始是遵循 CommonJS 规范的，这意味着是时候来一波“痛并快乐着”的改造了。</p> \n<p>而 CSS 的 Tree-Shaking 可以利用 <a href=\"https://github.com/purifycss/purifycss\" rel=\"nofollow noreferrer\">PurifyCSS</a> 插件来完成。关于这两项技术，有兴趣的可以“谷歌一下”，这里就不铺开细讲了。</p> \n<p>题外，京东的小程序团队已经把这一系列工程化能力集成在一套 CLI 工具中，有兴趣的可以看看这篇分享：<a href=\"https://mp.weixin.qq.com/s/_NSJTQ-4-8gTnwTVK-tn0A\" rel=\"nofollow noreferrer\">小程序工程化探索</a>。</p> \n<h3>减少代码包中的静态资源文件</h3> \n<p>小程序代码包最终会经过 GZIP 压缩放在 CDN 上，但 GZIP 压缩对于图片资源来说效果非常低。如 <code>JPG</code>、<code>PNG</code> 等格式文件，本身已经被压缩过了，再使用 GZIP 压缩有可能体积更大，得不偿失。所以，除了部分用于容错的图片必须放在代码包（譬如网络异常提示）之外，建议开发者把图片、视频等静态资源都放在 CDN 上。</p> \n<blockquote>\n 需要注意，\n <code>Base64</code> 格式本质上是长字符串，和 CDN 地址比起来也会更占空间。\n</blockquote> \n<h3>逻辑后移，精简业务逻辑</h3> \n<p>这是一个 “痛并快乐着” 的优化措施。“痛” 是因为需要给后台同学提改造需求，分分钟被打；“快乐” 则是因为享受删代码的过程，而且万一出 Bug 也不用背锅了...（开个玩笑）</p> \n<p>通过让后台承担更多的业务逻辑，可以节省小程序前端代码量，同时线上问题还支持紧急修复，不需要经历小程序的提审、发布上线等繁琐过程。</p> \n<p>总结得出，<strong>一般不涉及前端计算的展示类逻辑，都可以适当做后移</strong>。譬如京喜首页中的幕帘弹窗（如下图）逻辑，这里共有 10+ 种弹窗类型，以前的做法是前端从接口拉取 10+ 个不同字段，根据优先级和 “是否已展示”（该状态存储在本地缓存） 来决定展示哪一种，最后代码大概是这样的：</p> \n<pre><code class=\"js\">// 检查每种弹窗类型是否已展示\nPromise.all([\n  check(popup_1),\n  check(popup_2),\n  // ...\n  check(popup_n)\n]).then(result =&gt; {\n  // 优先级排序\n  const queue = [{\n    show: result.popup_1\n    data: data.popup_1\n  }, {\n    show: result.popup_2\n    data: data.popup_2\n  }, \n  // ...\n  {\n    show: result.popup_n\n    data: data.popup_n\n  }]\n})</code></pre> \n<p>逻辑后移之后，前端只需负责拿幕帘字段做展示就可以了，代码变成这样：</p> \n<pre><code class=\"js\">this.setData({\n  popup: data.popup\n})</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFach\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"首页幕帘弹窗\" title=\"首页幕帘弹窗\"></span></p> \n<h3>复用模板插件</h3> \n<p>京喜首页作为电商系统的门户，需要应对各类频繁的营销活动、升级改版等，同时也要满足不同用户属性的界面个性化需求（俗称 “千人千面”）。如何既能减少为应对多样化场景而产生的代码量，又可以提升研发效率，成为燃眉之急。</p> \n<p>类似于组件复用的理念，我们需要提供更丰富的可配置能力，实现更高的代码复用度。参考小时候很喜欢玩的 “乐高” 积木玩具，<strong>我们把首页模块的模板元素作颗粒度更细的划分，根据样式和功能抽象出一块块“积木”原料（称为插件元素）</strong>。当首页模块在处理接口数据时，会启动插件引擎逐个装载插件，最终输出个性化的模板样式，整个流程就好比堆积木。当后续产品/运营需要新增模板时，只要在插件库中挑选插件排列组合即可，不需要额外新增/修改组件内容，也更不会产生难以维护的 <code>if</code> / <code>else</code> 逻辑，so easy～</p> \n<p>当然，要完成这样的插件化改造免不了几个先决条件：</p> \n<ul> \n <li> <strong>用户体验设计的统一</strong>。如果设计风格总是天差地别的，强行插件化只会成为累赘。</li> \n <li> <strong>服务端接口的统一</strong>。同上，如果得浪费大量的精力来兼容不同模块间的接口字段差异，将会非常蛋疼。</li> \n</ul> \n<p>下面为大家提供部分例程来辅助理解。其中，<code>use</code> 方法会接受各类处理钩子最终拼接出一个 <code>Function</code>，在对应模块处理数据时会被调用。</p> \n<pre><code class=\"js\">// bi.helper.js\n\n/**\n * 插件引擎\n * @param {function} options.formatName 标题处理钩子\n * @param {function} options.validList 数据校验器钩子\n */ \nconst use = options =&gt; data =&gt; format(data)\n\n/**\n * 预置插件库\n */ \nnameHelpers = {\n  text: data =&gt; data.text,\n  icon: data =&gt; data.icon\n}\nlistHelpers = {\n  single: list =&gt; list.slice(0, 1),\n  double: list =&gt; list.slice(0, 2)\n}\n\n/**\n * “堆积木”\n */\nexport default {\n  1000: use({\n    formatName: nameHelpers.text,\n    validList: listHelpers.single\n  }),\n\n  1001: use({\n    formatName: nameHelpers.icon,\n    validList: listHelpers.double\n  })\n}</code></pre> \n<pre><code class=\"jsx\">&lt;!-- bi.wxml --&gt;\n&lt;!-- 各模板节点实现 --&gt;\n&lt;template name=\"renderName\"&gt;\n  &lt;view wx:if=\"{{type === \'text\'}}\"&gt; text &lt;/view&gt;\n  &lt;view wx:elif=\"{{type === \'icon\'}}\"&gt; icon &lt;/view&gt;\n&lt;/template&gt;\n\n&lt;view class=\"bi__name\"&gt;\n  &lt;template is=\"renderName\" data=\"{{...data.name}\"/&gt;\n&lt;/view&gt;</code></pre> \n<pre><code class=\"js\">// bi.js\nComponent({\n  ready() {\n    // 根据 tpl 值选择解析函数\n    const formatData = helper[data.tpl]\n    this.setData({\n      data: formatData(data)\n    })\n  }\n})</code></pre> \n<h3>分包加载</h3> \n<p>小程序启动时只会下载主包/独立分包，启用分包可以有效减少下载时间。（独立）分包需要遵循一些原则，详细的可以看官方文档：</p> \n<ul> \n <li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/basic.html\" rel=\"nofollow noreferrer\">使用分包</a></li> \n <li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/independent.html\" rel=\"nofollow noreferrer\">独立分包</a></li> \n</ul> \n<h3>部分页面 h5 化</h3> \n<p>小程序提供了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html\" rel=\"nofollow noreferrer\">web-view</a> 组件，支持在小程序环境内访问网页。当实在无法在小程序代码包中腾出多余空间时，可以考虑降级方案 —— 把部分页面 h5 化。</p> \n<blockquote>\n 小程序和 h5 的通信可以通过 JSSDK 或 postMessage 通道来实现，详见 \n <a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/web-view.html\" rel=\"nofollow noreferrer\">小程序开发文档</a>。\n</blockquote> \n<h2>白屏时间过长？</h2> \n<p>白屏阶段，是指小程序代码包下载完（也就是启动界面结束）之后，页面完成首屏渲染的这一阶段，也就是 FMP (首次有效绘制)。</p> \n<p>FMP 没法用标准化的指标定义，但对于大部分小程序来说，页面首屏展示的内容都需要依赖服务端的接口数据，那么影响白屏加载时间的主要由这两个元素构成：</p> \n<ul> \n <li> <strong>网络资源加载时间</strong>；</li> \n <li> <strong>渲染时间</strong>；</li> \n</ul> \n<h3>启用本地缓存</h3> \n<p>小程序提供了读写本地缓存的接口，数据存储在设备硬盘上。由于本地 I/O 读写（毫秒级）会比网络请求（秒级）要快很多，所以在用户访问页面时，可以优先从缓存中取上一次接口调用成功的数据来渲染视图，待网络请求成功后再覆盖最新数据重新渲染。除此之外，缓存数据还可以作为兜底数据，避免出现接口请求失败时页面空窗，一石二鸟。</p> \n<p>但并非所有场景都适合缓存策略，譬如对数据即时性要求非常高的场景（如抢购入口）来说，展示老数据可能会引发一些问题。</p> \n<p>小程序默认会按照 <strong>不同小程序</strong>、<strong>不同微信用户</strong> 这两个维度对缓存空间进行隔离。诸如京喜小程序首页也采用了缓存策略，会进一步按照 <strong>数据版本号</strong>、<strong>用户属性</strong> 来对缓存进行再隔离，避免信息误展示。</p> \n<h3>数据预拉取</h3> \n<p>小程序官方为开发者提供了一个在小程序冷启动时提前拉取第三方接口的能力：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/ability/pre-fetch.html\" rel=\"nofollow noreferrer\">数据预拉取</a>。</p> \n<blockquote>\n 关于冷启动和热启动的定义可以看 \n <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/runtime/operating-mechanism.html#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%90%AF%E5%8A%A8\" rel=\"nofollow noreferrer\">这里</a> \n</blockquote> \n<p>数据预拉取的原理其实很简单，就是在小程序启动时，微信服务器代理小程序客户端发起一个 HTTP 请求到第三方服务器来获取数据，并且把响应数据存储在本地客户端供小程序前端调取。当小程序加载完成后，只需调用微信提供的 API <code>wx.getBackgroundFetchData</code> 从本地缓存获取数据即可。这种做法可以充分利用小程序启动和初始化阶段的等待时间，使更快地完成页面渲染。</p> \n<p>京喜小程序首页已经在生产环境实践过这个能力，从每日千万级的数据分析得出，预拉取使冷启动时获取到接口数据的时间节点从 2.5s 加速到 1s（提速了 60%）。虽然提升效果非常明显，但这个能力依然存在一些不成熟的地方：</p> \n<ul> \n <li> <strong>预拉取的数据会被强缓存</strong>；<p>由于预拉取的请求最终是由微信的服务器发起的，也许是出于服务器资源限制的考虑，预拉取的数据会缓存在微信本地一段时间，缓存失效后才会重新发起请求。经过真机实测，在微信购物入口冷启动京喜小程序的场景下，预拉取缓存存活了 30 分钟以上，这对于数据实时性要求比较高的系统来说是非常致命的。</p> </li> \n <li> <strong>请求体和响应体都无法被拦截</strong>；<p>由于请求第三方服务器是从微信的服务器发起的，而不是从小程序客户端发起的，所以本地代理无法拦截到这一次真实请求，这会导致开发者无法通过拦截请求的方式来区分获取线上环境和开发环境的数据，给开发调试带来麻烦。</p> <p>小程序内部接口的响应体类型都是 <code>application/octet-stream</code>，即数据格式未知，使本地代理无法正确解析。</p> </li> \n <li> <strong>微信服务器发起的请求没有提供区分线上版和开发版的参数，且没有提供用户 IP 等信息</strong>；</li> \n</ul> \n<p>如果这几个问题点都不会影响到你的场景，那么可以尝试开启预拉取能力，这对于小程序首屏渲染速度是质的提升。</p> \n<h3>跳转时预拉取</h3> \n<p>为了尽快获取到服务端数据，比较常见的做法是在页面 <code>onLoad</code> 钩子被触发时发起网络请求，但其实这并不是最快的方式。从发起页面跳转，到下一个页面 <code>onLoad</code> 的过程中，小程序需要完成一些环境初始化及页面实例化的工作，耗时大概为 300 ~ 400 毫秒。</p> \n<p>实际上，我们可以在发起跳转前（如 <code>wx.navigateTo</code> 调用前），提前请求下一个页面的主接口并存储在全局 <code>Promise</code> 对象中，待下个页面加载完成后从 <code>Promise</code> 对象中读取数据即可。</p> \n<p>这也是双线程模型所带来的优势之一，不同于多页面 web 应用在页面跳转/刷新时就销毁掉 window 对象。</p> \n<h3>分包预下载</h3> \n<p>如果开启了分包加载能力，在用户访问到分包内某个页面时，小程序才会开始下载对应的分包。当处于分包下载阶段时，页面会维持在 “白屏” 的启动态，这用户体验是比较糟糕的。</p> \n<p>幸好，小程序提供了 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/subpackages/preload.html\" rel=\"nofollow noreferrer\">分包预下载</a> 能力，开发者可以配置进入某个页面时预下载可能会用到的分包，避免在页面切换时僵持在 “白屏” 态。</p> \n<h3>非关键渲染数据延迟请求</h3> \n<p>这是关键渲染路径优化的其中一个思路，从缩短网络请求时延的角度加快首屏渲染完成时间。</p> \n<blockquote> \n <a href=\"https://developers.google.com/web/fundamentals/performance/critical-rendering-path\" rel=\"nofollow noreferrer\">关键渲染路径（Critical Rendering Path）</a> 是指在完成首屏渲染的过程中必须发生的事件。\n</blockquote> \n<p>以京喜小程序如此庞大的小程序项目为例，每个模块背后都可能有着海量的后台服务作支撑，而这些后台服务间的通信和数据交互都会存在一定的时延。我们根据京喜首页的页面结构，把所有模块划分成两类：<strong>主体模块</strong>（导航、商品轮播、商品豆腐块等）和 <strong>非主体模块</strong>（幕帘弹窗、右侧挂件等）。</p> \n<p>在初始化首页时，小程序会发起一个聚合接口请求来获取主体模块的数据，而非主体模块的数据则从另一个接口获取，通过拆分的手段来降低主接口的调用时延，同时减少响应体的数据量，缩减网络传输时间。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFaci\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"京喜首页浮层模块\" title=\"京喜首页浮层模块\"></span></p> \n<h3>分屏渲染</h3> \n<p>这也是关键渲染路径优化思路之一，通过延迟非关键元素的渲染时机，为关键渲染路径腾出资源。</p> \n<p>类似上一条措施，继续以京喜小程序首页为例，我们在 <strong>主体模块</strong> 的基础上再度划分出 <strong>首屏模块</strong>（商品豆腐块以上部分） 和 <strong>非首屏模块</strong>（商品豆腐块及以下部分）。当小程序获取到主体模块的数据后，会优先渲染首屏模块，在所有首屏模块都渲染完成后才会渲染非首屏模块和非主体模块，以此确保首屏内容以最快速度呈现。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFacj\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"京喜首页分屏渲染\" title=\"京喜首页分屏渲染\"></span></p> \n<blockquote>\n 为了更好地呈现效果，上面 gif 做了降速处理\n</blockquote> \n<h3>接口聚合，请求合并</h3> \n<p>在小程序中，发起网络请求是通过 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/network/request/wx.request.html\" rel=\"nofollow noreferrer\">wx.request</a> 这个 API。我们知道，在 web 浏览器中，针对同一域名的 HTTP 并发请求数是有限制的；在小程序中也有类似的限制，但区别在于不是针对域名限制，而是针对 API 调用：</p> \n<ul> \n <li> <code>wx.request</code> （HTTP 连接）的最大并发限制是 10 个；</li> \n <li> <code>wx.connectSocket</code> （WebSocket 连接）的最大并发限制是 5 个；</li> \n</ul> \n<p>超出并发限制数目的 HTTP 请求将会被阻塞，需要在队列中等待前面的请求完成，从而一定程度上增加了请求时延。因此，<strong>对于职责类似的网络请求，最好采用节流的方式，先在一定时间间隔内收集数据，再合并到一个请求体中发送给服务端。</strong></p> \n<h3>图片资源优化</h3> \n<p>图片资源一直是移动端系统中抢占大流量的部分，尤其是对于电商系统。优化图片资源的加载可以有效地加快页面响应时间，提升首屏渲染速度。</p> \n<ul>\n <li><strong>使用 WebP 格式</strong></li>\n</ul> \n<p><a href=\"https://developers.google.com/speed/webp\" rel=\"nofollow noreferrer\">WebP</a> 是 Google 推出的一种支持有损/无损压缩的图片文件格式，得益于更优的图像数据压缩算法，其与 JPG、PNG 等格式相比，在肉眼无差别的图片质量前提下具有更小的图片体积（据官方说明，WebP 无损压缩体积比 PNG 小 26%，有损压缩体积比 JPEG 小 25-34%）。</p> \n<blockquote>\n 小程序的 \n <a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/image.html\" rel=\"nofollow noreferrer\">image 组件</a> 支持 JPG、PNG、SVG、WEBP、GIF 等格式。\n</blockquote> \n<ul>\n <li><strong>图片裁剪&amp;降质</strong></li>\n</ul> \n<p>鉴于移动端设备的分辨率是有上限的，很多图片的尺寸常常远大于页面元素尺寸，这非常浪费网络资源（一般图片尺寸 2 倍于页面元素真实尺寸比较合适）。得益于京东内部强大的图片处理服务，我们可以通过资源的命名规则和请求参数来获取服务端优化后的图片：</p> \n<p>裁剪成 100x100 的图片：<code>https://{host}/s100x100_jfs/{file_path}</code>；</p> \n<p>降质 70%：<code>https://{href}!q70</code>；</p> \n<ul>\n <li><strong>图片懒加载、雪碧图（CSS Sprite）优化</strong></li>\n</ul> \n<p>这两者都是比较老生常谈的图片优化技术，这里就不打算细讲了。</p> \n<p>小程序的 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/component/image.html\" rel=\"nofollow noreferrer\">image 组件</a> 自带 <code>lazy-load</code> 懒加载支持。雪碧图技术（CSS Sprite）可以参考 <a href=\"https://www.w3schools.com/css/css_image_sprites.asp\" rel=\"nofollow noreferrer\">w3schools</a> 的教程。</p> \n<ul>\n <li><strong>降级加载大图资源</strong></li>\n</ul> \n<p>在不得不使用大图资源的场景下，我们可以适当使用 “体验换速度” 的措施来提升渲染性能。</p> \n<p>小程序会把已加载的静态资源缓存在本地，当短时间内再次发起请求时会直接从缓存中取资源（与浏览器行为一致）。因此，对于大图资源，<strong>我们可以先呈现高度压缩的模糊图片，同时利用一个隐藏的 <code>&lt;image&gt;</code> 节点来加载原图，待原图加载完成后再转移到真实节点上渲染</strong>。整个流程，从视觉上会感知到图片从模糊到高清的过程，但与对首屏渲染的提升效果相比，这点体验落差是可以接受的。</p> \n<p>下面为大家提供部分例程：</p> \n<pre><code class=\"jsx\">&lt;!-- banner.wxml --&gt;\n&lt;image src=\"{{url}}\" /&gt;\n\n&lt;!-- 图片加载器 --&gt;\n&lt;image\n  style=\"width:0;height:0;display:none\"\n  src=\"{{preloadUrl}}\"\n  bindload=\"onImgLoad\"\n  binderror=\"onErrorLoad\"\n/&gt;</code></pre> \n<pre><code class=\"js\">// banner.js\nComponent({\n  ready() {\n    this.originUrl = \'https://path/to/picture\'  // 图片源地址\n    this.setData({\n      url: compress(this.originUrl)             // 加载压缩降质的图片\n      preloadUrl: this.originUrl                // 预加载原图\n    })\n  },\n  methods: {\n    onImgLoad() {\n      this.setData({\n        url: this.originUrl                       // 加载原图\n      })\n    }\n  }\n})</code></pre> \n<blockquote>\n 注意，具有 \n <code>display: none</code> 样式的 \n <code>&lt;image&gt;</code> 标签只会加载图片资源，但不渲染。\n</blockquote> \n<p>京喜首页的商品轮播模块也采用了这种降级加载方案，在首屏渲染时只会加载第一帧降质图片。以每帧原图 20~50kb 的大小计算，这一措施可以在初始化阶段节省掉几百 kb 的网络资源请求。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFack\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Banner 大图降级加载\" title=\"Banner 大图降级加载\"></span></p> \n<blockquote>\n 为了更好地呈现效果，上面 gif 做了降速处理\n</blockquote> \n<h3>骨架屏</h3> \n<p>一方面，我们可以从降低网络请求时延、减少关键渲染的节点数这两个角度出发，缩短完成 FMP（首次有效绘制）的时间。另一方面，我们也需要从用户感知的角度优化加载体验。</p> \n<p>“白屏” 的加载体验对于首次访问的用户来说是难以接受的，我们可以使用尺寸稳定的骨架屏，来辅助实现真实模块占位和瞬间加载。</p> \n<p>骨架屏目前在业界被广泛应用，京喜首页选择使用灰色豆腐块作为骨架屏的主元素，大致勾勒出各模块主体内容的样式布局。由于微信小程序不支持 SSR（服务端渲染），使动态渲染骨架屏的方案难以实现，因此京喜首页的骨架屏是通过 WXSS 样式静态渲染的。</p> \n<p>有趣的是，京喜首页的骨架屏方案经历了 <strong>“统一管理”</strong> 和 <strong>“（组件）独立管理”</strong> 两个阶段。出于避免对组件的侵入性考虑，最初的骨架屏是由一个完整的骨架屏组件统一管理的：</p> \n<pre><code class=\"jsx\">&lt;!-- index.wxml --&gt;\n&lt;skeleton wx:if=\"{{isLoading}}\"&gt;&lt;/skeleton&gt;\n&lt;block wx:else&gt;\n  页面主体\n&lt;/block&gt;</code></pre> \n<p>但这种做法的维护成本比较高，每次页面主体模块更新迭代，都需要在骨架屏组件中的对应节点同步更新（譬如某个模块的尺寸被调整）。除此之外，感官上从骨架屏到真实模块的切换是跳跃式的，这是因为骨架屏组件和页面主体节点之间的关系是整体条件互斥的，只有当页面主体数据 Ready（或渲染完毕）时才会把骨架屏组件销毁，渲染（或展示）主体内容。</p> \n<p>为了使用户感知体验更加丝滑，我们把骨架屏元素拆分放到各个业务组件中，骨架屏元素的显示/隐藏逻辑由业务组件内部独立管理，这就可以轻松实现 “谁跑得快，谁先出来” 的并行加载效果。除此之外，骨架屏元素与业务组件共用一套 WXML 节点，且相关样式由公共的 <code>sass</code> 模块集中管理，业务组件只需要在适当的节点挂上 <code>skeleton</code> 和 <code>skeleton__block</code> 样式块即可，极大地降低了维护成本。</p> \n<pre><code class=\"jsx\">&lt;!-- banner.wxml --&gt;\n&lt;view class=\"{{isLoading ? \'banner--skeleton\' : \'\'}}\"&gt;\n  &lt;view class=\"banner_wrapper\"&gt;&lt;/view&gt;\n&lt;/view&gt;</code></pre> \n<pre><code class=\"scss\">// banner.scss\n.banner--skeleton {\n  @include skeleton;\n  .banner_wrapper {\n    @include skeleton__block;\n  }\n}</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFacl\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"京喜首页骨架屏\" title=\"京喜首页骨架屏\"></span></p> \n<blockquote>\n 上面的 gif 在压缩过程有些小问题，大家可以直接访问【京喜】小程序体验骨架屏效果。\n</blockquote> \n<h2>如何提升渲染性能？</h2> \n<p>当调用 <code>wx.navigateTo</code> 打开一个新的小程序页面时，小程序框架会完成这几步工作：</p> \n<p><strong>1. 准备新的 webview 线程环境，包括基础库的初始化；</strong></p> \n<p><strong>2. 从逻辑层到视图层的初始数据通信；</strong></p> \n<p><strong>3. 视图层根据逻辑层的数据，结合 WXML 片段构建出节点树（包括节点属性、事件绑定等信息），最终与 WXSS 结合完成页面渲染；</strong></p> \n<p>由于微信会提前开始准备 webview 线程环境，所以小程序的渲染损耗主要在后两者 <strong>数据通信</strong> 和 <strong>节点树创建/更新</strong> 的流程中。相对应的，比较有效的渲染性能优化方向就是：</p> \n<ul> \n <li><strong>降低线程间通信频次；</strong></li> \n <li><strong>减少线程间通信的数据量；</strong></li> \n <li><strong>减少 WXML 节点数量；</strong></li> \n</ul> \n<h3>合并 <code>setData</code> 调用</h3> \n<p>尽可能地把多次 <code>setData</code> 调用合并成一次。</p> \n<p>我们除了要从编码规范上践行这个原则，还可以通过一些技术手段降低 <code>setData</code> 的调用频次。譬如，把同一个时间片（<a href=\"https://github.com/aooy/blog/issues/5\" rel=\"nofollow noreferrer\">事件循环</a>）内的 <code>setData</code> 调用合并在一起，Taro 框架就使用了这个优化手段。</p> \n<p>在 Taro 框架下，调用 <code>setState</code> 时提供的对象会被加入到一个数组中，当下一次事件循环执行的时候再把这些对象合并一起，通过 <code>setData</code> 传递给原生小程序。</p> \n<pre><code class=\"js\">// 小程序里的时间片 API\nconst nextTick = wx.nextTick ? wx.nextTick : setTimeout;</code></pre> \n<h3>只把与界面渲染相关的数据放在 <code>data</code> 中</h3> \n<p>不难得出，<code>setData</code> 传输的数据量越多，线程间通信的耗时越长，渲染速度就越慢。根据微信官方测得的数据，传输时间和数据量大体上呈正相关关系：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbnKtu\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"数据传输时间与数据量关系图\" title=\"数据传输时间与数据量关系图\"></span></p> \n<blockquote>\n 上图来自小程序官方开发指南\n</blockquote> \n<p>所以，与视图层渲染无关的数据尽量不要放在 <code>data</code> 中，可以放在页面（组件）类的其他字段下。</p> \n<h3>应用层的数据 diff</h3> \n<p>每当调用 <code>setData</code> 更新数据时，会引起视图层的重新渲染，小程序会结合新的 <code>data</code> 数据和 WXML 片段构建出新的节点树，并与当前节点树进行比较得出最终需要更新的节点（属性）。</p> \n<p>即使小程序在底层框架层面已经对节点树更新进行了 diff，但我们依旧可以优化这次 diff 的性能。譬如，在调用 <code>setData</code> 时，提前确保传递的所有新数据都是有变化的，也就是针对 data 提前做一次 diff。</p> \n<p>Taro 框架内部做了这一层优化。在每次调用原生小程序的 <code>setData</code> 之前，Taro 会把最新的 state 和当前页面实例的 data 做一次 diff，筛选出有必要更新的数据再执行 <code>setData</code>。</p> \n<blockquote>\n 附 Taro 框架的 \n <a href=\"https://nervjs.github.io/taro/docs/optimized-practice.html#%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%95%B0%E6%8D%AE-diff\" rel=\"nofollow noreferrer\">数据 diff 规则</a> \n</blockquote> \n<h3>去掉不必要的事件绑定</h3> \n<p>当用户事件（如 <code>Click</code>、<code>Touch</code> 事件等）被触发时，视图层会把事件信息反馈给逻辑层，这也是一个线程间通信的过程。但，如果没有在逻辑层中绑定事件的回调函数，通信将不会被触发。</p> \n<p>所以，尽量减少不必要的事件绑定，尤其是像 <code>onPageScroll</code> 这种会被频繁触发的用户事件，会使通信过程频繁发生。</p> \n<h3>去掉不必要的节点属性</h3> \n<p>组件节点支持附加自定义数据 <code>dataset</code>（见下面例子），当用户事件被触发时，视图层会把事件 <code>target</code> 和 <code>dataset</code> 数据传输给逻辑层。那么，当自定义数据量越大，事件通信的耗时就会越长，所以应该避免在自定义数据中设置太多数据。</p> \n<pre><code class=\"jsx\">&lt;!-- wxml --&gt;\n&lt;view\n  data-a=\'A\'\n  data-b=\'B\'\n  bindtap=\'bindViewTap\'\n&gt;\n  Click Me!\n&lt;/view&gt;</code></pre> \n<pre><code class=\"js\">// js\nPage({\n  bindViewTap(e) {\n    console.log(e.currentTarget.dataset)\n  }\n})</code></pre> \n<h3>适当的组件颗粒度</h3> \n<p>小程序的组件模型与 <a href=\"https://developer.mozilla.org/zh-CN/docs/Web/Web_Components\" rel=\"nofollow noreferrer\">Web Components</a> 标准中的 ShadowDOM 非常类似，每个组件都有独立的节点树，拥有各自独立的逻辑空间（包括独立的数据、<code>setData</code> 调用、<code>createSelectorQuery</code> 执行域等）。</p> \n<p>不难得出，如果自定义组件的颗粒度太粗，组件逻辑过重，会影响节点树构建和新/旧节点树 diff 的效率，从而影响到组件内 <code>setData</code> 的性能。另外，如果组件内使用了 <code>createSelectorQuery</code> 来查找节点，过于庞大的节点树结构也会影响查找效率。</p> \n<p>我们来看一个场景，京喜首页的 “京东秒杀” 模块涉及到一个倒计时特性，是通过 <code>setInterval</code> 每秒调用 <code>setData</code> 来更新表盘时间。我们通过把倒计时抽离出一个基础组件，可以有效降低频繁 <code>setData</code> 时的性能影响。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFacm\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"京东秒杀\" title=\"京东秒杀\"></span></p> \n<p>适当的组件化，既可以减小数据更新时的影响范围，又能支持复用，何乐而不为？诚然，并非组件颗粒度越细越好，组件数量和小程序代码包大小是正相关的。尤其是对于使用编译型框架（如 Taro）的项目，每个组件编译后都会产生额外的运行时代码和环境 polyfill，so，为了代码包空间，请保持理智...</p> \n<h3>事件总线，替代组件间数据绑定的通信方式</h3> \n<p>WXML 数据绑定是小程序中父组件向子组件传递动态数据的较为常见的方式，如下面例程所示：<code>Component A</code> 组件中的变量 <code>a</code>、<code>b</code> 通过组件属性传递给 <code>Component B</code> 组件。在此过程中，不可避免地需要经历一次 <code>Component A</code> 组件的 <code>setData</code> 调用方可完成任务，这就会产生线程间的通信。“合情合理”，但，如果传递给子组件的数据只有一部分是与视图渲染有关呢？</p> \n<pre><code class=\"jsx\">&lt;!-- Component A --&gt;\n&lt;component-b prop-a=\"{{a}}\" prop-b=\"{{b}}\" /&gt;</code></pre> \n<pre><code class=\"js\">// Component B\nComponent({\n  properties: {\n    propA: String,\n    propB: String,\n  },\n  methods: {\n    onLoad: function() {\n      this.data.propA\n      this.data.propB\n    }\n  }\n})</code></pre> \n<p>推荐一种特定场景下非常便捷的做法：通过事件总线（EventBus），也就是发布/订阅模式，来完成由父向子的数据传递。其构成非常简单（例程只提供关键代码...）：</p> \n<ul> \n <li> <p>一个全局的事件调度中心</p> <pre><code class=\"js\">class EventBus {\n  constructor() {\n    this.events = {}\n  }\n\n  on(key, cb) { this.events[key].push(cb) }\n\n  trigger(key, args) { \n    this.events[key].forEach(function (cb) {\n      cb.call(this, ...args)\n    })\n  }\n  \n  remove() {}\n}\n\nconst event = new EventBus()</code></pre> </li> \n <li> <p>事件订阅者</p> <pre><code class=\"js\">// 子组件\nComponent({\n  created() {\n    event.on(\'data-ready\', (data) =&gt; { this.setData({ data }) })\n  }\n})</code></pre> </li> \n <li> <p>事件发布者</p> <pre><code class=\"js\">// Parent\nComponent({\n  ready() {\n    event.trigger(\'data-ready\', data)\n  }\n})</code></pre> </li> \n</ul> \n<p><strong>子组件被创建时事先监听数据下发事件，当父组件获取到数据后触发事件把数据传递给子组件</strong>，这整个过程都是在小程序的逻辑层里同步执行，比数据绑定的方式速度更快。</p> \n<p>但并非所有场景都适合这种做法。像京喜首页这种具有 <strong>“数据单向传递”</strong>、<strong>“展示型交互”</strong> 特性、且 <strong>一级子组件数量庞大</strong> 的场景，使用事件总线的效益将会非常高；但若是频繁 “双向数据流“ 的场景，用这种方式会导致事件交错难以维护。</p> \n<p>题外话，Taro 框架在处理父子组件间数据传递时使用的是观察者模式，通过 <code>Object.defineProperty</code> 绑定父子组件关系，当父组件数据发生变化时，会递归通知所有后代组件检查并更新数据。这个通知的过程会同步触发数据 diff 和一些校验逻辑，每个组件跑一遍大概需要 5 ~ 10 ms 的时间。所以，如果组件量级比较大，整个流程下来时间损耗还是不小的，我们依旧可以尝试事件总线的方案。</p> \n<h3>组件层面的 diff</h3> \n<p>我们可能会遇到这样的需求，多个组件之间位置不固定，支持随时随地灵活配置，京喜首页也存在类似的诉求。</p> \n<p>京喜首页主体可被划分为若干个业务组件（如搜索框、导航栏、商品轮播等），这些业务组件的顺序是不固定的，今天是搜索框在最顶部，明天有可能变成导航栏在顶部了（夸张了...）。我们不可能针对多种顺序可能性提供多套实现，这就需要用到小程序的自定义模板 <code>&lt;template&gt;</code>。</p> \n<p>实现一个支持调度所有业务组件的模板，根据后台下发的模块数组按序循环渲染模板，如下面例程所示。</p> \n<pre><code class=\"jsx\">&lt;!-- index.wxml --&gt;\n&lt;template name=\"render-component\"&gt;\n  &lt;search-bar wx:if=\"{{compId === \'SearchBar\'}}\" floor-id=\"{{index}}\" /&gt;\n  &lt;nav-bar wx:if=\"{{compId === \'NavBar\'}}\" floor-id=\"{{index}}\" /&gt;\n  &lt;banner wx:if=\"{{compId === \'Banner\'}}\" floor-id=\"{{index}}\" /&gt;\n  &lt;icon-nav wx:if=\"{{compId === \'IconNav\'}}\" floor-id=\"{{index}}\" /&gt;\n&lt;/template&gt;\n\n&lt;view\n  class=\"component-wrapper\"\n  wx:for=\"{{comps}}\"\n  wx:for-item=\"comp\"\n&gt;\n  &lt;template is=\"render-component\" data=\"{{...comp}}\"/&gt;\n&lt;/view&gt;</code></pre> \n<pre><code class=\"js\">// search-bar.js\nComponent({\n  properties: {\n    floorId: Number,\n  },\n  created() {\n    event.on(\'data-ready\', (comps) =&gt; {\n      const data = comps[this.data.floorId] // 根据楼层位置取数据\n    })\n  }\n})</code></pre> \n<p>貌似非常轻松地完成需求，但值得思考的是：<strong>如果组件顺序调整了，所有组件的生命周期会发生什么变化？</strong></p> \n<p>假设，上一次渲染的组件顺序是 <code>[\'search-bar\'，\'nav-bar\'，\'banner\', \'icon-nav\']</code>，现在需要把 <code>nav-bar</code> 组件去掉，调整为 <code>[\'search-bar\'，\'banner\', \'icon-nav\']</code>。经实验得出，<strong>当某个组件节点发生变化时，其前面的组件不受影响，其后面的组件都会被销毁重新挂载。</strong></p> \n<p>原理很简单，每个组件都有各自隔离的节点树（<code>ShadowTree</code>），页面 body 也是一个节点树。在调整组件顺序时，小程序框架会遍历比较新/旧节点树的差异，于是发现新节点树的 <code>nav-bar</code> 组件节点不见了，就认为该（树）分支下从 <code>nav-bar</code> 节点起发生了变化，往后节点都需要重渲染。</p> \n<p>但实际上，这里的组件顺序是没有变化的，丢失的组件按道理不应该影响到其他组件的正常渲染。所以，我们在 <code>setData</code> 前先进行了新旧组件列表 diff：<strong>如果 <code>newList</code> 里面的组件是 <code>oldList</code> 的子集，且相对顺序没有发生变化，则所有组件不重新挂载</strong>。除此之外，我们还要在接口数据的相应位置填充上空数据，把该组件隐藏掉，done。</p> \n<p>通过组件 diff 的手段，可以有效降低视图层的渲染压力，如果有类似场景的朋友，也可以参考这种方案。</p> \n<h2>内存占用过高？</h2> \n<p>想必没有什么会比小程序 Crash 更影响用户体验了。</p> \n<p><strong>当小程序占用系统资源过高，就有可能会被系统销毁或被微信客户端主动回收</strong>。应对这种尴尬场景，除了提示用户提升硬件性能之外（譬如来京东商城买新手机），还可以通过一系列的优化手段降低小程序的内存损耗。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFacn\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"内存不足弹窗提示\" title=\"内存不足弹窗提示\"></span></p> \n<h3>内存预警</h3> \n<p>小程序提供了监听内存不足告警事件的 API：<a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/device/performance/wx.onMemoryWarning.html\" rel=\"nofollow noreferrer\">wx.onMemoryWarning</a>，旨在让开发者收到告警时及时释放内存资源避免小程序 Crash。然而对于小程序开发者来说，内存资源目前是无法直接触碰的，最多就是调用 <code>wx.reLaunch</code> 清理所有页面栈，重载当前页面，来降低内存负荷（此方案过于粗暴，别冲动，想想就好...）。</p> \n<p>不过内存告警的信息收集倒是有意义的，我们可以把内存告警信息（包括页面路径、客户端版本、终端手机型号等）上报到日志系统，分析出哪些页面 Crash 率比较高，从而针对性地做优化，降低页面复杂度等等。</p> \n<h3>回收后台页面计时器</h3> \n<p>根据双线程模型，小程序每一个页面都会独立一个 webview 线程，但逻辑层是单线程的，也就是所有的 webview 线程共享一个 JS 线程。以至于当页面切换到后台态时，仍然有可能抢占到逻辑层的资源，譬如没有销毁的 <code>setInterval</code>、<code>setTimeout</code> 定时器：</p> \n<pre><code class=\"js\">// Page A\nPage({\n  onLoad() {\n    let i = 0\n    setInterval(() =&gt; { i++ }, 100)\n  }\n})</code></pre> \n<blockquote>\n 即使如小程序的 \n <code>&lt;swiper&gt;</code> 组件，在页面进入后台态时依然是会持续轮播的。\n</blockquote> \n<p>正确的做法是，<strong>在页面 <code>onHide</code> 的时候手动把定时器清理掉，有必要时再在 <code>onShow</code> 阶段恢复定时器</strong>。坦白讲，区区一个定时器回调函数的执行，对于系统的影响应该是微不足道的，但不容忽视的是回调函数里的代码逻辑，譬如在定时器回调里持续 <code>setData</code> 大量数据，这就非常难受了...</p> \n<h3>避免频发事件中的重度内存操作</h3> \n<p>我们经常会遇到这样的需求：广告曝光、图片懒加载、导航栏吸顶等等，这些都需要我们在页面滚动事件触发时实时监听元素位置或更新视图。在了解小程序的双线程模型之后不难发现，页面滚动时 <code>onPageScroll</code> 被频发触发，会使逻辑层和视图层发生持续通信，若这时候再 “火上浇油” 调用 <code>setData</code> 传输大量数据，会导致内存使用率快速上升，使页面卡顿甚至 “假死”。所以，针对频发事件的监听，我们最好遵循以下原则：</p> \n<ul> \n <li><strong><code>onPageScroll</code> 事件回调使用节流；</strong></li> \n <li><strong>避免 CPU 密集型操作，譬如复杂的计算；</strong></li> \n <li><strong>避免调用 <code>setData</code>，或减小 <code>setData</code> 的数据量；</strong></li> \n <li><strong>尽量使用 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/wxml/IntersectionObserver.html\" rel=\"nofollow noreferrer\">IntersectionObserver</a> 来替代 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/wxml/SelectorQuery.html\" rel=\"nofollow noreferrer\">SelectorQuery</a>，前者对性能影响更小；</strong></li> \n</ul> \n<h3>大图、长列表优化</h3> \n<p>据 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/performance/tips.html\" rel=\"nofollow noreferrer\">小程序官方文档</a> 描述，大图片和长列表图片在 iOS 中会引起 WKWebView 的回收，导致小程序 Crash。</p> \n<p>对于大图片资源（譬如满屏的 gif 图）来说，我们只能尽可能对图片进行降质或裁剪，当然不使用是最好的。</p> \n<p>对于长列表，譬如瀑布流，这里提供一种思路：我们可以利用 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/api/wxml/IntersectionObserver.html\" rel=\"nofollow noreferrer\">IntersectionObserver</a> 监听长列表内组件与视窗之间的相交状态，当组件距离视窗大于某个临界点时，销毁该组件释放内存空间，并用等尺寸的骨架图占坑；当距离小于临界点时，再取缓存数据重新加载该组件。</p> \n<p>然而无可避免地，当用户快速滚动长列表时，被销毁的组件可能来不及加载完，视觉上就会出现短暂的白屏。我们可以适当地调整销毁阈值，或者优化骨架图的样式来尽可能提升体验感。</p> \n<p>小程序官方提供了一个 <a href=\"https://developers.weixin.qq.com/miniprogram/dev/extended/functional/recycle-view.html\" rel=\"nofollow noreferrer\">长列表组件</a>，可以通过 <code>npm</code> 包的方式引入，有兴趣的可以尝试。</p> \n<h2>总结</h2> \n<p>结合上述的种种方法论，京喜小程序首页进行全方位升级改造之后给出了答卷：</p> \n<p><strong>1. Audits 审计工具的性能得分 <code>86</code>；</strong></p> \n<p><strong>2. 优化后的首屏渲染完成时间（FMP）：</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFaco\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"优化后的首屏渲染时间\" title=\"优化后的首屏渲染时间\"></span></p> \n<p><strong>3. 优化前后的测速数据对比：</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFacp\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"优化前后的测速数据对比\" title=\"优化前后的测速数据对比\"></span></p> \n<p>然而，业务迭代在持续推进，多样化的用户场景徒增不减，性能优化将成为我们日常开发中挥之不去的原则和主题。本文以微信小程序开发中与性能相关的问题为出发点，基于小程序的底层框架原理，探究小程序性能体验提升的各种可能性，希望能为各位小程序开发者带来参考价值。</p> \n<h2>参考</h2> \n<ul> \n <li><a href=\"https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics\" rel=\"nofollow noreferrer\">User-centric Performance Metrics</a></li> \n <li><a href=\"https://developers.google.com/web/fundamentals/performance/optimizing-javascript/tree-shaking\" rel=\"nofollow noreferrer\">Reduce JavaScript Payloads with Tree Shaking</a></li> \n <li><a href=\"https://developers.weixin.qq.com/ebook?action=get_post_info&amp;docid=0008aeea9a8978ab0086a685851c0a\" rel=\"nofollow noreferrer\">小程序开发指南</a></li> \n <li><a href=\"https://developers.weixin.qq.com/miniprogram/dev/framework/\" rel=\"nofollow noreferrer\">小程序官方文档</a></li> \n <li><a href=\"https://taro.aotu.io/home/in.html\" rel=\"nofollow noreferrer\">Taro 官方文档</a></li> \n <li><a href=\"https://aotu.io/notes/2016/06/23/explore-something-of-webp/index.html\" rel=\"nofollow noreferrer\">探究WebP一些事儿</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s/PZKQD5QuoS1ImeA510-09Q\" rel=\"nofollow noreferrer\">京喜首页（微信购物入口）跨端开发与优化实践</a></li> \n</ul> \n<hr> \n<p>欢迎关注凹凸实验室博客：<a href=\"https://aotu.io/\" rel=\"nofollow noreferrer\">aotu.io</a></p> \n<p>或者关注凹凸实验室公众号（AOTULabs），不定时推送文章：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbA4t5\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"欢迎关注凹凸实验室公众号\" title=\"欢迎关注凹凸实验室公众号\"></span></p>', 'https://segmentfault.com/img/bVbFacd', '1894b118d35d44cb8fe8009529c4154b', 'd79254c4ca5e45dca9d484307c935281,3b375646301546259a8fb29d74ae4447,63c4e1e7ec204b43a62065a3ced4c2ce,7506700dea5a42298b9ecb0ac0aaab41,e0a1c37357374c5b81385440f46da50d', '0', '3', '1', '2020-04-16 16:49:29', '2020-04-16 16:49:29');
INSERT INTO `tb_recommend` VALUES ('8f26ee5067c04793bc947cf0dd915492', 'GitHub 高星项目，帮你在 Linux 上运行 Mac OS 软件！', '原因是在 Linux 系统上做开发，要比 Windous 和 Mac 方便、安全、好用、快捷太多了。但 Linux 一直被人诟病的，是生态不够完善。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFf3x\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>业内有这么一句话，“能够熟练使用 Linux 才算得上是合格的程序员。”</p> \n<p>原因是在 Linux 系统上做开发，要比 Windous 和 Mac 方便、安全、好用、快捷太多了。但 Linux 一直被人诟病的，是生态不够完善。</p> \n<p>像 QQ ，微信，Photoshop，甚至 office 办公三件套，你都很难在 linux 上找到满意的，并且功能和优化相比 Windows 差太多。</p> \n<p>商用桌面应用程序供应商考虑的是性价比，他们不确定是否应该投入时间和经理将他们的 Windows 应用程序或者 Mac 应用程序移植到 Linux 系统当中，毕竟 Linux 的市场规模还很小；但正因为应用程序的不支持，导致 Linux 不被大众使用。</p> \n<p>这可能是一个先有鸡还是先有蛋的问题。</p> \n<p>为了解决这个问题，Linux 的忠实用户们开始尝试一些其他方式，来在 Linux 上运行 Windows 和 Mac OS。比如很久之前推出的 wine，就可以帮助开发者在 Linux 上运行 Windows 应用。今天我们推荐的这个 GitHub 高星项目，可以帮助我们在 Linux 上运行 Mac OS 应用。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFf3z\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>早上刷微博的时候，看到了 GitHubDaily 对这个项目的介绍，觉得很有意思，就了解了一下。</p> \n<p>根据项目官网介绍，Darling 是一个转换层，可让您在 Linux 上运行 MacOS 软件，并且就如同运行原生 Linux 程序一样，不会有模拟器那样的性能问题。该项目有五大特点：</p> \n<blockquote>\n <ol> \n  <li>快速：Darling 无需使用硬件仿真器即可直接运行 macOS 软件；</li> \n  <li>免费：与 Linux 一样，Darling 是免费的开源软件。它在 GitHub 上公开开发，并以 GNU GPL 许可证版本 3 发行；</li> \n  <li>兼容：Darling 实现了完整的 Darwin 环境；</li> \n  <li>易于使用：Darling 为您完成大部分设置。可以直接享受使用您喜欢的软件的乐趣；</li> \n  <li>原生：我们的目标是使 Darling 下运行的应用程序看起来，感觉和行为完全像本机 Linux 应用程序一样，完全集成到 Linux 桌面体验中。</li> \n </ol>\n</blockquote> \n<p>另外，Darling 还支持简单的 GUI 应用，但需要通过一些特殊的设置。目前该项目在 GitHub 上已获得 4.3K Star，214 Fork。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFf3E\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<blockquote>\n 项目官网： \n <a href=\"http://darlinghq.org/\" rel=\"nofollow noreferrer\">http://darlinghq.org/</a>\n <br>GItHub 地址： \n <a href=\"https://github.com/darlinghq/darling\" rel=\"nofollow noreferrer\">https://github.com/darlinghq/...</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCJ1M\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFf3x', '5ca4567d892841b087fac5246effac40', '634b81d655c74cb0adc4d0aa362b8819,753b5aee3913424e81fe2b5299626d8c,410e0ac328ce4db8bebc61f2c565943b', '0', '3', '1', '2020-04-16 16:59:48', '2020-04-16 16:59:48');
INSERT INTO `tb_recommend` VALUES ('9166000a32c34752a4a661fdc3a0105c', '无需额外工具，又小拍的简单抓包教程', '大家可能都听说过一个名词，“抓包”。比如软件开发前后端联调，调用后端接口无反应，这时我们常常会说：“抓个包看看前端传递的数据吧”。又或者我们的网站接入 CDN 之后，想要看一下网站静态资源的缓存时间和自己设...', '<p>大家可能都听说过一个名词，“抓包”。比如软件开发前后端联调，调用后端接口无反应，这时我们常常会说：“抓个包看看前端传递的数据吧”。又或者我们的网站接入 CDN 之后，想要看一下网站静态资源的缓存时间和自己设置的缓存策略是否一致，也会用到抓包。那什么是抓包呢？</p> \n<p>主机之间的数据通信都是通过网络来进行传输，而将网络传输发送与接收的数据包进行截获、重发、编辑、转存等操作，就是抓包。</p> \n<p>抓包经常被用来进行数据截取与观察，用于获取 HTTP 标头、内容、大小等信息来进行分析，对判断软件的 Debug 很大的帮助。所以，学会抓包，对于排查一些网络问题十分重要。</p> \n<h2>主流抓包工具对比</h2> \n<p>先来简单看下有哪些常见的抓包工具，主要有下面几种：</p> \n<ul> \n <li>Charles</li> \n <li>Fiddler</li> \n <li>WireShark</li> \n <li>TcpDump</li> \n <li>Chrome Network</li> \n</ul> \n<p>其中目前主流的抓包工具有：TcpDump、WireShark、Fiddler，下面我们对这几个抓包工具的性能进行一些简单的对比。</p> \n<p><strong>1. TcpDump</strong></p> \n<p>Android 平台下的网络数据抓包工具，Android模拟器中自带 TcpDump 文件。</p> \n<p>用 TcpDump 对网络数据抓包，手机不用走代理——将网络数据包添加到 WireShark 中分析即可。</p> \n<p>缺点：</p> \n<ul> \n <li>手机必须获取 root 权限；</li> \n <li>不能查看实时通信数据——因为抓取的是 dump 出来的文件，而不能实时数据交互；</li> \n <li>获取的数据很多，分析时需要过滤出真正有用的信息。</li> \n</ul> \n<p><strong>2. WireShark</strong></p> \n<p>PC 端截获、分析通过该网卡的所有网络通信的数据包（针对移动端时候，就要对移动端设置代理服务器）强大的工具，完整查看网络中的每层、每个协议、每个数据包的详细组成信息；TCP、UDP、HTTP、HTTPS 等协议的数据包均可获取；</p> \n<p>缺点：</p> \n<ul> \n <li>获取的信息太多，需要手动过滤、进行分析。</li> \n <li>只能查看，不能修改、重发送网络数据包。</li> \n</ul> \n<p><strong>3. Fiddler</strong></p> \n<p>HTTP 协议的代理工具，抓取、分析电脑中所有进出该网卡、与网络进行数据交互的数据（针对移动端抓包时，需要设置代理服务器)，主要针对的是 HTTP/HTTPS 协议；能够清晰查看数据包中的内容——HTTPS中的数据包可以解密出来。</p> \n<p>缺点：</p> \n<ul> \n <li>只适用于一次请求，下次请求需要重新设定</li> \n <li>手动修改需要花费时间，如果程序等待超时，本次设定的 Response 结果失效</li> \n</ul> \n<h2>Chrome Network 抓包介绍</h2> \n<p>上文中可以看到主流的抓包工具都或多或少地存在缺点，那有没有一款界面简单、易操作，可以非常方便的查看网页中所有的网络请求，并审核检查单个资源的属性，比如 HTTP 标头、内容、大小等的抓包工具呢？</p> \n<p>Chrome Network 就可以做到。Chrome Network 是属于 Chrome DevTools 套件中的一个调试工具，下面我来对它的使用做一个简单介绍。</p> \n<p>注：本篇教程适用于使用 Chromium 内核的浏览器，Microsoft Edge 和 Firefox 也有类似的控制面板，在此不再赘述。</p> \n<p><strong>如何打开开发者工具面板</strong></p> \n<ol>\n <li>使用快捷键打开。</li>\n</ol> \n<ul> \n <li>Control+Shift+J 或者 F12 (Windows)</li> \n <li>Command+Option+J (Mac)</li> \n</ul> \n<p>2.通过 [更多工具] - [开发者工具] 打开。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228413\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>打开开发者工具后，切换到 [Network 面板]，面板的构成可查看下图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228412\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li>控制器：可以开启/关闭 Network 工具的网络活动记录功能，以及其它一些配置选项。</li> \n <li>过滤器：过滤请求列表中显示资源。</li> \n <li>概览：以图形化的方式，显示 HTTP 请求响应的时间轴。</li> \n <li>请求列表：网页中每一个资源请求记录，默认时间排序，点击可查看详细信息。</li> \n <li>概要：包含了当前抓取的请求数，传输大小以及传输耗时等信息</li> \n</ul> \n<p>接下来我们就来认识一下各个模块。</p> \n<p><strong>控制器</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228414\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>从左至右按钮的功能依次是：</p> \n<ul> \n <li>停止/开始抓包，红色圆圈代表正在抓包；</li> \n <li>清除请求列表中的所有请求；</li> \n <li>屏幕截图；</li> \n <li>隐藏/显示过滤器窗格；</li> \n <li>查找搜索；</li> \n <li>增大请求列表每一行的行高；</li> \n <li>隐藏/显示概览窗格</li> \n <li>按照框架来整合资源</li> \n <li>跨页面加载保存请求</li> \n <li>停用浏览器缓存</li> \n <li>模拟离线访问</li> \n <li>模拟慢网速访问，可自定义网速</li> \n</ul> \n<p>我们简单的来体验一下其中几个功能的使用。</p> \n<p><strong>场景一：</strong>如何模拟在本地没有缓存的情况下访问网页？</p> \n<p>我们可以打开控制器的 [Disable cache] 功能，重新刷新页面，浏览器会模拟不带缓存的请求访问，保证每一个请求都是向网络中发起的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228415\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景二：</strong>请求列表只记录当前页面的访问请求，如果点击了一个超链接，跳转到另一个网页，这样就会清空之前的记录。能否在点击链接跳转之后，依旧保存之前的请求记录呢？</p> \n<p>我们可以打开控制器的 [Preserve log] 功能，这样在点击链接跳转到新的页面后，跳转前的请求记录依旧会保留，方便我们跟踪请求响应。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228416\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>过滤器</strong></p> \n<p>我们在访问一个网站的时候，可能会有几十个或者上百个请求，这些请求中有些是我们关心的，有些是我们不需要的，这个时候就可以快速的使用过滤器来筛选出我们关心的那些请求。</p> \n<p>过滤器常见的过滤方式就是按类型过滤。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228417\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>默认过滤中已经内置几种类型，比方说我们可以筛选出 JS 类的请求、图片类的请求或者是WebSocket 类型的请求，按住 [Ctrl(Windows)] 或者 [Command(Mac)] 可以同时选择多个过滤类型。<br>那么 [Hide data URLs] 选项是什么意思呢？</p> \n<p>网站开发者很多时候会将一些小的图片或者 CSS 脚本，以 BASE64 格式嵌入到 HTML 中，以减少 HTTP 请求数。当勾选了 Hide data URLs 选项后，就可以隐藏掉请求列表中的像 data: 或者 blob: 类请求。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228418\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>除了以上几个 Chrome 提供的过滤器以外，还可以非常灵活的在过滤框中使用过滤属性进行请求日志的筛选。</p> \n<p>常见的过滤属性可参考下表。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228419\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景一：</strong>打开又拍云官网的时候，我们想筛选网页中来自于不同域名的请求资源，就可以在过滤框中输入 [domain:] ，Chrome 会帮我们自动补齐相关的域名信息。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228420\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景二：</strong>打开的网页中，如何查看哪些请求使用了缓存？使用命令 [is:from-cache] </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228421\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>请求列表</strong></p> \n<p>请求列表默认是按照资源请求发起的时间升序排列的，我们也可以选择按指定列排序，例如 [Waterfall] 列上右键，按照活动时间来进行排序。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228422\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>请求列表中默认每列的含义为：</p> \n<ul> \n <li>Name：请求资源的名称</li> \n <li>Status HTTP：状态码</li> \n <li>Type：请求资源的 MIME 类型</li> \n <li>Initiator：发起请求的对象或进程</li> \n <li>Size：服务器返回的响应大小（包括头体和包体），可显示解压后大小</li> \n <li>Time：总持续时间，从请求的开始到接收响应中的最后一个字节</li> \n <li>Waterfall：各请求相关活动的直观分析图</li> \n</ul> \n<p>我们也可以添加其它的一些列目录，在请求列上右键呼出菜单，可看到更多列选项。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228423\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>此外我们也可以配置自定义列，在请求列上右键呼出菜单-Response Headers- Manage Header Columns 中添加想列出的响应头信息。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228425\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景：</strong>如何自定义显示请求经过了CDN 的哪些节点？</p> \n<p>CDN 会在每一个响应头中添加上Via 响应头，那么我们就可以自定义请求列表显示 Via 列。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228424\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>HTTP 请求与响应</strong></p> \n<p>点击请求列表中的具体的请求，则可以打开请求内容详情，在内容详情中我们可以执行以下操作：</p> \n<ul> \n <li>查看 HTTP 请求/响应头部</li> \n <li>查看 cookie</li> \n <li>预览响应正文，例如查看图像</li> \n <li>查看响应正文</li> \n <li>时间详细分布</li> \n <li>将请求数据复制到剪贴板</li> \n <li>查看未压缩的资源大小，Use Large Request Rows</li> \n</ul> \n<p><strong>场景一：</strong>查看请求的响应与请求报文</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228426\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景二：</strong>预览图片</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228427\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>场景三：</strong>将一个请求导出为 cURL 命令</p> \n<p>在请求上右键呼出菜单，选择 Copy 选项。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022228428\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>以上就是对 Chrome 的 Network 面板的介绍，通过一些场景来帮助大家理解使用面板的功能。相比起 Wireshark 等一些网络抓包工具而言，Chrome Network 更为简单易用，查看 HTTP/2 或者 HTTPS 等请求报文也更为方便，对于前端展示或者网络连接产生的一些问题，定位也更为轻松快捷。</p> \n<h6>推荐阅读</h6> \n<p><a href=\"https://www.upyun.com/tech/article/533/IPv6%20%E6%97%B6%E4%BB%A3%E5%A6%82%E4%BD%95%E9%98%B2%E5%BE%A1%20DDoS%20%E6%94%BB%E5%87%BB%EF%BC%9F.html\" rel=\"nofollow noreferrer\">IPv6 时代如何防御 DDoS 攻击？</a></p> \n<p><a href=\"https://www.upyun.com/tech/article/523/%E4%BA%8C%E7%8B%97%E5%AD%90%20%E3%80%81%E5%88%9D%E6%81%8B%E5%8F%8AHTTPS.html\" rel=\"nofollow noreferrer\">二狗子 、初恋及HTTPS</a></p>', 'https://segmentfault.com/img/remote/1460000022228413', '6fbfa4aaad3a43458f21c8acf0038ac5', 'cc944f24ed5e4383a975481674f255e0,81a4561c1c294e0cae32c9fe6b5dc397,db6b58ae709645f2b64166fd73f2f705,a83bf36999c94af989d2d78048df00b8,63c4e1e7ec204b43a62065a3ced4c2ce', '0', '3', '1', '2020-04-16 16:56:37', '2020-04-16 16:56:37');
INSERT INTO `tb_recommend` VALUES ('92f3953ee5804660833795472e1880a7', '百度开源联邦学习框架 PaddleFL，让大规模分布式集群中部署联邦学习系统更容易', 'PaddleFL是一个基于飞桨（ PaddlePaddle）的开源联邦学习框架。研究人员可以很轻松地用PaddleFL复制和比较不同的联邦学习算法。开发人员也可以从padderFL中获益，因为用PaddleFL在大规模分布式集群中部署联邦学习...', '<p><strong>技术编辑：鸣飞 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFJDQ\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"开源联邦学习框架PaddleFL.jpg\" title=\"开源联邦学习框架PaddleFL.jpg\"></span></p> \n<p>PaddleFL是一个基于飞桨（ PaddlePaddle）的开源联邦学习框架。研究人员可以很轻松地用PaddleFL复制和比较不同的联邦学习算法。开发人员也可以从padderFL中获益，因为用PaddleFL在大规模分布式集群中部署联邦学习系统很容易。</p> \n<p>PaddleFL提供很多联邦学习策略及其在计算机视觉、自然语言处理、推荐算法等领域的应用。此外，PaddleFL还将提供传统机器学习训练策略的应用，例如多任务学习、联邦学习环境下的迁移学习。依靠着PaddlePaddle的大规模分布式训练和Kubernetes对训练任务的弹性调度能力，PaddleFL可以基于全栈开源软件轻松地部署。</p> \n<h4>联邦学习</h4> \n<p>如今，数据变得越来越昂贵，而且跨组织共享原始数据非常困难。联合学习旨在解决组织间数据隔离和数据知识安全共享的问题。联邦学习的概念是由谷歌的研究人员提出的。</p> \n<h4>PaddleFL概述</h4> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022300915\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"PaddleFL概述\" title=\"PaddleFL概述\"></span></p> \n<p>在PaddleFL中，横向和纵向联邦学习策略将根据给出的分类来实现。PaddleFL也将提供在自然语言处理，计算机视觉和推荐算法等领域的应用示例。</p> \n<h4>联邦学习策略</h4> \n<ul> \n <li> <strong>纵向联邦学习</strong>: 带privc的逻辑回归，带第三方privc的神经网络[5]</li> \n <li> <strong>横向联邦学习</strong>: 联邦平均，差分隐私</li> \n</ul> \n<h4>训练策略</h4> \n<ul> \n <li><strong>多任务学习</strong></li> \n <li><strong>迁移学习</strong></li> \n <li><strong>主动学习</strong></li> \n</ul> \n<h4>PaddleFL框架设计</h4> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022300914\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"PaddleFL框架设计\" title=\"PaddleFL框架设计\"></span></p> \n<p>在PaddeFL中，用于定义联邦学习任务和联邦学习训练工作的组件如下：</p> \n<p><strong>编译时</strong></p> \n<ul> \n <li> <strong>FL-Strategy</strong>: 用户可以使用FL-Strategy定义联邦学习策略，例如Fed-Avg[1]。</li> \n <li> <strong>User-Defined-Program</strong>: PaddlePaddle的程序定义了机器学习模型结构和训练策略，如多任务学习。</li> \n <li> <strong>Distributed-Config</strong>: 在联邦学习中，系统会部署在分布式环境中。分布式训练配置定义分布式训练节点信息。</li> \n <li> <strong>FL-Job-Generator</strong>: 给定FL-Strategy, User-Defined Program 和 Distributed Training Config，联邦参数的Server端和Worker端的FL-Job将通过FL Job Generator生成。FL-Jobs 被发送到组织和联邦参数服务器以进行联合训练。</li> \n</ul> \n<p><strong>运行时</strong></p> \n<ul> \n <li> <strong>FL-Server</strong>: 在云或第三方集群中运行的联邦参数服务器。</li> \n <li> <strong>FL-Worker</strong>: 参与联合学习的每个组织都将有一个或多个与联合参数服务器通信的Worker。</li> \n <li> <strong>FL-Scheduler</strong>: 训练过程中起到调度Worker的作用，在每个更新周期前，决定哪些Worker可以参与训练。</li> \n</ul> \n<h4>安装指南和快速入门</h4> \n<p>请参考<a href=\"https://paddlefl.readthedocs.io/en/latest/instruction.html\" rel=\"nofollow noreferrer\">快速开始</a>。</p> \n<h4>Kubernetes简单部署</h4> \n<p>kubectl apply -f ./paddle_fl/examples/k8s_deployment/master.yaml</p> \n<p>请参考<a href=\"https://github.com/PaddlePaddle/PaddleFL/blob/master/paddle_fl/examples/k8s_deployment/README.md\" rel=\"nofollow noreferrer\">K8S部署实例</a></p> \n<p>也可以参考<a href=\"https://github.com/PaddlePaddle/PaddleFL/blob/master/paddle_fl/examples/k8s_deployment/deploy_instruction.md\" rel=\"nofollow noreferrer\">K8S集群申请及kubectl安装</a>配置自己的K8S集群</p> \n<h4>性能测试</h4> \n<p>Gru4Rec [9] 在基于会话的推荐中引入了递归神经网络模型。PaddlePaddle的GRU4RC实现代码在<a href=\"https://github.com/PaddlePaddle/models/tree/develop/PaddleRec/gru4rec\" rel=\"nofollow noreferrer\">https://github.com/PaddlePaddle/models/tree/develop/PaddleRec/gru4rec</a>. 一个基于联邦学习训练Gru4Rec模型的示例请参考<a href=\"https://paddlefl.readthedocs.io/en/latest/examples/gru4rec_examples.html\" rel=\"nofollow noreferrer\">Gru4Rec in Federated Learning</a></p> \n<p><strong>项目地址</strong>：<a href=\"https://github.com/PaddlePaddle/PaddleFL\" rel=\"nofollow noreferrer\">https://github.com/PaddlePadd...</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"SegmentFault思否微信公众号\" title=\"SegmentFault思否微信公众号\"></span></p>', 'https://segmentfault.com/img/bVbFJDQ', '692c6787030d4b8882077b2ab9279c52', '674b70b62fa24c7ca9a671f8e54b8d15,115ec0efd61e4e22942b00b9fd1246b0,d114b152c3b644a6ab136104b4330b6f,406ef08e86cc4caa88239b8e0e4ea758,f3eb17e6e5664a97af3e9b1fca12b286', '0', '3', '1', '2020-04-16 16:59:29', '2020-04-16 16:59:29');
INSERT INTO `tb_recommend` VALUES ('931d082c58fc48b898b4fc1a5e988668', 'AFNetworking源码解析与面试考点延伸', '最近重读了AFNetworking 3.x的源码，算是温故而知新吧。也梳理了一些优秀的代码细节和面试考点，罗列下来，发现这个库小而精致，简直初学者的宝藏库。', '<p>最近重读了AFNetworking 3.x的源码，算是温故而知新吧。也梳理了一些优秀的代码细节和面试考点，罗列下来，发现这个库小而精致，简直初学者的宝藏库。</p> \n<h2>开源库怎么看？</h2> \n<p>先说个题外话，阅读优质的开源代码库，绝对是程序员们快速提升自我的有效途径，而怎样高效率的去阅读源码同样也是一个问题，不知道有没有人和我之前一样，碰到过读倒是读了，但总感觉收获不大的情况。</p> \n<p>这里分享一下我的一些读码经验：</p> \n<ol> \n <li> <p>多思考，多抛出问题，比如说</p> \n  <ul> \n   <li>整体的代码结构是怎样的？类与类之间的关系是怎样的？为什么要这么设计？</li> \n   <li>代码有没有涉及到多线程，其线程模型是怎样的？哪类问题可以适用这种多线程的方案？</li> \n   <li>代码中使用了哪些设计模式？具体是怎么实现的？</li> \n  </ul> </li> \n <li>也可以关注代码细节，遇到不熟悉的用法不要放过，多刨根究底才能夯实基础<p>关于<code>AFNetworking</code>的一些优秀代码细节，我这里也整理了一部分，可以查阅后文</p> </li> \n <li>一定要记笔记和总结，能分享更好。<p>参考费曼学习法，我认为这一点是最好的加深理解和强化记忆的手段。随着年龄的增大，记忆力会有所衰退，有个笔记能够回顾，能节约大把再次记忆的时间。此外，多与人分享还能够提升自己的影响力，与人交流验证，也能够为自己查缺补漏。</p> </li> \n</ol> \n<h2>AFNetworking 3.x的代码结构</h2> \n<p>还是说回到<code>AFNetworking</code>这里，AF的代码结构大部分人应该都了解，这里我简单介绍下。<code>AFNetworking 3.x</code>的代码结构比2.x要简单许多，主要也得益于苹果优化了网络相关的api，整体代码有这么几部分：</p> \n<ul> \n <li> <strong>AFURLSessionManager/AFHTTPSessionManager</strong> <p>这里就是AF代码的核心了，主要负责网络请求的发起，回调处理，是在系统网络相关API上的一层封装。大部分逻辑是在<code>AFURLSessionManager</code>里面处理的，<code>AFHTTPSessionManager</code>则是专为HTTP请求提供了一些便利方法。如果需要扩展其他协议的功能（比如FTP协议），可以考虑从<code>AFURLSessionManager</code>创建一个子类。</p> </li> \n <li> <strong>AFURLRequestSerialization/AFURLResponseSerialization</strong><p>这两兄弟主要处理一些参数序列化相关的工作。<code>AFURLRequestSerialization</code>是将传入的参数构造成<code>NSURLRequest</code>，比如自定义的header，一些post或者get参数等等。 <code>AFURLResponseSerialization</code>主要是将系统返回的<code>NSURLResponse</code>处理成我们需要的responseObject，比如json、xml、image等等</p> </li> \n <li> <strong>AFSecurityPolicy</strong><p>处理https相关的公钥和验证逻辑。目前由于苹果ATS的开启，基本HTTPS已经成为标配。虽然通常直接使用CA来验证服务器公钥的情况下，不需要我们额外做什么配置。但是从这里出发，顺便考察一下HTTPS相关的知识点，感觉也比较常见，具体面试题可看下文</p> </li> \n <li> <strong>AFNetworkReachabilityManager</strong><p>这个其实是比较独立的一个模块了，提供获取当前网络状态的功能。</p> </li> \n <li> <strong>UIKit+AFNetworking</strong><p>这里主要是通过Category来提供了一下UIkit的便利方法</p> </li> \n</ul> \n<h2>AF的一些优质代码细节</h2> \n<p>仔细瞅瞅代码之后，发现常见的OC基础知识在AF里面都有具体应用，挺多还是面试题考点，这里也是做个记录和梳理。</p> \n<ul>\n <li><strong>单例的创建方法</strong></li>\n</ul> \n<pre><code class=\"objc\">+ (instancetype)defaultInstance {\n    static AFImageDownloader *sharedInstance = nil;\n    static dispatch_once_t onceToken;\n    dispatch_once(&amp;onceToken, ^{\n        sharedInstance = [[self alloc] init];\n    });\n    return sharedInstance;\n}</code></pre> \n<p>必知必会，通过dispatch_once来保证多线程调用时，只有一个实例被创建。</p> \n<ul>\n <li><strong>dispatch_sync与dispatch_barrier_sync配合解决并行读串行写问题</strong></li>\n</ul> \n<pre><code class=\"objc\">// 注意是并行队列\nself.requestHeaderModificationQueue = dispatch_queue_create(\"requestHeaderModificationQueue\", DISPATCH_QUEUE_CONCURRENT);\n\n// 串行写，注意barrier block的具体执行时机\ndispatch_barrier_sync(self.requestHeaderModificationQueue, ^{\n    [self.mutableHTTPRequestHeaders setValue:value forKey:field];\n});\n\n// 并行读，注意和上面写操作同时执行时的执行顺序\nNSDictionary __block *value;\ndispatch_sync(self.requestHeaderModificationQueue, ^{\n    value = [NSDictionary dictionaryWithDictionary:self.mutableHTTPRequestHeaders];\n});\n</code></pre> \n<p>必知必会，GCD使用barrier来处理并行读串行写问题的具体用法</p> \n<ul>\n <li><strong>weakSelf与strongSelf的用法</strong></li>\n</ul> \n<pre><code class=\"objc\">__weak __typeof(self)weakSelf = self;\nAFNetworkReachabilityStatusCallback callback = ^(AFNetworkReachabilityStatus status) {\n    __strong __typeof(weakSelf)strongSelf = weakSelf;\n\n    strongSelf.networkReachabilityStatus = status;\n    if (strongSelf.networkReachabilityStatusBlock) {\n        strongSelf.networkReachabilityStatusBlock(status);\n    }\n\n    return strongSelf;\n};</code></pre> \n<p>必知必会，weakSelf避免循环引用，strongSelf保证block内部执行过程中self不会被释放</p> \n<ul>\n <li> <strong>其他用法</strong><p>NSSecureCoding、kvo、swizzle、NSStream、NSProgress、代码注释、pragma mark等等</p> </li>\n</ul> \n<h2>AFNetworking的可能面试考点</h2> \n<p>前面提到阅读开源库时，要多思考多提问题，这里也结合一些面试考题来梳理下</p> \n<h3>AFNetworking 2.x怎么开启常驻子线程？为何需要常驻子线程？</h3> \n<p>这个知识点应该是AF2.x版本面试官比较喜欢问的了，AF2.x版本有个细节，通过runloop开启了一个常驻子线程，具体代码是这样的：</p> \n<pre><code class=\"objc\">+ (void)networkRequestThreadEntryPoint:(id)__unused object {\n    @autoreleasepool {\n        [[NSThread currentThread] setName:@\"AFNetworking\"];\n\n        NSRunLoop *runLoop = [NSRunLoop currentRunLoop];\n        [runLoop addPort:[NSMachPort port] forMode:NSDefaultRunLoopMode];\n        [runLoop run];\n    }\n}\n\n+ (NSThread *)networkRequestThread {\n    static NSThread *_networkRequestThread = nil;\n    static dispatch_once_t oncePredicate;\n    dispatch_once(&amp;oncePredicate, ^{\n        _networkRequestThread = [[NSThread alloc] initWithTarget:self selector:@selector(networkRequestThreadEntryPoint:) object:nil];\n        [_networkRequestThread start];\n    });\n\n    return _networkRequestThread;\n}</code></pre> \n<p>首先，我们要了解为何要开启<strong>常驻</strong>子线程？</p> \n<p><code>NSURLConnection</code>的接口是异步的，然后会在发起的线程回调。而一个子线程，在同步代码执行完成之后，一般情况下，线程就退出了。那么想要接收到<code>NSURLConnection</code>的回调，就必须让子线程至少存活到回调的时机。而AF让线程常驻的原因是，当发起多个http请求的时候，会统一在这个子线程进行回调的处理，所以干脆就让其一直存活下来。</p> \n<p>上面说的一般情况，子线程执行完任务就会退出，那么什么情况下，子线程能够继续存活呢？这就涉及到第二个问题了，AF是如何开启常驻线程的，这里实际上考察的是runloop的基础知识。</p> \n<p>关于runloop，推荐看下<a href=\"https://blog.ibireme.com/2015/05/18/runloop/\" rel=\"nofollow noreferrer\">《深入理解RunLoop》</a>，个人觉得讲得非常详尽。这里简单来说，当runloop发现还有source/timer/observer的时候，runloop就不会退出。所以AF这里就通过给当前runloop添加一个NSMachPort，这个port实际上相对于添加了一个source事件源，这样子线程的runloop就会一直处于循环状态，等待别的线程向这个port发送消息，而实际上AF这里是没有消息发送到这个port的。</p> \n<p>除了AF的这种处理方式，实际上苹果也提供了回调线程的解决方案：</p> \n<pre><code class=\"objc\">// NSURLConnection\n- (void)setDelegateQueue:(nullable NSOperationQueue*) queue\n\n// NSURLSession\n+ (NSURLSession *)sessionWithConfiguration:(NSURLSessionConfiguration *)configuration delegate:(nullable id &lt;NSURLSessionDelegate&gt;)delegate delegateQueue:(nullable NSOperationQueue *)queue;</code></pre> \n<p>苹果提供了接口，可以让你制定一个operationQueue供回调执行。所以AF3.x的时候，就直接创建了一个并发度为1的队列，来处理回调。</p> \n<p><strong>扩展问题：</strong></p> \n<p>既然提到了runloop，可以考虑一下runloop的扩展问题：</p> \n<ul> \n <li>子线程默认有runloop吗？runloop创建和销毁的时机又是什么时候呢？</li> \n <li>runloop有哪些mode呢？滑动时发现定时器没有回调，是因为什么原因呢？</li> \n <li>除了上面这种addPort来保活线程的方法，有无其他方法呢？</li> \n</ul> \n<h3>AFURLSessionManager与NSURLSession的关系，每次都需要新建mananger吗？</h3> \n<p>我们如果仔细查看代码，应该就能得出这样的结论：manager与session是1对1的关系，AF会在manager初始化的时候创建对应的NSURLSession。同样，AF也在注释中写明了可以提供一个配置好的manager单例来全局复用。</p> \n<p>那么复用manager实际上就是复用了session，而复用session可以带来什么好处呢？</p> \n<p>其实iOS9之后，session就开始支持http2.0。而http2.0的一个特点就是多路复用（可参考<a href=\"https://juejin.im/post/5d70848df265da03d871de9c\" rel=\"nofollow noreferrer\">《Http系列(二) Http2中的多路复用》</a>）。所以这里复用session其实就是在利用http2.0的多路复用特点，减少访问同一个服务器时，重新建立tcp连接的耗时和资源。</p> \n<p>官方文档也推荐在不同的功能场景下，使用不同的session。比如：一个session处理普通的请求，一个session处理background请求；1个session处理浏览器公开的请求，一个session专门处理隐私请求等等场景。</p> \n<h3>AFSecurityPolicy如何避免中间人攻击？</h3> \n<p>现在，由于苹果ATS的策略，基本都切到HTTPS了，HTTPS的基本原理还是需要了解一下的，这里不做介绍，需要的可以google查阅一下相关文章。</p> \n<p>通常，首先我们要了解中间人攻击，大体就是黑客通过截获服务器返回的证书，并伪造成自己的证书，通常我们使用的Charles/Fiddler等工具实际上就可以看成中间人攻击。</p> \n<p>解决方案其实也很简单，就是<code>SSL Pinning</code>。<code>AFSecurityPolicy</code>的<code>AFSSLPinningMode</code>就是相关设置项。</p> \n<p><code>SSL Pinning</code>的原理就是需要将服务器的公钥打包到客户端中，tls验证时，会将服务器的证书和本地的证书做一个对比，一致的话才允许验证通过。</p> \n<pre><code class=\"objc\">typedef NS_ENUM(NSUInteger, AFSSLPinningMode) {\n    AFSSLPinningModeNone,\n    AFSSLPinningModePublicKey,    // 只验证证书中的公钥\n    AFSSLPinningModeCertificate,    // 验证证书所有字段，包括有效期之内\n};</code></pre> \n<p>由于数字证书存在有效期，内置到客户端后就存在失效后导致验证失败的问题，所以可以考虑设置为<code>AFSSLPinningModePublicKey</code>的模式，这样的话，只要保证证书续期后，证书中的公钥不变，就能够通过验证了。</p> \n<p><strong>扩展：</strong></p> \n<p>用了<code>SSL Pinning</code>就安全了吗?</p> \n<p>参考文章：</p> \n<p><a href=\"https://www.jianshu.com/p/b5c27669e2c1\" rel=\"nofollow noreferrer\">AFNetworking3.0后为什么不再需要常驻线程？</a></p> \n<p><a href=\"https://www.jianshu.com/p/5969bbb4af9f\" rel=\"nofollow noreferrer\">别说你会AFNetworking3.0/NSURLSession</a></p> \n<p><a href=\"https://segmentfault.com/a/1190000009199444\">AFNetWorking源码之AFSecurityPolicy</a></p> \n<p><a href=\"http://nelson.logdown.com/posts/2015/04/29/how-to-properly-setup-afnetworking-security-connection\" rel=\"nofollow noreferrer\">如何正確設定 AFNetworking 的安全連線</a></p> \n<hr> \n<p>原文链接： <a href=\"http://www.luoyibu.cn/posts/3247/\" rel=\"nofollow noreferrer\">http://www.luoyibu.cn/posts/3...</a> </p> \n<p>欢迎扫码关注我的微信公众号<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022119997\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p>', 'https://segmentfault.com/img/remote/1460000022119997', '6fbfa4aaad3a43458f21c8acf0038ac5', '85ee959b27f74072b13cc763b9bbf77e,ccaaa3888a50432ebcbc469fa62c40b5,f2fb7d236fec4c138cacd9162eb4488c,e2937a6cc53645a0909a3904d8b4517d', '0', '3', '1', '2020-04-16 16:50:17', '2020-04-16 16:50:17');
INSERT INTO `tb_recommend` VALUES ('95b3c64894d847378dfb087b93f6e2b7', '含ppt下载|OceanBase 2.2免费体验', '今天将全面解读OceanBase 2.2版本的核心特性，解析在异地容灾多活、在线数据迁移等场景下OceanBase的完整解决方案，以下为OceanBase团队的庆涛老师演讲整理全文：', '<blockquote>\n 蚂蚁金服近期开展的 “共战‘疫情’，技术破局”数字课堂线上直播系列演讲我们将整理并发布在 “蚂蚁金服科技” 微信公众号上，欢迎关注。&nbsp;\n</blockquote> \n<p>今天将全面解读OceanBase 2.2版本的核心特性，解析在异地容灾多活、在线数据迁移等场景下OceanBase的完整解决方案，以下为OceanBase团队的庆涛老师演讲整理全文：</p> \n<p>大家下午好。我是来自蚂蚁金服OceanBase团队的庆涛，很荣幸能在云栖社区直播平台为大家分享OceanBase数据库的相关知识。OceanBase官网最近发布了2.2版本的安装包，大家可以免费下载获取。安装文件里面包含了两个重要产品，一个是OCP（OceanBase Cloud Platform）和OceanBase 2.2版本，其中OCP是OceanBase的自动化运维平台，这次分享打算分两期给大家介绍OCP和OceanBase 2.2的功能，以及OceanBase 2.2的运维和开发。</p> \n<p>首先跟大家分享一下<strong>OceanBase产品的定位和发展历史</strong>。</p> \n<p>一个常见的问题：很多人会问OceanBase数据库到底是什么？首先OceanBase和Oracle / MySQL一样，它是一款关系型数据库，但是跟Oracle和MySQL不同的是，它是分布式架构的关系型数据库。而且它是一款原生的分布式数据库，不是分库分表中间件架构的数据库。OceanBase数据库由阿里巴巴和蚂蚁金服完全自主研发，不依赖于任何开源项目。目前OceanBase的定位是一款商业数据库，主要用于替换Oracle和MySQL，在部分场景下可以替换DB2数据库。</p> \n<p>下面为大家简单介绍一下OceanBase的发展历史。如今OceanBase已经有9年多的历史，我们的第一个业务是淘宝收藏夹，业务的特点是在上百亿的大表之间做关联查询。如今大家打开手机淘宝，这个业务其实依然是跑在OceanBase数据库之上。OceanBase的版本分为三个阶段，其中从0.4版本开始就在支付宝承担核心交易业务去O以及在网商银行承担全部的核心数据库。1.0版本后，OceanBase架构完全重构，兼容MySQL 5.6的SQL语法，从1.4版本开始逐步走向商用，第一家使用OceanBase的客户是南京银行。2018年9月，OceanBase 发布了2.0版本，OceanBase开始兼容Oracle的SQL语法，如今内部版本已经到了2.2.3。目前我们可以做到兼容70%左右的Oracle常用语法。</p> \n<p>接下来为大家介绍<strong>OceanBase的几个重要的外部客户</strong>，目前网商银行全部的核心业务数据都在OceanBase上，南京银行的互联网核心业务，参照网商银行的架构搭建，也使用了OceanBase数据库。全国各地有越来越多的城商行、农商行、以及一些互联网保险、证券公司的业务，目前也开始在OceanBase上部署。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021996035\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>OceanBase能在金融行业扎根，除了有支付宝强大的业务场景背书外，还离不开<strong>OceanBase最核心的六大产品能力：</strong></p> \n<p><strong>第一就是高可用。</strong>OceanBase的架构设计天然就是为故障容灾而设计的，它的数据至少有三副本，任何时候机器故障，只可能会出现局部的数据访问中断，并且会很快地自动恢复，恢复时还可以保证数据绝对不会丢失。这就是我们通常说的 RTO约等于30秒，然后RPO=0。这里30秒是包括故障探测时间。</p> \n<p><strong>第二个能力就是分布式架构</strong>，OceanBase数据库可以在线扩容、缩容、迁移、以及做负载均衡，并且整个集群可以异地部署，跨城市部署。成熟的方案有两地三中心和三地五中心。</p> \n<p><strong>第三个能力就是兼容Oracle和MySQL的常用语法。</strong>我们现在重点是兼容Oracle的语法。</p> \n<p><strong>第四个能力就是高性能</strong>，2017年，OceanBase支撑了支付宝双11大促活动，交易峰值达到每秒钟25.6万笔。2019年，OceanBase得到了国外权威机构TPC-C的认证，测试结果达到6088万tpmC，荣登性能榜首，是 Oracle结果的两倍。</p> \n<p><strong>第五个能力是低成本。</strong>OceanBase基于普通的PC服务器，只需要SSD盘、万兆网络，不需要小机，存储，还有光纤网络。</p> \n<p><strong>第六个能力就是多租户的能力。</strong>OceanBase使用的时候很像云数据库，但是它跟云没有必然的关系。在OceanBase集群里面，我们可以按需分配实例，还可以在线的资源扩容或者缩容。</p> \n<p>那么接下来我来带大家详细了解一下<strong>OceanBase 2.2版本的核心功能以及背后的原理</strong>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021996042\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>首先是集群，OceanBase集群架构至少包括三台机器，上图里实例是九台机器，机器会分为三个区域存放，每个区域我们称为一个zone，zone可以是小到一个机柜，机房，大到一个数据中心。三个数据中心的机器，整体上我们是做成一个OceanBase集群，每个机器都是普通的X86服务器，普通的SSD，万兆网卡彼此互通。</p> \n<p>我们会在每个机器上面运行一个OceanBase的数据库软件，它是一个单进程程序，叫OBServer，每个机器上的OBServer进程的作用基本上是一样的，都包含两个模块，一个是SQL引擎、一个是存储引擎。整个集群里面会有一台机器比较特别，它会有一个RootService，我们称为总控服务。所以从这个架构图上来看，当9台机器全部运行了OBServer进程以后，在我们眼里它就是9个OBServer进程，它们组成了一个集群。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021996038\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>那么接下来我们就看<strong>OceanBase集群的资源池</strong>，这么大一个资源池它怎么使用？这就要提到OceanBase强大的多租户能力。首先OceanBase会有一个内部租户，这个租户，也就是我们说的内部实例，主要是用于管理用的，它会占用少量的资源。15个CPU，60G内存，那么剩下的这些大部分资源就是未分配的，是留给业务用的。这时候我们来了两个业务，每个业务它会说我需要多少资源，那么在OceanBase里面就会划分出一块资源给业务使用，没有分完的，就留待给其他的业务使用。</p> \n<p>从这里的设计可以看出，当我们的业务方需要一个数据库的时候，我们的运维人员在一分钟以内就可以把数据库创建好，运维的效率大大提升。</p> \n<p>接下来再来看一下<strong>OceanBase里面数据分布的特点</strong>。首先OceanBase里数据的最小单位，不是表而是分区，但分区跟表是有关系的，我们说一个普通的表就是一个分区，像这里的t1表，表明它就是一个分区，我们给它编个号叫0号分区，所以这里写t1(p0)就表示 t1表的分区，但是一个分区表会有多个分区，像t3表、t4表的话，它就是分区表有0号分区、1号分区、2号分区，有三个分区。这些分区是分布在OceanBase集群任意的机器里面，没有固定的位置，这是第一个特点。</p> \n<p>第二个特点是每个分区会有三个副本，副本就是指一模一样的内容，像 t1(p0)，它也会有另外两个t1(p0)，三个副本在角色上面会有所区分，我们通过颜色来区分，比如绿色的是主副本，我们也称为leader副本。黄色的是备副本又叫follower副本。默认情况下只有主副本提供读写服务，follower副本不提供读写服务，并且每个分区的三个副本一定是分布在三个zone里面的，我们横向看是三个zone。在OceanBase里有一个反向代理软件叫OBProxy，它的作用主要就是接受应用的SQL请求。收到SQL之后会把请求转发到主副本所在的节点上面，OBProxy后面还会详细的介绍。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021996037\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>我们来看另外一个问题，三副本的内容是怎么保持同步的？比如说t1(p0)有三个副本，默认只有主副本提供读写。它们之间的同步是靠主副本上面的事务日志，也就是clog。当主副本上一个事务要提交的时候，它会把clog同时发给两个备副本。然后三个副本会把日志持久化到磁盘上，当三个成员里面，绝大多数成员把这个事务日志写成功之后，主副本上的事务就可以提交了。这里协议使用了Paxos协议。</p> \n<p>除了保持数据同步以外，当主副本出现故障时，OceanBase会自动的从两个备副本里选出一个新的主副本出来，并且会保证新选出来的主副本拥有全部的事务日志，所以数据是不会丢的。OceanBase的故障切换的力度很细，它是分区级别的，所以我们不会说某一台机器是主某一台机器是备，从这个图里面我们可以看出来有5台机器有主副本，凡是有主副本的机器都可以提供服务。当你的业务表很多的时候，每台机器上实际上都可以有主副本，所以OceanBase的机器是没有主备概念的。</p> \n<p>接下来我们详细的讲解<strong>OBProxy的功能</strong>。OBProxy的功能其实说起来也很简单，它就是只做SQL路由，不参与运算。当收到业务的SQL请求，分析出里面要访问的表，然后找到表对应的分区的主副本在哪个机器上面，就把它转发过去，取出数据之后原路返回。对于用户来说，OBProxy就是OceanBase数据库的一个代理，所以OBProxy的可用性非常重要。通常情况下我们会部署多个OBProxy，然后把它们挂在用户已有的一个负载均衡设备上面，比如说F5上面，然后F5提供一个VIP给业务用，但F5的高可用是靠自身的备机去提供。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021996039\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这里顺带提一下，除了OBProxy有路由功能以外，OBServer自身也是有路由功能的。</p> \n<p>接下来我们来看一下<strong>OceanBase的SQL兼容性</strong>。</p> \n<p>前面说OceanBase支持多租户，它可以兼容MySQL或者Oracle，实际上只能2选1不能同时兼容。下图左侧是MySQL常用的SQL功能，右侧是目前实现的Oracle常用的SQL功能。就Oracle功能这一块，现在是重点发展的方向。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021996036\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>数据类型的话，我们已经实现了75%的类型和86%的函数。存储过程也支持了不少功能，有些场景下业务客户的存储过程是可以平迁到OceanBase上的。在事务方面，OceanBase支持两种事务隔离级别，一个是读已提交，还有序列化隔离级别，这点是跟Oracle一致的。</p> \n<p>OceanBase支持跨节点的分布式事务，内部原理是两阶段提交，强一致的，并且这个事务对业务是透明的。使用的时候，业务只要稍微注意一下额，这个事务一定要及时提交，以避免长事务在OceanBase里会超时报错。此外，OceanBase还支持自治事务。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021996041\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>下面为大家介绍<strong>OceanBase相关的解决方案</strong>。在OceanBase的周边生态产品中，除了OceanBase集群外，我们还开发了一款OceanBase运维平台——OCP（OceanBase Cloud Platform），这款产品的目标就是让运维人员绝大部分的工作都可以通过运维平台来自动化完成。</p> \n<p>第二个产品是OceanBase开发者中心——ODC（OceanBase Developer Center），面向开发人员，目标是让开发人员能通过这个平台去连接数据库，而不用直连数据库，这样我们可以控制权限和审计功能。</p> \n<p>第三个就是OceanBase的迁移服务——OMS（OceanBase Migration Service），我们重点看一下OceanBase的迁移服务。为大家分享一个客户案例，某银行有一个Oracle业务，有一个MySQL业务，我们现在需要把它迁移到OceanBase上来。刚开始的时候客户应用是读写Oracle和MySQL，然后我们部署OMS之后，就把Oracle和MySQL的数据分别同步到OceanBase的Oracle租户和MySQL租户。这个时候业务是不停的，这个同步是实时同步，它会同步增量。当增量追上的时候，我们再寻找一个业务低峰期的时候，让业务短暂的停写原来的数据库，这个时候OMS可以对两边的数据做一个全量的校验，确保两边数据是一致的，然后再做决定，即切换。所谓的切换就是OMS把数据同步的方向给调整一下，从OceanBase同步回原来的Oracle数据库，这时候客户的业务再把连接指向新的OceanBase数据库，那么这样的一个切换过程就完成了。这里我们会把OB的数据同步回Oracle，这个是为了方便回滚，一旦客户决定再切换回去的时候，我们只需要把这些操作反过来做一遍就可以。同样的在回切的时候，我们依然要两边做数据校验，校验一致之后，我们再把同步方向返回来应用，把连接改回去就可以了。</p> \n<p><strong>OceanBase的容灾方案常用的就是两地三中心。</strong>两地三中心中整个集群是三副本架构，分布在三个机房，其中同城两机房，延时是2毫秒，异地机房延时是7毫秒。任何一个机器或者机房故障的话，数据库的服务都可以很快的恢复，并且保证不丢数据。当然有个缺点，故障之后写性能会下降一点点，如果应用不能承受性能下降的话，我们通常会做5副本，也就是三地五中心。</p> \n<p>最后我们来总结一下OceanBase的几个核心关键字，低成本、高可用、可扩展、高性能的分布式关系型数据库，同时它又像云数据库一样，并且适合金融行业的异地容灾和多活。OceanBase目标就是做一款分布式的Oracle。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021996040\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>PPT下载：<a href=\"https://files.alicdn.com/tpsservice/e099a7f95bca0aa3f6707c79f782093d.pdf\" rel=\"nofollow noreferrer\">https://files.alicdn.com/tpsservice/e099a7f95bca0aa3f6707c79f782093d.pdf</a></p>', 'https://segmentfault.com/img/remote/1460000021996035', '3f69fcc9b13843d1910b3dac597f5215', '83f62facb3b943ffa8e46abd1ebc64d9,c6be57ee659c4ebe8f254e3e7adf74a2,6aec6c8499c44483beecd569d05c7f4b,695a8bbf358245c5a5284af4df5b2222,a819e12d8465406d8430a3e7ee826d1c', '0', '3', '1', '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_recommend` VALUES ('9a816291d7f54c22804bd6d6e7d181a6', '支持联机对战的五子棋小游戏', '原文链接 [链接] 效果展示 原理简介 每次都写单机游戏自嗨好像没啥意思，这次我们来写个支持联机对战的游戏吧，省的有人在issue里说： 好吧，联机和对手比赛输了总不能怪我了吧 OK，跑题了，这明明是一个学习用的...', '<h2>原文链接</h2> \n<p><a href=\"https://mp.weixin.qq.com/s/79aBuK_EytVAbDp5hY8cHA\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/79...</a></p> \n<h2>效果展示</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbDlWK\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"1.png\" title=\"1.png\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbDlWL\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"2.png\" title=\"2.png\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbDlWN\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"3.png\" title=\"3.png\"></span></p> \n<h2>原理简介</h2> \n<p>每次都写单机游戏自嗨好像没啥意思，这次我们来写个支持联机对战的游戏吧，省的有人在issue里说：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733166\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>好吧，联机和对手比赛输了总不能怪我了吧</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733165\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>OK，跑题了，这明明是一个学习用的公众号。因为我之前也没写过可以联机对战的游戏，所以先整个简单的游戏试试吧，支持局域网联机对战的五子棋小游戏。废话不多说，让我们愉快地开始吧~</p> \n<p>这里简单介绍下原理吧，代码主要用PyQt5写的，pygame只用来播放一些音效。首先，设计并实现个游戏主界面：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733164\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>代码实现如下：</p> \n<pre><code class=\"text\">\'\'\'游戏开始界面\'\'\'\nclass gameStartUI(QWidget):\n  def __init__(self, parent=None, **kwargs):\n    super(gameStartUI, self).__init__(parent)\n    self.setFixedSize(760, 650)\n    self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘\')\n    self.setWindowIcon(QIcon(cfg.ICON_FILEPATH))\n    # 背景图片\n    palette = QPalette()\n    palette.setBrush(self.backgroundRole(), QBrush(QPixmap(cfg.BACKGROUND_IMAGEPATHS.get(\'bg_start\'))))\n    self.setPalette(palette)\n    # 按钮\n    # --人机对战\n    self.ai_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'ai\'), self)\n    self.ai_button.move(250, 200)\n    self.ai_button.show()\n    self.ai_button.click_signal.connect(self.playWithAI)\n    # --联机对战\n    self.online_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'online\'), self)\n    self.online_button.move(250, 350)\n    self.online_button.show()\n    self.online_button.click_signal.connect(self.playOnline)\n  \'\'\'人机对战\'\'\'\n  def playWithAI(self):\n    self.close()\n    self.gaming_ui = playWithAIUI(cfg)\n    self.gaming_ui.exit_signal.connect(lambda: sys.exit())\n    self.gaming_ui.back_signal.connect(self.show)\n    self.gaming_ui.show()\n  \'\'\'联机对战\'\'\'\n  def playOnline(self):\n    self.close()\n    self.gaming_ui = playOnlineUI(cfg, self)\n    self.gaming_ui.show()</code></pre> \n<p>会pyqt5的应该都可以写出这样的界面，没啥特别的，记得把人机对战和联机对战两个按钮触发后的信号分别绑定到人机对战和联机对战的函数上就行。</p> \n<p>然后分别来实现人机对战和联机对战就行了。这里人机对战的算法抄的公众号之前发的那篇AI五子棋的文章里用的算法，所以只要花点心思用PyQt5重新写个游戏界面就行了，效果大概是这样的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733168\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>主要的代码实现如下：</p> \n<pre><code class=\"text\">\'\'\'人机对战\'\'\'\nclass playWithAIUI(QWidget):\n    back_signal = pyqtSignal()\n    exit_signal = pyqtSignal()\n    send_back_signal = False\n    def __init__(self, cfg, parent=None, **kwargs):\n        super(playWithAIUI, self).__init__(parent)\n        self.cfg = cfg\n        self.setFixedSize(760, 650)\n        self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘\')\n        self.setWindowIcon(QIcon(cfg.ICON_FILEPATH))\n        # 背景图片\n        palette = QPalette()\n        palette.setBrush(self.backgroundRole(), QBrush(QPixmap(cfg.BACKGROUND_IMAGEPATHS.get(\'bg_game\'))))\n        self.setPalette(palette)\n        # 按钮\n        self.home_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'home\'), self)\n        self.home_button.click_signal.connect(self.goHome)\n        self.home_button.move(680, 10)\n        self.startgame_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'startgame\'), self)\n        self.startgame_button.click_signal.connect(self.startgame)\n        self.startgame_button.move(640, 240)\n        self.regret_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'regret\'), self)\n        self.regret_button.click_signal.connect(self.regret)\n        self.regret_button.move(640, 310)\n        self.givein_button = PushButton(cfg.BUTTON_IMAGEPATHS.get(\'givein\'), self)\n        self.givein_button.click_signal.connect(self.givein)\n        self.givein_button.move(640, 380)\n        # 落子标志\n        self.chessman_sign = QLabel(self)\n        sign = QPixmap(cfg.CHESSMAN_IMAGEPATHS.get(\'sign\'))\n        self.chessman_sign.setPixmap(sign)\n        self.chessman_sign.setFixedSize(sign.size())\n        self.chessman_sign.show()\n        self.chessman_sign.hide()\n        # 棋盘(19*19矩阵)\n        self.chessboard = [[None for i in range(19)] for _ in range(19)]\n        # 历史记录(悔棋用)\n        self.history_record = []\n        # 是否在游戏中\n        self.is_gaming = True\n        # 胜利方\n        self.winner = None\n        self.winner_info_label = None\n        # 颜色分配and目前轮到谁落子\n        self.player_color = \'white\'\n        self.ai_color = \'black\'\n        self.whoseround = self.player_color\n        # 实例化ai\n        self.ai_player = aiGobang(self.ai_color, self.player_color)\n        # 落子声音加载\n        pygame.mixer.init()\n        self.drop_sound = pygame.mixer.Sound(cfg.SOUNDS_PATHS.get(\'drop\'))\n    \'\'\'鼠标左键点击事件-玩家回合\'\'\'\n    def mousePressEvent(self, event):\n        if (event.buttons() != QtCore.Qt.LeftButton) or (self.winner is not None) or (self.whoseround != self.player_color) or (not self.is_gaming):\n            return\n        # 保证只在棋盘范围内响应\n        if event.x() &gt;= 50 and event.x() &lt;= 50 + 30 * 18 + 14 and event.y() &gt;= 50 and event.y() &lt;= 50 + 30 * 18 + 14:\n            pos = Pixel2Chesspos(event)\n            # 保证落子的地方本来没有人落子\n            if self.chessboard[pos[0]][pos[1]]:\n                return\n            # 实例化一个棋子并显示\n            c = Chessman(self.cfg.CHESSMAN_IMAGEPATHS.get(self.whoseround), self)\n            c.move(event.pos())\n            c.show()\n            self.chessboard[pos[0]][pos[1]] = c\n            # 落子声音响起\n            self.drop_sound.play()\n            # 最后落子位置标志对落子位置进行跟随\n            self.chessman_sign.show()\n            self.chessman_sign.move(c.pos())\n            self.chessman_sign.raise_()\n            # 记录这次落子\n            self.history_record.append([*pos, self.whoseround])\n            # 是否胜利了\n            self.winner = checkWin(self.chessboard)\n            if self.winner:\n                self.showGameEndInfo()\n                return\n            # 切换回合方(其实就是改颜色)\n            self.nextRound()\n    \'\'\'鼠标左键释放操作-调用电脑回合\'\'\'\n    def mouseReleaseEvent(self, event):\n        if (self.winner is not None) or (self.whoseround != self.ai_color) or (not self.is_gaming):\n            return\n        self.aiAct()\n    \'\'\'电脑自动下-AI回合\'\'\'\n    def aiAct(self):\n        if (self.winner is not None) or (self.whoseround == self.player_color) or (not self.is_gaming):\n            return\n        next_pos = self.ai_player.act(self.history_record)\n        # 实例化一个棋子并显示\n        c = Chessman(self.cfg.CHESSMAN_IMAGEPATHS.get(self.whoseround), self)\n        c.move(QPoint(*Chesspos2Pixel(next_pos)))\n        c.show()\n        self.chessboard[next_pos[0]][next_pos[1]] = c\n        # 落子声音响起\n        self.drop_sound.play()\n        # 最后落子位置标志对落子位置进行跟随\n        self.chessman_sign.show()\n        self.chessman_sign.move(c.pos())\n        self.chessman_sign.raise_()\n        # 记录这次落子\n        self.history_record.append([*next_pos, self.whoseround])\n        # 是否胜利了\n        self.winner = checkWin(self.chessboard)\n        if self.winner:\n            self.showGameEndInfo()\n            return\n        # 切换回合方(其实就是改颜色)\n        self.nextRound()\n    \'\'\'改变落子方\'\'\'\n    def nextRound(self):\n        self.whoseround = self.player_color if self.whoseround == self.ai_color else self.ai_color\n    \'\'\'显示游戏结束结果\'\'\'\n    def showGameEndInfo(self):\n        self.is_gaming = False\n        info_img = QPixmap(self.cfg.WIN_IMAGEPATHS.get(self.winner))\n        self.winner_info_label = QLabel(self)\n        self.winner_info_label.setPixmap(info_img)\n        self.winner_info_label.resize(info_img.size())\n        self.winner_info_label.move(50, 50)\n        self.winner_info_label.show()\n    \'\'\'认输\'\'\'\n    def givein(self):\n        if self.is_gaming and (self.winner is None) and (self.whoseround == self.player_color):\n            self.winner = self.ai_color\n            self.showGameEndInfo()\n    \'\'\'悔棋-只有我方回合的时候可以悔棋\'\'\'\n    def regret(self):\n        if (self.winner is not None) or (len(self.history_record) == 0) or (not self.is_gaming) and (self.whoseround != self.player_color):\n            return\n        for _ in range(2):\n            pre_round = self.history_record.pop(-1)\n            self.chessboard[pre_round[0]][pre_round[1]].close()\n            self.chessboard[pre_round[0]][pre_round[1]] = None\n        self.chessman_sign.hide()\n    \'\'\'开始游戏-之前的对弈必须已经结束才行\'\'\'\n    def startgame(self):\n        if self.is_gaming:\n            return\n        self.is_gaming = True\n        self.whoseround = self.player_color\n        for i, j in product(range(19), range(19)):\n            if self.chessboard[i][j]:\n                self.chessboard[i][j].close()\n                self.chessboard[i][j] = None\n        self.winner = None\n        self.winner_info_label.close()\n        self.winner_info_label = None\n        self.history_record.clear()\n        self.chessman_sign.hide()\n    \'\'\'关闭窗口事件\'\'\'\n    def closeEvent(self, event):\n        if not self.send_back_signal:\n            self.exit_signal.emit()\n    \'\'\'返回游戏主页面\'\'\'\n    def goHome(self):\n        self.send_back_signal = True\n        self.close()\n        self.back_signal.emit()</code></pre> \n<p>整个逻辑是这样的：</p> \n<p>设计并实现游戏的基本界面之后，先默认永远是玩家先手(白子)，电脑后手(黑子)。然后，当监听到玩家鼠标左键点击到棋盘网格所在的范围内的时候，捕获该位置，若该位置之前没有人落子过，则玩家成功落子，否则重新等待玩家鼠标左键点击事件。玩家成功落子后，判断是否因为玩家落子而导致游戏结束(即棋盘上有5颗同色子相连了)，若游戏结束，则显示游戏结束界面，否则轮到AI落子。AI落子和玩家落子的逻辑类似，然后又轮到玩家落子，以此类推。</p> \n<p>需要注意的是：为保证响应的实时性，AI落子算法应当写到鼠标左键点击后释放事件的响应中(感兴趣的小伙伴可以试试写到鼠标点击事件的响应中，这样会导致必须在AI计算结束并落子后，才能显示玩家上一次的落子和AI此次的落子结果)。</p> \n<p>开始按钮就是重置游戏，没啥可说的，这里为了避免有些人喜欢耍赖，我实现的时候代码写的是必须完成当前对弈才能重置游戏(毕竟小伙子小姑娘们要学会有耐心地下完一盘棋呀)。</p> \n<p>因为是和AI下，所以悔棋按钮直接悔两步，从历史记录列表里pop最后两次落子然后从棋盘对应位置取下这两次落子就OK了，并且保证只有我方回合可以悔棋以避免出现意料之外的逻辑出错。</p> \n<p>认输按钮也没啥可说的，就是认输然后提前结束游戏。</p> \n<p>接下来我们来实现一下联机对战，这里我们选择使用TCP/IP协议进行联机通信从而实现联机对战。先启动游戏的一方作为服务器端：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733167\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>通过新开一个线程来实现监听：</p> \n<pre><code class=\"text\">threading.Thread(target=self.startListen).start()\n\'\'\'开始监听客户端的连接\'\'\'\ndef startListen(self):\n    while True:\n       self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘 ——&gt; 服务器端启动成功, 等待客户端连接中\')\n       self.tcp_socket, self.client_ipport = self.tcp_server.accept()\n       self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘 ——&gt; 客户端已连接, 点击开始按钮进行游戏\')</code></pre> \n<p>后启动方作为客户端连接服务器端并发送客户端玩家的基本信息：</p> \n<pre><code class=\"text\">self.tcp_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nself.tcp_socket.connect(self.server_ipport)\ndata = {\'type\': \'nickname\', \'data\': self.nickname}\nself.tcp_socket.sendall(packSocketData(data))\nself.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘 ——&gt; 已经成功连接服务器, 点击开始按钮进行游戏\')</code></pre> \n<p>当客户端连接到服务器端时，服务器端也发送服务器端的玩家基本信息给客户端：</p> \n<pre><code class=\"text\">data = {\'type\': \'nickname\', \'data\': self.nickname}\nself.tcp_socket.sendall(packSocketData(data))</code></pre> \n<p>然后客户端和服务器端都利用新开的线程来实现网络数据监听接收：</p> \n<pre><code class=\"text\">\'\'\'接收客户端数据\'\'\'\ndef receiveClientData(self):\n    while True:\n        data = receiveAndReadSocketData(self.tcp_socket)\n        self.receive_signal.emit(data)\n\'\'\'接收服务器端数据\'\'\'\ndef receiveServerData(self):\n    while True:\n        data = receiveAndReadSocketData(self.tcp_socket)\n        self.receive_signal.emit(data)</code></pre> \n<p>并根据接收到的不同数据在主进程中做成对应的响应：</p> \n<pre><code class=\"text\">\'\'\'响应接收到的数据\'\'\'\ndef responseForReceiveData(self, data):\n    if data[\'type\'] == \'action\' and data[\'detail\'] == \'exit\':\n        QMessageBox.information(self, \'提示\', \'您的对手已退出游戏, 游戏将自动返回主界面\')\n        self.goHome()\n    elif data[\'type\'] == \'action\' and data[\'detail\'] == \'startgame\':\n        self.opponent_player_color, self.player_color = data[\'data\']\n        self.whoseround = \'white\'\n        self.whoseround2nickname_dict = {self.player_color: self.nickname, self.opponent_player_color: self.opponent_nickname}\n        res = QMessageBox.information(self, \'提示\', \'对方请求(重新)开始游戏, 您为%s, 您是否同意?\' % {\'white\': \'白子\', \'black\': \'黑子\'}.get(self.player_color), QMessageBox.Yes | QMessageBox.No)\n        if res == QMessageBox.Yes:\n            data = {\'type\': \'reply\', \'detail\': \'startgame\', \'data\': True}\n            self.tcp_socket.sendall(packSocketData(data))\n            self.is_gaming = True\n            self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘 ——&gt; %s走棋\' % self.whoseround2nickname_dict.get(self.whoseround))\n            for i, j in product(range(19), range(19)):\n                if self.chessboard[i][j]:\n                    self.chessboard[i][j].close()\n                    self.chessboard[i][j] = None\n            self.history_record.clear()\n            self.winner = None\n            if self.winner_info_label:\n                self.winner_info_label.close()\n            self.winner_info_label = None\n            self.chessman_sign.hide()\n        else:\n            data = {\'type\': \'reply\', \'detail\': \'startgame\', \'data\': False}\n            self.tcp_socket.sendall(packSocketData(data))\n    elif data[\'type\'] == \'action\' and data[\'detail\'] == \'drop\':\n        pos = data[\'data\']\n        # 实例化一个棋子并显示\n        c = Chessman(self.cfg.CHESSMAN_IMAGEPATHS.get(self.whoseround), self)\n        c.move(QPoint(*Chesspos2Pixel(pos)))\n        c.show()\n        self.chessboard[pos[0]][pos[1]] = c\n        # 落子声音响起\n        self.drop_sound.play()\n        # 最后落子位置标志对落子位置进行跟随\n        self.chessman_sign.show()\n        self.chessman_sign.move(c.pos())\n        self.chessman_sign.raise_()\n        # 记录这次落子\n        self.history_record.append([*pos, self.whoseround])\n        # 是否胜利了\n        self.winner = checkWin(self.chessboard)\n        if self.winner:\n            self.showGameEndInfo()\n            return\n        # 切换回合方(其实就是改颜色)\n        self.nextRound()\n    elif data[\'type\'] == \'action\' and data[\'detail\'] == \'givein\':\n        self.winner = self.player_color\n        self.showGameEndInfo()\n    elif data[\'type\'] == \'action\' and data[\'detail\'] == \'urge\':\n        self.urge_sound.play()\n    elif data[\'type\'] == \'action\' and data[\'detail\'] == \'regret\':\n        res = QMessageBox.information(self, \'提示\', \'对方请求悔棋, 您是否同意?\', QMessageBox.Yes | QMessageBox.No)\n        if res == QMessageBox.Yes:\n            pre_round = self.history_record.pop(-1)\n            self.chessboard[pre_round[0]][pre_round[1]].close()\n            self.chessboard[pre_round[0]][pre_round[1]] = None\n            self.chessman_sign.hide()\n            self.nextRound()\n            data = {\'type\': \'reply\', \'detail\': \'regret\', \'data\': True}\n            self.tcp_socket.sendall(packSocketData(data))\n        else:\n            data = {\'type\': \'reply\', \'detail\': \'regret\', \'data\': False}\n            self.tcp_socket.sendall(packSocketData(data))\n    elif data[\'type\'] == \'reply\' and data[\'detail\'] == \'startgame\':\n        if data[\'data\']:\n            self.is_gaming = True\n            self.setWindowTitle(\'五子棋-微信公众号: Charles的皮卡丘 ——&gt; %s走棋\' % self.whoseround2nickname_dict.get(self.whoseround))\n            for i, j in product(range(19), range(19)):\n                if self.chessboard[i][j]:\n                    self.chessboard[i][j].close()\n                    self.chessboard[i][j] = None\n            self.history_record.clear()\n            self.winner = None\n            if self.winner_info_label:\n                self.winner_info_label.close()\n            self.winner_info_label = None\n            self.chessman_sign.hide()\n            QMessageBox.information(self, \'提示\', \'对方同意开始游戏请求, 您为%s, 执白者先行.\' % {\'white\': \'白子\', \'black\': \'黑子\'}.get(self.player_color))\n        else:\n            QMessageBox.information(self, \'提示\', \'对方拒绝了您开始游戏的请求.\')\n    elif data[\'type\'] == \'reply\' and data[\'detail\'] == \'regret\':\n        if data[\'data\']:\n            pre_round = self.history_record.pop(-1)\n            self.chessboard[pre_round[0]][pre_round[1]].close()\n            self.chessboard[pre_round[0]][pre_round[1]] = None\n            self.nextRound()\n            QMessageBox.information(self, \'提示\', \'对方同意了您的悔棋请求.\')\n        else:\n            QMessageBox.information(self, \'提示\', \'对方拒绝了您的悔棋请求.\')\n    elif data[\'type\'] == \'nickname\':\n        self.opponent_nickname = data[\'data\']</code></pre> \n<p>对战过程实现的基本逻辑和人机对战是一致的，只不过要考虑数据同步问题，所以看起来代码略多了一些。当然对于联机对战，我也做了一些小修改，比如必须点击开始按钮，并经过对方同意之后，才能正式开始对弈，悔棋按钮只有在对方回合才能按，对方同意悔棋后需要记得把落子方切换回自己。然后加了一个催促按钮，同样必须在对方回合才能按。其他好像也没什么特别的改动了。</p> \n<p>All done~完整源代码详见相关文件~</p> \n<h2>相关文件</h2> \n<p><a href=\"https://github.com/CharlesPikachu/Games/tree/master/Game22\" rel=\"nofollow noreferrer\">https://github.com/CharlesPik...</a></p>', 'https://segmentfault.com/img/bVbDlWK', '3f69fcc9b13843d1910b3dac597f5215', 'faf36da502544b51be926ab85450c40d,43145b2d806a4c3e8bb30d20ef04d61b,a4f4fd7a73b84a7298db0174165eeaac,9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-16 16:57:49', '2020-04-16 16:57:49');
INSERT INTO `tb_recommend` VALUES ('9abef86099d7461bba12070af600b589', '这款 APP：广告拦截利器，上网摸鱼必备！', '相信大家在平时浏览网页、看视频的时候，都会遇到各种各样的广告，无论你是在电脑端、还是在手机端，这种烦恼都时刻存在。 无意当中，民工哥发现一款能屏蔽网页和去除视频广告的APP，功能非常强大，接下来给大家...', '<p>相信大家在平时浏览网页、看视频的时候，都会遇到各种各样的广告，无论你是在电脑端、还是在手机端，这种烦恼都时刻存在。</p> \n<p>无意当中，民工哥发现一款能屏蔽网页和去除视频广告的APP，功能非常强大，接下来给大家介绍一下相关的功能。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393387\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这款APP 软件的名称叫：<strong>infy，</strong>目前在App Store 上可以下载。</p> \n<p>搜索之后发现，有两款相同的软件，一款要付费，一款不需要，我们也不需要什么强大的功能，只需要选择免费的软件就可以了。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393386\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>安装好infy软件之后，打开界面如下，就可以清楚的看到各种屏蔽选项。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393385\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>从上面的截图来看，第一个选项就是拦截百度推广中的广告，那么，首先就来试试这个功能的效果如何？ </p> \n<p>在百度搜索「运维工程师」，结果如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393388\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>发现排在前面两个都是推广信息。 </p> \n<p>这时，我们打开infy拦截功能。 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393390\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>不过，要真正使用上这个功能，我们要同步打开Safar 浏览器中的「内容拦截器」，并将「Infy拦截」打开。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393389\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393393\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这时候，我们再次去百度搜索关键词「运维工程师」，发现之前的广告推广已经没有了，真的被屏蔽去掉了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393391\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>还有一个功能就是：全局拦截各大主流的视频APP中的广告 </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393392\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>经过民工哥的测试，发现的确是能拦截目前一些主流的视频APP当中的广告，强能的确非常强大，这样一来就能省出一大笔。</p> \n<p><strong>不过，这款APP暂时有几点不太满意：</strong></p> \n<p>1、只有苹果手机能用，IOS专属！！</p> \n<p>2、免费的功能还是有点受限的，像屏蔽视频广告，目前好像优酷、腾讯的视频APP中的广告不能屏蔽。</p> \n<p><strong>有兴趣的朋友可以下载试试看。</strong></p>', 'https://segmentfault.com/img/remote/1460000022393387', 'f53014d680884163a5bd5ce762e90cdf', '81a4561c1c294e0cae32c9fe6b5dc397,77a7bd638e0a45ec84569ef6b79325c1', '0', '3', '1', '2020-04-16 16:59:59', '2020-04-16 16:59:59');
INSERT INTO `tb_recommend` VALUES ('9bfba00e7689432da1838d0e184760f2', '当浏览器全面禁用三方 Cookie', '苹果公司前不久对 Safari 浏览器进行一次重大更新，这次更新完全禁用了第三方 Cookie，这意味着，默认情况下，各大广告商或网站将无法对你的个人隐私进行追踪。而微软和 Mozilla 等也纷纷采取了措施禁用第三方 Co...', '<p>苹果公司前不久对 <code>Safari</code> 浏览器进行一次重大更新，这次更新完全禁用了第三方 <code>Cookie</code>，这意味着，默认情况下，各大广告商或网站将无法对你的个人隐私进行追踪。而微软和 <code>Mozilla</code> 等也纷纷采取了措施禁用第三方 <code>Cookie</code>，但是由于这些浏览器市场份额较小，并没有给市场带来巨大的冲击。</p> \n<p>从 <code>2017</code> 年截至 <code>2019</code> 年底， <code>Google</code> 面临的罚款总额已经超过 93 亿欧元，其中一大原因便是侵犯用户数据隐私。迫于巨大压力，<code>Google Chrome</code> 官方团队前不久也宣布，为了提升用户隐私和安全，未来两年将完全禁用第三方 <code>Cookie</code>。</p> \n<p>在完全不能写入三方 <code>Cookie</code> 的情况下，将会对前端的数据读写方式，甚至是整个广告行业带来巨大影响。</p> \n<h2>Cookie 的意义</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386156\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>众所周知，<code>HTTP</code> 协议是无状态的协议，如果你在同一个客户端向服务器发送多次请求，服务器不会知道这些请求来自同一客户端。</p> \n<p>这正是 <code>HTTP</code> 协议得以广泛应用的原因，试想一下，如果它是有状态协议，你必须要时刻与服务器建立链接，那么如果连接意外断开，整个会话就会丢失，重新连接之后一般需要从头开始；而如果是无状态协议，使得会话与连接本身独立起来，这样即使连接断开了，会话状态也不会受到严重伤害，保持会话也不需要保持连接本身。</p> \n<p>如果 <code>HTTP</code> 协议只是用来访问静态文件，那不会有任何问题，但是如果你要为广大用户提供更好的服务，服务器就需要知道每个请求具体来自于哪个用户，比如你在逛淘宝的时候你只需要登录一次，当你发起一次购买请求，服务器就已经知道你登录过了，不会再让你进行登录。</p> \n<p>所以 <code>HTTP</code> 协议需要占用浏览器的一小块存储，存储当前访问用户的一些 ”状态“，然后每次发起 <code>HTTP</code> 请求，请求中就会携带这些状态，从而让服务器知道你是谁。 <code>Cookie</code> 出现的的意义就是为了解决这个问题，让无状态的 <code>HTTP</code> 协议拥有一小块记忆。</p> \n<p>但是， <code>Cookie</code> 一经出现，就成了各大广告和购物网站窥探用户隐私的利器，他们使用第三方 <code>Cookie</code> 不断获取你的数据，那么什么第三方 <code>Cookie</code> 呢？</p> \n<h2>第三方 Cookie</h2> \n<p>如果是你正常的正在逛着天猫，天猫会把你的信息写入一些 <code>Cookie</code> 到 <code>.tmall.com</code> 这个域下，然而打开控制台你会看到，并不是所有 <code>Cookie</code> 都是 <code>.tmall.com</code> 这个域下的，里面还有很多其他域下的 <code>Cookie</code> ，这些所有非当前域下的 <code>Cookie</code> 都属于第三方 <code>Cookie</code>，虽然你可能从来没访问过这些域，但是他们已经悄悄的通过这些第三方 <code>Cookie</code>来标识你的信息，然后把你的个人信息发送过去了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386155\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>而 <code>.tmall.com</code> 这个域下的 <code>Cookie</code> 都属于第一方 <code>Cookie</code>，那么为什么还需要第三方 <code>Cookie</code> 呢？再打开 <code>taobao.com</code>，你会发现你已经不需要再登录了，因为淘宝、天猫都属于阿里旗下的产品，阿里为他们提供统一的登录服务，同时，你的登录信息也会存到这个统一登录服务的域下，所以存到这个域下的 <code>Cookie</code> 就成了三方 <code>Cookie</code>。</p> \n<p>我们再打开已经完全禁用了第三方 <code>Cookie</code> 的 <code>Safari</code>，发现只剩下 <code>.tmall.com</code> 这个域下的 <code>Cookie</code> 了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386158\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这时你会发现即使你已经登录了天猫，再访问淘宝也还是需要登录的，你已经无法享用这样的功能了，而三方 <code>Cookie</code> 可不仅仅就这么点用途，在 <code>Web</code> 开发中，三方 <code>Cookie</code> 的应用非常之广，下面我们再来具体看几个应用场景：</p> \n<h2>三方Cookie的用途</h2> \n<h3>前端日志打点</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386157\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>大多数 <code>Web</code> 站点都会引用一些第三方 <code>SDK</code> 来进行前端异常或性能监控，这些 <code>SDK</code> 会通过一些接口将监控到的信息上传到他们的服务器。一般它们都需要标识每个用户来方便排查问题或者统计 <code>UV</code> 数据，所以当你一此请求这个站点的时候，它们可能会在你的站点上 <code>set</code> 一个 <code>Cookie</code>，后续所有的日志上报请求都会带上这个 <code>Cookie</code> 。</p> \n<p>由于一般这些第三方 <code>SDK</code> 都是用于监控的通用服务，它们肯定会拥有自己独立的域名，比如 <code>log.com</code>，它在你的域名 <code>mysite.com</code> 下种下的 <code>Cookie</code> 就属于第三方 <code>Cookie</code>。</p> \n<h3>广告营销神器 - Facebook Pixel</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386162\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在电商业务中，追踪流量、导流量、转换率、销售额这些都是商家最关心的问题。这时候你就可以使用 <code>Facebook Pixel</code>，简单来说 <code>Facebook Pixel</code> 像素就是一串 <code>JavaScript</code> 代码，可以追踪广告的转化量、改进受众定位、使广告花费回报最大化。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386159\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>当访客进入到被设有 <code>Facebook Pixel</code> 的页面时，便会触发这段代码。比如，查看了商品或者加入购物车， <code>Facebook Pixel</code> 便会向系统发送请求来记录这些行为，系统可以利用这些收到的行为信息进一步的做追踪和优化。</p> \n<p>举一个实际例子，我们进入一个国外的电商网站 <code>Brava Fabrics</code> ，你会发现已经被写入了一堆 <code>facebook.com</code> 下的三方 <code>cookie</code>：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386161\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>我猜测这个 <code>fr</code> 应该就是用来标识我身份信息的 <code>cookie</code>，然后点击几个页面，在 <code>network</code> 里面找到了几个 <code>facebook</code> 发送的请求，下面是其中一个：</p> \n<pre><code class=\"js\">https://www.facebook.com/tr/?id=382444918612794&amp;ev=PageView&amp;dl=https%3A%2F%2Fbravafabrics.com%2Fcollections%2Fa-moment-of-bliss&amp;rl=https%3A%2F%2Fbravafabrics.com%2F&amp;if=false&amp;ts=1586868288778&amp;sw=1680&amp;sh=1050&amp;ud[ct]=eb045d78d273107348b0300c01d29b7552d622abbc6faf81b3ec55359aa9950c&amp;ud[country]=eb045d78d273107348b0300c01d29b7552d622abbc6faf81b3ec55359aa9950c&amp;v=2.9.15&amp;r=stable&amp;ec=0&amp;o=30&amp;fbp=fb.1.1586867082370.951509876&amp;it=1586868284974&amp;coo=false&amp;rqm=GET</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386160\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>查看详情你会发现，有下面几个主要的参数：</p> \n<pre><code>dl: https://bravafabrics.com/collections/a-moment-of-bliss\nrl: https://bravafabrics.com/</code></pre> \n<p>这时 <code>facebook</code> 已经知道了我从 <code>https://bravafabrics.com/</code> 来到了 <code>https://bravafabrics.com/collections/a-moment-of-bliss</code> 这个页面，同时，这个请求会携带 <code>fr=09wX7ui8MrvCh2SIa..BdNoGz.f.F6R.0.0.Belanb.AWXCDx</code> 这个 <code>Cookie</code>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386163\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>来到 <code>facebook</code>，当你登录后，<code>facebook</code> 会把刚刚这些 <code>Cookie</code> 和你的 <code>facebook Id</code> 关联起来，然后他就可以好好的分析你的行为了：</p> \n<ul> \n <li>有人在你的网站上完成了购买。</li> \n <li>有人注册进行试用，或者以其他方式将自己标识为你网站上的潜在客户。</li> \n <li>有人在你网站上的购买过程中输入他们的付款信息。</li> \n <li>有人将产品添加你网站上的购物车中。</li> \n <li>有人选择特定版本的产品，例如选择某种颜色。</li> \n <li>有人发起了结账，但没有付款</li> \n <li>...</li> \n</ul> \n<p>而如此强大的追踪能力，只需要你复制一段 <code>Facebook Pixel</code> 的 <code>JavaScript</code> 脚本到你的页面上就可以了。而这一切能力就建立在一个小小的 <code>Cookie</code> 的基础上，因为有了这个 <code>Cookie</code> ，<code>Facebook</code> 才能将这些行为与它的账号体系进行关联。</p> \n<h3>无处不在的的 mmstat</h3> \n<p>再来看一个我们国内的例子，平时我们在国内的搜索引擎或视频网站上搜索到一些东西，然后打开购物网站就可以收到各种你兴趣的相关推荐，这已经是大众习以为常的事情了，各大购物网站、广告商，会通过第三方 <code>Cookie</code> 收集你的年龄、性别、浏览历史等从而判断你的兴趣喜好，然后带给你精准的信息推荐。</p> \n<p>比如，我们在浏览百度、优酷、天猫等网站时，都能看到几个 <code>.mmstat.com</code> 这个域下的 <code>Cookie</code></p> \n<p>百度：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386164\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>优酷：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386165\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>天猫：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386166\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>当你在百度、优酷、淘宝等进行一系列的操作时，<code>.mmstat.com</code> 已经悄悄的通过三方 <code>Cookie</code> 把你的个人信息运送到了他们那边。 <code>.mmstat.com</code> 应该就是阿里旗下的大数据营销平台阿里妈妈旗下的域名（只是个人猜测）。打开阿里妈妈首页，可以看到，其号称是更懂消费者的数据金矿，已经建立起5亿用户的身份识别体系。你的每一次搜索、每一次购买、都会让它变的更精准，下一次你就收到更精准的推荐。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386167\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>当然，三方 <code>Cookie</code> 只是众多获取你喜好信息的一种方式，只不过这种方式更便捷，成本更低。</p> \n<h2>浏览器的策略</h2> \n<p>最近几大浏览器针对 <code>Cookie</code> 策略的频繁改动，意味着三方 <code>Cookie</code> 被全面禁用已经不远了：</p> \n<h3>Firefox、Safari —— 默认禁用</h3> \n<p>在 <code>Safari 13.1</code>、<code>Firefox 79</code> 版本中，三方 <code>Cookie</code> 已经被默认禁用，但是由于这些游览器市场份额较小，并没有给市场带来巨大的冲击。因为阿里的登录信息是统一存在一个三方 <code>Cookie</code> 下的，淘宝刚开始的处理方式，甚至是弹个框出来，告诉用户手动开启三方 <code>Cookie</code> ：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386168\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>但是这样的处理方式对于庞大的用户来讲肯定体验是极低的，解决方案可能是先将 <code>Cookie</code> 种在当前域下，所有就有了我们上面的测试结果，淘宝、天猫两个网站需要登录两次。</p> \n<p>但是三方 <code>Cookie</code>做的事情远不止这些，等到 <code>Chrome</code> 全面禁用之前，一定要提前作出改变。</p> \n<h3>Chrome —— SameSite Cookie</h3> \n<p>还好由于三方 <code>Cookie</code> 对 <code>Google</code> 的广告业务影响较大，所以其没有立即进行禁用，而是一直陆续修改一些小的策略来对三方 <code>Cookie</code> 进行限制，比如 <code>SameSite</code></p> \n<p><code>SameSite</code> 是 <code>Chrome 51</code> 版本为浏览器的 <code>Cookie</code> 新增的了一个属性， <code>SameSite</code> 阻止浏览器将此 <code>Cookie</code> 与跨站点请求一起发送。其主要目标是降低跨源信息泄漏的风险。同时也在一定程度上阻止了 <code>CSRF</code> 攻击。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386172\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><code>SameSite</code> 可以避免跨站请求发送 <code>Cookie</code>，有以下三个属性：</p> \n<h4>Strict</h4> \n<p><code>Strict</code> 是最严格的防护，将阻止浏览器在所有跨站点浏览上下文中将 <code>Cookie</code> 发送到目标站点，即使在遵循常规链接时也是如此。因此这种设置可以阻止所有 <code>CSRF</code> 攻击。然而，它的用户友好性太差，即使是普通的 <code>GET</code> 请求它也不允许通过。</p> \n<p>例如，对于一个普通的站点，这意味着如果一个已经登录的用户跟踪一个发布在公司讨论论坛或电子邮件上的网站链接，这个站点将不会收到 <code>Cookie</code> ，用户访问该站点还需要重新登陆。</p> \n<p>不过，具有交易业务的网站很可能不希望从外站链接到任何交易页面，因此这种场景最适合使用 <code>strict</code> 标志。</p> \n<h4>Lax</h4> \n<p>对于允许用户从外部链接到达本站并使用已有会话的网站站，默认的 <code>Lax</code> 值在安全性和可用性之间提供了合理的平衡。 <code>Lax</code> 属性只会在使用危险 <code>HTTP</code> 方法发送跨域 <code>Cookie</code> 的时候进行阻止，例如 <code>POST</code> 方式。同时，使用 <code>JavaScript</code> 脚本发起的请求也无法携带 <code>Cookie</code>。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386169\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>例如，一个用户在 A 站点 点击了一个 B 站点（GET请求），而假如 B 站点 使用了<code>Samesite-cookies=Lax</code>，那么用户可以正常登录 B 站点。相对地，如果用户在 A 站点提交了一个表单到 B站点（POST请求），那么用户的请求将被阻止，因为浏览器不允许使用 <code>POST</code> 方式将 <code>Cookie</code> 从A域发送到Ｂ域。</p> \n<h4>None</h4> \n<p>浏览器会在同站请求、跨站请求下继续发送 <code>Cookies</code>，不区分大小写。</p> \n<h4>策略更新</h4> \n<p>在旧版浏览器，如果 <code>SameSite</code> 属性没有设置，或者没有得到运行浏览器的支持，那么它的行为等同于 <code>None</code>，<code>Cookies</code> 会被包含在任何请求中——包括跨站请求。</p> \n<p>但是，在 <code>Chrome 80+</code> 版本中，<code>SameSite</code> 的默认属性是 <code>SameSite=Lax</code>。换句话说，当 <code>Cookie</code> 没有设置 <code>SameSite</code> 属性时，将会视作 <code>SameSite</code> 属性被设置为<code>Lax</code> 。如果想要指定 <code>Cookies</code> 在同站、跨站请求都被发送，那么需要明确指定 <code>SameSite</code> 为 <code>None</code>。具有 <code>SameSite=None</code> 的 <code>Cookie</code> 也必须标记为安全并通过 <code>HTTPS</code> 传送。这意味着所有使用 <code>JavaScript</code> 脚本收集用户信息的请求默认将不能携带三方 <code>Cookie</code>。</p> \n<p>然而这个改动并不会造成太大的影响，它只是给各大网站提了一个信号，因为你只需要把你想要发送的 <code>Cookie</code> 的属性手动设置为 <code>none</code> 即可：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386170\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386171\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>真正可怕的是我们将无法直接指定 <code>SameSite</code> 为 <code>None</code>，只能用户自己去选择，这才是真正的默认禁用。</p> \n<p><code>Chrome</code> 也宣布，将在下个版本也就是 <code>Chrome 83</code> 版本，在访客模式下禁用三方 <code>Cookie</code>，在 <code>2022</code> 年全面禁用三方 <code>Cookie</code>，到时候，即使你能指定 <code>SameSite</code> 为 <code>None</code> 也没有意义，因为你已经无法写入第三方 <code>Cookie</code> 了。</p> \n<h2>当三方 Cookie 被全面禁止</h2> \n<p>现在，我们想象一下，当浏览器禁用了三方 <code>Cookie</code>，而我们又没有作出任何改变的情况下，会发生什么：</p> \n<h3>前端日志异常</h3> \n<p>可能有一天你会突然发现，你的 <code>UV</code> 暴涨，但是 <code>PV</code> 却没有什么变化，那可能是你的打点 <code>SDK</code> 使用的三方 <code>Cookie</code> 被禁用掉了。</p> \n<p>这时这个 <code>SDK</code> 将无法在你的域下写入一个三方 <code>Cookie</code>，导致你的每次刷新页面它都会带一个新的 <code>Cookie</code> 回来，后端接受到的信号就是这些都是不同用户的请求，所以都会计入 <code>UV</code>。同时你在排查问题时，你也无法将用户的行为串联起来，导致排查非常困难。</p> \n<h3>智能广告推荐消失</h3> \n<p>上面我们提到，广告服务通过你的年龄、性别、行为来推断你的喜好，从而推送给你精准的广告，使用了三方 <code>Cookie</code> 来进行信息追踪的广告主将无法获得你的这些喜好，从而无法推荐给你感兴趣的广告。</p> \n<p>这时，广告主只能在你当时的访问环境进行预定义广告，比如你正在访问宠物网站，就给你推荐宠物用品等等。</p> \n<p>同时，可能之前广告主还会通过 <code>Cookie</code> 判断你阅读某个广告的次数，一旦你阅读同一个广告多次但是没有发生转化，其就会停止向你推送该广告。或者你已经购买过了这个商品，那你也不会再看到这个广告了。如果没有了频率控制，那么你可能要连续很多天盯着一个你永远也不会去点的广告，或者你会持续看到一个你已经购买过的产品广告。</p> \n<h3>无法追踪转化率</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386174\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>当你查看一则广告时，该广告会在你的浏览器中放置一个 <code>Cookie</code>，表示你已经看到它。如果随后你进入转化阶段（购买、下载等），广告主们需要能追踪每一个他们投放到你网站上的转化率，这样他们才能计算投放的效果，从而作出优化策略，如果你无法再追踪广告转化率了，那么也很难再进行投放了。</p> \n<p>当然，以上只是建立在你没有进行任何改变的基础上，距离全面禁用三方 <code>Cookie</code> 还有一年多的时间，这应该是一个足够的时间让你及时作出应对。</p> \n<h3>是好是坏</h3> \n<p>虽然，这对你带来的可能是糟糕的广告体验，但是全面禁用三方 <code>Cookie</code> 对我们用户来讲肯定是一件好事，因为你的信息不会被轻而易举的就被别人追踪了，你的隐私信息也不会容易被泄漏。</p> \n<p>然而事情真的那么简单么？贪婪的广告商绝对不会直接放弃对你的信息追踪，首先他们已经对你掌握了足够多的信息，而且三方 <code>Cookie</code> 只是众多获取你信息的一种手段，只不过这种方法更方便简单，为了利益，他们一定会找到更多的替代方案：</p> \n<h2>使用一方 Cookie 替代 三方 Cookie</h2> \n<p>如果我们引入了一个三方的 <code>SDK</code>，比如 <code>google analytics</code> ，说明我们对其是信任的，它对我们的信息收集追踪都是在允许范围内的。所以这些 <code>SDK</code> 依然可以使用第一方 <code>Cookie</code> 来完成用户身份标识符。</p> \n<p>比如，<code>gtag.js</code> 和 <code>analytics.js</code> 会设置以下 <code>Cookie</code> 用户标识用户信息：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386175\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>但是，这些 <code>Cookie</code> 并不是第三方 <code>Cookie</code>，而是设在你的域下的第一方 <code>Cookie</code>，比如打开 <code>twitter</code> 的 <code>Cookie</code> 信息：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386176\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>我们发现 <code>_ga</code> 、<code>_gid</code> 这两个 <code>Cookie</code> 正是设置在其自己域下面的。</p> \n<p>如果使用正常的 <code>Set-Cookie</code> 的形式，<code>google analytics</code> 是无法直接将 <code>Cookie</code> 设置到 <code>twitter.com</code> 这个域下面的，而且 <code>google analytics</code> 发起的日志收集请求也无法携带 <code>twitter.com</code> 这个域下的 <code>Cookie</code>。</p> \n<p>打开 <code>sdk</code> 的代码我发现里面有使用 js 设置 <code>Cookie</code> 的代码：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386173\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>并且，收集日志的请求中也又没携带任何 <code>Cookie</code>，而是把这信息带在了参数中：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386180\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这样的方式就模拟了使用三方 <code>Cookie</code> 标识用户信息的过程，并且完全可以替代它。总而言之禁用三方 <code>Cookie</code> 对这种三方 <code>SDK</code> 的影响并不大，只要稍微改变一下思维即可。</p> \n<p>当然，由于 <code>Safari</code> 和 <code>Firefox</code> 已经全面禁用了三方 <code>Cookie</code>，一些广告营销服务也正在给出使用一方 <code>Cookie</code> 的替代方案，比如 <code>Facebook Pixel</code>：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386179\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>你允许了其读取一方 <code>Cookie</code> 就意味着它能获取你更多的数据，这意味着你需要承担更大的用户信息泄漏的风险。而且使用一方 <code>Cookie</code> 也不像使用三方 <code>Cookie</code> 那样灵活，在某些场景下也是有很大限制的。</p> \n<h2>浏览器指纹</h2> \n<p>三方 <code>Cookie</code> 的主要作用是标识你的身份，从而在你下一次访问时知道你是谁，那么如果有一种技术直接就可以获取你的唯一标识时，那么就不需要再存储 <code>Cookie</code> 了，这个技术就是 “浏览器指纹” 。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386178\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>“浏览器指纹”是一种通过浏览器对网站可见的配置和设置信息来跟踪 <code>Web</code> 浏览器的方法，浏览器指纹就像我们人手上的指纹一样，每个人拥有一份接近于独一无二的配置。</p> \n<p>如果单单拿出一个配置来讲可能很多人和你拥有一样的配置，比如下面的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386183\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li> <p>系统版本：</p> \n  <ul> \n   <li>我的系统版本是 <code>Mac OS X 10_14_6</code> </li> \n   <li>大约 <code>11.91%</code> 的人与我的配置相同</li> \n   <li>大约每 <code>8</code> 个人中有一个和我配置相同</li> \n  </ul> </li> \n <li> <p><code>Chrome</code> 版本：</p> \n  <ul> \n   <li>我使用的浏览器是 <code>Chrome</code>，并且版本是：<code>81.0.4044.92</code> </li> \n   <li>大约 <code>0.08%</code> 的人与我的配置相同</li> \n   <li>大约每 <code>1250</code> 个人中有一个和我配置相同</li> \n  </ul> </li> \n <li> <p><code>UTC+8</code> 时间：</p> \n  <ul> \n   <li>我的<code>UTC+8</code> 时间是 <code>2020.4.15 23:00:00</code> </li> \n   <li>大约 <code>2.30%</code> 的人与我的配置相同</li> \n   <li>大约每 <code>43</code> 个人中有一个和我配置相同</li> \n  </ul> </li> \n</ul> \n<p>如果单独看每个配置，那他们都不能作为你独一无二的特征，但是综合起来看呢？比如就看这三项，三项的配置与你都相同的人的概率就会大大减小了。以上只是一些简单的特征，比如系统版本，浏览器版本，这些只需要一个简单的 <code>navigator.userAgent</code> 属性就可以拿到。</p> \n<p>像这样的属性还有非常多个，他们可能来自 <code>HTTP Header</code>、<code>Javascript attributes</code>、<code>浏览器插件</code> 等等</p> \n<h3>HTTP Header</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386181\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>上面的 <code>HTTP Header</code> 中就包含了大量的定制化特性，可以看到每一项配置中与我相同的概率是非常低的，然而这些信息属于普通的浏览器指纹，普通指纹可以理解为容易被发现并且容易修改的部分，而且你也可以轻易的篡改他们，有些配置比如 <code>User-Agent</code> 、<code>language</code> 使用 <code>JavaScript</code> 的 <code>navigator</code> 对象获取是最准确而且不会被篡改的。下面还有一些其他常见的 <code>JavaScript</code> 属性：</p> \n<h3>Javascript attributes</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386177\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这里面包含一些使用 <code>Javascript</code> 很容易获取的一些配置：</p> \n<ul> \n <li> <code>Screen width</code>：屏幕宽度</li> \n <li> <code>Screen height</code>：屏幕高度</li> \n <li> <code>Cookies enabled</code>：是否允许 <code>Cookie</code> </li> \n <li> <code>Content language</code>：语言信息</li> \n <li> <code>List of fonts</code>：字体信息</li> \n <li> <code>Timezone</code>：时区信息</li> \n <li> <code>Navigator properties：Navigator</code> 对象中包含的属性信息</li> \n <li>...</li> \n</ul> \n<p>以上这些信息非常容易获取，而且带有的信息较少，最后生成出来的指纹可能碰撞的概率就越大，实际上通过 <code>JS</code> 能获取的远不止这些，下面还有一些重复率非常低的指标：</p> \n<h3>Canvas 指纹</h3> \n<p><code>Canvas</code> 是 <code>HTML5</code> 中用于在网页上绘制 <code>2D</code> 图形元素。浏览器在绘制图形时，会调用操作系统的绘图接口，即便使用 <code>Cavans</code> 绘制相同的元素，但是由于系统的差别，不同浏览器使用了不同的图形处理引擎、不同的图片导出选项、不同的默认压缩级别、对抗锯齿、次像素渲染等算法也不同。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386182\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>具体获取流程如下：在画布上渲染一些文字，再用 <code>toDataURL</code> 转换出来，你就会得到属于你的 <code>Cavans</code> 指纹：</p> \n<pre><code class=\"js\">    const canvas = document.getElementById(\"canvas-fingerprint\");\n    const context = canvas.getContext(\"2d\");\n    context.font = \"18pt Arial\";\n    context.textBaseline = \"top\";\n    context.fillText(\"canvas-fingerprint-test\", 2, 2);\n    return canvas.toDataURL(\"image/jpeg\");</code></pre> \n<p>上面的图中可以看到，<code>Canvas</code> 指纹和我相同的概率是 <code>&lt;0.01%</code> 的，可见这是一个在浏览器指纹中非常重要的指标。</p> \n<h3>WebGL</h3> \n<p><code>WebGL</code> 是一种用于在网页上呈现3D图像的 <code>JavaScript</code> 浏览器API。网站可利用 <code>WebGL</code> 来识别你的设备指纹：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386185\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li> <code>WebGL</code> 报告 —— 完整的 <code>WebGL</code> 浏览器报告表是可获取、可被检测的。在一些情况下，它会被转换成为哈希值以便更快地进行分析。</li> \n <li> <code>WebGL</code> 图像 —— 渲染和转换为哈希值的隐藏3D图像。由于最终结果取决于进行计算的硬件设备，因此此方法会为设备及其驱动程序的不同组合生成唯一值。这种方式为不同的设备组合和驱动程序生成了唯一值。</li> \n</ul> \n<h3>WebRTC</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386184\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><code>WebRTC</code> （网页实时通信，<code>Web Real Time Communication</code>），是可以让浏览器有音视频实时通信的能力，通常被需要快速直接连接的网络应用程序所应用。即便你使用了代理，网站也能借此获取你真实的公共和本地IP地址。该插件可被用于泄漏你的本地 <code>IP</code> 地址或追踪媒体设备。<code>WebRTC</code> 会暴露你的：</p> \n<ul> \n <li>公共IP地址</li> \n <li>本地IP地址</li> \n <li>媒体设备的数量及其哈希值</li> \n</ul> \n<h3>CSS</h3> \n<p>就算用户禁用了 <code>JavaScript</code> ，网站也可以通过纯 <code>CSS</code> 来获取到一些信息，比如这样：</p> \n<pre><code>@media(device-width: 1920px) {\n  body {\n    background: url(\"https://example.org/1920.png\");\n  }\n}</code></pre> \n<p>通过统计 <code>1920.png</code> 这个图片的请求日志，便可知道有哪些用户的窗口宽度是 <code>1920px</code>。</p> \n<h3>UUID 的计算</h3> \n<p>综合以上的指标特征，可以计算出一个属于你自己的唯一的 <code>uuid</code>，这就是你的 \"浏览器指纹\" 了。当然，计算时不能简单的将上述指标进行叠加，因为某些指标在一些场景下聚合度比较高，每个指标带来的信息量也不相同，一般每个指标都拥有一个自己的 \"信息熵\" :</p> \n<blockquote>\n 信息熵（entropy）是接收的每条消息中包含的信息的平均量，熵越高，则能传输越多的信息，熵越低，则意味着传输的信息越少。\n</blockquote> \n<p>在计算 <code>uuid</code> 时，一般信息熵较大的指标会拥有较大的权重，这样可以大大降低碰撞率，提高 <code>uuid</code> 的准确性。</p> \n<p>当然，这些也不用你自己去挨个费劲的去获取了，使用 <code>clientjs</code>（<code>https://github.com/jackspirou/clientjs</code>） 可以轻而易举的帮你获取这些指标，并最终获取 <code>uuid</code>：</p> \n<pre><code class=\"js\">// Create a new ClientJS object\nconst client = new ClientJS();\n\n// Get the client\'s fingerprint id\nconst fingerprint = client.getFingerprint();\n\n// Print the 32bit hash id to the console\nconsole.log(fingerprint);</code></pre> \n<p>你也可以单独获取这些信息：</p> \n<pre><code class=\"js\">  const client = new ClientJS();\n  client.getBrowserData();\n  client.getFingerprint();\n  client.getCustomFingerprint(...);\n  client.isCanvas();\n  client.getCanvasPrint();\n  client.getFlashVersion();\n  client.isSilverlight();\n  client.getSilverlightVersion();\n  // 。。。</code></pre> \n<h2>参考</h2> \n<ul> \n <li><a href=\"https://zhuanlan.zhihu.com/p/34591096\" rel=\"nofollow noreferrer\">https://zhuanlan.zhihu.com/p/...</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s/5-oObFPiRP6a5O49YsS9wg\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/5-...</a></li> \n <li><a href=\"https://juejin.im/post/5d97fb5ef265da5ba12cdea9\" rel=\"nofollow noreferrer\">https://juejin.im/post/5d97fb...</a></li> \n</ul> \n<h2>小结</h2> \n<p>作为一名普通用户，我会感叹，太难了，我很难保护我的个人隐私，收集我信息的平台无处不在，收集我信息的手段也是各种各样。。。</p> \n<p>在现实世界里，没有什么会保持不变的。</p> \n<p>作为一名开发者，你要时刻保持警惕，有危机意识，第一时间更新你的技术以应对外部环境的变化，否则你就会被淘汰。</p> \n<p>文中如有错误，欢迎在评论区指正，如果这篇文章帮助到了你，欢迎点赞和关注。</p> \n<p>想阅读更多优质文章、可关注我的<a href=\"https://github.com/ConardLi/ConardLi.github.io\" rel=\"nofollow noreferrer\">github博客</a>，你的star✨、点赞和关注是我持续创作的动力！</p> \n<p>推荐关注我的微信公众号【code秘密花园】，每天推送高质量文章，我们一起交流成长。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022386186\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p>', 'https://segmentfault.com/img/remote/1460000022386156', '6fbfa4aaad3a43458f21c8acf0038ac5', '63c4e1e7ec204b43a62065a3ced4c2ce,d79254c4ca5e45dca9d484307c935281,b456ad7a7d1d468ba659bb4c31f24e99,63b70326a7b34ffeb8eeb2f0098c86c1,e75baefb206a4efe959a99aad77632a3', '0', '3', '1', '2020-04-16 16:48:02', '2020-04-16 16:48:02');
INSERT INTO `tb_recommend` VALUES ('9d23e9ca4fda403e9d9117648db070ee', '值得一看的35个Redis面试题总结', '1.什么是redis? Redis 是一个基于内存的高性能key-value数据库。  2.Reids的特点　　 Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381180\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>1.什么是redis?</strong></p> \n<p>Redis 是一个基于内存的高性能key-value数据库。&nbsp; </p> \n<p><strong>2.Reids的特点　</strong>　</p> \n<p>Redis本质上是一个Key-Value类型的内存数据库，很像memcached，整个数据库统统加载在内存当中进行操作，定期通过异步操作把数据库数据flush到硬盘上进行保存。</p> \n<p>因为是纯内存操作，Redis的性能非常出色，每秒可以处理超过 10万次读写操作，是已知性能最快的Key-Value DB。</p> \n<p>Redis的出色之处不仅仅是性能，Redis最大的魅力是支持保存多种数据结构，此外单个value的最大限制是1GB，不像 memcached只能保存1MB的数据，因此Redis可以用来实现很多有用的功能。</p> \n<p>比方说用他的List来做FIFO双向链表，实现一个轻量级的高性 能消息队列服务，用他的Set可以做高性能的tag系统等等。另外Redis也可以对存入的Key-Value设置expire时间，因此也可以被当作一 个功能加强版的memcached来用。</p> \n<p>Redis的主要缺点是数据库容量受到物理内存的限制，不能用作海量数据的高性能读写，因此Redis适合的场景主要局限在较小数据量的高性能操作和运算上。</p> \n<p><strong>3.使用redis有哪些好处？</strong>　</p> \n<ol> \n <li>速度快，因为数据存在内存中，类似于HashMap，HashMap的优势就是查找和操作的时间复杂度都是O(1)&nbsp;</li> \n <li>支持丰富数据类型，支持string，list，set，sorted set，hash&nbsp;</li> \n <li>支持事务，操作都是原子性，所谓的原子性就是对数据的更改要么全部执行，要么全部不执行&nbsp;</li> \n <li>丰富的特性：可用于缓存，消息，按key设置过期时间，过期后将会自动删除</li> \n</ol> \n<p><strong>4.redis相比memcached有哪些优势？ 　</strong>　</p> \n<ol> \n <li>memcached所有的值均是简单的字符串，redis作为其替代者，支持更为丰富的数据类型&nbsp;</li> \n <li>redis的速度比memcached快很多</li> \n <li>redis可以持久化其数据</li> \n</ol> \n<p><strong>5.Memcache与Redis的区别都有哪些？&nbsp;</strong>&nbsp;&nbsp;</p> \n<ol> \n <li>存储方式 Memecache把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小。 Redis有部份存在硬盘上，这样能保证数据的持久性。&nbsp;</li> \n <li>数据支持类型 Memcache对数据类型支持相对简单。 Redis有复杂的数据类型。&nbsp;</li> \n <li>使用底层模型不同 它们之间底层实现方式 以及与客户端之间通信的应用协议不一样。 Redis直接自己构建了VM 机制 ，因为一般的系统调用系统函数的话，会浪费一定的时间去移动和请求。&nbsp;</li> \n</ol> \n<p><strong>6.redis常见性能问题和解决方案：</strong></p> \n<ol> \n <li>Master写内存快照，save命令调度rdbSave函数，会阻塞主线程的工作，当快照比较大时对性能影响是非常大的，会间断性暂停服务，所以Master最好不要写内存快照。</li> \n <li>Master AOF持久化，如果不重写AOF文件，这个持久化方式对性能的影响是最小的，但是AOF文件会不断增大，AOF文件过大会影响Master重启的恢复速度。Master最好不要做任何持久化工作，包括内存快照和AOF日志文件，特别是不要启用内存快照做持久化,如果数据比较关键，某个Slave开启AOF备份数据，策略为每秒同步一次。</li> \n <li>Master调用BGREWRITEAOF重写AOF文件，AOF在重写的时候会占大量的CPU和内存资源，导致服务load过高，出现短暂服务暂停现象。</li> \n <li>Redis主从复制的性能问题，为了主从复制的速度和连接的稳定性，Slave和Master最好在同一个局域网内</li> \n</ol> \n<p><strong>7. mySQL里有2000w数据，redis中只存20w的数据，如何保证redis中的数据都是热点数据</strong></p> \n<p><em>相关知识：redis 内存数据集大小上升到一定大小的时候，就会施行数据淘汰策略（回收策略）。</em></p> \n<p><strong>redis 提供 6种数据淘汰策略：</strong></p> \n<ol> \n <li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li> \n <li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li> \n <li>volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li> \n <li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li> \n <li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li> \n <li>no-enviction（驱逐）：禁止驱逐数据</li> \n</ol> \n<p><strong>8.请用Redis和任意语言实现一段恶意登录保护的代码，限制1小时内每用户Id最多只能登录5次。具体登录函数或功能用空函数即可，不用详细写出。</strong>&nbsp;</p> \n<p>用列表实现:列表中每个元素代表登陆时间,只要最后的第5次登陆时间和现在时间差不超过1小时就禁止登陆.用Python写的代码如下：</p> \n<pre><code>#!/usr/bin/env&nbsp;python3\nimport redis &nbsp;\nimport sys &nbsp;\nimport time\n\nr = redis.StrictRedis(host=’127.0.0.1′, port=6379, db=0) &nbsp;\ntry:\n   id = sys.argv[1]\nexcept:&nbsp;\n   print(‘input&nbsp;argument&nbsp;error’) \n   sys.exit(0) &nbsp;\n\nif&nbsp;r.llen(id) &gt;=&nbsp;5&nbsp;and&nbsp;time.time() – float(r.lindex(id,&nbsp;4)) &lt;=&nbsp;3600:\n   print(“you are forbidden logining”)\nelse: &nbsp; &nbsp; &nbsp;&nbsp;&nbsp; &nbsp;\n   print(‘you are allowed&nbsp;to&nbsp;login’)\n   r.lpush(id, time.time()) \n   # login_func()</code></pre> \n<p><strong>9.为什么redis需要把所有数据放到内存中?　</strong></p> \n<p>Redis为了达到最快的读写速度将数据都读到内存中，并通过异步的方式将数据写入磁盘。所以redis具有快速和数据持久化的特征。如果不将数据放在内存中，磁盘I/O速度为严重影响redis的性能。在内存越来越便宜的今天，redis将会越来越受欢迎。</p> \n<p>如果设置了最大使用的内存，则数据已有记录数达到内存限值后不能继续插入新值。</p> \n<p><strong>10.Redis是单进程单线程的</strong></p> \n<p>redis利用队列技术将并发访问变为串行访问，消除了传统数据库串行控制的开销</p> \n<p><strong>11.redis的并发竞争问题如何解决?</strong></p> \n<p>Redis为单进程单线程模式，采用队列模式将并发访问变为串行访问。Redis本身没有锁的概念，Redis对于多个客户端连接并不存在竞争，但是在Jedis客户端对Redis进行并发访问时会发生连接超时、数据转换错误、阻塞、客户端关闭连接等问题，这些问题均是由于客户端连接混乱造成。</p> \n<p><strong>对此有2种解决方法：</strong></p> \n<p>1.客户端角度，为保证每个客户端间正常有序与Redis进行通信，对连接进行池化，同时对客户端读写Redis操作采用内部锁synchronized。 </p> \n<p>2.服务器角度，利用setnx实现锁。 </p> \n<p><em>注：对于第一种，需要应用程序自己处理资源的同步，可以使用的方法比较通俗，可以使用synchronized也可以使用lock；第二种需要用到Redis的setnx命令，但是需要注意一些问题。</em></p> \n<p><strong>12.redis事物的了解CAS(check-and-set 操作实现乐观锁 )?</strong></p> \n<p>和众多其它数据库一样，Redis作为NoSQL数据库也同样提供了事务机制。在Redis中，MULTI/EXEC/DISCARD/WATCH这四个命令是我们实现事务的基石。</p> \n<p>相信对有关系型数据库开发经验的开发者而言这一概念并不陌生，即便如此，我们还是会简要的列出<strong>Redis中事务的实现特征</strong>：</p> \n<ol> \n <li>在事务中的所有命令都将会被串行化的顺序执行，事务执行期间，Redis不会再为其它客户端的请求提供任何服务，从而保证了事物中的所有命令被原子的执行。</li> \n <li>和关系型数据库中的事务相比，在Redis事务中如果有某一条命令执行失败，其后的命令仍然会被继续执行。</li> \n <li>我们可以通过MULTI命令开启一个事务，有关系型数据库开发经验的人可以将其理解为\"BEGIN TRANSACTION\"语句。在该语句之后执行的命令都将被视为事务之内的操作，最后我们可以通过执行EXEC/DISCARD命令来提交/回滚该事务内的所有操作。这两个Redis命令可被视为等同于关系型数据库中的COMMIT/ROLLBACK语句。</li> \n <li>在事务开启之前，如果客户端与服务器之间出现通讯故障并导致网络断开，其后所有待执行的语句都将不会被服务器执行。然而如果网络中断事件是发生在客户端执行EXEC命令之后，那么该事务中的所有命令都会被服务器执行。</li> \n <li>当使用Append-Only模式时，Redis会通过调用系统函数write将该事务内的所有写操作在本次调用中全部写入磁盘。然而如果在写入的过程中出现系统崩溃，如电源故障导致的宕机，那么此时也许只有部分数据被写入到磁盘，而另外一部分数据却已经丢失。</li> \n</ol> \n<p>Redis服务器会在重新启动时执行一系列必要的一致性检测，一旦发现类似问题，就会立即退出并给出相应的错误提示。</p> \n<p>此时，我们就要充分利用Redis工具包中提供的redis-check-aof工具，该工具可以帮助我们定位到数据不一致的错误，并将已经写入的部分数据进行回滚。修复之后我们就可以再次重新启动Redis服务器了。</p> \n<p><strong>13.WATCH命令和基于CAS的乐观锁：</strong>　</p> \n<p>在Redis的事务中，WATCH命令可用于提供CAS(check-and-set)功能。假设我们通过WATCH命令在事务执行之前监控了多个Keys，倘若在WATCH之后有任何Key的值发生了变化，EXEC命令执行的事务都将被放弃，同时返回Null multi-bulk应答以通知调用者事务</p> \n<p>执行失败。例如，我们再次假设Redis中并未提供incr命令来完成键值的原子性递增，如果要实现该功能，我们只能自行编写相应的代码。其伪码如下：</p> \n<pre><code>val&nbsp;= GET mykey\nval = val +&nbsp;1\nSET mykey&nbsp;$val</code></pre> \n<p>以上代码只有在单连接的情况下才可以保证执行结果是正确的，因为如果在同一时刻有多个客户端在同时执行该段代码，那么就会出现多线程程序中经常出现的一种错误场景--竞态争用(race condition)。</p> \n<p>比如，客户端A和B都在同一时刻读取了mykey的原有值，假设该值为10，此后两个客户端又均将该值加一后set回Redis服务器，这样就会导致mykey的结果为11，而不是我们认为的12。为了解决类似的问题，我们需要借助WATCH命令的帮助，见如下代码：</p> \n<pre><code>WATCH&nbsp;mykey\nval = GET mykey\nval = val +&nbsp;1\nMULTI\nSET mykey&nbsp;$val\nEXEC</code></pre> \n<p>和此前代码不同的是，新代码在获取mykey的值之前先通过WATCH命令监控了该键，此后又将set命令包围在事务中，这样就可以有效的保证每个连接在执行EXEC之前，如果当前连接获取的mykey的值被其它连接的客户端修改，那么当前连接的EXEC命令将执行失败。这样调用者在判断返回值后就可以获悉val是否被重新设置成功。 </p> \n<p><strong>14.redis持久化的几种方式</strong></p> \n<p><strong>1、快照（snapshots）</strong></p> \n<p>缺省情况情况下，Redis把数据快照存放在磁盘上的二进制文件中，文件名为dump.rdb。你可以配置Redis的持久化策略，例如数据集中每N秒钟有超过M次更新，就将数据写入磁盘；或者你可以手工调用命令SAVE或BGSAVE。</p> \n<p><strong>工作原理</strong></p> \n<ul> \n <li>Redis forks.</li> \n <li>子进程开始将数据写到临时RDB文件中。</li> \n <li>当子进程完成写RDB文件，用新文件替换老文件。</li> \n <li>这种方式可以使Redis使用copy-on-write技术。</li> \n</ul> \n<p><strong>2、AOF</strong></p> \n<p>快照模式并不十分健壮，当系统停止，或者无意中Redis被kill掉，最后写入Redis的数据就会丢失。</p> \n<p>这对某些应用也许不是大问题，但对于要求高可靠性的应用来说，Redis就不是一个合适的选择。Append-only文件模式是另一种选择。你可以在配置文件中打开AOF模式</p> \n<p><strong>3、虚拟内存方式</strong></p> \n<p>当你的key很小而value很大时,使用VM的效果会比较好.因为这样节约的内存比较大.</p> \n<p>当你的key不小时,可以考虑使用一些非常方法将很大的key变成很大的value,比如你可以考虑将key,value组合成一个新的value.</p> \n<p>vm-max-threads这个参数,可以设置访问swap文件的线程数,设置最好不要超过机器的核数,如果设置为0,那么所有对swap文件的操作都是串行的.可能会造成比较长时间的延迟,但是对数据完整性有很好的保证.</p> \n<p>自己测试的时候发现用虚拟内存性能也不错。如果数据量很大，可以考虑分布式或者其他数据库。</p> \n<p><strong>15.redis的缓存失效策略和主键失效机制</strong></p> \n<p>作为缓存系统都要定期清理无效数据，就需要一个主键失效和淘汰策略. </p> \n<p>在Redis当中，有生存期的key被称为volatile。在创建缓存时，要为给定的key设置生存期，当key过期的时候（生存期为0），它可能会被删除。</p> \n<p><strong>1、影响生存时间的一些操作</strong></p> \n<p>生存时间可以通过使用 DEL 命令来删除整个 key 来移除，或者被 SET 和 GETSET 命令覆盖原来的数据，也就是说，修改key对应的value和使用另外相同的key和value来覆盖以后，当前数据的生存时间不同。</p> \n<p>比如说，对一个 key 执行INCR命令，对一个列表进行LPUSH命令，或者对一个哈希表执行HSET命令，这类操作都不会修改 key 本身的生存时间。另一方面，如果使用RENAME对一个 key 进行改名，那么改名后的 key的生存时间和改名前一样。</p> \n<p>RENAME命令的另一种可能是，尝试将一个带生存时间的 key 改名成另一个带生存时间的 another_key ，这时旧的 another_key (以及它的生存时间)会被删除，然后旧的 key 会改名为 another_key ，因此，新的 another_key 的生存时间也和原本的 key 一样。使用PERSIST命令可以在不删除 key 的情况下，移除 key 的生存时间，让 key 重新成为一个persistent key 。</p> \n<p><strong>2、如何更新生存时间</strong></p> \n<p>可以对一个已经带有生存时间的 key 执行EXPIRE命令，新指定的生存时间会取代旧的生存时间。过期时间的精度已经被控制在1ms之内，主键失效的时间复杂度是O（1），EXPIRE和TTL命令搭配使用，TTL可以查看key的当前生存时间。设置成功返回 1；当 key 不存在或者不能为 key 设置生存时间时，返回 0 。</p> \n<p><strong>最大缓存配置：</strong></p> \n<p>在 redis 中，允许用户设置最大使用内存大小，server.maxmemory默认为0，没有指定最大缓存，如果有新的数据添加，超过最大内存，则会使redis崩溃，所以一定要设置。redis 内存数据集大小上升到一定大小的时候，就会实行数据淘汰策略。</p> \n<p><strong>redis 提供 6种数据淘汰策略：</strong></p> \n<ol> \n <li>volatile-lru：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li> \n <li>volatile-ttl：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li> \n <li>&nbsp;volatile-random：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li> \n <li>allkeys-lru：从数据集（server.db[i].dict）中挑选最近最少使用的数据淘汰</li> \n <li>allkeys-random：从数据集（server.db[i].dict）中任意选择数据淘汰</li> \n <li>no-enviction（驱逐）：禁止驱逐数据</li> \n</ol> \n<p>注意这里的6种机制，volatile和allkeys规定了是对已设置过期时间的数据集淘汰数据还是从全部数据集淘汰数据，后面的lru、ttl以及random是三种不同的淘汰策略，再加上一种no-enviction永不回收的策略。</p> \n<p><strong>使用策略规则：</strong></p> \n<ol> \n <li>如果数据呈现幂律分布，也就是一部分数据访问频率高，一部分数据访问频率低，则使用allkeys-lru</li> \n <li>如果数据呈现平等分布，也就是所有的数据访问频率都相同，则使用allkeys-random</li> \n</ol> \n<p><strong>三种数据淘汰策略：</strong></p> \n<p>ttl和random比较容易理解，实现也会比较简单。主要是Lru最近最少使用淘汰策略，设计上会对key 按失效时间排序，然后取最先失效的key进行淘汰</p> \n<p><strong>16.redis 最适合的场景　</strong>　</p> \n<p>Redis最适合所有数据in-momory的场景，虽然Redis也提供持久化功能，但实际更多的是一个disk-backed的功能，跟传统意义上的持久化有比较大的差别，那么可能大家就会有疑问，似乎Redis更像一个加强版的Memcached，那么何时使用Memcached，何时使用Redis呢?</p> \n<p>如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：</p> \n<ol> \n <li>Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。</li> \n <li>Redis支持数据的备份，即master-slave模式的数据备份。</li> \n <li>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。</li> \n</ol> \n<p><strong>1、会话缓存（Session Cache）</strong></p> \n<p>最常用的一种使用Redis的情景是会话缓存（session cache）。用Redis缓存会话比其他存储（如Memcached）的优势在于：Redis提供持久化。当维护一个不是严格要求一致性的缓存时，如果用户的购物车信息全部丢失，大部分人都会不高兴的，现在，他们还会这样吗？</p> \n<p>幸运的是，随着 Redis 这些年的改进，很容易找到怎么恰当的使用Redis来缓存会话的文档。甚至广为人知的商业平台Magento也提供Redis的插件。</p> \n<p><strong>2、全页缓存（FPC）</strong></p> \n<p>除基本的会话token之外，Redis还提供很简便的FPC平台。回到一致性问题，即使重启了Redis实例，因为有磁盘的持久化，用户也不会看到页面加载速度的下降，这是一个极大改进，类似PHP本地FPC。 </p> \n<p>再次以Magento为例，Magento提供一个插件来使用Redis作为全页缓存后端。</p> \n<p>此外，对WordPress的用户来说，Pantheon有一个非常好的插件 wp-redis，这个插件能帮助你以最快速度加载你曾浏览过的页面。</p> \n<p><strong>3、队列</strong></p> \n<p>Reids在内存存储引擎领域的一大优点是提供 list 和 set 操作，这使得Redis能作为一个很好的消息队列平台来使用。Redis作为队列使用的操作，就类似于本地程序语言（如Python）对 list 的 push/pop 操作。 </p> \n<p>如果你快速的在Google中搜索“Redis queues”，你马上就能找到大量的开源项目，这些项目的目的就是利用Redis创建非常好的后端工具，以满足各种队列需求。例如，Celery有一个后台就是使用Redis作为broker，你可以从这里去查看。</p> \n<p><strong>4、排行榜/计数器</strong></p> \n<p>Redis在内存中对数字进行递增或递减的操作实现的非常好。集合（Set）和有序集合（Sorted Set）也使得我们在执行这些操作的时候变的非常简单，Redis只是正好提供了这两种数据结构。</p> \n<p>所以，我们要从排序集合中获取到排名最靠前的10个用户–我们称之为“user_scores”，我们只需要像下面一样执行即可：</p> \n<p>当然，这是假定你是根据你用户的分数做递增的排序。如果你想返回用户及用户的分数，你需要这样执行：</p> \n<pre><code>ZRANGE&nbsp;user_scores&nbsp;0&nbsp;10&nbsp;WITHSCORES</code></pre> \n<p>Agora Games就是一个很好的例子，用Ruby实现的，它的排行榜就是使用Redis来存储数据的，你可以在这里看到。 </p> \n<p><strong>5、发布/订阅</strong></p> \n<p>最后（但肯定不是最不重要的）是Redis的发布/订阅功能。发布/订阅的使用场景确实非常多。我已看见人们在社交网络连接中使用，还可作为基于发布/订阅的脚本触发器，甚至用Redis的发布/订阅功能来建立聊天系统！（不，这是真的，你可以去核实）。</p> \n<p>Redis提供的所有特性中，我感觉这个是喜欢的人最少的一个，虽然它为用户提供如果此多功能。</p> \n<p><strong>17、Redis集群方案什么情况下会导致整个集群不可用？</strong></p> \n<p>有A，B，C三个节点的集群,在没有复制模型的情况下,如果节点B失败了，那么整个集群就会以为缺少5501-11000这个范围的槽而不可用。</p> \n<p><strong>18、Redis支持的Java客户端都有哪些？官方推荐用哪个？</strong></p> \n<p>Redisson、Jedis、lettuce等等，官方推荐使用Redisson。</p> \n<p><strong>19、Redis和Redisson有什么关系？</strong></p> \n<p>Redisson是一个高级的分布式协调Redis客服端，能帮助用户在分布式环境中轻松实现一些Java的对象 (Bloom filter, BitSet, Set, SetMultimap, ScoredSortedSet, SortedSet, Map, ConcurrentMap, List, ListMultimap, Queue, BlockingQueue, Deque, BlockingDeque, Semaphore, Lock, ReadWriteLock, AtomicLong, CountDownLatch, Publish / Subscribe, HyperLogLog)。</p> \n<p><strong>20、Jedis与Redisson对比有什么优缺点？</strong></p> \n<p>Jedis是Redis的Java实现的客户端，其API提供了比较全面的Redis命令的支持；</p> \n<p>Redisson实现了分布式和可扩展的Java数据结构，和Jedis相比，功能较为简单，不支持字符串操作，不支持排序、事务、管道、分区等Redis特性。Redisson的宗旨是促进使用者对Redis的关注分离，从而让使用者能够将精力更集中地放在处理业务逻辑上。</p> \n<p><strong>21、Redis如何设置密码及验证密码？</strong></p> \n<pre><code>设置密码：config set requirepass 123456\n\n授权密码：auth 123456\n</code></pre> \n<p><strong>22、说说Redis哈希槽的概念？</strong></p> \n<p>Redis集群没有使用一致性hash,而是引入了哈希槽的概念，Redis集群有16384个哈希槽，每个key通过CRC16校验后对16384取模来决定放置哪个槽，集群的每个节点负责一部分hash槽。</p> \n<p><strong>23、Redis集群的主从复制模型是怎样的？</strong></p> \n<p>为了使在部分节点失败或者大部分节点无法通信的情况下集群仍然可用，所以集群使用了主从复制模型,每个节点都会有N-1个复制品.</p> \n<p><strong>24、Redis集群会有写操作丢失吗？为什么？</strong></p> \n<p>Redis并不能保证数据的强一致性，这意味这在实际中集群在特定的条件下可能会丢失写操作。</p> \n<p><strong>25、Redis集群之间是如何复制的？</strong></p> \n<p>异步复制</p> \n<p><strong>26、Redis集群最大节点个数是多少？</strong></p> \n<p>16384个。</p> \n<p><strong>27、Redis集群如何选择数据库？</strong></p> \n<p>Redis集群目前无法做数据库选择，默认在0数据库。</p> \n<p><strong>28、怎么测试Redis的连通性？</strong></p> \n<p>ping</p> \n<p><strong>29、Redis中的管道有什么用？</strong></p> \n<p>一次请求/响应服务器能实现处理新的请求即使旧的请求还未被响应。这样就可以将多个命令发送到服务器，而不用等待回复，最后在一个步骤中读取该答复。</p> \n<p>这就是管道（pipelining），是一种几十年来广泛使用的技术。例如许多POP3协议已经实现支持这个功能，大大加快了从服务器下载新邮件的过程。</p> \n<p><strong>30、怎么理解Redis事务？</strong></p> \n<p>事务是一个单独的隔离操作：事务中的所有命令都会序列化、按顺序地执行。事务在执行的过程中，不会被其他客户端发送来的命令请求所打断。</p> \n<p>事务是一个原子操作：事务中的命令要么全部被执行，要么全部都不执行。</p> \n<p><strong>31、Redis事务相关的命令有哪几个？</strong></p> \n<pre><code>MULTI、EXEC、DISCARD、WATCH</code></pre> \n<p><strong>32、Redis key的过期时间和永久有效分别怎么设置？</strong></p> \n<pre><code>EXPIRE和PERSIST命令。</code></pre> \n<p><strong>33、Redis如何做内存优化？</strong></p> \n<p>尽可能使用散列表（hashes），散列表（是说散列表里面存储的数少）使用的内存非常小，所以你应该尽可能的将你的数据模型抽象到一个散列表里面。</p> \n<p>比如你的web系统中有一个用户对象，不要为这个用户的名称，姓氏，邮箱，密码设置单独的key,而是应该把这个用户的所有信息存储到一张散列表里面。</p> \n<p><strong>34、Redis回收进程如何工作的？</strong></p> \n<p>一个客户端运行了新的命令，添加了新的数据。</p> \n<p>Redi检查内存使用情况，如果大于maxmemory的限制, 则根据设定好的策略进行回收。</p> \n<p>一个新的命令被执行，等等。</p> \n<p>所以我们不断地穿越内存限制的边界，通过不断达到边界然后不断地回收回到边界以下。</p> \n<p>如果一个命令的结果导致大量内存被使用（例如很大的集合的交集保存到一个新的键），不用多久内存限制就会被这个内存使用量超越。</p> \n<p><strong>35、Redis集群方案应该怎么做？都有哪些方案？</strong></p> \n<p>1.codis。</p> \n<p>目前用的最多的集群方案，基本和twemproxy一致的效果，但它支持在 节点数量改变情况下，旧节点数据可恢复到新hash节点。</p> \n<p>2.redis cluster3.0自带的集群，特点在于他的分布式算法不是一致性hash，而是hash槽的概念，以及自身支持节点设置从节点。具体看官方文档介绍。</p> \n<p>3.在业务代码层实现，起几个毫无关联的redis实例，在代码层，对key 进行hash计算，然后去对应的redis实例操作数据。 这种方式对hash层代码要求比较高，考虑部分包括，节点失效后的替代算法方案，数据震荡后的自动脚本恢复，实例的监控，等等。</p>', 'https://segmentfault.com/img/remote/1460000022381180', 'c56940aa8b004dab84568e86900b2ee6', '55723db96b9f4593bae02bc1e49f1e87,90ebd6b2270249dc8580eb97aa14aa02,d7416e100af54eb7a4d9274b9a462240,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 16:48:58', '2020-04-16 16:48:58');
INSERT INTO `tb_recommend` VALUES ('9d923fd37b3b4e988af8e2a4acead640', '谷歌开源数据集模型，可从录音混音中分离出不同声音', '近期，随着市场对音视频领域的需求和技术发展，包括阿里巴巴和微软在内的科技巨头都投入了大量时间和资源试图解决声音分离问题。近日，谷歌发布了一个新的数据集 —— 自由通用声音分离数据集，简称 FUSS，旨在支持...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFVyT\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>近期，随着市场对音视频领域的需求和技术发展，包括阿里巴巴和微软在内的科技巨头都投入了大量时间和资源试图解决声音分离问题。近日，谷歌发布了一个新的数据集 —— 自由通用声音分离数据集，简称 FUSS，旨在支持开发能够从录音混音中分离出不同声音的 AI 模型。</p> \n<p>根据报告显示，该模型的使用场景非常丰富，如果将其商业化，FUSS 可能会被用于企业用于从电话会议中提取语音。</p> \n<p>这是继谷歌和瑞士 Idiap 研究所的一项研究之后，该研究描述了两种机器学习模型 -- 扬声器识别网络和频谱掩码网络 -- 共同 \"显著降低了多扬声器信号上的语音识别单词错误率（WER）。</p> \n<hr> \n<p>正如 Google Research 的科学家 John Hershey、Scott Wisdom 和 Hakan Erdogan 在一篇文章中解释的那样，大部分的声音分离模型都假设混合物中的声音数量是静态的，它们要么将少数声音类型的混合物（如语音与非语音）或同一声音类型的不同实例（如第一个扬声器与第二个扬声器）分离出来。FUSS 数据集则将焦点转移到更普遍的问题上，即将任意数量的声音从彼此之间分离出来。</p> \n<p>为此，FUSS 数据集包括了一组不同的声音，一个逼真的房间模拟器，以及将这些元素混合在一起的代码，以实现多源、多类音频的真实性。</p> \n<p>谷歌的研究人员从 FreeSound.org 中提取音频片段，经过过滤，排除了那些在混合在一起时无法被人类分离的声音，他们编译了包括 12377 个混合声音长达 23 个小时的音频，从中产生了 20000 个混合声音，用于训练 AI 模型，另外还有 1000 个混合声音用于验证，1000 个混合声音用于评估。</p> \n<p>研究人员表示，他们使用谷歌的 TensorFlow 机器学习框架开发了自己的房间模拟器，该框架可以生成一个具有「频率依赖性」反射属性的箱形房间的脉冲响应，给定一个声源和麦克风位置。FUSS 附带了每个音频样本所使用的预计算房间脉冲响应，以及混音代码。此外，FUSS 还提供了一个预训练的、基于掩码的分离模型，可以高精度地重构多声源混音。</p> \n<p>谷歌团队计划开放房间模拟器的代码，并计划扩展该模拟器，以解决计算成本更高的声学特性，以及具有不同反射特性的材料和新颖的房间形状。</p> \n<p>\"我们希望「FUSS 数据集」能够降低新研究的门槛，特别是能够快速迭代和应用来自其他机器学习领域的新技术来应对声音分离的挑战。\"</p> \n<blockquote> \n <strong>GitHub 地址：</strong> \n <br>\n <a href=\"https://github.com/google-research/sound-separation\" rel=\"nofollow noreferrer\">https://github.com/google-res...</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyR0\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFVyT', '1894b118d35d44cb8fe8009529c4154b', '6224a68b52f54990a07d51854b320f32,2a09bf1afefd4d659606f43445741ee3,0e8101b2d5224b029a5f8f4b0948a37e,382be152cdba43989a2a4408c1116f87', '0', '3', '1', '2020-04-16 16:55:39', '2020-04-16 16:55:39');
INSERT INTO `tb_recommend` VALUES ('9dc15dc9b4fd4eb28d62cb21696ed8bb', 'Linux 基金会正在扩大 2020 年奖学金计划，以帮助更多有需要的人', 'SegmentFault 思否消息：鉴于 COVID-19 大流行，Linux 基金会发布公告宣布正在扩大今年的奖学金计划（The Linux Foundation Training (LiFT) Scholarship Program），以帮助有需要的人。', '<p><strong>技术编辑：鸣飞 发自北京</strong><br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p>SegmentFault 思否消息：鉴于 COVID-19 大流行，Linux 基金会发布公告宣布正在扩大今年的奖学金计划（The Linux Foundation Training (LiFT) Scholarship Program），以帮助有需要的人。</p> \n<p>Linux 基金会将在今年颁发多达 500 个奖学金，自 2011 年该计划启动以来已经授予了 106 个奖学金。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022292114\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"The Linux Foundation Training (LiFT) Scholarship Program\" title=\"The Linux Foundation Training (LiFT) Scholarship Program\"></span></p> \n<p>这是 Linux 基金会第九次主办 Linux 基金会培训（LiFT）奖学金计划，旨在为有前途的开发人员和系统管理员提供机会，他们有希望帮助塑造 Linux 和开源软件的未来，但没有其他方面的帮助参加培训课程的能力。</p> \n<p>申请人可以在世界上的任何地方居住，只要他们对这些技术表现出热情，并且对成为开源专业人士有浓厚的兴趣。</p> \n<p>Linux 基金会培训奖学金将涵盖奖学金获得者选择的每位获奖者选择的一门课程的费用，价值数千美元（不包括亲自参加课程的旅行费用）。在完成培训课程之后，所有类别的优胜者也可以选择免费参加Linux 基金会提供的任何认证考试。奖学金由基金会成员提供支持，他们非常重视帮助培训面向未来的开发人员和 IT 专业人员。</p> \n<p>Linux 基金会致力于将更多本地和国际人才带入开源社区。他的目标是增加获得开源培训的机会，扩大技术多样性，并为通向 IT 行业需求最大，利润最高的工作创造一条清晰的途径。</p> \n<p><strong>Linux 基金会奖学金计划将提供以下 10 个类别的奖学金：</strong></p> \n<ul> \n <li>Open Source Newbies</li> \n <li>Teens-in-Training</li> \n <li>Women in Open Source</li> \n <li>Software Developer Do-Gooder</li> \n <li>SysAdmin Super Star</li> \n <li>Blockchain Blockbuster</li> \n <li>Cloud Captain</li> \n <li>Linux Kernel Guru</li> \n <li>Networking Notable</li> \n <li>Web Development Wiz</li> \n</ul> \n<p><strong>申请必须在 2020 年 4 月 30 日美国太平洋时间晚上 11:59 之前提交。</strong></p> \n<p><strong>申请地址</strong>：<a href=\"https://forms.gle/hRJmrB8ytCxW4rUB6\" rel=\"nofollow noreferrer\">https://forms.gle/hRJmrB8ytCx...</a></p> \n<p><strong>技术编辑：鸣飞 | 发自北京</strong> <br><strong>SegmentFault 思否报道 | 公众号：SegmentFault</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFweb\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"SegmentFault思否微信公众号\" title=\"SegmentFault思否微信公众号\"></span></p>', 'https://segmentfault.com/img/remote/1460000022292114', '692c6787030d4b8882077b2ab9279c52', '753b5aee3913424e81fe2b5299626d8c,f3eb17e6e5664a97af3e9b1fca12b286,81a4561c1c294e0cae32c9fe6b5dc397,aed399344712406e830d6efe028b7fe2', '0', '3', '1', '2020-04-16 16:59:30', '2020-04-16 16:59:30');
INSERT INTO `tb_recommend` VALUES ('9e413e90a89840babb380172ddb2e6a8', '使用 Springboot 开发电商项目之 IDEA 创建项目 (二)', '本博文是按照how2j.cn教程 Java天猫整站Springboot实战项目学习的，该教程是我目前见过最好、最完整、最系统的Java入门学习到实战的课程，作者列了完整的学习路线图，有大量的实战项目，由浅入深，很容易上手。', '<blockquote>\n 本博文是按照\n <a href=\"https://how2j.cn/k/tmall_springboot/tmall_springboot-1799/1799.html?p=126405\" rel=\"nofollow noreferrer\">how2j.cn</a>教程 Java天猫整站Springboot实战项目学习的，该教程是我目前见过最好、最完整、最系统的Java入门学习到实战的课程，作者列了完整的学习路线图，有大量的实战项目，由浅入深，很容易上手。\n</blockquote> \n<h2>一、开发环境</h2> \n<ul> \n <li>OS MacOS</li> \n <li>JDK 1.8</li> \n <li>SpringBoot 1.5.9</li> \n <li>IDEA IDEA 2019</li> \n</ul> \n<h2>二、新建项目</h2> \n<h3>1、新建项目</h3> \n<p>使用 IDEA 新建项目，点击 Create New Project，选中maven webapp格式，然后next：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022290849\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"file\" title=\"file\"></span></p> \n<h3>2、项目参数</h3> \n<p>GroupId: com.how2java.tmall<br>Artifact: tmall_springboot</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022290850\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"file\" title=\"file\"></span></p> \n<h3>3、依赖</h3> \n<ul> \n <li>\n  <ol>\n   <li>左边选中 Web</li>\n  </ol></li> \n <li>\n  <ol>\n   <li>右边选中 Web</li>\n  </ol></li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022290853\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"file\" title=\"file\"></span></p> \n<h3>4、项目路径</h3> \n<p>项目路径选择：</p> \n<pre><code>e:\\project\\tmall_springboot</code></pre> \n<h3>5、Maven仓库</h3> \n<p>Maven仓库配置可以参照我们上一篇博文：<br><a href=\"http://digtime.cn/articles/313/shi-yong-springboot-kuang-jia-kai-fa-dian-shang-xiang-mu-zheng-zhan-zhi-kai-fa-huan-jing-da-jian-yi\" rel=\"nofollow noreferrer\">使用 Springboot 开发电商项目之开发环境搭建 (一)</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022289212\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"file\" title=\"file\"></span></p> \n<h3>6、删除默认类</h3> \n<p>首先删除 <code>TmallSpringbootApplication.java</code> 这个自动创建的类，并且把其包也删除掉。</p> \n<h3>7、配置 pom.xml</h3> \n<p>复制如下内容到已经存在的pom里，如图所示，这个过程会导致idea去下载pom里声明的相关jar包，会花一定的时间，视网络和计算机性能而定。<br>此时会弹出如图所示的提醒，为了避免每次修改 pom.xml 都出现这个对话框，点击 \"<code>Enable Auto-Import</code>\"<br>为了确保导入成功，右键点击pom.xml-&gt;Maven-&gt;Reimport</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022290851\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"file\" title=\"file\"></span></p> \n<pre><code>&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt;\n  &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n  &lt;groupId&gt;com.how2java.tmall&lt;/groupId&gt;\n  &lt;artifactId&gt;tmall_springboot&lt;/artifactId&gt;\n  &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;\n  &lt;name&gt;tmall_springboot&lt;/name&gt;\n  &lt;description&gt;tmall_springboot&lt;/description&gt;\n  &lt;packaging&gt;war&lt;/packaging&gt;\n    &lt;parent&gt;\n        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;\n        &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;\n    &lt;/parent&gt;\n    &lt;dependencies&gt;\n        &lt;!-- springboot web --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- springboot tomcat 支持 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-tomcat&lt;/artifactId&gt;\n            &lt;scope&gt;provided&lt;/scope&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 热部署 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt;\n            &lt;optional&gt;true&lt;/optional&gt;\n        &lt;/dependency&gt;       \n        &lt;!-- jpa--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/dependency&gt;        \n        &lt;!-- redis --&gt;      \n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;\n        &lt;/dependency&gt;    \n        &lt;!-- springboot test --&gt; \n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt; \n        &lt;!-- thymeleaf --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-thymeleaf&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- elastic search --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-elasticsearch&lt;/artifactId&gt;\n        &lt;/dependency&gt;\n        &lt;!-- 用了 elasticsearch 就要加这么一个，不然要com.sun.jna.Native 错误 --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;com.sun.jna&lt;/groupId&gt;\n            &lt;artifactId&gt;jna&lt;/artifactId&gt;\n            &lt;version&gt;3.0.9&lt;/version&gt;\n        &lt;/dependency&gt;        \n                 \n        &lt;!-- thymeleaf legacyhtml5 模式支持 --&gt;      \n        &lt;dependency&gt;\n            &lt;groupId&gt;net.sourceforge.nekohtml&lt;/groupId&gt;\n            &lt;artifactId&gt;nekohtml&lt;/artifactId&gt;\n            &lt;version&gt;1.9.22&lt;/version&gt;\n        &lt;/dependency&gt;        \n        &lt;!-- 测试支持 --&gt;\n        &lt;dependency&gt;\n              &lt;groupId&gt;junit&lt;/groupId&gt;\n              &lt;artifactId&gt;junit&lt;/artifactId&gt;\n              &lt;version&gt;4.12&lt;/version&gt;\n              &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;   \n        &lt;!-- tomcat的支持.--&gt;\n        &lt;dependency&gt;\n               &lt;groupId&gt;org.apache.tomcat.embed&lt;/groupId&gt;\n               &lt;artifactId&gt;tomcat-embed-jasper&lt;/artifactId&gt;\n               &lt;version&gt;8.5.23&lt;/version&gt;\n        &lt;/dependency&gt;    \n        &lt;!-- mysql--&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;mysql&lt;/groupId&gt;\n            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;\n            &lt;version&gt;5.1.21&lt;/version&gt;\n        &lt;/dependency&gt;\n      \n        &lt;!-- junit --&gt;\n        &lt;dependency&gt;\n          &lt;groupId&gt;junit&lt;/groupId&gt;\n          &lt;artifactId&gt;junit&lt;/artifactId&gt;\n          &lt;version&gt; 4.12&lt;/version&gt;\n        &lt;/dependency&gt;                \n        &lt;!-- commons-lang --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;commons-lang&lt;/groupId&gt;\n            &lt;artifactId&gt;commons-lang&lt;/artifactId&gt;\n            &lt;version&gt;2.6&lt;/version&gt;\n        &lt;/dependency&gt;       \n        &lt;!-- shiro --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.apache.shiro&lt;/groupId&gt;\n            &lt;artifactId&gt;shiro-spring&lt;/artifactId&gt;\n            &lt;version&gt;1.3.2&lt;/version&gt;\n        &lt;/dependency&gt;        \n        &lt;!-- hsqldb --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;\n            &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;\n        &lt;/dependency&gt;    \n    &lt;/dependencies&gt;\n    &lt;properties&gt;\n        &lt;java.version&gt;1.8&lt;/java.version&gt;\n    &lt;/properties&gt;\n    &lt;build&gt;\n        &lt;plugins&gt;\n            &lt;plugin&gt;\n                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;\n            &lt;/plugin&gt;\n        &lt;/plugins&gt;\n    &lt;/build&gt;\n&lt;/project&gt;</code></pre> \n<h2>三、后台分类管理</h2> \n<h3>1、实体类</h3> \n<p>Category.java</p> \n<p>首先新建包，菜单 -&gt; File -&gt; Package -&gt; 然后输入</p> \n<pre><code>com.how2java.tmall.pojo</code></pre> \n<p>然后创建类 Category，接下来.讲解这个类。</p> \n<pre><code>@Entity </code></pre> \n<p>表示这是一个实体类</p> \n<pre><code>@Table(name = \"category\") </code></pre> \n<p>表示对应的表名是 category</p> \n<pre><code>@JsonIgnoreProperties({ \"handler\",\"hibernateLazyInitializer\" })</code></pre> \n<p>因为是做前后端分离，而前后端数据交互用的是 json 格式。 那么 Category 对象就会被转换为 json 数据。 而本项目使用 jpa 来做实体类的持久化，jpa 默认会使用 hibernate, 在 jpa 工作过程中，就会创造代理类来继承 Category ，并添加 handler 和 hibernateLazyInitializer 这两个<code>无须 json 化的属性</code>，所以这里需要用 JsonIgnoreProperties 把这两个属性忽略掉。</p> \n<pre><code>package com.how2java.tmall.pojo;\n \nimport javax.persistence.Column;\nimport javax.persistence.Entity;\nimport javax.persistence.GeneratedValue;\nimport javax.persistence.GenerationType;\nimport javax.persistence.Id;\nimport javax.persistence.Table;\n \nimport com.fasterxml.jackson.annotation.JsonIgnoreProperties;\n \n@Entity\n@Table(name = \"category\")\n@JsonIgnoreProperties({ \"handler\",\"hibernateLazyInitializer\" })\n \npublic class Category {\n    @Id\n    @GeneratedValue(strategy = GenerationType.IDENTITY)\n    @Column(name = \"id\")   \n    int id;\n     \n    String name;\n     \n    public int getId() {\n        return id;\n    }\n    public void setId(int id) {\n        this.id = id;\n    }\n     \n    public String getName() {\n        return name;\n    }\n    public void setName(String name) {\n        this.name = name;\n    }\n}</code></pre> \n<h3>2、创建DAO类</h3> \n<p>CategoryDAO.java</p> \n<p>在 Category.java 步骤里已经讲解过了如何创建包，这里就不讲解如何创建包，而是直接给出类了。<br>CategoryDAO 类集成了 JpaRepository，就提供了CRUD和分页 的各种常见功能。 这就是采用 JPA 方便的地方~</p> \n<pre><code>package com.how2java.tmall.dao;\n  \nimport org.springframework.data.jpa.repository.JpaRepository;\n \nimport com.how2java.tmall.pojo.Category;\n \npublic interface CategoryDAO extends JpaRepository&lt;Category,Integer&gt;{\n \n}</code></pre> \n<h3>3、服务类</h3> \n<p>CategoryService.java</p> \n<pre><code>@Service</code></pre> \n<p>标记这个类是 Service类</p> \n<pre><code>@Autowired CategoryDAO categoryDAO;</code></pre> \n<p>自动装配 上个步骤的 CategoryDAO 对象</p> \n<pre><code>   public List&lt;Category&gt; list() {\n       Sort sort = new Sort(Sort.Direction.DESC, \"id\");\n       return categoryDAO.findAll(sort);\n   }</code></pre> \n<p>首先创建一个 Sort 对象，表示通过 id 倒排序， 然后通过 categoryDAO进行查询。</p> \n<blockquote>\n 注： 这里抛弃了 CategoryService 接口 加上 CategoryService 实现类的这种累赘的写法，而是直接使用 CategoryService 作为实现类来做。\n</blockquote> \n<pre><code>package com.how2java.tmall.service;\n \nimport java.util.List;\n \nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.data.domain.Sort;\nimport org.springframework.stereotype.Service;\n \nimport com.how2java.tmall.dao.CategoryDAO;\nimport com.how2java.tmall.pojo.Category;\n \n@Service\npublic class CategoryService {\n    @Autowired CategoryDAO categoryDAO;\n \n    public List&lt;Category&gt; list() {\n        Sort sort = new Sort(Sort.Direction.DESC, \"id\");\n        return categoryDAO.findAll(sort);\n    }\n}</code></pre> \n<h3>4、页面控制器类</h3> \n<p><code>AdminPageController.java</code><br>后台管理页面跳转专用控制器。<br>因为是做前后端分离，所以数据是通过 RESTFUL接口来取的，而在业务上，除了 RESTFUL 服务要提供，还要提供页面跳转服务，所以所有的后台页面跳转都放在 AdminPageController 这个控制器里。 而RSTFUL 专门放在 Category 对应的控制器 <code>CategoryController.java</code> 里面。 这样代码更清晰，不会搅起搅起的~</p> \n<pre><code>@Controller</code></pre> \n<p>表示这是一个控制器。</p> \n<pre><code>@GetMapping(value=\"/admin\")\npublic String admin(){\n   return \"redirect:admin_category_list\";\n}</code></pre> \n<p>访问地址 admin,就会客户端跳转到 admin_category_list去。</p> \n<pre><code>@GetMapping(value=\"/admin_category_list\")\npublic String listCategory(){\n    return \"admin/listCategory\";\n}</code></pre> \n<p>访问地址 admin_category_list 就会访问 admin/listCategory.html 文件。</p> \n<pre><code>package com.how2java.tmall.web;\n \nimport org.springframework.stereotype.Controller;\nimport org.springframework.web.bind.annotation.GetMapping;\n \n@Controller\npublic class AdminPageController {\n    @GetMapping(value=\"/admin\")\n    public String admin(){\n        return \"redirect:admin_category_list\";\n    }\n    @GetMapping(value=\"/admin_category_list\")\n    public String listCategory(){\n        return \"admin/listCategory\";\n    }\n}</code></pre> \n<h3>5、REST服务控制器</h3> \n<p><code>CategoryController.java</code><br>这个就是专门用来提供 RESTFUL 服务器控制器了</p> \n<pre><code>@RestController</code></pre> \n<p>表示这是一个控制器，并且对每个方法的返回值都会直接转换为 json 数据格式。</p> \n<pre><code>@Autowired CategoryService categoryService;</code></pre> \n<p>自动装配 CategoryService</p> \n<pre><code>    @GetMapping(\"/categories\")\n    public List&lt;Category&gt; list() throws Exception {\n        return categoryService.list();\n    }</code></pre> \n<p>对于categories 访问，会获取所有的 Category对象集合，并返回这个集合。 因为是声明为 @RestController， 所以这个集合，又会被自动转换为 JSON数组抛给浏览器。</p> \n<pre><code>package com.how2java.tmall.web;\n \nimport com.how2java.tmall.pojo.Category;\nimport com.how2java.tmall.service.CategoryService;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n \nimport java.util.List;\n  \n@RestController\npublic class CategoryController {\n    @Autowired CategoryService categoryService;\n     \n    @GetMapping(\"/categories\")\n    public List&lt;Category&gt; list() throws Exception {\n        return categoryService.list();\n    }\n}</code></pre> \n<h3>6、启动类</h3> \n<p>启动类，代替自动生成的 TmallSpringbootApplication.java</p> \n<pre><code>package com.how2java.tmall;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n@SpringBootApplication\npublic class Application {\n    public static void main(String[] args) {\n        SpringApplication.run(Application.class, args);    \n    }\n}</code></pre> \n<h3>7、跨域配置类</h3> \n<p>CORSConfiguration.java<br>配置类，用于允许所有的请求都跨域。<br>因为是二次请求，第一次是获取 html 页面， 第二次通过 html 页面上的 js 代码异步获取数据，一旦部署到服务器就容易面临跨域请求问题，所以允许所有访问都跨域，就不会出现通过 ajax 获取数据获取不到的问题了。</p> \n<pre><code>package com.how2java.tmall.config;\n \nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.CorsRegistry;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;\n \n@Configuration\npublic class CORSConfiguration extends WebMvcConfigurerAdapter{\n    @Override\n    public void addCorsMappings(CorsRegistry registry) {\n        //所有请求都允许跨域\n        registry.addMapping(\"/**\")\n                .allowedOrigins(\"*\")\n                .allowedMethods(\"*\")\n                .allowedHeaders(\"*\");\n    }\n}</code></pre> \n<h3>8、异常处理类</h3> \n<p>GloabalExceptionHandler.java<br>异常处理，主要是在处理删除父类信息的时候，因为外键约束的存在，而导致违反约束。</p> \n<pre><code>package com.how2java.tmall.exception;\n \nimport javax.servlet.http.HttpServletRequest;\n \nimport org.springframework.web.bind.annotation.ControllerAdvice;\nimport org.springframework.web.bind.annotation.ExceptionHandler;\nimport org.springframework.web.bind.annotation.RestController;\n \n@RestController\n@ControllerAdvice\npublic class GloabalExceptionHandler {\n    @ExceptionHandler(value = Exception.class)\n    public String defaultErrorHandler(HttpServletRequest req, Exception e) throws Exception {\n        e.printStackTrace();\n        Class constraintViolationException = Class.forName(\"org.hibernate.exception.ConstraintViolationException\");\n        if(null!=e.getCause()  &amp;&amp; constraintViolationException==e.getCause().getClass()) {\n            return \"违反了约束，多半是外键约束\";\n        }\n        return e.getMessage();\n    }\n \n}</code></pre> \n<h3>9、springboot配置文件</h3> \n<p><code>application.properties </code><br>springboot 配置文件，有些项目会用 application.yml ，站长习惯用 .properties ，觉得更易读。</p> \n<p>下面是配置文件的内容：</p> \n<pre><code>spring.datasource.url=jdbc:mysql://127.0.0.1:3306/tmall_springboot?characterEncoding=UTF-8\nspring.datasource.username=root\nspring.datasource.password=admin\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.hibernate.ddl-auto = none</code></pre> \n<p>分别是数据库访问地址，账号密码，驱动以及表结构自动生成策略(none)。</p> \n<pre><code>spring.thymeleaf.mode=LEGACYHTML5\nspring.thymeleaf.encoding=UTF-8\nspring.thymeleaf.content-type=text/html\nspring.thymeleaf.cache=false</code></pre> \n<p>使用 thymeleaf 作为视图，这个是springboot 官方推荐视图，<code>它的好处是可以是纯 html</code> 。<br>其中LEGACYHTML5表示经典html5模式，即允许非严格的html出现，元素少点什么也可以编译通过， 这个比较符合大家的编写习惯，太过严格的html，写起来累。 <br>cache=false 表示不要缓存，以免在开发过程中因为停留在缓存而给开发人员带来困扰。</p> \n<pre><code>server.context-path=/tmall_springboot</code></pre> \n<p>上下文地址为 tmall_springboot, 所以访问的时候，都要加上这个，比如：</p> \n<pre><code>http://127.0.0.1:8080/tmall_springboot/admin</code></pre> \n<pre><code>spring.http.multipart.maxFileSize=100Mb\nspring.http.multipart.maxRequestSize=100Mb</code></pre> \n<p>设置上传文件大小，默认只有1 m</p> \n<pre><code>spring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl</code></pre> \n<p>jpa对实体类的默认字段会把驼峰命名的属性，转换为字段名的时候自动加上下划线。 这个配置的作用就是去掉下划线<br>比如属性名称是 createDate, jpa 默认转换为字段名 create_Date。 有了这个配置之后，就会转换为同名字段 createDate</p> \n<pre><code>spring.jpa.show-sql=true</code></pre> \n<p>显示 hibernate 执行的sql语句。 这个在上线之后，应该是关掉的，因为大量的 控制台输出会严重影响系统性能。 但是呢，因为本项目会和 redis 和 es 整合，打印 sql 语句的目的是为了观察 缓存是否起效果。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022290852\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"file\" title=\"file\"></span></p> \n<pre><code>#database\nspring.datasource.url=jdbc:mysql://127.0.0.1:3306/tmall_springboot?characterEncoding=UTF-8\nspring.datasource.username=root\nspring.datasource.password=admin\nspring.datasource.driver-class-name=com.mysql.jdbc.Driver\nspring.jpa.hibernate.ddl-auto = none\n \n#thymeleaf\nspring.thymeleaf.mode=LEGACYHTML5\nspring.thymeleaf.encoding=UTF-8\nspring.thymeleaf.content-type=text/html\nspring.thymeleaf.cache=false\n \n#context\nserver.context-path=/tmall_springboot\n \n#设置上传文件大小，默认只有1 m\nspring.http.multipart.maxFileSize=100Mb\nspring.http.multipart.maxRequestSize=100Mb\n \nspring.jpa.hibernate.naming.physical-strategy=org.hibernate.boot.model.naming.PhysicalNamingStrategyStandardImpl\n \n#显示 hibernate运行的 sql 语句\nspring.jpa.show-sql=true</code></pre> \n<h2>四、静态资源</h2> \n<p>接下来是各种静态资源，诸如jquery, bootstrap, css, 图片，公用 html 等，内容稍杂，就不挨个列出来了。</p> \n<ol> \n <li>css,img,js目录是样式，图片脚本等文件</li> \n <li>include/admin目录下是4个HTML 包含关系中讲解到的被包含文件</li> \n</ol> \n<p>静态资源路径：tmall_springboot/src/main/webapp/</p> \n<p>注： 如果目录不存在，比如 webapp目录， templates 目录不存在，请自行创建。<br>注： 静态资源为什么不放在 static 目录下？ 一般说来，在约定里，springboot 的静态资源会在 static 目录下，但是我们是放在 webapp 目录下，为什么会这样呢？ 因为我们还要做上传图片的功能，如果是放在 static 下，上传后的图片就无法被访问，还是放在 webapp 下，上传后，能够立即被访问。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022300723\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"file\" title=\"file\"></span></p> \n<h2>五、前端Vue交互</h2> \n<p>listCategory.html </p> \n<p>接着在 templates 下面新建 admin目录，然后新建 listCategory.html 文件。<br>listCategory.html 看着复杂，其实没那么复杂，它其实就了两件事： 获取数据 和 展示数据</p> \n<h3>1. 获取数据</h3> \n<pre><code>$(function(){\n}</code></pre> \n<p>这个是jquery的代码，表示当整个html加载好了之后执行</p> \n<pre><code>var data4Vue = {\n    uri:\'categories\',\n    beans: []\n};</code></pre> \n<p>vue用到的数据， uri表示访问哪个地址去获取数据，这里的值是 categories，和 CategoryController.java 相呼应</p> \n<pre><code>var vue = new Vue({\n   el: \'#workingArea\',\n   data: data4Vue,</code></pre> \n<p>创建Vue对象，el 表示和本页面的 <code>&lt;div id=\"workingArea\" &gt;</code> 元素绑定，data 表示vue 使用上面的data4Vue对象。</p> \n<pre><code>mounted:function(){\n   this.list();\n},</code></pre> \n<p>加载Vue对象成功之后会调用，成功的时候去调用 list() 函数。</p> \n<pre><code>methods: {\n    list:function(){\n        var url =  this.uri;\n        axios.get(url).then(function(response) {\n            vue.beans = response.data;\n        });\n    }\n}</code></pre> \n<p>list 函数使用 data4Vue里的 uri作为地址，然后调用 axios.js 这个 ajax库，进行异步调用。 调用成功之后，把服务端返回的数据，保存在 vue.beans 上。</p> \n<h3>2. 展示数据</h3> \n<pre><code>&lt;tr v-for=\"bean in beans \"&gt;</code></pre> \n<p>使用 v-for进行遍历， 这个 beans 就表示data4Vue里面的beans属性。</p> \n<pre><code>&lt;td&gt;{{bean.id}}&lt;/td&gt;</code></pre> \n<p>bean就是遍历出来的每个id, 这里就是输出每个分类的id.</p> \n<pre><code>&lt;a :href=\"\'admin_property_list?cid=\' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-th-list\"&gt;&lt;/span&gt;&lt;/a&gt;</code></pre> \n<p>在超链里的href里拼接分类id.</p> \n<p>页面HTML路径：<code>tmall_springboot/src/main/resources/templates/admin/</code></p> \n<p>listCategory.html 页面完整代码：</p> \n<pre><code>&lt;!DOCTYPE html&gt;\n&lt;html xmlns:th=\"http://www.thymeleaf.org\"&gt;\n \n    &lt;head th:include=\"include/admin/adminHeader::html(\'分类管理\')\" &gt;&lt;/head&gt;\n    &lt;body&gt;\n        &lt;div th:replace=\"include/admin/adminNavigator::html\" &gt;&lt;/div&gt;\n        &lt;script&gt;\n            $(function(){\n                var data4Vue = {\n                        uri:\'categories\',\n                        beans: []\n                };\n \n                //ViewModel\n                var vue = new Vue({\n                    el: \'#workingArea\',\n                    data: data4Vue,\n                    mounted:function(){ //mounted　表示这个 Vue 对象加载成功了\n                        this.list();\n                    },\n                    methods: {\n                        list:function(){\n                            var url =  this.uri;\n                            axios.get(url).then(function(response) {\n                                vue.beans = response.data;\n                            });\n                        }\n                    }\n                });\n            });\n \n        &lt;/script&gt;\n        &lt;div id=\"workingArea\" &gt;\n            &lt;h1 class=\"label label-info\" &gt;分类管理&lt;/h1&gt;\n            &lt;br&gt;\n            &lt;br&gt;\n            &lt;div class=\"listDataTableDiv\"&gt;\n                &lt;table class=\"table table-striped table-bordered table-hover  table-condensed\"&gt;\n                    &lt;thead&gt;\n                    &lt;tr class=\"success\"&gt;\n                        &lt;th&gt;ID&lt;/th&gt;\n                        &lt;th&gt;图片&lt;/th&gt;\n                        &lt;th&gt;分类名称&lt;/th&gt;\n                        &lt;th&gt;属性管理&lt;/th&gt;\n                        &lt;th&gt;产品管理&lt;/th&gt;\n                        &lt;th&gt;编辑&lt;/th&gt;\n                        &lt;th&gt;删除&lt;/th&gt;\n                    &lt;/tr&gt;\n                    &lt;/thead&gt;\n                    &lt;tbody&gt;\n                        &lt;tr v-for=\"bean in beans \"&gt;\n                            &lt;td&gt;{{bean.id}}&lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;img height=\"40px\"  :src=\"\'img/category/\'+bean.id+\'.jpg\'\"&gt;\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                {{bean.name}}\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;a :href=\"\'admin_property_list?cid=\' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-th-list\"&gt;&lt;/span&gt;&lt;/a&gt;\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;a :href=\"\'admin_product_list?cid=\' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-shopping-cart\"&gt;&lt;/span&gt;&lt;/a&gt;\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;a :href=\"\'admin_category_edit?id=\' + bean.id \"&gt;&lt;span class=\"glyphicon glyphicon-edit\"&gt;&lt;/span&gt;&lt;/a&gt;\n                            &lt;/td&gt;\n                            &lt;td&gt;\n                                &lt;a href=\"#nowhere\"  @click=\"deleteBean(bean.id)\"&gt;&lt;span class=\"   glyphicon glyphicon-trash\"&gt;&lt;/span&gt;&lt;/a&gt;\n                            &lt;/td&gt;\n                        &lt;/tr&gt;\n                    &lt;/tbody&gt;\n                &lt;/table&gt;\n            &lt;/div&gt;\n        &lt;/div&gt;\n        &lt;div th:replace=\"include/admin/adminFooter::html\" &gt;&lt;/div&gt;\n    &lt;/body&gt;\n&lt;/html&gt;</code></pre> \n<h2>六、思路图</h2> \n<ol> \n <li>首先浏览器上访问路径 /admin</li> \n <li>这个路径被 AdminPageController 的admin方法匹配，然后客户端跳转到 admin_category_list</li> \n <li>admin_category_list 被 AdminPageController 的 listCategory 方法匹配，服务端跳转到 admin/listCategory.html</li> \n <li>listCategory.html 这个html页面通过http协议传输到浏览器端</li> \n <li>浏览器根据html 上的js代码，异步调用 categories 这个地址。 CategoryController 获取捕捉到这个请求，到数据库里查出所有的分类数据，并转换为 json数组返回给浏览器。</li> \n <li>浏览器根据这个json数组，通过 vue 的v-for 方式把其遍历到 多个 tr 元素上，用户就看到了表格里的多条数据了。</li> \n</ol> \n<h2>七、项目源代码</h2> \n<p>本项目源代码托管在GitHub上，地址：<a href=\"https://github.com/corwien/tmall_springboot/\" rel=\"nofollow noreferrer\">https://github.com/corwien/tmall_springboot/</a></p> \n<hr> \n<p>Java学习资源推荐：<br><a href=\"https://how2j.cn?p=126405\" rel=\"nofollow noreferrer\">Java 最强学习站 https://how2j.cn?p=126405</a></p>', 'https://segmentfault.com/img/remote/1460000022290849', '1894b118d35d44cb8fe8009529c4154b', '404982af52c7437280759bb9156099eb,2294832fe5104d73ace4f14ad9549018,1d36446f3db84f4c836556d1513c37f0,ec3409e632664448918190c226301c4b,b350d9c92c524bb4b9feedd40e5eebcd', '0', '3', '1', '2020-04-16 16:58:55', '2020-04-16 16:58:55');
INSERT INTO `tb_recommend` VALUES ('a00b41f610fe48cfbc633efd07210b63', '与国同悲，愿我们用技术改变世界', '与国同悲，SegmentFault 思否技术媒体全线暂停更新一天。 特别专题丨新型肺炎防疫，做好防护，我们整理了一些有价值的内容 如何获取靠谱的新型冠状病毒疫情 肺炎前线的科技公司 广东科技出版社发布《新型冠状病毒...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFzxj\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"稿定设计导出-20200404-113817.png\" title=\"稿定设计导出-20200404-113817.png\"></span></p> \n<p>与国同悲，SegmentFault 思否技术媒体全线暂停更新一天。</p> \n<hr> \n<ol> \n <li><a href=\"https://segmentfault.com/a/1190000021641318\">特别专题丨新型肺炎防疫，做好防护，我们整理了一些有价值的内容</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650218949&amp;idx=1&amp;sn=f2c95723a3eeb065ec1c07cd11999376&amp;chksm=befe21e48989a8f254355ec4c272c11074d4c5fb7eba29b61b982c69b14acdb8594709375ba0&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">如何获取靠谱的新型冠状病毒疫情</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650218952&amp;idx=1&amp;sn=4d1c8982a1832ec294e72453ac84014f&amp;chksm=befe21e98989a8ffd7beaf0a5334a216f39394c8d3c644f27366ec83db9dd372f4c2483c132a&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">肺炎前线的科技公司</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000021648701\">广东科技出版社发布《新型冠状病毒感染防护手册》</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000021649672\">火神山医院面向全国紧急招募 IT 运维志愿者</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000021648500\">湖北科学技术出版社发布《新型冠状病毒肺炎预防手册》</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000021649955\">疫情特殊时期，致 SegmentFault 思否全体员工的一封公开信</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650218975&amp;idx=1&amp;sn=1d387564a96f0072878fe0fe59c867a7&amp;chksm=befe21fe8989a8e867dc6321636cf8a4a113fc6e6ef95add7d7abca908ec76944a3c272f430d&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">疫情面前，中国医院需要什么样的数据中台？</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650218986&amp;idx=1&amp;sn=050944d160685b8344d0ec54c9585095&amp;chksm=befe21cb8989a8dd9ac421aeae52a34b8624d67f13cc93090406bff89e3a9c3800e969522556&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">爬了 8W 条弹幕评论，4000 万人熬夜“监工”，不是无聊是期望……</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650219003&amp;idx=1&amp;sn=a7d7da33d4032f4da1fd34c0af609212&amp;chksm=befe21da8989a8cc088bd7ac925a6f404d6af4250c9407e77631462206cf6b54ef7808d8528d&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">面对突发疫情：信息管理跟“口罩”一样重要</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000021715328\">GitHub 中文趋势榜第一！「2020 新冠肺炎记忆」项目已获4.6K星标！</a></li> \n <li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5NTEwMTAwNg==&amp;mid=2650219119&amp;idx=1&amp;sn=553df09051841077983feb65db3cbfc4&amp;chksm=befe224e8989ab58abb246ed4b8108a72cf3184d9f31a2dae6e2498f0dbc45b7b385786e80b9&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">第一轮返工潮，哪些城市疫情传播压力最大</a></li> \n <li><a href=\"https://aijishu.com/a/1060000000091759?aff=sf\" rel=\"nofollow noreferrer\">AIZOO 开源人脸口罩检测数据+模型+代码+在线网页体验，通通都开源了</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022140058\">世界卫生组织（WHO）发起黑客马拉松，携手 Facebook、微软等科技企业应对冠状病毒挑战</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022012855\">受疫情影响，全球各顶尖技术峰会均改为线上举办</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022044368\">全球最大 COVID-19 研究数据集正式开放，加强科技抗疫</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000022246736\">为应对呼吸机短缺，MIT 开源学生团队开发的低成本呼吸机</a></li> \n</ol>', 'https://segmentfault.com/img/bVbFzxj', '3f69fcc9b13843d1910b3dac597f5215', '57f41641447a40eb9bde76ded2a16296,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 16:47:19', '2020-04-16 16:47:19');
INSERT INTO `tb_recommend` VALUES ('a417cbd9a0a6473bb252b8426ed87840', '一行 Python 代码能实现这么多丧心病狂的功能？', '导读：最近看知乎上有一篇名为《一行 Python 能实现什么丧心病狂的功能？》的帖子，点进去发现一行Python代码可以做这么多丧心病狂的功能！', '<p>导读：最近看知乎上有一篇名为《一行 Python 能实现什么丧心病狂的功能？》的帖子，点进去发现一行Python代码可以做这么多丧心病狂的功能！ </p> \n<p>整理了一下知乎上这篇文章的内容，颇觉有趣，分享给大家。</p> \n<p><strong>一行代码打印乘法口诀</strong></p> \n<pre><code>print(\'\\n\'.join([\'&nbsp;\'.join([\"%2s&nbsp;x%2s&nbsp;=&nbsp;%2s\"%(j,i,i*j)&nbsp;for&nbsp;j&nbsp;in&nbsp;range(1,i+1)])&nbsp;for&nbsp;i&nbsp;in&nbsp;range(1,10)]))</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391341\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>&nbsp;一行代码打印迷宫</strong></p> \n<pre><code>print(\'\'.join(__import__(\'random\').choice(\'\\u2571\\u2572\')&nbsp;for&nbsp;i&nbsp;in&nbsp;range(50*24)))</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391342\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>一行代码表白爱情</strong></p> \n<pre><code>print(\'\\n\'.join([\'\'.join([(\'Love\'[(x-y)&nbsp;%&nbsp;len(\'Love\')]&nbsp;if&nbsp;((x*0.05)**2+(y*0.1)**2-1)**3-(x*0.05)**2*(y*0.1)**3&nbsp;&lt;=&nbsp;0else\'&nbsp;\')&nbsp;for&nbsp;x&nbsp;in&nbsp;range(-30,&nbsp;30)])&nbsp;for&nbsp;y&nbsp;in&nbsp;range(30,&nbsp;-30,&nbsp;-1)]))！</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391344\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>一行代码打印小龟龟</strong></p> \n<pre><code>print(\'\\n\'.join([\'\'.join([\'*\'&nbsp;if&nbsp;abs((lambda&nbsp;a:lambda&nbsp;z,c,n:a(a,z,c,n))(lambda&nbsp;s,z,c,n:z&nbsp;if&nbsp;n==0&nbsp;else&nbsp;s(s,z*z+c,c,n-1))(0,0.02*x+0.05j*y,40))&lt;2&nbsp;else&nbsp;\'&nbsp;\'&nbsp;for&nbsp;x&nbsp;in&nbsp;range(-80,20)])&nbsp;for&nbsp;y&nbsp;in&nbsp;range(-20,20)]))</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391343\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>看完是不是感觉很有趣，一行Python代码可以这么搞？</p> \n<p>欢迎大家关注我的微信公众号【<a href=\"https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzI0MDQ4MTM5NQ==&amp;scene=124#wechat_redirect\" rel=\"nofollow noreferrer\">民工哥技术之路</a>】，最新整理的&nbsp;<strong>2TB</strong>&nbsp;技术干货：包括<strong>架构师实战教程、大数据、Docker容器、系统运维、数据库、redis、MogoDB、电子书、Java基础课程、Java实战项目、ELK Stack、机器学习、BAT面试精讲视频</strong>等。只需在<strong>「&nbsp;</strong><strong>民工哥技术之路」</strong>微信公众号对话框回复关键字：<strong>1024</strong>即可获取全部资料。</p>', 'https://segmentfault.com/img/remote/1460000022391341', 'c56940aa8b004dab84568e86900b2ee6', 'd7416e100af54eb7a4d9274b9a462240,753b5aee3913424e81fe2b5299626d8c,55723db96b9f4593bae02bc1e49f1e87,43145b2d806a4c3e8bb30d20ef04d61b,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 16:48:53', '2020-04-16 16:48:53');
INSERT INTO `tb_recommend` VALUES ('a4ddf4b5176d45d7bf109956b298f7ab', 'GraphQL 落地背后：利弊取舍', '此文是作者考虑 GraphQL 在 Node.js 架构中的落地方案后所得。从最初考虑可以（以内置中间件）加入基础服务并提供完整的构建、发布、监控支持，到最终选择不改动基础服务以提供独立包适配，不限制实现技术选型，...', '<p>此文是作者考虑 GraphQL 在 Node.js 架构中的落地方案后所得。从最初考虑可以（以内置中间件）加入基础服务并提供完整的构建、发布、监控支持，到最终选择不改动基础服务以提供独立包适配，不限制实现技术选型，交由业务团队自由选择的轻量方式落地。中间经历了解除误解，对收益疑惑，对最初定位疑惑，最终完成利弊权衡的过程。</p> \n<p>文章会从解除误解，技术选型，利弊权衡的角度，结合智联招聘的开发现状进行交流分享。</p> \n<p>文章会以 JavaScript 生态和 JavaScript 客户端调用与服务端开发体验为例。</p> \n<p>对入门知识不做详细阐述，可自行查阅学习指南<a href=\"https://wiki.zhaopin.com/pages/%E4%B8%AD%E6%96%87\" rel=\"nofollow noreferrer\">中文</a>(<a href=\"https://graphql.cn/learn/\" rel=\"nofollow noreferrer\">https://graphql.cn/learn/</a>)/<a href=\"https://wiki.zhaopin.com/pages/%E8%8B%B1%E6%96%87\" rel=\"nofollow noreferrer\">英文</a>(<a href=\"https://graphql.org/learn/\" rel=\"nofollow noreferrer\">https://graphql.org/learn/</a>)，规范<a href=\"https://wiki.zhaopin.com/pages/%E4%B8%AD%E6%96%87\" rel=\"nofollow noreferrer\">中文</a>(<a href=\"https://spec.graphql.cn/\" rel=\"nofollow noreferrer\">https://spec.graphql.cn/</a>)/<a href=\"https://wiki.zhaopin.com/pages/%E8%8B%B1%E6%96%87\" rel=\"nofollow noreferrer\">英文</a>(<a href=\"https://github.com/graphql/graphql-spec/tree/master/spec\" rel=\"nofollow noreferrer\">https://github.com/graphql/graphql-spec/tree/master/spec</a>)，中文文档有些滞后，但不影响了解 GraphQL。</p> \n<h2>全貌</h2> \n<p>GraphQL 是一种 API 规范。不是拿来即用的库或框架。不同对 GraphQL 的实现在客户端的用法几乎没有区别，但在服务端的开发方式则天差地别。</p> \n<h2>GraphQL 模型</h2> \n<p>一套运行中的 GraphQL 分为三层：</p> \n<ul> \n <li>左侧是客户端和发出的 Document 和其他参数。</li> \n <li>中间是主要由 Schema 和 Resolver 组成的 GraphQL 引擎服务。</li> \n <li>右侧是 Resolver 对接的数据源。</li> \n</ul> \n<p>仅仅有客户端是无法工作的。</p> \n<h3>初识</h3> \n<p>GraphQL 的实现能让客户端获取以结构化的方式，从服务端结构化定义的数据中只获取想要的部分的能力。</p> \n<p>符合 GraphQL 规范的实现我称之为 GraphQL 引擎。</p> \n<p>这里的服务端不仅指网络服务，用 GraphQL 作为中间层数据引擎提供本地数据的获取也是可行的，GraphQL 规范并没有对数据源和获取方式加以限制。</p> \n<ul>\n <li>操作模型：GraphQL 规范中对数据的操作做了定义，有三种，query（查询）、mutation（变更）、subscription（订阅）。</li>\n</ul> \n<h3>客户端</h3> \n<p>我们把客户端调用时发送的数据称为 <code>Query Document</code>（查询文档），是段结构化的字符串，形如：</p> \n<pre><code class=\"graphql\"># 客户端发送\nquery {\n  contractedAuthor: {\n    name\n    articles {\n      time\n      title\n    }\n  }\n  updateTime\n}\n# 或\nmutation {\n  # xxxxxx\n}\n</code></pre> \n<p>需要注意的是 <code>Query Document</code> 名称中的 Query 和操作模型中的 query 是没有关系的，像上述示例所示，<code>Query Document</code> 也可以包含 mutation 操作。所以为了避免误解，后文将把 <code>Query Document</code>（查询文档）称为 Document 或文档。一个 Document 中可包含单个或多个操作，每个操作都可以查询补丁数量的跟字段。</p> \n<p>其中 query 下的 updateTime、contractedAuthor 这种操作下的第一层字段又称之为 <code>root field</code>（根字段）。其他具体规范请自行查阅文档。</p> \n<h3>Schema</h3> \n<p>服务端使用名为 <code>GraphQL Schema Language</code>（或 <code>Schema Definition Language</code>、<code>SDL</code> ）的语言定义 Schema 来描述服务端数据。</p> \n<pre><code class=\"graphql\"># 服务端 schema\ntype Query {\n  contractedAuthor: Author\n  unContractedAuthor: Author\n  updateTime: String\n}\n\ntype Mutation{\n  # xxx\n}\n\ntype Subscription {\n  # xxx\n}\n\ntype Author {\n  name: String\n  articles: [Article]\n}\n\ntype Article {\n  time: String\n  title: String\n  content: String\n}\n\nschema {\n  query: Query\n  mutation: Mutation\n  subscription: Subscription\n}\n</code></pre> \n<p>可以看到，由于 GraphQL 是语言无关的，所以 SDL 带有自己简单的类型系统。具体与 JavaScript、Go 其他语言的类型如何结合，要看各语言的实现。</p> \n<p>从上面的 Schema 中我们可以得到如下的一个数据结构，这就是服务可提供的完整的数据的 <code>Graph</code>（图）：</p> \n<pre><code class=\"graphql\">{\n  query: {\n    contractedAuthor: {\n      name: String\n      articles: [{\n        time: String\n        title: String\n        content: String\n      }]\n    }\n    unContractedAuthor: {\n      name: String\n      articles: [{\n        time: String\n        title: String\n        content: String\n      }]\n    }\n    updateTime: String\n  }\n  mutation: {\n    # xxx\n  }\n  subscription: {\n    # xxx\n  }\n}\n</code></pre> \n<p>在 Schema 定义中存在三种特殊的类型 Query、Mutation、Subscription，也称之为 <code>root types</code>（根类型），与 Document 中的操作模型一一对应的。</p> \n<p>结合 Document 和 Schema，可以直观的感受到 Document 和 Schema 结构的一致，且 Document 是 Schema 结构的一部分，那么数据就会按照 Document 的这部分返回，会得到如下的数据：</p> \n<pre><code class=\"js\">{\n  errors: [],\n  data: {\n    contractedAuthor: {\n      name: \'zpfe\',\n      articles: [\n        {\n          time: \'2020-04-10\',\n          title: \'深入理解GraphQL\'\n        },\n        {\n          time: \'2020-04-11\',\n          title: \'GraphQL深入理解\'\n        }\n      ]\n    },\n    updateTime: \'2020-04-11\'\n  }\n}\n</code></pre> \n<p>预期数据会返回在 data 中，当有错误时，会出现 errors 字段并按照规范规定的格式展示错误。</p> \n<h3>跑起来的 Schema</h3> \n<p>现在 Document 和 Schema 结构对应上了，那么数据如何来呢？</p> \n<ul> \n <li> <p><code>Selection Sets</code> 选择集：</p> <pre><code class=\"graphql\">query {\n  contractedAuthor: {\n    name\n    articles {\n      time\n      title\n    }\n    honour {\n      time\n      name\n    }\n  }\n  updateTime\n}\n</code></pre> <p>如上的查询中存在以下选择集：</p> <pre><code class=\"graphql\"># 顶层\n{\n  contractedAuthor\n  updateTime\n}\n# 二层\n{\n  name\n  articles\n  honour\n}\n# articles：三层 1\n{\n  time\n  title\n}\n# honour：三层 2\n{\n  time\n  name\n}\n</code></pre> </li> \n <li> <code>Field</code> 字段：类型中的每个属性都是一个字段。</li> \n</ul> \n<p>省略一些如校验、合并的细节，数据获取的过程如下：</p> \n<ul> \n <li>执行请求：GraphQL 引擎拿到 Document 并解析并处理之后，得到一个新的结构化的 Document（当然原本的 Document 也是结构化的，只不过是个字符串）。</li> \n <li>执行操作：引擎会首先分析客户端的目标操作，如是 query 时，则会去 Schema 中找到 Query 类型部分执行，由前文所说 Query、Mutation、Subscription 是特殊的操作类型，所以如 query、mutation、subscription 字段是不会出现在返回结果中的，返回结果中的第一层字段是前文提到的 <code>root field</code>（根字段）。</li> \n <li>执行选择集：此时已经明确的知道客户端希望获取的 <code>Selection Sets</code>（选择集）。query 操作下，引擎一般会以广度优先、同层选择集并行执行获取选择集数据，规范没有明确规定。mutation 下，因为涉及到数据修改，规范规定要按照由上到下按顺序、深度优先的方式获取选择集数据。</li> \n <li> <p>执行字段：</p> \n  <ul> \n   <li> <p>确定了选择集的执行顺序后开始真正的字段值的获取，非常简化的讲，Schema 中的类型应该对其每个字段提供一个叫做 Resolver 的解析函数用于获取字段的值。那么可执行的 Schema 就形如：</p> <pre><code class=\"graphql\">type Query {\n  contractedAuthor () =&gt; Author\n}\ntype Author {\n  name () =&gt; String\n  articles () =&gt; [Article]\n}\ntype Article {\n  time () =&gt; String\n  title () =&gt; String\n  content () =&gt; String\n}\n</code></pre> <p>其中每个类型方法都是一个 Resolver。</p> </li> \n   <li>在执行字段 Resolver 之后会得字段的值，如果值的类型为对象，则会继续执行其下层字段的 Resolver，如 <code>contractedAuthor()</code> 后得到值类型为 Author，会继续执行 <code>name ()</code> 和 <code>articles()</code> 以获取 name 和 articles 的值，直到得到类型为标量（String、Int等）的值。</li> \n   <li>同时虽然规范中没有规定 Resolver 缺少的情况，但引擎实现时，一般会实现一个向父层字段（即字段所在对象）取与自己同名的属性的值的 Resolver。如未提供 Artical 对象 time 字段的 Resolver，则会直接取 artical.time。</li> \n  </ul> </li> \n</ul> \n<p>至此由 Schema 和 Resolver 组合而成的<code>可执行 Schema</code> 就诞生了，Schema 跑了起来，GraphQl 引擎也就跑了起来。</p> \n<p>GrahpQL 服务端开发的<strong>核心就是定义 Schema （结构）和实现相应的 Resolver（行为）</strong>。</p> \n<h3>其他定义</h3> \n<p>当然，在使用 GraphQL 的过程中，还可以：</p> \n<ul> \n <li>使用 <code>Variables</code>（变量）复用同一段 Document 来动态传参。</li> \n <li>使用 <code>Fragments</code>（片段）降低 Document 的复杂度。</li> \n <li>使用 <code>Field Alias</code>（字段别名）进行简单的返回结果字段重命名。</li> \n</ul> \n<p>这些都没有什么问题。</p> \n<p>但是在 <strong><code>Directives</code></strong>（指令）的支持和使用上，规范和实现是有冲突的。</p> \n<ol> \n <li>规范内置指令：规范中只规定了 GraphQL 引擎需要实现 Document 中可用的 @skip（条件跳过）、@include（条件包含），在服务端 Schema 部分可用的 @deprecated（字段已废弃）指令。</li> \n <li>自定义指令支持：在我查到的资料中，Facebook 与 graphql-js（Facebook提供实现）官方有不支持自定义指令的表态<a href=\"https://wiki.zhaopin.com/pages/1\" rel=\"nofollow noreferrer\">1</a>(<a href=\"https://github.com/graphql/graphql-js/issues/446\" rel=\"nofollow noreferrer\">https://github.com/graphql/graphql-js/issues/446</a>)<a href=\"https://wiki.zhaopin.com/pages/2\" rel=\"nofollow noreferrer\">2</a>(<a href=\"https://github.com/graphql-rust/juniper/issues/156\" rel=\"nofollow noreferrer\">https://github.com/graphql-rust/juniper/issues/156</a>)<a href=\"https://wiki.zhaopin.com/pages/3\" rel=\"nofollow noreferrer\">3</a>(<a href=\"https://github.com/graphql/graphql-js/issues/41\" rel=\"nofollow noreferrer\">https://github.com/graphql/graphql-js/issues/41</a>)。在 Apollo 实现的 Graphql 生态中则是支持自定义 Schema 端可用的指令，对 Document 端的自定义指令实现<a href=\"https://www.apollographql.com/docs/apollo-server/schema/creating-directives/#what-about-query-directives\" rel=\"nofollow noreferrer\">暂不支持且不建议支持</a>。</li> \n</ol> \n<p>而在研究 GraphQL 时发生的的误解在于：</p> \n<ul> \n <li>规范、教程提到 query（查询）时，无法确认是指客户端侧客户端发出的 <code>Query Document</code> 整个操作还是，Document 中的 query 操作，亦或是服务端侧定义在 Schema 中的 Query 类型。</li> \n <li>或如讲到 Arguments、Variables 等概念，其原则、写法是位于三层的那部分。</li> \n</ul> \n<h2>实现与选型</h2> \n<p>GraphQL 的典型实现主要有以下几种：</p> \n<ul> \n <li> <a href=\"https://github.com/graphql/graphql-js\" rel=\"nofollow noreferrer\">graphql-js</a>：由 Facebook 官方提供的实现。几乎是</li> \n <li> <a href=\"https://github.com/apollographql\" rel=\"nofollow noreferrer\">Apollo GraphQL</a>: Apollo 提供的实现和 GraphQL 生态，内容丰富，不止一套引擎，还提供了纯客户端使用（不局限JavaScript）多种工具。</li> \n <li> <a href=\"https://github.com/MichalLytek/type-graphql\" rel=\"nofollow noreferrer\">type-graphql</a>：强依赖 TypeScript 开发的实现，主要是输出可执行 Schema。</li> \n</ul> \n<p><strong>graphql-js 可以说是其他实现的基础。</strong></p> \n<p>可执行 Schema 的创建方式是这几种实现最大的不同，下面将就这部分进行展示。</p> \n<h3>graphql-js</h3> \n<pre><code class=\"bash\">npm install --save graphql\n</code></pre> \n<ul> \n <li> <p>创建可执行 Schema</p> <pre><code class=\"js\">import {\n  graphql,\n  GraphQLList,\n  GraphQLSchema,\n  GraphQLObjectType,\n  GraphQLString,\n} from \'graphql\'\n\nconst article = new GraphQLObjectType({\n  fields: {\n    time: {\n      type: GraphQLString,\n      description: \'写作时间\',\n      resolve (parentValue) {\n        return parent.date\n      }\n    },\n    title: {\n      type: GraphQLString,\n      description: \'文章标题\',\n    }\n  }\n})\n\nconst author = new GraphQLObjectType({\n  fields: {\n    name: {\n      type: GraphQLString,\n      description: \'作者姓名\',\n    },\n    articles: {\n      type: GraphQLList(article),\n      description: \'文章列表\',\n      resolve(parentValue, args, ctx, info) {\n        // return ajax.get(\'xxxx\', { query: args })\n      },\n    }\n  },\n})\n\nconst schema = new GraphQLSchema({\n  query: new GraphQLObjectType({\n    name: \'RootQuery\',\n    fields: {\n      contractedAuthor: {\n        type: author,\n        description: \'签约作者\',\n        resolve(parentValue, args, ctx, info) {\n          // return ajax.get(\'xxxx\', { query: args })\n        },\n      },\n    },\n  }),\n})\n</code></pre> <p>能明确的看到，graphql-js 实现通过 GraphQLSchema 创建出的 schema 中，field 和 resolver 和他们一一对应的关系，同时此 schema 就是可执行 Schema。</p> </li> \n <li> <p>执行</p> <pre><code class=\"js\">import { parse, execute, graphql } from \'graphql\'\nimport { schema } from \'上面的schema\'\n\n// 实际请求中，document 由 request.body 获取\nconst document = `\nquery {\n  contractedAuthor {\n    name\n    articles {\n      title\n    }\n  }\n}`\n// 或使用导入的 graphql 方法执行\nconst response = await execute({\n  schema,\n  document: parse(document),\n  // 其他变量参数等\n})\n</code></pre> <p>传入可执行 schema 和解析后的 Document 即可得到预期数据。</p> </li> \n</ul> \n<h3>Apollo</h3> \n<p>Apollo 提供了完整的 GraphQL Node.js 服务框架，但是为了更直观的感受可执行 Schema 的创建过程，使用 Apollo 提供的 <code>graphql-tools</code> 进行可执行 Schema 创建。</p> \n<pre><code class=\"bash\">npm install graphql-tools graphql\n</code></pre> \n<p>上面是 Apollo 给出的依赖安装命令，可以看到 graphql-tools 需要 graphql-js（graphql）作为依赖 。</p> \n<ul>\n <li> <p>创建可执行 Schema</p> <pre><code class=\"js\">import { makeExecutableSchema } from \'graphql-tools\'\n\nconst typeDefs = `\ntype Article {\n  time: String\n  title: String\n}\n\ntype Author {\n  name: String\n  articles: [Article]\n}\n\ntype Query {\n  contractedAuthor: Author\n}\n\nschema {\n  query: Query\n}\n`\nconst resolvers = {\n  Query: {\n    contractedAuthor (parentValue, args, ctx, info) {\n      // return ajax.get(\'xxxx\', { query: args })\n    }\n  },\n  Author: {\n    articles (parentValue, args, ctx, info) {\n      // return ajax.get(\'xxxx\', { query: args })\n    }\n  },\n  Article: {\n    time (article) {\n      return article.date\n    }\n  }\n}\nconst executableSchema = makeExecutableSchema({\n  typeDefs,\n  resolvers,\n})\n</code></pre> <p>resolvers 部分以类型为维度，以对象方法的形式提供了 Resolver。在生成可执行 Schema 时，会将 Schema 和 Resolver 通过类型映射起来，有一定的理解成本。</p> </li>\n</ul> \n<h3>type-graphql</h3> \n<p>这部分涉及 TypeScript，只做不完整的简要展示，详情自行查阅文档。</p> \n<pre><code class=\"bash\">npm i graphql @types/graphql type-graphql reflect-metadata\n</code></pre> \n<p>可以看到 type-graphql 同样需要 graphql-js（graphql）作为依赖 。</p> \n<ul>\n <li> <p>创建可执行 Schema</p> <pre><code class=\"ts\">import \'reflect-metadata\'\nimport { buildSchemaSync } from \'type-graphql\'\n\n@ObjectType({ description: \"Object representing cooking recipe\" })\nclass Recipe {\n  @Field()\n  title: string\n}\n\n@Resolver(of =&gt; Recipe)\nclass RecipeResolver {\n\n  @Query(returns =&gt; Recipe, { nullable: true })\n  async recipe(@Arg(\"title\") title: string): Promise&lt;Recipe&gt; {\n    // return await this.items.find(recipe =&gt; recipe.title === title);\n  }\n\n  @Query(returns =&gt; [Recipe], { description: \"Get all the recipes from around the world \" })\n  async recipes(): Promise&lt;Recipe[]&gt; {\n    // return await this.items;\n  }\n\n  @FieldResolver()\n  title(): string {\n    return \'标题\'\n  }\n}\nconst schema = buildSchemaSync({\n  resolvers: [RecipeResolver]\n})\n</code></pre> <p>type-graphql 的核心是类，使用装饰器注解的方式复用类生成 Schema 结构，并由 <code>reflect-metadata</code> 将注解信息提取出来。如由 <code>@ObjectType()</code> 和 <code>@Field</code> 将类 Recipe 映射为含有 title 字段的 schema Recipe 类型。由 @Query 注解将 <code>recipe</code>、<code>recipes</code> 方法映射为 schema query 下的根字段。由 <code>@Resolver(of =&gt; Recipe)</code> 和 <code>@FieldResolver()</code> 将 <code>title()</code> 方法映射为类型 <code>Recipe</code> 的 title 字段的 Resolver。</p> </li>\n</ul> \n<h3>关联与差异</h3> \n<p>同：在介绍 Apollo 和 type-graphql 时，跳过了执行部分的展示，是因为这两种实现生成的可执行 Schema 和 graphql-js 的是通用的，查看这两者最终生成的可执行 Schema 可以发现其类型定义都是使用的由 graphql-js 提供的 <code>GraphQLObjectType</code> 等， 可以选择使用 graphql-js 提供的执行函数（graphql、execute 函数），或 apollo-server 提供的服务执行。</p> \n<p>异：</p> \n<ul> \n <li>结构：直接可见的是结构上的差异，graphql-js 作为官方实现提供了结构（Schema）和行为（Resolver）不分离的创建方式，没有直接使用 SDL 定义 Schema，好处是理解成本低，上手快；apollo 实现则使用结构和行为分离的方式定义，且使用了 SDL，结构和行为使用类名形成对应关系，有一定的理解成本，好处是 Schema 结构更直观，且使用 SDL 定义 Schema 更快。</li> \n <li> <p>功能：</p> \n  <ul> \n   <li>graphql-js：graphql-js 是绕不过的基础。提供了生成可执行 Schema 的函数和执行 Schema 生成返回值的函数（graphql、execute 函数），使用执行方法可快速将现有 API 接口快速改造为 GraphQL 接口。适合高度定制 GraphQL 服务或快速改造。</li> \n   <li>apollo：提供了开箱即用的完整的 Node.js 服务；提供了拼接 Schema（本地、远端）的方法，使 GraphQL 服务拆分成为可能；提供了客户端可用的数据获取管理工具。当遇到问题在 apollo 生态中找一找一般都会有收获。</li> \n   <li>type-grahpql：当使用 TypeScript 开发 GraphQL 时，一般要基于 TypeScript 对数据定义模型，也要在 Schema 中定义数据模型，此时 type-graphql 的类型复用的方式就比较适合。同时 type-grahpql 只纯粹的负责生成可执行 Schema，与其他服务实现不冲突，但是这个实现的稳定性还有待观察。</li> \n  </ul> </li> \n</ul> \n<h2>利弊</h2> \n<p>对 GraphQL 的直观印象就是按需、无冗余，这是显而易见的好处，那么在实际应用中真的这么直观美好么？</p> \n<ul> \n <li>声明式的获取数据：结构化的 Document 使得得到数据后，对数据的操作提供了一定便利（如果能打通服务端和客户端的类型公用，使得客户端在开发时提供代码智能提示更好）。</li> \n <li>调用合并：经常提到的与 RESTful 相比较优的一点是，当需要获取多个关联数据时，RESTful 接口往往需要多次调用（并发或串行），而基于 GraphQL 的接口调用则可以将调用顺序体现在结构化的查询中，一次获取全部数据，减少了接口往返顺序。但同时也有一些注意事项，要真正减少调用次数，要在前端应用中集中定义好应用全局的数据结构，统一获取，如果仍然让业务组件就近获取（只让业务组件这种真正的使用方知晓数据结构），这个优势并不存在。</li> \n <li>无冗余：按需返回数据，在网络性能上确实有一定优化。</li> \n <li>文档化：GraphQL 的内省功能可以根据 Schema 生成实时更新的 API 文档，且没有维护成本，对于调用方直观且准确。</li> \n <li>数据 Mock：服务端 Schema 中包含数据结构和类型，所以在此基础上实现一个 Mock 服务并不困难，apollo-server 就有实现，可以加快前端开发介入。</li> \n <li>强类型（字段校验）：由于 JS 语言特性，强类型只能称为字段强类型校验（包括入参类型和返回结果），当数据源返回了比 Schema 多或少的字段时，并不会引发错误，而就算采用了 TypeScript 由于没有运行时校验，也会有同样的问题。但是字段类型校验也会有一定的帮助。</li> \n <li>调试：由于我们调用 GraphQL 接口时（如：<code>xxx/graphql/im</code>）无法像 RESTful 接口那样（如：<code>xxx/graphql/im/message</code>、<code>xxx/graphql/im/user</code>）从 URL 直接分辨出业务类型，会给故障排查带来一些不便。</li> \n</ul> \n<p>上面提到的点几乎都是出于调用方的视角，可以看到，<strong>作为 GraphQL 服务的调用方是比较舒服</strong>的。</p> \n<p>由于智联招聘前端架构Ada中包含基于 Node.js 的 BFF（Backends For Frontends 面向前端的后端）层，前端开发者有能力针对具体功能点开发一对一的接口，有且已经进行了数据聚合、处理、缓存工作，也在 BFF 层进行过数据模型定义的尝试，同时已经有团队在现有 BFF 中接入了 GraphQL 能力并稳定运行了一段时间。所以也会从 GraphQL 的开发者和两者间的角度谈谈成本和收益。</p> \n<ul> \n <li>BFF：GraphQL 可以完成数据聚合、字段转换这种符合 BFF 特征的功能，提供了一种 BFF 的实现选择。</li> \n <li>版本控制：客户端结构化的查询方式可以让服务追踪到字段的使用情况。且在增加字段时，根据结构化查询按需查询的特点，不会影响旧的调用（虽然 JavaScript 对多了个字段的事情不在意）。对于服务的迭代维护有一定便利。</li> \n <li>开发成本：毫无疑问 Resolver（业务行为）的开发在哪种服务模式下都不可缺少，而 Schema 的定义一定是额外的开发成本，且主观感受是 Schema 的开发过程还是比较耗费精力的，数据结构复杂的情况下更为如此。同时考虑到开发人员的能力差异，GraphQL 的使用也会是团队长期的人员成本。像我们在 BFF 层已经有了完全针对功能点一对一的接口的情况下，接口一旦开发完成，后续迭代要么彻底重写、要么不再改动，这种情况下是用不到 GraphQL 的版本控制优势，将每个接口都实现为 GraphQL 接口，收益不高。</li> \n <li>迁移改造：提供 GraphQL 接口有多种方式，可以完全重写也可以定义 Schema 后在 Resolver 中调用现有接口，仅仅把 GraphQL 当作网关层。</li> \n <li>调用合并：GraphQL 的理念就是将多个查询合并，对应服务端，通常只会提供一个合并后的“大”的接口，那么原本以 URL 为粒度的性能监控、请求追踪就会有问题，可能需要改为以 <code>root field</code>（根字段）为粒度。这也是需要额外考虑的。</li> \n <li>文档化：在智联招聘所推行的开发模式中，通常 BFF 接口和前端业务是同一个人进行开发，对接口数据格式是熟知的，且接口调用方唯一、无复用，GraphQL 的文档化这一特性带来的收益也有限。</li> \n <li>规范：由于 GraphQL Schema 的存在，使得数据模型的定义成为了必要项。在使用 JavaScript 开发接口服务时，相对其他各种数据模型定义的尝试，提供了定义数据模型的统一实践和强规范，也算是收益之一。同时 Resolver 的存在强化了只在前端做 UI、交互而在 BFF 层处理逻辑的概念。</li> \n</ul> \n<h2>总结</h2> \n<p>综合来看，可用的 GraphQL 服务（不考虑拿 GraphQL 做本地数据管理的情况）的重心在服务提供方。作为 GraphQL 的调用方是很爽的，且几乎没有弊端。那么要不要上马 GraphQL 就要重点衡量服务端的成本收益了。就我的体会而言，有以下几种情况：</p> \n<ol> \n <li>服务本身提供的就是针对具体功能的接口，接口只有单一的调用方，不存在想要获取的数据结构不固定的情况，或者说是一次性接口，发布完成后不用再迭代的，那么没必要使用 GraphQL。</li> \n <li>服务本身是基础服务，供多方调用，需求不一但对外有统一的输出模型的情况下（如：Github 开放接口，无法确定每个调用者需求是什么），可以使用 GraphQL。</li> \n <li>在 Node.js（JavaScript）中，由于面向对象、类型的支持程度问题，开发者编程思维问题，实现成本比 Java 等其他语言更高，要谨慎考虑成本。</li> \n <li>没有 BFF 层时，由于 GraphQL 对于实现数据聚合、字段转换提供了范式，可以考虑使用 GraphQL 服务作为 BFF 层，或者结合1、2点，将部分接口实现为 GraphQL，作为 BFF 层的一部分，其他接口还可以采取 RESTful 风格或其他风格，并不冲突。</li> \n <li>当前端开发本身就要基于 Node.js 进行 BFF 层开发，团队对规范、文档有更高优先级的需求时，可以考虑使用 GraphQL 进行开发。</li> \n</ol>', null, '3f69fcc9b13843d1910b3dac597f5215', 'cefcbb7ca2c24b738ea0386eb45886de,1062207552f54e86b0a1ad8dd7c0a888', '0', '3', '1', '2020-04-16 16:47:08', '2020-04-16 16:47:08');
INSERT INTO `tb_recommend` VALUES ('a4de9075ca474538b09e81b84a8c1275', 'Spring 面试 7 大问题，你顶得住不？', '下面总结了 Spring 面试 7 大问题，看你能顶得住不？ 1、一般问题 1.1. 不同版本的 Spring Framework 有哪些主要功能？ 1.2. 什么是 Spring Framework？ Spring 是一个开源应用框架，旨在降低应用程序开发的复杂...', '<p>下面总结了 Spring 面试 7 大问题，看你能顶得住不？</p> \n<h4>1、一般问题</h4> \n<p>1.1. 不同版本的 Spring Framework 有哪些主要功能？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF7ig\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>1.2. 什么是 Spring Framework？</p> \n<p>Spring 是一个开源应用框架，旨在降低应用程序开发的复杂度。</p> \n<p>它是轻量级、松散耦合的。</p> \n<p>它具有分层体系结构，允许用户选择组件，同时还为 J2EE 应用程序开发提供了一个有凝聚力的框架。</p> \n<p>它可以集成其他框架，如 Structs、Hibernate、EJB 等，所以又称为框架的框架。</p> \n<p>1.3. 列举 Spring Framework 的优点。</p> \n<p>由于 Spring Frameworks 的分层架构，用户可以自由选择自己需要的组件。</p> \n<p>Spring Framework 支持 POJO(Plain Old Java Object) 编程，从而具备持续集成和可测试性。</p> \n<p>由于依赖注入和控制反转，JDBC 得以简化。</p> \n<p>它是开源免费的。</p> \n<p>1.4. Spring Framework 有哪些不同的功能？</p> \n<p>轻量级 - Spring 在代码量和透明度方面都很轻便。</p> \n<p>IOC - 控制反转</p> \n<p>AOP - 面向切面编程可以将应用业务逻辑和系统服务分离，以实现高内聚。</p> \n<p>容器 - Spring 负责创建和管理对象（Bean）的生命周期和配置。</p> \n<p>MVC - 对 web 应用提供了高度可配置性，其他框架的集成也十分方便。</p> \n<p>事务管理 - 提供了用于事务管理的通用抽象层。Spring 的事务支持也可用于容器较少的环境。</p> \n<p>JDBC 异常 - Spring 的 JDBC 抽象层提供了一个异常层次结构，简化了错误处理策略。</p> \n<p>1.5. Spring Framework 中有多少个模块，它们分别是什么？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF7ih\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>Spring 核心容器 – 该层基本上是 Spring Framework 的核心。</strong><strong>它包含以下模块：</strong></p> \n<ul> \n <li>Spring Core</li> \n <li>Spring Bean</li> \n <li>SpEL (Spring Expression Language)</li> \n <li>Spring Context</li> \n</ul> \n<p><strong>数据访问/集成 – 该层提供与数据库交互的支持。</strong><strong>它包含以下模块：</strong></p> \n<ul> \n <li>JDBC (Java DataBase Connectivity)</li> \n <li>ORM (Object Relational Mapping)</li> \n <li>OXM (Object XML Mappers)</li> \n <li>JMS (Java Messaging Service)</li> \n <li>Transaction</li> \n</ul> \n<p><strong>Web – 该层提供了创建 Web 应用程序的支持。</strong><strong>它包含以下模块：</strong></p> \n<ul> \n <li>Web</li> \n <li>Web – Servlet</li> \n <li>Web – Socket</li> \n <li>Web – Portlet</li> \n</ul> \n<p><strong>AOP</strong>&nbsp;– 该层支持面向切面编程</p> \n<p><strong>Instrumentation</strong>&nbsp;– 该层为类检测和类加载器实现提供支持。</p> \n<p><strong>Test&nbsp;</strong>– 该层为使用 JUnit 和 TestNG 进行测试提供支持。</p> \n<p>几个杂项模块:</p> \n<ul> \n <li>Messaging – 该模块为 STOMP 提供支持。它还支持注解编程模型，该模型用于从 WebSocket 客户端路由和处理 STOMP 消息</li> \n <li>Aspects – 该模块为与 AspectJ 的集成提供支持。</li> \n</ul> \n<p>1.6. 什么是 Spring 配置文件？</p> \n<p>Spring 配置文件是 XML 文件。该文件主要包含类信息。它描述了这些类是如何配置以及相互引入的。但是，XML 配置文件冗长且更加干净。如果没有正确规划和编写，那么在大项目中管理变得非常困难。</p> \n<p>1.7. Spring 应用程序有哪些不同组件？</p> \n<p>Spring 应用一般有以下组件：</p> \n<p><strong>接口</strong>&nbsp;- 定义功能。</p> \n<p><strong>Bean 类&nbsp;</strong>- 它包含属性，setter 和 getter 方法，函数等。</p> \n<p><strong>Spring 面向切面编程（AOP）</strong>&nbsp;- 提供面向切面编程的功能。</p> \n<p><strong>Bean 配置文件&nbsp;</strong>- 包含类的信息以及如何配置它们。</p> \n<p><strong>用户程序</strong>&nbsp;- 它使用接口。</p> \n<p>1.8. 使用 Spring 有哪些方式？</p> \n<p>使用 Spring 有以下方式：</p> \n<ul> \n <li>作为一个成熟的 Spring Web 应用程序。</li> \n <li>作为第三方 Web 框架，使用 Spring Frameworks 中间层。</li> \n <li>用于远程使用。</li> \n <li>作为企业级 Java Bean，它可以包装现有的 POJO（Plain Old Java Objects）。</li> \n</ul> \n<h4>2、依赖注入（Ioc）</h4> \n<p>2.1. 什么是 Spring IOC 容器？</p> \n<p>Spring 框架的核心是 Spring 容器。容器创建对象，将它们装配在一起，配置它们并管理它们的完整生命周期。Spring 容器使用依赖注入来管理组成应用程序的组件。</p> \n<p>容器通过读取提供的配置元数据来接收对象进行实例化，配置和组装的指令。该元数据可以通过 XML，Java 注解或 Java 代码提供。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF7ii\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>2.2. 什么是依赖注入？</p> \n<p>在依赖注入中，您不必创建对象，但必须描述如何创建它们。您不是直接在代码中将组件和服务连接在一起，而是描述配置文件中哪些组件需要哪些服务。由 IoC 容器将它们装配在一起。</p> \n<p>2.3. 可以通过多少种方式完成依赖注入？</p> \n<p>通常，依赖注入可以通过三种方式完成，即：</p> \n<ul> \n <li>*构造函数注入</li> \n <li>*setter 注入</li> \n <li>*接口注入</li> \n</ul> \n<p>在 Spring Framework 中，仅使用构造函数和 setter 注入。</p> \n<p>2.4. 区分构造函数注入和 setter 注入。</p> \n<p>构造函数注入</p> \n<p>setter 注入</p> \n<p>没有部分注入</p> \n<p>有部分注入</p> \n<p>不会覆盖 setter 属性</p> \n<p>会覆盖 setter 属性</p> \n<p>任意修改都会创建一个新实例</p> \n<p>任意修改不会创建一个新实例</p> \n<p>适用于设置很多属性</p> \n<p>适用于设置少量属性</p> \n<p>2.5. spring 中有多少种 IOC 容器？</p> \n<ul> \n <li>* BeanFactory - BeanFactory 就像一个包含 bean 集合的工厂类。它会在客户端要求时实例化 bean。</li> \n <li>* ApplicationContext - ApplicationContext 接口扩展了 BeanFactory 接口。它在 BeanFactory 基础上提供了一些额外的功能。</li> \n</ul> \n<p>2.6. 区分 BeanFactory 和 ApplicationContext。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF7ij\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>2.7. 列举 IoC 的一些好处。</p> \n<p>IoC 的一些好处是：</p> \n<ul> \n <li>它将最小化应用程序中的代码量。</li> \n <li>它将使您的应用程序易于测试，因为它不需要单元测试用例中的任何单例或 JNDI 查找机制。</li> \n <li>它以最小的影响和最少的侵入机制促进松耦合。</li> \n <li>它支持即时的实例化和延迟加载服务。</li> \n</ul> \n<p>2.8. Spring IoC 的实现机制。</p> \n<p>Spring 中的 IoC 的实现原理就是工厂模式加反射机制。<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247491561&amp;idx=2&amp;sn=446e9a25108a71bbb8a0c24a955f3ada&amp;chksm=eb539adfdc2413c9e80a4e0811b83b8978f0d2fc367e0ba60c70e36cce2a5c502c4d98623d95&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Spring的核心思想，总结得非常好</a>，推荐大家看下。</p> \n<p>示例：</p> \n<pre><code>interface&nbsp;Fruit&nbsp;{  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;abstract&nbsp;void&nbsp;eat();  \n}  \nclass&nbsp;Apple&nbsp;implements&nbsp;Fruit&nbsp;{  \n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;eat(){  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Apple\");  \n&nbsp;&nbsp;&nbsp;&nbsp;}  \n}  \nclass&nbsp;Orange&nbsp;implements&nbsp;Fruit&nbsp;{  \n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;void&nbsp;eat(){  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;System.out.println(\"Orange\");  \n&nbsp;&nbsp;&nbsp;&nbsp;}  \n}  \nclass&nbsp;Factory&nbsp;{  \n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;Fruit&nbsp;getInstance(String ClassName)&nbsp;{  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fruit f=null;  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try&nbsp;{  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f=(Fruit)Class.forName(ClassName).newInstance();  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}&nbsp;catch&nbsp;(Exception e) {  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;e.printStackTrace();  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;f;  \n&nbsp;&nbsp;&nbsp;&nbsp;}  \n}  \nclass&nbsp;Client&nbsp;{  \n&nbsp;&nbsp;&nbsp;&nbsp;public&nbsp;static&nbsp;void&nbsp;main(String[] a)&nbsp;{  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Fruit f=Factory.getInstance(\"io.github.dunwu.spring.Apple\");  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(f!=null){  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;f.eat();  \n&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}  \n&nbsp;&nbsp;&nbsp;&nbsp;}  \n}</code></pre> \n<h4>3、Beans</h4> \n<p>3.1. 什么是 spring bean？</p> \n<ul> \n <li>它们是构成用户应用程序主干的对象。</li> \n <li>Bean 由 Spring IoC 容器管理。</li> \n <li>它们由 Spring IoC 容器实例化，配置，装配和管理。</li> \n <li>Bean 是基于用户提供给容器的配置元数据创建。</li> \n</ul> \n<p>3.2. spring 提供了哪些配置方式？</p> \n<ul>\n <li>基于 xml 配置</li>\n</ul> \n<p>bean 所需的依赖项和服务在 XML 格式的配置文件中指定。这些配置文件通常包含许多 bean 定义和特定于应用程序的配置选项。它们通常以 bean 标签开头。例如：</p> \n<pre><code>&lt;bean id=\"studentbean\" class=\"org.edureka.firstSpring.StudentBean\"&gt;  \n &lt;property name=\"name\" value=\"Edureka\"&gt;&lt;/property&gt;  \n&lt;/bean&gt;</code></pre> \n<ul>\n <li>基于注解配置</li>\n</ul> \n<p>您可以通过在相关的类，方法或字段声明上使用注解，将 bean 配置为组件类本身，而不是使用 XML 来描述 bean 装配。默认情况下，Spring 容器中未打开注解装配。因此，您需要在使用它之前在 Spring 配置文件中启用它。例如：</p> \n<pre><code>&lt;beans&gt;  \n&lt;context:annotation-config/&gt;  \n&lt;!-- bean definitions go here --&gt;  \n&lt;/beans&gt;</code></pre> \n<ul>\n <li>基于 Java API 配置</li>\n</ul> \n<p>Spring 的 Java 配置是通过使用 @Bean 和 @Configuration 来实现。</p> \n<ol> \n <li>@Bean 注解扮演与 元素相同的角色。</li> \n <li>@Configuration 类允许通过简单地调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系。</li> \n</ol> \n<p>例如：</p> \n<pre><code>@Configuration  \npublic class StudentConfig {  \n &nbsp; &nbsp;@Bean  \n &nbsp; &nbsp;public StudentBean myStudent() {  \n &nbsp; &nbsp; &nbsp; &nbsp;return new StudentBean();  \n &nbsp; &nbsp;}  \n}</code></pre> \n<p>3.3. spring 支持集中 bean scope？</p> \n<p>Spring bean 支持 5 种 scope：</p> \n<ul> \n <li>Singleton - 每个 Spring IoC 容器仅有一个单实例。</li> \n <li>Prototype - 每次请求都会产生一个新的实例。</li> \n <li>Request - 每一次 HTTP 请求都会产生一个新的实例，并且该 bean 仅在当前 HTTP 请求内有效。</li> \n <li>Session - 每一次 HTTP 请求都会产生一个新的 bean，同时该 bean 仅在当前 HTTP session 内有效。</li> \n <li>Global-session - 类似于标准的 HTTP Session 作用域，不过它仅仅在基于 portlet 的 web 应用中才有意义。Portlet 规范定义了全局 Session 的概念，它被所有构成某个 portlet web 应用的各种不同的 portlet 所共享。在 global session 作用域中定义的 bean 被限定于全局 portlet Session 的生命周期范围内。如果你在 web 中使用 global session 作用域来标识 bean，那么 web 会自动当成 session 类型来使用。</li> \n</ul> \n<p>仅当用户使用支持 Web 的 ApplicationContext 时，最后三个才可用。这篇推荐看下：<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484136&amp;idx=1&amp;sn=69b44311cbc348a631b1a1171ca0a117&amp;chksm=eb5387dedc240ec8261dd1b7b917a2b1922925ec78f5c4e8da96f1a52d866468c2616b1b6751&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Spring bean&nbsp;scope详解</a>。关注微信公众号：Java技术栈，在后台回复：spring，可以获取我整理的 N 篇最新Spring 教程，都是干货。</p> \n<p>3.4. spring bean 容器的生命周期是什么样的？</p> \n<p>spring bean 容器的生命周期流程如下：</p> \n<ol> \n <li>Spring 容器根据配置中的 bean 定义中实例化 bean</li> \n <li>Spring 使用依赖注入填充所有属性，如 bean 中所定义的配置。</li> \n <li>如果 bean 实现 BeanNameAware 接口，则工厂通过传递 bean 的 ID 来调用 setBeanName()。</li> \n <li>如果 bean 实现 BeanFactoryAware 接口，工厂通过传递自身的实例来调用 setBeanFactory()。</li> \n <li>如果存在与 bean 关联的任何 BeanPostProcessors，则调用 preProcessBeforeInitialization() 方法。</li> \n <li>如果为 bean 指定了 init 方法（ 的 init-method 属性），那么将调用它。</li> \n <li>最后，如果存在与 bean 关联的任何 BeanPostProcessors，则将调用 postProcessAfterInitialization() 方法。</li> \n <li>如果 bean 实现 DisposableBean 接口，当 spring 容器关闭时，会调用 destory()。</li> \n <li>如果为 bean 指定了 destroy 方法（ 的 destroy-method 属性），那么将调用它。</li> \n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF7ik\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>3.5. 什么是 spring 的内部 bean？</p> \n<p>只有将 bean 用作另一个 bean 的属性时，才能将 bean 声明为内部 bean。为了定义 bean，Spring 的基于 XML 的配置元数据在 &lt;property&gt; 或 &lt;constructor-arg&gt; 中提供了 &lt;bean&gt; 元素的使用。内部 bean 总是匿名的，它们总是作为原型。</p> \n<p>例如，假设我们有一个 Student 类，其中引用了 Person 类。这里我们将只创建一个 Person 类实例并在 Student 中使用它。</p> \n<p>Student.java</p> \n<pre><code>public class Student {  \n &nbsp; &nbsp;private Person person;  \n &nbsp; &nbsp;//Setters and Getters  \n}  \npublic class Person {  \n &nbsp; &nbsp;private String name;  \n &nbsp; &nbsp;private String address;  \n &nbsp; &nbsp;//Setters and Getters  \n}</code></pre> \n<p>bean.xml</p> \n<pre><code>&lt;bean id=“StudentBean\" class=\"com.edureka.Student\"&gt;  \n &nbsp; &nbsp;&lt;property name=\"person\"&gt;  \n &nbsp; &nbsp; &nbsp; &nbsp;&lt;!--This is inner bean --&gt;  \n &nbsp; &nbsp; &nbsp; &nbsp;&lt;bean class=\"com.edureka.Person\"&gt;  \n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;property name=\"name\" value=“Scott\"&gt;&lt;/property&gt;  \n &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;&lt;property name=\"address\" value=“Bangalore\"&gt;&lt;/property&gt;  \n &nbsp; &nbsp; &nbsp; &nbsp;&lt;/bean&gt;  \n &nbsp; &nbsp;&lt;/property&gt;  \n&lt;/bean&gt;</code></pre> \n<p>3.6. 什么是 spring 装配</p> \n<p>当 bean 在 Spring 容器中组合在一起时，它被称为装配或 bean 装配。Spring 容器需要知道需要什么 bean 以及容器应该如何使用依赖注入来将 bean 绑定在一起，同时装配 bean。</p> \n<p>3.7. 自动装配有哪些方式？</p> \n<p>Spring 容器能够自动装配 bean。也就是说，可以通过检查 BeanFactory 的内容让 Spring 自动解析 bean 的协作者。</p> \n<p>自动装配的不同模式：</p> \n<ul> \n <li>no - 这是默认设置，表示没有自动装配。应使用显式 bean 引用进行装配。</li> \n <li>byName - 它根据 bean 的名称注入对象依赖项。它匹配并装配其属性与 XML 文件中由相同名称定义的 bean。</li> \n <li>byType - 它根据类型注入对象依赖项。如果属性的类型与 XML 文件中的一个 bean 名称匹配，则匹配并装配属性。</li> \n <li>构造函数 - 它通过调用类的构造函数来注入依赖项。它有大量的参数。</li> \n <li>autodetect - 首先容器尝试通过构造函数使用 autowire 装配，如果不能，则尝试通过 byType 自动装配。</li> \n</ul> \n<p>3.8. 自动装配有什么局限？</p> \n<ul> \n <li>覆盖的可能性 - 您始终可以使用 和 设置指定依赖项，这将覆盖自动装配。</li> \n <li>基本元数据类型 - 简单属性（如原数据类型，字符串和类）无法自动装配。</li> \n <li>令人困惑的性质 - 总是喜欢使用明确的装配，因为自动装配不太精确。</li> \n</ul> \n<h4>4、注解</h4> \n<p>4.1. 你用过哪些重要的 Spring 注解？</p> \n<ul> \n <li> <a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247491621&amp;idx=1&amp;sn=332712bcb7146cb9f5f3f280e3bb1c2b&amp;chksm=eb506513dc27ec05d2143663720c1a3b7d9b610954763cb7cea3f8f31a6bad5064d8ef5b13c1&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Spring 最常用的 7 大类注解，</a>这篇推荐看下。</li> \n <li>@Controller - 用于 Spring MVC 项目中的控制器类。</li> \n <li>@Service - 用于服务类。</li> \n <li>@RequestMapping - 用于在控制器处理程序方法中配置 URI 映射。</li> \n <li>@ResponseBody - 用于发送 Object 作为响应，通常用于发送 XML 或 JSON 数据作为响应。</li> \n <li>@PathVariable - 用于将动态值从 URI 映射到处理程序方法参数。</li> \n <li>@Autowired - 用于在 spring bean 中自动装配依赖项。</li> \n <li>@Qualifier - 使用 @Autowired 注解，以避免在存在多个 bean 类型实例时出现混淆。</li> \n <li>@Scope - 用于配置 spring bean 的范围。</li> \n <li>@Configuration，@ComponentScan 和 @Bean - 用于基于 java 的配置。</li> \n <li>@Aspect，@Before，@After，@Around，@Pointcut - 用于切面编程（AOP）。</li> \n</ul> \n<p>关注微信公众号：Java技术栈，在后台回复：spring，可以获取我整理的 N 篇最新Spring 教程，都是干货。</p> \n<p>4.2. 如何在 spring 中启动注解装配？</p> \n<p>默认情况下，Spring 容器中未打开注解装配。因此，要使用基于注解装配，我们必须通过配置&lt;context：annotation-config /&gt; 元素在 Spring 配置文件中启用它。</p> \n<p>4.3. @Component, @Controller, @Repository, @Service 有何区别？</p> \n<ul> \n <li>@Component：这将 java 类标记为 bean。它是任何 Spring 管理组件的通用构造型。spring 的组件扫描机制现在可以将其拾取并将其拉入应用程序环境中。</li> \n <li>@Controller：这将一个类标记为 Spring Web MVC 控制器。标有它的 Bean 会自动导入到 IoC 容器中。</li> \n <li>@Service：此注解是组件注解的特化。它不会对 @Component 注解提供任何其他行为。您可以在服务层类中使用 @Service 而不是 @Component，因为它以更好的方式指定了意图。</li> \n <li>@Repository：这个注解是具有类似用途和功能的 @Component 注解的特化。它为 DAO 提供了额外的好处。它将 DAO 导入 IoC 容器，并使未经检查的异常有资格转换为 Spring DataAccessException。</li> \n</ul> \n<p>4.4. @Required 注解有什么用？</p> \n<p>@Required 应用于 bean 属性 setter 方法。此注解仅指示必须在配置时使用 bean 定义中的显式属性值或使用自动装配填充受影响的 bean 属性。如果尚未填充受影响的 bean 属性，则容器将抛出 BeanInitializationException。</p> \n<p>示例：</p> \n<pre><code>public class Employee {  \n &nbsp; &nbsp;private String name;  \n &nbsp; &nbsp;@Required  \n &nbsp; &nbsp;public void setName(String name){  \n &nbsp; &nbsp; &nbsp; &nbsp;this.name=name;  \n &nbsp; &nbsp;}  \n  \n  \n &nbsp; &nbsp;public string getName(){  \n &nbsp; &nbsp; &nbsp; &nbsp;return name;  \n &nbsp; &nbsp;}  \n}</code></pre> \n<p>4.5. @Autowired 注解有什么用？</p> \n<p>@Autowired 可以更准确地控制应该在何处以及如何进行自动装配。此注解用于在 setter 方法，构造函数，具有任意名称或多个参数的属性或方法上自动装配 bean。默认情况下，它是类型驱动的注入。</p> \n<pre><code>public class Employee {  \n &nbsp; &nbsp;private String name;  \n &nbsp; &nbsp;@Autowired  \n &nbsp; &nbsp;public void setName(String name) {  \n &nbsp; &nbsp; &nbsp; &nbsp;this.name=name;  \n &nbsp; &nbsp;}  \n &nbsp; &nbsp;public string getName(){  \n &nbsp; &nbsp; &nbsp; &nbsp;return name;  \n &nbsp; &nbsp;}  \n}</code></pre> \n<p>4.6. @Qualifier 注解有什么用？</p> \n<p>当您创建多个相同类型的 bean 并希望仅使用属性装配其中一个 bean 时，您可以使用@Qualifier 注解和 @Autowired 通过指定应该装配哪个确切的 bean 来消除歧义。</p> \n<p>例如，这里我们分别有两个类，Employee 和 EmpAccount。在 EmpAccount 中，使用@Qualifier 指定了必须装配 id 为 emp1 的 bean。</p> \n<pre><code>public class Employee {  \n &nbsp; &nbsp;private String name;  \n &nbsp; &nbsp;@Autowired  \n &nbsp; &nbsp;public void setName(String name) {  \n &nbsp; &nbsp; &nbsp; &nbsp;this.name=name;  \n &nbsp; &nbsp;}  \n &nbsp; &nbsp;public string getName() {  \n &nbsp; &nbsp; &nbsp; &nbsp;return name;  \n &nbsp; &nbsp;}  \n}</code></pre> \n<p>EmpAccount.java</p> \n<pre><code>public class EmpAccount {  \n &nbsp; &nbsp;private Employee emp;  \n  \n &nbsp; &nbsp;@Autowired  \n &nbsp; &nbsp;@Qualifier(emp1)  \n &nbsp; &nbsp;public void showName() {  \n &nbsp; &nbsp; &nbsp; &nbsp;System.out.println(“Employee name : ”+emp.getName);  \n &nbsp; &nbsp;}  \n}</code></pre> \n<p>4.7. @RequestMapping 注解有什么用？</p> \n<p>@RequestMapping 注解用于将特定 HTTP 请求方法映射到将处理相应请求的控制器中的特定类/方法。<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247484331&amp;idx=1&amp;sn=acf8750f5b4174cf238527498f06e307&amp;chksm=eb53869ddc240f8bfebeb73cd5bae0fed5ebf4b349f37a62129afc7f0432fbf99500245f129a&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">Spring MVC常用注解，</a>推荐看下。</p> \n<p>此注解可应用于两个级别：</p> \n<ul> \n <li>类级别：映射请求的 URL</li> \n <li>方法级别：映射 URL 以及 HTTP 请求方法</li> \n</ul> \n<h4>5、数据访问</h4> \n<p>5.1. spring DAO 有什么用？</p> \n<p>Spring DAO 使得 JDBC，Hibernate 或 JDO 这样的数据访问技术更容易以一种统一的方式工作。这使得用户容易在持久性技术之间切换。它还允许您在编写代码时，无需考虑捕获每种技术不同的异常。</p> \n<p>5.2. 列举 Spring DAO 抛出的异常。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF7il\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>5.3. spring JDBC API 中存在哪些类？</p> \n<ul> \n <li>JdbcTemplate</li> \n <li>SimpleJdbcTemplate</li> \n <li>NamedParameterJdbcTemplate</li> \n <li>SimpleJdbcInsert</li> \n <li>SimpleJdbcCall</li> \n</ul> \n<p>5.4. 使用 Spring 访问 Hibernate 的方法有哪些？</p> \n<p>我们可以通过两种方式使用 Spring 访问 Hibernate：</p> \n<ol> \n <li>使用 Hibernate 模板和回调进行控制反转</li> \n <li>扩展 HibernateDAOSupport 并应用 AOP 拦截器节点</li> \n</ol> \n<p>5.5. 列举 spring 支持的事务管理类型</p> \n<p>Spring 支持两种类型的事务管理：</p> \n<ol> \n <li>程序化事务管理：在此过程中，在编程的帮助下管理事务。它为您提供极大的灵活性，但维护起来非常困难。</li> \n <li>声明式事务管理：在此，事务管理与业务代码分离。仅使用注解或基于 XML 的配置来管理事务。</li> \n</ol> \n<p>5.6. spring 支持哪些 ORM 框架</p> \n<ul> \n <li>Hibernate</li> \n <li>iBatis</li> \n <li>JPA</li> \n <li>JDO</li> \n <li>OJB</li> \n</ul> \n<h4>6、AOP</h4> \n<p>6.1. 什么是 AOP？</p> \n<p>AOP(Aspect-Oriented Programming), 即 面向切面编程, 它与 OOP( Object-Oriented Programming, 面向对象编程) 相辅相成, 提供了与 OOP 不同的抽象软件结构的视角。</p> \n<p>在 OOP 中, 我们以类(class)作为我们的基本单元, 而 AOP 中的基本单元是 Aspect(切面)</p> \n<p>6.2. AOP 中的 Aspect、Advice、Pointcut、JointPoint 和 Advice 参数分别是什么？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF7im\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ol> \n <li>Aspect - Aspect 是一个实现交叉问题的类，例如事务管理。方面可以是配置的普通类，然后在 Spring Bean 配置文件中配置，或者我们可以使用 Spring AspectJ 支持使用 @Aspect 注解将类声明为 Aspect。</li> \n <li>Advice - Advice 是针对特定 JoinPoint 采取的操作。在编程方面，它们是在应用程序中达到具有匹配切入点的特定 JoinPoint 时执行的方法。您可以将 Advice 视为 Spring 拦截器（Interceptor）或 Servlet 过滤器（filter）。</li> \n <li>Advice Arguments - 我们可以在 advice 方法中传递参数。我们可以在切入点中使用 args() 表达式来应用于与参数模式匹配的任何方法。如果我们使用它，那么我们需要在确定参数类型的 advice 方法中使用相同的名称。</li> \n <li>Pointcut - Pointcut 是与 JoinPoint 匹配的正则表达式，用于确定是否需要执行 Advice。Pointcut 使用与 JoinPoint 匹配的不同类型的表达式。Spring 框架使用 AspectJ Pointcut 表达式语言来确定将应用通知方法的 JoinPoint。</li> \n <li>JoinPoint - JoinPoint 是应用程序中的特定点，例如方法执行，异常处理，更改对象变量值等。在 Spring AOP 中，JoinPoint 始终是方法的执行器。</li> \n</ol> \n<p>6.3. 什么是通知（Advice）？</p> \n<p>特定 JoinPoint 处的 Aspect 所采取的动作称为 Advice。Spring AOP 使用一个 Advice 作为拦截器，在 JoinPoint “周围”维护一系列的拦截器。</p> \n<p>6.4. 有哪些类型的通知（Advice）？</p> \n<ul> \n <li>Before - 这些类型的 Advice 在 joinpoint 方法之前执行，并使用 @Before 注解标记进行配置。</li> \n <li>After Returning - 这些类型的 Advice 在连接点方法正常执行后执行，并使用@AfterReturning 注解标记进行配置。</li> \n <li>After Throwing - 这些类型的 Advice 仅在 joinpoint 方法通过抛出异常退出并使用 @AfterThrowing 注解标记配置时执行。</li> \n <li>After (finally) - 这些类型的 Advice 在连接点方法之后执行，无论方法退出是正常还是异常返回，并使用 @After 注解标记进行配置。</li> \n <li>Around - 这些类型的 Advice 在连接点之前和之后执行，并使用 @Around 注解标记进行配置。</li> \n</ul> \n<p>6.5. 指出在 spring aop 中 concern 和 cross-cutting concern 的不同之处。</p> \n<p>concern 是我们想要在应用程序的特定模块中定义的行为。它可以定义为我们想要实现的功能。</p> \n<p>cross-cutting concern 是一个适用于整个应用的行为，这会影响整个应用程序。例如，日志记录，安全性和数据传输是应用程序几乎每个模块都需要关注的问题，因此它们是跨领域的问题。</p> \n<p>6.6. AOP 有哪些实现方式？</p> \n<p>实现 AOP 的技术，主要分为两大类：</p> \n<ul> \n <li>静态代理 - 指使用 AOP 框架提供的命令进行编译，从而在编译阶段就可生成 AOP 代理类，因此也称为编译时增强；</li> \n <li>编译时编织（特殊编译器实现）</li> \n <li>类加载时编织（特殊的类加载器实现）。</li> \n <li>动态代理 - 在运行时在内存中“临时”生成 AOP 动态代理类，因此也被称为运行时增强。</li> \n <li>JDK 动态代理</li> \n <li>CGLIB</li> \n</ul> \n<p>6.7. Spring AOP and AspectJ AOP 有什么区别？</p> \n<p>Spring AOP 基于动态代理方式实现；AspectJ 基于静态代理方式实现。</p> \n<p>Spring AOP 仅支持方法级别的 PointCut；提供了完全的 AOP 支持，它还支持属性级别的 PointCut。</p> \n<p>6.8. 如何理解 Spring 中的代理？</p> \n<p>将 Advice 应用于目标对象后创建的对象称为代理。在客户端对象的情况下，目标对象和代理对象是相同的。<a href=\"http://mp.weixin.qq.com/s?__biz=MzI3ODcxMzQzMw==&amp;mid=2247486759&amp;idx=2&amp;sn=6769d8ff9d163babe726b6213c6d15e4&amp;chksm=eb538811dc240107bcf2a6e65b5381b2a68175af8ff12f4e2c1b0a06f7d16850db4acb64a18e&amp;scene=21#wechat_redirect\" rel=\"nofollow noreferrer\">详解 Java 中的三种代理模式</a>，这篇看下。</p> \n<pre><code>Advice&nbsp;+&nbsp;Target&nbsp;Object&nbsp;=&nbsp;Proxy</code></pre> \n<p>6.9. 什么是编织（Weaving）？</p> \n<p>为了创建一个 advice 对象而链接一个 aspect 和其它应用类型或对象，称为编织（Weaving）。在 Spring AOP 中，编织在运行时执行。请参考下图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF7in\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h4>7、MVC</h4> \n<p>7.1. Spring MVC 框架有什么用？</p> \n<p>Spring Web MVC 框架提供 模型-视图-控制器 架构和随时可用的组件，用于开发灵活且松散耦合的 Web 应用程序。</p> \n<p>MVC 模式有助于分离应用程序的不同方面，如输入逻辑，业务逻辑和 UI 逻辑，同时在所有这些元素之间提供松散耦合。</p> \n<p>7.2. 描述一下 DispatcherServlet 的工作流程</p> \n<p>DispatcherServlet 的工作流程可以用一幅图来说明：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF7io\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ol> \n <li>向服务器发送 HTTP 请求，请求被前端控制器 DispatcherServlet 捕获。</li> \n <li>DispatcherServlet 根据 -servlet.xml 中的配置对请求的 URL 进行解析，得到请求资源标识符（URI）。然后根据该 URI，调用 HandlerMapping 获得该 Handler 配置的所有相关的对象（包括 Handler 对象以及 Handler 对象对应的拦截器），最后以HandlerExecutionChain 对象的形式返回。</li> \n <li>DispatcherServlet 根据获得的Handler，选择一个合适的 HandlerAdapter。（附注：如果成功获得HandlerAdapter后，此时将开始执行拦截器的 preHandler(…)方法）。</li> \n <li>提取Request中的模型数据，填充Handler入参，开始执行Handler（Controller)。在填充Handler的入参过程中，根据你的配置，Spring 将帮你做一些额外的工作：</li> \n</ol> \n<ul> \n <li>HttpMessageConveter：将请求消息（如 Json、xml 等数据）转换成一个对象，将对象转换为指定的响应信息。</li> \n <li>数据转换：对请求消息进行数据转换。如`String`转换成`Integer`、`Double`等。</li> \n <li>数据根式化：对请求消息进行数据格式化。如将字符串转换成格式化数字或格式化日期等。</li> \n <li>数据验证：验证数据的有效性（长度、格式等），验证结果存储到`BindingResult`或`Error`中。</li> \n</ul> \n<p>5.Handler(Controller)执行完成后，向 DispatcherServlet 返回一个 ModelAndView 对象；</p> \n<p>6.根据返回的ModelAndView，选择一个适合的 ViewResolver（必须是已经注册到 Spring 容器中的ViewResolver)返回给DispatcherServlet。</p> \n<p>7.ViewResolver 结合Model和View，来渲染视图。</p> \n<p>8.视图负责将渲染结果返回给客户端。</p> \n<p>7.3. 介绍一下 WebApplicationContext</p> \n<p>WebApplicationContext 是 ApplicationContext 的扩展。它具有 Web 应用程序所需的一些额外功能。它与普通的 ApplicationContext 在解析主题和决定与哪个 servlet 关联的能力方面有所不同。</p> \n<p><strong>参考资料：</strong></p> \n<blockquote> \n <a href=\"https://www.edureka.co/blog/interview-questions/spring-interview-questions/\" rel=\"nofollow noreferrer\">https://www.edureka.co/blog/i...</a>\n <p><a href=\"https://www.journaldev.com/2696/spring-interview-questions-and-answers\" rel=\"nofollow noreferrer\">https://www.journaldev.com/26...</a></p> \n <p>作者：静默虚空<br>juejin.im/post/5cbda379f265da03ae74c282</p> \n</blockquote> \n<p><strong>推荐去我的博客阅读更多：</strong></p> \n<p>1.<a href=\"http://www.javastack.cn/categories/Java/\" rel=\"nofollow noreferrer\">Java JVM、集合、多线程、新特性系列教程</a></p> \n<p>2.<a href=\"http://www.javastack.cn/categories/Spring/\" rel=\"nofollow noreferrer\">Spring MVC、Spring Boot、Spring Cloud 系列教程</a></p> \n<p>3.<a href=\"http://www.javastack.cn/categories/Tools/\" rel=\"nofollow noreferrer\">Maven、Git、Eclipse、Intellij IDEA 系列工具教程</a></p> \n<p>4.<a href=\"http://www.javastack.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/\" rel=\"nofollow noreferrer\">Java、后端、架构、阿里巴巴等大厂最新面试题</a></p> \n<p>生活很美好，明天见～</p>', 'https://segmentfault.com/img/bVbF7ig', '6fbfa4aaad3a43458f21c8acf0038ac5', '2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-16 16:48:53', '2020-04-16 16:48:53');
INSERT INTO `tb_recommend` VALUES ('a82195a3a2c64033b6bf3b6692b19bbd', '《Flappy Bird》开发者：游戏爆红之后，觉得“这个世界突然疯了”...', '从默默无闻到一夜爆红，《Flappy BIrd》在当年创造手机游戏的一个奇迹，iOS 免费游戏下载榜单第一名、2014年\"美国及中国 iTunes 最受欢迎免费应用软件\"、被Cnet 评为“21世纪初全球最具影响力的 25 个 App 之一”。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbALB3\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>从默默无闻到一夜爆红，《Flappy BIrd》在当年创造手机游戏的一个奇迹，iOS 免费游戏下载榜单第一名、2014年\"美国及中国 iTunes 最受欢迎免费应用软件\"、被Cnet 评为“21世纪初全球最具影响力的 25 个 App 之一”。</p> \n<p>但就在爆火几天之后，开发者阮河东撂下一句：<strong>“他摧毁了我的生活，我恨他”。</strong>然后把游戏永久下架。</p> \n<p>这在我们看来不可思议，为他带来巨额收益和名气的作品，说放下就放下，这其中肯定有很多只有他自己才知道的隐情和感受。</p> \n<p>就在前不久，阮河东出现在母校越南河内理工大学，分享了他当时和现在的心路历程。</p> \n<h2>Flappy Bird 一战封神</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbALCa\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>阮河东在一个名为万福的越南小村庄长大，在《Flappy Bird》爆火之前，只是一个普普通通的、和父母一起居住的、看起来安静甚至有些腼腆的年轻人。他从没想过自己有朝一日会成为一个世界知名的游戏开发者。</p> \n<p><strong>16 岁那年，阮河东通过自学在电脑上编写了自己的第一个程序 —— 一个国际象棋游戏。</strong>这也燃起了他对编程开发的兴趣与信心。在报考大学时选择了河内的一所大学学习计算机专业，并加入了河内唯一的一家游戏公司实习。</p> \n<p>阮河东表示，在《Flappy Bird》之前，他本来打算成为一名工程师，但后来决定改变自己的职业，为移动设备做手游。</p> \n<p>在 2013 年的时候，App Store 里最热门的游戏的《糖果传奇》和《愤怒的小鸟》等作品，<strong>但这些游戏大部分都是为了满足玩家「长期服务式娱乐」的需求，具有丰富的玩法和内容，但阮河东想做的是一款「一分钟就能结束的游戏」。</strong></p> \n<p>做这个决定的另一个原因是，当时他并没有足够的决心完成一款游戏，除正常的工作外，他一没有太多的业余时间，二没有自己的团队，三是也没有什么预算。为了完成这个游戏，他必须把项目限制的尽可能小，功能尽可能的简单，才有可能完成。</p> \n<p>于是他就给自己想做的游戏设定了一个核心法则：<strong>他希望游戏是可爱的，要足以吸引年轻人，而且要让没有多少时间玩的人们易于上手。</strong></p> \n<p>做完决定之后，他用了 2 至 3 天开发《Flappy Bird》，结果我们大家都知道，他和他的鸟，一战成名。</p> \n<p>游戏一经推出，很快就登上了 iOS 免费游戏下载榜单的第一名，并在 2014 年初被评为“美国及中国 iTunes 最受欢迎免费应用软件”。</p> \n<p>在 2014 年 2 月，《Flappy Bird》玩家游戏次数超过 200 亿次，在 App Store 和 Google Play 单月下载了破 9000 万次。当时最高单日广告收入 5 万美元。</p> \n<p>这个结果让阮河东很意外，《Flappy Bird》完全是他一个人用业余时间开发制作，并且就这样的一个像素级作品，竟然能够登顶全球下载榜。</p> \n<h2>“他摧毁了我的生活，我恨他”</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbALCf\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>在游戏爆火之后，除了名声与收入，也给他带来了很多的麻烦以及社会压力：</p> \n<p>《赫芬顿邮报》指出这款游戏是一个“疯狂地恼人、困难和令人沮丧的游戏”，且“结合了超陡峭的难度曲线、差劣无聊的画质和生硬的动作”。</p> \n<p>这款游戏的难度也导致不少玩家感到愤怒，其中一位玩家更指出他自己用了半小时才能获得 5 分...</p> \n<p>还有人指责他在 App Store 排名作弊，而且抄袭了《马里奥》游戏...</p> \n<p>但最让阮河东担忧的是，是他在社交网站上收到的几条评论信息：</p> \n<p>一个妈妈声称阮河东的游戏「让孩子沉迷」，另一个人则感叹：“在我的学校里已经有13个孩子因为你的游戏而摔了他们的手机，他们简直对这上了瘾。”</p> \n<p>阮河东在采访中还提及到，有人因为玩这个游戏而丢了工作，有的孩子沉迷于游戏不再愿意和母亲交流。</p> \n<p><strong>“一开始我以为他们只是在开玩笑，直到我发现他们真的伤害到了自己。”</strong>阮河东这才了解到这件事情的严重性。</p> \n<p>为了知道这个爆款游戏和开发者的最新动态，当地的狗仔队围在他家门口，严重影响了他和家人的生活。“我无法入睡。（我感觉）生活不像以前那样轻松舒适了。”</p> \n<p><strong>那时他才 28 岁，只有一个想法就是“这个世界突然疯了。”</strong></p> \n<p>虽然比起从游戏中得到的收入，这样的代价似乎很小，但阮河东依然觉得媒体的关注让他感到窒息。心理和生理上的嘈杂烦恼，让他只想要平静的一个人待一会儿。</p> \n<p>“设计 Flapp Bird 的初衷是希望人们能在放松的时候玩上几分钟。但不巧的是，它现在成为了一款让人上瘾的产品。我觉得，这已经成为了一个问题了。为了解决这个问题，最好的办法就是让 Flappy Bird 下架。现在它永远不会再回来了。”</p> \n<p>2014 年 2 月 8 日，阮河东在 twitter 上发了一篇推文，公布他将把游戏永久下架。</p> \n<p>多年之后，阮河东回忆到：<strong>“虽然在《Flappy Bird》成功之后根本没时间享受其中的喜悦，但对于该游戏登顶 App Store ，还是感到过自豪。”</strong></p> \n<h2>消失五年，归来恰似少年</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbALCr\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>五年后，开发者阮河东出现在母校越南河内理工大学，分享当时和现在的心路历程。</p> \n<p>在分享会中，有现场的学生问他是否后悔把游戏下架，从而失去巨额的收入来源？</p> \n<p>但阮河东没有直接回答这个问题，而是说了下他目前理解的「收入和工作」的关系。</p> \n<blockquote>\n “在美国，人们用一百万美元衡量一个人，有了一百万美元就意味着这个人不用工作了 ——\n <br>我曾经以为我有了一百万美元就会退休……后来我很多次达成了这个目标，但是我仍然无法退休。\n <p>各人有各人的选择……<strong>我当年（成功）的代价就是自己的成长。但不要牺牲自己的成长来换取短期的成功。</strong>”</p> \n</blockquote> \n<p>不过现在的他，看到的更多的是事情积极的一面。</p> \n<p>Flappy Bird 的成功让他变得很有信心，「我可以自由地去做任何我想做的事情。」</p> \n<p>除了 Flappy Bird，阮河东还开发了 Super Ball Juggling 和 Shuriken Block 两款游戏，目前它们在 App Store 分别排名第 6 和第 8。</p> \n<p>阮河东说，如果这两款游戏如果能够和《Flappy Bird》一样让人沉迷，那么这次他将毫不犹豫的将他们下架。</p> \n<p>这大概就是属于一个技术至上者的理想主义，引用一句话：</p> \n<blockquote>\n 无论是深重的痛苦还是巨大的利益，无论是恶意的攻击抑或盲目的追捧，他都只信奉技术为真理，他依仗技术，因技术而骄傲，为守护心中的技术梦想而自豪。\n</blockquote> \n<h2>后话：开发者的技术理想</h2> \n<p>作为开发者，作为一名互联网社会的「搭建者」，我们的初心一定是想通过技术实现我们的价值，通过技术去做一些可以影响世界或者让社会变得更好的事情。</p> \n<p>这可能就是根植于纯粹技术人心中，纯粹的技术理想吧。</p> \n<p>Respect。</p> \n<blockquote>\n 太阳下山明早依旧爬上来\n <br>花儿谢了明天还是一样的开\n <br>我的青春一去无影踪\n <br>我的青春小鸟一去不回来\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbAuMz\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbALB3', '61cdf41d1e5e4f229b76f6a042e254b6', '66d1b6953b664c409cf7283cdb6c6566,a4f4fd7a73b84a7298db0174165eeaac,9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-16 16:57:50', '2020-04-16 16:57:50');
INSERT INTO `tb_recommend` VALUES ('a894f1b41e4c4886a4c143c6d4fced3a', '新冠疫情在阻止全球变暖，让地球自愈？你可拉倒吧！', '内容概要：受新冠疫情影响，经济环境急剧收缩，有机构预测全球今年碳排放将达到历史最高水平，远超二战后，和 08 年金融危机，却仍然不能阻止全球变暖的趋势。', '<blockquote>\n 内容概要：受新冠疫情影响，经济环境急剧收缩，有机构预测全球今年碳排放将达到历史最高水平，远超二战后，和 08 年金融危机，却仍然不能阻止全球变暖的趋势。\n</blockquote> \n<blockquote>\n 关键词：新冠疫情 经济收缩 碳排放\n</blockquote> \n<h2>经济环境收缩 30%，碳排放仅下降 4%</h2> \n<p>新冠疫情的持续，已经对世界范围内所有国家的经济造成了巨大影响。据预测统计，今年第一季度，中国的经济总量收缩 40%，美国的经济总量收缩 30%-50%。</p> \n<p>根据第一财经的报道，他们邀请了我国 20 位首席经济学家进行了预测，所有经济学家均预计 2020 年 GDP 增速放缓已成为不争的事实。</p> \n<p>而且，短期内疫情对经济所受影响更为显著，第一季度 GDP 增速将大幅下滑至负数，预测均值为 -6.48 %。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0AG\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"b79083a3ed481b76c65802840a8b6ca9.jpg\" title=\"b79083a3ed481b76c65802840a8b6ca9.jpg\"></span></p> \n<p>人们停止了旅行、出门购物，带来经济的大幅收缩，但在碳排放上却没有获得同等的效果。</p> \n<h2>碳排放达最高降幅，仍无法阻止全球变暖</h2> \n<p>英国气候政策网站 Carbon Brief，作为业内权威的能源机构，预测新冠疫情能够减少约 1600Mt 二氧化碳的排放量，这大约是 2019 年全球排放量的 4 ％。</p> \n<p>迄今为止，上一次如此规模的碳排放骤降，还是在第二次世界大战结束时，1944 -1945 年，全球的碳排放量下降了 845 Mt 。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0AO\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"31388add09944566f55e5e095159dabf.jpg\" title=\"31388add09944566f55e5e095159dabf.jpg\"></span></p> \n<ul>\n <li><em>Carbon Brief 对近代碳排放的几次骤降的图示</em></li>\n</ul> \n<p>蓝色分别代表：二战后、1991-1992 世界大萧条、能源危机、西班牙流感、2008 年金融危机，和这些时段减排的二氧化碳量。</p> \n<p>红色分别代表：新冠疫情对印度、美国中国和欧盟的碳排放的预测减排量，和全球石油部门碳排放的预测减排量，总和为世界碳排放的预测减排量。</p> \n<p>在此基础上，前几日，有媒体写出《碳排放急速下降，新冠疫情正在阻止全球变暖》等文章，内容中举例威尼斯的河水变清，动物出没在城市。</p> \n<p>就此得出结论：地球在自愈，全球在减速变暖。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0AS\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"气候变化.jpg\" title=\"气候变化.jpg\"></span></p> \n<p>这些都是很美好的想象。</p> \n<p>经济的报复式增长，是疫情结束后大概率会出现的局面，并不会因为考虑到碳排放而控制。</p> \n<p>在 2008-2009 年金融危机之后，碳排放下降幅度排在历史第五位，为 440 Mt。</p> \n<p>但金融危机的后一年，受到经济增长的刺激，全球碳排放量报复式增长了 1612 Mt。</p> \n<p>而我们遏制全球变暖的理想计划：必须在未来十年中，世界每年需要减少 6 ％的碳排放量，才能使温度下降 1.5 摄氏度。</p> \n<p>换句话说，即使全球经济负增长，即使我们在近几个月里，停止了大部分的环球贸易、旅游。</p> \n<p>但这点减少的排放，和暂时的生态改善，根本不足以动摇全球变暖的局面。</p> \n<h2>停止幻想地球自愈，落实真正的解决方案</h2> \n<p>2019 年 6 月，Yoshua Bengio、吴恩达和 Carla Gomes 联合了 20 多个气候变化人工智能指导委员会和顾问成员，其中包括 DeepMind 创始人 Demis Hassabis。</p> \n<p>共同发表了一篇题为《用机器学习应对气候变化》的论文，其中包含 650 篇参考文献。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0AU\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"aba5a9543607dff20029a07bea9b2040.jpg\" title=\"aba5a9543607dff20029a07bea9b2040.jpg\"></span></p> \n<p>该论文探讨了机器学习在气候变化中的应用，如预测供需或极端天气事件，以及可提高城市、交通和电力系统效率的预测 AI。</p> \n<h3>应对气候变化：停止口号，停止空想</h3> \n<p>在去年底 NeurIPS 2019 中，由气候变化人工智能组织（Climate Change AI）主办的「气候变化」的分会场中，邀请到了 Yoshua Bengio、吴恩达、Jeff Dean，以及 Carla Gomes 进行交流。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0Bl\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"b4682f837a185ff0dc7f1bd4328f4c36.jpg\" title=\"b4682f837a185ff0dc7f1bd4328f4c36.jpg\"></span>**<br>Yoshua Bengio 表示在 NeurIPS 上讨论减少碳排放的项目，可能会比讨论 GAN 或其他技术进步更有意义。</p> \n<p>吴恩达也认为，与其强调气候问题的严重性，不如做出实际行动——先梳理相关数据集，然后进行实验，最终公布研究结果，或与气候科学家进行对话。</p> \n<h3>下一次正式讨论</h3> \n<p>按照原计划，下一次关于利用 AI 应对气候变化主题论坛将于本月，在埃塞俄比亚的斯亚贝巴举行的 ICLR 2020 中继续。</p> \n<p>但因为新冠疫情，ICLR 2020 将改为 4 月 25 日- 30 日在线上举办网络会议（网址：<a href=\"https://iclr.cc/\" rel=\"nofollow noreferrer\">https://iclr.cc/</a>）。</p> \n<p><em>参考来源：</em><br>1）<a href=\"https://www.technologyreview.com/2020/04/10/999230/we-halted-the-global-economy-and-emissions-still-wont-decline-as-much-as-we-need/\" rel=\"nofollow noreferrer\">https://www.technologyreview....</a><br>2）<a href=\"https://www.carbonbrief.org/analysis-coronavirus-set-to-cause-largest-ever-annual-fall-in-co2-emissions\" rel=\"nofollow noreferrer\">https://www.carbonbrief.org/a...</a><br>3）<a href=\"https://www.leiphone.com/news/201912/37EHy6r7KK54JEFD.html\" rel=\"nofollow noreferrer\">https://www.leiphone.com/news...</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0Dr\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"截屏2020-04-14 下午12.08.26.png\" title=\"截屏2020-04-14 下午12.08.26.png\"></span></p>', 'https://segmentfault.com/img/bVbF0AG', 'f53014d680884163a5bd5ce762e90cdf', '13f1211b651544e3a17611b2117e9cec,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-16 16:55:36', '2020-04-16 16:55:36');
INSERT INTO `tb_recommend` VALUES ('a90f0f475f6542318303a2304433fadb', '快速学习MySQL数据库！掌握这38点够用了', '无论是运维、开发、测试，还是架构师，数据库技术是一个必备加薪神器，那么，一直说学习数据库、学MySQL，到底是要学习它的哪些东西呢？此文为你揭晓，你值得一看！看过别忘记点赞+转发支持哦。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022381428\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>原文：<a href=\"https://www.cnblogs.com/Survivalist/p/7954943.html\" rel=\"nofollow noreferrer\">https://www.cnblogs.com/Survi...</a></p> \n<blockquote>\n 无论是运维、开发、测试，还是架构师，数据库技术是一个必备加薪神器，那么，一直说学习数据库、学MySQL，到底是要学习它的哪些东西呢？此文为你揭晓，你值得一看！看过别忘记点赞+转发支持哦。\n</blockquote> \n<h5>1.如何快速掌握MySQL?</h5> \n<p><strong><em>⑴培养兴趣</em></strong> <br>兴趣是最好的老师，不论学习什么知识，兴趣都可以极大地提高学习效率。当然学习MySQL 5.6也不例外。 <br><strong><em>⑵夯实基础</em></strong> <br>计算机领域的技术非常强调基础，刚开始学习可能还认识不到这一点，随着技术应用的深 入，只有有着扎实的基础功底，才能在技术的道路上走得更快、更远。对于MySQL的学习来说， SQL语句是其中最为基础的部分，很多操作都是通过SQL语句来实现的。所以在学习的过程中， 读者要多编写SQL语句，对于同一个功能，使用不同的实现语句来完成，从而深刻理解其不同之处。 <br><strong><em>(3)及时学习新知识</em></strong> <br>正确、有效地利用搜索引擎，可以搜索到很多关于MySQL 5.6的相关知识。同时，参考别 人解决问题的思路，也可以吸取别人的经验，及时获取最新的技术资料。 <br><strong><em>⑷多实践操作</em></strong> <br>数据库系统具有极强的操作性，需要多动手上机操作。在实际操作的过程中才能发现问题， 并思考解决问题的方法和思路，只有这样才能提高实战的操作能力。</p> \n<h5>2.如何选择服务器的类型？</h5> \n<p>MySQL服务器配置窗口中各个参数的含义如下。 <br>【Server Configuration Type】该选项用于设置服务器的类型。单击该选项右侧的向下按钮， 即可看到包括3个选项。</p> \n<p><strong><em>3个选项的具体含义如下。</em></strong></p> \n<ul> \n <li>(1) Development Machine(开发机器)：该选项代表典型个人用桌面工作站。假定机器上运行 着多个桌面应用程序。将MySQL服务器配置成使用最少的系统资源。</li> \n <li>(2) Server Machine (服务器)：该选项代表服务器，MySQL服务器可以同其它应用程序一起 运行，例如FTP、email和web服务器。MySQL服务器配置成使用适当比例的系统资源。</li> \n <li>(3) DedicatedMySQL Server Machine (专用 MySQL 服务器）：该选项代表只运行MySQL服务的服务器。假定运行没有运行其它应用程序。MySQL服务器配置成使用所有可用系统资源。作为初学者，建议选择【DevelopmentMachine】（开发者机器）选项，这样占用系统的资源 比较少。</li> \n</ul> \n<h5>3.如何选择存储引擎</h5> \n<p>不同存储引擎都有各自的特点，以适应不同的需求，如下表所示。为了做出选择：</p> \n<ul> \n <li>1、首先需 要考虑每一个存储引擎提供了哪些不同的功能。如果要提供提交，回滚和崩溃恢复能力的事务安全（ACID兼容）能力，并要求实现并发控 制，InnoDB是个很好的选择。如果数据表主要用来插入和查询记录，则MyISAM引擎能提供较 高的处理效率；如果只是临时存放数据，数据量不大，并且不需要较高的数据安全性，可以选择将数据保存在内存中的Memory引擎，MySQL中使用该引擎作为临时表，存放查询的中间结果。如果只有INSERT和SELECT操作，可以选择Archive引擎，Archive存储引擎支持高并发的插 入操作，但是本身并不是事务安全的。Archive存储引擎非常适合存储归档数据，如记录日志信 息可以使用Archive引擎。</li> \n <li>2、使用哪一种引擎要根据需要灵活选择，一个数据库中多个表可以使用不同引擎以满足各种性能和实际需求。</li> \n <li>3、使用合适的存储引擎，将会提高整个数据库的性能。</li> \n</ul> \n<h5>4.如何查看默认存储引擎？</h5> \n<p>使用SHOW ENGINES语句查看系统中所有的存储引擎，其中包括默认的存储引擎。可以看出来当前数据库系统中有五种存储引擎，默认是MyISAM。还可以使用一种直接的方法查看默认存储引擎。执行结果直接显示了当前默认的存储引擎为MyISAM。</p> \n<h5>5.表删除操作须谨慎。</h5> \n<p>表删除操作将把表的定义和表中的数据一起删除，并且MySQL在执行删除操作时，不会有 任何的确认信息提示，因此执行删除操时，应当慎重。在删除表前，最好对表中的数据进行备份， 这样当操作失误时，可以对数据进行恢复，以免造成无法挽回的后果。同样的，在使用ALTER TABLE进行表的基本修改操作时，在执行操作过程之前，也应该 确保对数据进行完整的备份，因为数据库的改变是无法撤销的，如果添加了一个不需要的字段， 可以将其删除；相同的，如果删除了一个需要的列，该列下面的所有数据都将会丢失。</p> \n<h5>6.每个表中都要有一个主键吗？</h5> \n<p>并不是每一个表中都需要主键，一般的，如果多个表之间进行连接操作时，需要用到主键。 因此并不需要为每个表建立主键，而且有些情况最好不使用主键。</p> \n<h5>7.每个表都可以任意选择存储引擎吗？</h5> \n<p>外键约束（FOREIGN KEY)不能跨引擎使用。MySQL支持多种存储引擎，每一个表都可 以指定一个不同的存储引擎，但是要注意：外键约束是用来保证数据的参照完整性，如果表之间 需要关联外键，却指定了不同的存储引擎，这些表之间是不能创建外键约束的。所以说，存储引 擎的选择也不完全是随意的。</p> \n<h5>8.带AUTO_INCREMENT约束的字段值是从1开始的吗？</h5> \n<p>默认的，在MySQL中，AUTO_INCREMENT的初始值是1，每新增一条记录，字段值自动加1。设置自增属性（AUTO_INCREMENT)的时候，还可以指定第一条插入记录的自增字段的 值，这样新插入的记录的自增字段值从初始值开始递增，如在tb_emp8中插入第一条记录，同时 指定id值为5,则以后插入的记录的id值就会从6开始往上增加。添加唯一性的主键约束时， 往往需要设置字段自动增加属性。</p> \n<h5>9.带AUTO_INCREMENT约束的字段值是从1开始的吗？</h5> \n<p>TIMESTAMP与DATETIME除了存储字节和支持的范围不同外，还有一个最大的区别就是： DATETIME在存储日期数据时，按实际输入的格式存储，即输入什么就存储什么，与时区无关； 而TIMESTAMP值的存储是以UTC(世界标准时间）格式保存的，存储时对当前时区进行转换， 检索时再转换回当前时区。即查询时，根据当前时区的不同，显示的时间值是不同的。</p> \n<h5>10.选择数据类型的方法和技巧是什么？</h5> \n<p>MySQL提供了大量的数据类型，为了优化存储，提高数据库性能，在任何情况下均应使用 最精确的类型。即在所有可以表示该列值的类型中，该类型使用的存储最少。 <br><strong><em>1.整数和浮点数</em></strong> <br>如果不需要小数部分，则使用整数来保存数据；如果需要表示小数部分，则使用浮点数类 型。对于浮点数据列，存入的数值会对该列定义的小数位进行四舍五入。例如如果列的值的范 围为1〜99999，若使用整数，则MEDIUMINT UNSIGNED是最好的类型；若需要存储小数，则 使用FLOAT类型。浮点类型包括FLOAT和DOUBLE类型。DOUBLE类型精度比FLOAT类型高，因此，如要求存储精度较高时，应选择DOUBLE类型。 <br><strong><em>2.浮点数和定点数</em></strong> <br>浮点数FLOAT，DOUBLE相对于定点数DECIMAL的优势是：在长度一定的情况下，浮点 数能表示更大的数据范围。但是由于浮点数容易产生误差，因此对精确度要求比较高时，建议使 用DECIMAL来存储。DECIMAL在MySQL中是以字符串存储的，用于定义货币等对精确度要 求较高的数据。在数据迁移中，float(M,D)是非标准SQL定义，数据库迁移可能会出现问题，最 好不要这样使用。另外两个浮点数进行减法和比较运算时也容易出问题，因此在进行计算的时候， 一定要小心。如果进行数值比较，最好使用DECIMAL类型。 <br><strong><em>3.日期与时间类型</em></strong> <br>MySQL对于不同种类的日期和时间有很多的数据类型，比如YEAR和TIME。如果只需要 记录年份，则使用YEAR类型即可；如果只记录时间，只须使用TIME类型。如果同时需要记录日期和时间，则可以使用TIMESTAMP或者DATETIME类型。由于 TIMESTAMP列的取值范围小于DATETIME的取值范围，因此存储范围较大的日期最好使用 DATETIME。TIMESTAMP也有一个DATETIME不具备的属性。默认的情况下，当插入一条记录但并没 有指定TIMESTAMP这个列值时，MySQL会把TIMESTAMP列设为当前的时间。因此当需要 插入记录同时插入当前时间时，使用TIMESTAMP是方便的，另外TIMESTAMP在空间上比 DATETIME更有效。</p> \n<p><strong><em>4.CHAR与VARCHAR之间的特点与选择</em></strong></p> \n<h6>CHAR和VARCHAR的区别：</h6> \n<ul> \n <li>CHAR是固定长度字符，VARCHAR是可变长度字符；CHAR会自动删除插入数据的尾部 空格，VARCHAR不会删除尾部空格。</li> \n <li>CHAR是固定长度，所以它的处理速度比VARCHAR的速度要快，但是它的缺点就是浪费 存储空间。所以对存储不大，但在速度上有要求的可以使用CHAR类型，反之可以使用 VARCHAR类型来实现。</li> \n</ul> \n<h5>存储引擎对于选择CHAR和VARCHAR的影响：</h5> \n<ul> \n <li>对于MyISAM存储引擎：最好使用固定长度的数据列代替可变长度的数据列。这样可以使 整个表静态化，从而使数据检索更快，用空间换时间。</li> \n <li>对于InnoDB存储引擎：使用可变长度的数据列，因为InnoDB数据表的存储格式不分固定 长度和可变长度，因此使用CHAR不一定比使用VARCHAR更好，但由于VARCHAR是按照 实际的长度存储，比较节省空间，所以对磁盘I/O和数据存储总量比较好。</li> \n</ul> \n<p><strong><em>5.ENUM 和 SET</em></strong> <br>ENUM只能取单值，它的数据列表是一个枚举集合。它的合法取值列表最多允许有65 535 个成员。因此，在需要从多个值中选取一个时，可以使用ENUM。比如：性别字段适合定义为 ENUM类型，每次只能从’男’或’女’中取一个值。SET可取多值。它的合法取值列表最多允许有64个成员。空字符串也是一个合法的SET值。 在需要取多个值的时候，适合使用SET类型，比如：要存储一个人兴趣爱好，最好使用SET类型。ENUM和SET的值是以字符串形式出现的，但在内部，MySQL以数值的形式存储它们。 <br><strong><em>6.BLOB 和 TEXT</em></strong> <br>BLOB是二进制字符串，TEXT是非二进制字符串，两者均可存放大容量的信息。BLOB主 要存储图片、音频信息等，而TEXT只能存储纯文本文件。应分清两者的用途。</p> \n<h5>11.MySQL中如何使用特殊字符？</h5> \n<p>诸如单引号（’），双引号（\"），反斜线（)等符号，这些符号在MySQL中不能直接输入 使用，否则会产生意料之外的结果。在MySQL中，这些特殊字符称为转义字符，在输入时需要 以反斜线符号（’\\’）开头，所以在使用单引号和双引号时应分别输入（\\’）或者（\\\")，输入反 斜线时应该输入（\\)，其他特殊字符还有回车符（\\r)，换行符（\\n)，制表符（\\tab)，退格 符（\\b)等。在向数据库中插入这些特殊字符时，一定要进行转义处理。</p> \n<h5>12.MySQL中可以存储文件吗？</h5> \n<p>MySQL中的BLOB和TEXT字段类型可以存储数据量较大的文件，可以使用这些数据类型 存储图像、声音或者是大容量的文本内容，例如网页或者文档。虽然使用BLOB或者TEXT可 以存储大容量的数据，但是对这些字段的处理会降低数据库的性能。如果并非必要，可以选择只 储存文件的路径。</p> \n<h5>13.MySQL中如何执行区分大小写的字符串比较？</h5> \n<p>在Windows平台下，MySQL是不区分大小的，因此字符串比较函数也不区分大小写。如果 想执行区分大小写的比较，可以在字符串前面添加BINARY关键字。例如默认情况下，’a’=‘A’ 返回结果为1，如果使用BINARY关键字，BINARY’a’=‘A’结果为0,在区分大小写的情况下，’a’ 与’A’并不相同。</p> \n<h5>14.如何从日期时间值中获取年、月、日等部分日期或时间值？</h5> \n<p>MySQL中，日期时间值以字符串形式存储在数据表中，因此可以使用字符串函数分别截取日期时间值的不同部分，例如某个名称为dt的字段有值“2010-10-01 12:00:30”，如果只需要获 得年值，可以输入LEFT(dt, 4)，这样就获得了字符串左边开始长度为4的子字符串，即YEAR 部分的值；如果要获取月份值，可以输入MID(dt,6,2)，字符串第6个字符开始，长度为2的子 字符串正好为dt中的月份值。同理，读者可以根据其他日期和时间的位置，计算并获取相应的值。</p> \n<h5>15.如何改变默认的字符集？</h5> \n<p>CONVERT()函数改变指定字符串的默认字符集，在开始的章节中，向读者介绍使用GUI图形化安装配置工具进行MySQL的安装和配置，其中的一个步骤是可以选择MySQL的默认字符集。但是，如果只改变字符集，没有必要把配置过程重新执行一遍，在这里，一个简单的方式是 修改配置文件。在Windows中，MySQL配置文件名称为my.ini，该文件在MySQL的安装目录下面。修改配置文件中的default-character-set和character-set-server参数值，将其改为想要的字 符集名称，如gbk、gb2312、latinl等，修改完之后重新启动MySQL服务，即可生效。读者可以在修改字符集时使用SHOW VARIABLES LIKE ’character_set_°%’;命令查看当前字符集，以进行对比。</p> \n<h5>16.DISTINCT可以应用于所有的列吗？</h5> \n<p>查询结果中，如果需要对列进行降序排序，可以使用DESC，这个关键字只能对其前面的列 进行降序排列。例如，要对多列都进行降序排序，必须要在每一列的列名后面加DESC关键字。 而DISTINCT不同，DISTINCT不能部分使用。换句话说，DISTINCT关键字应用于所有列而不 仅是它后面的第一个指定列。例如，查询3个字段s_id，f_name，f_price，如果不同记录的这3个字段的组合值都不同，则所有记录都会被查询出来。</p> \n<h5>17.ORDER BY可以和LIMIT混合使用吗？</h5> \n<p>在使用ORDER BY子句时，应保证其位于FROM子句之后，如果使用LIMIT，则必须位 于ORDER BY之后，如果子句顺序不正确，MySQL将产生错误消息。</p> \n<h5>18.什么时候使用引号？</h5> \n<p>在查询的时候，会看到在WHERE子句中使用条件，有的值加上了单引号，而有的值未加。 单引号用来限定字符串，如果将值与字符串类型列进行比较，则需要限定引号；而用来与数值进 行比较则不需要用引号。</p> \n<h5>19.在WHERE子句中必须使用圆括号吗？</h5> \n<p>任何时候使用具有AND和OR操作符的WHERE子句，都应该使用圆括号明确操作顺序。 如果条件较多，即使能确定计算次序，默认的计算次序也可能会使SQL语句不易理解，因此使 用括号明确操作符的次序，是一个好的习惯。</p> \n<h5>20.更新或者删除表时必须指定WHERE子句吗？</h5> \n<p>在前面章节中可以看到，所有的UPDATE和DELETE语句全都在WHERE子句中指定了条 件。如果省略WHERE子句，则UPDATE或DELETE将被应用到表中所有的行。因此，除非 确实打算更新或者删除所有记录，否则要注意使用不带WHERE子句的UPDATE或DELETE 语句。建议在对表进行更新和删除操作之前，使用SELECT语句确认需要删除的记录，以免造 成无法挽回的结果。</p> \n<h5>21.索引对数据库性能如此重要，应该如何使用它？</h5> \n<p>为数据库选择正确的索引是一项复杂的任务。如果索引列较少，则需要的磁盘空间和维护开销 都较少。如果在一个大表上创建了多种组合索引，索引文件也会膨胀很快。而另一方面，索引较多 可覆盖更多的查询。可能需要试验若干不同的设计，才能找到最有效的索引。可以添加、修改和删 除索引而不影响数据库架构或应用程序设计。因此，应尝试多个不同的索引从而建立最优的索引。</p> \n<h5>22.尽量使用短索引。</h5> \n<p>对字符串类型的字段进行索引，如果可能应该指定一个前缀长度。例如，如果有一个 CHAR(255)的列，如果在前10个或30个字符内，多数值是惟一的，则不需要对整个列进行索引。 短索引不仅可以提高查询速度而且可以节省磁盘空间、减少I/O操作。</p> \n<h5>23. MySQL存储过程和函数有什么区别？</h5> \n<p>在本质上它们都是存储程序。函数只能通过return语句返回单个值或者表对象；而存储过程 不允许执行return，但是可以通过out参数返回多个值。函数限制比较多，不能用临时表，只能用表变量，还有一些函数都不可用等等；而存储过程的限制相对就比较少。函数可以嵌入在SQL 语句中使用，可以在SELECT语句中作为查询语句的一个部分调用；而存储过程一般是作为一个独立的部分来执行。</p> \n<h6>24.存储过程中的代码可以改变吗？</h6> \n<p>目前，MySQL还不提供对已存在的存储过程代码的修改，如果必须要修改存储过程，必须使用DROP语句删除之后，再重新编写代码，或者创建一个新的存储过程。</p> \n<h5>25.存储过程中可以调用其他存储过程吗？</h5> \n<p>存储过程包含用户定义的SQL语句集合，可以使用CALL语句调用存储过程，当然在存储 过程中也可以使用CALL语句调用其他存储过程，但是不能使用DROP语句删除其他存储过程。</p> \n<h5>26.存储过程的参数不要与数据表中的字段名相同。</h5> \n<p>在定义存储过程参数列表时，应注意把参数名与数据库表中的字段名区别开来，否则将出 现无法预期的结果。</p> \n<h5>27.存储过程的参数可以使用中文吗？</h5> \n<p>一般情况下，可能会出现存储过程中传入中文参数的情况，例如某个存储过程根据用户的 名字查找该用户的信息，传入的参数值可能是中文。这时需要在定义存储过程的时候，在后面加 上character set gbk,不然调用存储过程使用中文参数会出错，比如定义userInfo存储过程，代码 如下：</p> \n<pre><code>CREATE&nbsp;PROCEDURE&nbsp;useInfo(IN&nbsp;u_name&nbsp;VARCHAR(50)&nbsp;character&nbsp;set&nbsp;gbk,&nbsp;OUT&nbsp;u_age&nbsp;INT)</code></pre> \n<p><strong><em>1.两者的区别：28.MySQL中视图和表的区别以及联系是什么？</em></strong></p> \n<ul> \n <li>(1)视图是已经编译好的SQL语句，是基于SQL语句的结果集的可视化的表，而表不是。</li> \n <li>(2)视图没有实际的物理记录，而基本表有。</li> \n <li>(3)表是内容，视图是窗口。</li> \n <li>(4)表占用物理空间而视图不占用物理空间，视图只是逻辑概念的存在，表可以及时对它 进行修改，但视图只能用创建的语句来修改。</li> \n <li>(5)视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些SQL 语句的集合。从安全的角度来说，视图可以防止用户接触数据表，因而用户不知道表结构。</li> \n <li>(6)表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表。</li> \n <li>(7)视图的建立和删除只影响视图本身，不影响对应的基本表。</li> \n</ul> \n<p><strong><em>2.两者的联系：</em></strong></p> \n<ul> \n <li>视图（view)是在基本表之上建立的表，它的结构（即所定义的列）和内容（即所有记录） 都来自基本表，它依据基本表存在而存在。一个视图可以对应一个基本表，也</li> \n <li>可以对应多个基本 表。视图是基本表的抽象和在逻辑意义上建立的新关系。</li> \n</ul> \n<h5>29.使用触发器时须特别注意。</h5> \n<p>在使用触发器的时候需要注意，对于相同的表，相同的事件只能创建一个触发器，比如对 表account创建了一个BEFORE INSERT触发器，那么如果对表account再次创建一个BEFORE INSERT触发器，MySQL将会报错，此时，只可以在表account上创建AFTER INSERT或者 BEFORE UPDATE类型的触发器。灵活的运用触发器将为操作省去很多麻烦。</p> \n<h5>30.及时删除不再需要的触发器。</h5> \n<p>触发器定义之后，每次执行触发事件，都会激活触发器并执行触发器中的语句。如果需求 发生变化，而触发器没有进行相应的改变或者删除，则触发器仍然会执行旧的语句，从而会影响 新的数据的完整性。因此，要将不再使用的触发器及时删除。</p> \n<h5>31.应该使用哪种方法创建用户？</h5> \n<p>创建用户有几种方法：GRANT语句、CREATE USER语句和直接操作user表。一般情况， 最好使用GRANT或者CREATE USER语句，而不要直接将用户信息插入user表，因为user表中存储了全局级别的权限以及其他的账户信息，如果意外破坏了 user表中的记录，则可能会对 MySQL服务器造成很大影响。</p> \n<h5>32.mysqldump备份的文件只能在MySQL中使用吗？</h5> \n<p>mysqldump备份的文本文件实际是数据库的一个副本，使用该文件不仅可以在MySQL中恢 复数据库，而且通过对该文件的简单修改，可以使用该文件在SQL Server或者Sybase等其他数 据库中恢复数据库。这在某种程度上实现了数据库之间的迁移。</p> \n<h5>33.如何选择备份工具？</h5> \n<p>直接复制数据文件是最为直接、快速的备份方法，但缺点是基本上不能实现增量备份。备 份时必须确保没有使用这些表。如果在复制一个表的同时服务器正在修改它，则复制无效。备份 文件时，最好关闭服务器，然后重新启动服务器。为了保证数据的一致性，需要在备份文件前， 执行以下SQL语句：</p> \n<pre><code>CREATE&nbsp;PROCEDURE&nbsp;useInfo(IN&nbsp;u_name&nbsp;VARCHAR(50)&nbsp;character&nbsp;set&nbsp;gbk,&nbsp;OUT&nbsp;u_age&nbsp;INT)</code></pre> \n<p>目录下即可。mysqlhotcopy 是一个 PERL 程序，它使用 LOCK TABLES、FLUSH TABLES 和 cp 或 scp来快速备份数据库。它是备份数据库或单个表的最快的途径，但它只能运行在数据库文件所在的 机器上，并且mysqlhotcopy只能用于备份MyISAM表。mysqlhotcopy适合于小型数据库的备份， 数据量不大，可以使用mysqlhotcopy程序每天进行一次完全备份。mysqldump将数据表导成SQL脚本文件，在不同的MySQL版本之间升级时相对比较合适， 这也是最常用的备份方法。mysqldump比直接复制要慢些。也就是把内存中的数据都刷新到磁盘中，同时锁定数据表，以保证复制过程中不会有新的 数据写入。这种方法备份出来的数据恢复也很简单，直接复制回原来的数据库</p> \n<h5>34.平时应该打开哪些日志？</h5> \n<p>日志既会影响MySQL的性能，又会占用大量磁盘空间。因此，如果不必要，应尽可能少地 开启日志。根据不同的使用环境，可以考虑开启不同的日志。例如，在开发环境中优化查询效率 低的语句，可以开启慢查询日志；如果需要记录用户的所有查询操作，可以开启通用查询日志； 如果需要记录数据的变更，可以开启二进制日志；错误日志是默认开启的。</p> \n<h5>35.如何使用二进制日志？</h5> \n<p>二进制日志主要用来记录数据变更。如果需要记录数据库的变化，可以开启二进制日志。 基于二进制日志的特性，不仅可以用来进行数据恢复，还可用于数据复制。在数据库定期备份的 情况下，如果出现数据丢失，可以先用备份恢复大部分数据，然后使用二进制日志恢复最近备份 后变更的数据。在双机热备情况下，可以使用MySQL的二进制日志记录数据的变更，然后将变 更部分复制到备份服务器上。</p> \n<h5>36.如何使用慢查询日志？</h5> \n<p>慢查询日志主要用来记录查询时间较长的日志。在开发环境下，可以开启慢查询日志来记 录查询时间较长的查询语句，然后对这些语句进行优化。通过配long_query_time的值，可以灵活地掌握不同程度的慢查询语句。</p> \n<h5>37.是不是索引建立得越多越好？</h5> \n<p>合理的索引可以提高查询的速度，但不是索引越多越好。在执行插入语句的时候，MySQL 要为新插入的记录建立索引。所以过多的索引会导致插入操作变慢。原则上是只有查询用的字段 才建立索引。</p> \n<h5>38.如何使用查询缓冲区？</h5> \n<p>查询缓冲区可以提高查询的速度，但是这种方式只适合查询语句比较多、更新语句比较少 的情况。默认情况下查询缓冲区的大小为〇，也就是不可用。可以修改queiy_cache_size以调整 查询缓冲区大小；修改query_cache_type以调整查询缓冲区的类型。在my.ini中修改 query_cache_size 和 query_cache_type 的值如下所示：</p> \n<pre><code>[mysqld]\nquery_cache_size=&nbsp;512M&nbsp;\nquery_cache_type=&nbsp;1\nquery_cache_type=1</code></pre> \n<p>表示开启查询缓冲区。只有在查询语句中包含SQL_NO_CACHE关键字 时，才不会使用查询缓冲区。可以使用FLUSH QUERY CACHE语句来刷新缓冲区，清理查询缓 冲区中的碎片。</p>', 'https://segmentfault.com/img/remote/1460000022381428', 'c56940aa8b004dab84568e86900b2ee6', '1a77ff8ac4c54e58b5e6b22210cff64f,83f62facb3b943ffa8e46abd1ebc64d9,55723db96b9f4593bae02bc1e49f1e87,d7416e100af54eb7a4d9274b9a462240,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 16:48:57', '2020-04-16 16:48:57');
INSERT INTO `tb_recommend` VALUES ('abd4d23301b44fbe9fb9ccca7e5408a8', 'Python正则表达式，这一篇就够了！', '大多数编程语言的正则表达式设计都师从Perl，所以语法基本相似，不同的是每种语言都有自己的函数去支持正则，今天我们就来学习 Python中关于 正则表达式的函数。re模块主要定义了9个常量、12个函数、1个异常，每...', '<p>之前我们讲解了 <a href=\"https://segmentfault.com/a/1190000021787021\">正则表达式语法</a> 的起源、发展、流派、语法、引擎、优化等相关知识，今天我们主要来学习一下 <strong>正则表达式在 Python语言 中的应用</strong>！</p> \n<p>大多数编程语言的正则表达式设计都师从Perl，所以语法基本相似，不同的是每种语言都有自己的函数去支持正则，今天我们就来学习 Python中关于 正则表达式的函数。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242430\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>re模块主要定义了9个常量、12个函数、1个异常，每个常量和函数猪哥都会通过实际代码案例讲解，让大家能更直观的了解其作用！</p> \n<p>注：为避免出现代码格式错乱，猪哥尽量使用代码截图演示哦。</p> \n<h2>一、re模块简介</h2> \n<p>聊到Python正则表达式的支持，首先肯定会想到<code>re</code>库，这是一个Python处理文本的<strong>标准库</strong>。</p> \n<blockquote> \n <strong>标准库</strong>的意思表示这是一个\n <strong>Python内置模块</strong>，不需要额外下载，目前Python内置模块大概有300个。可以在这里查看Python所有的内置模块：\n <a href=\"https://docs.python.org/3/py-modindex.html#cap-r\" rel=\"nofollow noreferrer\">https://docs.python.org/3/py-...</a> \n</blockquote> \n<p>因为re是内置模块，所以不需要再下载，使用时直接引入即可：</p> \n<pre><code class=\"python\">import re</code></pre> \n<p>re模块官方文档：<a href=\"https://docs.python.org/zh-cn/3.8/library/re.html\" rel=\"nofollow noreferrer\">https://docs.python.org/zh-cn...</a><br>re模块库源码：<a href=\"https://github.com/python/cpython/blob/3.8/Lib/re.py\" rel=\"nofollow noreferrer\">https://github.com/python/cpy...</a></p> \n<h2>二、re模块常量</h2> \n<p>常量即表示不可更改的变量，一般用于做标记。</p> \n<p>re模块中有9个常量，常量的值都是int类型！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242436\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>上图我们可以看到，所有的常量都是在<strong>RegexFlag枚举类</strong>来实现，这是在Python 3.6做的改版。在Python 3.6以前版本是直接将常量写在re.py中，使用枚举的好处就是方便管理和使用！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242435\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>下面我们来快速学习这些常量的作用及如何使用他们，按常用度排序！</p> \n<h3>1. IGNORECASE</h3> \n<p><strong>语法：</strong> re.IGNORECASE 或简写为 re.I</p> \n<p><strong>作用：</strong> 进行忽略大小写匹配。</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242431\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>在默认匹配模式下<strong>大写字母B</strong>无法匹配<strong>小写字母b</strong>，而在 忽略大小写 模式下是可以的。</p> \n<h3>2. ASCII</h3> \n<p><strong>语法：</strong> re.ASCII 或简写为 re.A</p> \n<p><strong>作用：</strong> 顾名思义，ASCII表示ASCII码的意思，让 <code>\\w</code>, <code>\\W</code>, <code>\\b</code>, <code>\\B</code>, <code>\\d</code>, <code>\\D</code>, <code>\\s</code> 和 <code>\\S</code> 只匹配ASCII，而不是Unicode。</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242441\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>在默认匹配模式下<code>\\w+</code>匹配到了所有字符串，而在<strong>ASCII</strong>模式下，只匹配到了a、b、c（ASCII编码支持的字符）。</p> \n<p>注意：这只对字符串匹配模式有效，对字节匹配模式无效。</p> \n<h3>3. DOTALL</h3> \n<p><strong>语法：</strong> re.DOTALL 或简写为 re.S</p> \n<p><strong>作用：</strong> DOT表示<code>.</code>，ALL表示所有，连起来就是<code>.</code>匹配所有，包括换行符<code>\\n</code>。<strong>默认模式下<code>.</code>是不能匹配行符<code>\\n</code>的</strong>。</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242434\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>在默认匹配模式下<code>.</code>并没有匹配换行符<code>\\n</code>，而是将字符串分开匹配；而在<strong>re.DOTALL</strong>模式下，换行符<code>\\n</code>与字符串一起被匹配到。</p> \n<p>注意：<strong>默认匹配模式下<code>.</code>并不会匹配换行符<code>\\n</code></strong>。</p> \n<h3>4. MULTILINE</h3> \n<p><strong>语法：</strong> re.MULTILINE 或简写为 re.M</p> \n<p><strong>作用：</strong> 多行模式，当某字符串中有换行符<code>\\n</code>，默认模式下是不支持换行符特性的，比如：行开头 和 行结尾，而多行模式下是支持匹配行开头的。</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242433\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>正则表达式中<code>^</code>表示匹配行的开头，默认模式下它只能匹配字符串的开头；而在多行模式下，它还可以匹配 换行符<code>\\n</code>后面的字符。</p> \n<p>注意：正则语法中<code>^</code>匹配行开头、<code>\\A</code>匹配字符串开头，单行模式下它两效果一致，多行模式下<code>\\A</code>不能识别<code>\\n</code>。</p> \n<h3>5. VERBOSE</h3> \n<p><strong>语法：</strong> re.VERBOSE 或简写为 re.X</p> \n<p><strong>作用：</strong> 详细模式，可以在正则表达式中加注解！</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242442\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>默认模式下并不能识别正则表达式中的注释，而详细模式是可以识别的。</p> \n<p>当一个正则表达式十分复杂的时候，详细模式或许能为你提供另一种注释方式，但它不应该成为炫技的手段，建议谨慎考虑后使用！</p> \n<h3>6.LOCALE</h3> \n<p><strong>语法：</strong> re.LOCALE 或简写为 re.L </p> \n<p><strong>作用：</strong> 由当前语言区域决定 <code>\\w</code>, <code>\\W</code>, <code>\\b</code>, <code>\\B</code> 和大小写敏感匹配，这个标记只能对byte样式有效。<strong>这个标记官方已经不推荐使用</strong>，因为语言区域机制很不可靠，它一次只能处理一个 \"习惯”，而且只对8位字节有效。</p> \n<p><strong>注意：</strong> 由于这个标记官方已经不推荐使用，而且猪哥也没使用过，所以就不给出实际的案例！</p> \n<h3>7.UNICODE</h3> \n<p><strong>语法：</strong> re.UNICODE 或简写为 re.U</p> \n<p><strong>作用：</strong> 与 ASCII 模式类似，匹配unicode编码支持的字符，但是 Python 3 默认字符串已经是Unicode，所以有点冗余。</p> \n<h3>8. DEBUG</h3> \n<p><strong>语法：</strong> re.DEBUG </p> \n<p><strong>作用：</strong> 显示编译时的debug信息。</p> \n<p><strong>代码案例：</strong> <br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242443\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>虽然debug模式下确实会打印编译信息，但猪哥并不理解这是什么语言 以及表达的含义，<strong>希望了解的朋友能不吝赐教。</strong></p> \n<h3>9.TEMPLATE</h3> \n<p><strong>语法：</strong> re.TEMPLATE 或简写为 re.T</p> \n<p><strong>作用：</strong> 猪哥也没搞懂TEMPLATE的具体用处，源码注释中写着：disable backtracking(禁用回溯)，有了解的同学可以留言告知！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242432\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h3>10. 常量总结</h3> \n<ol> \n <li>9个常量中，前5个（IGNORECASE、ASCII、DOTALL、MULTILINE、VERBOSE）有用处，两个（LOCALE、UNICODE）官方不建议使用、两个（TEMPLATE、DEBUG）试验性功能，不能依赖。</li> \n <li>常量在re常用函数中都可以使用，查看源码可得知。<span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242444\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span> </li> \n <li>常量可叠加使用，因为常量值都是2的幂次方值，所以是可以叠加使用的，叠加时请使用 <code>|</code> 符号，请勿使用<code>+</code> 符号！<span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242445\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span> </li> \n</ol> \n<p>最后来一张思维导图总结一下re模块中的常量吧。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242438\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h2>三、re模块函数</h2> \n<p>re模块有12个函数，猪哥将以功能分类来讲解；这样更具有比较性，同时也方便记忆。</p> \n<h3>1.查找一个匹配项</h3> \n<p>查找并返回一个匹配项的函数有3个：<strong>search、match、fullmatch</strong>，他们的区别分别是：</p> \n<ol> \n <li> <strong>search：</strong> 查找任意位置的匹配项</li> \n <li> <strong>match：</strong> 必须从字符串开头匹配</li> \n <li> <strong>fullmatch：</strong> 整个字符串与正则完全匹配</li> \n</ol> \n<p>我们再来根据实际的代码案例比较：</p> \n<p><strong>案例1:</strong><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242437\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>案例1中<strong>search函数</strong>是在字符串中任意位置匹配，只要有符合正则表达式的字符串就匹配成功，其实有两个匹配项，但search函数值返回一个。</p> \n<p>而<strong>match函数</strong>是要从头开始匹配，而字符串开头多了个字母<code>a</code>，所以无法匹配，<strong>fullmatch函数</strong>需要完全相同，故也不匹配！</p> \n<p><strong>案例2:</strong><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242439\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>案例2删除了text最开头的字母a，这样<strong>match函数</strong>就可以匹配啦，而<strong>fullmatch函数</strong>依然不能完全匹配！</p> \n<p><strong>案例3:</strong><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242440\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>案例3中，我们只留下一段文字，并且与正则表达式一致；这时<strong>fullmatch函数</strong>终于可以匹配了。</p> \n<p><strong>完整案例：</strong><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242455\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><strong>注意：查找 一个匹配项 返回的都是一个匹配对象（Match）。</strong></p> \n<h3>2.查找多个匹配项</h3> \n<p>讲完查找一项，现在来看看查找多项吧，查找多项函数主要有：<strong>findall函数</strong> 与 <strong>finditer函数</strong>：</p> \n<ol> \n <li> <strong>findall：</strong> 从字符串任意位置查找，<strong>返回一个列表</strong> </li> \n <li> <strong>finditer</strong>：从字符串任意位置查找，<strong>返回一个迭代器</strong> </li> \n</ol> \n<p>两个方法基本类似，只不过一个是返回列表，一个是返回迭代器。我们知道列表是一次性生成在内存中，而迭代器是需要使用时一点一点生成出来的，内存使用更优。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242446\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>如果可能存在大量的匹配项的话，建议使用<strong>finditer函数</strong>，一般情况使用<strong>findall函数</strong>基本没啥影响。</p> \n<h3>3.分割</h3> \n<p><strong>re.split(pattern, string, maxsplit=0, flags=0)</strong> 函数：用 <strong>pattern</strong> 分开 string ， <strong>maxsplit</strong>表示最多进行分割次数， <strong>flags</strong>表示模式，就是上面我们讲解的常量！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242448\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><strong>注意：<code>str</code>模块也有一个 split函数 ，那这两个函数该怎么选呢？</strong><br>str.split函数功能简单，不支持正则分割，而re.split支持正则。</p> \n<p><strong>关于二者的速度如何？</strong> 猪哥实际测试一下，在相同数据量的情况下使用<code>re.split</code>函数与<code>str.split</code>函数<strong>执行次数</strong> 与 <strong>执行时间</strong> 对比图：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242447\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>通过上图对比发现，1000次循环以内<code>str.split</code>函数更快，而循环次数1000次以上后<code>re.split</code>函数明显更快，而且次数越多差距越大！</p> \n<p><strong>所以结论是：在 不需要正则支持 且 数据量和数次不多 的情况下使用<code>str.split</code>函数更合适，反之则使用<code>re.split</code>函数。</strong></p> \n<p>注：具体执行时间与测试数据有关！</p> \n<h3>4.替换</h3> \n<p>替换主要有<strong>sub函数</strong> 与 <strong>subn函数</strong>，他们功能类似！</p> \n<p>先来看看<strong>sub函数</strong>的用法：</p> \n<p><strong>re.sub(pattern, repl, string, count=0, flags=0)</strong> 函数参数讲解：repl替换掉string中被pattern匹配的字符， count表示最大替换次数，flags表示正则表达式的常量。</p> \n<p>值得注意的是：<strong>sub函数</strong>中的入参：<strong>repl替换内容既可以是字符串，也可以是一个函数哦！</strong> 如果repl为函数时，只能有一个入参：Match匹配对象。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242450\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p><strong>re.subn(pattern, repl, string, count=0, flags=0)</strong> 函数与 <strong>re.sub函数</strong> 功能一致，只不过返回一个元组 (字符串, 替换次数)。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242449\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h3>5.编译正则对象</h3> \n<p><strong>compile函数</strong> 与 <strong>template函数</strong> 将正则表达式的样式编译为一个 正则表达式对象 （正则对象Pattern），这个对象与re模块有同样的正则函数（后面我们会讲解Pattern正则对象）。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242451\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>而<strong>template函数</strong> 与 <strong>compile函数</strong> 类似，只不过是增加了我们之前说的<strong>re.TEMPLATE</strong> 模式，我们可以看看源码。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242452\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h3>6.其他</h3> \n<p><strong>re.escape(pattern)</strong> 可以转义正则表达式中具有特殊含义的字符，比如：<code>.</code> 或者 <code>*</code> ，举个实际的案例：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242453\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><strong>re.escape(pattern)</strong> 看似非常好用省去了我们自己加转义，但是使用它很容易出现转义错误的问题，所以并不建议使用它转义，<strong>而建议大家自己手动转义！</strong></p> \n<p><strong>re.purge()</strong> 函数作用就是清除 <strong>正则表达式缓存</strong>，具体有什么缓存呢？我们来看看源码就知道它背地里干了 什么：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242454\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>看方法大概是清除缓存吧，我们再来看看具体的案例：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242456\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>猪哥在两个案例之间使用了<strong>re.purge()</strong> 函数清除缓存，然后分别比较前后案例源码里面的缓存，看看是否有变化！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242457\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h3>7.总结</h3> \n<p>同样最后来一张思维导图总结一下re模块中的函数吧。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242459\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h2>四、re模块异常</h2> \n<p>re模块还包含了一个正则表达式的编译错误，当我们给出的<strong>正则表达式是一个无效的表达式</strong>（就是表达式本身有问题）时，就会raise一个异常！</p> \n<p>我们来看看具体的案例吧：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242458\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>上图案例中我们可以看到，在编写正则表达式中我们多写了一个括号，这导致执行结果报错；而且是在其他所有案例执行之前，所以说明是在正则表达式编译时期就报错了。</p> \n<p>注意：这个异常一定是 正则表达式 本身是无效的，与要匹配的字符串无关！</p> \n<h2>五、正则对象Pattern</h2> \n<p>关于<code>re</code>模块的常量、函数、异常我们都讲解完毕，但是完全有必要再讲讲<strong>正则对象Pattern</strong>。</p> \n<h3>1. 与re模块 函数一致</h3> \n<p>在<code>re</code>模块的函数中有一个重要的函数 <strong>compile函数</strong> ，这个函数可以预编译返回一个正则对象，此正则对象拥有与<code>re</code>模块相同的函数，我们来看看<strong>Pattern类</strong>的源码。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242460\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>既然是一致的，那到底该用<strong>re模块</strong> 还是 <strong>正则对象Pattern</strong> ？</p> \n<p>而且，有些同学可能看过<code>re</code>模块的源码，你会发现其实<strong>compile函数</strong> 与 其他 <strong>re函数</strong>（search、split、sub等等） 内部调用的是同一个函数，最终还是调用正则对象的函数！<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242461\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>也就是说下面 两种代码写法 底层实现 其实是一致的：</p> \n<pre><code class=\"python\"># re函数\nre.search(pattern, text)\n\n# 正则对象函数\ncompile = re.compile(pattern)\ncompile.search(text)</code></pre> \n<p>那还有必要使用<strong>compile函数</strong> 得到正则对象再去调用 <strong>search函数</strong> 吗？直接调用re.search 是不是就可以？</p> \n<h3>2. 官方文档怎么说</h3> \n<p>关于到底该用<strong>re模块</strong> 还是 <strong>正则对象Pattern</strong> ，官方文档是否有说明呢？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242463\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>官方文档推荐：<strong>在多次使用某个正则表达式时推荐使用正则对象Pattern</strong> 以增加复用性，因为通过 <strong>re.compile(pattern)</strong> 编译后的模块级函数会被缓存！</p> \n<h3>3. 实际测试又如何？</h3> \n<p>上面官方文档推荐我们在 <strong>多次使用某个正则表达式时使用正则对象</strong>，那实际情况真的是这样的吗？</p> \n<p>我们在实测一下吧</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242462\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>猪哥编写了两个函数，一个使用<strong>re.search函数</strong> 另一个使用 <strong>compile.search函数</strong> ，分别(不同时)循环执行<strong>count次</strong>(count从1-1万)，比较两者的耗时！</p> \n<p>得出的结果猪哥绘制成折线图：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242464\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>得出的结论是：100次循环以内两者的速度基本一致，当超出100次后，使用 <strong>正则对象Pattern</strong> 的函数 耗时明显更短，所以比<strong>re模块</strong> 要快！</p> \n<p>通过实际测试得知：Python 官方文档推荐 <strong>多次使用某个正则表达式时使用正则对象函数</strong> 基本属实！</p> \n<h2>六、注意事项</h2> \n<p>Python 正则表达式知识基本讲解完毕，最后稍微给大家提一提需要注意的点。</p> \n<h3>1.字节串 与 字符串</h3> \n<p>模式和被搜索的字符串既可以是 Unicode 字符串 (str) ，也可以是8位字节串 (bytes)。 但是，Unicode 字符串与8位字节串不能混用！</p> \n<h3>2.r 的作用</h3> \n<p>正则表达式使用反斜杠（\'\'）来表示特殊形式，或者把特殊字符转义成普通字符。 </p> \n<p>而反斜杠在普通的 Python 字符串里也有相同的作用，所以就产生了冲突。</p> \n<p>解决办法是对于正则表达式样式使用 Python 的原始字符串表示法；在带有 \'r\' 前缀的字符串字面值中，反斜杠不必做任何特殊处理。</p> \n<h3>3.正则查找函数 返回匹配对象</h3> \n<p>查找一个匹配项（search、match、fullmatch）的函数返回值都是一个 <strong>匹配对象Match</strong> ，需要通过<strong>match.group()</strong> 获取匹配值，这个很容易忘记。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022242465\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>另外还需要注意：<strong>match.group()</strong> 与<strong>match.groups()</strong> 函数的差别！</p> \n<h3>4.重复使用某个正则</h3> \n<p>如果要重复使用某个正则表达式，推荐先使用 <strong>re.compile(pattern)函数</strong> 返回一个正则对象，然后复用这个正则对象，这样会更快！</p> \n<h3>5.Python 正则面试</h3> \n<p>笔试可能会遇到需要使用Python正则表达式，不过不会太难的，大家只要记住那几个方法的区别，会正确使用，基本问题不大。</p>', 'https://segmentfault.com/img/remote/1460000022242430', '61cdf41d1e5e4f229b76f6a042e254b6', '43145b2d806a4c3e8bb30d20ef04d61b,91a1be3a7ac0413482742452c7613692,fe213d41bcb743e2840d8aa58cf48d3e', '0', '3', '1', '2020-04-16 16:47:20', '2020-04-16 16:47:20');
INSERT INTO `tb_recommend` VALUES ('acaf06b62b78489dbf46eba1422964b1', '第五期：如何通过知晓云生成带参数二维码', '作者：知晓云 - 小程序开发快人一步来源：知晓课堂 许多小程序开发者，都需要获取进入小程序不同页面的二维码：包括常见的四方形「QR 码」和微信推出的「小程序码」。 这时候，我们直接在小程序后台中获取到的二...', '<p>作者：<a href=\"https://cloud.minapp.com/?utm_source=segmentfault&amp;utm_medium=article_footer&amp;utm_term=\" rel=\"nofollow noreferrer\">知晓云</a> - 小程序开发快人一步<br>来源：知晓课堂</p> \n<p>许多小程序开发者，都需要获取进入小程序不同页面的二维码：包括常见的四方形「QR 码」和微信推出的「小程序码」。</p> \n<p>这时候，我们直接在小程序后台中获取到的二维码，就远远无法满足我们以上需求了。贴心的是，<strong>微信提供了「获取小程序二维码」的接口</strong>。</p> \n<p>通过这个接口，<strong>商家和开发者能够制作进入不同页面的小程序二维码，而不会限定扫码进入小程序主页</strong>。</p> \n<p>下面，我们就以某游戏资料库小程序的英雄详情页为例，展示这个接口的使用方法。</p> \n<h3>准备工作</h3> \n<p>首先，<strong>我们需要确保在小程序的</strong><code>app.json</code><strong>代码中，已经注册了相应的页面</strong>。</p> \n<p>在本例的设定中，我们就需要在<code>pages</code>里，将<code>pages/detail/hero/hero</code>这个页面注册进去。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383418\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>当然，相应目录下也需要有相应的页面文件，且你的小程序已经有已发布的线上版本。否则，用户扫码后，微信会提示出错。</p> \n<p><strong>接下来，我们需要到微信小程序后台，获取小程序的 AppSecret</strong>（如果已经获取，这一步可以跳过）。</p> \n<p>进入小程序后台，点击左侧「设置」，找到「开发设置」，我们就能找到 AppSecret 一项。点击「获取」或「重置」，扫码之后，网页就会显示新的 AppSecret。需要注意的是，如果你之前生成过新的 AppSecret，那么旧的 AppSecret 会随这个操作而失效。</p> \n<p><strong>开发者也需要记得妥善保管 AppSecret，尽可能保证 AppSecret 不会丢失、泄漏。</strong></p> \n<h3>获取二维码</h3> \n<p>有了小程序的 AppID 和 AppSecret，我们就能利用服务器，获取小程序的二维码了。在本例，我们通过模拟请求的方式，让大家了解这个接口的使用方法和原理。</p> \n<p>首先，<strong>我们要利用 AppID 和 AppSecret，获取 Access Token</strong>。</p> \n<p>这一步，我们请求的地址是<code>https://api.weixin.qq.com/cgi-bin/token</code>，你需要使用<code>GET</code>方法，传递你的 AppID 和 AppSecret。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383421\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>从结果中，我们可以得知：执行这个操作后，微信会给你返回一个 JSON 数据包。<strong>解析这个数据包，我们就可以获得 Access Token。</strong></p> \n<p>有了 Access Token，我们就可以获取不同的小程序二维码了。</p> \n<p><strong>微信提供了两个</strong><code>POST</code><strong>&nbsp;获取小程序二维码的接口。</strong>你可以根据你的业务需求，自由选择任一接口，获取相应的小程序二维码（<code>GET</code>参数中的<code>ACCESS_TOKEN</code>部分填入上一步我们获取到的 Access Token）。</p> \n<ul> \n <li>获取「小程序码」，可以使用这个接口：<p><code>https://api.weixin.qq.com/wxa/getwxacode?access_token=ACCESS_TOKEN</code></p> </li> \n <li>想要经典的「小程序二维码」，可以使用这个接口：<p><code>https://api.weixin.qq.com/cgi-bin/wxaapp/createwxaqrcode?access_token=ACCESS_TOKEN</code></p> </li> \n</ul> \n<p><code>POST</code><strong>请求体中，需要包含小程序的页面地址，以及传入小程序的参数。</strong>记住，这个页面必须要在小程序里的<code>app.json</code>进行注册。</p> \n<p>本例中，JSON 请求体如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383419\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>发送请求后，微信会直接返回一张制作好的「小程序码」。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022383420\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>现在，长按上图扫一扫，看看是不是到了指定页面了？</p> \n<h3>注意事项</h3> \n<p>除了我们文中举例的接口，微信还开放了另一个与二维码相关的接口，即&nbsp;wxacodeunlimit&nbsp;来获取小程序码。（数量不限；但无法携带参数）</p> \n<p><strong>微信将通过「获取小程序二维码」接口获取的二维码的数量限定在十万个</strong>，并且似乎并没有「注销以前生成的二维码」的功能和机制。</p> \n<p>所以，如果你有非常大量的小程序二维码生成需求，建议使用普通链接小程序的方式生成小程序码。如果需要使用微信提供的二维码生成接口生成<strong>带参数的小程序码</strong>，也要注意不要超过限额。</p> \n<h3>更便捷的方式</h3> \n<p>知晓云 JS SDK 将上面的实现过程进行了封装，一个接口就可以实现上文提到的三种获取方式（知晓云还会帮你存储管理 Access Token）。该接口为：</p> \n<p>wx.BaaS.getWXACode(type, params)</p> \n<p>接口中&nbsp;type&nbsp;的三种类型</p> \n<ul> \n <li>wxacode&nbsp;：获取小程序码，适用于需要的码数量较少的场景，生成的码永久有效，数量有限</li> \n <li>wxacodeunlimit：获取小程序码，适用于需要的码数量极多的业务场景，生成的码永久有效，数量暂无限制</li> \n <li>xaqrcode：获取小程序二维码，该接口生成的码永久有效，数量有限 <br> params 对应了微信获取二维码的参数，详情请查阅知晓云 SDK 文档</li> \n</ul> \n<p>注意，该接口不需要再传入 Access Token，但在调用前需要提前确保：</p> \n<ul> \n <li>在知晓云「设置」-&gt;SDK 页面中开启了 SDK 生成小程序码的权限</li> \n <li>知晓云「设置」-&gt;小程序页面中已经配置好了 AppID 和 AppSecret</li> \n</ul> \n<p><strong>PS：知晓云后台自带二维码生成功能，无需开发也能快速获取进入小程序不同页面的二维码。</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF46a\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<blockquote>\n <strong>相关阅读</strong>\n</blockquote> \n<p>第一期：<a href=\"https://segmentfault.com/a/1190000021767822\">快速实现图片爬虫</a><br>第二期：<a href=\"https://segmentfault.com/a/1190000021770283\">快速生成分享海报</a><br>第三期：<a href=\"https://segmentfault.com/a/1190000022146396\">处理微信卡券消息</a><br>第四期：<a href=\"https://segmentfault.com/a/1190000022160584\">自动回复客服消息</a></p> \n<p>关注「知晓云」公众号，点击菜单栏「知晓云」-「知晓课堂」，获取更多开发教程。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022146422\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p>', 'https://segmentfault.com/img/remote/1460000022383418', '1894b118d35d44cb8fe8009529c4154b', '63c4e1e7ec204b43a62065a3ced4c2ce,3b375646301546259a8fb29d74ae4447,15941dc0af92453481b8a0626f963283,f831bc1c03f94b4b9e49390a3a354a3e', '0', '3', '1', '2020-04-16 16:49:22', '2020-04-16 16:49:22');
INSERT INTO `tb_recommend` VALUES ('ad2a178634524759b81eca1ea3a6b0ec', 'GitHub 屏蔽微软工程师的开源项目，因存在伊朗外部贡献者？', '近日，微软 UX 首席工程师 Rob Eisenberg 在 Twitter 上抱怨，他创建的开源 JS 框架 Aurelia 被 GitHub 禁止访问。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbESA2\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>近日，微软 UX 首席工程师 Rob Eisenberg 在 Twitter 上抱怨，他创建的开源 JS 框架 Aurelia 被 GitHub 禁止访问。</p> \n<p>该事件发生后引起全球开发者的广泛关注，一是 GitHub 竟然连自己家的项目都封，还有一个原因就是，此次封禁的原因竞是因为项目包含伊朗的外部贡献者？</p> \n<h2>GitHub 高管回应：这是一次严重失误</h2> \n<p>发现项目被封禁后，该工程师向 GitHub 提起了申诉，并在社交媒体进行曝光抗议：</p> \n<blockquote>\n “因为我们有两名来自伊朗的外部贡献者（非 GH 组织成员），所以 GitHub 自动标记并封禁了账号。”\n</blockquote> \n<p>随着事件的发酵，该账号已被恢复使用，GitHub CEO Nat Friedman 和 COO Erica Brescia 也在社交媒体表示“这是一次严重失误”。</p> \n<p>Friedman 在 HackerNews 上回复表示，他们将进行调查确保不会再次发生。他解释说，如果一家公司在美国有业务，它们都必须遵守美国的贸易制裁规定。这包括了与美国银行基础设施的互动。因此将公司总部设在其它地方并没有帮助。</p> \n<p>根据美国的政策，GitHub 不能向被制裁国家提供商业性质的服务，但 Github 仍然向被制裁的伊朗、叙利亚和古巴等国提供了公开的软件代码库的访问。</p> \n<h2>GitHub：除非真正需要，否则我们不会删除您的任何内容</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbESCg\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>就在二月底，GitHub 发布了其 2019 年透明度报告，详细介绍了如何以及向谁披露用户信息，以及基于什么理由删除或阻止了内容。</p> \n<p>GitHub 政策高级经理 Abby Vollmer 表示，该组织赞成在平台上保留尽可能多的内容，而不是删除信息。GitHub 确实相信内容审核会引起自由表达的担忧。</p> \n<p>沃尔默说：“对内容删除政策保持透明，并尽可能严格地限制内容删除，这是联合国言论自由专家对平台的建议，这些平台旨在 促进在线内容审核中的自由表达。”</p> \n<p>“在GitHub，我们都做到了。”</p> \n<p>但从这件事情来说，GitHub 真的做到了么...</p> \n<blockquote>\n 拓展阅读： \n <br>\n <a href=\"https://segmentfault.com/a/1190000021842599\">GitHub：除非真正需要，否则我们不会删除您的任何内容</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCLmI\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbESA2', 'f53014d680884163a5bd5ce762e90cdf', '634b81d655c74cb0adc4d0aa362b8819,9d5eb002705648e2bc3d345fa34a8191,f3eb17e6e5664a97af3e9b1fca12b286', '0', '3', '1', '2020-04-16 16:59:34', '2020-04-16 16:59:34');
INSERT INTO `tb_recommend` VALUES ('ad5163782f44476d8ab550a06c58814f', 'IOT、AI、云计算等融合技术推进制造业产业转型', '3月31日，BoCloud博云、京东智联云、海尔集团联手，以“制造”到“智造”为主题，进行了IT赋能企业数字化转型实践分享。博云售前解决方案架构师尹贺杰，京东云与AI企业云业务部高级业务技术经理吴世超，海尔集团智能...', '<blockquote>\n 3月31日，BoCloud博云、京东智联云、海尔集团联手，以“制造”到“智造”为主题，进行了IT赋能企业数字化转型实践分享。\n <br>博云售前解决方案架构师尹贺杰，京东云与AI企业云业务部高级业务技术经理吴世超，海尔集团智能制造产业技术总监亢晓飞三位制造业转型专家，分别从传统制造业互联网化改造、工业制造业融合技术和工业互联网制造企业转型等多个角度进行了实践及案例分享。我们将分三期，分别回顾活动中的精彩内容。\n <br>本期内容，我们将回顾京东云与AI企业云业务部高级业务技术经理吴世超，讲解京东智联云如何通过物联网技术、AI技术及云平台帮助用户实现数字化及智能化转型。\n</blockquote> \n<p>通过新技术提升制造业全要素生产率，成为优化经济结构、驱动传统产业转型升级的国家战略。以物联网、云计算、AI为代表的新一代信息技术，为传统行业，特别是制造业升级转型赋能，成为制造业释放数字能力，探索智能创新的战略化手段。而京东智联云，围绕客户，利用云计算、大数据、物联网和人工智能等新的IT技术，通过企业商业模式创新、客户体验再造、业务流程重构和组织机构重组，以实现企业的发展和转型。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321566\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<ul> \n <li> <strong>智能平台</strong>：建设人工智能能力中台，利用计算机视觉、语音及声 学、机器学习、深度学习、知识图谱等能力助力企业快速进入AI时代。</li> \n <li> <strong>IOT平台</strong>：平台提供安全可靠的设备连接通信能力与管理能力，将海量设备数据采集，同时提供了设备数据转发，设备存储，帮助应用快速集成。</li> \n <li> <strong>云平台</strong>：提供可靠、安全、易于管理的云服务，支撑上层实现高聚合、松耦合、数据高可用、资源易集成等，再结合微服务方式，将企业核心业务下沉至基础设施中，基于前后端分离的模式，为企业打造敏捷集成、自动化运维的共享平台。</li> \n</ul> \n<h3>AIoT软硬一体</h3> \n<h3>打造面向全场景的万物智联解决方案</h3> \n<p>在数字化进程中， 制造业企业首先需要解决数字接入能力，京东物联网平台包含To C和To B两方面，包括智能家居、智能车联、工业物联、智能地产、智能园区、门店科技六大场景服务，利用云技术、物流、商城等成熟、丰富的技术能力打造全场景IOT服务场景。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321569\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>京东智联云工业物联网平台包含四个理念：</p> \n<p>1.<strong>全息的感知</strong>：实现从感知、采集、分析、应用，全设备、全链路、全业务的贯通。<br>2.<strong>泛在的连接</strong>：建立设备层、平台侧、用户侧、合作伙伴的泛在的连接生态。<br>3.<strong>开放共享</strong>：打造数据共享平台，同时打造能力开放行业的新业态。<br>4.<strong>融合创新</strong>：融合京东智联云、京东大数据、京东物流、京东AI等相关能力，赋能制造行业智能化发展。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321565\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>通过这四个理念，京东智联云能够将制造业企业设备、数据、流程进行整合，实现数字生态中人、设备、数据的互联与交互，为企业通过数字化技术开发新技术与产品提供数字基础。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321567\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>京东物联管理平台主要有以下技术特点：</p> \n<ul> \n <li> <strong>设备接入</strong>：接入设备品类超过200个，有丰富的物模型管理经验。接入适配层，多协议支持，支持动态数据转换、多种设备配网方案，显著提升了设备接入效率。</li> \n <li> <strong>连接规模</strong>：京东物联平台发展已近5年，已连接设备量级过亿，系统有丰富的百万级高并发处理经验。平台的稳定性和高性能得到过真实检验。</li> \n <li> <strong>松耦合性</strong>：与云平台松耦合，可以快速部署在各类云服务平台之上。物管平台模块间的松耦合，包括平台后台和边缘节点之间，平台后台数据处理组件和设备管理组件之间。</li> \n <li> <strong>开放性</strong>：京东物联管理平台南向具备很强的灵活性，对边缘框架的接入持有开放的态度，支持不同边缘框架的适配接入。北向支持按电力业务场景定制接口。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321568\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><em>京东物联中台在国家电网中的应用</em></p> \n<h3>京东AI</h3> \n<h3>清晰全面的人工智能战略布局</h3> \n<p>京东AI基于语音声学、语义、知识图谱、对话、计算机视觉、机器学习这六大能力，针对行业客户提供AI支持与能力。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321570\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>基于六项核心技术，能够为客户提供人工智能开发与训练平台，为开发人员提供研发环境及工具，结合自身业务进行相关的AI应用探索。京东AI拥有四十余项久经考验的通用API，直接能够为业务使用。客服、零售、市政、医疗四大场景，京东智联云产品及解决方案结合实际业务场景，帮助业务提升的能力。</p> \n<h3>京东智联云</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321573\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><em>制造业场景典型云平台架构</em></p> \n<p>在制造行业中，为了保护自身企业数据安全，用户更倾向于使用私有云或专有云平台。为了结合客户实际需求，京东智联云为客户提供了既能保障本地数据安全的私有云方案和同时能够利用京东AI、大数据等线上能力的混合云架构两种方案。</p> \n<p>与生产业务强相关、对数据时效性要求较高的业务系统部署在本地的专有云上，与外界进行物理隔离，保障企业数据安全；本地基础的应用，如物联网平台、私有云平台、生产应用平台则部署在本地的平台。同时搭建了混合云架构，在公有云上做本地数据云上的灾备和冷备，用户可以使用AI、大数据等技术来进行分析和处理，提升生产力、降低能耗，降低整体建设成本。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321572\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p>京东智联云的专有云平台 JD Cloud Stack 产品，是汇聚了京东在云计算和大数据领域多年技术积累的核心成果之一，包含60 多个云计算平台资源产品，涵盖基础资源、弹性计算、网络、 存储、数据库与缓存、互联网中间件、大数据、混合云、安全、网络流量接入、用户接入、后台管理平台、运维工具等各个层次，并通过统一的 JD Cloud Stack 服务目录向用户提供IaaS、PaaS、SaaS、DaaS、 AIaaS 等通用和定制化的云计算服务。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321571\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><em>JD Cloud Mesh 多云管理</em></p> \n<p><strong>京东智联云安全保护体系</strong></p> \n<p>数据安全保护体系是以合规监管要求和用户业务需求为输入，结合数据安全在人员组织、制度流程、技术保障的执行要求，通过技术工具的使用，贯穿整个数据全生命周期过程域的安全能力建设。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321574\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<p><strong>点击“<a href=\"https://www.jdcloud.com/cn/products/jdstack?utm_source=PMM_Segmentfault&amp;utm_medium=ReadMore_235&amp;utm_campaign=ReadMore&amp;utm_term=NA\" rel=\"nofollow noreferrer\">阅读</a>”了解京东智联云JDStack 专有云！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321575\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Alt\" title=\"Alt\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022321576\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Alt\" title=\"Alt\"></span></p>', 'https://segmentfault.com/img/remote/1460000022321566', '692c6787030d4b8882077b2ab9279c52', 'e80d97c3472e428dabdaf417adac7a3c,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-16 16:56:35', '2020-04-16 16:56:35');
INSERT INTO `tb_recommend` VALUES ('ad6176b33c944e5dbefae55e88d06927', 'React 16.8.6 版本存在内存泄露', '发现这个React 内存泄露问题是某一天的晚上一直开着直播页，直播页用的 react 版本是 16.8.6，到了早上跳到这个页面的时候，控制台有点卡，怀疑是有内存泄露，于是就开始分析这个直播页面。', '<blockquote>\n 发现这个React 内存泄露问题是某一天的晚上一直开着直播页，直播页用的 react 版本是 16.8.6，到了早上跳到这个页面的时候，控制台有点卡，怀疑是有内存泄露，于是就开始分析这个直播页面。\n</blockquote> \n<h3>分析</h3> \n<p>打开控制台 <code>performance</code> 面板点击开始录制，如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391867\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>从上图可以发现在这时间内， nodes 节点一直在增长，很有可能发生了内存泄露。</p> \n<p>我们来到 <code>memory</code> 面板分析内存变化:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391866\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<blockquote>\n 注：上图的蓝色线条表示在时间轴的最后该对象依旧存在，灰色线条则说明对象在时间轴内被分配，但是已经被gc(垃圾回收)了。\n</blockquote> \n<p>上图都是点击 gc 再进行记录的，但是上图还有很多蓝色线条，而且内存一直往上涨，很明显的内存泄露问题，那会是什么导致内存泄露的呢？</p> \n<p>很快发现这里有个 bi 的东西居然占了 31%的大小：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391868\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这个 bi 是用来干嘛的？展开 bi ，鼠标悬浮在 bi 某处：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391870\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>发现这个节点是直播间里的进房消息，里面是 react 存的 <code>FiberNode</code> 节点，观察了一下里面这些 bi 基本上都是消息元素。</p> \n<p>选择 <code>summary</code>，选出<code>Detached</code> （分离）的元素：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391871\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><code>Detached HTMLDivElement</code> 居然有41429个，展开，鼠标悬浮：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391869\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>还是消息信息，说明是这个导致 bi 增加的。我们继续展开：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391872\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>从上图看 react 会保留消息的上下兄弟节点的引用，而且保留的引用层级有点深，各个节点嵌套依赖，导致一直存在内存里：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391873\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>仔细查下了项目消息相关代码，发现并不会存在有内存泄露的操作。这里简单说下渲染消息的逻辑，消息有进房消息，聊天消息，礼物消息等等，消息展示会根据 messages 数组里面的类型去渲染不同的消息。messages 数组不会无限增长，控制在 100 个，超过就删掉第一个元素，保证维持100个元素渲染消息，但是从上图来看，这些分离的元素并没有被 react 完全删除，还保存在内存里，查了下 React 的 Issue，并查了相关文章，发现有不少人遇到这个问题：</p> \n<ul> \n <li><a href=\"https://github.com/facebook/react/issues/16138\" rel=\"nofollow noreferrer\">https://github.com/facebook/r...</a></li> \n <li><a href=\"https://github.com/facebook/react/issues/14732\" rel=\"nofollow noreferrer\">https://github.com/facebook/r...</a></li> \n <li><a href=\"https://github.com/facebook/react/issues/18116\" rel=\"nofollow noreferrer\">https://github.com/facebook/r...</a></li> \n <li><a href=\"https://blog.discordapp.com/discord-react-memory-leak-565c89763e8\" rel=\"nofollow noreferrer\">Investigating Discord’s React Memory Leak - Discord Blog</a></li> \n</ul> \n<p>React 核心成员 Dan 给出的解决办法是升级到 16.9.0。</p> \n<p>这里将项目 React 和 React-dom 版本升级16.9.0，<br>发现 FiberNode 节点还是会一直增加。。。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391875\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391874\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>继续查看Issue 发现，React 版本 <code>0.0.0-241c4467e</code> 修复了这个问题。<br><a href=\"https://github.com/facebook/react/issues/18066\" rel=\"nofollow noreferrer\">Bug: Detached DOM node memory leak · Issue #18066 · facebook/react · GitHub</a></p> \n<p>这个版本的 mr 已经合并在 React master 上<br><a href=\"https://github.com/facebook/react/pull/17666\" rel=\"nofollow noreferrer\">Null stateNode after unmount by bvaughn · Pull Request #17666 · facebook/react · GitHub</a></p> \n<p>这个 mr 是 2019 年 12 月 20 号合并的，2019 年 12 月 20 号之后的版本是 16.13.0，这里将项目直接升级到 16.13.1，然后查看 node 节点：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391877\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>发现 node 节点可以降下来了，查看 <code>memory</code> 面板：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391876\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>对比<code>Snapshot 5</code>，分离的元素没有新增，说明这个版本基本修复了这个问题。</p> \n<h3>结论</h3> \n<p>React <strong>16.8.6</strong> (<strong>16.2.5到16.12.0</strong> 可能会有，这些版本没有验证，但是 issue 里面有人遇到）的版本会存在内存泄露问题，建议升级 React 到 <strong>16.13.0</strong> 以上。</p>', 'https://segmentfault.com/img/remote/1460000022391867', 'f53014d680884163a5bd5ce762e90cdf', 'e0a1c37357374c5b81385440f46da50d,224db6e7ee264d868ecd07eba961eb6f,63c4e1e7ec204b43a62065a3ced4c2ce,d79254c4ca5e45dca9d484307c935281', '0', '3', '1', '2020-04-16 16:48:00', '2020-04-16 16:48:00');
INSERT INTO `tb_recommend` VALUES ('b26596ba04ab4a2e945f8027b94fa96e', '亚马逊工人罢工快递延误，谷歌无人机送货却业绩翻倍', '导读：无人机配送早在几年前就已实现，不过近期 ，它的存在显得尤为重要。随着美国疫情形势愈加严峻，多州颁布「居家令」。当出门购物已经成为奢侈的事情之时，无人机出场，为人们配送药物与食品，可谓雪中送炭。', '<blockquote>\n 导读：无人机配送早在几年前就已实现，不过近期 ，它的存在显得尤为重要。随着美国疫情形势愈加严峻，多州颁布「居家令」。当出门购物已经成为奢侈的事情之时，无人机出场，为人们配送药物与食品，可谓雪中送炭。\n</blockquote> \n<p>今年的新冠病毒全球大流行，让我们更加依赖于网购。但面对网购订单的激增，配送人员的紧缺和安全防护措施的缺乏，各电商平台的物流工作也迎来了巨大的考验。</p> \n<p>此前，在国内抗疫过程中，无人配送车、配送机器人在医院、隔离酒店等危险场所，解决了「最后一公里」的配送问题。</p> \n<p>在美国，谷歌旗下的 Wing 无人机也于近期开始大规模进军物流配送业，并取得了相当不错的成绩。</p> \n<h2>亚马逊工人罢工，物流配送遭差评</h2> \n<p>亚马逊也许没想到，网购需求的激增竟然给了他们一个措手不及。</p> \n<p>3 月末，亚马逊配送中心的员工称，因为配送过程中也无法保持安全距离，担心感染病毒，亚马逊史丹顿岛仓库部分员工举行了罢工。他们要求公司关闭仓库，并对其进行清洁和消毒。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXop\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"60ccf25ce6a79420777bf198f2d62355.jpg\" title=\"60ccf25ce6a79420777bf198f2d62355.jpg\"></span></p> \n<ul>\n <li><em>工人要求公司加强对他们的安全防护并涨薪</em></li>\n</ul> \n<p>订单激增遇上工人罢工、交付延误，亚马逊境况不容乐观。一向被认为是服务与物流典范的亚马逊，在快递方面遭到了差评。</p> \n<p>用户们反映，「两天送达」感觉更像是「某天送达」，还有许多物品似乎变成了永久「不可购买」。网购的准时性已经完全失去了保障。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXow\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"57ff01d8da536745fde3f079f36be777.jpg\" title=\"57ff01d8da536745fde3f079f36be777.jpg\"></span></p> \n<ul>\n <li><em>亚马逊快递的延误，逼得网友想直接去商店购买</em></li>\n</ul> \n<p>这种情形下，无人机配送也许能够破解目前电商平台所面临的配送难题。</p> \n<h2>美国 ：无人机送货，店家业绩反超平时</h2> \n<p>早在 2014 年，谷歌的 X 部门的项目 Project Wing，便首次推出无人机送货服务，去年年底获得美国联邦航空管理局的认证。</p> \n<p>其第一次飞行是在澳大利亚昆士兰州进行，自那以后，Wing 已经进行了数万次试飞。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXoz\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"e49906b165b6111af05dfb15123be326.jpg\" title=\"e49906b165b6111af05dfb15123be326.jpg\"></span></p> \n<ul>\n <li><em>Wing 首次测试选择在澳大利亚昆士兰州向民宅运送药品和食物等</em></li>\n</ul> \n<p>尽管如此，之前的无人机送货似乎一直都不温不火。而这次疫情，Wing 派上了大用场，业务量增长翻倍。</p> \n<p>谷歌母公司 Alphabet 旗下子公司 Wing 称，使用无人机配送服务的客户数量急剧增加，其 Wing 无人机在过去两周内，完成了超过 1000 次送货服务，主要运送食物和药品。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXoF\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"fee39798e3edc3349667450306e6139a.jpg\" title=\"fee39798e3edc3349667450306e6139a.jpg\"></span></p> \n<ul>\n <li><em>为避免接触，无人机配送服务开始流行</em></li>\n</ul> \n<p>Wing 公司发言人 Jonathan Bass 表示：「我们正努力支持那些近期没办法开门的当地企业，把产品直接送到顾客家里。」</p> \n<p>他还补充说，「虽然无人机的有效载荷是有限的，但用无人机送货的话，订单在几分钟内就可以完成。」</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXoG\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"5b02c43e951b8896506e0dce9cf2c0e5.jpg\" title=\"5b02c43e951b8896506e0dce9cf2c0e5.jpg\"></span></p> \n<ul> \n <li>*无人机正在弗吉尼亚州的一户人家交付包裹</li> \n <li>*</li> \n</ul> \n<p>用无人机配送之后，店家的销售业绩反而超过了平时。一家咖啡店 Mockingbird Cafe 在与 Wing 合作的第一个周末，通过 Wing 的无人机售出的糕点比平时在店内销售的多 50%。</p> \n<p>因此，亚马逊、联合包裹服务公司（United Parcel Service）和许多小型企业也都开始尝试无人机交付。</p> \n<h2>日本：无人机配送海鲜当日达</h2> \n<p>在日本，也同样出现了无人机送货的身影。不同于美国的是，日本的无人机配送的是当地的食材担当——海鲜。</p> \n<p>即使在新冠肺炎流行期间，海鲜在日本依然没有失去它的重要地位。为了让顾客们及时吃到最新鲜的海鲜，雅马哈公司和日本航空现在正在研究使用无人机进行当日达海鲜配送服务。</p> \n<p>这两家公司的员工于 2 月份在日本五岛列岛进行了一次实地测试。该位置属于日本长崎县，位于东京以西约 1000 公里。</p> \n<p>测试开始于中通岛的上京机场，他们将新鲜捕获的 20 公斤的长牙石斑鱼等装进一个保温箱，然后吊在一架雅马哈 Fazer R G2 无人驾驶直升机下面。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFXoI\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"adb10c0dc892db2a679999f74757d37a.jpg\" title=\"adb10c0dc892db2a679999f74757d37a.jpg\"></span></p> \n<ul>\n <li><em>Fazer R G2 无人直升机载着刚捕捞的海鲜向目的地飞去</em></li>\n</ul> \n<p>Fazer R G2 是为用户视线之外的自主飞行而设计的，它由四冲程燃油喷射发动机驱动，可在高达 2800 米的高度上携带 35 千克的最大有效载荷。</p> \n<p>该无人机随后起飞，飞行约 35 公里，飞往九州岛上的 Saikai。到达目的地后，箱子被此处的员工从无人机上取下，装上日本航空公司的商业航班，于当天抵达东京的一家餐厅。</p> \n<p>这架直升机在 100 米的高度飞行，大约 40 分钟就完成了从中通岛到九州的行程。</p> \n<p>相比之下，乘坐汽车和渡轮完成同样的行程，要花近 3 个小时。</p> \n<p>无人机的起飞和降落，都由地面工作人员通过无线电遥控操作。雅马哈公司无人驾驶系统办公室的人员，通过卫星转播的视频和其他数据来监控无人机的飞行进度。</p> \n<p>就以上案例看来，无人机配送从效率和安全健康方面都超过了人力配送，但是，无人机的有效载荷、续航时间方面的限制，以及对运输场地空旷度的要求等，仍然是未来需要解决的。</p>', 'https://segmentfault.com/img/bVbFXop', '1c5851dc916d4e70a60f0c957f548876', 'cfd640a90e5f4fa7b713a1afcedf12cf,4a80ddea758b47c990fb8b276d19a350', '0', '3', '1', '2020-04-16 16:55:38', '2020-04-16 16:55:38');
INSERT INTO `tb_recommend` VALUES ('b266658e741b4c20bd2761363849b84e', 'OUT 啦！你的 App 还不支持一键登录吗？', '在用户使用 App、网站、产品客户端时，是否对于登陆信息的反复输入感到厌烦？在用户查看信息、打开问卷、收取资源时，是否因为条条框框输入注册信息而放弃使用？在企业上新产品，宣传推广，迎接新用户时，是否面...', '<p>在用户使用 App、网站、产品客户端时，是否对于登陆信息的反复输入感到厌烦？<br>在用户查看信息、打开问卷、收取资源时，是否因为条条框框输入注册信息而放弃使用？<br>在企业上新产品，宣传推广，迎接新用户时，是否面临过因用户烦于注册而流失的情况？<br>个人账号的逐渐增多，实名认证的加强推广让登陆界面频频出现在大家生活中，而操作登陆和注册也成为了使用互联网的一环。</p> \n<h2>常见的登陆/注册方式</h2> \n<p><strong>账号密码模式</strong></p> \n<p>论起最基础也是最常见的登陆注册方式，毫无疑问是账号密码模式了。<br>作为最传统且一直到今天仍在广泛使用的方法，它毫无疑问是简单粗暴且有效的。虽然它也是导致重复输入引起烦躁，从而放弃使用的本源。<br>这个模式的必要点就是账号和密码的记忆，一旦忘记就会导致无法登陆。而且从安全角度看可能会出现为了便于记忆在多个平台使用同一套账号密码，从而降低了安全性。如果有一个平台出现信息泄露，将会威胁到其他平台的内容安全。</p> \n<p><strong>短信验证模式</strong></p> \n<p>在手机实名制后，因为一人一号的基础，衍生出了手机、验证码动态登陆注册模式。相比账号密码模式，它可以有效的避免重复注册，且不再需要记忆账号密码。<br>该模式是在你登陆注册时，输入手机号，然后获取验证码，等待收取验证码后再进行验证码填写。在这个过程中使用者收取验证短信会受到运营商网络的影响，而且验证短信也会面临是否屏蔽等无法接受的情况。更甚至因为丢失手机号，或者更换手机号后会无法登陆。</p> \n<p><strong>一键登录模式</strong></p> \n<p>虽然短信验证模式依然有部分缺陷，但是我们也可以看到这些缺点主要集中在短信验证码的收发上。相比需要记忆账号密码的模式已经无疑有了很大进步。<br>那么有没有一种方法可以去掉或者减少因为运营商网络所导致的收发短信问题，从而使登陆注册更加方便呢？<br>一键登录完全符合了这个需求。</p> \n<h2>一键登录就是这么优秀</h2> \n<p>所谓一键登录，是指在登陆注册时依托运营商的移动数据网络，采用“通信网关取号”及 SIM 卡识别等技术，不需要通过收发验证码，而是App自动获取当前手机的手机号，然后直接使用该号码进行登陆。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022328439\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>相比传统登陆方式，一键登录有以下 4 个优点：</p> \n<ul> \n <li>帮助用户节省手动输入账号和密码的时间，减少用户操作步骤，提升用户体验；</li> \n <li>取消账号密码，无需记忆，也不用担心密码泄露导致的安全问题</li> \n <li>取消收发及输入验证码过程，节省短信费用，也减少了等待验证码的时间</li> \n <li>3 秒内完成登陆注册流程，有效避免因注册/登陆的繁琐流程而使用户流失</li> \n</ul> \n<h2>快速接入一键登录</h2> \n<p>既然是这么方便的功能，那为什么现在还没有完全推广开来呢？<br>因为使用一键登录需要接入三大运营商，而运营商是否开放相关服务则成了关键。<br>那么现在就有了一个好消息，最近三大运营商有了自己的开放平台，而且还使用了同一套授权程序，只需要接入接口就可以使用了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022328438\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>现在又拍云刚好可以为大家提供一键登录接入功能，依托于又拍云的亿级推送业务技术构架，可以轻松应对高并发。并且封装了完善的SDK，直接调用就可以接入，开启一键登录功能。同时又拍云还贴心地提供了授权界面自定义功能，企业可自定义配置授权页面，保证产品界面的美观统一。<br>一键登录作为一种能够明显减少身份校验带来的麻烦，提升账户安全性，而且更为便捷的登陆注册模式，在今后互联网用户身份认证里肯定能够占据重要地位，值得开发者们在选择身份认证上的考虑！</p> \n<h6>推荐阅读</h6> \n<p><a href=\"https://www.upyun.com/tech/article/536/%E6%97%A0%E9%9C%80%E9%A2%9D%E5%A4%96%E5%B7%A5%E5%85%B7%EF%BC%8C%E5%8F%88%E5%B0%8F%E6%8B%8D%E7%9A%84%E7%AE%80%E5%8D%95%E6%8A%93%E5%8C%85%E6%95%99%E7%A8%8B.html\" rel=\"nofollow noreferrer\">无需额外工具，又小拍的简单抓包教程</a></p> \n<p><a href=\"https://www.upyun.com/tech/article/526/%E5%A4%A7%E5%AE%B6%E9%83%BD%E5%9C%A8%E8%AF%B4%E7%9A%84%E4%BA%91%E5%AE%89%E5%85%A8%EF%BC%8C%E5%88%B0%E5%BA%95%E6%98%AF%E6%80%8E%E4%B9%88%E5%9B%9E%E4%BA%8B%EF%BC%9F.html\" rel=\"nofollow noreferrer\">大家都在说的云安全，到底是怎么回事？</a></p>', 'https://segmentfault.com/img/remote/1460000022328439', 'f53014d680884163a5bd5ce762e90cdf', 'cc944f24ed5e4383a975481674f255e0,60e459d5028e400894856f94e826804c,63c4e1e7ec204b43a62065a3ced4c2ce,2a09bf1afefd4d659606f43445741ee3', '0', '3', '1', '2020-04-16 16:56:34', '2020-04-16 16:56:34');
INSERT INTO `tb_recommend` VALUES ('b2f1a8e0d797428f80d76bef05cdc3a3', '手摸手带你走近git', '本文主要介绍git 密钥生成与配置，基础命令包括clone、add、commit、pull、push等，冲突处理，查看并回退历史版本，以及提交规范等。', '<h1>前言</h1> \n<p>&nbsp;&nbsp;本文主要介绍<code>git</code> 密钥生成与配置，基础命令包括<code>clone</code>、<code>add</code>、<code>commit</code>、<code>pull</code>、<code>push</code>等，冲突处理，查看并回退历史版本，以及提交规范等。</p> \n<h1>密钥生成与配置</h1> \n<ul>\n <li>配置用户名和邮箱</li>\n</ul> \n<pre><code>//打开git bash 输入以下命令\n\n//用户名，填你的名字全称 如：yaoxfly 方便识别\ngit config --global  user.name \'yaoxfly\'\n//邮箱,填你的常用邮箱，代码出错时会发邮件通知你\ngit config --global  user.email  \'123@qq.com\'</code></pre> \n<ul>\n <li>生成私钥和公钥</li>\n</ul> \n<pre><code>ssh-keygen -t rsa 并按回车3下</code></pre> \n<blockquote>\n tips:为什么按三下，是因为有提示你是否需要设置密码，如果设置了每次使用git都会用到密码，一般都是直接不写为空，直接回车就好了.\n</blockquote> \n<ul>\n <li>私钥和公钥文件名和生成路径</li>\n</ul> \n<p>&nbsp;&nbsp;私钥:<code>id_rsa</code>，公钥:<code>id_rsa.pub</code><br>默认文件夹在你打开<code>git bash</code>的目录，或者在你的用户目录<code>~/.ssh</code>文件夹下</p> \n<ul>\n <li>配置</li>\n</ul> \n<p>复制<code>id_rsa.pub</code>文件里的所有内容粘贴到需要地方，比如<code>github</code>或码云的公钥配置上</p> \n<blockquote>\n tips: 在生成\n <code>key</code>之前 \n <code>git config --global</code> 姓名和邮箱一定要设置， 否则每次操作都要填写用户名和密码，不要在秘钥上设置密码，直接下一步就好。\n</blockquote> \n<h1>基础</h1> \n<h4>clone(克融项目)</h4> \n<pre><code>git clone  \'xxxx\'</code></pre> \n<h4>add(新增文件)</h4> \n<pre><code>git add .  // 匹配所有的文件, 提交被修改的和新建的文件，但不包括被删除的文件 \ngit add -u  // update tracked files  更新所有改变的文件,将修改的文件提交到暂存区。 \ngit add -A  // 是上面两个功能的合集(git add --all的缩写)</code></pre> \n<h4>commit(提交)</h4> \n<ul>\n <li>提交</li>\n</ul> \n<pre><code>git commit -m  \"添加你的注释,一般是一些更改信息\"</code></pre> \n<ul>\n <li>撤回提交</li>\n</ul> \n<pre><code>//仅仅是撤回commit操作，您写的代码仍然保留\ngit reset --soft HEAD^  </code></pre> \n<h4>push (远程提交)</h4> \n<ul>\n <li>提交</li>\n</ul> \n<pre><code>git push origin master:master  </code></pre> \n<ul>\n <li> <code>fatal: refusing to merge unrelated histories</code> 拒绝合并不相关的历史解决方式,强制提交</li>\n</ul> \n<pre><code>git push origin master:master -f </code></pre> \n<ul>\n <li>提交简写</li>\n</ul> \n<pre><code>git push -u</code></pre> \n<blockquote>\n tips:出现这个问题的最主要原因还是在于本地仓库和远程仓库实际上是独立的两个仓库。\n</blockquote> \n<h4>pull(拉新合并)</h4> \n<ul>\n <li>git pull</li>\n</ul> \n<p>&nbsp;&nbsp;命令基本上就是 <code>git fetch</code> 和 <code>git merge</code> 命令的组合体，git 从指定的远程仓库中抓取内容，然后马上尝试将其合并进你所在的分支中。</p> \n<ul>\n <li>git fetch [remote-name] (拉新)</li>\n</ul> \n<p>&nbsp;&nbsp;这个命令会访问远程仓库，从中拉取所有你还没有的数据。 执行完成后，你将会拥有那个远程仓库中所有分支的引用，可以随时合并或查看。<br>但是注意的是 <code>git fetch</code> 并不会自动合并或修改你当前的工作。 你必须手动将其合并入你的工作。</p> \n<ul>\n <li>git merge [remote-name] (合并)</li>\n</ul> \n<p>&nbsp;&nbsp;合并分支</p> \n<ul>\n <li>总结</li>\n</ul> \n<p>&nbsp;&nbsp;使用 <code>git pull</code>，命令来自动的抓取然后合并远程分支到当前分支。(相当于一次执行fetch加merge命令)更简单，更方便快捷，更舒适的工作流程。</p> \n<h4>branch(分支)</h4> \n<ul>\n <li>创建新分支</li>\n</ul> \n<pre><code> git branch newBranch</code></pre> \n<ul>\n <li>切换新分支</li>\n</ul> \n<pre><code> git checkout newBranch</code></pre> \n<ul>\n <li>合并分支</li>\n</ul> \n<pre><code>git merge newBranch  </code></pre> \n<ul>\n <li>删除分支</li>\n</ul> \n<pre><code> git branch -D newBranch</code></pre> \n<blockquote>\n tips:合并分支前，一定要切换到想要合并的分支上，比如主分支，再执行分支合并操作\n</blockquote> \n<h4>其他命令</h4> \n<ul>\n <li>查看提交历史</li>\n</ul> \n<pre><code>git log</code></pre> \n<ul>\n <li>查看当前状态</li>\n</ul> \n<pre><code>git status</code></pre> \n<ul>\n <li>缓存删除</li>\n</ul> \n<pre><code>git rm -r --cached .</code></pre> \n<blockquote>\n tips:应用场景,比如.gitignore忽略的文件无效的情况等\n</blockquote> \n<ul>\n <li>修改本地代码关联的远程地址</li>\n</ul> \n<pre><code>git remote set-url origin ssh://git@ip:端口/home/git/gitrepo/git.git </code></pre> \n<blockquote>\n tips：当代码库远程迁移后，可使用当前功能\n</blockquote> \n<h4>获取指定历史版本源代码</h4> \n<pre><code>git clone http://XXXX/XX.git //克融项目\ngit log   // 查看commit历史,并找到需要的版本\ngit checkout \'版本号\' //获取</code></pre> \n<blockquote>\n tips：运行\n <code>git log</code>命令 ,查看commit后跟着的哈希值就是版本号\n</blockquote> \n<h1>冲突解决</h1> \n<ul>\n <li>版本分支的问题<p>&nbsp;&nbsp;问题描述：提交git仓库时出现：Your branch is up-to-date with \'origin/master\'.</p> </li>\n</ul> \n<pre><code>/*解决方案*/\n\n//这时候我们就需要新建一个分支\n git branch newBranch  \n//检查分支是否创建成功,前面的*代表的是当前你所在的工作分支\n git branch\n//切换到你的新分支\n git checkout newBranch\n//添加修改和新增的文件\n git add .\n//提交到本地\n git commit -m \"18.03.01\"\n//检查是否成功\n git status\n//然后切换到主分支\n git checkout master \n//将新分支提交的改动合并到主分支上(合并前一定要切换到主分支)\n git merge newBranch   \n// push代码了\n git push -u origin master\n//删除这个分支\n git branch -D newBranch</code></pre> \n<ul>\n <li>冲突导致，文件乱码</li>\n</ul> \n<p>++&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD</p> \n<p>++&lt;&lt;&lt;&lt;&lt;&lt;&lt; new_branch</p> \n<p>&nbsp;&nbsp;可直接删除掉这些乱码，保存后再提交，某些<code>ide</code>可提示,并可删除这些乱码等其他智能操作,如<code>vs code</code>,编码神器，我的最爱，哈哈，强推一波。</p> \n<ul>\n <li>提示：仓库内还有未合并的文件,不能提交代码.</li>\n</ul> \n<p>&nbsp;&nbsp; 问题描述：committing is not possible because you have unmerged files</p> \n<pre><code>/*解决方案*/\n\n//把你修改的文件一个个添加进去\ngit  add \'文件名\'，\n//提交本地\ngit commit -a -m  \"备注信息\" \n//提交远程\ngit push -u</code></pre> \n<h1>提交规范</h1> \n<ul>\n <li>规范说明</li>\n</ul> \n<p>git提交也有规范，业内做的比较好,具有参考价值的就是<code>Angular</code>的提交。</p> \n<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt; #header\n// 空一行\n&lt;body&gt;\n// 空一行\n&lt;footer&gt;\n\n//中文释义\n&lt;类型&gt;[可选的作用域]: &lt;主题&gt; 描述\n\n[可选的正文]\n\n[可选的脚注]\n</code></pre> \n<ul>\n <li>主体参数</li>\n</ul> \n<table> \n <thead>\n  <tr> \n   <th>参数</th> \n   <th>说明</th> \n   <th>是否必须</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>type</td> \n   <td>提交类型</td> \n   <td>true</td> \n  </tr> \n  <tr> \n   <td>scope</td> \n   <td>提交影响的范围</td> \n   <td>false</td> \n  </tr> \n  <tr> \n   <td>subject</td> \n   <td>提交目的的简短描述</td> \n   <td>false</td> \n  </tr> \n  <tr> \n   <td>header</td> \n   <td>内容</td> \n   <td>true</td> \n  </tr> \n </tbody> \n</table> \n<ul>\n <li> <p>type有以下标识</p> \n  <ul> \n   <li>feat：增加新功能(feature)</li> \n   <li>fix : 修复bug</li> \n   <li>docs : 文档改变 (documentation)</li> \n   <li>style : 代码格式改变</li> \n   <li>refactor : 某个已有功能重构</li> \n   <li>build : 改变了build工具, 如</li> \n   <li>grunt换成了npm</li> \n   <li>revert: 撤销上一次的 commit</li> \n   <li>perf : 性能优化</li> \n   <li>test : 增加测试</li> \n   <li>ci: 与CI(持续集成服务)有关的改动</li> \n   <li>chore：不修改src或者test的其余修改，例如构建过程或辅助工具的变动</li> \n   <li>del：删除某个内容</li> \n  </ul> </li>\n</ul> \n<blockquote> \n <p>tips:</p> \n <ol> \n  <li>如果type为feat和fix，则该 commit 将肯定出现在 Change log 之中。其他特殊情况(docs、chore、style、refactor、test）由你决定，要不要放入 Change log，建议是不要。</li> \n  <li>当一次改动包括主要type与特殊type时，统一采用主要type。</li> \n </ol> \n</blockquote>', null, '3f69fcc9b13843d1910b3dac597f5215', 'f4fda25145b9451a9b0d77d6a2a63712,30ea6d13caf14dc8990e3284489224d9', '0', '3', '1', '2020-04-16 16:59:47', '2020-04-16 16:59:47');
INSERT INTO `tb_recommend` VALUES ('b5a20a9b9df34fd6953514a5e5afe285', '打造百亿量级、亿级日活SDK的十大关键要点', '一个好的SDK应该具备易用性、稳定性、轻量、灵活的特点，而个推作为国内第三方推送市场的早期进入者，一直致力于为开发者提供高效稳定的推送SDK。', '<p>一个好的SDK应该具备易用性、稳定性、轻量、灵活的特点，而个推作为国内第三方推送市场的早期进入者，一直致力于为开发者提供高效稳定的推送SDK。</p> \n<p>经过十年的深耕与创新，个推夯实了行业地位。截止2019年6月，个推SDK累计安装量超440亿，日活独立设备数达4.3 亿，并成功服务了人民日报、新华社、微博、马蜂窝、酷我音乐等一系列明星APP。辉煌数据的背后是强大的技术支撑。</p> \n<p>这期文章，我们特地采访了个推Android 资深开发敬瑜，以个推推送SDK为例，来聊聊打造大型SDK的关键技术点。</p> \n<p>作者 个推Android 资深开发 敬瑜</p> \n<p><strong>01 开发 SDK 和 开发APP 有什么联系？</strong></p> \n<p>APP 和 SDK两者关系密切，APP是SDK的主要载体， SDK 则是 APP开发所需的重要工具。从研发者的角度来看，SDK开发和 APP开发均属于 Android 顶层应用开发，并无本质区别，两者的目的均是要提供产品给客户使用；但从商业角度来讲，APP 是to C 的产品，用户是广大群众；而 SDK 则是to B 的产品，用户为广大开发者，两者在运营模式上有所不同。</p> \n<p><strong>02 SDK 开发最关键的点是什么？</strong></p> \n<p>SDK没有UI交互，用户使用 APP 时并不会感知到SDK 的存在。但是作为APP的重要部分，SDK的性能直接影响着APP的性能，也间接影响着用户在使用APP时的体验和感受。总结个推推送SDK的开发经验，我们认为SDK开发最需要注意的是其稳定性。</p> \n<p>作为一款第三方 SDK，稳定性是第一要素，我们要保证推送SDK在不同环境下（APP、终端设备等）都能正常运行。要想保障稳定性，复杂环境的兼容是关键。减少使用非 SDK 接口也有助于提升稳定性。</p> \n<p>除了稳定性外，以下几个问题对于打造优质SDK也很重要。</p> \n<p><strong>03 SDK 版本适配以及厂商兼容情况如何？</strong></p> \n<p>个推 SDK 支持 Android 端和 iOS 端，以下文章均使用 Android 端来举例。</p> \n<p>截止目前，Android 系统从07年发布第一版至今，经历了多次迭代，Android Q为其最新版本。个推Android SDK 支持 Android 2.3及以上版本，几乎可以在市面上现存的所有Android 版本上运行。</p> \n<p><strong> 1）版本适配</strong><br>APP 主要在手机上运行，若想 APP 在 Pad、电视之类的智能设备上运行，则基本需要单独适配，也就是说，APP 会根据其使用环境调试相应的版本。而 SDK 的运行环境相对复杂，我们根本不知道自己开发的 SDK 会在什么样的环境下运行，可能是手机、Pad、电视，也可能是车载设备，甚至是冰箱等智能家居设备。这类设备的 Android 系统版本从 2.3至10.0 不等。我们在开发SDK 的时候需要尽量地向下兼容。为此，个推推送 SDK 依旧保留着对 Android 2.3 系统的兼容。 </p> \n<p><strong> 2）厂商兼容</strong><br>一个成熟的 SDK 势必要保证在不同的厂商设备上正常运行，尤其是当SDK 内部涉及到Android 四大组件时需要特别注意厂商的兼容性，注意其是否会限制固定 action 的广播使用及限制固定类名 service 的启动。而如果 SDK 开发涉及到 Android framewrok 的引用，某些功能可能会失效。比如AndFix 的底层实现依托于 Art/Dalvik 虚拟机的架构，但是大部分厂商会对虚拟机进行定制，修改底层 ArtMethod 结构，这时，AndFix将无法在修改过虚拟机的设备上生效。</p> \n<p>所以在 SDK 开发过程中我们要尽量避免Android Framework 的引用。个推在使用Android 四大组件的时候，会要求开发者提供自定义 Service，其Service 只需要继承个推默认的即可，这样可以保证 SDK 在不同厂商上均能正常运行。</p> \n<p><strong>04 怎么看待现在市面上的 SDK广泛支持多混合开发这一现象？</strong></p> \n<p>大前端开发是必然的趋势，现在新推出的产品会优先使用混合开发，保证一套代码可以在多个终端上运行。因此，一个成熟的 SDK 有必要对不同的语言框架进行适配。目前，个推 SDK 不仅支持 Android、iOS系统，还支持混合开发，如unity3d cocos2dx react-native flutter cordova apicloud等。具体见<a href=\"https://github.com/GetuiLaboratory\" rel=\"nofollow noreferrer\">个推实验室</a></p> \n<p><strong>05 Android SDK 是否会使用开源项目？</strong></p> \n<p>不会使用。<br>有以下几点考虑：</p> \n<ul> \n <li>使用开源项目会增加包的体积；</li> \n <li>不能保证开源项目支持复杂的终端环境；</li> \n</ul> \n<p>-客户的 APP可能已使用开源项目，将导致编译失败；</p> \n<p><strong>06 如何适配海外市场环境？</strong></p> \n<p>开拓Google Play 市场是各大互联网公司的长远规划之一。个推Android SDK Google Play版本自发布以来，积极适配复杂的海外环境，为海外App消息的稳定下发提供强大的支撑和保障。为了有更好的用户体验，个推推送 SDK 还在国外众多地方布置了机房，以保证推送的到达率。另外，个推推送SDK还需要对 Google Play 制定的各种规则进行适配，以及还要考虑不同国家不同版本机型的适配问题。这要求我们在开发过程中尽量使用 Google 生产的手机进行调试与测试。</p> \n<p><strong>07 SDK 如何降低手机电量、流量的消耗？</strong></p> \n<p>为了给用户更好的使用体验，我们会尽可能地降低SDK对电量以及流量所造成的消耗。为此，我们不会使用蓝牙这类电量消耗较高的工具。此外，我们还会采用多链路合并技术来节约流量。</p> \n<p>为了准确地了解所耗电量、流量的降低情况，我们还会做一个全面的测试。每次发版之前，我们都会采用严格的测试标准，使用特定的 APP 进行电量压测。为了尽可能地排除外来因素的干扰，保证测试的准确性，我们往往会使用集成了个推推送 SDK 的 APP来测量。常见测量 APP 的方式有Batterystats &amp; bugreport和Battery Historian。具体细节可以自行查阅 PowerProfile.java 和 power_profile.xml 的使用与原理。</p> \n<p><strong>08 如何自主检测 SDK 的异常？</strong></p> \n<p>经过近 10 年的优化与升级，个推推送 SDK 的异常情况已经控制在一个非常非常低的水平，但因为 Android 市场碎片化非常严重，SDK 在如此碎片化的环境下运行难免会出现各种意想不到的突发情况，为此我们专门开发了SDK运行自查系统，类似于精简版的 bugly。该内部产品与 SDK 相辅相成，可以自主检测 SDK 的异常情况，并在发现异常后主动上报。其次，在代码层面，我们也做了一些防控，避免 SDK 因为异常而导致无法正常使用。另外，我们还成立了技术支持团队，服务广大的开发者，定期回访客户，帮助解决客户遇到的问题。</p> \n<p><strong>09 开发SDK还有什么是需要注意的么？</strong></p> \n<p>SDK开发过程中，我们还需要注意安全性。安全性不仅仅代表网络数据交互的安全、本地数据存储的安全，也涉及到 SDK 的加固、混淆、第三方安全软件审核。举例来说，个推 Android SDK 提供了四大组件的对接，SDK 内部会特别注意，避免这些组件被反序列化攻击。为了让开发者更加放心地使用我们的SDK，我们公司内部建立了严格的安全管理机制，来保障SDK的安全性。</p> \n<p><strong>10 对 SDK 开发者有何建议？</strong></p> \n<p>其实从 Android APP 诞生开始，SDK 的开发就从未中断过。SDK 开发者与 APP 开发者的工作内容基本相同，但是开发 SDK 更注重对 Java 语言以及 Android 底层的理解。如果大家想从事Android SDK 开发，建议多研究 Java 的相关知识，深入理解 Android framework 层。</p> \n<p>开发SDK并不难，难的是如何让自己开发的 SDK 在复杂的环境下稳定运行。这需要我们对 SDK 的架构有一个比较清晰的认知，并对前文所提到的问题进行认真思考。</p> \n<p>多年来，个推 SDK始终以服务开发者为己任，持续为用户提供优质的体验。为了进一步提升推送后台的保活能力，个推已发布 2.13.3.0版本，并对 Android Q 进行了适配，请前往个推文档中心下载<a href=\"http://docs.getui.com/download.html\" rel=\"nofollow noreferrer\">http://docs.getui.com/downloa...</a>，即刻体验。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022161427\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p>', 'https://segmentfault.com/img/remote/1460000022161427', '1c5851dc916d4e70a60f0c957f548876', '0b50d8c7b2a44489a9dd703b034feac2,8dfc62f227ae4076888ea4872e03cddd,85ee959b27f74072b13cc763b9bbf77e', '0', '3', '1', '2020-04-16 16:50:16', '2020-04-16 16:50:16');
INSERT INTO `tb_recommend` VALUES ('b7857bcb41934719a01e2df5ce51f00f', 'GNU Guix 将终止对 Linux 内核的支持，全面替换为 GNU Hurd', 'GNU Guix 项目官方近日宣布，正在用 GNU Hurd 替换其 Linux（确切地说是GNU Linux-libre）内核，Guix 1.1 将是最后一个支持 Linux 的版本。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFHty\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>GNU Guix 项目官方近日宣布，正在用 GNU Hurd 替换其 Linux（确切地说是GNU Linux-libre）内核，Guix 1.1 将是最后一个支持 Linux 的版本。</p> \n<p>而到了 Guix 2.0，他们可能会完全删除 Linux 内核，但仍然允许“外国”发行版尽最大努力支持它。</p> \n<p>他们希望 GNU Hurd 可以“为用户增加安全性和自由度”。尽管 GNU Hurd 仍然不能在当今的许多硬件上运行，更不用说支持其他较新的硬件功能和设备。</p> \n<p>基本上，现阶段的 GNU Hurd 可以为基本的虚拟机加速，但除此之外并不太实用。</p> \n<h2>GNU Guix</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFHtA\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>GNU Guix 是一个事务包管理器，是 GNU 系统的高级发行版，它尊重用户的自由。如前文所说，Guix 可以在运行 Hurd 或 Linux 内核的任何系统上使用，也可以用作 i686，x86_64，ARMv7 和 AArch64 机器的独立操作系统发行版。</p> \n<p>除了标准的软件包管理功能之外，Guix 还支持事务性升级和回滚，无特权的软件包管理，每用户配置文件以及垃圾回收。当用作独立的 GNU / Linux 发行版时，Guix 为操作系统配置管理提供了一种声明式，无状态的方法。通过 Guile 编程接口和 Scheme 语言的扩展，Guix 具有高度可定制性和可破解性。</p> \n<h2>GNU Hurd</h2> \n<p>GNU Hurd 是一套操作系统內核，以微內核架构设计。Hurd 是 GNU 操作系统的核心部分。GNU 项目从 1990 年开始开发 GNU Hurd，并且将它作为一个遵循 GPL 的自由软件发布。Hurd 的目标是从功能、安全性和稳定性上全面超越传统 Unix 內核，而同时又能保持对其的兼容性，为此 Hurd 遵守 POSIX 标准。</p> \n<p>「Hurd」是一个间接递归缩写，来自“HIRD of Unix Replacing Daemons”，其中“HIRD”表示“HURD of Interfaces Representing Depth”。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFyLB\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFHty', 'f53014d680884163a5bd5ce762e90cdf', '10a8813a8ce34deb9b8d590fcf74124c,753b5aee3913424e81fe2b5299626d8c', '0', '3', '1', '2020-04-16 16:47:15', '2020-04-16 16:47:15');
INSERT INTO `tb_recommend` VALUES ('b7ea1c02ee2b41a093392ea5aeac9229', '疑似国内银行上百万数据泄露，涉及上海银行、兴业银行、浦发银行等', '据社交媒体账号 @Bank Security 发布的消息显示，大量国内银行的数据正在被出售。数据包括上海银行 80 万行客户数据、46 万中国兴业银行信用卡资料、20 万上海理财 VIP 客户数据和 10 万上海浦发银行客户资料。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFWyd\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片描述\" title=\"图片描述\"></span></p> \n<p>技术编辑：徐九丨发自 北京<br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>据社交媒体账号 @Bank Security 发布的消息显示，大量国内银行的数据正在被出售。数据包括上海银行 80 万行客户数据、46 万中国兴业银行信用卡资料、20 万上海理财 VIP 客户数据和 10 万上海浦发银行客户资料。</p> \n<p>根据网曝图片显示，被泄露的数据包括姓名、地址、电话号码、身份证号、存款金额、所办业务等金融数据。</p> \n<hr> \n<p>据业内人士表示，银行数据泄露有两种来源：一种是技术上从后台数据库导出，一种是业务人员从前台导出。技术层面数据库数据的泄露，有可能是公司技术人员非法拷贝数据库中的数据，也有可能是被黑客攻击导致泄露。</p> \n<p>据业内人士分析，此次疑似又是一起因安全保护措施不当导致的数据库泄露。</p> \n<p>近两年，数据泄露事件频发，网络信息安全已成为不容忽视的问题，希望各厂商、开发者能够重视安全问题，避免造成不必要的损失。</p> \n<p>针对此次泄露事件，相关银行暂未进行回复。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFPkW\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFWyd', '692c6787030d4b8882077b2ab9279c52', '83f62facb3b943ffa8e46abd1ebc64d9,e75baefb206a4efe959a99aad77632a3', '0', '3', '1', '2020-04-16 16:58:54', '2020-04-16 16:58:54');
INSERT INTO `tb_recommend` VALUES ('b95fc0f4cfb545b18aa5112c1c332f2a', '用 MelonJS 开发一个游戏', '游戏开发并不需要局限于使用 Unity 或 Unreal Engine4 的用户。 JavaScript 游戏开发已经有一段时间了。实际上，最流行的浏览器（例如Chrome，Firefox和Edge）的最新版本提供了对高级图形渲染（例如WebGL）的支持...', '<blockquote>\n 作者：Fernando Doglio\n <p>翻译：疯狂的技术宅</p> \n <p>原文：<a href=\"https://blog.bitsrc.io/writing-a-typing-game-with-melonjs-ef0dd42f37bf\" rel=\"nofollow noreferrer\">https://blog.bitsrc.io/writin...</a></p> \n <p><strong>未经允许严禁</strong></p> \n</blockquote> \n<p>游戏开发并不需要局限于使用 Unity 或 Unreal Engine4 的用户。 JavaScript 游戏开发已经有一段时间了。实际上，最流行的浏览器（例如Chrome，Firefox和Edge）的最新版本提供了对高级图形渲染（例如<a href=\"https://get.webgl.org/\" rel=\"nofollow noreferrer\">WebGL</a>）的支持，从而带来了非常有趣的游戏开发机会。</p> \n<p>不过用 WebGL 进行游戏开发没有办法在一篇文章中涵盖其所有内容（有专门为此编写的完整书籍），并且出于个人喜好，在深入研究特定技术之前，我更倾向于依赖框架的帮助。</p> \n<p>这就是为什么经过研究后，我决定用 <a href=\"http://www.melonjs.org/\" rel=\"nofollow noreferrer\">MelonJS</a> 编写此快速教程的原因。</p> \n<h2>什么是 MelonJS？</h2> \n<p>你可能已经猜到了，MelonJS 是一个 JavaScript 游戏引擎，与所有主流浏览器完全兼容（从 Chrome 到 Opera，一直到移动版 Chrome 和 iOS Safari）。</p> \n<p>它具有一系列功能，在我的研究过程中非常引人注目：</p> \n<ul> \n <li>对于初学者来说，它是完全独立的，不需要外部依赖就可以使它工作。</li> \n <li>但是，它可以与多个第三方工具集成在一起，使你的工作更加轻松，例如<a href=\"https://github.com/bjorn/tiled/wiki\" rel=\"nofollow noreferrer\">Tiled</a>（可帮助你创建地图和游戏关卡），<a href=\"https://github.com/melonjs/melonJS/wiki/How-to-use-Texture-Atlas-with-TexturePacker\" rel=\"nofollow noreferrer\">TexturePacker</a>（帮助你创建所需的纹理图集并简化和优化精灵管理）。</li> \n <li>集成了 2D 物理引擎。这意味着你可以使用开箱即用的逼真的 2D 运动和碰撞检测。这很关键，因为必须解决所有这些问题，这需要大量的工作（更不用说数学运算了，这并不是我的菜）。</li> \n <li>支持声音 API，使你能够以出色的简便性添加声音效果和背景音乐。</li> \n</ul> \n<p>该引擎还有其他令人赞叹的功能，你可以在其网站上进行查看，不过以上是本文中我们最关注的功能。</p> \n<p><strong>提示：</strong>使用 <a href=\"https://bit.dev/\" rel=\"nofollow noreferrer\"><strong>Bit</strong></a>（<a href=\"https://github.com/teambit/bit\" rel=\"nofollow noreferrer\">Github</a>）可以轻松共享和重用 JS 模块，项目中的 UI 组件，建议更新。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqEU?w=650&amp;h=355\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>Bit 组件：能够轻松地在团队中跨项目共享</p> \n<h2>设计我们的游戏</h2> \n<p>打字游戏的目的是通过打字（或敲击随机键）为玩家提供移动或执行某种动作的能力。</p> \n<p>我记得小时候曾经学过如何打字（是的，很久以前）了，当时在“Mario Teaches Typing” 这个游戏中，必须键入单个字母才能前进，要么跳到乌龟上，要么从下面打一个方块。下图为你提供了游戏外观以及怎样与之进行互动的想法。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqEW?w=523&amp;h=347\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>尽管这是一个有趣的小游戏，但它并不是一个真正的平台游戏，Mario 所执行的动作始终对应一个按键，并且永远不会失效。</p> \n<p>不过，对于本文，我想让事情变得更有趣，并不是创建一个简单的打字游戏，例如上面的游戏：</p> \n<p>游戏不会通过单个字母来决定下一步的行动，而是提供了五个选择，并且每个选择都必须写一个完整的单词：</p> \n<ol> \n <li>前进</li> \n <li>向前跳</li> \n <li>跳起来</li> \n <li>向后跳</li> \n <li>向后移动</li> \n</ol> \n<p>换句话说，你可以通过输入的单词来移动角色，而不是经典的基于箭头进行控制。</p> \n<p>除此之外，该游戏将是一个经典平台游戏，玩家可以通过走动收集金币。为了简洁起见，我们会将敌人和其他类型的实体排除在本教程之外（尽管你应该能够推断出所使用的代码，并能基于该代码创建自己的实体）。</p> \n<p>为了使本文保持合理的长度，我将只关注一个阶段，全方位的动作（换句话说，你将能够执行所有 5 个动作）、几个敌人、一种收藏品，还有数量可观的台阶供你跳来跳去。</p> \n<h2>你需要的工具</h2> \n<p>尽管 melonJS 是完全独立的，但在此过程中有一些工具可以帮助大家，我建议你使用它们：</p> \n<ul> \n <li> <a href=\"https://www.codeandweb.com/texturepacker\" rel=\"nofollow noreferrer\">Texture Packer</a>：有了这个，你将能够自动生成纹理图集，这是另一种表达 JSON 文件的方式，其中打包了所有图像，以便引擎以后可以检索并根据需要使用它们。 如果你没有这个工具，那么手动维护地图集可能会消耗太多的时间。</li> \n <li>Tiled：这将是我们的关卡编辑器。尽管你可以免费下载它（你需要找到显示“No thanks, just take me to the downloads” 的链接），但是你可以向该神奇工具的作者捐献最低 1 美元。如果你有可用的 PayPal 帐户或借记卡，建议你这样做，这样的软件需要维护，并且需要付出时间和精力。</li> \n</ul> \n<p>使用这些工具，你将可以继续学习并完成本教程，所以让我们开始编码吧。</p> \n<h2>基本的平台游戏</h2> \n<p>为了开始这个项目，我们可以使用一些示例代码。下载引擎时，它将默认附带一组示例项目，你可以检出这些项目（它们位于 <em>example</em> 文件夹中）。</p> \n<p>这些示例代码是我们用来快速启动项目的代码。在其中，你会发现：</p> \n<ul> \n <li> <em>data</em> 文件夹，包含与代码无关的所有内容。在这里你可以找到声音、音乐、图像、地图定义甚至字体。</li> \n <li> <em>js文件夹</em>，你将在这里保存所有与游戏相关的代码。</li> \n <li> <em>index.html 和 index.css文件</em>。这些是你的应用与外界互动所需的联系点。</li> \n</ul> \n<h3>了解现有代码</h3> \n<p>现在暂时将资源留在 <em>data</em> 文件夹中，我们需要了解该示例为我们提供了什么。</p> \n<h4>执行游戏</h4> \n<p>要执行游戏，你需要做一些事情：</p> \n<ol> \n <li>一份 melonJS。如果已下载，请确保获得 <code>dist</code> 文件夹的内容。将其复制到任意文件夹中，并确保像其他 JS 文件一样，将其添加到 <code>index.html</code> 文件中。</li> \n <li>安装（如果尚未安装）npm 中提供的 <a href=\"https://www.npmjs.com/package/http-server\" rel=\"nofollow noreferrer\">http-server</a> 模块，该模块可以快速为相关文件夹提供 HTTP 服务。如果尚未安装，只需执行以下操作：</li> \n</ol> \n<pre><code class=\"bash\">$ npm install -g http-server</code></pre> \n<p>安装完成后，从项目文件夹中运行：</p> \n<pre><code class=\"bash\">$ http-server</code></pre> \n<p>这时你可以通过访问 <code>http://localhost:8080</code> 来测试游戏。</p> \n<h4>查看代码</h4> \n<p>在游戏中你会发现这是一个能够进行基本（非常尴尬）动作的平台游戏，几个不同的敌人和一个收藏品。基本上这与我们的目标差不多，但控制方案略有不同。</p> \n<p>这里要检查的关键文件是：</p> \n<ul> \n <li> <strong>game.js</strong>：该文件包含所有初始化代码，有趣的是如何实例化游戏图形和主控件。</li> \n <li> <strong>screens/play.js</strong>：包含设置关卡所需的所有代码。你会注意到它内容并不多。由于级别定义是使用其他工具（即 Tiled）完成的，所以此代码只是启用了该功能。</li> \n <li> <strong>entities/player.js</strong>：显然这是你的主要目标。该文件包含你角色的移动代码，碰撞反应和控制键绑定。虽然规模并不大，却是你想花费最多时间的地方。</li> \n <li> <strong>entities/enemies.js</strong>：仅次于 player 代码，这很重要，因为你将看到如何基于预定义的坐标来设置自动行为。</li> \n</ul> \n<p>其余文件也很有用，但并不是那么重要，我们会在需要时使用它们。</p> \n<h3>了解一切从何而来</h3> \n<p>如果你提前做好了了功课，可能已经注意到了，没有一行实例化玩家或敌人的代码。他们的坐标无处可寻。那么，游戏该如何理解呢？</p> \n<p>这是关卡编辑器所起到的作用。如果你下载了Tiled，则可以在 <code>data/map</code> 文件夹中打开名为 <code>map1.tmx</code> 的文件，然后会看到类似下面的内容：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFa?w=674&amp;h=383\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>屏幕的中心部分向你显示正在设计的关卡。如果仔细观察，你会看到图像和矩形形状，其中一些具有不同的颜色和名称。这些对象代表游戏中的 <em>东西</em>，具体取决于它们的名称和所属的层。</p> \n<p>在屏幕的右侧，你会在其中看到图层列表（在右上方）。有不同类型的层：</p> \n<ul> \n <li>图像层：用于背景或前景图像</li> \n <li>对象层：用于碰撞对象、实体以及你想在地图中实例化的任何对象。</li> \n <li>Tile 层：你将在其中放置 Tile 以创建实际关卡的位置。</li> \n</ul> \n<p>右下角包含此地图的图块。 tileet 也可以由 Tiled 创建，并且可以在同一文件夹中以 <em>tsx</em> 扩展名找到该 tileet。</p> \n<p>最后，在屏幕左侧，你会看到“属性”部分，在这里你将看到有关所选对象或单击的图层的详细信息。你将能够更改通用属性（例如图层的颜色，以便更好地了解其对象的位置）并添加自定义属性（稍后将其作为参数传递给游戏中实体的构造函数）。</p> \n<h2>更改运动方案</h2> \n<p>现在我们已经准备好进行编码了，让我们专注于本文的主要目的，我们将以示例的工作版本为例，尝试对其进行修改，使其可以用作打字游戏。</p> \n<p>这意味着，需要更改的第一件事是运动方案，或者换句话说：更改控制。</p> \n<p>转到 <code>entities/player.js</code> 并检查 <code>init</code> 方法。你会注意到很多 <code>bindKey</code> 和 <code>bindGamepad</code> 调用。这些代码本质上是将特定按键与逻辑操作绑定在一起。简而言之，它可以确保无论你是按向右箭头键，D 键还是向右移动模拟摇杆，都会在代码中触发相同的“向右”动作。</p> \n<p>所有这些都需要将其删除，这对我们没什么用。同时创建一个新文件，将其命名为 <code>wordServices.js</code>，并在此文件中创建一个对象，该对象将在每个回合中返回单词，这能够帮助我们了解玩家到底选择了哪个动作。</p> \n<pre><code class=\"javascript\">/**\n * Shuffles array in place.\n * @param {Array} a items An array containing the items.\n */\nfunction shuffle(a) {\n    var j, x, i;\n    for (i = a.length - 1; i &gt; 0; i--) {\n        j = Math.floor(Math.random() * (i + 1));\n        x = a[i];\n        a[i] = a[j];\n        a[j] = x;\n    }\n    return a;\n}\n\n\nActionWordsService = {\n\n    init: function(totalActions) {\n        //load words...\n        this.words = [\n            \"test\", \"hello\", \"auto\", \"bye\", \"mother\", \"son\", \"yellow\", \"perfect\", \"game\"\n        ]\n        this.totalActions = totalActions\n        this.currentWordSet = []\n    },\n\n    reshuffle: function() {\n        this.words = shuffle(this.words)\n    },\n\n    getRegionPostfix: function(word) {\n        let ws = this.currentWordSet.find( ws =&gt; {\n            return ws.word == word\n        })\n        if(ws) return ws.regionPostfix\n        return false\n    },\n\n    getAction: function(word) {\n        let match = this.getWords().find( am =&gt; {\n            return am.word == word\n        })\n        if(match) return match.action\n        return false\n    },\n\n    getWords: function() {\n        let actions = [ { action: \"right\", coords: [1, 0], regionPostfix: \"right\"}, \n                        { action: \"left\", coords: [-1, 0], regionPostfix: \"left\"}, \n                        { action: \"jump-ahead\", coords: [1,-0.5], regionPostfix: \"upper-right\"}, \n                        { action: \"jump-back\", coords:[-1, -0.5], regionPostfix: \"upper-left\"},\n                        { action: \"up\", coords: [0, -1], regionPostfix: \"up\"}\n                    ]\n\n       this.currentWordSet = this.words.slice(0, this.totalActions).map( w =&gt; {\n            let obj = actions.shift()\n            obj.word = w\n            return obj\n       })\n       return this.currentWordSet\n    }\n}</code></pre> \n<p>本质上，该服务包含一个单词列表，然后将其随机排列，并且每次请求该列表时（使用 getWords 方法），都会随机获取一组单词，并将它们分配给上面提到的一种操作。还有与每个操作相关的其他属性：</p> \n<ul> \n <li>基于动作 HUD，<strong>coords</strong> 属性用于将文本放置在正确的坐标中（稍后会详细介绍）</li> \n <li> <strong>regionPostfix</strong> 属性用于为 HUD 操作选择正确的框架。</li> \n</ul> \n<p>现在，让我们看看如何在游戏过程中请求用户输入。</p> \n<p>注意：继续前进之前，请记住，为了使新服务可用于其余代码，你必须将其包含在 <code>index.html</code> 文件中，就像其他 JS 库一样：</p> \n<pre><code class=\"html\">&lt;script type=\"text/javascript\" src=\"js/wordServices.js\"&gt;&lt;/script&gt;</code></pre> \n<h3>如何捕获用户输入</h3> \n<p>你可以潜在地使用键绑定的组合来模仿使用游戏元素的输入字段的行为，但是请考虑输入字段默认提供的所有可能的组合和行为（例如，粘贴文本、选择、移动而不删除字符等） ），必须对所有程序进行编程以使其可用。</p> \n<p>相反，我们可以简单地在 HTML 主页面中添加一个文本字段，并使用 CSS 对其进行样式设置，使其位于 Canvas 元素之上，它将成为游戏的一部分。</p> \n<p>你只需要在 <code>&lt;body&gt;</code> 内的这段代码即可：</p> \n<pre><code class=\"html\">&lt;input type=\"text\" id=\"current-word\" /&gt;</code></pre> \n<p>尽管这完全取决于你，但我还是建议你使用 <a href=\"https://jquery.com/\" rel=\"nofollow noreferrer\">jQuery</a> 来简化将回调附加到 <code>keypress</code> 事件上所需的代码。当然可以使用原生 JS 完成此操作，但我更喜欢这个库提供的语法糖。</p> \n<p>以下代码位于 <code>game.js</code> 文件的 <code>load</code> 方法中，负责捕获用户的输入：</p> \n<pre><code class=\"javascript\">me.$input = $(\"#current-word\")\n\nlet lastWord = \'\'\nme.$input.keydown( (evnt) =&gt; {\n\n    if(evnt.which == 13) {\n        console.log(\"Last word: \", lastWord)\n        StateManager.set(\"lastWord\", lastWord)\n        lastWord = \'\'\n        me.$input.val(\"\")\n    } else {\n        if(evnt.which &gt; 20) {\n            let validChars = /[a-z0-9]+/gi\n            if(!String.fromCharCode(evnt.which).match(validChars)) return false\n          }\n\n        setTimeout(_ =&gt; {\n            lastWord = me.$input.val() //String.fromCharCode(evnt.which)\n            console.log(\"Partial: \", lastWord)\n        }, 1)\n    }\n    setTimeout(() =&gt; {\n        StateManager.set(\"partialWord\", me.$input.val())\n    }, 1);\n})</code></pre> \n<p>本质上是我们捕获输入元素并将其存储在全局对象 <code>me</code> 中。这个全局变量包含游戏所需的一切。</p> \n<p>这样，我们可以为按下的任何按键设置事件处理程序。如你所见，我正在检查键码 13（代表ENTER键）以识别玩家何时完成输入，否则我将确保他们输入的是有效字符（我只是避免使用特殊字符，这样可以防止 melonJS 提供的默认字体出现问题）。</p> \n<p>最后我在 <code>StateManager</code> 对象上设置了两个不同的状态，<em>lastWord</em> 了解玩家输入的最后一个单词，<em>partialWord</em> 解现在正在输入的内容。这两种状态很重要。</p> \n<h3>组件之间共享数据</h3> \n<p>如何在组件之间共享数据是很多框架中的常见问题。我们将捕获的输入作为 <code>game</code> 组件的一部分，那么该如何与他人共享这个输入呢？</p> \n<p>我的解决方案是创建一个充当<a href=\"https://nodejs.org/api/events.html\" rel=\"nofollow noreferrer\">事件发送器（event emitter）</a>的全局组件：</p> \n<pre><code class=\"javascript\">const StateManager = {\n\n    on: function(k, cb) {\n        console.log(\"Adding observer for: \", k)\n        if(!this.observers) {\n            this.observers = {}\n        }\n\n        if(!this.observers[k]) {\n            this.observers[k] = []\n        }\n        this.observers[k].push(cb)\n    },\n    clearObserver: function(k) {\n        console.log(\"Removing observers for: \", k)\n        this.observers[k] = []\n    },\n    trigger: function(k) {\n        this.observers[k].forEach( cb =&gt; {\n            cb(this.get(k))\n        })\n    },\n    set: function(k, v) {\n        this[k] = v\n        this.trigger(k)\n    },\n    get: function(k) {\n        return this[k]\n    }\n\n}</code></pre> \n<p>代码非常简单，你可以为特定状态设置多个“观察者”（它们是回调函数），并且一旦设置了该状态（即更改），便会用新值调用所有这些回调。</p> \n<h3>添加 UI</h3> \n<p>创建关卡之前的最后一步是显示一些基本的 UI。因为我们需要显示玩家可以移动的方向以及需要输入的单词。</p> \n<p>为此将使用两个不同的UI元素：</p> \n<ul> \n <li>一个用于图形，它将具有几个不同的帧，本质上一个用于正常图像，然后一个将每个方向显示为“selected”（与 <code>ActionWordsService</code> 上的 <code>regionPostfix</code> 属性相关联）</li> \n <li>一个用于在图像周围输出文本。顺便说一下，这也与 <code>ActionWordsService</code> 上的 <code>coords</code> 属性相关联。</li> \n</ul> \n<p>我们可以在 js 文件夹内搭上现有的 HUD.js 文件。在其中添加两个新组件。</p> \n<p>第一个是 <code>ActionControl</code> 组件，如下所示：</p> \n<pre><code class=\"javascript\">game.HUD.ActionControl = me.GUI_Object.extend({\n    init: function(x, y, settings) {\n        game.HUD.actionControlCoords.x = x //me.game.viewport.width - (me.game.viewport.width / 2)\n        game.HUD.actionControlCoords.y = me.game.viewport.height - (me.game.viewport.height / 2) + y\n\n        settings.image = game.texture;\n\n        this._super(me.GUI_Object, \"init\", [\n            game.HUD.actionControlCoords.x, \n            game.HUD.actionControlCoords.y, \n            settings\n        ])\n\n        //update the selected word as we type\n        StateManager.on(\'partialWord\', w =&gt; {\n            let postfix = ActionWordsService.getRegionPostfix(w)\n            if(postfix) {\n                this.setRegion(game.texture.getRegion(\"action-wheel-\" + postfix))\n            } else {\n                this.setRegion(game.texture.getRegion(\"action-wheel\")\n            }\n            this.anchorPoint.set(0.5,1)\n        })\n\n        //react to the final word\n        StateManager.on(\'lastWord\', w =&gt; {\n            let act = ActionWordsService.getAction(w)\n            if(!act) {\n\n                me.audio.play(\"error\", false);\n                me.game.viewport.shake(100, 200, me.game.viewport.AXIS.X)\n                me.game.viewport.fadeOut(\"#f00\", 150, function(){})\n           } else {\n               game.data.score += Constants.SCORES.CORRECT_WORD\n           }\n        })\n    }\n})</code></pre> \n<p>看起来很多，但是它只是做了一点事情：</p> \n<ol> \n <li>它从 <code>settings</code> 属性中提取其坐标，在 Tiled 上设置地图后，我们将对其进行检查。</li> \n <li>添加对输入了一部分的单词作出反应的代码。我们将 <code>postfix</code> 属性用于当前编写的单词。</li> \n <li>并添加了对完整的词做出反应的代码。如果某个动作与该字词相关联（即是正确的词），那么它将为玩家加分。否则将晃动屏幕并播放错误声音。</li> \n</ol> \n<p>第二个图形部分，即要输入的单词，如下所示：</p> \n<pre><code class=\"javascript\">game.HUD.ActionWords = me.Renderable.extend({\n    init: function(x, y) {\n        this.relative = new me.Vector2d(x, y);\n\n        this._super(me.Renderable, \"init\", [\n            me.game.viewport.width + x,\n            me.game.viewport.height + y,\n            10, //x &amp; y coordinates\n            10\n        ]);\n\n         // Use screen coordinates\n        this.floating = true;\n\n        // make sure our object is always draw first\n        this.z = Infinity;\n        // create a font\n        this.font = new me.BitmapText(0, 0, {\n            font : \"PressStart2P\",\n            size: 0.5,\n            textAlign : \"right\",\n            textBaseline : \"bottom\"\n        });\n\n        // recalculate the object position if the canvas is resize\n        me.event.subscribe(me.event.CANVAS_ONRESIZE, (function(w, h){\n            this.pos.set(w, h, 0).add(this.relative);\n        }).bind(this));\n\n        this.actionMapping = ActionWordsService.getWords()\n    },\n\n    update: function() {\n        this.actionMapping = ActionWordsService.getWords()\n        return true\n    },\n    draw: function(renderer) {\n        this.actionMapping.forEach( am =&gt; {\n            if(am.coords[0] == 0 &amp;&amp; am.coords[1] == 1) return \n            let x = game.HUD.actionControlCoords.x + (am.coords[0]*80) + 30\n            let y = game.HUD.actionControlCoords.y + (am.coords[1]*80) - 30\n            this.font.draw(renderer, am.word, x, y)\n        })\n    }\n})</code></pre> \n<p>该组件的繁重工作是通过 <code>draw</code> 方法完成的。 <code>init</code> 方法只是初始化变量。在调用 <code>draw</code> 的过程中，我们将迭代选定的单词，并使用与之相关的坐标以及一组固定数字，将单词定位在 <code>ActionControl</code> 组件的坐标周围。</p> \n<p>这是建议的动作控制设计的样子（以及坐标如何与之关联）：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFp?w=333&amp;h=255\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>当然，它应该有透明的背景。</p> \n<p>只需确保将这些图像保存在 <code>/data/img/assets/UI</code> 文件夹中，这样当你打开 TexturePacker 时，它将识别出新图像并将其添加到纹理中地图集。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFt?w=678&amp;h=351\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>上图显示了如何添加 action wheel 的新图像。然后，你可以单击“Publish sprite sheet”并接受所有默认选项。它将覆盖现有的地图集，因此对于你的代码无需执行任何操作。这一步骤至关重要，因为纹理地图集将作为资源加载（一分钟内会详细介绍），并且多个实体会将其用于动画之类的东西。请记住，在游戏上添加或更新图形时，都务必这样做。</p> \n<h2>将所有内容与Tiled放在一起</h2> \n<p>好了，现在我们已经介绍了基础知识，让我们一起玩游戏。首先要注意的是：地图。</p> \n<p>通过使用 tiled 和 melonJS 中包含的默认 tileet，我创建了这个地图（ 25x16 tiles 地图，其中 tile 为 32 x 32px）：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFE?w=676&amp;h=338\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>这些是我正在使用的图层：</p> \n<ul>\n <li>HUD：它仅包含一个名为 <strong>HUD.ActionControl</strong> 的元素（重要的是要保持名称相同，一会儿你会明白为什么）。下图显示了此元素的属性（请注意自定义属性）</li>\n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFJ?w=265&amp;h=412\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<ul> \n <li>collision：默认情况下，melonJS 会把以 <code>collision</code> 开头的所有层都假定为碰撞层，这意味着其中的任何形状都是不可遍历的。在这里你将定义地板和平台的所有形状。</li> \n <li>player：该层仅包含 <strong>mainPlayer</strong> 元素（一种形状，该形状将使 melonJS 知道在游戏开始时需要放置玩家的位置）。</li> \n <li>entities：在这一层中，我再次添加了硬币，它们的名称很重要，请保持一致，因为它们需要与你在代码中注册的名称相匹配。</li> \n <li>最后三层就可以在其中添加地图和背景的图像。</li> \n</ul> \n<p>准备好之后，我们可以转到 <code>game.js</code> 文件，并在 <code>loaded</code> 方法内添加以下几行：</p> \n<pre><code class=\"javascript\">// register our objects entity in the object pool\nme.pool.register(\"mainPlayer\", game.PlayerEntity);\nme.pool.register(\"CoinEntity\", game.CoinEntity);\nme.pool.register(\"HUD.ActionControl\", game.HUD.ActionControl);</code></pre> \n<p>这些代码用来注册你的实体（你要使用 Tiled 直接放置在地图上的实体）。第一个参数提供的名称是你需要用 Tiled 进行匹配的名称。</p> \n<p>此外，在此文件中，<code>onLoad</code> 方法应如下所示：</p> \n<pre><code class=\"javascript\">  onload: function() {\n\n        // init the video\n        if (!me.video.init(965, 512, {wrapper : \"screen\", scale : \"auto\", scaleMethod : \"fit\", renderer : me.video.AUTO, subPixel : false })) {\n            alert(\"Your browser does not support HTML5 canvas.\");\n            return;\n        }\n\n        // initialize the \"sound engine\"\n        me.audio.init(\"mp3,ogg\");\n\n        // set all ressources to be loaded\n        me.loader.preload(game.resources, this.loaded.bind(this));\n        ActionWordsService.init(5)\n    },</code></pre> \n<p>我们的基本要求是 <code>965x512</code> 的分辨率（我发现，当屏幕的高度与地图的高度相同时效果很好。在我们的例子中为 <code>16*32 = 512</code>）之后，将使用5个单词（这些是你可以继续前进的5个方向）初始化 <code>ActionWordsService</code> 。</p> \n<p><code>onLoad</code> 方法中另一条有趣的代码是：</p> \n<pre><code class=\"javascript\">me.loader.preload(game.resources, this.loaded.bind(this));</code></pre> \n<h3>资源文件</h3> \n<p>游戏需要的所有类型的资源（即图像、声音、背景音乐、JSON 配置文件等）都需要添加到 <code>resources.js</code> 文件中。</p> \n<p>这是你资源文件的内容：</p> \n<pre><code class=\"javascript\">game.resources = [\n\n    { name: \"tileset\",     type:\"image\", src: \"data/img/tileset.png\" },\n    { name: \"background\",  type:\"image\", src: \"data/img/background.png\" },\n    { name: \"clouds\",      type:\"image\", src: \"data/img/clouds.png\" },\n\n    \n    { name: \"screen01\", type: \"tmx\", src: \"data/map/screen01.tmx\" },\n\n    { name: \"tileset\",  type: \"tsx\", src: \"data/map/tileset.json\" },\n\n    { name: \"action-wheel\", type:\"image\", src: \"data/img/assets/UI/action-wheel.png\" },\n    { name: \"action-wheel-right\", type:\"image\", src: \"data/img/assets/UI/action-wheel-right.png\" },\n    { name: \"action-wheel-upper-right\",type:\"image\", src: \"data/img/assets/UI/action-wheel-upper-right.png\" },\n    { name: \"action-wheel-up\", type:\"image\", src: \"data/img/assets/UI/action-wheel-up.png\" },\n    { name: \"action-wheel-upper-left\", type:\"image\", src: \"data/img/assets/UI/action-wheel-upper-left.png\" },\n    { name: \"action-wheel-left\", type:\"image\", src: \"data/img/assets/UI/action-wheel-left.png\" },\n\n    { name: \"dst-gameforest\", type: \"audio\", src: \"data/bgm/\" },\n\n    { name: \"cling\",     type: \"audio\", src: \"data/sfx/\" },\n    { name: \"die\",       type: \"audio\", src: \"data/sfx/\" },\n    { name: \"enemykill\", type: \"audio\", src: \"data/sfx/\" },\n    { name: \"jump\",      type: \"audio\", src: \"data/sfx/\" },\n\n    { name: \"texture\",   type: \"json\",  src: \"data/img/texture.json\" },\n    { name: \"texture\",   type: \"image\", src: \"data/img/texture.png\" },\n\n    { name: \"PressStart2P\", type:\"image\", src: \"data/fnt/PressStart2P.png\" },\n    { name: \"PressStart2P\", type:\"binary\", src: \"data/fnt/PressStart2P.fnt\"}\n];</code></pre> \n<p>其中你可以使用诸如图块集、屏幕映射之类的东西（请注意，名称始终是不带扩展名的文件名，这是强制性的要求，否则将找不到资源）。</p> \n<h3>硬币</h3> \n<p>游戏中的硬币非常简单，但是当你与它们碰撞时，需要发生一些事情，它们的代码如下所示：</p> \n<pre><code class=\"javascript\">game.CoinEntity = me.CollectableEntity.extend({\n\n    /**\n     * constructor\n     */\n    init: function (x, y, settings) {\n        // call the super constructor\n        this._super(me.CollectableEntity, \"init\", [\n            x, y ,\n            Object.assign({\n                image: game.texture,\n                region : \"coin.png\"\n            }, settings)\n        ]);\n\n    },\n\n    /**\n     * collision handling\n     */\n    onCollision : function (/*response*/) {\n\n        // do something when collide\n        me.audio.play(\"cling\", false);\n        // give some score\n        game.data.score += Constants.SCORES.COIN\n\n        //avoid further collision and delete it\n        this.body.setCollisionMask(me.collision.types.NO_OBJECT);\n\n        me.game.world.removeChild(this);\n\n        return false;\n    }\n});</code></pre> \n<p>请注意，硬币实体实际上是扩展了 <code>CollectibleEntity</code> （这给它提供了一个特殊的冲撞类型给实体，因此melonJS知道在玩家移过它时会调用碰撞处理程序），你要做的就是调用其父级的构造函数，然后当你拾起它时,在 <code>onCollision</code> 方法上会播放声音，在全局得分中加 1，最后从世界中删除对象。</p> \n<h2>成品</h2> \n<p>将所有内容放在一起，就有了一个可以正常工作的游戏，该游戏可以让你根据输入的单词在 5 个不同的方向上移动。</p> \n<p>它看起来应该像这样：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbzqFK?w=677&amp;h=358\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>并且由于本教程已经太长了，你可以在 <a href=\"https://github.com/deleteman/plaformer-sample-1\" rel=\"nofollow noreferrer\">Github</a> 上查看该游戏的完整代码。</p> \n<hr> \n<h4>本文首发微信公众号：前端先锋</h4> \n<h4>欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章</h4> \n<h2><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVRyYe?w=430&amp;h=430\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章\" title=\"欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章\"></span></h2> \n<h3>欢迎继续阅读本专栏其它高赞文章：</h3> \n<ul> \n <li><a href=\"https://segmentfault.com/a/1190000019115050\">深入理解Shadow DOM v1</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019135847\">一步步教你用 WebVR 实现虚拟现实游戏</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019154021\">13个帮你提高开发效率的现代CSS框架</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019085935\">快速上手BootstrapVue</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019205065\">JavaScript引擎是如何工作的？从调用栈到Promise你需要知道的一切</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019216390\">WebSocket实战：在 Node 和 React 之间进行实时通信</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019315509\">关于 Git 的 20 个面试题</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019302858\">深入解析 Node.js 的 console.log</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019283751\">Node.js 究竟是什么？</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019268920\">30分钟用Node.js构建一个API服务器</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018903274\">Javascript的对象拷贝</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018224157\">程序员30岁前月薪达不到30K，该何去何从</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018646425\">14个最好的 JavaScript 数据可视化库</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018439250\">8 个给前端的顶级 VS Code 扩展插件</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018660861\">Node.js 多线程完全指南</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018701596\">把HTML转成PDF的4个方案及实现</a></li> \n</ul> \n<hr> \n<ul>\n <li><a href=\"http://blog.yidengxuetang.com/\" rel=\"nofollow noreferrer\">更多文章...</a></li>\n</ul>', 'https://segmentfault.com/img/bVbzqEU?w=650&amp;h=355', '6fbfa4aaad3a43458f21c8acf0038ac5', 'd79254c4ca5e45dca9d484307c935281,a4f4fd7a73b84a7298db0174165eeaac,401f1c4dcfbc499e8f7129c091c299f8,d16a93d83052441a90afaa57d69fdc3c', '0', '3', '1', '2020-04-16 16:57:51', '2020-04-16 16:57:51');
INSERT INTO `tb_recommend` VALUES ('ba42f07312e94d3085e689b3f9f6f9e2', '硬核干货！QPS、TPS、并发用户数、吞吐量关系', 'QPS Queries Per Second  是每秒查询率 ,是一台服务器每秒能够相应的查询次数，是对一个特定的查询服务器在规定时间内所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。', '<h3><strong>1、QPS</strong></h3> \n<hr> \n<p><strong>QPS</strong>&nbsp;<code>Queries Per Second</code>&nbsp; 是每秒查询率 ,是<strong>一台服务器</strong>每秒能够相应的查询次数，是对一个特定的查询服务器<strong>在规定时间内</strong>所处理流量多少的衡量标准, 即每秒的响应请求数，也即是最大吞吐能力。</p> \n<h3><strong>2、TPS</strong></h3> \n<hr> \n<p><strong>TPS&nbsp;</strong><code>Transactions Per Second</code>也就是事务数/秒。一个事务是指一个客户机向服务器发送请求然后服务器做出反应的过程。客户机在发送请求时开始计时，收到服务器响应后结束计时，以此来计算使用的时间和完成的事务个数， </p> \n<p><strong>3、QPS和TPS区别</strong></p> \n<hr> \n<p>个人理解如下： </p> \n<p>1、Tps即每秒处理事务数，包括了</p> \n<ul> \n <li>用户请求服务器&nbsp;&nbsp;</li> \n <li>服务器自己的内部处理&nbsp;&nbsp;</li> \n <li>服务器返回给用户</li> \n</ul> \n<p>这三个过程，每秒能够完成N个这三个过程，Tps也就是N；</p> \n<p>2、Qps基本类似于Tps，但是不同的是，对于一个页面的一次访问，形成一个Tps；但一次页面请求，可能产生多次对服务器的请求，服务器对这些请求，就可计入“Qps”之中。</p> \n<p><strong>例子：</strong></p> \n<blockquote>\n 例如：访问一个页面会请求服务器3次，一次放，产生一个“T”，产生3个“Q”\n <p>例如：一个大胃王一秒能吃10个包子，一个女孩子0.1秒能吃1个包子，那么他们是不是一样的呢？答案是否定的，因为这个女孩子不可能在一秒钟吃下10个包子，她可能要吃很久。这个时候这个大胃王就相当于TPS，而这个女孩子则是QPS。虽然很相似，但其实是不同的。</p> \n</blockquote> \n<p><strong>4、并发数</strong></p> \n<hr> \n<p>并发数（并发度）：指系统同时能处理的请求数量，同样反应了系统的负载能力。这个数值可以分析机器1s内的访问日志数量来得到</p> \n<h3><strong>5、吐吞量</strong></h3> \n<hr> \n<p>吞吐量是指系统在单位时间内处理请求的数量，TPS、QPS都是吞吐量的常用量化指标。 </p> \n<p><strong>系统吞吐量要素</strong></p> \n<p>一个系统的吞吐量（承压能力）与request（请求）对cpu的消耗，外部接口，IO等等紧密关联。</p> \n<p>单个request 对cpu消耗越高，外部系统接口，IO影响速度越慢，系统吞吐能力越低，反之越高。</p> \n<p><strong>重要参数</strong> </p> \n<p>QPS(TPS),并发数，响应时间</p> \n<ul> \n <li>QPS(TPS)：每秒钟request/事务 数量</li> \n <li>并发数：系统同时处理的request/事务数</li> \n <li>响应时间：一般取平均响应时间</li> \n</ul> \n<p><strong>关系</strong></p> \n<p>QPS(TPS)=并发数/平均响应时间 </p> \n<p>一个系统吞吐量通常有QPS(TPS),并发数两个因素决定，每套系统这个两个值都有一个相对极限值，在应用场景访问压力下，只要某一项达到系统最高值，系统吞吐量就上不去了，如果压力继续增大，系统的吞吐量反而会下降，原因是系统超负荷工作，上下文切换，内存等等其他消耗导致系统性能下降。</p> \n<h3><strong>6、PV</strong></h3> \n<hr> \n<p><strong>PV</strong>（Page View）：页面访问量，即页面浏览量或点击量，用户每次刷新即被计算一次。可以统计服务一天的访问日志得到。&nbsp;</p> \n<h3><strong>7、UV&nbsp;</strong></h3> \n<hr> \n<p><strong>UV</strong>（Unique Visitor）：独立访客，统计1天内访问某站点的用户数。可以统计服务一天的访问日志并根据用户的唯一标识去重得到。响应时间（RT）：响应时间是指系统对请求作出响应的时间，一般取平均响应时间。可以通过Nginx、Apache之类的Web Server得到。&nbsp;</p> \n<h3><strong>8、DAU</strong></h3> \n<hr> \n<p><strong>DAU</strong>(Daily Active User)，日活跃用户数量。常用于反映网站、互联网应用或网络游戏的运营情况。DAU通常统计一日（统计日）之内，登录或使用了某个产品的用户数（去除重复登录的用户），与UV概念相似&nbsp;</p> \n<h3><strong>9、MAU</strong></h3> \n<hr> \n<p><strong>MAU</strong>(Month Active User)：月活跃用户数量，指网站、app等去重后的月活跃用户数量</p> \n<h2><strong>10、系统吞吐量评估</strong></h2> \n<hr> \n<p>我们在做系统设计的时候就需要考虑CPU运算，IO，外部系统响应因素造成的影响以及对系统性能的初步预估。 </p> \n<p>而通常情况下，我们面对需求，我们评估出来的出来QPS，并发数之外，还有另外一个维度：日pv。</p> \n<p>通过观察系统的访问日志发现，在用户量很大的情况下，各个时间周期内的同一时间段的访问流量几乎一样。比如工作日的每天早上。只要能拿到日流量图和QPS我们就可以推算日流量。</p> \n<p>通常的技术方法：</p> \n<p>1、找出系统的最高TPS和日PV，这两个要素有相对比较稳定的关系（除了放假、季节性因素影响之外）</p> \n<p>2、通过压力测试或者经验预估，得出最高TPS，然后跟进1的关系，计算出系统最高的日吞吐量。B2B中文和淘宝面对的客户群不一样，这两个客户群的网络行为不应用，他们之间的TPS和PV关系比例也不一样。</p> \n<h2><strong>11、软件性能测试的基本概念和计算公式</strong></h2> \n<hr> \n<p><strong>软件做性能测试时需要关注哪些性能呢？</strong> </p> \n<p>首先，开发软件的目的是为了让用户使用，我们先站在用户的角度分析一下，用户需要关注哪些性能。</p> \n<p>对于用户来说，当点击一个按钮、链接或发出一条指令开始，到系统把结果已用户感知的形式展现出来为止，这个过程所消耗的时间是用户对这个软件性能的直观印 象。也就是我们所说的响应时间，当相应时间较小时，用户体验是很好的，当然用户体验的响应时间包括个人主观因素和客观响应时间，在设计软件时，我们就需要 考虑到如何更好地结合这两部分达到用户最佳的体验。如：用户在大数据量查询时，我们可以将先提取出来的数据展示给用户，在用户看的过程中继续进行数据检 索，这时用户并不知道我们后台在做什么。</p> \n<p>用户关注的是用户操作的相应时间。</p> \n<p>其次，我们站在管理员的角度考虑需要关注的性能点。</p> \n<p>1、 响应时间 <br>2、 服务器资源使用情况是否合理 <br>3、 应用服务器和数据库资源使用是否合理 <br>4、 系统能否实现扩展 <br>5、 系统最多支持多少用户访问、系统最大业务处理量是多少 <br>6、 系统性能可能存在的瓶颈在哪里 <br>7、 更换那些设备可以提高性能 <br>8、 系统能否支持7×24小时的业务访问</p> \n<p>再次，站在开发（设计）人员角度去考虑。</p> \n<p>1、 架构设计是否合理 <br>2、 数据库设计是否合理 <br>3、 代码是否存在性能方面的问题 <br>4、 系统中是否有不合理的内存使用方式 <br>5、 系统中是否存在不合理的线程同步方式 <br>6、 系统中是否存在不合理的资源竞争</p> \n<blockquote>\n 来源：&nbsp;\n <br>\n <a href=\"https://juejin.im/post/5c2cb5e15188257a937fbfaf?utm_source=gold_browser_extension\" rel=\"nofollow noreferrer\">https://juejin.im/post/5c2cb5...</a> \n</blockquote> \n<p>最新整理的&nbsp;<strong>2TB</strong>&nbsp;技术干货：包括<strong>架构师实战教程、大数据、Docker容器、系统运维、数据库、redis、MogoDB、电子书、Java基础课程、Java实战项目、ELK Stack、机器学习、BAT面试精讲视频</strong>等。只需在<strong>「&nbsp;</strong><strong>民工哥技术之路」</strong>微信公众号对话框回复关键字：<strong>1024</strong>即可获取全部资料。</p>', null, '5ca4567d892841b087fac5246effac40', 'd7416e100af54eb7a4d9274b9a462240,77a7bd638e0a45ec84569ef6b79325c1,81a4561c1c294e0cae32c9fe6b5dc397,f0e336796bd94b8299ef69b2b2529ec4,f2fb7d236fec4c138cacd9162eb4488c', '0', '3', '1', '2020-04-16 16:58:54', '2020-04-16 16:58:54');
INSERT INTO `tb_recommend` VALUES ('bd7b6708850149dcbf2809f3da35644b', 'Tomcat相关面试题，看这篇就够了！保证能让面试官颤抖！', 'Tomcat相关的面试题出场的几率并不高，正式因为如此，很多人忽略了对Tomcat相关技能的掌握，下面这一篇文章最早发布在知识星球，整理了Tomcat相关的系统架构，介绍了Server、Service、Connector、Container之间的...', '<p>Tomcat相关的面试题出场的几率并不高，正式因为如此，很多人忽略了对Tomcat相关技能的掌握，下面这一篇文章最早发布在知识星球，整理了Tomcat相关的系统架构，介绍了Server、Service、Connector、Container之间的关系，各个模块的功能，可以说把这几个掌握住了，Tomcat相关的面试题你就不会有任何问题了！另外，在面试的时候你还要有意识无意识的往Tomcat这个地方引，就比如说常见的Spring MVC的执行流程，一个URL的完整调用链路，这些相关的题目你是可以再往Tomcat处理请求的这个过程去说的！掌握注Tomcat这些技能了，面试官一定会佩服你的！</p> \n<p>学了本节之后你应该明白的是：</p> \n<ul> \n <li>Server、Service、Connector、Container四大组件之间的关系和联系，以及他们的主要功能点；</li> \n <li>Tomcat执行的整体架构，请求是如何被一步步处理的；</li> \n <li>Engine、Host、Context、Wrapper相关的概念关系；</li> \n <li>Container是如何处理请求的；</li> \n <li>Tomcat用到的相关设计模式；</li> \n</ul> \n<h2><strong>一、Tomcat顶层架构</strong></h2> \n<p>俗话说，站在巨人的肩膀上看世界，一般学习的时候也是先总览一下整体，然后逐个部分个个击破，最后形成思路，了解具体细节，Tomcat的结构很复杂，但是 Tomcat 非常的模块化，找到了 Tomcat最核心的模块，问题才可以游刃而解，了解了Tomcat的整体架构对以后深入了解Tomcat来说至关重要！</p> \n<p>先上一张Tomcat的顶层结构图（图A），如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393429\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Tomcat中最顶层的容器是Server，代表着整个服务器，从上图中可以看出，一个Server可以包含至少一个Service，用于具体提供服务。</p> \n<p>Service主要包含两个部分：Connector和Container。从上图中可以看出 Tomcat 的心脏就是这两个组件，他们的作用如下：</p> \n<p>1、Connector用于处理连接相关的事情，并提供Socket与Request和Response相关的转化;&nbsp;</p> \n<p>2、Container用于封装和管理Servlet，以及具体处理Request请求；</p> \n<p><strong>一个Tomcat中只有一个Server，一个Server可以包含多个Service，一个Service只有一个Container，但是可以有多个Connectors，这是因为一个服务可以有多个连接，如同时提供Http和Https链接，</strong>也可以提供向相同协议不同端口的连接,示意图如下（Engine、Host、Context下边会说到）：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393431\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>多个 Connector 和一个 Container 就形成了一个 Service，有了 Service 就可以对外提供服务了，但是 Service 还要一个生存的环境，必须要有人能够给她生命、掌握其生死大权，那就非 Server 莫属了</strong>！所以整个 Tomcat 的生命周期由 Server 控制。</p> \n<p>另外，上述的包含关系或者说是父子关系，都可以在tomcat的conf目录下的<code>server.xml</code>配置文件中看出，下图是删除了注释内容之后的一个完整的<code>server.xml</code>配置文件（Tomcat版本为8.0）</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393433\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>详细的配置文件文件内容可以到Tomcat官网查看：</p> \n<p><a href=\"http://tomcat.apache.org/tomcat-8.0-doc/index.html\" rel=\"nofollow noreferrer\">http://tomcat.apache.org/tomc...</a></p> \n<p>上边的配置文件，还可以通过下边的一张结构图更清楚的理解：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393430\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Server标签设置的端口号为8005，shutdown=”SHUTDOWN” ，表示在8005端口监听“SHUTDOWN”命令，如果接收到了就会关闭Tomcat。一个Server有一个Service，当然还可以进行配置，一个Service有多个，Service左边的内容都属于Container的，Service下边是Connector。</p> \n<h2><strong>二、Tomcat顶层架构小结：</strong></h2> \n<p>（1）Tomcat中只有一个Server，一个Server可以有多个Service，一个Service可以有多个Connector和一个Container；&nbsp; <br>（2） Server掌管着整个Tomcat的生死大权；&nbsp; <br>（4）Service 是对外提供服务的；&nbsp; <br>（5）Connector用于接受请求并将请求封装成Request和Response来具体处理；&nbsp; <br>（6）Container用于封装和管理Servlet，以及具体处理request请求；</p> \n<p>知道了整个Tomcat顶层的分层架构和各个组件之间的关系以及作用，对于绝大多数的开发人员来说Server和Service对我们来说确实很远，而我们开发中绝大部分进行配置的内容是属于Connector和Container的，所以接下来介绍一下Connector和Container。</p> \n<h2><strong>三、Connector和Container的微妙关系</strong></h2> \n<p>由上述内容我们大致可以知道一个请求发送到Tomcat之后，首先经过Service然后会交给我们的Connector，Connector用于接收请求并将接收的请求封装为Request和Response来具体处理，Request和Response封装完之后再交由Container进行处理，Container处理完请求之后再返回给Connector，最后在由Connector通过Socket将处理的结果返回给客户端，这样整个请求的就处理完了！</p> \n<p>Connector最底层使用的是Socket来进行连接的，Request和Response是按照HTTP协议来封装的，所以Connector同时需要实现TCP/IP协议和HTTP协议！</p> \n<p>Tomcat既然处理请求，那么肯定需要先接收到这个请求，接收请求这个东西我们首先就需要看一下Connector！</p> \n<h2><strong>四、Connector架构分析</strong></h2> \n<p>Connector用于接受请求并将请求封装成Request和Response，然后交给Container进行处理，Container处理完之后在交给Connector返回给客户端。</p> \n<p>因此，我们可以把Connector分为四个方面进行理解：</p> \n<p>（1）Connector如何接受请求的？&nbsp;</p> \n<p>（2）如何将请求封装成Request和Response的？&nbsp;</p> \n<p>（3）封装完之后的Request和Response如何交给Container进行处理的？&nbsp;</p> \n<p>（4）Container处理完之后如何交给Connector并返回给客户端的？</p> \n<p>首先看一下Connector的结构图（图B），如下所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393432\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Connector就是使用ProtocolHandler来处理请求的，不同的ProtocolHandler代表不同的连接类型，比如：Http11Protocol使用的是普通Socket来连接的，Http11NioProtocol使用的是NioSocket来连接的。</p> \n<p>其中ProtocolHandler由包含了三个部件：Endpoint、Processor、Adapter。</p> \n<p>（1）Endpoint用来处理底层Socket的网络连接，Processor用于将Endpoint接收到的Socket封装成Request，Adapter用于将Request交给Container进行具体的处理。</p> \n<p>（2）Endpoint由于是处理底层的Socket网络连接，因此Endpoint是用来实现TCP/IP协议的，而Processor用来实现HTTP协议的，Adapter将请求适配到Servlet容器进行具体的处理。</p> \n<p>（3）Endpoint的抽象实现AbstractEndpoint里面定义的Acceptor和AsyncTimeout两个内部类和一个Handler接口。Acceptor用于监听请求，AsyncTimeout用于检查异步Request的超时，Handler用于处理接收到的Socket，在内部调用Processor进行处理。</p> \n<p>至此，我们应该很轻松的回答（1）（2）（3）的问题了，但是（4）还是不知道，那么我们就来看一下Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？</p> \n<h2><strong>五、Container架构分析</strong></h2> \n<p>Container用于封装和管理Servlet，以及具体处理Request请求，在Connector内部包含了4个子容器，结构图如下（图C）：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393434\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>4个子容器的作用分别是：</p> \n<p>（1）Engine：引擎，用来管理多个站点，一个Service最多只能有一个Engine；&nbsp;</p> \n<p>（2）Host：代表一个站点，也可以叫虚拟主机，通过配置Host就可以添加站点；&nbsp;</p> \n<p>（3）Context：代表一个应用程序，对应着平时开发的一套程序，或者一个WEB-INF目录以及下面的web.xml文件；&nbsp;</p> \n<p>（4）Wrapper：每一Wrapper封装着一个Servlet；</p> \n<p>下面找一个Tomcat的文件目录对照一下，如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393436\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Context和Host的区别是Context表示一个应用，我们的Tomcat中默认的配置下webapps下的每一个文件夹目录都是一个Context，其中ROOT目录中存放着主应用，其他目录存放着子应用，而整个webapps就是一个Host站点。</p> \n<p>我们访问应用Context的时候，如果是ROOT下的则直接使用域名就可以访问，例如：www.ledouit.com,如果是Host（webapps）下的其他应用，则可以使用www.ledouit.com/docs进行访问，当然默认指定的根应用（ROOT）是可以进行设定的，只不过Host站点下默认的主营用是ROOT目录下的。</p> \n<p>看到这里我们知道Container是什么，但是还是不知道Container是如何进行处理的以及处理完之后是如何将处理完的结果返回给Connector的？别急！下边就开始探讨一下Container是如何进行处理的！</p> \n<h2><strong>六、Container如何处理请求的</strong></h2> \n<p>Container处理请求是使用Pipeline-Valve管道来处理的！（Valve是阀门之意）</p> \n<p>Pipeline-Valve是责任链模式，责任链模式是指在一个请求处理的过程中有很多处理者依次对请求进行处理，每个处理者负责做自己相应的处理，处理完之后将处理后的请求返回，再让下一个处理者继续处理。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393435\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>但是！Pipeline-Valve使用的责任链模式和普通的责任链模式有些不同！区别主要有以下两点：</p> \n<p>（1）每个Pipeline都有特定的Valve，而且是在管道的最后一个执行，这个Valve叫做BaseValve，BaseValve是不可删除的；</p> \n<p>（2）在上层容器的管道的BaseValve中会调用下层容器的管道。</p> \n<p>我们知道Container包含四个子容器，而这四个子容器对应的BaseValve分别在：StandardEngineValve、StandardHostValve、StandardContextValve、StandardWrapperValve。</p> \n<p>Pipeline的处理流程图如下（图D）：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022393437\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>（1）Connector在接收到请求后会首先调用最顶层容器的Pipeline来处理，这里的最顶层容器的Pipeline就是EnginePipeline（Engine的管道）；</p> \n<p>（2）在Engine的管道中依次会执行EngineValve1、EngineValve2等等，最后会执行StandardEngineValve，在StandardEngineValve中会调用Host管道，然后再依次执行Host的HostValve1、HostValve2等，最后在执行StandardHostValve，然后再依次调用Context的管道和Wrapper的管道，最后执行到StandardWrapperValve。</p> \n<p>（3）当执行到StandardWrapperValve的时候，会在StandardWrapperValve中创建FilterChain，并调用其doFilter方法来处理请求，这个FilterChain包含着我们配置的与请求相匹配的Filter和Servlet，其doFilter方法会依次调用所有的Filter的doFilter方法和Servlet的service方法，这样请求就得到了处理！</p> \n<p>（4）当所有的Pipeline-Valve都执行完之后，并且处理完了具体的请求，这个时候就可以将返回的结果交给Connector了，Connector在通过Socket的方式将结果返回给客户端。</p> \n<h2><strong>七、总结</strong></h2> \n<p>至此，我们已经对Tomcat的整体架构有了大致的了解，从图A、B、C、D可以看出来每一个组件的基本要素和作用。我们在脑海里应该有一个大概的轮廓了！如果你面试的时候，让你简单的聊一下Tomcat，上面的内容你能脱口而出吗？当你能够脱口而出的时候，这位面试官一定会对你刮目相看的！</p>', 'https://segmentfault.com/img/remote/1460000022393429', '1c5851dc916d4e70a60f0c957f548876', '55723db96b9f4593bae02bc1e49f1e87,2294832fe5104d73ace4f14ad9549018,d7416e100af54eb7a4d9274b9a462240,81a4561c1c294e0cae32c9fe6b5dc397,40a18ee9514e46b28a96cc182f4f8df2', '0', '3', '1', '2020-04-16 16:48:52', '2020-04-16 16:48:52');
INSERT INTO `tb_recommend` VALUES ('bdb42f526ff149519d49911b1f2b8d96', '图解你身边的 SOLID 原则', '这篇文章我们来简单介绍一下 SOLID 原则（这五个字母代表了面向对象编程的五个基本原则） 我们用身边的事物来举例，让它们更易于理解和记忆。 好啦，开始吧~ S - 单一职责原则 Single Responsibllity Principle -...', '<p>这篇文章我们来简单介绍一下 <a href=\"https://en.wikipedia.org/wiki/Single_responsibility_principle\" rel=\"nofollow noreferrer\">SOLID</a> 原则（这五个字母代表了面向对象编程的五个基本原则）</p> \n<p>我们用身边的事物来举例，让它们更易于理解和记忆。</p> \n<p>好啦，开始吧~</p> \n<h2>S - 单一职责原则</h2> \n<blockquote>\n Single Responsibllity Principle - 即 \n <a href=\"https://en.wikipedia.org/wiki/Single_responsibility_principle\" rel=\"nofollow noreferrer\">SRP</a> \n</blockquote> \n<p>一个类只能承担一个职责。通俗点儿说就是一个类只能承担一件事，并且只能有一个潜在的原因去更改这个类，否则就违反了单一职责原则。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022384757\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"1_s.jpg\" title=\"1_s.jpg\"></span></p> \n<h2>O - 开闭原则</h2> \n<blockquote>\n Open/Closed Principle - 即 \n <a href=\"https://en.wikipedia.org/wiki/Open/closed_principle\" rel=\"nofollow noreferrer\">OCP</a> \n</blockquote> \n<p>软件实体应该对 <strong>扩展</strong> 开放，对 <strong>修改</strong> 关闭。允许扩展行为而无需修改源代码。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022384754\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"2_o.jpg\" title=\"2_o.jpg\"></span></p> \n<h2>L - 里氏替换原则</h2> \n<blockquote>\n Liskov Substitution Principle - 即 \n <a href=\"https://en.wikipedia.org/wiki/Liskov_substitution_principle\" rel=\"nofollow noreferrer\">LSP</a> \n</blockquote> \n<p>程序中的对象应该可以被其子类实例替换掉，而不会影响程序的正确性。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022384756\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"3_l.jpg\" title=\"3_l.jpg\"></span></p> \n<h2>I - 接口隔离原则</h2> \n<blockquote>\n Interface Segregation Principle - 即 \n <a href=\"https://en.wikipedia.org/wiki/Interface_segregation_principle\" rel=\"nofollow noreferrer\">ISP</a> \n</blockquote> \n<p>使用多个特定细分的接口比单一的总接口要好，不能强迫用户去依赖他们用不到的接口。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022384755\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"4_i.jpg\" title=\"4_i.jpg\"></span></p> \n<h2>D - 依赖倒置原则</h2> \n<blockquote>\n Dependency Inversion Principle - \n <a href=\"https://en.wikipedia.org/wiki/Dependency_inversion_principle\" rel=\"nofollow noreferrer\">DIP</a> \n</blockquote> \n<p>程序要依赖于抽象接口，而不是具体实现。</p> \n<ul> \n <li>高层模块不应该依赖于低层模块，二者都应该依赖于抽象</li> \n <li>抽象不应该依赖具体实现，具体实现应该依赖抽象</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022384758\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"5_d.jpg\" title=\"5_d.jpg\"></span></p> \n<p>插头不应该依赖具体某种电线，它只需要有线并且能导电。</p> \n<p>全文完~希望本文对你理解 SOLID 有帮助啦~</p> \n<h2>参考文章</h2> \n<ul> \n <li><a href=\"https://dev.to/trekhleb/s-o-l-i-d-principles-around-you-1o17\" rel=\"nofollow noreferrer\">S.O.L.I.D. Principles Around You</a></li> \n <li><a href=\"https://en.wikipedia.org/wiki/SOLID\" rel=\"nofollow noreferrer\">SOLID 维基百科</a></li> \n <li><a href=\"https://en.wikipedia.org/wiki/Single_responsibility_principle\" rel=\"nofollow noreferrer\">SRP 维基百科</a></li> \n <li><a href=\"https://en.wikipedia.org/wiki/Open/closed_principle\" rel=\"nofollow noreferrer\">OCP 维基百科</a></li> \n <li><a href=\"https://en.wikipedia.org/wiki/Liskov_substitution_principle\" rel=\"nofollow noreferrer\">LSP 维基百科</a></li> \n <li><a href=\"https://en.wikipedia.org/wiki/Interface_segregation_principle\" rel=\"nofollow noreferrer\">ISP 维基百科</a></li> \n <li><a href=\"https://en.wikipedia.org/wiki/Dependency_inversion_principle\" rel=\"nofollow noreferrer\">DIP 维基百科</a></li> \n</ul> \n<hr> \n<p>本文首发于公众号：<strong>码力全开</strong>（codingonfire）</p> \n<blockquote>\n <strong>本文随意转载哈，注明原文链接即可，公号文章转载联系我开白名单就好~</strong>\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022384759\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"codingonfire.jpg\" title=\"codingonfire.jpg\"></span></p>', 'https://segmentfault.com/img/remote/1460000022384757', '1894b118d35d44cb8fe8009529c4154b', 'd79254c4ca5e45dca9d484307c935281,63c4e1e7ec204b43a62065a3ced4c2ce,5bc240f3bc174167bf6eaa745d97c6ae,c8cd9b29a54f4d27bee226951a981924', '0', '3', '1', '2020-04-16 16:48:04', '2020-04-16 16:48:04');
INSERT INTO `tb_recommend` VALUES ('be6ab488fa674af7bbb85fc512323eef', 'CPU Cache 基础解析', '文末含分享内容视频链接 CPU Cache 基础 最近看了一些 CPU 缓存相关的东西，在这里做一下记录。 Wiki 词条：CPU cache - Wikipedia 一些基本概念 CPU 缓存出现的原因 主存一般是 DRAM，CPU 速度比主存快很多倍，...', '<blockquote>\n 文末含分享内容视频链接\n</blockquote> \n<h1>CPU Cache 基础</h1> \n<p>最近看了一些 CPU 缓存相关的东西，在这里做一下记录。</p> \n<p>Wiki 词条：<a href=\"https://en.wikipedia.org/wiki/CPU_cache\" rel=\"nofollow noreferrer\">CPU cache - Wikipedia</a></p> \n<h2>一些基本概念</h2> \n<h4>CPU 缓存出现的原因</h4> \n<ol> \n <li>主存一般是 DRAM，CPU 速度比主存快很多倍，没有缓存存在时 CPU 性能很大程度取决于读取存储数据的能力</li> \n <li>比 DRAM 快的存储介质是存在的，比如作为 CPU 高速缓存的 SRAM，只是很贵，做很大的 SRAM 不经济</li> \n <li>CPU 访问数据存在时间局部性和空间局部性，所以可以将 CPU 需要频繁访问的少量热数据放在速度快但很贵的 SRAM 中，既能大幅度改善 CPU 性能也不会让成本提升太多</li> \n</ol> \n<h4>Cache Line</h4> \n<p>CPU 每次访问数据时先在缓存中查找一次，找不到则去主存找，访问完数据后会将数据存入缓存，以备后用。这就产生了一个问题，CPU 在访问某个地址的时候如何知道目标数据是在缓存中存在？如何知道缓存的数据是否还有效没被修改？不能为每个存入缓存的字节都打标记，所以 CPU 缓存会划分为固定大小的 Block 称为 Cache Line，作为存取数据的最小单位。大小都为 2 的整数幂，比如 16 字节，256 字节等。这样一个 cache line 这一整块内存能通过一个标记来记录是否在内存中，是否还有效，是否被修改等。一次存取一块数据也能充分利用总线带宽以及 CPU 访问的空间局部性。</p> \n<h4>Cache Write Policy</h4> \n<p>Cache 不光是在读取数据时有用，目前大部分 CPU 在写入数据时也会先写 Cache。一方面是因为新存数据很可能会被再次使用，新写数据先写 Cache 能提高缓存命中率；另一方面 CPU 写 Cache 速度更快，从而写完之后 CPU 可以去干别的事情，能提高性能。</p> \n<p>CPU 写数据如果 Cache 命中了，则为了保持 Cache 和主存一致有两种策略。如果 CPU 写 Cache 每次都要更新主存，则称为 <strong>Write-Through</strong> ，因为每次写 Cache 都伴随主存更新所以性能差，实际使用的也少；写 Cache 之后并不立即写主存而是等待一段时间能积累一些改动后再更新主存的策略称为 <strong>Write-Back</strong> ，性能更好但为了保证写入的数据不丢使机制更加复杂。采用 Write Back 方式被修改的内存在从 Cache 移出(比如 Cache 不够需要腾点空间)时，如果被修改的 Cache Line 还未写入主存需要在被移出 Cache 时更新主存，为了能分辨出哪些 Cache 是被修改过哪些没有，又需要增加一个新的标志位在 Cache Line 中去标识。</p> \n<p>CPU 写数据如果 Cache 未命中，则只能直接去更新主存。但更新完主存后又有两个选择，将刚修改的数据存入 Cache 还是不存。每次直接修改完主存都将主存被修改数据所在 Cache Line 存入 Cache 叫做 <strong>Write-Allocate</strong> 。需要注意的是 Cache 存取的最小单位是 Cache Line。即使 CPU 只写一个字节，也需要将被修改字节所在附近 Cache Line 大小的一块内存完整的读入 Cache。如果 CPU 写主存的数据超过一个 Cache Line 大小，则不用再读主存原来内容，直接将新修改数据写入 Cache。相当于完全覆盖主存之前的数据。</p> \n<p>写数据时除了需要考虑上述写 Cache 策略外，还需要保持各 CPU Cache 之间的一致性。比如一个 CPU 要向某个内存地址写数据，它需要通知其它所有 CPU 自己要写这个地址，如果其它 CPU 的 Cache Line 内有缓存这个地址的话，需要将这个 Cache Line 设置为 Invalidate。这样写数据的那个 CPU 就能安全的写数据了。下一次其它 CPU 要读这个内存地址时，发现这个 Cache Line 是 Invalidate 状态，所以需要重新从内存做加载，即发生一次 Communication Miss。这种 Miss 不是 Cache 不够大，也不是 Cache 冲突，而是因为其它 CPU 写同一个 Cache Line 里数据导致了 Cache Miss。缓存一致性维护需要专门文章来写。</p> \n<h4>SMP 和 NUMA</h4> \n<p>SMP 词条：<a href=\"https://en.wikipedia.org/wiki/Symmetric_multiprocessing\" rel=\"nofollow noreferrer\">Symmetric multiprocessing - Wikipedia</a><br>NUMA 词条：<a href=\"https://en.wikipedia.org/wiki/Non-uniform_memory_access\" rel=\"nofollow noreferrer\">Non-uniform memory access - Wikipedia</a></p> \n<p>简单说 SMP 就是一组 CPU 会通过一条总线共享机器内的内存、IO 等资源。因为所有东西都是共享的，所以扩展性受限。</p> \n<p>NUMA 则是将机器内 CPU 分为若干组，每个组内都有独立的内存，IO资源，组与组之间不相互共享内存和 IO 等资源，组之间通过专门的互联模块连接。总体上扩展性更强。</p> \n<p>本文主要以 SMP 系统为例。CPU 以及 Cache，Memory 的关系如下：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392216\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>CPU 缓存结构</h2> \n<h4>Direct Mapped Cache</h4> \n<p>最简单的缓存结构就是 Direct Mapped 结构。如下图所示，每个 Cache Line 由基本的 Valid 标志位，Tag 以及 Data 组成。当访问一个内存地址时，根据内存地址用 Hash 函数处理得到目标地址所在 Cache Line 的 Index。根据 Index 在 Cache 中找到对应 Cache Line 的 Data 数据，再从 Data 中根据内存地址的偏移量读取所需数据。因为 Hash 函数是固定的，所以每一个内存地址在缓存上对应固定的一块 Cache Line。所以是 Direct Mapped。</p> \n<p>实际中为了性能 hash 函数都非常简单，就是从内存地址读取固定的几个 bit 数据作为 Cache Line 的 Index。拿下图为例，Cache Line 大小为 4 字节，一共 32 bit 是图中的 Data 字段。4 字节一共需要 2 bit 用于寻址，所以看到 32 bit 的地址中，0 1 两个 bit 作为 Offset。2 ~ 11 bit 作为 Cache Line 的 Index 一共 1024 个，12 ~ 31 bit 作为 tag 用于区分映射到相同 Cache Line 的不同内存 block。比如现在要读取的地址是 0x1124200F，先从地址中取 2 ~ 11 bit 得到 0x03 表示目标 Cache Line 的 Index 是 3，之后从地址中读 12 ~ 31 bit 作为 tag 是 0x11242。拿这个 Tag 跟 Index 为 3 的 Cache Line 的 Tag 做比较看是否一致，一致则表示当前 Cache Line 中包含目标地址，不一致则表示当前 Cache Line 中没有目标地址。因为 Cache 比内存小很多，所以可能出现多个不在同一 Cache Line 的内存地址被映射到同一个 Cache Line 的情况，所以需要用 Tag 做区分。最后，如果目标地址确实在 Cache Line，且 Cache Line 的 Valid 为 true，则读取 0x1124200F 地址的 0 ~ 1 bit，即找目标数据在 Cache Line 内的 Offset，得到 0x03 表示读取当前 Cache Line 中最后一个字节的数据。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392215\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>上图的 Cache 是 1024 X 4 字节 一共 4 KB。但由于 Tag 和 Valid 的存在，缓存实际占用的空间还会更大。</p> \n<p><strong>替换策略</strong></p> \n<p>因为 Direct Mapped 方式下，每个内存在 Cache 中有固定的映射位置，所以新访问的数据要被存入 Cache 时，根据数据所在内存地址计算出 Index 发现该 Index 下已经存在有效的 Cache Line，需要将这个已存在的有效 Cache Line 从 Cache 中移出。如果采用 Write-Back 策略，移出时需要判断这个数据是否有被修改，被修改了需要更新主存。</p> \n<p>Write-Back 策略在前面有介绍，即写数据时只写缓存就立即返回，但标记缓存为 Dirty，之后在某个时间再将 Dirty 的缓存写入主存。</p> \n<h4>Two-way Set Associative Cache</h4> \n<p>我们希望缓存越大越好，越大的缓存经常意味着更快的执行速度。对于 Direct Mapped Cache 结构，增大缓存就是增加 Index 数量，相当于是对上面表进行纵向扩展。但除了纵向扩展之外，还可以横向扩展来增加 Cache 大小，这就是 Two-way Set Associative Cache。</p> \n<p>基本就是如下图所示，图上省略了 Tag 和 Valid 等标识每个 cell 就是一个 Cache Line，与 Direct Mapped Cache 不同点在于，Two-way Set Associative Cache 里每个 Index 对应了两个 Cache Line，每个 Cache Line 有自己的 Tag。同一个 index 下的两个 cache line 组成 Set。在访问内存时，先根据内存地址找到目标地址所在 Set 的 index，之后并发的去验证 Set 下的两个 Cache Line 的 Tag，验证目标地址是否在 Cache Line 内，在的话就读取数据，不在则去读主存。</p> \n<p>这里并发的验证两个 Cache Line 的 Tag 是由硬件来保证，硬件电路结构会更加复杂但查询效率与 Direct Mapped Cache 一致。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392218\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Set 内的两个 Cache Line 是具有相同 Index 的两个不同 Cache Line。上图来自 <a href=\"https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html\" rel=\"nofollow noreferrer\">Is Parallel Programming Hard, And, If So, What Can You Do About It?</a>，图 C.2。以这个图为例，假设 Cache Line 大小是 256 字节，所以图上所有地址最右侧都是 00，即有 8 bit 的 Offset，从 0 到 7。因为 Cache Line 只有 16 个，所以 index 是 4 bit，从 8 ~ 11。图中看到 0x12345E00 和 0x43210E00 在 8 ~ 11 bit 位置上是相同的，都是 0xE 所以这两个内存地址被映射到 Cache 中同一个 Index 下。这两个 Cache Line 就会放在同一个 Set 内，在访问时能同时被比较 Tag。</p> \n<p><strong>替换策略</strong></p> \n<p>新数据要存入 Cache 时，根据数据所在内存地址计算出 Index 后发现该 Index 下两个 Way 的 Cache Line 都已被占用且处在有效状态。需要有办法从这两个 Cache Line 里选一个出来移除。Direct Mapped 因为一个 Index 下只有一个 Cache Line 就没这个问题。</p> \n<p>如果是这里说的 Two-way Set Associative Cache 还比较好弄，给每个 Way 增加一个最近访问过的标识。每次一个 Way 被访问就将最近访问位置位，并清理另一个 Way 的最近访问位。从而在执行替换时，将不是最近访问过的那个 Way 移除。不过下面会看到 N-way Set Associative Cache 当有 N 个 Way 的时候替换策略更加复杂，一般是尽可能使用最少的状态信息实现近似的 LRU。</p> \n<h4>N-way Set Associative Cache</h4> \n<p>顾名思义，就是在 Two-way Set Associative Cache 基础上继续横向扩展，在一个 Set 内加入更多更多的 Way 也即 Cache Line。这些 Cache Line 能被并发的同时验证 Tag。如果 Cache 内所有的 Cache Line 都在同一个 Set 内，即所有 Cache Line 都能同时被验证 Tag，则这种 Cache 叫做 <strong>Fully Associative Cache</strong> 。可以看出 Fully Associative Cache 性能是最强的，能省去从地址中读取 Index 查找 Set 的过程。但横向扩展的 Way 越多，结构越复杂，成本越高，越难实现大的 Cache。所以 Fully Associative Cache 虽然存在，但都很小，一般用在 TLB 上。</p> \n<h4>Cache 结构为什么发展出横向扩展？</h4> \n<p>这个是我自己提出来的问题。对 Direct Mapped Cache 扩展 Cache 时就是增加更多的 index，让 cache 表变得更长。但为什么会发展出 Two-way Set Associative Cache 呢？比如如果一共 16 个 Cache Line，是 16 行 Cache Line 还是 8 行 Set 每个 Set 两个 Cache Line 在容量和命中率上似乎并没有差别。</p> \n<p>后来看到了 <a href=\"https://stackoverflow.com/questions/33314115/whats-the-difference-between-conflict-miss-and-capacity-miss\" rel=\"nofollow noreferrer\">这个问题</a> ，明白了其中的原因。主要是需要区分出来 Conflict Miss 和 Capacity Miss (还有一个 Communication Miss，前面说过)。当 Cache 容量足够，但由于两块不同的内存映射到了同一个 Cache Line，导致必须将老的内存块剔除产生的 Miss 叫做 Conflict Miss，即使整个 Cache 都是空的，只有这一个 Cache Line 有效时也会出现 Miss。而由于容量不足导致的 Miss 就是 Capacity Miss。比如 cache 只有 32k，访问的数据有 200k，那访问时候一定会出现后访问的数据不断的把先访问数据从 Cache 中顶出去，导致 Cache 一直处在 Miss 状态的问题。</p> \n<p>在 Capacity Miss 方面横向扩展和纵向扩展没有什么区别，主要区别就是 Conflict Miss。假若轮番访问 A B 两个内存，这两个内存映射到同一个 Cache Line 上，那对于 Direct Mapped Cache，因为每块内存只有固定的一个 Cache Line 能存放，则会出现持续的 Conflict Miss，称为 cache thrashing。而 Two-way Set Associative Cache 就能将 A B 两块内存放入同一个 Set 下，就都能 Cache 住，不会出现 Conflict Miss。这就是横向扩展的好处，也是为什么横向扩展即使困难，各个 CPU 都在向这个方向发展。并且横向扩展和纵向扩展并不冲突，Two-way Set Associative Cache 也能加多 Set 来进行扩展。</p> \n<h4>Cache Prefetching</h4> \n<p>词条：<a href=\"https://en.wikipedia.org/wiki/Cache_prefetching\" rel=\"nofollow noreferrer\">Cache prefetching - Wikipedia</a></p> \n<p>Cache 运作时并不一定每次只加载一条 Cache Line，而是可能根据程序运行状况，发现有一些固定模式比如 for loop 的时候在加载 Cache Line 时会多加载一点，类似于通过 Batch 来做优化一样。</p> \n<h2>为什么缓存存取速度比主存快</h2> \n<p><a href=\"https://www.quora.com/Why-is-SRAM-better-than-DRAM\" rel=\"nofollow noreferrer\">Why is SRAM better than DRAM? - Quora</a></p> \n<h2>False Sharing</h2> \n<p>Wiki 词条：<a href=\"https://en.wikipedia.org/wiki/False_sharing\" rel=\"nofollow noreferrer\">False sharing - Wikipedia</a></p> \n<p>比如像下面图这个样子：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392217\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>A B 两个对象在内存上被连续的创建在一起，假若这两个对象都很小，小于一个 Cache Line 大小，那他们可能会共用同一个 Cache Line。如果再有两个线程 Thread 1 和 Thread 2 会去操作这两个对象，我们从代码角度保证 Thread 1 只会操作 A，而 Thread2 只会操作 B。那按道理这两个 Thread 访问 A B 不该有相互影响，都能并行操作。但现在因为它俩刚好在同一个 Cache Line 内，就会出现 A B 对象所在 Cache Line 在两个 CPU 上来回搬迁的问题。</p> \n<p>比如 Thread 1 要修改对象 A，那 Thread 1 所在 CPU 1 会先获取 A 所在 Cache Line 的 Exclusive 权限，会发送 Invalidate 给其它 CPU 让其它 CPU 设置该 Cache Line 为无效。之后 Thread 2 要修改对象 B，Thread 2 所在 CPU 2 又会尝试获取 B 所在 Cache Line 的 Exclusive 权限，会发 Invalidate 给其它 CPU，包括 CPU 1。CPU 1 要是已经写完了 A，那就要把数据刷写内存，之后设置 Cache Line 无效并响应 Invalidate。没写完就得等待 CPU 1 写完 A 后再处理 Cache Line 的 Invalidate 问题。之后 CPU 2 再去操作 Cache Line 更新 B 对象。再后来 Thread 1 要去更新 A 对象的话又要去把 A B 所在 Cache Line 在 CPU 2 上设置无效。也就是说这块 Cache Line 失去了 Cache 功能，会在两个 CPU 上来回搬迁，会经常性的执行刷写内存，读取内存操作，导致两个本来看上去没有关系的操作实际上有相互干扰。</p> \n<p>想观测到这个现象最简单的是让 A B 是同一个类的不同 Field，而不是两个独立对象，比如：</p> \n<pre><code class=\"java\">class SomeClass{\n    volatile long valueA;\n    volatile long valueB;\n}</code></pre> \n<p>这个对象在内存上布局如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392219\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>看到这个 Object 只有 32 字节，在我机器上一个 Cache Line 是 64 字节 (mac 上执行 <code>sysctl machdep.cpu.cache.linesize</code>，Linux 上执行 <code>getconf LEVEL1_DCACHE_LINESIZE</code> 来查看)，所以 A B 都能放在同一个 Cache Line 上，之后可以创建出来两个 Thread 去分别操作同一个 SomeClass 对象的 valueA 和 valueB Field，记录一下时间，再跟下面解决方案里说的方式做对比，看看 False Sharing 的现象。</p> \n<h4>解决办法</h4> \n<p>解决这个问题的办法也很容易，如果是上面例子的话，就是让被操作的 valueA 和 valueB 隔得远一点。比如可以这么声明：</p> \n<pre><code class=\"java\">class SomeClassPadding {\n    volatile long valueA;\n    public long p01, p02, p03, p04, p05, p06, p07, p08;\n    volatile long valueB;\n}</code></pre> \n<p>对象内存布局就变成了：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392220\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>因为我确认我机器的 Cache Line 是 64 字节，所以加了 8 个 long。如果 Padding 少一些，比如 6 个，那 valueA 在 Offset 16，第六个 Padding 在 Offset 64，valueB 恰好是 Offset 64，似乎已经足够将 valueB 放到下一个 Cache Line 了但实际还是有问题。因为对象不一定刚好分配在 Cache Line 开头，比如 Cache Line 恰好从 valueA 所在 Offset 16 开始，到 Offset 80 结束，如果只有 6 个 <code>long</code> 做 Padding，那 valueA 和 valueB 还是在同一个 Cache Line 上。所以 Padding 至少需要和 Cache Line 一样长。</p> \n<p>还有要<strong>注意</strong>看到 Padding 得声明为 <code>public</code>，不然 JVM 发现这一堆 Padding 不可能被访问到可能就直接优化掉了。</p> \n<p>在我机器上测试，Padding 之后性能提升了大概 4 5 倍的样子。如果上面 <code>SomeClasPadding</code> 去掉 <code>volatile</code> 声明，则提升大概 1.5 倍的样子，之所以有这个差距是因为没有 <code>volatile</code> 的话线程操作 valueA 和 valueB 如果 Cache Line 不在当前 CPU Cache 中，它并不要求等待 Cache Line 加载进来后再做写入，而是可以把写入操作放在一个叫 <code>Store Buffer</code> 的地方以提高性能，具体可以关注我们的下一篇分享内容。等 Cache Line 加载后再对它做修改，相当于是将一段时间的写入操作积累了一下一口气写入。而有了 <code>volatile</code> 后则要求每次写入真的得等 Cache Line 加载后再写，从而放大了等待 Cache Line 加载的时间，更容易观察到 False Sharing 问题。</p> \n<p>另外，Padding 当然是有代价的。一个是让对象变得更大，占用内存，再有是 Padding 了一堆无用数据还得加载到 Cache 里，白白占用了 Cache 空间。</p> \n<p>需要注意的是自己手工 Padding 方法可能被虚拟机做重排，即 Padding 本来想加到 valueA 和 valueB 之间，但可能被重排到 valueB 之后，导致实际没有什么用。比如：</p> \n<pre><code class=\"java\">class SomeClassPadding {\n    volatile long valueA;\n    public int p01, p02, p03, p04, p05, p06, p07, p08;\n    volatile long valueB;\n}</code></pre> \n<p>实际的内存布局是下图这样，即 Padding 都跑到 valueB 后面去了。另外按说 Cache Line 是 64 字节的话用 <code>int</code> 做 Padding 至少要 16 个，我这里只是为了说明手工 Padding 的问题，所以少写了一些。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392221\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>内存布局实际会依赖虚拟机而不同，所以上面这种 Padding 方式是不可靠的。即使变量真声明为 <code>long</code> 也不能保证所有虚拟机都按照相同方式做排列。最靠谱的手工 Padding 方式是用 Class 的层级结构做 Padding，因为 JVM 要求父类的成员一定要排在子类成员之前，所以级联的 Class 结构能保证 Padding 的可靠性。比如：</p> \n<pre><code class=\"java\">class SomeClassValueA {\n    volatile long valueA;\n}\nclass SomeClassPaddings extends SomeClassValueA{\n    public int p01, p02, p03, p04, p05, p06, p07, p08, p09, p10, p11;\n}\nclass SomeClassValueB extends SomeClassPaddings{\n    volatile long valueB;\n}\nclass SomeClass extends SomeClassValueB{   \n}</code></pre> \n<p>内存结构就变成:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392222\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这里为了演示用 <code>int</code> 做 Padding，又不想让图片太长，所以只写了 11 个 <code>int</code>，但实际至少需要 16 个 <code>int</code> 即凑够 64 字节才行。一般 Padding 都用 <code>long</code> 做，不会用 <code>int</code>，可以少写很多变量。</p> \n<p>这个顺序是 JVM 规范保证的，所以所有虚拟机都会按照这个方式排列，所以是可靠的。</p> \n<p>另一个方法是用 <code>@Contentded</code> 注解，java 8 后开始支持，java 11 后 <code>Contended</code> 从 <code>sun.misc</code> 搬到了 <code> jdk.internal.misc</code>。它作用就是自动帮你做 Padding，它保证在任意 JVM 上都能有 Padding 效果，就不用我们再去构造 Class 级联结构了。比如上面例子中用 <code>@Contended</code> 就是：</p> \n<pre><code class=\"java\">class SomeClassContended {\n    volatile long valueA;\n    @Contended\n    volatile long valueB;\n}</code></pre> \n<p>它的内存结构在 HotSpot 64 下是:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392223\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>它是按 128 做 padding 的，它并没管我机器的 Cache Line 是多少，另外它是在 <code>valueB</code> 前后都做 Padding。这也是更推荐的方式。一般来说都尽力用 <code>@Contended</code> 注解了，除非为了兼容 Java 8 以下 JVM 或者为了性能，为了 Object 大小等原因，才可能会去手工做 Padding。</p> \n<p>上面内存结构是通过 <a href=\"https://plugins.jetbrains.com/plugin/10953-jol-java-object-layout\" rel=\"nofollow noreferrer\">JOL 插件</a> 来查看的，它里面用的<a href=\"https://openjdk.java.net/projects/code-tools/jol/\" rel=\"nofollow noreferrer\">OpenJDK: jol</a> 工具。</p> \n<p>False Sharing 测试的话可以参考 <a href=\"https://hg.openjdk.java.net/code-tools/jmh/file/b6f87aa2a687/jmh-samples/src/main/java/org/openjdk/jmh/samples/JMHSample_22_FalseSharing.java\" rel=\"nofollow noreferrer\">JMH 的例子</a> 写自己的测试。</p> \n<p>实际 Padding 例子，可以看看 Netty 4.1.48 下的 <a href=\"https://github.com/netty/netty/blob/netty-4.1.48.Final/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java#L125\" rel=\"nofollow noreferrer\">InternalThreadLocalMap</a>。</p> \n<h4>JVM 上这个问题常见吗</h4> \n<p>上面 False Sharing 的例子是我们故意构造而得到的，所以很容易复现，很容易观察到。但实际开发中让同一个对象里不同 Field 被多个线程同时访问的情况并不多。倒是有这种例子比如 <code>ConcurrentHashMap</code> 里用于计算元素总量的 <code>CounterCell</code> 类。不过这种场景并不是很多，而一般情况下，拿上面的 <code>SomeClass</code> 来举例，它更可能被声明为：</p> \n<pre><code class=\"java\">class SomeClass{\n    volatile long value;\n}\n\nSomeClass a = new SomeClass();\nSomeClass b = new SomeClass();</code></pre> \n<p>之后 Thread 1 和 Thread 2 分别去操作 <code>a</code>，<code>b</code> 两个对象。这种场景下，按说确实有 False Sharing 问题，但因为 <code>a</code>, <code>b</code> 对象都分配在 JVM 堆上，它俩得刚巧在堆上被连续创建出来，且在后续一系列 GC 中都一直能恰好挨在一起，才能持续的存在 False Sharing 问题。这么看来 False Sharing 似乎很难出现。比如我们测试时，让每个 Thread 都像上面这样 <code>new SomeClass()</code> 之后都操作自己 <code>new</code> 出来的 <code>SomeClass</code> 对象，我们会发现无论怎么测试，性能都和没有 False Sharing 时的性能一致，也即没有 False Sharing 问题。下面会说为什么这里没有 False Sharing。</p> \n<p>更进一步，即使是同一个 Class 内的不同 Field，如果不是普通变量而是引用，比如这样：</p> \n<pre><code class=\"java\">class SomeClass {\n    ObjectA valueA;\n    ObjectB valueB;\n}</code></pre> \n<p>两个 Thread 分别操作这两个引用，False Sharing 问题要求这两个引用恰好指向 JVM 堆上两个相邻对象，且两个对象得足够小，保证两个对象内被操作的值离得足够近，能放在同一个 Cache Line 上。想想每个对象都有 Object Header 也即天生就有至少 16 字节的 Padding 在，这也让被操作的值更不容易恰好在同一个 Cache Line 上。</p> \n<p>所以 False Sharing 问题在 JVM 上并不会特别常见。</p> \n<h4>TLAB，PLAB 可能会加重 False Sharing 问题</h4> \n<p>按说 False Sharing 问题不会很常见，不过 TLAB 和 PLAB 机制可能会增大它出现的几率。TLAB 全称 Thread Local Allocation Buffers，我并没有找到一个特别好的介绍，这个 Blog 马马虎虎能看看： <a href=\"https://dzone.com/articles/thread-local-allocation-buffers\" rel=\"nofollow noreferrer\">Introduction to Thread Local Allocation Buffers (TLAB) - DZone Java</a>。</p> \n<p>以下图为例，Java 分配内存通常一开始在 Eden 区分配，一个指针用来区分分配过的区域和还未分配的区域。每次分配内存都需要去移动这个指针来分配。如果所有线程分配内存时候都去操作这个指针，势必会产生很多竞争，各个线程都想去移动这个指针，而 TLAB 的存在即是说每次线程分配内存的时候不是申请多少就分配多少，而是每次分配稍大的区域，如下图虚线，之后内存分配尽力在线程自己的这块内存区域上进行，从而减少对 ptr 指针的竞争。如果线程的 TLAB 用完了，或者分配的对象太大，才会去争抢 ptr。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392224\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>与 TLAB 类似的还一个叫做 PLAB 的，Promotion Local Allocation Buffers，用在一组 GC 线程并发的将新生代对象晋升到老代时使用。也是每个 GC 线程会提前分配一块区域，每次晋升对象的时候将对象拷贝至线程自己的这块分配好的区域上，从而减小竞争。</p> \n<p>如果是标记-整理算法，按说对象并发的 Sweep 到新位置时也会是用上面这种方法进行。不过这个我没有找到说明的地方。</p> \n<p>这么一来之前说两个线程分别 <code>new SomeClass()</code>，每个线程只操作自己 <code>new</code> 出来的 <code>SomeClass</code> 对象不会引起 False Sharing 的原因就清楚了，因为每个线程会把 <code>SomeClass</code> 分配在自己的 TLAB 上，一般 TLAB 大于 Cache Line 所以不会引起 False Sharing 问题。JVM 上容易引起 False Sharing 问题的点也清楚了，即一个线程连续分配了两个对象，这两个对象后来被分配给不同的线程，并且被它们频繁更新，这两个对象在两个不同线程上就容易出现 False Sharing 问题，即使经历数轮 GC，它俩可能在内存上还是可能在一起，所以说 TLAB 和 PLAB 会增大 False Sharing 出现的概率。</p> \n<p>怎么证实这一点呢？不太容易，但指导思想就是让同一个线程连续 <code>new</code> 对象，再让其它线程来访问这些对象。只要对象不会很大，因为 TLAB 的关系，这些对象中有两个在同一个 Cache Line 上的几率会很大。比如我在 JMH 测试时这么写：</p> \n<pre><code class=\"java\">public static class SomeClassValue {\n    volatile int value;\n}\n@State(Scope.Group)\npublic static class SomeClass {\n    SomeClassValue[] val = new SomeClassValue[2];\n    public SomeClass() {\n        this.val[0] = new SomeClassValue();\n        this.val[1] = new SomeClassValue();\n    }\n}\n@Benchmark\n@Group(\"share\")\npublic void testA(SomeClass someClass) {\n    someClass.c[0].value++;\n}\n\n@Benchmark\n@Group(\"share\")\npublic void testB(SomeClass someClass) {\n    someClass.c[1].value++;\n}</code></pre> \n<p>看到线程会共享 <code>SomeClass</code> 对象，但会分别访问 <code>SomeClass</code> 中不同的 <code>SomeClassValue</code>。这两个 value 可能会被放在同一个 Cache Line 上而被观测到执行性能下降。</p> \n<h4>JVM 上 False Sharing 严重吗</h4> \n<p>正常来说 False Sharing 并不常见，想测出它也不容易，可能根据机器型号不同，JVM 版本不同，运行状况甚至运行时机不同而不一定什么时候出现，但是一旦出现在系统的 Hot Spot 上，数倍的性能损失是很严重的。False Sharing 可能产生严重问题的场景是：</p> \n<ul> \n <li>某个 Class 的对象被连续的创建；</li> \n <li>创建的对象被分发给多个不同的线程去读取、写入，每个线程本来可以独享一个对象；</li> \n <li>对象内被线程操作的 Field 被声明为 volatile；</li> \n</ul> \n<p>比如可以拿 Netty 4.1.48 下的 <a href=\"https://github.com/netty/netty/blob/netty-4.1.48.Final/common/src/main/java/io/netty/util/internal/InternalThreadLocalMap.java#L125\" rel=\"nofollow noreferrer\">InternalThreadLocalMap</a> 作为例子感受一下。这个 Thread Local Map 本来是每个 EventLoop 一个的，各个 <code>EventLoop</code> 不相互干扰。但是访问 Thread Local 对象本身是 Hot Spot，访问的很多，如果一旦出现 False Sharing 就会导致性能大幅度下降。<code>EventLoop</code> 是 Netty 启动时在一个 <a href=\"https://github.com/netty/netty/blob/netty-4.1.48.Final/common/src/main/java/io/netty/util/concurrent/MultithreadEventExecutorGroup.java#L84\" rel=\"nofollow noreferrer\">for loop</a> 中一口气被创建出来的，所以一组 <code>InternalThreadLocalMap</code> 中有几个刚巧紧挨着被创建出来是完全可能的。所以 <code>InternalThreadLocalMap</code> 用 Padding 做了一下保护。当然我理解即使 <code>EventLoop</code> 不是连续被创建出来也该去保护一下 <code>InternalThreadLocalMap</code> 以防恰好多个 Map 对象被放到同一个 Cache Line 上去。</p> \n<h2>参考</h2> \n<ul> \n <li>本文是我在准备 LeanCloud 内部的一个分享时写的，感兴趣的读者还可以查看视频版本：<a href=\"https://segmentfault.com/ls/1650000022381498\">CPU Cache 基础解析</a>。上期内容：<a href=\"https://segmentfault.com/a/1190000022352273\">IO 多路复用</a>。</li> \n <li><a href=\"https://www.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html\" rel=\"nofollow noreferrer\">PerfBook</a></li> \n <li><a href=\"http://opass.logdown.com/posts/249025-discussion-on-memory-cache\" rel=\"nofollow noreferrer\">淺談memory cache « Opass’s Blog</a></li> \n <li><a href=\"http://www.cs.iit.edu/~virgil/cs470/Book/\" rel=\"nofollow noreferrer\">Computer Architecture - Class notes</a></li> \n <li>《现代体系结构上的UNIX系统》</li> \n <li><a href=\"https://coolshell.cn/articles/20793.html\" rel=\"nofollow noreferrer\">与程序员相关的CPU缓存知识 | | 酷 壳 - CoolShell</a></li> \n <li><a href=\"https://people.freebsd.org/~lstewart/articles/cpumemory.pdf\" rel=\"nofollow noreferrer\">https://people.freebsd.org/~l...</a></li> \n <li><a href=\"https://www.stardog.com/blog/writing-cache-friendly-code/\" rel=\"nofollow noreferrer\">Writing cache-friendly code - Stardog</a></li> \n <li><a href=\"http://java-performance.com/\" rel=\"nofollow noreferrer\">http://java-performance.com/</a></li> \n</ul>', 'https://segmentfault.com/img/remote/1460000022392216', '3f69fcc9b13843d1910b3dac597f5215', 'e08558de0cef4bd899b5b6aa03550a21,1500b6a8b7a64b41a84f31328c0a3c9a,55723db96b9f4593bae02bc1e49f1e87', '0', '3', '1', '2020-04-16 16:48:52', '2020-04-16 16:48:52');
INSERT INTO `tb_recommend` VALUES ('c083c5a43b51431ea25403a11f045750', '用 Node.js 爬虫下载音乐', '互联网上有许多可供人类消费的信息。但是如果这些数据不是以专用的 REST API 的形式出现，通常很难以编程方式对其进行访问。使用 jsdom 之类的 Node.js 工具，你可以直接从网页上抓取并解析这些数据，并用于你自...', '<blockquote>\n 作者：Sam Agnew\n <br>翻译：疯狂的技术宅\n <br>原文：\n <a href=\"https://www.twilio.com/blog/web-scraping-and-parsing-html-in-node-js-with-jsdom\" rel=\"nofollow noreferrer\">https://www.twilio.com/blog/w...</a>\n <br>\n <strong>未经允许严禁转载</strong> \n</blockquote> \n<p>互联网上有许多可供人类消费的信息。但是如果这些数据不是以专用的 <a href=\"https://www.twilio.com/docs/api/rest\" rel=\"nofollow noreferrer\">REST API</a> 的形式出现，通常很难以编程方式对其进行访问。使用 <a href=\"https://www.npmjs.com/package/jsdom\" rel=\"nofollow noreferrer\">jsdom</a> 之类的 Node.js 工具，你可以直接从网页上抓取并解析这些数据，并用于你自己的项目和应用。</p> \n<p>让我们以用 MIDI 音乐数据来<a href=\"https://www.twilio.com/blog/training-a-neural-network-on-midi-music-data-with-magenta-and-python\" rel=\"nofollow noreferrer\">训练神经网络</a> 来 <a href=\"https://www.twilio.com/blog/generating-nintendo-music-over-the-phone-with-magenta-and-twilio\" rel=\"nofollow noreferrer\">生成听起来经典的任天堂音乐</a>为例。我们需要一套来自旧任天堂游戏的 MIDI 音乐。通过使用 jsdom 可以从<a href=\"https://vgmusic.com/music/console/nintendo/nes/\" rel=\"nofollow noreferrer\">视频游戏音乐档案</a>中抓取这些数据。</p> \n<h2>入门和依赖项设置</h2> \n<p>在继续之前，你需要确保自己有 <a href=\"https://nodejs.org/en/\" rel=\"nofollow noreferrer\">Node.js 和 npm</a> 的最新版本。</p> \n<p>切换到你希望此代码存在的目录，并在终端中运行以下命令创建项目的程序包：</p> \n<pre><code class=\"sh\">npm init --yes</code></pre> \n<p><code>--yes</code> 参数可以忽略所有你必须填写或跳过的提示。现在我们的程序有了 package.json</p> \n<p>为了通过发出 HTTP 请求从网页获取数据，我们将使用 <a href=\"https://www.npmjs.com/package/got\" rel=\"nofollow noreferrer\">Got</a> 库，对于 HTML 的解析，我们将用 Cheerio。</p> \n<p>在终端中运行以下命令安装这些库：</p> \n<pre><code class=\"sh\">npm install got@10.4.0 jsdom@16.2.2</code></pre> \n<p>jsdom 是大量 Web 标准的纯 JavaScript 实现，也是许多 JavaScript 开发人员熟悉的工具。让我们深入了解该如何使用它。</p> \n<h2>用 Got 检索要与 jsdom 一起使用的数据</h2> \n<p>首先让我们编写一些从网页中获取 HTML 的代码，然后看看如何开始解析。以下代码将向我们想要的网页发送一个 <code>GET</code> 请求，并使用该页面的 HTML 创建一个 jsdom 对象，我们将其命名为 <code>dom</code>：</p> \n<pre><code class=\"javascript\">const fs = require(\'fs\');\nconst got = require(\'got\');\nconst jsdom = require(\"jsdom\");\nconst { JSDOM } = jsdom;\n\nconst vgmUrl= \'https://www.vgmusic.com/music/console/nintendo/nes\';\n\ngot(vgmUrl).then(response =&gt; {\n  const dom = new JSDOM(response.body);\n  console.log(dom.window.document.querySelector(\'title\').textContent);\n}).catch(err =&gt; {\n  console.log(err);\n});</code></pre> \n<p>当向构造函数 <code>JSDOM</code> 传递一个字符串时，将返回一个 JSDOM 对象，你可以从中访问许多可用的属性，例如 <code>window</code>。如该代码所示，你可以用查询选择器（<a href=\"https://developer.mozilla.org/en-US/docs/Web/API/Document/querySelector\" rel=\"nofollow noreferrer\">query selector</a>）。</p> \n<p>例如 <code>querySelector(\'title\').textContent</code> 将获取页面上 <code>&lt;title&gt;</code> 标记内的文本。如果将此代码保存到名为 <code>index.js</code> 的文件并用命令 <code>node index.js</code> 运行，它会把网页的标题记录到控制台。</p> \n<h2>通过 jsdom 使用 CSS 选择器</h2> \n<p>如果你想在查询中获得更具体的信息，可以使用 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Selectors\" rel=\"nofollow noreferrer\">HTML 解析器</a>进行解析。最常见的两个方法是按 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/Class_selectors\" rel=\"nofollow noreferrer\">class</a> 或 <a href=\"https://developer.mozilla.org/en-US/docs/Web/CSS/ID_selectors\" rel=\"nofollow noreferrer\">ID</a> 获取。如果要获取 ID 为 “menu” 的div，则可以用 <code>querySelectorAll(\'#menu\')</code>，并且如果要获取 VGM MIDI 表格中的所有标题列，则可以执行 <code>querySelectorAll(\'td.header\')</code></p> \n<p>我们在此页面上想要的是我们需要下载的所有 MIDI 文件的超链接。可以用 <code>querySelectorAll(\'a\')</code>开始获取页面上的每个链接。在 <code>index.js</code> 中的代码中添加以下内容：</p> \n<pre><code class=\"javascript\">got(vgmUrl).then(response =&gt; {\n  const dom = new JSDOM(response.body);\n    dom.window.document.querySelectorAll(\'a\').forEach(link =&gt; {\n    console.log(link.href);\n  });\n}).catch(err =&gt; {\n  console.log(err);\n});</code></pre> \n<p>此代码记录页面上每个链接的 URL。可以用 <code>forEach</code> 函数浏览给定选择器中的所有元素。遍历页面上的每个链接都很棒，但是如果要下载所有 MIDI 文件，则需要更具体一些。</p> \n<h2>通过 HTML 元素过滤</h2> \n<p>在编写更多代码去解析所需的内容之前，先来看一下浏览器渲染出来的 HTML。每个网页都是不同的，有时从其中获取正确的数据需要一些创造力、模式识别和实验。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF40l\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>我们的目标是下载许多 MIDI 文件，但是这个网页上有很多重复的曲目以及歌曲的混音。我们只希望下载重复歌曲中的一首，并且因为我们的最终目标是用这些数据来训练神经网络以生成准确的 Nintendo 音乐，所以我们不想在用户创建的混音上对其进行训练。</p> \n<p>当你编写代码解析网页时，通常可以用现代浏览器中的开发者工具。如果右键单击你感兴趣的元素，则可以检查该元素后面的 HTML 并获取更多信息。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF40s\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>你可以编写<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/filter\" rel=\"nofollow noreferrer\">过滤器函数</a>来微调所需的选择器数据。这些函数遍历给定选择器的所有元素，并根据是否应将它们包含在集合中而返回 true 或 false。</p> \n<p>如果查看了上一步中记录的数据，可能会注意到页面上有很多链接没有 <code>href</code> 属性，因此无处可寻。可以确定它们不是我们要寻找的 MIDI，所以需要写一个简短的函数来过滤掉那些 MIDI，并包含确实能够链接到 <code>.mid</code> 文件的 <code>href</code> 元素：</p> \n<pre><code class=\"javascript\">const isMidi = (link) =&gt; {\n  // Return false if there is no href attribute.\n  if(typeof link.href === \'undefined\') { return false }\n\n  return link.href.includes(\'.mid\');\n};</code></pre> \n<p>现在有一个问题，我们不想下载重复项或用户生成的混音。可以用正则表达式来确保仅获取文本中不带括号的链接，因为只有重复项和混音项包含括号：</p> \n<pre><code class=\"javascript\">const noParens = (link) =&gt; {\n  // Regular expression to determine if the text has parentheses.\n  const parensRegex = /^((?!\\().)*$/;\n  return parensRegex.test(link.textContent);\n};</code></pre> \n<p>试着将它们添加到你的 <code>index.js</code> 中的代码中，通过从 <code>querySelectorAll</code> 返回的 HTML 元素节点集合中创建一个数组，然后把过滤器函数应用到其中：</p> \n<pre><code class=\"javascript\">got(vgmUrl).then(response =&gt; {\n  const dom = new JSDOM(response.body);\n\n  // Create an Array out of the HTML Elements for filtering using spread syntax.\n  const nodeList = [...dom.window.document.querySelectorAll(\'a\')];\n\n  nodeList.filter(isMidi).filter(noParens).forEach(link =&gt; {\n    console.log(link.href);\n  });\n}).catch(err =&gt; {\n  console.log(err);\n});</code></pre> \n<p>再次运行代码，它仅应打印 <code>.mid</code> 文件，而不复制任何特定歌曲。</p> \n<h2>从网页下载我们想要的 MIDI 文件</h2> \n<p>现在我们有了遍历所需的每个 MIDI 文件的工作代码，必须编写代码来下载所有这些文件。</p> \n<p>在用于遍历所有 MIDI 链接的回调函数中，添加以下代码以将 MIDI 下载流式传输到本地文件，并进行错误检查：</p> \n<pre><code class=\"javascript\">  nodeList.filter(isMidi).filter(noParens).forEach(link =&gt; {\n    const fileName = link.href;\n    got.stream(`${vgmUrl}/${fileName}`)\n      .on(\'error\', err =&gt; { console.log(err); console.log(`Error on ${vgmUrl}/${fileName}`) })\n      .pipe(fs.createWriteStream(`MIDIs/${fileName}`))\n      .on(\'error\', err =&gt; { console.log(err); console.log(`Error on ${vgmUrl}/${fileName}`) })\n      .on(\'finish\', () =&gt; console.log(`Downloaded: ${fileName}`));\n  });</code></pre> \n<p>从要保存 MIDI 文件的目录中运行代码，从终端屏幕上能够看到下载的所有 2230 个 MIDI 文件（在编写此代码时）。这样我们就完成所有需要的 MIDI 文件的抓取了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF40v\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>现在可以仔细倾听并欣赏任天堂音乐了！</p> \n<h2>浩瀚的万维网</h2> \n<p>你可以通过编程的方式从网页上获取内容，无论你需要什么项目，都可以访问大量的数据源。要记住的一件事是，被更改过网页的 HTML 可能会破坏你的代码，所以如果你要在此基础上构建应用程序，请确保所有内容保持最新。</p> \n<p>如果你正在寻找与刚刚从视频游戏音乐档案库中获取的数据有关的内容，则可以尝试使用 Python 库，例如 <a href=\"https://www.twilio.com/blog/training-a-neural-network-on-midi-music-data-with-magenta-and-python\" rel=\"nofollow noreferrer\">Magenta to train a neural network with it</a>。</p> \n<hr> \n<h4>本文首发微信公众号：前端先锋</h4> \n<h4>欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章</h4> \n<h2><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVRyYe\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章\" title=\"欢迎扫描二维码关注公众号，每天都给你推送新鲜的前端技术文章\"></span></h2> \n<h3>欢迎继续阅读本专栏其它高赞文章：</h3> \n<ul> \n <li><a href=\"https://segmentfault.com/a/1190000019115050\">深入理解Shadow DOM v1</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019135847\">一步步教你用 WebVR 实现虚拟现实游戏</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019154021\">13个帮你提高开发效率的现代CSS框架</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019085935\">快速上手BootstrapVue</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019205065\">JavaScript引擎是如何工作的？从调用栈到Promise你需要知道的一切</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019216390\">WebSocket实战：在 Node 和 React 之间进行实时通信</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019315509\">关于 Git 的 20 个面试题</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019302858\">深入解析 Node.js 的 console.log</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019283751\">Node.js 究竟是什么？</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000019268920\">30分钟用Node.js构建一个API服务器</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018903274\">Javascript的对象拷贝</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018224157\">程序员30岁前月薪达不到30K，该何去何从</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018646425\">14个最好的 JavaScript 数据可视化库</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018439250\">8 个给前端的顶级 VS Code 扩展插件</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018660861\">Node.js 多线程完全指南</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000018701596\">把HTML转成PDF的4个方案及实现</a></li> \n</ul> \n<hr> \n<ul>\n <li><a href=\"http://blog.yidengxuetang.com/\" rel=\"nofollow noreferrer\">更多文章...</a></li>\n</ul>', 'https://segmentfault.com/img/bVbF40l', '692c6787030d4b8882077b2ab9279c52', '63c4e1e7ec204b43a62065a3ced4c2ce,d16a93d83052441a90afaa57d69fdc3c,d79254c4ca5e45dca9d484307c935281,fe213d41bcb743e2840d8aa58cf48d3e', '0', '3', '1', '2020-04-16 16:48:02', '2020-04-16 16:48:02');
INSERT INTO `tb_recommend` VALUES ('c15b7650ea1341adbf1cf7fb37440602', '我的本科回忆录：从迷茫自卑到保送华科', '今天看新闻，多地高三终于开学了，看着他们风华正茂的样子，想着他们几个月后就要成为大学校园的一份子，我自己不禁也感慨万千。 说长不长，说短不短，距离我踏入大学本科校园的日子也已经过去快11年了。 我觉得...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022298589\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<hr> \n<p>今天看新闻，多地高三终于开学了，看着他们风华正茂的样子，想着他们几个月后就要成为大学校园的一份子，我自己不禁也感慨万千。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022298588\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>说长不长，说短不短，距离我踏入大学本科校园的日子也已经过去快<code>11</code>年了。</p> \n<p>我觉得我们这代90后年轻人还是蛮累的，毕业之后奔向四方，只顾着不顾一切的往前冲，甚至来不及追忆自己的青春与成长。</p> \n<p>正好趁着这个机会，这会有点上头，就写点文字来分享一下我的本科经历和心路历程吧，对于我个人来说也是一个青春的追忆。</p> \n<p>正好也顺便来聊聊本科阶段该如何度过、有些节奏应该怎么把握、有些事情又该如何取舍，以及一些心态的调整问题，因为总有小伙伴私信说很迷茫，很纠结。</p> \n<hr> \n<h2>01</h2> \n<p>首先，我讲讲我自己本科阶段的实际情况。</p> \n<p>我本科没有参加过任何的协会、社团、学生会。是的，我很想进，但是一个都没进去。不瞒你说，各种尝试去面试，结果全都被刷了。我在自卑、迷茫和焦躁中度过了我的大一。</p> \n<p>记得大一时候的我成绩不是太好，班级117个人，我的排名在四十多的样子。第一学年勉强拿了个三等奖学金，几百块钱，我为此还闷闷不乐很久，心里还想着，觉得自己其实蛮努力的。</p> \n<p>直到多年后我才明白，在大一的美好时光里，可能自己还是迷茫、跟风、目光总是在别人身上，才导致很多事情没有深入的做下去。</p> \n<hr> \n<h2>02</h2> \n<p>大二暑假，我有过一段时间不长的实验室经历，但我基本上啥也没学着。我是怎么进来的，怎么出去的，我没能融入得了那个环境，我放弃了。</p> \n<p>本科阶段我也没有任何大型的比赛经历，大二那时候，电赛（全国大学生电子设计竞赛）的初期参与了，后期没参与，更别说上场比赛了。我恋家，暑假呆了大半个月我跑回去了。</p> \n<hr> \n<h2>03</h2> \n<p>慢慢的，经过了几番折腾尝试之后，我的杂念少了一些，因为我知道其他同学那些繁华的世界和我基本没什么关系了，当然我也承认这跟我的个人性格有关。</p> \n<p>虽然到现在我也不愿意承认，但那时候其实自己也没得选择，所以只能一个劲顾着搞学习，大二、大三真是把自习室的牢板都坐穿了……</p> \n<p>很幸运的是，但到了大三末，经过两年的孤独和努力，专业成绩搞了个全系第一，我竟然拿到了保送华科硕士研究生的资格。我开始变得坦然起来了，觉得自己并不是一无是处。</p> \n<hr> \n<h2>04</h2> \n<p>回首过往，我内心其实知道，本科阶段总体来讲过得<strong>很无聊</strong>，但<strong>不算空虚</strong>吧，我只能这么安慰自己。</p> \n<p>本科阶段，尤其是大一和大二，我作为一个非常孤独的个体，还是非常羡慕那些在社团和学生会混得风生水起，个个都有女朋友的那波人，因为跟他们相比，我觉得自己有些自卑。</p> \n<hr> \n<h2>05</h2> \n<p>所以接下来聊聊我对于本科阶段的一些看法吧，因为咱这里年轻的小伙伴多。</p> \n<p>大一课不多，而且全是认知性的课程，我觉得可以抽出一部分精力来考虑参加社团、学生会，协会等等。可能还是因为我在本科阶段一直没有得到这个，所以一直很羡慕，就算现在阔别校园这么多年也还是很羡慕！因为我觉得这也是同学少年时代的一种独特的经历跟体验。但好在这个不是必选项，如果比较内向或者仅仅是因为跟风的因素而其实内心并不太想参加的，可以不去。</p> \n<hr> \n<h2>06</h2> \n<p>大一、大二尽量把英语四六级给过了吧，尤其四级，不过的话很麻烦，后面不论就业、考研还是保研。</p> \n<hr> \n<h2>07</h2> \n<p>大二下、大三<strong>这一年半</strong>的时间里，一定要开始要逐步地寻找自己的目标。要考研的，就好好学习专业课、复习专业课；对技术有兴趣的，就开始规划好技术路线来学习技术，扎实推进，定一个个小目标慢慢实现，慢慢激励自己；当然，如果对考研、学技术都没有兴趣的，我觉得也没问题，你要是能找到自己内心的寄托那再好不过了。</p> \n<hr> \n<h2>08</h2> \n<p>很多小伙伴问我到底要不要<strong>进实验室</strong>的话题，好像很纠结这个事情，我个人是觉得，这个问题你既然问出来了，我个人感觉其实你内心可能没有那么想去。</p> \n<p>进实验室这个事情千万不要跟风，一定要根据自己的内心兴趣来。我的亲身经历告诉你，如果不进实验室也没有问题，不要有心理包袱。学校的实验室里做的东西，其实也没有那么高深，你仅凭个人之力花精力学，也不会差哪儿去。</p> \n<hr> \n<h2>09</h2> \n<p>大三下的<strong>实习与否</strong>我个人觉得倒还好，没必要因为这个焦虑得睡不着觉。</p> \n<p>我觉得实习这个事情最起码可以为<strong>两件事</strong>让路：第一个是考研的充分准备、第二个则是校招的充分准备，切勿因小失大。</p> \n<p>因为很多找的实习，也没那么有技术含量，对找工作的加分也没有那么大，要是去打酱油那就有点浪费时间了，除非说能拿到一些大厂的实习offer。</p> \n<p>当然，这纯属我个人意见，小伙伴们仅供参考。</p> \n<hr> \n<h2>10</h2> \n<p>最后，还有一些额外的心里话。</p> \n<p>首先，我觉得大学阶段最最重要的还是建立起对专业的认知、以及培养独立思考和独立解决问题的能力，这个比什么都重要；</p> \n<p>本科阶段的成绩其实没有那么没用，大家尽可能还是注意一下为好，后续保研、进研究所、国家机关、事业单位啥的多多少少还是看成绩单的，毕竟都喜欢培养那种根正苗红的学生；</p> \n<p>关于班干部这件事，我觉得其实是可以努力争取一下的，毕竟可以多接触老师，多跟老师交流肯定不是一件坏事；</p> \n<p>大学阶段还是多结交几个志同道合的真心朋友吧，坦诚相待，少一点套路，这可能是你以后整个人生道路上的风景；</p> \n<p>最后，如果能找到心仪的对象，那是最好不过的，也可以努力争取一下；</p> \n<p>最后的最后，我尤其想跟那些本科阶段觉得自己孤独甚至自卑，但骨子里又想做出点什么的小伙伴们说的是：千万不要妄自菲薄，一定找到属于自己内心的寄托，并为此坚定不移地奋斗三年，你一定会变得很坦然的！</p> \n<p>好吧，就聊这么多了。</p> \n<hr> \n<p>每天进步一点点，Peace！</p> \n<p>2020.04.07 晚</p>', 'https://segmentfault.com/img/remote/1460000022298589', '61cdf41d1e5e4f229b76f6a042e254b6', '81a4561c1c294e0cae32c9fe6b5dc397,1af5f9c4e9a14953af29cb85b3dd6caa,9fc0276000e346da8c0bab1b5f78adaa,0a5aa8da93084aa6ac3dc20b1cc90863,25b298296d9948c5aceac5227fa0ef07', '0', '3', '1', '2020-04-16 16:47:12', '2020-04-16 16:47:12');
INSERT INTO `tb_recommend` VALUES ('c1a1b1f7610b471b989f643e4e3a0e4c', '如何在Choerodon平台中导入应用服务', '通过之前的文章《Choerodon猪齿鱼实践之应用生命周期管理》，我们已经基本了解了Choerodon平台中应用服务的特性和微服务架构的特点。在此基础上，本文将为大家介绍Choerodon平台中导入应用服务的功能。', '<p>通过之前的文章<a href=\"http://choerodon.io/zh/blog/lifecycle/\" rel=\"nofollow noreferrer\">《Choerodon猪齿鱼实践之应用生命周期管理》</a>，我们已经基本了解了Choerodon平台中应用服务的特性和微服务架构的特点。在此基础上，本文将为大家介绍Choerodon平台中导入应用服务的功能。</p> \n<h1>导入应用服务功能的背景</h1> \n<p>由于Choerodon平台采用的是微服务架构，因此其中的应用会被分解为更小、完全独立的服务组件，这使得它们拥有更高的敏捷性、可伸缩性和可用性。基于这些特点，我们就可以将各个项目中开发得到的应用服务组件化，并达到复用应用服务的效果，以此来避免重复造轮子的情况。</p> \n<p>对于同组织内不同项目之间的应用服务共享，我们在之前的文章中已经进行了详细地介绍（具体步骤请参考：<a href=\"https://choerodon.io/zh/blog/application-service-sharing/\" rel=\"nofollow noreferrer\">Choerodon猪齿鱼实践之应用服务共享</a>）；但是如果想<strong>将应用服务共享至其他组织中的某个项目</strong>，或者<strong>将之前在其他平台中开发的应用服务迁移到Choerodon平台之中</strong>，我们要怎样实现呢？这就涉及到下面要介绍的“<strong>导入应用服务</strong>”的功能。</p> \n<h1>导入应用服务功能介绍</h1> \n<p>导入应用服务目前有3个来源，分别是：<strong>共享应用</strong>（组织内其他项目共享至本项目下的应用服务）、<strong>GitHub</strong>与<strong>GitLab</strong>。目的是从这些来源中导入已有的应用服务及其对应的代码仓库，并支持在已有应用服务的基础上进行开发，以此来避免重复造轮子的情况。</p> \n<h2><strong>共享应用</strong></h2> \n<p>若同组织其他项目下存在符合需求的应用服务，只需通过共享规则的方式将此应用服务共享至本项目即可；而在本项目中导入目标应用服务后，便能在原有代码库的基础上进行二次开发或部署。（注意：选择添加应用服务后，会默认选择该应用服务共享出来的最新版本；若直接导入，此时便会将该服务版本对应的代码库与commit导入到项目之中；此处版本可自主切换）<span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022302869\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片\" title=\"图片\"></span></p> \n<h2><strong>从GitHub导入</strong></h2> \n<p>若目标应用服务的代码已经被上传至GitHub之中，此时只需在导入应用服务中选择“从GitHub导入”，再输入GitHub的HTTP地址，便能将应用服务的仓库克隆至本项目下进行二次开发。Choerodon平台目前支持从GitHub公库导入应用服务，且不能导入空库。</p> \n<p>此外，Choerodon还在GitHub上预置了多个常用的应用服务模板供各个项目团队选择。只需在“从GitHub导入”的选项中，选择导入来源为“系统预设模板”即可。其中的应用服务模板是由同类型应用服务的代码库整理而成的，引用了相应的应用服务模板后，即可在gitlab中快速地创建初始代码库。其中包括：</p> \n<ul> \n <li>微服务-MicroService；</li> \n <li>web前端-MicroServiceFront；</li> \n <li>Java库-JavaLib；</li> \n <li>Java库-SpringBoot；</li> \n <li>Go库-GoTemplate；</li> \n <li>自动化测试-Mocha-ChoerodonMochaTemplate；</li> \n</ul> \n<p>在这些模板中，至少都包含了 Dockerfile 文件、CI 文件以及 Chart 目录文件。</p> \n<p>其中Dockerfile是由一系列命令和参数构成的脚本，这些命令应用于基础镜像并最终创建一个新的镜像，主要用于控制应用容器化的进程。其次是CI文件，模板中的CI文件主要用于设置在提交代码后，自动集成时要经历的所有阶段。而其中的Chart目录文件则用于将平台中的容器打包，统一置于K8S平台进行管理。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022302871\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片\" title=\"图片\"></span></p> \n<h2><strong>从GitLab导入</strong></h2> \n<p>若目标应用服务的代码已经被上传至GitLab之中，此时只需在导入应用服务中选择“从GitLab导入”，再输入GitLab的HTTP地址（若为私库，还需输入私有Token）。便能将应用服务的代码仓库克隆至本项目下进行二次开发。Choerodon平台目前支持从GitLab的公库和私库导入应用服务，且同样不能导入空库。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022302870\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"图片\" title=\"图片\"></span></p> \n<p>应用服务导入成功之后，系统会默认在本项目对应的 gitlab group 中创建一个 project 作为此应用服务的初始代码库，而后再通过相应的页面功能实现对此应用服务的管理。同时，可以在“代码管理”模块，按照规范的开发流程对导入的应用服务进行分支管理、合并请求管理、版本管理、CI管理、标记管理以及代码质量的监测。</p> \n<h1>总结</h1> \n<p>导入应用服务功能使得Choerodon平台中的应用服务更加灵活，不仅仅支持组织内各项目之间应用服务的共享与复用，还可通过GitHub与GitLab导入的方式实现跨组织和跨平台的复用已有的应用服务，充分地发挥微服务架构的敏捷性与可伸缩性。</p> \n<h2>关于猪齿鱼</h2> \n<p><a href=\"http://choerodon.io/\" rel=\"nofollow noreferrer\">Choerodon 猪齿鱼</a>作为开源多云应用敏捷全链路技术平台，是基于开源技术Kubernetes，Istio，knative，Gitlab，Spring Cloud来实现本地和云端环境的集成，实现企业多云/混合云应用环境的一致性。平台通过提供精益敏捷、持续交付、容器环境、微服务、DevOps等能力来帮助组织团队来完成软件的生命周期管理，从而更快、更频繁地交付更稳定的软件。</p> \n<p>更加详细的内容，请参阅<a href=\"https://github.com/choerodon/choerodon/tree/master/changelogs\" rel=\"nofollow noreferrer\">Release Notes</a>和<a href=\"http://choerodon.io/\" rel=\"nofollow noreferrer\">官网</a>。</p> \n<p>大家也可以通过以下社区途径了解猪齿鱼的最新动态、产品特性，以及参与社区贡献：</p> \n<ul> \n <li>官网：<a href=\"http://choerodon.io/\" rel=\"nofollow noreferrer\">http://choerodon.io</a> </li> \n <li>论坛：<a href=\"http://forum.choerodon.io/\" rel=\"nofollow noreferrer\">http://forum.choerodon.io</a> </li> \n <li>Github：<a href=\"https://github.com/choerodon\" rel=\"nofollow noreferrer\">https://github.com/choerodon</a> </li> \n</ul> \n<p>欢迎加入Choerodon猪齿鱼社区，共同为企业数字化服务打造一个开放的生态平台。</p> \n<blockquote>\n 本篇文章出自\n <a href=\"https://forum.choerodon.io/\" rel=\"nofollow noreferrer\">Choerodon猪齿鱼社区</a>毛智伟。\n</blockquote>', 'https://segmentfault.com/img/remote/1460000022302869', '1c5851dc916d4e70a60f0c957f548876', 'd56b9fa723c243c3bfff49e3717856d3,c6611ad44f6e40fea7acd54a33ad01c2,8d3b9574902f4306bcf2833371d35439,634b81d655c74cb0adc4d0aa362b8819,1103d9e24e014eeab039ce0de76ad440', '0', '3', '1', '2020-04-16 16:59:46', '2020-04-16 16:59:46');
INSERT INTO `tb_recommend` VALUES ('c3c644e6109a4ccebbb613999b301ed1', '[宝宝也能看懂的活动篇][30-Day LeetCoding Challenge] 第十天', '最小栈 Hi 大家好，我是张小猪。欢迎来到『宝宝也能看懂』系列特别篇 - 官方小活动 『30-Day LeetCoding Challenge』。 这里是 4 月 10 号的题，也是题目列表中的第 155 题 -- 『最小栈』 题目描述 设计一个支持 ...', '<h1>最小栈</h1> \n<p>Hi 大家好，我是张小猪。欢迎来到『宝宝也能看懂』系列特别篇 - 官方小活动 『30-Day LeetCoding Challenge』。</p> \n<p>这里是 4 月 10 号的题，也是题目列表中的第 155 题 -- 『最小栈』</p> \n<h2>题目描述</h2> \n<p>设计一个支持 <code>push</code>，<code>pop</code>，<code>top</code> 操作，并能在常数时间内检索到最小元素的栈。</p> \n<ul> \n <li> <code>push(x)</code> —— 将元素 x 推入栈中。</li> \n <li> <code>pop()</code> —— 删除栈顶的元素。</li> \n <li> <code>top()</code> —— 获取栈顶元素。</li> \n <li> <code>getMin()</code> —— 检索栈中的最小元素。</li> \n</ul> \n<p>示例:</p> \n<pre><code class=\"shell\">MinStack minStack = new MinStack();\nminStack.push(-2);\nminStack.push(0);\nminStack.push(-3);\nminStack.getMin();   --&gt; 返回 -3.\nminStack.pop();\nminStack.top();      --&gt; 返回 0.\nminStack.getMin();   --&gt; 返回 -2.</code></pre> \n<h2>官方难度</h2> \n<p>EASY</p> \n<h2>解决思路</h2> \n<p>题目要求很简单，就是要封装一个叫做 <code>MinStack</code> 的类，几个操作都是普通的栈操作，不过多了一个返回最小的元素值。由于原生 JS 的 <code>Array</code> 就集合了队列和栈的操作行为，所以我们可以直接基于它来实现。</p> \n<h3>直接方案</h3> \n<p>直接基于原生的 <code>Array</code> 来实现栈的操作，另外我们用一个变量来记录栈内数据的最小值。这里小猪用一个 <code>_top</code> 指针来标识栈顶的位置，从而避免数据的擦除开销和数组动态缩短的开销，另外在每一次 <code>pop</code> 的时候通过遍历去更新记录的最小值。具体代码如下：</p> \n<pre><code class=\"js\">class MinStack {\n  constructor() {\n    this._top = -1;\n    this.data = [];\n    this.min = Number.MAX_SAFE_INTEGER;\n  }\n  push(n) {\n    this.data[++this._top] = n;\n    n &lt; this.min &amp;&amp; (this.min = n);\n  }\n  pop() {\n    this.min = Number.MAX_SAFE_INTEGER;\n    for (let i = --this._top; i &gt;= 0; --i) {\n      this.data[i] &lt; this.min &amp;&amp; (this.min = this.data[i]);\n    }\n  }\n  top() {\n    return this.data[this._top];\n  }\n  getMin() {\n    return this.min;\n  }\n}</code></pre> \n<h3>优化</h3> \n<p>上述代码有个问题，<code>pop</code> 操作的时间复杂度其实是 O(n)，因为需要通过遍历来完成最小值的更新。我们来尝试把它变成 O(1)。</p> \n<p>为了直接更新最小值，那么它可能来自于可以直接计算或者提前算好了存起来。由于数据并没有什么数学联系，所以直接计算显然是不现实的，那么我们就从提前算好来考虑。我们可以想象一下在插入一个新数据的时候发生的情况：当前栈中的最小值我是知道的；新数据是否最小我也是知道的。那么就相当于插入数据前的最小值和插入数据后的最小值我都知道。那么反过来，它们其实也就是弹出数据前和弹出数据后的最小值。</p> \n<p>到此，我们便得到了实现思路。具体代码如下：</p> \n<pre><code class=\"js\">class MinStack {\n  constructor() {\n    this._top = -1;\n    this.data = [];\n    this.min = Number.MAX_SAFE_INTEGER;\n  }\n  push(n) {\n    this.data[++this._top] = this.min;\n    this.data[++this._top] = n;\n    n &lt; this.min &amp;&amp; (this.min = n);\n  }\n  pop() {\n    this.min = this.data[--this._top];\n    --this._top;\n  }\n  top() {\n    return this.data[this._top];\n  }\n  getMin() {\n    return this.min;\n  }\n}</code></pre> \n<h2>总结</h2> \n<p>优化方式中包含了一点思维的转换，不过也非常简单，希望能帮助到有需要的小伙伴。</p> \n<p>如果觉得不错的话，记得『三连』哦。小猪爱你们哟~</p> \n<h2>相关链接</h2> \n<ul> \n <li><a href=\"https://github.com/poppinlp/leetcode#30-day-leetcoding-challenge\" rel=\"nofollow noreferrer\">活动题目列表</a></li> \n <li><a href=\"https://github.com/poppinlp/leetcode\" rel=\"nofollow noreferrer\">leetcode 题解 repo</a></li> \n <li><a href=\"https://segmentfault.com/blog/zxzfbz\">我的 segmentfault 专栏</a></li> \n <li><a href=\"https://zhuanlan.zhihu.com/zxzfbz\" rel=\"nofollow noreferrer\">我的知乎专栏</a></li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCAAa\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"qrcode_green.jpeg\" title=\"qrcode_green.jpeg\"></span></p>', 'https://segmentfault.com/img/bVbCAAa', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '3921afbb134d45f6aa368b52d2670e7b,faf36da502544b51be926ab85450c40d,789898341cc64d45a1f44e26daab183f,63c4e1e7ec204b43a62065a3ced4c2ce,55723db96b9f4593bae02bc1e49f1e87', '0', '3', '1', '2020-04-16 16:55:35', '2020-04-16 16:55:35');
INSERT INTO `tb_recommend` VALUES ('cab49be802484eacb707a2e783862d6a', '生鲜 B2B 技术平台的前端团队该如何搭建', '线下越重，线上需要越轻，这个轻指的是轻便轻巧和简洁易用，通过前面几章小菜技术与产品历史介绍，我们了解到 B2B 生鲜领域在线下是如此之重，那么在交易场景线上化的过程中，端的移动化就势在必行，试想一下，让...', '<blockquote>\n 著作权归作者所有。商业转载请联系 Scott 获得授权，非商业转载请注明出处[务必保留全文，勿做删减]。\n</blockquote> \n<p>线下越重，线上需要越轻，这个轻指的是轻便轻巧和简洁易用，通过前面几章小菜技术与产品历史介绍，我们了解到 B2B 生鲜领域在线下是如此之重，那么在交易场景线上化的过程中，端的移动化就势在必行，试想一下，让菜市场摊位老板人手一台笔记本点开网页选购支付，让采购销售抱着电脑去拜访客户，一边聊蔬菜行情，一边打开笔记本进行记录，有没有一种回到世纪初的感觉。</p> \n<p>产品的移动化，这将是我们展开这篇文章的背景，我们会先了解小菜的产品托管在哪些端上，然后感受这些端带来的挑战，最后是我们面对这些挑战所采取的策略，以及整个小菜前端团队历练后的技术成长和沉淀，和我们对于自己的一个评估和对未来的展望，本文将采用最通俗易懂的方式陈述，会略有繁琐，但力求对技术新人也足够友好。</p> \n<p><a></a></p> \n<h3>一、小菜大前端的端有哪些</h3> \n<p>小菜早期围绕着蔬菜销地以客户集单批发的模式摸爬滚打几年，从上游的蔬菜供应商到下游批发市场的摊位老板，在这个长长的链路中，我们诞生了这样几款线上产品来服务于不同的人群和场景，之前文章中也有介绍，这里再汇总一下，共 7 款 App：</p> \n<ul> \n <li>宋小菜 服务于销地批发老板的下单工具</li> \n <li>宋小福 服务于小菜内部销售团队的 CRM 销售管理与客户管理工具</li> \n <li>宋小仓 连接司机-物流-采购-销售的蔬菜在途位置监控工具</li> \n <li>采秘 &nbsp; &nbsp;服务于小菜内部采购团队的蔬菜品类采购工具</li> \n <li>麦大蔬 服务于上游蔬菜供应商的大宗农产品交易平台</li> \n <li>宋大仓 服务于上游囤货配资的进出库管理平台</li> \n <li>行情宝 服务于产销两地的行情采集和预测工具</li> \n</ul> \n<p>前 6 款 App 都是基于 ReactNative 开发的 iOS/Android App，最后一个是微信小程序，它们涵盖了公司几乎所有的协同场景和工作流，其他涉及审核、数据观测和过程管理的部分，则会进入到我们 PC 端产品中，也就是：</p> \n<ul>\n <li>ERP 后台管理系统</li>\n</ul> \n<p>生鲜的 toB 场景，角色众多，链路冗长，这种延伸到产地农民，延伸到小 B 交易的管理系统一定会角色杂，权限多，操作重，业务复杂度所带来的页面复杂度不是一般的小系统可比拟。</p> \n<p>到目前为止，我们已经看到小菜的 7 个移动端 App，以及一个复杂的后台管理系统，这些都跟前端工程师息息相关，除了这些，还有 2 个重要的内部产品，就是：</p> \n<ul> \n <li>大表哥 数据报表系统</li> \n <li>大瓜子 市调模板配置系统</li> \n</ul> \n<p>其中大表哥（谐音：搭 Excel 表格）由前端工程师独立研发和维护的数据报表系统，单拎出来这个系统，是因为在 B2B 公司，尤其涉及到供应链的长链路场景中，真实业务数据的及时反馈对于每一个执行团队都至关重要，没有这些数据抓手，就失去了多维度数据观测，都很难快速的做出正确的运营决策和业务调整，甚至很难发现业务中出现的漏洞和问题，比如不正常的非自助下单（也就是销售帮忙下单）的比例。</p> \n<p>关于报表系统后文还有介绍，我们再为前端增加一个服务的产品场景，就是微信生态内产品，比如公众号或者小程序，它的技术栈和运行环境跟原生 App 和 PC 都不同，虽然小程序可以带来更多的业务可能性，也会对前端带来更大的挑战。</p> \n<p>我们把这些端合并一下，小菜前端要服务的端或场景：</p> \n<ul> \n <li>移动端（iOS/Android App/小程序）</li> \n <li>PC 端（ERP）</li> \n <li>工具端（大表哥数据报表）</li> \n</ul> \n<p>端上全部开花，这也应了我之前在掘金 JTalk 上小菜对于长链路流通交易分享的一个观点：<a href=\"http://www.itdks.com/eventlist/detail/2174\" rel=\"nofollow noreferrer\">链路足够长，每个节点上都可以长出产品</a>。那这些端产品都是与业务有强关联的，还有更多技术基建的和服务于团队内的产品，比如：</p> \n<ul> \n <li>大伯伯（谐音打包包） 实现 App 选仓库选分支选环境配置的自主打包与推包系统</li> \n <li>大表姐（来自饥饿游戏，寓意开工没有回头箭） 实现 6 款 App 解包差分后下发热更新包的发布系统</li> \n <li>姑奶奶 &nbsp;线上异常汇集分析与与 Bug 定级指派系统</li> \n <li>大舅子 向下调用微服务接口向上提供 GraphQL 查询能力的数据聚合服务</li> \n <li>RGB &nbsp; &nbsp;用户使用 App 的 PV/UV，以及业务数据监控相关的可视化平台</li> \n <li>110 &nbsp; &nbsp; 解决端异常收集与报警需求</li> \n <li>堂哥工作台 团队记录资源分配与 redmine 同步的自动化周报系统</li> \n <li>ITms 解决内部 App 安装测试的配置生成和预装服务</li> \n <li>...</li> \n</ul> \n<p>这些是服务于团队内部的工具链，全部由小菜前端自行维护。到这里我们发现，在小菜这样一家创业公司内，前端要服务的端和场景的确较多，但这些产品和工具的背后，整个前端组也就 10 个人而已（我们当然也求才若渴），但是人虽少，效率不能自我妥协，所以我们能服务到这些端，也正是基于端的多样性和数量，我们称自己：宋小菜大前端。</p> \n<p>先上小菜端上若干产品和工具的技术栈图，帮助大家理解我们的技术理念：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1525686896336-0af87fa7-b4e7-4c43-ae22-80a5a86c7746.png#align=left&amp;display=inline&amp;height=545&amp;originHeight=990&amp;originWidth=1358&amp;status=done&amp;style=none&amp;width=747\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><a></a></p> \n<h3>二、多端带来的挑战</h3> \n<p><a></a></p> \n<h5>1. 【物理现状】移动端的碎片化</h5> \n<p>古典互联网时代，因为要兼容 IE678 而痛苦不堪，Hack 黑魔法经验基本代表前端水平，如今互联网早已移动化，我们理想中的移动端开发，看上去是可以大胆使用新语法特性，只需要做好尺寸兼容就好了，但事实并非如此，不仅在移动端的浏览器不是如此，在移动端开发 RN App 也是如此，这是我们某一款 App 一段时间内，所收集上来的手机厂商分布：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1525342888541-27451bb8-8278-4ba1-9554-f36b79da48f0.png#align=left&amp;display=inline&amp;height=493&amp;originHeight=996&amp;originWidth=1508&amp;status=done&amp;style=none&amp;width=747\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>可以发现 Android 的碎片化非常严重，每一个厂商下面有不同时期推出的不同型号的手机，这些手机有着不同版本的操作系统，不同的分辨率和用电策略，不同的后台进程管理方式和用户权限，要让一款 App 在哪怕头部 40% 的手机上兼容，都是一件艰难的事情，这个客观物理现状叠加下面的社区现状，App 质量保证这件事情会变得雪上加霜。</p> \n<p><a></a></p> \n<h5>2. 【社区现状】技术框架的不稳定性</h5> \n<p>回到本文的开头，我们在长链路的 B2B 生鲜场景中，为了更快更轻，开发出 7 款 App，而且将来随着业务场景的拓展会诞生更多独立 App 甚至是集大成的 App，所以技术选型不太可能选择原生的 Java/Object-C 开发，尤其对于创业公司，6 款 App 得需要多少名原生开发工程师才能搞定，高频繁重的业务变化又怎样靠堆人来保证？</p> \n<p>想清楚这些，一开始我们就调研 ReactNative，并最终全部从原生切换到了 RN，通过跑过来的这 3 年来看，使用 RN 为公司节约了大量的人力成本同时，也尽可能的满足到几乎所有的需要快速迭代的业务场景，又快又轻，成为宋小菜大前端团队做事的一个典型特征。</p> \n<p>但换一个角度看，就是带来的问题，又快又轻的背后是 RN 版本的飞速迭代，截止到目前，也就是 2018 年 6 月份，RN 还没有推出一个官方的正式的长期维护的稳定版本，什么意思？就是 RN 目前依然处在不稳定的研发周期内，我们依然站在刀尖起舞，用不稳定的 RN 版本试图开发稳定的应用，三年走过来，我们在 RN 的框架里，多少次面对旧版本局限性和新版本不稳定性都进退不得，旧版本的 Bug 可能会在新版本中修复，新版本引进则会来新版本自己的问题。</p> \n<p>除了 RN 自身版本，还有第二个问题，围绕着 RN 有很多业界优秀的组件，但这些社区组件甚至官方组件，都不一定能及时跟进最新的 RN 版本，同时还能兼容到较老的 RN 版本，所以 RN 升级导致的组件不兼容性，会引发你 Fork 修改组件的冲动，但这样会带来额外的开发成本和版本维护成本，取舍会成为版本升降的终极问题。</p> \n<p>在国内开发，还有第三个问题，就是中文文档缺乏，社区资源匮乏，参考文献陈旧，可拿来主义的开源工程方案甚至社区线上线下会议分享都很缺乏，一个不小心就会踩坑，这就是 RN 社区的现状，我们在刀尖浪花上独步，App 选型背后的技术栈稳定性则成为悬在头上的一把铡刀，你不知道什么时候会咔嚓一声。</p> \n<p><a></a></p> \n<h5>3. 【人才现状】人员能力的长短不齐</h5> \n<p>我们知道有一个词叫做主观能动性，表示没有条件创造条件也可以上，这个词的主体就是人，聊完移动端设备现状和社区现状后，我们来聊聊人的问题。RN 在国内真正开始普及使用，是从 2015 年开始，也就意味着，到 2018 年，一个 RN 工程师也就只有 3 年的工作经验，而 RN 的 “Learn once, write anywhere” 也刺激着一切 Care 人员开支， Care 产品研发投入性价比的公司纷纷跳水研究 RN，争抢 RN 人才，RN 是前端中的移动前端，前端有多抢手，那么 RN 工程师就比它还要抢手。</p> \n<p>这导致基本上 RN 工程师，很难靠外部招聘，只能靠内部培养，这也是小菜前端的成长历程，我们有 &nbsp;2 名资深 RN 工程师，一个是从服务端 Java，一个是从原生 Android 开发转过来的。如果 RN 人手不足，产品支持的力度和速度就一定会遇到瓶颈，这就是我们曾经面临的问题，就是人才现状，外招数量不足，内培速度有限，RN 工程师的数量和能力就时不时成为公司业务扩张的瓶颈。</p> \n<p><a></a></p> \n<h5>4. 【公司现状】高密集业务的交付质量</h5> \n<p>作为工程师，我们有很强的自尊心和不容挑战的代码洁癖，但在一个创业公司里面，甚至大公司的一个创业团队里面，我们需要对接一些关键的业务节点，冲刺一些特定的时间窗口，并且要及时响应多变的业务，和业务背后多变的产品形态，这都会带来非常密集的需求队列。</p> \n<p>这些密集的需求队列对我们的代码实现质量有非常高的挑战，一个组件用 5 分钟思考如何抽象和用 50 分钟思考，实现后的稳定性、兼容性都是不同的，如何保证产品按期交付上线，会是摆在我们面前一个非常关键的命题，而这个难题之外，还有一个更难的命题等着我们，那就是如何保证交付不延期的同时，还能保证交付质量。</p> \n<p>要知道，如果一个项目代码赶的太毛糙，后期维护起来的成本会是巨大的，甚至只能用更高的成本重构重写。本质上，再次重构就一定是公司在为早期的猛冲买单，为这些技术债买单，如何不去买单或者如何用最小的成本买单，这跟我们早期的业务密集程度，交付周期，质量把控有很大的关系。</p> \n<p>综上，移动端碎片化所带来的兼容难度，RN 框架的局限性，版本间差异带来的不稳定性，技术社区资源的匮乏和前端团队技术能力掣肘，再叠加上高密度的业务排期，让前端开发这个本来很酷的事情，变得晴雨不定。</p> \n<p>这些避不开的现实，是绕不过去的坎儿，是搭建团队必须搞定的基础，我们想要把 B2B 生鲜的线上线下场景通过端产品关联起来，想要通过前端团队的用户侧输出从而让这些产品落地，就必须面对这些现实挑战，而应对这些挑战，首先必须搞清楚有哪些挑战，搞清楚挑战以后，我们就会认识到，首当其冲的事情，是去搭建 B2B 生鲜公司的前端技术栈和人才梯队，现在我们进入到本文的重点。</p> \n<p><a></a></p> \n<h3>三、如何应对井喷的挑战</h3> \n<p><a></a></p> \n<h5>1. 前端梯队如何搭建</h5> \n<p>创业公司的技术团队，本质上就是人和事，用合适的人搞定特定的事，人才的瓶颈就是这家公司产品落地速度和上线质量的瓶颈，因此人是第一位的，对于前端团队来说，如何一步步形成有综合战斗力的团队，取决于搭建什么层次的前端梯队，如果所有人一视同仁，培养同样的能力栈，发挥同样的兴趣向，跟进同样的业务线，那么这个梯队的扁平就会带来致命的团队瓶颈：能力可复制但不能互补，能力可递进但很难跨越，不能互补和很难跨越会导致团队内的技术路线过于单一，技术思维趋于固化，至于技术储备的丰富性和技术沟通带来的碰撞就更有限，最终导致人做事越来越机械化，甚至失去最初的技术初心。</p> \n<p>那么小菜前端到底如何搭建，还是要从公司的人员、业务和技术现状出发，由于端的碎片化和技术框架的不稳定性，就必须在质量保障上投入巨大的人力保证产品可用，而人才能力局限性和数量的匮乏，就跟产品的质量保证成为了天然的矛盾，不可协调，代码撺太快，线上天天都是 Bug，代码撺太慢，产品节奏跟不上，至于跟工程师天天宣讲要小心小心再小心，能起到的作用也不大，因为工程师本身的能力也是参差不齐的，所以就必须把团队先拆成两部分，一部分做基建支持，一部分做业务支持，基建支持的同学研发整个团队的工具脚手架、抽象和打磨团队的基础通用组件、长期维护项目的通用架构，这些投入都会反哺到业务支持的同学，业务的同学可以放心大胆的基于基建的成果做上层业务开发，稳定的工程基础有了保障，上层的业务代码做质量保障难度就大大降低了。</p> \n<p>除了分出来人做基建，做业务，还需要有核心的技术骨干，做技术前瞻性的研究，为团队 3 个月后，半年后，甚至 1 年后的技术方向，做必要的调研、测试和实验性开发，因为对于刀耕火种的早期技术团队，从原始人到迈向外太空跨空间作战，这中间还差着很多个关键的技术迭代节点，这些关键的技术迭代节点，一部分是靠外招技术专家和资深的工程师来输血发力，还有一大部分是需要靠团队内部长期的积累沉淀，也就是人才内部培养。</p> \n<p>我们总结一下：</p> \n<ul> \n <li>基建的同学负责输出工具系统、基础组件、流程规范，保证内部效率最大化和质量的有效保障</li> \n <li>架构的同学负责攻克技术底层难点，调研先进技术，升级团队技术架构，沉淀技术方案，锁定和推进团队未来技术方向</li> \n <li>业务的同学负责产品跟进，高频使用基建产品，并通过反馈来优化团队的技术基础设施，同时基于业务来抽象更多的基建需求</li> \n</ul> \n<p>基建、架构、业务这三个角色并不是相互独立，而是互有重合各有侧重，一个业务的同学，可能也同时在负责基建的事情，一个基建的同学，可能也同时在参与架构的设计，在小菜就有同学以架构和基建为主，业务也时不时的参与开发，架构和基建必须依托于业务场景来做，不能脱离了场景，不然会输出畸形的难以落地的技术方案。</p> \n<p>上面是人员的分工，还有三个重要的保障，这里不做引申，只列举一下：</p> \n<ul> \n <li>团队人员的兴趣栈、能力栈和业务要尽量匹配</li> \n <li>团队人员的阶段性目标、长期规划要跟进公司的职业晋升路线和能力模型</li> \n <li>团队要有持续性的内部技术互动分享和对外的技术理念、方法方案分享</li> \n</ul> \n<p>小菜的前端是大前端，对人的要求是：一专多精多能，至少在某个领域内朝着专家方向走，同时要慢慢精通多项技能，最后是具备多个特定技术栈的开发能力，比如 ReactNative，在小菜就是一个必须具备的开发能力，不要求每一个同学都成为 RN 专家或者精通，但要具备业务开发的能力，通俗点描述，就是能用 RN 开发业务产品。</p> \n<p>最后一点，就是资源流转，架构的同学，基建的同学和业务的同学的梯次关系是从下到上，越下越接近技术本质，越上越接近业务结果，越向下需要越好的技术实力，越向上需要越好的业务理解能力，这两个能力都是核心能力，需要让团队成员沿着梯队关系慢慢流动起来，业务中技术能力好的同学可以有机会沉下来做做基建，长期埋头基建的同学可以有机会上去做做业务，业务理解不错技术沉淀又好的同学可以继续沉下去参与架构，这样团队内部的同学都可以有多样性的技术场景和业务场景，一旦有同学请假、陷在别的业务不能抽调，马上就有同学可以补位进来开发，不会影响到产品上线节点。</p> \n<p>关于团队如何搭建，目前小菜是走到了这个算是 v1.0 的阶段，未来还有更多挑战，也会带来更多的基于公司现状的新调整，无论如何变迁，方法论我们先沉下来：</p> \n<ul> \n <li>人才梯队要有层次：基础架构、基建和业务上层等</li> \n <li>人才成长要有规划：兴趣栈、能力栈和公司关系</li> \n <li>人才能力要有扩展：单人能力和互补后的团队能力</li> \n</ul> \n<p>以人为过程，以事为结果，人事之间要有动态的机制形成互惠互补的关系，只有这样，团队才会初心不变，激情常在。</p> \n<p><a></a></p> \n<h5>2. 如何做技术选型</h5> \n<p>技术选型是一个行业老话题了，方法论也有很多，在小菜我们遵循的是：技术方向性预研大踏步，业务基建型开发小碎步，前者尽可能激进，后者尽可能保守，比如 数据报表系统，我们激进的采用 GraphQL 来解决 &nbsp;SQL =&gt; 页面 Dom 的链路问题，在宋小福 App 上面，我们就求稳的采用 v0.48 的 ReactNative 版本，而不是用当时较新的 v50+ 版本。</p> \n<p>在做技术选型之前，还有一些比较重要的基础性问题需要搞定，那就是团队技术动作的一致性，这个一致主要包含两点：</p> \n<ul> \n <li>代码规范共用一套</li> \n <li>仓库合作方式共用一套</li> \n</ul> \n<p>这两点如果不一致，会给技术选型后的落地带来内耗成本，千万不可大意。</p> \n<p>再回到技术选型本身，抛开激进保守的大踏步和小碎步，我们需要回到技术本质和工程师的本质来看待如何选的命题，技术的本质是效率，工程师的本质是兴趣，如果这一套技术选型不能带来效率，如果工程师普遍不感兴趣，那么通常这一个选型我们不会采纳，我觉得这一个主观一些的标准，大家可以参考，但这里面也要权衡好历史包袱、维护成本，上手难度等这些客观现实，如果一个新技术会带来革命性的效率提升，那么即使有上手难度和维护成本，我们也会果断入坑，比如 GraphQL 对于数据报表对于解放前后端有大幅度的提升，我们会果断入坑大力推行，如果一个技术对于团队是锦上添花，那么我们会慎重选用，比如 TypeScript，可以给工程稳定性带来了较大的保障，但我们只选择在热更新这种 RN SDK 和 Server 端的去集成，而不是一下子推广到整个团队项目中铺开用，这里面就会考虑到实际得到的好处，以及历史包袱和上手难度，反复权衡后并没有带来更大的价值，所以这两类场景的推行和不大力推行，就又不会太依赖于工程师的喜好兴趣。</p> \n<p>那么我们技术选型后的结果是如何呢？</p> \n<p>文章最开始的那张图，里面就是我们的技术栈，这里再做一下总结：</p> \n<ul> \n <li>工具类：强依赖 Node，多而杂的其他技术，如：MongoDB/Redis/MySQL/Shell/Python</li> \n <li>业务类：强依赖 React/ReactNative，适度集成其他技术，如： Redux/GraphQL/Apollo</li> \n <li>框架类：除了 React 全家桶会谨慎选择，Node 端框架则相对宽松：Koa/Thinkjs/Eggjs</li> \n</ul> \n<p>这些相对求稳，不求稳的部分，如小程序开发，我们会使用 mpvue，也会用原生，还会集成进去 GraphQL，同时一些涉及到数据爬取和视频图像识别，我们也会集成 Python/C++/TenserFLow 等等，不过这些往往是前瞻性的技术尝试，会让团队的同学适当分配精力持续研究。</p> \n<p><a></a></p> \n<h5>3. RN 的 App 工程如何架构</h5> \n<p>小菜的主要产品类型，尤其是对外的产品，主要是 RN App，而且数量较多，那么 RN 项目的合理架构就变得尤其重要，我们这里探讨下小菜前端在 RN App 上面的沉淀，涉及到原生层面的技术细节太多，这里暂不做讨论。</p> \n<p>首先，我们在构建 RN App 工程时需要关注这几个关键要素：</p> \n<ul> \n <li>配置管理</li> \n <li>静态文件管理</li> \n <li>网络请求</li> \n <li>组件管理</li> \n <li>路由管理</li> \n <li>数据缓存</li> \n <li>App 的热更新</li> \n <li>数据搜集</li> \n</ul> \n<p><strong>配置管理</strong>是指可以灵活合理的管理 App 的内部环境，主要包括：</p> \n<ul> \n <li>App 本身的一些配置</li> \n <li>所使用三方插件的配置</li> \n</ul> \n<p>我们在构建工程时尽量将所有的配置抽象统一放置在一个地方，这样便于查找和修改，但是由于大多数配置都统一放在同一个地方，那么就难免有部分文件要使用某个配置时其引用路径比较长，比如：</p> \n<pre><code class=\"javascript\">import { pluginAConfig } from \'../../../../../config\'</code></pre> \n<p>这样就造成了阅读性很差且代码不美观，因此我们可以使用 Facebook 的 <code>fbjs</code> 模块提供的一个功能<code>providesModule</code> :</p> \n<pre><code class=\"javascript\">//config.js\n/**\n * config for all\n * @providesModule config \n * 使用 providesModule 将 config 暴露出去\n **/\nimport pluginAConfig from \'./plugin_a_config\'\n\nexport default {\n    pluginAConfig\n}\n\n// 然后在其他文件中调用\n// A.js\nimport { pluginAConfig } from \'config\'</code></pre> \n<p>这样就能很方便地在 App 的任意一处使用 config 了，但是我们要避免滥用 <code>providesMoudle</code> ，因为使用了 <code>providesMoudle</code> 进行声明的模块的源码，想要在编辑器中使用跳转到定义的方式去查看比较困难，不利于团队多人合作。</p> \n<p><strong>静态资源</strong>泛指会被多次调用的图片或 icon，我们一般在 RN 使用图片时是直接引用的：</p> \n<pre><code class=\"javascript\">import { Image } from \'react-native\'\n\nrender(){\n &nbsp;return (\n    &lt;Image source={{uri: \'./logo.png\'}} /&gt;\n &nbsp;)\n}</code></pre> \n<p>当图片需要在多处使用时，我们可能会将这些可能会被反复使用的图片统一管理到 <code>assets</code> 文件夹中，统一管理和使用，但是当需要使用图片资源的文件嵌套较深时，引用图片就变得麻烦：</p> \n<pre><code class=\"javascript\">render(){\n &nbsp;return (\n &nbsp; &nbsp;&lt;Image source={{uri: \'../../../../assets/logo.png\'}} /&gt;\n &nbsp;)\n}</code></pre> \n<p>这个问题与配置管理的问题一样，可以首先将图片资源按照类型进行分类，比如 assets 文件夹下有 button/icon/img/splash/svg 等，每一个类型的结构如下：</p> \n<pre><code class=\"javascript\">- icon/\n - asset/\n - index.js</code></pre> \n<p>其中 <code>asset</code> 文件夹保存我们的图片资源，在 <code>index.js</code> 中对图片进行引用并暴露为模块：</p> \n<pre><code class=\"javascript\">// index.js\nexport default {\n   IconAlarmClockOrange: require(\'./asset/icon_alarm_clock_orange.png\'),\n   IconAvatarBlue: require(\'./asset/icon_avatar_blue.png\'),\n   IconArrowLeftBlue: require(\'./asset/icon_arrow_left_blue.png\'),\n   IconArrowUpGreen: require(\'./asset/icon_arrow_up_green.png\')\n}</code></pre> \n<p>然后再在 <code>assets</code> 文件夹下编辑 <code>index.js</code> ，将所有的图片资源作为 <code>assets</code> 模块暴露出去，为了避免和其他模块冲突你可以修改模块名为 <code>xxAssets</code></p> \n<pre><code class=\"javascript\">// assets/index.js\n/**\n * @providesModule myAssets\n **/\n import Splash from \'./splash\'\n import Icon from \'./icon\'\n import Img from \'./img\'\n import Btn from \'./button\'\n import Svg from \'./svg\'\n\n export {\n   Splash,\n   Icon,\n   Img,\n   Btn,\n   Svg\n }\n\n// A.js\nimport { Icon } from \'myAssets\'\n\nrender(){\n &nbsp;return (\n &nbsp; &nbsp;&lt;Image source={Icon.IconAlarmClockOrange} /&gt;\n &nbsp;)\n}</code></pre> \n<p>这样，我们就能很方便地将分散在项目各处的图片资源统一到一个地方进行管理了，使用起来也非常方便。</p> \n<p><strong>网络请求</strong>这块，react-native 使用 <a href=\"https://github.com/facebook/react-native/blob/master/Libraries/Network/fetch.js\" rel=\"nofollow noreferrer\">whatwg-fetch</a>，我们也可以选在其他的三方包如 <a href=\"https://github.com/axios/axios\" rel=\"nofollow noreferrer\">axios</a> 来做网络请求，但有我们在开发中遇到过一个问题，那就是我们明明已经在代码里已经修改了 cookie， 但是每次请求可能还是会带上之前的 cookie 从而造成一些困扰，所以这里推荐一个实用的组件 <code>Networking</code> :</p> \n<pre><code class=\"javascript\">import { NativeModules } from \'react-native\'\nconst { Networking } = NativeModules\n\n// 手动清除已缓存 Cookie，这样就能解决上述的问题了\nNetworking.clearCookies(callBack)</code></pre> \n<p>当然，<code>Networking</code> 的功能不止于此，还有很多其他有趣的功能可以发掘，可以直接用它来包装自己的网络请求工具，还支持 <code>abort</code> ，可以参考 <a href=\"https://github.com/facebook/react-native/blob/master/Libraries/Network/RCTNetworking.ios.js\" rel=\"nofollow noreferrer\">源码</a> 来具体把玩。</p> \n<p>使用 RN 开发 App 本身效率就比较高，如果想要继续进阶就要考虑组件化开发，一旦涉及到组件化开发，就不可避免地会涉及到组件管理的问题，这里的<strong>组件管理</strong>比较宽泛，它实际上应该指的是：</p> \n<ul> \n <li>组件规范</li> \n <li>组件类型划分</li> \n <li>组件开发标准</li> \n</ul> \n<p>组件规范指的是 UI 设计规范，我们可以与设计同学交流规定好一套特定的规范，然后将通用的样式属性（如主题颜色，按钮轮廓，返回按键，Tab 基础样式等）定义出来，便于所有的组件开发者在开发时使用，而不是开发者各自为政在开发时重复写样式文件，这里推荐一个比较好用的用于样式定义的三方插件 <a href=\"https://github.com/vitalets/react-native-extended-stylesheet\" rel=\"nofollow noreferrer\">react-native-extended-stylesheet</a> ，我们可以使用这个插件定义我们的通用属性：</p> \n<pre><code class=\"javascript\">// mystyle\nimport { PixelRatio, Dimensions } from \'react-native\'\nimport EStyleSheet from \'react-native-extended-stylesheet\'\n\nconst { width, height } = Dimensions.get(\'window\')\n\nconst globals = {\n  /** build color **/\n  $Primary: \'#aa66ff\',\n  $Secondary: \'#77aa33\',\n  $slimLine: 1 / PixelRatio.get(),\n  /** dimensions **/\n  $windowWidth: width,\n  $windowHeight: height\n}\n\nEStyleSheet.build(globals)\n\nmodule.exports = {\n  ...EStyleSheet,\n  create: styleObject =&gt; EStyleSheet.create(styleObject),\n  build: (obj) =&gt; {\n    if (!obj) {\n      return\n    }\n    EStyleSheet.build(_.assign(obj, globals))\n  }\n}\n\n// view.js\nimport MyStyleSheet from \'mystyle\'\n\nconst s = MyStyleSheet.create({\n &nbsp;container: {\n &nbsp; &nbsp;backgroundColor: \'$Secondary\',\n &nbsp; &nbsp;width: \'$windowWidth\'\n &nbsp;}\n})\n\nrender....</code></pre> \n<p>这样，我们就能在开发的任意插件或者 App 中直接使用这些基础属性，当某些属性需要修改时只需要更新 <code>mystyle</code> 组件即可，还可以衍生出主题切换等功能，使得开发更加灵活。</p> \n<p>关于组件类型我们会抛开三方组件以及原生组件，因为一旦涉及到这两者，需要写的东西就太多了，我们将组件按使用范围分为通用组件和业务组件两大类。</p> \n<p>首先什么是业务组件？即我们在开发某个业务产品常用到的组件，这个组件绑定了与业务相关的一些特殊属性，除了这个业务开发以外，其他地方都不适用，但是在开发这个业务时多个页面会频繁地使用到，所以我们有必要将其抽象出来，方便使用。</p> \n<p>什么是通用组件？即可以在 App 范围内使用甚至于跨 App 使用的组件，这里可以对这个类别进行细分，我们将能跨 App 使用的组件上传到了自己的搭建的私有 npm &nbsp;仓库，方便我们的 App 开发者使用，同时，具有 App 自己特色的组件则放到工程中统一管理，同样适用 <code>providesModules</code> 暴露出去。</p> \n<p>制定一整套组件开发标准的是很重要的，因为很多组件开发可能是多人维护的，有一套既定的规范就可以降低维护成本，组件使用的说明文档的完善也同样重要。</p> \n<p>开发 App 就不可避免地会遇到如何管理页面以及处理页面跳转等问题，也就是<strong>路由管理</strong>问题，自从 Facebook 取消了 RN 本身自带的 Navigator 以后，许多依赖于这个组件的开发者不得不将目光投向百花齐放的社区三方组件，FB 随后推荐大家使用的是 <a href=\"https://github.com/react-community\" rel=\"nofollow noreferrer\">react-community</a> 推出的 <a href=\"https://github.com/react-navigation\" rel=\"nofollow noreferrer\">react-navigation</a>&nbsp;，现在这个路由组件已经独立出来了。我们在开发时就是使用的这个组件作为路由管理组件，只不过是在其基础上做了一些定制 ，使得使用更加简单，部分跳转动作更加符合我们的产品场景，推荐大家使用这个组件。当然，除去这个组件还有很多其他的组件可供选择：</p> \n<ul> \n <li>基于 <code>react-navigation</code> 进行深度定制的 <a href=\"https://github.com/aksonov/react-native-router-flux\" rel=\"nofollow noreferrer\">react-native-router-flux</a> </li> \n <li>基于原生解决方案的 <a href=\"https://github.com/wix/react-native-navigation\" rel=\"nofollow noreferrer\">react-native-navigation</a> </li> \n <li>airbnb 的 <a href=\"https://github.com/airbnb/native-navigation\" rel=\"nofollow noreferrer\">native-navigation</a> </li> \n</ul> \n<p>路由管理作为整个 App 的骨架，它是这几个部分中最重要的一部分，合理地定制和使用路由管理可以极大地简化我们的开发复杂度。</p> \n<p>一般情况下需要缓存的数据基本上就可能是我们会在 App 很多地方都会使用到的全局数据，如用户信息，App 设置（非应用层面的设置）等，RN 提供一个 <a href=\"https://github.com/facebook/react-native/blob/master/Libraries/Storage/AsyncStorage.js\" rel=\"nofollow noreferrer\">AsyncStorage</a> 存储引擎，通常的使用方式是对这个数据引擎进行包装后暴露出符合我们要求的读写接口。这里推荐另外一种使用方式：</p> \n<p>既然需要缓存的数据可能是会在 App 很多地方使用到的全局数据，那么我们可以将这些全局数据使用 <a href=\"https://github.com/reactjs/redux\" rel=\"nofollow noreferrer\">redux</a> 来进行管理，而利器 <a href=\"https://github.com/rt2zz/redux-persist\" rel=\"nofollow noreferrer\">redux-persist</a> 则能让我们很优雅地读写我们的缓存数据。</p> \n<p>同时，如果对 <code>react-navigation</code> 进行合理的定制，接管其路由管理，那么我们还能实现保存用户退出 App 之前最后浏览的页面的状态，用户在下次打开 App 依然可以从之前浏览的地方继续使用 App，当然，这个功能要谨慎使用！</p> \n<p><strong>App 的版本更新</strong>，RN 除了传统的 App 更新外还有一个热更新的可选项（传统 App 更新也有热更新，其原理就不太一样了），社区大多数人都推荐使用 <a href=\"https://github.com/Microsoft/react-native-code-push\" rel=\"nofollow noreferrer\">codepush</a> 来进行热更新，至于其后端解决方案 貌似已经有了一个 <a href=\"https://github.com/lisong/code-push-server\" rel=\"nofollow noreferrer\">code-push-server</a> ，我们是使用自己的热更新方案，其原理就是在不更新原生代码的基础上更新 JS 代码和静态资源文件。</p> \n<p><strong>搜集的 App 使用数据</strong>(包括异常数据)并对此分析，根据分析来定位问题是保证 App 质量的有效手段之一。你可以选择自己搭建一套数据搜集服务，包括客户端 SDK 和服务端搜集服务，或者选择市场上已有的工具，目前较为成熟的收据搜集工具比较多，如友盟，mixpanel, <a href=\"https://count.ly/\" rel=\"nofollow noreferrer\">countly</a> 等等，在此不作赘述。</p> \n<p>总结一下，一个 RN App 架构应该要保证 App 的运行稳定以及开发的便捷。运行稳定这一方面，除了从 JS 层面（如单元测试，JS 错误上报等）保证之外，很大程度上还要依赖于原生层面的处理，所以团队里面要有同学的精力可以投在原生研究上面，至于开发便捷，我们尽量将复杂重要或者简单繁琐的操作在构建工程时就做掉，这样也可以大幅度提高我们的开发效率，降低开发者之间的合作沟通成本。</p> \n<p><a></a></p> \n<h5>4. 效率协同工具如何打造</h5> \n<p>效率协同往往不分家，效率宽泛一点，就是又快又好，协同宽泛一点，就是顺滑无内耗，而且效率协同在不同的场景下，一定有不同的表现，所以效率协同一定要具体到某一个场景才有意义，比如：</p> \n<p>我们要发布 6 款 RN App 中的若干款，在一周内的若干天发布，由若干人自行打包测试自行发布，那么这里面就有巨大的协同问题，同时还有一些效率问题，如果一个同学进来改了 3 行接口调用代码，他至少要有这几个阶段:</p> \n<ul> \n <li>开发阶段本机切新分支调试</li> \n <li>测试阶段打一个连接测试环境的包测试有效性</li> \n <li>测试完再打一个连接正式环境的本地包测正确性</li> \n <li>最后再打一个连接正式环境的用来热更新的包进行发布</li> \n</ul> \n<p>那么多人之间都各自来做这个发布，就会出现一些发布冲突的协同问题，如果把发布权限全回收到某一个人，协同貌似能解决，但是会带来效率问题，大家要让这个发布人频繁打包，或者打好的包，反复传给发布人，发布人的时间线就被他人的开发进程给打断了，变成了一个打包员，关于这个我专门做了一张图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1525411608024-527ad7a0-2767-4132-91ac-5da2cec086ae.png#align=left&amp;display=inline&amp;height=523&amp;originHeight=1160&amp;originWidth=1658&amp;status=done&amp;style=none&amp;width=747\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这里面的一个圆点，就代表一个编译后的包，比如 A 打出来的不需要 Debug 的连接正式环境的需要热更新的 iOS 的 ipa 包，那么 A 的这个包，跟 B 打出来的不需要 Debug 的连接正式环境的需要热更新的 iOS 的 ipa 包，即便是在同一个仓库的同一个分支，也不能保证 100% 一模一样的包，原因在于，这些本地打的包，还会受到 Node/NPM 版本（语义化），XCode 版本，原生热更新版本控制等等因素影响，导致这个包自身很容易出问题，甚至是一些人肉引发的分支和人工上传等等的影响，也会导致这个包发布出问题，举一个我们真实发生过的故障，A 打完包，把包文件钉钉传给 B，B 在发布的时候，选择本地文件时候选错了一个老版本直接发布上线，导致线上部分用户直接版本回退，我们后来不得已采用紧急回滚，才把影响范围控制住。</p> \n<p>上面大篇幅的介绍打包的这个场景，是小菜前端早期非常痛苦的一个场景，协同方式和规范无论我们如何三令五申总是避免不了人肉的问题，一旦出问题，就是大问题大故障，那么这时候，就必须投入基建的力量来打造一款或者一套流程工具，通过工具一劳永逸的解决这些主要的协同问题，把琐碎人肉的事情交给机器去做，机器比人做的快，也比人做的好。</p> \n<p>我们来总结一下，团队跑一段时间，一定会挤压一些问题，这些问题不可以视而不见，也不可以拿业务支持第一这样的借口来无限期推迟解决问题，而是时不时评估一下，有没有可能通过系统和工具，来约束一些行为，来取代一些人肉工作，进而可以一劳永逸的解决掉一些问题，一旦决定去解决了，那么如何打造协同工具就变得顺水推舟了，因为工程师最擅长的干的事情之一，就是造轮子造工具。</p> \n<p>小菜前端造了哪些轮子哪些工具呢，文章最开始就已经列出来了，这里再陈述和解释一下：</p> \n<ul> \n <li>大伯伯（谐音打包包） 解决人肉打包带来的协同问题</li> \n <li>大表姐（代号 Laurence - 来自饥饿游戏） 解决人肉发布、人工维护版本，问题追溯定位的效率问题</li> \n <li>姑奶奶 解决去多个三方平台查看异常日志和 Bug 反馈指派的人肉效率问题</li> \n <li>大舅子 解决前后端耦合在 Restful/Mock/冗余的接口 的合作效率问题</li> \n <li>RGB &nbsp; &nbsp;解决纯数字报表分析页面访问数据和用户行为的效率问题</li> \n <li>堂哥工作台 解决组员与 Leader 日报周报难回忆带来的书写效率和后期回顾问题</li> \n <li>小菜图书馆 解决小菜书架上面借书还书靠人肉记录维护的效率问题</li> \n <li>...</li> \n</ul> \n<p>其中的大舅子这个单独拿出来说一下，现在前后端常见的合作方式是基于 restful API 的接口合作，前后端经过一轮接口评审，后端再为前端写 Mock 数据，可能还会加上一个 Proxy 服务，最终前端本地的页面上，做 Mock 环境、测试环境和正式环境的切换，这种方式最大的问题有 2 个：</p> \n<ul> \n <li>前端比较依赖于后端的接口定义，后端为前端 Mock 做完后，前端才方便的进行页面中的数据替换和逻辑判断，有等待成本</li> \n <li>前端复杂多变的页面会影响到后端的接口复杂度和体积，页面上的字段增减，都会反映到接口的字段增减，接口本身变得不稳定，会带来很多隐患点，比如接口体积越来越臃肿，或者接口有多个版本，一旦接口文档更新没跟上，会导致后期的同一个接口的不同版本之间，增加调用出错概率等等</li> \n</ul> \n<p>当然业界也有各种各样规避这些问题的策略，可能是文档建设，可能是流程约束，小菜早期，哪怕到现在，也是在使用这种方式合作的，直到现在我们有了大舅子，前后端合作的方式开始进化，大舅子系统架构图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1527817993898-647eb047-03cf-4747-99b4-f31eb6bf2b00.png#align=left&amp;display=inline&amp;height=429&amp;originHeight=927&amp;originWidth=1616&amp;status=done&amp;style=none&amp;width=747\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>大舅子目前的架构是放到网关下面，网关层做一些鉴权和安全的处理，向下把一个 GraphQL 的请求转发给大舅子，大舅子上面根据这个 Query Type 对应的 Resolver 去调用下层的服务接口，下层可能是另外一个 GraphQL 服务，也可能是微服务，也可能是数据库，兼容度很高，无论是哪一种，大舅子的角色扮演就是配置和聚合：配置客户端上页面对应的数据类型，嵌套关系和数据结构，向下连接和聚合不同的数据源。</p> \n<p>内部的开发正式环境关系图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1527818051969-24d27b30-4b7f-4221-a436-9a47a0bc171d.png#align=left&amp;display=inline&amp;height=636&amp;originHeight=1080&amp;originWidth=1268&amp;status=done&amp;style=none&amp;width=747\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这个事情并不新鲜，多年前，Nodejs 就在扮演数据聚合层的角色，把多个 API 聚合成一个 API，或者打散一些 API，聚合成新的 API，但本质上依然是向客户端提供 API，这种 API 依然是面向页面，可以看做是页面驱动的 API，大舅子因为整个建模基础是 GraphQL，所以页面和数据结合的权利，交给了客户端自己去做，它需要什么数据，就在客户端声明什么数据结构，带来的好处很多，这里列举两条我认为有价值的：</p> \n<ul> \n <li>前端可以不再局限于接口评审阶段，可以继续往前提到数据库/表结构评审阶段进入开发流程，在表结构评审期就能拿到字段定义与含义，从而再大舅子上提前定义前端自己的 Type 和 Resolver</li> \n <li>后端不再耽误自己的时间为前端提供 Mock，也不再受页面 API 的约束，可以下沉精力专心做下层业务领域能努力的建设，下沉的领域能力多大，那么端上可使用和组合的能力就有多大</li> \n</ul> \n<p>从此，尘归尘，土归土，前后因为页面数据控制权的分离而解耦，也因为数据能力的回收而同时贴近业务，前端也被倒逼去了解业务，不再仅仅是界面和产品交互驱动，现在大舅子还在早期的迭代阶段，关于它的好处和优化的空间还非常非常大，今天不做深入讨论，我们来总结一下：</p> \n<p>小菜前端已经从工具基建中受益，因为工具带来了协同和效率的优化只是结果之一，最重要的收获还有两个：</p> \n<ul> \n <li>解放了小菜前端团队以及技术团队的人肉时间，可以有精力做其他事情</li> \n <li>通过基建工具研发培养了小菜前端分析问题和解决问题的能力，同时沉淀了一些不错的技术方案</li> \n</ul> \n<p>那么小菜的成长和沉淀，我们接下来就可以来总结一下了。</p> \n<p><a></a></p> \n<h3>四、技术成长和沉淀</h3> \n<p>技术成长就是工程师的能力变化，我在 4 月份给大家做了一个 10 个月前后的能力评估，这 10 个月，是小菜前端 3 年来基建密度和团队内调整最大的几个月，也是团队整体战斗力提升最大的几个月，本文的所有分析、策略和实际的解决办法，也都是在这几个月里面进行实施的，挑了几个同学，挑了几个主要的能力维度，我们感受下他们的技术成长，白色的 * 代表 10 个月之前的能力值，2 颗星代表可以熟练的开发，三颗星代表基本精通或擅长，四颗星是比较精通。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1525415185719-d923f471-39a7-4f7c-9970-d76e8b3a3886.png#align=left&amp;display=inline&amp;height=343&amp;originHeight=832&amp;originWidth=1814&amp;status=done&amp;style=none&amp;width=747\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>可以看到每个人都有不同程度不同层面的成长，有的全面开花，有的某些领域内快速积累，也要同学技术成长不多，但是协作能力工程能力有很大提升，其实还少了一个维度，就是参与业务拿到的结果或者说业务能力，图上放不下了，稍后会做分析和补充，我们再来看下这些同学做的事情：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.yuque.com/yuque/86/2018/png/87556/1525415536480-e57c2ab2-4c21-47f5-8bd5-15723be9270d.png#align=left&amp;display=inline&amp;height=420&amp;originHeight=998&amp;originWidth=1776&amp;status=done&amp;style=none&amp;width=747\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>如果仔细比照一下，我们很容易得出三个结论：</p> \n<ul> \n <li>整个技术团队综合技术能力有大幅度的提升</li> \n <li>承担职责越多的同学能力成长越多越快（如组员 A）</li> \n <li>承担繁重基建和工具开发的同学比承担业务开发的同学技术成长更多（如组员 E）</li> \n</ul> \n<p>业务能力没有放到图上，这是要补充的第四个结论</p> \n<ul>\n <li>承担业务越多的同学，项目管理能力/沟通能力/业务理解能力也越好</li>\n</ul> \n<p>以上是人才成长，那么沉淀下来的内容一共是三部分：</p> \n<ul> \n <li>通用的工具技术解决方案</li> \n <li>通用的技术模块和业务组件库</li> \n <li>团队整体的问题解决套路（分析解决问题的思维方式）</li> \n</ul> \n<p>通用的技术解决方案可以不断的快速复用，比如我们宋小福用新架构前后调整优化有 1 个月，把这同一套架构放到麦大蔬上 2 周就够了，再次迁移到新项目宋大仓里面只需要 1 周就搞定了。</p> \n<p>通用的技术模块和业务组件库，则是我们的组件三步走策略，首先是某个业务产品线下面的组件模板，比如 筛选组件或者列表组件，能在这个业务场景下的产品形态中通用，如果它可以跨产品线，那么就会跃升为 App 内通用组件，如果它还能继续抽象具有可重用性，那么就可以跃升为跨 App 的通用业务组件，比如热更新组件，地理位置定位组件，登录组件，异常提示弹窗组件等等。</p> \n<p>团队整体的问题解决套路，这个是我们最大的收获，再直白一点，就是如何更快更好更有创造性的做事，这种思维方式，解决问题的套路，本质上是可以在团队内不断传承的，无论我们后面遇到什么样的业务和团队问题，我们用这一套场景-技术-长短期投入产出比评估的路子，都能用较轻的方式把问题解决掉，这个对于我们培养新人有很大的帮助。</p> \n<p><a></a></p> \n<h3>五、对未来的展望</h3> \n<p>小菜三年走过来，前端团队从早期的技术和人员不稳定，到现在趋于稳定，站在公司的角度，最大的收获就是培养和磨炼了一批有创业热情，有担当勇气，有技术底蕴的一群人，这一群人抱团在一起，可以在所谓大前端这个框框内玩出更多的花样，支持到更多的业务场景。</p> \n<p>站在今天看明天，虽然有很多东西对我们来说依然是未知的，但我们不再像过去一样临场发怯，手忙脚乱，取而代之的是无论多大多难的业务类型，我们都可以坐下来利用这帮人的智慧汇聚出一个最优选择，胸有成竹的去做技术探索和工程尝试，在跟公司一起成长变大的过程中，站在今天看明天，虽然有很多东西对我们来说依然是未知的，但我们不再像过去一样临场发怯，手忙脚乱，取而代之的是无论多大多难的业务类型，我们都可以坐下来利用这帮人的智慧汇聚出一个最优选择，胸有成竹的去做技术探索和工程尝试，在跟公司一起成长变大的过程中，小菜前端也一定会沉淀出来更有实践价值，更有效率的技术方案，而这些就是我们将来可推广复用的宝贵技术资产，当然除了宝贵的技术资产，最最最重要的还有我们这群人，可以开心有趣有挑战性的 Coding，想进一步了解我们团队的可以<a href=\"https://cnodejs.org/topic/5ad951ec3edb2aff6be85e01\" rel=\"nofollow noreferrer\">移步这里</a>。</p> \n<blockquote>\n Scott 近年面试或线下线上技术分享，遇到太多前端同学，由于团队原因/个人原因/职业成长/技术与管理通道，甚至家庭城市等等原因，在理想国与现实之间，在放弃与坚守之间，摇摆不停，心酸硬扛，大家可以找我聊聊南聊聊北，对工程师的宿命和价值有更多的看见与了解，Scott 微信： codingdream，也可以来\n <a href=\"https://www.yuque.com/iscott\" rel=\"nofollow noreferrer\">关注 Scott 跟进我的动态</a>。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882754189-781488ce-b345-45cf-a3b7-cb5309e9caa6.png#align=left&amp;display=inline&amp;height=399&amp;name=2.png&amp;originHeight=600&amp;originWidth=600&amp;size=158647&amp;status=done&amp;style=none&amp;width=399\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"2.png\" title=\"2.png\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882773713-309efa88-e1fc-481f-865b-3c0cb0d3ec43.png#align=left&amp;display=inline&amp;height=398&amp;name=1.png&amp;originHeight=600&amp;originWidth=600&amp;size=134434&amp;status=done&amp;style=none&amp;width=398\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"1.png\" title=\"1.png\"></span></p>', 'https://cdn.yuque.com/yuque/86/2018/png/87556/1525686896336-0af87fa7-b4e7-4c43-ae22-80a5a86c7746.png#align=left&amp;display=inline&amp;height=545&amp;originHeight=990&amp;originWidth=1358&amp;status=done&amp;style=none&amp;width=747', '692c6787030d4b8882077b2ab9279c52', 'd16a93d83052441a90afaa57d69fdc3c,12f91faac18b49819869f52fbdbb1960,15941dc0af92453481b8a0626f963283', '0', '3', '1', '2020-04-16 16:49:27', '2020-04-16 16:49:27');
INSERT INTO `tb_recommend` VALUES ('cc0d20679c894ba6a6edb43f407a9358', '宜信技术学院全新升级，理念、工具、案例三大核心解读金融科技技术解决方案', '经过多年的探索和发展，宜信技术团队沉淀了海量的软件研发经验，特别是在金融科技领域，积极探索软件技术在金融服务与金融安全保障方面的智能化、创新性的技术解决方案，并取得了非常多的技术成果。2019年，围绕“...', '<p><strong>宜信技术学院成立于2017年，专注于分享与传播宜信技术团队的研发实践成果与技术解决方案。</strong></p> \n<p>经过多年的探索和发展，宜信技术团队沉淀了海量的软件研发经验，特别是在金融科技领域，积极探索软件技术在金融服务与金融安全保障方面的智能化、创新性的技术解决方案，并取得了非常多的技术成果。<strong>2019年，围绕“科技支持、科技赋能、科技引领”的理念，宜信技术团队通过数据中台、AI中台等中台化产品的落地，开发出智能聊天机器人等AI产品，对实际业务场景中的用户体验提升起到了非常大的作用。</strong>宜信技术学院通过宜信技术成果开源、研发实践经验分享、技术沙龙活动3大核心模块对外输出这些优秀的经验与成果。</p> \n<p>近期，宜信技术学院官网改版，围绕着提高内容展现效果与用户阅读体验这2个方面，在首页、内容展现页、内容推荐方式等方面进行全面升级，更加明确了<strong>宜信技术学院技术成果开源、研发实践经验分享、技术沙龙活动3大模块的核心位置，从技术逻辑、实践案例、研发工具3个角度全面分享与传播宜信技术团队的研发实践经验。</strong></p> \n<h3>定期举办技术沙龙，分享研发实践案例与技术解决方案</h3> \n<p>宜信技术学院定期邀请技术团队的技术负责人进行线上线下沙龙分享，在分享中，针对前沿技术理念或复杂技术问题在宜信的落地实践进行解读，总结软件研发的底层逻辑和解决方案。例如在2019年，宜信技术学院组织了针对数据中台、AI中台等中台相关话题的技术沙龙，分享宜信中台化产品落地的思路和方法。</p> \n<p>本次官网改版调整了活动版块的展现形式，通过在活动列表页加入活动状态展示及在活动详情页加入活动推荐列表等方式，让用户能够更加直观地了解到近期活动的主题及相关信息，同时优化了活动推荐及详情的展现样式，让信息呈现更加清晰直观。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020860270\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>每天更新技术文章，分类标签解读垂直领域技术实现逻辑</h3> \n<p>宜信技术学院官网及官方媒体账号每天都会更新技术干货文章，文章内容包含了宜信技术高管分享的技术发展理念以及一线技术专家沉淀的技术经验，其中《程序员笔记》已经成为一个让很多用户持续关注的栏目。</p> \n<p>在本次官网改版中，首页的“文章推荐”全面优化了展现形式，根据标签分类进行版块划分，文章展现更加清晰，内容呈现更加丰富，用户可以很快找到自己感兴趣的内容。同时优化了文章详情页中“相关推荐”的内容展现逻辑，用户可以根据标签持续阅读自己感兴趣的话题文章。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020860271\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>积极开源技术成果，提供研发工具共创技术开源生态</h3> \n<p>宜信技术学院主导传播多个宜信技术开源成果，并建立开发者生态。到目前为止，我们开源了Davinci、Moonbox、Wormhole、UAV.Monitor、SIA-TASK等多个技术框架，在宜信技术学院官网上对每个技术框架的特性、原理、使用方式都做了详细说明，并实时更新维护。</p> \n<p>本次官网改版，重新设计开源软件的内容展现风格，更加直观展示所有项目，用户可以更快速定位到想了解的项目。移动端更是将开源代码仓库的入口调整到最显著的位置，方便开发者快速跳转了解开源项目的源码及更多信息。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000020860272\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在本次官网改版升级中，除了强化宜信技术学院的3大核心模块外，还对一些用户体验细节做了全面升级，例如：在首页的底部增加了宜信技术学院各子页面的跳转入口、友情链接入口、联系二维码，可以更方便地联系到宜信技术学院的运营同学；在移动端的文章内容页，增加了top按钮，可以一键置顶等。</p> \n<p><strong>宜信技术学院作为宜信技术团队在软件研发实践经验上的传播窗口，持续专注于宜信技术实践经验的萃取、沉淀与传播，面向金融科技行业及软件研发行业，分享软件技术在宜信业务场景中落地的经验与思路，最终实现技术赋能业务发展和服务升级的目标。</strong></p>', 'https://segmentfault.com/img/remote/1460000020860270', 'c56940aa8b004dab84568e86900b2ee6', '6aec6c8499c44483beecd569d05c7f4b', '0', '3', '1', '2020-04-16 16:59:10', '2020-04-16 16:59:10');
INSERT INTO `tb_recommend` VALUES ('cccefb68754449cc9bdd2e70bc8c414e', 'Proxy 封装微信小程序的异步调用', '上回写到： 没看上回的同学，在这里：在微信小程序中使用 async/await {代码...} {代码...} 这不已经封装过了吗？ 这回写的是不一样的封装。因为，一个小程序里要写好多个 toAsync 调用，真的很烦呐！ 能不能一次...', '<p>上回写到：</p> \n<blockquote>\n 没看上回的同学，在这里：\n <a href=\"https://segmentfault.com/a/1190000021966277\">在微信小程序中使用 async/await</a> \n</blockquote> \n<pre><code class=\"js\">// utils/async.js\n\nfunction wxPromisify(fn) {\n    return async function(args) {\n        return new Promise((resolve, reject) =&gt; {\n            fn({\n                ...(args || {}),\n                success: res =&gt; resolve(res),\n                fail: err =&gt; reject(err)\n            });\n        });\n    };\n}\n\nexport function toAsync(names) {\n    return (names || [])\n        .map(name =&gt; (\n            {\n                name,\n                member: wx[name]\n            }\n        ))\n        .filter(t =&gt; typeof t.member === \"function\")\n        .reduce((r, t) =&gt; {\n            r[t.name] = wxPromisify(wx[t.name]);\n            return r;\n        }, {});\n}</code></pre> \n<pre><code class=\"js\">// pages/somepage/somepage.js\n\nimport { toAsync } = require(\"../../utils/async\");\n\n// ...\n\nconst awx = toAsync([\"login\", \"request\"]);\nawait awx.login();\nawait awx.request({...});</code></pre> \n<p>这不已经封装过了吗？</p> \n<p>这回写的是不一样的封装。因为，一个小程序里要写好多个 <code>toAsync</code> 调用，真的很烦呐！</p> \n<hr> \n<p>能不能一次封装，到处调用？能！把所有用到的方法都在初始化的时候封装起来。可是，难免会有遗漏。</p> \n<p>能不能一次封装，到处调用，还不需要初始化？</p> \n<p>能！祭出 Proxy 大神：</p> \n<pre><code class=\"js\">// utils/asyncjs\n\nfunction wxPromisify(fn) { ... }    // 前面已经定义过了\n\nexport function asyncProxy(target) {\n    return new Proxy(target, {\n        cache: {},\n        get(it, prop) {\n            const aFn = this.cache[prop];\n            if (aFn) { return aFn; }\n            const v = it[prop];\n            if (typeof v !== \"function\") {\n                return v;\n            }\n            return this.cache[prop] = wxPromisify(v);\n        }\n    });\n}</code></pre> \n<pre><code class=\"js\">// app.js\nimport { asyncProxy } from \"./utils/async\";\n\nApp({\n    onLaunch: function() {\n        wx.awx = asyncProxy(wx);\n        // ....\n    }\n})</code></pre> \n<pre><code class=\"js\">// pages/somepage/somepage\n// ...\nconst { awx } = wx;\nawait awx.login();\nawait awx.request({...});</code></pre> \n<hr> \n<p>解释：</p> \n<p>因为 <code>awx</code> 是代理的 <code>wx</code> 对象，调用 <code>awx.login()</code> 的时候，实际是先调用代理的 <code>get(wx, \"login\")</code>，找到用来代替 <code>wx.login</code> 的东西。</p> \n<p>根据上面代码里的逻辑，先从 <code>cache</code> 里找使用 <code>wxPromisify()</code> 封装的结果，若有，直接返回；若没有，先封装成 Promise 网络的函数，存入 <code>cache</code>，再返回。</p> \n<p>直观一点描述，大概是这样：</p> \n<pre><code>awx.login();\n   ^^^^^^\n   get(wx, \"login\")</code></pre> \n<hr> \n<p>请关注公众号<strong>边城客栈</strong>⇗</p> \n<p>看完了先别走，点个赞啊 ⇓，赞赏 ⇘ 也行！</p>', null, 'c56940aa8b004dab84568e86900b2ee6', '3b375646301546259a8fb29d74ae4447,631c6273e6474a3d858ca44050a4bc8b,499b6d4decaa4985b8272adc258273fc,6e98a760af6d411d8e06b244853c67e9', '0', '3', '1', '2020-04-16 16:49:25', '2020-04-16 16:49:25');
INSERT INTO `tb_recommend` VALUES ('cd0c32a6cfeb4dc3b96c8a8065850644', '跨端开发框架深度横评之2020版', '对应小程序开发领域，这一年也发生了巨大变化。开发框架从单纯的微信小程序开发，过渡到多端框架成为标配，进一步提升开发效率成为开发者的强烈需求。', '<p>又是一年四月天，距离上次发布<a href=\"https://segmentfault.com/a/1190000018738455\">跨端开发框架深度横评</a>已过去整整一年。</p> \n<p>这一年，小程序在用户规模及商业化方面都取得了极大的成功。微信小程序日活超过3亿，支付宝、百度、字节跳动小程序的月活也纷纷超过3亿。</p> \n<p>对应小程序开发领域，这一年也发生了巨大变化。开发框架从单纯的微信小程序开发，过渡到多端框架成为标配，进一步提升开发效率成为开发者的强烈需求。</p> \n<p>这一年 <code>mpvue</code> 停止更新，<code>Taro</code>开始探索 <code>taro next</code>，<code>uni-app</code> 产品和生态持续完善，微信新推出了支持H5和微信小程序的 <code>kbone</code> 框架...</p> \n<p>去年的深度横评中很多老将已经退出江湖，一些新秀吸引眼球，因此，是时候来一波2020版的新横评了。</p> \n<h2>评测目标筛选</h2> \n<p>跨端框架是一个重投入工作，在各框架的1年多的比拼中，很多框架因为投入不足而逐渐被开发者放弃，<code>uni-app</code>和<code>taro</code>依靠持续的大力度投入，成为了市场主流。</p> \n<p><code>taro</code> 在稳定版的基础之上，最近也推出了 <code>taro next</code>，这2个版本差异较大，本次会分别评测。</p> \n<p><code>kbone</code> 框架虽面世不久，但毕竟是微信官方发布，关注的人不少，故本次将 <code>kbone</code> 加入评测目标。</p> \n<p>所以，本次评测的对象（按发布时间排序）：</p> \n<ul> \n <li>微信原生开发</li> \n <li>taro，京东凹凸实验室出品，官网地址：<a href=\"https://taro.jd.com/\" rel=\"nofollow noreferrer\">https://taro.jd.com/</a> </li> \n <li>uni-app，DCloud出品，官网地址：<a href=\"https://uniapp.dcloud.net.cn\" rel=\"nofollow noreferrer\">https://uniapp.dcloud.net.cn</a> </li> \n <li>kbone，腾讯微信团队出品，官网地址：<a href=\"https://wechat-miniprogram.github.io/kbone/docs/\" rel=\"nofollow noreferrer\">https://wechat-miniprogram.github.io/kbone/docs/</a> </li> \n</ul> \n<p>本次评测除了运行性能等实测数据外，尽可能得通过框架官网及github、掘金、腾讯课堂等三方社区公开采集数据，希望给大家一个综合全面的评估依据。</p> \n<h2>功能实现</h2> \n<p><code>taro</code> 和 <code>uni-app</code> 是比较典型的多端框架，发布到各个端均可。而 <code>kbone</code> 只支持微信小程序和H5。</p> \n<p><code>taro</code> 和 <code>uni-app</code> 均将常用接口及组件封装了成了跨端API和跨端组件，组件规范沿用微信小程序的规范，部分平台特有API，这两个框架亦有应对方案：</p> \n<ul> \n <li>taro：支持<a href=\"https://nervjs.github.io/taro/docs/hybrid.html\" rel=\"nofollow noreferrer\">与小程序代码混写</a>，可通过混写的方式调用框架尚未封装的小程序新增API</li> \n <li>uni-app：支持<a href=\"https://uniapp.dcloud.io/platform\" rel=\"nofollow noreferrer\">条件编译</a>，可在条件编译代码块中，随意调用各个平台新增的API及组件</li> \n</ul> \n<p><code>taro</code> 和 <code>uni-app</code> 可以不受限的调用各家小程序平台所有的API及组件。</p> \n<p><code>kbone</code> 沿用<code>web</code>的开发习惯，使用<code>html</code>标签及<code>js api</code>；涉及微信特有api时，可通过<code>process.env.isMiniprogram</code>判断环境，然后编写微信原生代码。对于<code>html</code>中没有标签可替代的微信内置组件（如<code>swiper</code>），需要使用 <code>wx-component</code> 标签或者使用 <code>wx-</code> 前缀，这样的内置组件会被包裹一层自定义组件，带来相应的性能开销。</p> \n<p>除了接口、组件之外，我们以微信小程序为例，找几个典型能力对比框架支持度：</p> \n<table> \n <thead>\n  <tr> \n   <th align=\"center\">框架</th> \n   <th align=\"center\">taro</th> \n   <th align=\"center\">uni-app</th> \n   <th align=\"center\">kbone</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td align=\"center\">微信自定义组件</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n  <tr> \n   <td align=\"center\">三方插件</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">❌</td> \n  </tr> \n  <tr> \n   <td align=\"center\">分包加载</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n  <tr> \n   <td align=\"center\">sitemap</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n  <tr> \n   <td align=\"center\">wxs</td> \n   <td align=\"center\">❌</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">❌</td> \n  </tr> \n  <tr> \n   <td align=\"center\">云开发</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n   <td align=\"center\">⭕️</td> \n  </tr> \n </tbody> \n</table> \n<p>补充说明：</p> \n<ul> \n <li>如果在 Taro 项目引用了小程序原生的第三方组件，那么该项目将不再具备多端转换的能力，例如，如果使用了微信小程序的第三方组件，那么项目只能转换成微信小程序，转义成其他平台会失效，详见<a href=\"https://taro-docs.jd.com/taro/docs/mini-third-party.html\" rel=\"nofollow noreferrer\">taro官网</a> </li> \n <li>uni-app 中使用微信自定义组件的话，支持编译发行到App/H5/微信小程序/QQ小程序4个平台，详见<a href=\"https://uniapp.dcloud.net.cn/frame?id=%e5%b0%8f%e7%a8%8b%e5%ba%8f%e7%bb%84%e4%bb%b6%e6%94%af%e6%8c%81\" rel=\"nofollow noreferrer\">uni-app官网</a> </li> \n <li>taro 不支持 wxs 的依据：<a href=\"https://github.com/NervJS/taro/issues/2959\" rel=\"nofollow noreferrer\">#2959</a> </li> \n <li>kbone 不支持微信三方插件的依据：<a href=\"https://github.com/Tencent/kbone/issues/58\" rel=\"nofollow noreferrer\">#58</a>；不支持wxs的依据：<a href=\"https://github.com/Tencent/kbone/issues/129\" rel=\"nofollow noreferrer\">#129</a> </li> \n <li>云开发在微信平台，三个框架都支持，但 taro/kbone仅支持微信小程序平台，uni-app支持<code>App/H5/小程序</code>所有平台使用云开发，详见下方 <code>serverless/云开发</code> 章节。</li> \n</ul> \n<p><code>wxs</code>是提升性能体验的重要利器，除了微信小程序的<code>wxs</code>外，还有支付宝的<code>SJS</code>、百度的<code>Filter</code>，这些高级技术 <code>uni-app</code> 均完善支持。参考：<a href=\"https://juejin.im/post/5d7f366b6fb9a06af8250bc4\" rel=\"nofollow noreferrer\">谜之wxs，uni-app如何用它大幅提升性能</a></p> \n<p>从如上功能对比来看：微信原生 ~ uni-app &gt; taro &gt; kbone</p> \n<h2>运行性能</h2> \n<p>我们继续沿用去年的测试模型，看看一年来，各家小程序开发框架的性能是否有提升。详细如下：</p> \n<ul> \n <li>开发内容：开发一个仿微博小程序首页的复杂长列表，支持下拉刷新、上拉翻页、点赞。</li> \n <li>界面如下：</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326485\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ul> \n <li>开发版本：一共开发了5个版本，包括微信原生版、taro版、uni-app版、kbone版，按照官网指引通过<code>cli</code>方式默认安装。</li> \n <li>taro 目前稳定版本是2.0版，但近期在宣传跨框架的taro next，故我们基于同样的 react代码，同时测试了taro 2.0 和 taro next 两个版本的数据。</li> \n <li>测试代码开源（<a href=\"https://github.com/dcloudio/test-framework\" rel=\"nofollow noreferrer\">Github仓库地址：https://github.com/dcloudio/test-framework</a>），</li> \n</ul> \n<p><em>Tips:若有同学觉得测试代码写法欠妥，欢迎提交 PR 或 <a href=\"https://github.com/dcloudio/test-framework/issues\" rel=\"nofollow noreferrer\">Issus</a></em></p> \n<ul> \n <li>测试机型：红米 Redmi 6 Pro、MIUI 11.0.5 稳定版（最新版）、微信版本 7.0.12（最新版）</li> \n <li>测试环境：每个框架开始测试前，杀掉各App进程、清空内存，保证测试机环境基本一致；每次从本地读取静态数据，屏蔽网络差异。</li> \n</ul> \n<p>我们以上述仿微博小程序为例，测试2个容易出性能问题的点：长列表加载、大量点赞组件的响应。</p> \n<h3>长列表加载</h3> \n<p>仿微博的列表是一个包含很多组件的列表，这种复杂列表对性能的压力更大，很适合做性能测试。</p> \n<p>从触发上拉加载到数据更新、页面渲染完成，需要准确计时。人眼视觉计时肯定不行，我们采用程序埋点的方式，制定了如下计时时机：</p> \n<ul> \n <li>计时开始时机：交互事件触发，框架赋值之前，如：上拉加载（onReachBottom）函数开头</li> \n <li>计时结束时机：页面渲染完毕(微信setData回调函数开头)</li> \n</ul> \n<p>Tips：<code>setData</code>回调函数开头可认为是页面渲染完成的时间，是因为微信<code>setData</code>定义如下(<a href=\"https://developers.weixin.qq.com/miniprogram/dev/reference/api/Page.html?search-key=Page.prototype.setData\" rel=\"nofollow noreferrer\">微信规范</a>)：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326486\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>测试方式：从页面空列表开始，通过程序自动触发上拉加载，每次新增20条列表，记录单次耗时；固定间隔连续触发 N 次上拉加载，使得页面达到 20*N 条列表，计算这 N 次触发上拉到渲染完成的平均耗时。</p> \n<p>测试结果如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326487\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>说明：以400条微博列表为例，从页面空列表开始，每隔1秒触发一次上拉加载（新增20条微博），记录单次耗时，触发20次后停止（页面达到400条微博），计算这20次的平均耗时，结果微信原生在这20次 <code>触发上拉 -&gt; 渲染完成</code> 的平均耗时为538毫秒，最快的<code>uni-app</code>是446毫秒，最慢的<code>kbone</code>是4057毫秒</p> \n<p>大家初看这个数据，可能比较疑惑，别急，下方有详细说明</p> \n<p><strong>说明1：为何 taro next/kbone 测试数据不完整?</strong></p> \n<p>因为 <code>taro next</code> 和<code>kbone</code> 采用的是动态渲染方案，这类方案在页面复杂、组件较多时，会大量增加页面 <code>dom</code> 节点数量，甚至超出微信的 <code>dom</code> 节点数限制（如下告警信息）。我们在 红米手机（Redmi 6 Pro）上实测，页面组件超过600个时，<code>taro next</code>、<code>kbone</code> 实现的仿微博App就会报出运行异常，并停止渲染（页面白屏），故这两个测试框架在组件较多时，测试数据不完整。这也就意味着，当页面组件太多时，无法使用这2个框架。</p> \n<blockquote>\n dom limit exceeded please check if there\'s any mistake you\'ve made\n</blockquote> \n<p>另外，kbone官网有如下介绍：</p> \n<blockquote>\n kbone 是使用一定的性能损耗来换取更为全面的 Web 端特性支持。\n</blockquote> \n<p>故<code>taro next</code>、<code>kbone</code>的测试数据，明显和<code>taro 2.0</code>、<code>uni-app</code>不是一个量级的。</p> \n<p>如果你的应用是长列表场景，那<code>taro next</code>、<code>kbone</code>就明显不太合适。</p> \n<p><strong>说明2：为什么测试数据显示uni-app 会比微信原生框架的性能略好呢？</strong></p> \n<p>这个问题在去年的测评中，已解释过。为了避免新同学迷惑，这里再次说明一下。</p> \n<p>微信原生框架耗时主要在<code>setData</code>调用上，开发者若不单独优化，则每次都会传递大量数据；而 <code>uni-app</code>、<code>taro</code> 都在调用<code>setData</code>之前自动做<code>diff</code>计算，每次仅传递变动的数据。</p> \n<p>例如当前页面有20条数据，触发上拉加载时，会新加载20条数据，此时原生框架通过如下代码测试时，<code>setData</code>会传输40条数据</p> \n<pre><code>data: {\n    listData: []\n},\nonReachBottom() { //上拉加载\n    let listData = this.data.listData;\n    listData.push(...Api.getNews());//新增数据\n    this.setData({\n        listData\n    }) //全量数据，发送数据到视图层\n}</code></pre> \n<p>开发者使用微信原生框架，完全可以自己优化，精简传递数据（每次仅传递变化的20条数据），比如修改如下：</p> \n<pre><code class=\"javascript\">data: {\n    listData: []\n},\nonReachBottom() { //上拉加载\n    // 通过长度获取下一次渲染的索引\n    let index = this.data.listData.length;\n    let newData = {}; //新变更数据\n    Api.getNews().forEach((item) =&gt; {\n        newData[\'listData[\' + (index++) + \']\'] = item //赋值，索引递增\n    }) \n    this.setData(newData) //增量数据，发送数据到视图层\n}</code></pre> \n<p>经过如上优化修改后，再次测试，微信原生框架性能数据如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326489\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>从测试结果可看出：</p> \n<ul> \n <li>经过开发者手动优化，微信原生框架可达到更好的性能；</li> \n <li> <code>uni-app</code>相比微信原生，性能接近，算是一个数量级；并且随着数据量增加，性能消耗增加不明显，从438到454，只有16毫秒的变化</li> \n <li> <code>taro 2.0</code>随着数据量越大，性能损耗随着增大，从595到790，有将近200毫秒的变化；</li> \n <li> <code>taro next</code>和<code>kbone</code>相比之下，差距就比较大了。</li> \n</ul> \n<p>这个结果，和<code>web</code>开发类似，<code>web</code>开发也有原生js开发、<code>vue</code>、<code>react</code>框架等情况。如果不做特殊优化，原生js写的网页，性能经常还不如<code>vue</code>、<code>react</code>框架的性能。</p> \n<p>也恰恰是因为<code>Vue</code>、<code>react</code>框架的优秀，性能好，开发体验好，所以原生js开发已经逐渐减少使用了。</p> \n<p><strong>说明3：为何今年的性能测试数据和去年的不同？</strong></p> \n<p>细心的同学会发现，同样的测试手机，同样的测试代码，为何今年的性能数据会比<a href=\"https://juejin.im/post/5ca1736af265da30ae314248#heading-3\" rel=\"nofollow noreferrer\">去年的数据</a>有大幅提升？</p> \n<ul> \n <li>taro、uni-app及微信原生，三个框架的数据都有大幅提升，400条记录时，至少都有300毫秒的优化</li> \n <li>uni-app及优化后的微信原生，随着数据量的增加，耗时数据变化并不明显，但去年是很明显的线性增长</li> \n</ul> \n<p>其实，通过微信原生工程的数据对比，就能得出结论：2019年，微信针对小程序运行时做了大幅性能优化。</p> \n<p>这对开发者来说应该是个<strong>好消息</strong>，小程序性能体验更佳，可承载更好的用户业务。</p> \n<p>复杂长列表加载下一页评测结论：微信原生开发(手动优化) ~ <code>uni-app</code> &gt; 微信原生开发(未手动优化) ~ <code>taro 2.0</code> &gt; <code>taro next</code> &gt; <code>kbone</code></p> \n<h3>点赞组件响应速度</h3> \n<p>长列表中的某个组件，比如点赞组件，点击时是否能及时的修改未赞和已赞状态？是这项测试的评测点。</p> \n<p>测试方式：</p> \n<ul> \n <li>选中某微博，点击“点赞”按钮，实现点赞状态状态切换（已赞高亮、未赞灰色），</li> \n <li>点赞按钮 <code>onclick</code>函数开头开始计时，<code>setData</code>回调函数开头结束计时；</li> \n</ul> \n<p>在红米手机（Redmi 6 Pro）上进行多次测试，求其平均值，结果如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326488\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>说明：也就是在列表数量为400时，微信原生开发的应用，点赞按钮从点击到状态变化需要26毫秒。</p> \n<p>测试结果数据说明：</p> \n<ul> \n <li>taro next/kbone 测试数据不完整的原因同上，在组件较多时，页面已经不再渲染了</li> \n <li>taro 2.0版本、uni-app和微信原生在点赞组件上的性能体验接近，但taro next和kbone有较大的性能差距，这个也是因为动态运行时框架导致的。</li> \n</ul> \n<p>组件数据更新性能测评：<code>uni-app</code> ~ <code>taro 2.0</code> &gt; <code>taro next</code> &gt; <code>kbone</code></p> \n<p>综上，本性能测试做了2个测试，长列表加载和组件状态更新，综合2个实验，结论如下：</p> \n<p>微信原生开发(手动优化) ~ <code>uni-app</code> &gt; 微信原生开发(未手动优化) ~ <code>taro 2.0</code> &gt; <code>taro next</code> &gt; <code>kbone</code></p> \n<h2>跨端支持</h2> \n<p>这三个框架都是为了解决平台同构问题，跨端的比较是必需的。</p> \n<p><code>taro</code> 和 <code>uni-app</code> 相对比较成熟，支持主流的所有平台。kbone 只支持微信小程序和 Web 端。我们重点比较一下 <code>taro</code> 和 <code>uni-app</code>。</p> \n<h3>小程序平台</h3> \n<p><code>taro</code> 和 <code>uni-app</code> 均支持微信、支付宝、百度、字节跳动小程序，功能基本可以拉齐。</p> \n<p>双方都有不少大厂案例，<code>taro</code>有京东、货拉拉、淘票票等公司小程序案例，<code>uni-app</code>有腾讯、华为、vivo、联想、中华英才网等公司小程序案例。</p> \n<h3>App平台</h3> \n<ul>\n <li>能力方面</li>\n</ul> \n<p><code>taro</code>与微信小程序引擎拉齐度较低，很多功能需要开发者分别在iOS和Android上做原生开发才能实现。比如App端很常见的三方登录、支付、分享等能力，<code>taro</code>并未封装。</p> \n<p><code>uni-app</code>则在基础引擎层面提供了丰富的能力，还提供了丰富的插件市场，可切实提升开发者的效率。</p> \n<ul>\n <li>性能方面</li>\n</ul> \n<p><code>taro</code>在App端使用了<code>react native</code>的渲染引擎，虽然渲染层ui是原生的，但在实时交互和高响应要求的UI操作方面表现一直不佳，js层和视图层的通信损耗让很多开发者深感无力。</p> \n<p><code>uni-app</code>的App引擎同时给开发者提供了原生渲染引擎和小程序引擎的双选方案，并且由于发明了renderjs技术，以及支持wxs、bindingx等技术，解决了js层和视图层的通信损耗问题，在高响应要求的UI操作方面有更好的性能表现。比如这类canvas动画：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326491\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ul>\n <li>开发体验方面</li>\n</ul> \n<p>taro的开发者需自行搭建iOS/Android开发环境，比较繁琐，（<a href=\"https://taro-docs.jd.com/taro/docs/react-native.html#%E6%90%AD%E5%BB%BA-android-%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83\" rel=\"nofollow noreferrer\">官方原文地址</a>）：</p> \n<p><code>uni-app</code>可以做到让前端开发者不依赖原生工程师独立完成App。其开发的小程序，可以更平滑的变成可商用的App。</p> \n<p>使用跨平台开发的核心诉求在于提升效率，如果一个App的开发由前端、iOS、Android等3拨工程师协作完成，其实效率反而非常低。</p> \n<p>另外，<code>uni-app</code>还提供了uni小程序sdk，这个工具可以帮助原生App快速搭建自己的小程序平台。这是其他框架所未提供的。</p> \n<h3>H5平台</h3> \n<p>taro的H5平台在一年来的进步较多，可用性大幅提升。但相比于<code>uni-app</code>，目前仍然缺失对wxs和小程序组件的支持。</p> \n<h3>快应用</h3> \n<p><code>taro</code>支持快应用的时间比<code>uni-app</code>早。</p> \n<p>但快应用发展到2020年有了一些变化，<code>uni-app</code>针对新的形势，提供了2个发行到快应用的方案（当前两个版本都处于社区维护状态）：</p> \n<ul> \n <li>quickapp-vue版：<a href=\"https://doc.quickapp.cn/tutorial/others/vue.html\" rel=\"nofollow noreferrer\">使用 Vue开发快应用</a>。此方案由小米主导，但华为快应用暂不支持。</li> \n <li>quickapp-light版：基于小程序架构的快应用（Light版），详见<a href=\"https://www.hellohub.cn\" rel=\"nofollow noreferrer\">https://www.hellohub.cn</a>。此方案由华为主导，但小米快应用暂不支持。</li> \n</ul> \n<h3>跨端灵活性</h3> \n<p>跨端开发，离不开条件编译。因为不能用统一来抹杀各个平台的特色。</p> \n<p>优良的条件编译能力对各端开发的灵活度至关重要，可以让开发者在共享和个性化之间游刃有余。</p> \n<p><code>taro</code> 、<code>uni-app</code>和 <code>kbone</code> 均支持在<code>js</code>代码通过<code>process.env</code>判断平台，然后编写平台特有代码。</p> \n<p><code>taro</code>额外支持统一接口的多端文件编码方式，以及在样式文件中使用<code>ifdef</code>条件编译。</p> \n<p><code>uni-app</code>是全面可条件编译的，目录、文件、配置、组件、js、css，所有一切均可通过<code>ifdef</code>条件编译。</p> \n<p>跨端支持小结结论：<code>uni-app</code> &gt; <code>taro</code> &gt; <code>kbone</code></p> \n<h2>开发体验</h2> \n<p><code>taro</code>、<code>uni-app</code>、<code>kbone</code>均支持<code>cli</code>模式，可以在主流前端工具中开发，且基本都带有d.ts的语法提示库。三个框架均支持主流的<code>vue</code>或<code>react</code>语法，配套的ide工具链较丰富，着色、校验、格式化完善。</p> \n<p>相比微信原生，这三个开发框架的开发体验都更为优秀。</p> \n<p>但在开发工具维度上，明显高出一截的框架是<code>uni-app</code>，其出品公司同时也是HBuilderX的出品公司<a href=\"https://dcloud.net.cn/\" rel=\"nofollow noreferrer\">DCloud.io</a>，HBuilderX为<code>uni-app</code>做了很多优化，代码提示、转到定义、easycom、运行调试...故<code>uni-app</code>的开发效率、易用性非其他框架可及。</p> \n<p>开发体验维度，对比结果：<code>uni-app</code> &gt; <code>taro</code>,<code>kbone</code></p> \n<h2>serverless/云开发</h2> \n<p>serverless是目前炙手可热的一个概念，被称为下一代的云技术，是真正的”云“。</p> \n<p>微信率先将 serverless 技术引入小程序开发领域，即<a href=\"https://developers.weixin.qq.com/miniprogram/dev/wxcloud/basis/getting-started.html\" rel=\"nofollow noreferrer\">云开发</a>，帮助开发者云端一体的完成业务。随后，支付宝、百度都上线了自己的云开发。根据微信公开的数据，已经有50万开发者在使用微信云开发了。</p> \n<p>不过小程序厂家主导的云开发存在一个天然限制，就是和平台绑定过紧，无法和其它平台共享数据。</p> \n<p>我们以微信云开发为例，如果你仅开发微信小程序，数据独家存在微信平台，那没问题；但如果你同时还有App或其他家小程序，此时微信小程序的数据存储在微信平台，其它平台的数据存储在开发者自己的服务器上，此时就出现了数据割裂。假设一个用户先使用小程序，个人数据存储在微信平台；有了粘性后升级到App，此时App端无法读取微信平台的数据，则用户就无法查看之前在小程序上的历史数据，甚至在App平台需要重新注册。这种情况对开发者是不利的。</p> \n<p>因此，跨端的 serverless 方案才是开发者的最优解。</p> \n<p>目前主流框架对云开发的支持情况：</p> \n<ul> \n <li>Taro：仅支持微信小程序，详见<a href=\"https://taro-docs.jd.com/taro/docs/wxcloudbase.html\" rel=\"nofollow noreferrer\">小程序云开发模板</a> </li> \n <li>uni-app：DCloud 联合阿里云、腾讯云，提供基于 serverless 模式和 js 编程的云开发平台，支持App/H5/小程序所有平台，详见<a href=\"https://uniapp.dcloud.net.cn/uniCloud/README\" rel=\"nofollow noreferrer\">uniCloud</a> </li> \n <li>kbone：仅支持微信小程序，详见<a href=\"https://wechat-miniprogram.github.io/kbone/docs/guide/advanced.html#%E4%BA%91%E5%BC%80%E5%8F%91\" rel=\"nofollow noreferrer\">云开发</a> </li> \n</ul> \n<p>serverless 维度上，<code>uni-app</code>大幅领先其它框架。</p> \n<h2>插件市场</h2> \n<p>一个开发框架能否成功，除了框架自身的高度产品化外，开发者生态的构建也至关重要。</p> \n<p><code>uni-app</code> 于2018年底率先推出<a href=\"https://ext.dcloud.net.cn\" rel=\"nofollow noreferrer\">插件市场</a>，支持前端组件、js sdk、页面模板、项目模板、原生插件等多种类型，且提供了赞赏、付费购买等手段，刺激轮子作者的创作激情。目前市场上已发布插件接近1500个，众多插件下载量都在万次以上。</p> \n<p><code>Taro</code> 于 2019年5月上线<a href=\"http://taro-ext.jd.com/\" rel=\"nofollow noreferrer\">物料市场</a>，目前市场上已发布物料90个；从热门榜单来看，下载量并不大，下载最多的也就数百。</p> \n<p><code>kbone</code>目前还没有插件市场。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326490\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Tips:</p> \n<ul>\n <li>插件数量及下载量数据采集时间为 2020.04.03 16：00</li>\n</ul> \n<p>插件市场维度，<code>uni-app</code>独领风骚。</p> \n<h2>学习资源</h2> \n<p>除了各大框架官网外，开发者通常还会通过视频教程、社区博客等方式系统学习。</p> \n<p>相关学习资源的丰富程度，也能侧面反映一个框架的受欢迎程度，故我们采集了几个三方站点的数据。</p> \n<p><strong>视频教程</strong></p> \n<table> \n <thead>\n  <tr> \n   <th>框架</th> \n   <th>腾讯课堂</th> \n   <th>网易云课堂</th> \n   <th>慕课网</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>taro</td> \n   <td>4</td> \n   <td>1</td> \n   <td>2</td> \n  </tr> \n  <tr> \n   <td>uni-app</td> \n   <td>16</td> \n   <td>16</td> \n   <td>1</td> \n  </tr> \n </tbody> \n</table> \n<p>Tips：</p> \n<ul>\n <li>视频教程数据采集时间为2020.04.05 22:00</li>\n</ul> \n<h2>开发交流</h2> \n<p>除了入门的学习资源，开发期的交流也很重要，这个我们主要看官方组织的社区和交流群。</p> \n<h3>社区论坛</h3> \n<p><code>uni-app</code> 的<a href=\"https://ask.dcloud.net.cn\" rel=\"nofollow noreferrer\">问答社区</a>，帖子丰富，沉淀较多；目前已沉淀2万多相关帖子，每日更新帖子数百篇，月uv百万。</p> \n<p>对于习惯使用 github issue反馈问题的用户，<code>uni-app</code>同样支持，目前累计有1391个issues。</p> \n<p>Taro 早期基于github issue进行产品Bug管理，目前累计已有近4898个issue；后于2019年5月上线<a href=\"http://taro-club.jd.com/\" rel=\"nofollow noreferrer\">开发者社区</a>，和物料市场上线时间相同，目前沉淀1300+帖子，每日更新帖子在10个左右，相关数据计算方法如下：</p> \n<ul> \n <li>帖子总数：Taro 社区顶部选择<code>板块</code>，计算每个板块下所有主题总数，如下图。</li> \n <li>每日更新帖子数：根据帖子列表中的最后回复时间，计算24小时内有回复或评论的主题总数</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326492\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>kbone 在微信开放社区中新增了一个<a href=\"https://developers.weixin.qq.com/community/minihome/mixflow/1213301129006825473\" rel=\"nofollow noreferrer\">Kbone官方框架</a>的专区，因产品发布较晚，目前只有一百多个帖子。</p> \n<p>总结一下社区帖子及issue数据，情况如下（采集时间为 2020.04.03 23：00）：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326493\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>交流群</h3> \n<table> \n <thead>\n  <tr> \n   <th>框架</th> \n   <th>微信群</th> \n   <th>QQ群</th> \n   <th>交流群开发者（预估）</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>taro</td> \n   <td>16</td> \n   <td>-</td> \n   <td>8k</td> \n  </tr> \n  <tr> \n   <td>uni-app</td> \n   <td>20</td> \n   <td>40+</td> \n   <td>90k</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>-</td> \n   <td>1</td> \n   <td>0.5k</td> \n  </tr> \n </tbody> \n</table> \n<p>Tips:</p> \n<ul> \n <li>Taro 有16个微信群是根据 Taro 官网上显示<code>Taro 开发交流 15 群 已满</code>推论而出，每个微信群500人，交流群人数： 500*16 = 8000人</li> \n <li>uni-app 官网 QQ群有35个，微信群20个，还有十几个专项QQ群，其中有30个QQ群达到2000人，交流群人数： 30 <em> 2000 + 5</em> 1000 + 20*500 + 5000 = 90000人</li> \n <li>kbone 在 github 的 readme中有一个qq交流群，申请加入时显示500人已满</li> \n</ul> \n<p>除了交流群外，DCloud对外公布的<code>uni-app</code>的开发者数量达到百万人，暂未看到<code>taro</code>和<code>kbone</code>公布此类数据。</p> \n<p>总体而言，开发交流维度比较结果如下：<code>uni-app</code> &gt; <code>taro</code> &gt; <code>kbone</code></p> \n<h2>其它指标</h2> \n<h3>github</h3> \n<table> \n <thead>\n  <tr> \n   <th>框架</th> \n   <th>star</th> \n   <th>贡献者</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>taro</td> \n   <td>24.6k</td> \n   <td>122</td> \n  </tr> \n  <tr> \n   <td>uni-app</td> \n   <td>19.7k</td> \n   <td>72</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>2.7k</td> \n   <td>7</td> \n  </tr> \n </tbody> \n</table> \n<p>在开源社区方面，<code>Taro</code>做的还是非常成功的，它吸引了更多开发者为其贡献代码、文档。</p> \n<h3>百度指数</h3> \n<p>通过<a>index.baidu.com</a>，可查看主流框架的搜索指数，它代表了网友的搜索量和相关文章的收录量。目前<code>kbone</code>尚未收录到百度指数中，如下是近期 <code>uni-app</code> 和 <code>taro</code>的百度指数对比图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326494\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>结语</h2> \n<p>所有的评测都只是提供决策依据，最后的结果还是要依赖开发者的团队技术栈、业务诉求、未来规划等。</p> \n<p>不过作为一篇评测文章的结语，我们还是要给出自己的建议：</p> \n<ul> \n <li>如果你熟悉React，不懂Vue.js，推荐Taro；</li> \n <li>如果你熟悉Vue.js，则推荐 uni-app；</li> \n <li>如果你已经有H5代码，只想增加微信小程序平台，并且对性能要求不高，可以考虑kbone；</li> \n <li>如果你的业务涉及多端，更推荐 uni-app；</li> \n <li>如果你希望通过 serverless 方案快速上线业务，推荐 uni-app。</li> \n</ul> \n<p>如有读者认为本文中任何评测失真，欢迎在这里报 <a href=\"https://github.com/dcloudio/test-framework/issues\" rel=\"nofollow noreferrer\">issuse</a>。</p>', 'https://segmentfault.com/img/remote/1460000022326485', '5ca4567d892841b087fac5246effac40', '15ef803612034600809b3e6c99cb32ab,7506700dea5a42298b9ecb0ac0aaab41,3b375646301546259a8fb29d74ae4447', '0', '3', '1', '2020-04-16 16:47:11', '2020-04-16 16:47:11');
INSERT INTO `tb_recommend` VALUES ('ced542b2a9234651bc1dbb0a8266a3e8', 'NIO、BIO、AIO 与 PHP 实现', '最近看到NIO，AIO，Netty，Promise话题很热，我作为一个phper也想来凑凑热闹，凑着凑着发现周围怎么都是javaer，jser。那么PHP能做NIO，AIO么？', '<h2>前言</h2> \n<p>最近看到NIO，AIO，Netty，Promise话题很热，我作为一个phper也想来凑凑热闹，凑着凑着发现周围怎么都是javaer，jser。那么<code>PHP</code>能做<code>NIO</code>，<code>AIO</code>么？</p> \n<h2>什么BIO、NIO、AIO</h2> \n<p><code>BIO</code> 同步阻塞I/O。</p> \n<p>有小伙伴又要问了啥叫 <code>同步</code>，啥叫<code>阻塞</code>啊？</p> \n<h4>同步/异步 阻塞/非阻塞</h4> \n<p><strong>同步:</strong> 两个同步任务相互依赖，并且一个任务必须以依赖于另一任务的某种方式执行。 比如在<code>A-&gt;B</code>事件模型中，你需要先完成 A 才能执行B。 再换句话说，同步调用种被调用者未处理完请求之前，调用不返回，调用者会一直等待结果的返回。</p> \n<p><strong>异步:</strong> 两个异步的任务完全独立的，一方的执行不需要等待另外一方的执行。再换句话说，异步调用种一调用就返回结果不需要等待结果返回，当结果返回的时候通过回调函数或者其他方式拿着结果再做相关事情，</p> \n<p><strong>阻塞:</strong> 阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续。</p> \n<p><strong>非阻塞:</strong> 非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。</p> \n<p>以上就是这四个词汇的解释，那么放到计算机IO上，比较接地气的解释</p> \n<h3>BIO （Blocking I/O)</h3> \n<p>那么我们拿快递揽件来举例，一个快递公司，有一部分工作是揽件，它的工作模式是只能一个一个的揽件，你要寄快递，必须排队，一个一个的来，这就是 <strong>同步</strong> 。好不容易轮到你了，你把快递一扔给他，他还让给你等着，快递工作人员说，我们这后面还有些信息要录入，快递要检查，必须等我们快递公司检查完毕后，你才能离开，这叫 <strong>阻塞</strong> 。</p> \n<h3>NIO （No-Blocking I/O）</h3> \n<p>同步非阻塞的I/O</p> \n<p>继续啊，拿快递公司举例。这个快递公司发现有些用户在后面排队，排着排着，太久了就去隔壁快递公司了，怎么办呢？快递公司想了个办法，置办了一个发号器和一批收纳盒。来一个客户，就把快递放在一个收纳盒里，再给用户一个编号，此时再来一个用户，不论前面一个的快递是否检查完毕，还是给他一个收纳盒，发一个编号。不同客户之间不排队，一来就被受理了，这就是 <strong>非阻塞</strong>。 我们再来看看内部，快递呢还是一个个地录入信息，X光检查，这样就是 <strong>同步</strong> 运行的，等待快递人员检查完毕叫号，客户拿到回执才能离开快递点。</p> \n<h3>AIO （Asynchronous I/O）</h3> \n<p>异步非阻塞IO</p> \n<p>也有Javaer叫他 NIO2，快递公司揽件又升级了，做了一个快递柜，客户又寄件需求，来了就放入快递柜，然后通过手机扫码关注这个柜子的动态，客户就可以离开了，此时服务被受理，并能马上离开。这就是 <strong>非阻塞</strong> 。等到快递人员来揽件时，会将柜子里面的寄件一并取走，快递点集中一起处理这些快递件，发现有问题的件，不是立即停下手中的活等待客户来出来，而是放一旁通知客户来，然后继续处理下一个快递，这就是 <strong>异步</strong>。</p> \n<h4>异步 阻塞 IO</h4> \n<p>同步/异步 阻塞/非阻塞，这4个名词，两两组和，还有一个就是 <code>异步/阻塞</code>。</p> \n<p>那么我们还是先把例子举出来吧，还是这个快递点，来了一批客户来寄口罩到国外，由于有很大的可能会通不过检查，所以，快递点把大家都留了下来。等所有的 寄件 都检查完了在统一给大家发送回执单，这就是 <strong>阻塞</strong> 。快递人员检查寄件时，发现问题不是立马通知客户来处理，而已放到一边，继续处理下一个。 这就是 <strong>异步</strong>。</p> \n<h4>伪异步 IO</h4> \n<p>这种模式，底层实现是多个 <code>同步阻塞的BIO</code>， 同时运行。</p> \n<p>最后总结一下：</p> \n<blockquote>\n 阻塞与非阻塞指的的是当不能进行读写（网卡满时的写/网卡空的时候的读）的时候， I/ O操作立即返回还是阻塞；同步异步指的是，当数据已经 \n <code>ready</code> 的时候，读写操作是同步读还是异步读，阶段不同而已。\n</blockquote> \n<h3>区别</h3> \n<h4>异步/同步在计算机区别</h4> \n<p>以上是一些举例，只是帮助大家理解记忆，接下来我们看看计算上的实现。</p> \n<p>最初计算机提供的Web服务，采用的是 <a href=\"https://baike.baidu.com/item/CGI/607810\" rel=\"nofollow noreferrer\"><code>CGI</code></a> 协议，就是纯正的 <code>BIO</code> 模式。一个<code>cgi</code>进程监听一个端口，处理完一个请求，才能接收下一个http请求。这就是<code>同步</code>。</p> \n<blockquote>\n 而客户的实际体验式是\"异步\"的，那是因为后来优化了，\n <code>CGI</code> 程序能够自我fork进程的达到同时响应多个\n <code>http</code>请求的效果。\n</blockquote> \n<p>注意，我们这里讨论的基础是 <strong>单进程</strong> ，上的 <code>异步/同步</code>。</p> \n<h4>阻塞/非阻塞在计算机区别</h4> \n<p>这里拿购物流程举例，用户的下单，需要做如下操作：</p> \n<ul> \n <li>商品可售否</li> \n <li>库存数量</li> \n <li>用户余额</li> \n <li>触发哪些优惠规则</li> \n <li>奖券有效性</li> \n <li>...</li> \n</ul> \n<p>按照一般做法就是一步步验证，上一个检查完了，再进行下一个检查，这就是 <strong>阻塞</strong> 的方式。</p> \n<p>那么非阻塞方式如何做呢，假设在微服务环境中，商品，库存，奖券，促销都是独立的系统，调用商品服务，发起商品可售检查请求；不等商品服务回复，继续调用库存服务，发起商品可售库存请求；紧接着依次发出...检查请求，这样5个检查项目的请求同时发起，最后，我等他们所有的请求都回复我，再来一起来校验是否所有的检查都通过了。就这种发起请求不等响应，就继续做下一件事的叫 <strong>非阻塞</strong> 。</p> \n<p>转载著名<a href=\"https://segmentfault.com/a/1190000022356197\">来源sifou</a></p> \n<h2>PHP 能做什么</h2> \n<h3>PHP 与 BIO 实现</h3> \n<p>PHP已经实现啦，这是最基本的好么。但平时测试时却感觉是不阻塞啊，好，我们来一起做个实验，将nginx和php-fpm的进程限制为1个试试。php-fpm就是 多进程的 BIO，现在我们强项改成单进程。</p> \n<ul>\n <li>调整Nginx配置</li>\n</ul> \n<p>调整 <code>/etc/nginx/nginx.conf</code> 文件:</p> \n<pre><code class=\"shell\">## 把nginx worker数量设置为1\nworker_processes 1;</code></pre> \n<p>好了之后我们通过ps命令检查下<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFnUN\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<ul>\n <li>调整PHP配置</li>\n</ul> \n<p>调整 <code>/etc/php/php-fpm/conf.d/www.conf</code> 文件：</p> \n<pre><code class=\"shell\">pm = static\n\npm.max_children = 1\n\npm.start_servers = 1\n\npm.min_spare_servers = 1\n\npm.max_spare_servers = 1</code></pre> \n<p>找到这几个配置都改为如上数值。</p> \n<p>最后的结果如下</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFnVm\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>我在<code>index.php</code>代码里面加入第一行就加入了sleep。</p> \n<pre><code class=\"php\">&lt;?php\nsleep(5);</code></pre> \n<p>我们同时打开两个网页，一起访问试试<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFnW4\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>通过Firefox 抓包可以发现，其中一个耗时5s，另一个页面耗时9.3s，<em>（0.7s误差是我手速慢了）</em> 这就是 BIO。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFnX2\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>好的，我们再做一个实验。把以上nginx，php-fpm配置中<code>1</code>改成<code>2</code>.然后我们打开<code>三个网</code>页，<code>同时访问</code>试试看。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFnZH\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>结果是有<code>两个网页耗时5s</code>，<code>一个是9s</code>，也就是说服务器同时处理了2个请求，第三个请求等待了4s才被处理。这就是 多线程-BIO，<strong>一个服务同时接待的客户数量取决与worker的数量</strong>。</p> \n<h3>PHP 与 NIO 实现</h3> \n<p>我们写的大部分php-fpm代码以及第三方框架都是阻塞的。PHP也是支持<code>非阻塞</code>IO编程的。</p> \n<p>这里其他博主也用PHP原生代码实现NIO编程： <a href=\"https://segmentfault.com/a/1190000015365056#item-6\">PHP回顾之socket编程</a>。</p> \n<h3>I/O 多路复用</h3> \n<p>在这段小Demo中，PHP 实现 NIO 核心两个函数就是 <code>stream_set_blocking</code>、<code>stream_select()</code>。<br>通过以上源码，发现原生的NIO实现还是比较繁琐，不易读的。同时，我就想问一句了，这个 <code>NIO</code> 就是为了实现一个 socket server 么，我们来看看<a href=\"https://netty.io/\" rel=\"nofollow noreferrer\">Netty 官网</a>。打开Netty首页，它是这样描述自己的</p> \n<blockquote>\n Netty is a NIO client server framework which enables quick and easy development of network applications such as protocol servers and clients. It greatly simplifies and streamlines network programming such as TCP and UDP socket server.\n</blockquote> \n<p>第一句话：Netty是一个 <code>NIO 客户端</code> 服务框架, 能快速轻松地开发协程<code>客户端</code>。第二句话：简化了网络编程，如创建TCP和UDP套接字服务。</p> \n<p>好，重点是什么？第一句话就是重点——开发 协程<code>客户端</code>！回到我们业务上，刚刚举了一个例子，购物到下单，有很多个流程需要做检查，按照一般的BIO那么程序时序图如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFFlf\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"nio购物流程检查\" title=\"nio购物流程检查\"></span></p> \n<p>从上可以看到，三个检查依次分开执行。那么客户的等待时间是大于，库存检查时间加上，产品检查时间加上，促销检查时间 的。</p> \n<p>假设, 库存，产品，促销是三个微服务，然后购物车服务用 <code>NIO客户端</code>，与这三个微服务交互，那么会是怎样的效果呢：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFFna\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"nio请求时序图\" title=\"nio请求时序图\"></span></p> \n<p>这里，我们发起检查请求时，是按照顺序发起的，但不等第一个服务返回检查结果就开始发起下一个检查请求。最后三个服务都返回后，综合结果，返回给用户。那么这三个检查的耗时，就等于一个服务（耗时最长的那个服务）的检查耗时。大大减少得了购物车服务响应时间。</p> \n<blockquote>\n 我看到一些 \n <code>Netty</code>、 \n <code>NodeJS</code>、\n <code>Swoole</code> 等教程 通篇都在讲如何实现一个\n <code>WebSocket</code>服务，\n <code>TCP</code>服务或者是\n <code>Http</code>服务。对，这是最基础的，但 \n <code>NIO</code> 框架核心优势在开发一个非阻塞\n <code>客户端</code>！这才是它的优势，这才是和 \n <code>BIO</code> 编程差异化所在.\n</blockquote> \n<h3>NIO 客户端</h3> \n<p>看到以上两个时序图，还是给大家演示一下用PHP原生代码实现一个 <code>PHP-BIO</code> 。 <a href=\"https://gitee.com/xupaul/php-nio-server\" rel=\"nofollow noreferrer\">PHP Simple NIO Server</a></p> \n<blockquote>\n 建议大家点击链接，把源码\n <code>git clone https://gitee.com/xupaul/php-nio-server</code> 到本地运行一下，再来看截图更容易理解。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFMRS\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<blockquote>\n 这三个所依赖的服务响应耗时，我设置为：inventory: 4s, product: 2s, promo:6s\n</blockquote> \n<p>蓝色框和黄色框标注了两个请求，我们主要看参数 <code>noBlocking： true/false</code> 的不同, 第一个是非阻塞方式请求， 可以看到共耗时6s，第二个共耗时12s！ <em>（第三个为啥和第二个耗时不一样——6s这个留给大家去研究）</em>。显而易见得非阻塞IO的优势。不过这代码结构就不那么友好了，看到代码 nio_server.php 中，有两种请求方式，阻塞代码流程还能看懂检查完成后就综合结果返回，而非阻塞方式中，发起三个检查后程序流程就开始进入到<code>handleMessage</code>，代码进入哪个分支，取决于 <code>socket_read</code> 的消息，不运行起程序来，没有文档，很难搞懂整个程序流程。</p> \n<p>那么，有没有什么什么方便的php类库，让我们编码更友好一点呢，这里介绍下 <a href=\"https://reactphp.org/\" rel=\"nofollow noreferrer\">ReactPHP</a> </p> \n<p>这里我用ReactPHP重新实现 <code>nio_server</code>, 代码在<a href=\"https://gitee.com/xupaul/php-nio-server/blob/master/react-php-demo/react_nio_server.php\" rel=\"nofollow noreferrer\">这里</a></p> \n<blockquote>\n 这个回调代码写起来有点 \n <code>NodeJS</code> 的味道呢，当你的PHP没启用 libev 之类的拓展时，\n <code>ReactPHP</code>内部Loop依然用的 \n <code>stream_select()</code>, 可以看源码 \n <code>~/react/event-loop/src/StreamSelectLoop.php@290</code> .\n</blockquote> \n<p>执行效果如下：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFN9K\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>能同时发起请求这个功能，那还得提一下 <code>curl_multi</code>， 它能同时发起多个<code>curl</code>请求，最后不断检查是否所有的curl请求已完成。这只是在发起多个<code>Http</code> <code>curl</code>请求阶段做到 <code>非阻塞</code> 运行。</p> \n<p>还有个拓展<a href=\"https://www.php.net/manual/zh/book.pthreads.php\" rel=\"nofollow noreferrer\">pThreads</a>，能够实现多线程，不过对PHP编译参数有限制，需要在线程安全的模式下运行。</p> \n<blockquote>\n pThreads 现在已不是PHP官方所推荐使用的拓展了，当然了这种就属于\n <code>伪异步IO</code>范畴了\n</blockquote> \n<h3>PHP 与 AIO</h3> \n<p><code>PHP</code> <code>异步&amp;非阻塞</code> 编码。</p> \n<p>此处， 非阻塞I/O 系统调用( nonblocking system call ) 和 <strong>异步I/O系统调用 （asychronous system call）</strong>的区别是：</p> \n<ul> \n <li>一个非阻塞I/O 系统调用 <code>read()</code> 操作立即返回的是任何可以立即拿到的数据， 可以是完整的结果， 也可以是不完整的结果， 还可以是一个空值。</li> \n <li>而异步I/O系统调用 <code>read()</code> 结果必须是完整的， 但是这个操作完成的通知可以延迟到将来的一个时间点。</li> \n</ul> \n<pre><code class=\"php\">&lt;?php\n\n/**\n * 消息处理\n */\nfunction handleMessage() {\n    global $changed, $clients, $cartCheck;\n    foreach ($changed as $key =&gt; $client) {\n        while (true) {\n            // read socket data\n            $msg = @fread($client, 1024);\n//            $msg = 1;\n            if ($msg) {\n                // application process\n            } else {\n                if (feof($client)) {\n                    // TODO check data eof\n                }\n                break;\n            }</code></pre> \n<p>可以看到，在文件<a href=\"https://gitee.com/xupaul/php-nio-server/blob/master/cart-server-demo/nio_server.php\" rel=\"nofollow noreferrer\"><code>~/nio_server.php</code></a> 中， 虽然设置了 <code>stream_set_blocking false</code>， 但是在209行的 <code>fread()</code> , 这是在一个循环里读，这是一个阻塞读取。这的系统函数的响应速度是受系统IO影响的。</p> \n<p>而异步调用中，当有<code>I/O事件</code>时，系统会将数据复制到用户内存中，也就是准备好数据，再通知到用户程序。</p> \n<p>那么原生PHP显然是不支持的，这里呢就要引入PHP拓展，就是 <a href=\"https://www.php.net/manual/zh/book.event.php\" rel=\"nofollow noreferrer\"><code>Event</code></a>，或者 <a href=\"https://www.php.net/manual/zh/book.ev.php\" rel=\"nofollow noreferrer\"><code>Ev</code></a> 拓展。这篇博客主要讲 <code>Event</code>。</p> \n<blockquote> \n <code>Event</code> 拓展是基于 \n <a href=\"https://libevent.org/\" rel=\"nofollow noreferrer\"><code>libevent</code></a> 库封装而来，而 \n <code>Ev</code> 拓展是基于 \n <a href=\"http://software.schmorp.de/pkg/libev\" rel=\"nofollow noreferrer\"><code>libev</code></a> 库封装而来。 通过PHP接口，和C库的接口就能看到他们之间的联系，所以，如果通过PHP文档找不到相关资料可以去，看看C库的文档。而 \n <code>Libevent</code> 年久失修，不推荐大家使用。\n</blockquote> \n<p>这里放上用<code>Event</code>实现的<code>Tcp Server</code> <a href=\"https://gitee.com/xupaul/php-nio-server/blob/master/event-php-demo/event_buffer_socket_server.php\" rel=\"nofollow noreferrer\">demo</a></p> \n<p>在用<code>Event</code>做这个<code>demo</code>中，我用到了<code>EventBuffer</code> ，读、写都和<code>Buffer</code>交互, <code>Buffer</code>数据是用户态数据，不会等待系统I/O或被阻塞，避免了程序耗时在I/O数据拷贝上。由此PHP 也能实现 <code>AIO</code> 程式，提高CPU利用率。</p> \n<p>讲到这里，就会感觉这个PHP的<code>AIO</code>有些牵强了，我这找了其他博主的论点来帮助大家理解，这两张图展示了 用户程序，与内核采用 <code>分阻塞</code> 和 <code>异步</code> 交互时的异同。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFW7f\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>上面是<code>非阻塞IO</code>，下面是<code>异步IO</code>。中间的区别就是<code>非阻塞IO</code>的应用，需要不断的去访问内核获取数据（当然了，每一次访问都是有求必应，能取到数据），但不一定能取完; 而<code>异步IO</code>的特点就是，你告诉内核取数据，取完整了，我再一起发给应用程序。这就是Linux对<code>异步IO</code>的定义。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFW7c\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>那么再看到我们的Demo，这是一个简单TCP server，一个TCP请求系统是能知道一个数据的包大小的，是否接收完毕，这是传输层要做的。而我们的应用层面，是接收到数据还要做合并，分包，以及数据转码。 这就和 <strong><code>AIO</code> 数据结果必须是完整的</strong>，概率有些出入，（在系统层面显然是完整的） . 在应用层面呢，一次性收到的不一定是完整的数据，那么就还需要做额外代码来解决合包，分包，沾包。这就是<code>AIO</code>实现<code>Tcp Server</code>的需要问题。</p> \n<blockquote>\n 为了解决以上问题，就需要自定义TCP通讯协议。相当于自己开发RPC框架了。\n</blockquote> \n<p>那我们来看看Http呢，在应用层面有明确公开的协议(协议有头无尾，标明了每次请求具体长度)，并有丰富的实现。这就是一个非常适合采用<code>AIO</code>编程协议。而PHP的<code>Event</code>拓展，恰好有<a href=\"https://www.php.net/manual/zh/class.eventhttp.php\" rel=\"nofollow noreferrer\"><code>EventHttp</code></a>实现。</p> \n<p>话不多说，先上 <a href=\"https://gitee.com/xupaul/php-nio-server/blob/master/event-php-demo/event_http_server.php\" rel=\"nofollow noreferrer\"><code>Demo</code></a>。</p> \n<pre><code class=\"php\">&lt;?php\n...\n\n/**\n * event http 请求回调函数\n * \n * @param   \\EventHttpRequest   $req    Http请求对象\n */\nfunction _http_about($req) {\n    echo __METHOD__, PHP_EOL;\n    // print request URL\n    echo \"URI: \", $req-&gt;getUri(), PHP_EOL;\n    // print request\'s headers\n    echo \"Input headers:\"; var_dump($req-&gt;getInputHeaders());\n    echo \"\\n &gt;&gt; Sending reply ...\";\n    /**\n     * @var \\EventBuffer    $buf\n     */\n    $buf = $req-&gt;getOutputBuffer();\n    $buf-&gt;add(\"It\'s about Event http server\");\n    $req-&gt;sendReply(200, \"OK\", $buf);\n    echo \"OK\\n\";\n}</code></pre> \n<p>这里是一个回调函数，入参数就是一个由 <code>EventHttp</code> 封装的http请求对象。这就满足了以上 调用时非阻塞，数据完全准备好后，再通知回调——<strong>异步I/O</strong>。好，借助<code>Event</code>，PHP就实现了<code>AIO</code>.</p> \n<h2>结语</h2> \n<p>关于性能提升，这就不做压测了，主要论证PHP实现<code>NIO</code>、<code>AIO</code> 的可行性。也实际给大家展示了几个<code>Demo</code>, 简单展示了如何写<code>异步</code>,<code>非阻塞</code>程序。可以看到 异步编程 对大家的要求是比较高的，当需要发起 IO 操作，都要用非阻塞方式调用，不然就会阻塞整个进程，而纯粹的异步编程就是单进程，阻塞后该服务就不能响应新的请求。同时呢，我们常用PDO，mysqli，Redis这些不得不用的拓展，也只提供了阻塞读的接口。而当前PHP环境中，可以说“几乎所有”的第三方框架，都是阻塞编码，如果你的项目中使用了其他框架，那么你写的代码没问题，不保证依赖的第三方框架阻塞方式请求 <code>I\\O</code>. 所以，<strong>一般 PHP 异步编程，都会采用多进程异步</strong>，让异步来提高每个请求的响应速度，如果进程阻塞，就让其他空闲的进程处理新进入的请求。</p> \n<p>以上，希望大家通过文章能了解 <code>异步/同步</code>、<code>阻塞/非阻塞</code>区别，以及对PHP<code>异步</code>、<code>非阻塞</code>编程。</p> \n<p>有问题欢迎提问～</p> \n<h2>参考</h2> \n<ol> \n <li><a href=\"https://blog.csdn.net/linvo/article/details/5466046\" rel=\"nofollow noreferrer\">PHP实现非阻塞</a></li> \n <li><a href=\"https://segmentfault.com/a/1190000015365056\">PHP回顾之socket编程</a></li> \n <li><a href=\"http://nikic.github.io/2012/12/22/Cooperative-multitasking-using-coroutines-in-PHP.html\" rel=\"nofollow noreferrer\">Cooperative multitasking using coroutines (in PHP!)</a></li> \n <li><a href=\"https://blog.csdn.net/historyasamirror/article/details/5778378\" rel=\"nofollow noreferrer\">IO - 同步，异步，阻塞，非阻塞</a></li> \n <li><a href=\"https://blog.csdn.net/lengxiao1993/article/details/78154467\" rel=\"nofollow noreferrer\">同步/异步，阻塞/非阻塞概念深度解析</a></li> \n <li><a href=\"https://www.cnblogs.com/52fhy/p/9258040.html\" rel=\"nofollow noreferrer\">PHP之高性能I/O框架：Libevent</a></li> \n <li><a href=\"https://zhuanlan.zhihu.com/p/20315482\" rel=\"nofollow noreferrer\">网络编程（三）：从libevent到事件通知机制</a></li> \n</ol>', 'https://segmentfault.com/img/bVbFnUN', '1894b118d35d44cb8fe8009529c4154b', '84e1fca09c4340be87d5c1ef4601b026,2fd0d43e373d4a38add451c1ae47594f,79c58d0fa766471e8390a7d60e9f57be,0c52f81f27204666928190ebbc74d1aa,9661fbcbaed6483c9f5992883e9a62a6', '0', '3', '1', '2020-04-16 16:47:10', '2020-04-16 16:47:10');
INSERT INTO `tb_recommend` VALUES ('d0e5f3f566cd44b0b80e762d5bd265f2', '[Skr-Shop]购物车之架构设计', 'skr shop是一群底层码农，由于被工作中的项目折磨的精神失常，加之由于程序员的自傲：别人设计的系统都是一坨shit，我的设计才是宇宙最牛逼，于是乎决定要做一个只设计不编码的电商设计手册。', '<p>来还债了，希望大家在疫情中都是平安的，回来的时候公司也还在！</p> \n<hr> \n<blockquote>\n skr shop是一群底层码农，由于被工作中的项目折磨的精神失常，加之由于程序员的自傲：别人设计的系统都是一坨shit，我的设计才是宇宙最牛逼，于是乎决定要做一个只设计不编码的电商设计手册。\n</blockquote> \n<p>在上一篇文章 <a href=\"https://dayutalk.cn/2019/12/09/%E8%B4%AD%E7%89%A9%E8%BD%A6%E8%AE%BE%E8%AE%A1%E4%B9%8B%E9%9C%80%E6%B1%82%E5%88%86%E6%9E%90/\" rel=\"nofollow noreferrer\">购物车设计之需求分析</a> 描述了购物车的通用需求。本文重点则在如何实现上进行架构上的设计（业务+系统架构）。</p> \n<h1>说明</h1> \n<p>架构设计可以分为三个层面：</p> \n<ul> \n <li>业务架构</li> \n <li>系统架构</li> \n <li>技术架构</li> \n</ul> \n<p>快速简单的说明下三个架构的意思；当我们拿到购物车需求时，我们说用Golang来实现，存储用Redis；这描述的是技术架构；我们对购物车代码项目进行代码分层，设计规范，以及依赖系统的规划这叫系统架构；</p> \n<p>那业务架构是什么呢？业务架构本质上是对系统架构的文字语言描述；什么意思？我们拿到一个需求首先要跟需求方进行沟通，建立统一的认知。比如：规范名词（购物车中说的商品与商品系统中商品的含义是不同的）；建立大家都能明白的模型，购物车、用户、商品、订单这些实体之间的互动，以及各自具备什么功能。</p> \n<p>在业务架构分析上有很多方法论，比如：领域驱动设计，但是它并不是唯一的业务架构分析方法，也并不是说最好的。适合你的就是最好的。我们常用的实体关系图、UML图也属于业务架构领域；</p> \n<p>这里需要强点一点的是，不管你用什么方式来建模设计，有设计总比没设计强，其次一定要将建模的内容体现到你的代码中去。</p> \n<p>本文在业务架构上的分析借助了 <code>DDD</code> （领域驱动设计）思想；还是那句话<code>适合的就是最好的</code>。</p> \n<h1>业务架构</h1> \n<p>通过前面的需求分析，我们已经明确我们的购物车要干什么了。先来看一下一个典型的用户操作购物车过程。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277102\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"用户旅程\" title=\"用户旅程\"></span></p> \n<p>在这个过程中，用户使用购物车这个载体完成了商品的购买流程；不断流动的数据是商品，购物车这个载体是稳定的。这是我们系统中的稳定点与变化点。</p> \n<p>商品的流动方式可能多种多样，比如从不同地方加入购物车，不同方式加入购物车，生命周期在购物车中也不一样；但是这个流程是稳定的，一定是先让购物车中存在商品，然后才能去结算产生订单。</p> \n<p>商品在购物车中的生命周期如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277103\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"过程\" title=\"过程\"></span></p> \n<p>按照这个过程，我们来看一下每个阶段对应的操作。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277104\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"过程对应的操作\" title=\"过程对应的操作\"></span></p> \n<p>这里注意一点，加车前这个操作其实我们可以放到购物车的添加操作中，但是由于这部分是非常不稳定且多变的。我们将其独立出来，方便后续进行扩展而不影响相对比较稳定的购物车阶段。</p> \n<blockquote>\n 上面这三个阶段，按照DDD中的概念，应该叫做实体，他们整体构成了购物车这个域；今天我们先不讲这些概念，就先略过，后面有机会单独发文讲解。\n</blockquote> \n<h2>加车前</h2> \n<p>通过流程分析，我们总结出了系统需要具备的操作接口，以及这些接口对应的实体，现在我们先来看加车前主要要做些什么；</p> \n<p>加车前其实主要就是对准备加入的购物车商品进行各个纬度的校验，检查是否满足要求。</p> \n<p>在让用户加车前，我们首先解决的是用户从哪里卖，然后进行验证？因为同一个商品从不同渠道购买是存在不同情况的，比如：小米手机，我们是通过秒杀买，还是通过好友众筹买，或者商城直接购买，价格存在差异，但是实际上他是同一个商品；</p> \n<p>第二个问题是是否具备购买资格，还是上面说的，秒杀、众筹这个加车操作，不是谁都可以添加的，得现有资格。那么资格的检查也是放到这里；</p> \n<p>第三个问题是对这个购买的商品进行商品属性上的验证，如是否上下架，有库存，限购数量等等。</p> \n<p>而且大家会发现，这里的验证条件可能是非常多变的。如何构建一个方便扩展的代码呢？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277105\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"加车的验证\" title=\"加车的验证\"></span></p> \n<p>整个加车过程，重要的就是根据来源来区分不同的验证。我们有两种选择方式。</p> \n<p>方式一：通过策略模式+门面模式的方式来搞定。策略就是根据不同的加车来源进行不同的验证，门面就是根据不同的来源封装一个个策略；</p> \n<p>方式二：通过责任链模式，但是这里需要有一个变化，这个链在执行过程中，可以选择跳过某些节点，比如：秒杀不需要库存、也不需要众筹的验证；</p> \n<p>通过综合的分析我选择了责任链的模式。贴一下核心代码</p> \n<pre><code>// 每个验证逻辑要实现的接口\ntype Handler interface {\n    Skipped(in interface{}) bool // 这里判断是否跳过\n    HandleRequest(in interface{}) error // 这里进行各种验证\n}\n\n// 责任链的节点\ntype RequestChain struct {\n    Handler\n    Next *RequestChain\n}\n\n// 设置handler\nfunc (h *RequestChain) SetNextHandler(in *RequestChain) *RequestChain {\n    h.Next = in\n    return in\n}</code></pre> \n<p>关于设计模式，大家可以看我小伙伴的github：<a href=\"https://github.com/TIGERB/easy-tips/tree/master/go/src/patterns\" rel=\"nofollow noreferrer\">https://github.com/TIGERB/eas...</a></p> \n<h2>购物车</h2> \n<p>说完了加车前，现在来看购物车这一部分。我们在之前曾讨论过，购物车可能会有多种形态的，比如：存储多个商品一起结算，某个商品立即结算等。因此购物车一定会根据渠道来进行购物车类型的选择。</p> \n<p>这部分的操作相对是比较稳定的。我们挑几个比较重要的操作来讲一下思路即可。</p> \n<h3>加入购物车</h3> \n<p>通过把条件验证的前置，会发现在进行加车操作时，这部分逻辑已经变得非常的轻量了。要做的主要是下面几个部分的逻辑。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277107\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"加入购物车\" title=\"加入购物车\"></span></p> \n<p>这里有几个取巧的地方，首先是获取商品的逻辑，由于在前面验证的时候也会用到，因此这里前面获取后会通过参数的方式继续往后传递，因此这里不需要在读库或者调用服务来获取；</p> \n<p>其次这里需要把当前用户现有购物车数据获取到，然后将添加的这个商品添加进来。这是一个类似合并操作，原来这个商品是存在，相当于数量加一；需要注意这个商品跟现存的商品有没有父子关系，有没有可能加入后改变了某个活动规则，比如：原来买了2个送1个赠品，现在再添加了一个变成3个，送2个赠品；</p> \n<blockquote>\n 注意：这里的添加并不是在购物车直接改数量，可能就是在列表、详情页直接添加添加。\n</blockquote> \n<p>通过将合并后的购物车数据，通过营销活动检查确认ok后，直接回写到存储中。</p> \n<h3>合并购物车</h3> \n<p>为什么会有合并购物车这个操作？因为一般电商都是准许游客身份进行操作的，因此当用户登录后需要将二者进行合并。</p> \n<p>这里的合并很多部分的逻辑是可以与加入购物车复用的逻辑。比如：合并后的数据都需要检查是否合法，然后覆写回存储中。因此大家可以看到这里的关联性。设计的方法在某种程度上要通用。</p> \n<h3>购物车列表</h3> \n<p>购物车列表这是一个非常重要的接口，原则上购物车接口会提供两种类型，一种简版，一种完全版本；</p> \n<p>简版的列表接口主要是用在类似PC首页右上角之类获取简单信息；完全版本就是在购物车列表中会用到。</p> \n<p>在实际实现中，购物车绝不仅仅是一个读取接口那么简单。因为我们都知道不管是商品信息、活动信息都是在不断的发生变化。因此每次的读取接口必然需要检查当前购物车中数据的合法性，然后发现不一致后需要覆写原存储的数据。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022277106\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"购物车列表\" title=\"购物车列表\"></span></p> \n<p>也有一些做法会在每个接口都去检查数据的合法性，我建议为了性能考虑，部分接口可以适当放宽检查，在获取列表时再进行完整的检查。比如添加接口，我只会检测我添加的商品的合法性，绝不会对整个购物车进行检查。因为该操作之后一般都会调用列表操作，那么此时还会进行校验，二者重复操作，因此只取后者。</p> \n<h2>结算</h2> \n<p>结算包括两部分，结算页的详情信息与提交订单。结算页可以说是在购物车列表上的一个包装，因为结算页与列表页最大的不同是需要用户选择配送地址（虚拟商品另说），此时会产生更明确的价格信息，其他基本一致。因此在设计购物车列表接口的时候，一定要考虑充分的通用性。</p> \n<p>这里另外一个需要注意的是：立即购买，我们也会通过结算页接口来实现，但是内部其实还是会调用添加接口，将商品添加到购物车中；有三个需要注意的地方，首先是这个添加操作是服务内部完成的，对于服务调用方是不需要感知这个加入操作的存在；其次是这个购物车在Redis中的Key是独立于普通购物车的，否则二者的商品耦合在一起非常难于操作处理；最后立即购买的购物车要考虑账号多终端登录的时候，彼此数据不能互相影响，这里可以用每个端的uuid来作为购物车的标记避免这种情况。</p> \n<p>购物车的最后一步是生成订单，这一步最要紧的是需要给购物车加锁，避免提交过程中数据被篡改，多说一句，很多人写的Redis分布式锁代码都存在缺陷，大家一定要注意原子性的问题，这类文章网络上很多不再赘述。</p> \n<p>加锁成功之后，我们这里有多种做法，一种是按照DB涉及组织数据开始写表，这适用于业务量要求不大，比如订单每秒下单量不超过2000K的；那如果你的系统并发要求非常高怎么办？</p> \n<p>其实也很简单，高性能的三大法宝之一：异步；我们提交的时候直接将数据快照写入MQ中，然后通过异步的方式进行消费处理，可以通过通过控制消费者的数量来提升处理能力。这种方法虽然性能提升，但是复杂度也会上升，大家需要根据自己的实际情况来选择。</p> \n<p>关于业务架构的设计，到此告一段落，接下来我们来看系统架构。</p> \n<h1>系统架构</h1> \n<p>系统结构主要包含，如何将业务架构映射过来，以及输出对应输入参数、输出参数的说明。由于输入、输出针对各自业务来确定的，而且没有什么难度，我们这里就只说如何将业务架构映射到系统架构，以及系统架构中最核心的Redis数据结构选择以及存储的数据结构设计。</p> \n<h2>代码结构</h2> \n<p>下面的代码目录是按照 <code>Golang</code> 来进行设计的。我们来看看如何将上面的业务架构映射到代码层面来。</p> \n<pre><code class=\"golang\">├── addproducts.go\n├── cartlist.go\n├── mergecart.go\n├── entity\n│&nbsp;&nbsp; ├── cart\n│&nbsp;&nbsp; │&nbsp;&nbsp; ├── add.go\n│&nbsp;&nbsp; │&nbsp;&nbsp; ├── cart.go\n│&nbsp;&nbsp; │&nbsp;&nbsp; └── list.go\n│&nbsp;&nbsp; ├── order\n│&nbsp;&nbsp; │&nbsp;&nbsp; ├── checkout.go\n│&nbsp;&nbsp; │&nbsp;&nbsp; ├── order.go\n│&nbsp;&nbsp; │&nbsp;&nbsp; └── submit.go\n│&nbsp;&nbsp; └── precart\n├── event\n│&nbsp;&nbsp; └── sendorder.go\n├── facade\n│&nbsp;&nbsp; ├── activity.go\n│&nbsp;&nbsp; └── product.go\n└── repo</code></pre> \n<p>外层有 <code>entity</code>、<code>event</code>、<code>facade</code>、<code>repo</code>这四个目录，职责如下：</p> \n<p><strong>entity</strong>: 存放的是我们前面分析的购物领域的三个实体；所有主要的操作都在这三个实体上；</p> \n<p><strong>event</strong>: 这是用来处理产生的事件，比如刚刚说的如果我们提交订单采用异步的方式，那么该目录就该完成的是如何把数据发送到MQ中去；</p> \n<p><strong>facade</strong>: 这儿目录是干嘛的呢？这主要是因为我们的服务还需要依赖像商品、营销活动这些服务，那么我们不应该在实体中直接调用它，因为第三方可能存在变动，或者有增加、减少，我们在这里进行以下简单的封装(设计模式中的门面模式)；</p> \n<p><strong>repo</strong>: 这个目录从某种程度上可以理解为 <code>Model</code>层，在整个领域服务中，如果与持久化打交道，都通过它来完成。</p> \n<p>最后外层的几个文件，就是我们所提供的领域服务，供应用层来进行调用的。</p> \n<blockquote>\n 为了保证内容的紧凑，我这里放弃了对整个微服务的目录介绍，只单独介绍了领域服务，后续会单独成文介绍下微服务的整个系统架构。\n</blockquote> \n<p>通过上面的划分，我们完成了两件事情：</p> \n<ol> \n <li>业务架构分析的结构在系统代码中都有映射，他们彼此体现。这样最大的好处是，保证设计与代码的一致性，看了文档你就知道对应的代码在哪里；</li> \n <li>每个目录各自的关注点都进行了分离，更内聚，更容易开发与维护。</li> \n</ol> \n<h2>Redis存储</h2> \n<p>现在来看，我们选择Redis作为购物商品数据的存储，我们要解决两个问题，一是我们需要存哪些数据？二是我们用什么结构来存？</p> \n<p>网络上很多写购物车的都是只保存一个商品id，真实场景是很难满足需求的。你想想，一个商品id如何记住用户选择的赠品？用户上次选择的活动？以及购买的商品渠道？</p> \n<p>综合比较通用的场景，我给出一个参考结构：</p> \n<pre><code class=\"golang\">// 购物车数据\ntype ShoppingData struct {\n    Item       []*Item `json:\"item\"`\n    UpdateTime int64   `json:\"update_time\"`\n    Version    int32   `json:\"version\"`\n}\n\n// 单个商品item元素\ntype Item struct {\n    ItemId       string          `json:\"item_id\"`\n    ParentItemId string          `json:\"parent_item_id,omitempty\"` // 绑定的父item id\n    OrderId      string          `json:\"order_id,omitempty\"`       // 绑定的订单号\n    Sku          int64           `json:\"sku\"`\n    Spu          int64           `json:\"spu\"`\n    Channel      string          `json:\"channel\"`\n    Num          int32           `json:\"num\"`\n    Status       int32           `json:\"status\"`\n    TTL          int32           `json:\"ttl\"`                     // 有效时间\n    SalePrice    float64         `json:\"sale_price\"`              // 记录加车时候的销售价格\n    SpecialPrice float64         `json:\"special_price,omitempty\"` // 指定价格加购物车\n    PostFree     bool            `json:\"post_free,omitempty\"`     // 是否免邮\n    Activities   []*ItemActivity `json:\"activities,omitempty\"`    // 参加的活动记录\n    AddTime      int64           `json:\"add_time\"`\n    UpdateTime   int64           `json:\"update_time\"`\n}\n\n// 活动\ntype ItemActivity struct {\n    ActID    string `json:\"act_id\"`\n    ActType  string `json:\"act_type\"`\n    ActTitle string `json:\"act_title\"`\n}</code></pre> \n<p>重点说一下 <code>Item</code> 这个结构，<code>item_id</code> 这个字段是标记购物车中某个商品的唯一标记，因为我们之前说过，同一个sku由于渠道不同，那么在购物车中会是两个不同的item；接下来的 <code>parent_item_id</code> 字段是用来标记父子关系的，这里将可能存在的树结构转成了顺序结构，我们不管是父商品还是子商品，都采用顺序存储，然后通过这个字段来进行关联；有些同学可能会奇怪，为什么会存order id这个字段呢？大家关注下自己的日常业务，比如：再来一单、定金预售等，这种一定是与某个订单相关联的，不管是为了资格验证还是数据统计。剩下的字段都是一些非常常规的字段，就不在一一介绍了；</p> \n<blockquote>\n 字段的类型，大家根据自己的需要进行修改。\n</blockquote> \n<p>接下来该说怎么选择Redis的存储结构了，Redis常用的 <code>Hash Table、集合、有序集合、链表、字符串</code> 五种，我们一个个来分析。</p> \n<p>首先购车一定有一个key来标记这个购物车属于哪个用户的，为了简化，我们的key假设是：<code>uid:cart_type</code>。</p> \n<p>我们先来看如果用 <code>Hash Table</code>；我们添加时，需要用到如下命令：<code>HSET uid:cart_type sku ShoppingData</code>；看起来没问题，我们可以根据sku快速定位某个商品然后进行相关的修改等，但是注意，ShoppingData是一个json串，如果用户购物车中有非常多的商品，我们用 <code>HGETALL uid:cart_type</code> 获取到的时间复杂度是O(n)，然后代码中还需要一一反序列化，又是O(n)的复杂度。</p> \n<p>如果用<code>集合</code>，也会遇到类似的问题，每个购物车看做一个集合，集合中的每个元素是 ShoppingData ，取到代码中依然需要逐一反序列化(反序列化是成本)，关于有序集合与链表就不在分析，大家可以按照上面的思路去尝试下问题所在。</p> \n<p>看起来我们没得选，只有使用<code>String</code>，那我们来看一下<code>String</code>的契合度是什么样子。首先<code>SET uid:cart_type ShoppingDataArr</code>；我们把购物车所有的数据序列化成一个字符串存储，每次取出来的时间复杂度是O(1)，序列化、反序列化都只需要一次。看来是非常不错的选择。但是在使用中大家还是有几点需要注意。</p> \n<ol> \n <li>单个Value不能太大，要不然就会出现大key问题，所以一般购物车有上限限制，比如item不能超过多少个；</li> \n <li>对redis的操作性能提升上来了，但是代码的就是修改单个item时的不便，必须每次读取全部然后找到对应的item进行修改；这里我们可以把从redis中的数据读取出来后，在内存中构建一个HashTable，来减少每次遍历的复杂度；</li> \n</ol> \n<p>网上也看到很多Redis数据结构组合使用来保存购物车数据的，但是无疑增加了网络开销，相比起来还是String最经济划算。</p> \n<h1>总结</h1> \n<p>至此对于购物车的实现设计算是完结了，其中关于订单表的设计会单独放到订单模块去讲。</p> \n<p>对于整个购物车服务，虽然没有写的详细到某个具体的接口，但是分析到这一步，我相信大家心中都是有沟壑的，能够结合自己的业务去实现它。</p> \n<p>文中有些很有意思的地方，建议大家动手去做做看，有任何问题，我们随时交流。</p> \n<ul> \n <li>改编版的责任链模式</li> \n <li>Redis的分布式事务锁实现</li> \n</ul> \n<p>接下来终于要到订单部分的设计了，希望大家继续关注我们。</p> \n<p><strong>项目地址：<a href=\"https://github.com/skr-shop/manuals\" rel=\"nofollow noreferrer\">https://github.com/skr-shop/m...</a></strong></p>', 'https://segmentfault.com/img/remote/1460000022277102', '692c6787030d4b8882077b2ab9279c52', '4810ef0267f242fa99b85b2fd8a3cc02,ddfb55921ea24001b6178c86a1d11095,cb1ca7cb006244a3a4b5b52cb568301c', '0', '3', '1', '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_recommend` VALUES ('d0fc1d6cde614e8f87d013265ff35b61', '区块链上的虚拟开放世界游戏是怎样的？| TVP思享', '区块链是一种具有颠覆性意义的互联网基础设施，这种颠覆性体现在可以为各行各业构建低成本的资产交易功能，进而让资产可以更方便地流动。金融行业本身具有虚拟属性，区块链天然支持金融特性，所以金融行业本身就...', '<blockquote>\n 区块链是一种具有颠覆性意义的互联网基础设施，这种颠覆性体现在可以为各行各业构建低成本的资产交易功能，进而让资产可以更方便地流动。金融行业本身具有虚拟属性，区块链天然支持金融特性，所以金融行业本身就成为了区块链最先落地的行业。然而游戏行业也具备类似的虚拟性质，区块链的开发者们已经在游戏上做了诸多探索，其中类似《我的世界》的虚拟开放世界游戏最为热门，本文是对TVP陈浩老师的直播演讲整理，分享区块链是如何打造不一样的虚拟开放游戏世界的。「TVP思享」专栏，凝结大咖思考，汇聚专家分享，收获全新思想，欢迎长期关注。\n</blockquote> \n<h2><strong>一、区块链世界游戏的前身</strong></h2> \n<hr> \n<p>虚拟开放世界游戏的发展已经有不少年头了，和区块链结合之后，更是焕发了别样的生机。从我们玩过的游戏开始谈起，下面介绍三款游戏：豆瓣的阿尔法城、我的世界、头号玩家里的绿洲。</p> \n<p>豆瓣阿尔法城严格意义上来说不算是一款游戏，而是一个社交类的虚拟社区，虽然带了一些游戏的概念，但主导的还是社交。这是一个比较小众的社区，截止2015年3月份也只有8万用户，对于整个互联网的体量来说，显得相当小众。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132075\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>但就是这么一款游戏，它带来了一些新的概念，把街道做的具象化。玩家可以进入到社区里面去，入住的街道都是具象化的，玩家可以在里面开小店，开面包房，还有民政局、婚介所......它是一个完完全全虚拟化的镜像社区，模拟了现实世界。这也是一个开放的社区，用户可以自由进行创作。</p> \n<p>当前世界上用户和玩家人数最多的、市值最高的一款世界游戏的当属「我的世界」。它是一个高度自由开放的像素方块游戏，玩家可以在这个世界当中进行探索。不像传统游戏那样，有游戏任务目标、副本、主线，在这里没有直接的任务目标，玩家最大乐趣就是在里面制作一些建筑，以及完成一些简单的小任务。这款游戏是源码级开放的，用户可以改到源码层面，这样就会带来非常大规模的游戏体量上的创造，也就是用户的创造和探索。</p> \n<p>在这款游戏中有一个红石系统，玩家可以基于红石系统去做自己的作品。比如做一个单片机，做一个计算器，甚至去做一款游戏都是可以的，极大的释放了玩家们的想象力。在这款游戏当中，玩家可以做他想做的任何事情，限制只在于自身的想象力。这其实也是一个虚拟世界的游戏，玩家看到的作品都是可以分享给其他玩家的一种资产。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132076\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在2018年斯皮尔伯格导演了一部电影—头号玩家，电影当中有一款游戏叫做绿洲。绿洲可以说就是前文提到的两款游戏的一个升级版本，或者说是一种完全体。游戏是完全开放的，玩家在里面可以做很多的事情。对于这款游戏本身而言，也有一些比较有特色的地方，比如它有一个自由的经济体系，玩家在绿洲中所获得的游戏币，是可以拿出来在现实中做交易的。例如，头号玩家主角升级版的体感设备就是他通过打游戏获得的。</p> \n<p>可以说绿洲这款游戏，已经突破了虚实世界之间的界限，用户可以进入到完全虚拟的开放世界当中去，有一个自己的化身，用化身来进行创造，去探索更多的游戏内容。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132074\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>上面提到的这三款游戏基本上都强调了用户创造和探索这样的概念。</p> \n<h2><strong>二、区块链上的虚拟开放游戏</strong></h2> \n<hr> \n<p>下面开始正式介绍区块链上的一款世界游戏：Cryptovoxels。</p> \n<p>严格意义上来说，它不像传统类型的游戏。首先它没有一个严格意义上的游戏运营，它的像素风格看起来甚至比较原始，而且它的整体游戏性也不是特别高。我更愿意称之为一个平台，它是一个开放式的平台，玩家可以在上面去做很多的事情。这款游戏比较有意思地方叫做创意空间，里面有很多的玩家，发挥自己的艺术创造力，在游戏中构建和欣赏，特定社区特定圈子里面拥有共同语言的作品。</p> \n<p>在这款游戏当中，玩家也同样可以去做社交。相对来说，它目前的社交还比较原始，更多像是一种概念，而不是严格意义上的一种服务。玩家在里面可以做自己想做的任何事情，比如去号召大家开个舞会，号召大家去拍集体照等，游戏中的很多元素都是要玩家主动去驱动社区成员或者团体的成员一起去完成的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132079\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>除了以上这些特色以外，它还有其他一些特点，就要涉及到区块链上的一些特性了。</p> \n<p>（1）原生资产交易</p> \n<p>用户创造出来的东西，其实是一种资产。比如玩家在我的世界上做了一个单片机，这样的一个系统其实是玩家创造的游戏资产，可以拿去交易。在我的世界虽然比较困难，但是在区块链的世界里却是可以办到的。</p> \n<p>在比较早期的时候，很多人在谈一个概念叫资产上映，就是指把现实世界当中的一些资产映射到区块链上面去。但是随着区块链的发展，例如现在区块链上比较火的一些游戏，衍变出了区块链原生资产。用户在区块链上创造出来的原生资产，它也是有一定的价值，只要是被社区共识所认可的资产，都是可以拿去做交易的。</p> \n<p>（2）社区共同发展</p> \n<p>当玩家去创造一个作品，做一个很好玩的东西的时候，其实就是在跟社区共同发展。Cryptovoxel这款游戏其实就是基于社区创造的，它本身不具有特别多的游戏性，基本都是通过用户去驱动的，并渐渐形成了社区的共识。</p> \n<p>也可以认为，这款游戏本身是没有任何价值的，只有当你真正融入到游戏的社区圈层里来，你才会发现更多的内容，变得喜欢上这款游戏。这就是区块链所赋予游戏的特点：社区共同发展。</p> \n<p>（3）基于区块链</p> \n<p>在这款游戏当中，土地是需要玩家去购买的。想要拥有一片土地，得去拿数字货币去购买。而这款游戏目前是基于以太坊，所以玩家得拿自己手中的以太坊去购买土地。</p> \n<p>获得土地之后，接下去玩家就可以做游戏当中任何想做的事情。这里还有一个特性，购买的土地，会被区块链永久记录。也就是说这块土地是永久的属于玩家，而且不能被销毁。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132077\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>其实这款游戏的用户数、交易的规模在圈内都不算大，但是它的衍生意义是比较强的，给了很多区块链从业者一个非常好的启发。</p> \n<p>游戏中的土地可以用来拍卖和租用，而在别的游戏当中可能需要游戏策划设计才会产生，这款游戏本身就具有这样一套土地交易系统。玩家可以从土地的发行商去购买，买到之后可以再租给他人，一切交易活动都通过一个公开的交易市场。</p> \n<p>除了土地本身以外，玩家还可以在土地上创造作品，拍卖自己的作品。区块链还为玩家提供多元化的个性社交入口。社交的主场最早的时候是个人网站，然后到博客，再到朋友圈和微博，一直到现在的短视频和vlog。那么，下一步会有什么样的个性社交入口呢？很可能就像Cryptovoxels里面所展现的那样，每个人都有一个区块链上面的化身系统，化身系统不单单是游戏，它可以做一切你想做的事情。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132078\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2><strong>三、细说Token和NFT交易市场</strong></h2> \n<hr> \n<p>前文提到，土地是登记在区块链上面的，而区块链上就用Token来查看和验证玩家土地的所有权。土地的公开交易信息，展示在OpenSea网站上，它是一个第三方公开的交易市场，并不属于这个游戏，在OpenSea上可以来交易土地资源的Token。</p> \n<p>那什么是Token呢？在区块链上是一个比较专业性的名词，翻译成代币或者通证都是可以的，它其实是一个比较开放性的工具，代表了某某物体或某某事件。可以认为它是一种符号，或者说是一种价值标识都是可以的。作为一种价值标识，Token其实是有分类的：</p> \n<h3><strong>1. 同质型Token</strong></h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132081\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在公开的二级市场进行交易的时候，交易的标的物基本上用的都是同质型Token。怎么去理解？</p> \n<p>例如货币、证券、黄金这些都算是同质型Token。最简单来看，它们的使用是不做具体单个区分的。比如我手上的100元钞票，和你手上的100元钞票，在使用的时候，是不进行区分的，只要它代表的面值是100元，就可以了。因为它是同质性的，我们可以延伸定义它为标准资产，它还有个性质就是流动性高。所谓流动性高就容易被市场接纳，容易被买卖掉，通常是由大范围的社会共识决定的。最典型的就是大家手上的现金，现金总是很容易购买和交易的。如果你手上有很多的实物资产，比如说有100台挖掘机，是很难找到对方去买你的挖掘机的。所以同质型Token通常具有流动性高这样的特点，基本上它的价值也是比较稳定的。</p> \n<h3><strong>2. 非同质性Token（NFT）</strong></h3> \n<p>与同质型Token对应的是NFT：非同质性Token，英文全称为Non-Fungible Token。非同质性Token，跟我们前文提到的那几款游戏是有联系的，我们刚刚提到的能交易的土地，还有玩家创造出来的作品，其实都是非同质性Token。</p> \n<p>总的来说，它是一种非标准资产。比方说常见的收藏品、游戏项目、数字艺术品、活动门票或者域名，以及实物资产的所有权记录，这些都是都可以认为是非标准资产。</p> \n<p>它最大特点是唯一性，比如说我家有一幅画，它是全世界唯一的，如果你家里也有一幅的话，那么肯定有一个是假的，这就表明了这种价值标记的唯一性。延伸来看，它的流动性其实是比较低的。如果存在小范围的社区共识，在圈子里面流动是比较方便的，但想要出圈子往往比较困难，它会带来比较高的鉴定成本。</p> \n<p>这两年很火的A追鞋子，其实就是一种非同质性Token，鞋子拿到二级市场去交易的时候，除了做交易之外，它还附带了一个功能叫做鉴定，由交易市场主体机构来去背书为你的产品生成一个证书。</p> \n<p>非同质性Token，它的流动性比较低，与之对应的价值波动也比较大，由相应的销售门槛或者销售能力所决定的，也由供需决定。很多时候并不是要对每个资产都进行区分，确定它的唯一性。比如做大宗商品的时候，我们其实关注是某一类或者某一批货物。比如一集装箱的鞋子，品质基本上是比较接近的，我们去标记它们的时候，直接标记集装箱就可以了，而不需要标记到每一个鞋子上面。做这种业务上的简化是很有必要的，这就是衍生出来的 Non-Fungible with classes 概念。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132082\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>（1）NFT的六大特征</strong></p> \n<p>区块链上已经被实践或是被用到的NFT主要有两类：</p> \n<p>第一类就是：游戏当中的稀缺资源和角色，就像上文提到的土地，它就是一种稀缺资源。</p> \n<p>另一类就是被人创造出来的，在区块链世界当中独一无二的稀缺资源，比如玩家在游戏中创造出的数字艺术品，我们就可以用NFT去标记它。</p> \n<p>从Token的获取上来看，可能涉及到Token的发行机制。以前文提到的Cryptovoxels游戏来看，是玩家直接去找游戏的开发商买土地，买了土地Token就归属玩家。还有一种就是玩家创造出来的，比如在土地上盖个性化的房子，这就是玩家创造的一个资产，也就是说资产因为玩家的劳作而被增值了，更富有价值。这时还可以考虑把这片土地和房子一起卖掉，进行一个循环交易。</p> \n<p>另外NFT交易还存在第三方标准化的交易场所，而并不是我们想象的游戏的开发商。它跟游戏运营商没有关系，甚至可以说没有半点关系，就是一个单纯的NFT交易市场。至于买方是谁，用户并不关心，只要价位合理，符合心理预期就可以交易。这样的第三方标准化交易场所，目前在区块链行业里面也有很多了。</p> \n<p>NFT还有一个特性，就是它的可追溯性是很强的。无论它在第三方交易市场被交易了多少次，都能去追溯到Token的源头，最多就是程序加载或者优化的工作量稍微多一点而已。可追溯性同样带给了NFT一个特性，就是它的鉴定成本降低了。只要找到初始的鉴定人或者中间环节的鉴定人，目前Token所代表的物件，或者是说数字艺术品，就一定是真的，这是大家都可以去监督的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132080\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>NFT最主要的特性是标准化，也即是把资产标准化。</p> \n<p>不管是游戏当中创造的资产，还是把链下的资产标准化登记到链上去，标准化的意义就在于可以相互打通，更方便的完成交易。可交易性体现在NFT现在可以很方便的可以出现在第三方交易市场，自由交易。</p> \n<p>也因为有了第三方交易市场，它的流动性也变高了。因为它的可追溯性，又带来了不变性这样的特点。Token所代表的线上的虚拟资产，是永远不变的。除非是对资产进一步修改之后，它重新派出了一个新的资产，这样跟原来资产就不是同一个标记了。这证明了用户所创造出来的资产，不管是游戏角色还是作品等，它都是具有稀缺性的。对于NFT的标准化和可继承性，在下文还会有更加详细的介绍。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132085\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>（2）NFT交易市场</strong></p> \n<p>前面提到的第三方交易市场叫OpenSea，它是全球数字收藏品和NFT的交易市场，其中包括ERC721和ERC1155资产。ERC721和ERC1155，其实就是标准化协议的一种，以太坊区块链上面的NFT的资产标准化协议，通常就是指这两个协议。ERC1155是向下兼容ERC72I的，所以目前很多行业的以太坊的开发社区通常用1155协议会比较多！</p> \n<p>OpenSea是一个很开放的交易市场，只要你有以太坊的地址和以太坊钱包，就可以在上面进行交易。</p> \n<p>第二个是SuperRare，它是基于以太坊IPFS的去中心化数字艺术品交易市场。在区块链上，如果用虚拟和数字的方式创造了画作等艺术品，就可以在区块链上把它卖掉。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132083\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>第三个是Rare Bits，也是一个NFT交易市场，但是它并不局限于艺术品交易，人们可以在上面买卖很多的NFT。</p> \n<p>还有诸如Known Origin等，其实它们的服务内容基本相同，都是服务于以太坊区块链的。区分链上的NFT交易市场，其实是有很大的竞争空间的。比如说OpenSea 提供服务跟SuperRare提供的服务，在行业类别上可能有些细微差异，但是它们的服务内容是比较类似的。SuperRare和Known Origin，它们的服务内容也是处于竞争的关系。所以如果现在要去做这样一个交易市场的话，目前是有很多对手的。类似互联网发展的历史，如果想要超前，就必须赶在行业的前头，创建这样一个场景，把用户给导入进来。</p> \n<p>这一切的工作，区块链可以帮你完成一半，这一半对应的就是导流工作。并不需要花费大量人力去做获客行为，现在只需要把交易市场建立起来，然后投放出去，基本上就会有用户过来在你的垂直交易市场进行买卖行为了。NFT交易市场的建立和繁荣，也极大的推动了区块链的行业发展！</p> \n<h2><strong>四、区块链为游戏行业注入新的想象力</strong></h2> \n<hr> \n<p>接下来重点延伸一下，区块链所带来的这些标准化、可继承等概念到底有什么不一样？它未来可以发展成怎样的路径？</p> \n<p>对于游戏资产标准化，这个概念可以这样理解。如果用传统的游戏发行方式，游戏里面的土地都是属于游戏运营商的，里面可能也有超级管理的角色。其实也佐证了现在很多的游戏，它们都是各自为政的，开发出来的游戏有一套自己的标准。整个游戏生态其实是封闭的，跟别的游戏没有关系。传统的游戏会受到游戏策划的制约，而区块链上的游戏，则不会受到任何人的制约，基本上社区想做什么都可以。所以游戏资产的标准化为我们衍生出一些新的想法，如果游戏资产被标准化，那么将会赋予玩家和用户更多的创造性和流动性，也会使游戏变得更加开放，其次还可以把游戏里面的资产放到第三方交易场所去交易。</p> \n<p>游戏资产标准化应该是区块链带给游戏行业最大的点，游戏里面的资产，绝大部分应该都是NFT。在不同区块链上有不同的协议，比如在以太网上，就是前文提到的ERC721和ERC1155协议，在元界上是MIT协议，都是开放的标准。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132086\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>任何一个游戏都有可以预期的生命周期，游戏从上线到最后整个社区玩不动了，玩家逐渐减少，到最后关闭。在整个游戏的生命周期，玩家对这款游戏的设计和发展，几乎全程没有参与感，基本上都由游戏策划说了算。</p> \n<p>如果游戏最后被关闭了，玩家曾经在游戏里叱咤风云的记录也就随之消失。还有典型的二次元壁现象，也即游戏里创造出任何东西都跟现实生活没有关系。</p> \n<p>而区块链上的游戏则有很大的不同。区块链上的游戏是取决于社区的，只要社区有人想玩，游戏就会一直延续下去，只要社区想发展它，游戏就会一直发展下去，没有尽头。而只要社区一直保持存在，游戏的生命就会一直长久。</p> \n<p>典型的例子就是「我的世界」，「我的世界」的游戏生命周期很长，就得益于它的开放性。而且玩家的参与感也增强了，由玩家决定游戏的玩法。</p> \n<p>另外游戏数据可以永久保存，区块链可以永久记录玩家的游戏资产。关于突破虚实界限，上文也提到过，就是用户创造出来的游戏资产，可以拿数字货币直接交易和购买，它们其实就已经开始突破虚拟世界和现实世界之间的界限。</p> \n<p>比如头号玩家里面，主角的游戏体感设备就是通过玩游戏得来的，在区块链上已经能够做到这样的事情了，这也是未来的发展趋势。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132084\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在区块链上做游戏，并不意味着一定不能使用传统的方法。如果把传统做游戏的方法完全抛抛不看，其实是不对的，需要我们结合去看待。</p> \n<p>下图所示左边这张图是传统游戏网络拓扑结构，首先有个用户终端-APP，连接到服务器,底层是数据库。右边是加入区块链技术以后，除了连接自己的数据库之外，还要再连接区块链。具体用哪条区块链，由你自己去选，再根据NFT资产标准化的协议将数据放上去。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132087\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这中间涉及到元数据的概念，并不需要把所有的游戏资产全部放上去。比如不需要把游戏的全部美术资源放上去，容易撑爆区块链，所以是不可取的。</p> \n<p>只要把游戏中一些关键参数，比如游戏的所有权、游戏道具的基本特性等传上去，这就是元数据，尽可能小而全面的关键数据。剩下的美术资源等数据依然可以存在数据库中。</p> \n<p>所以区块链如果要应用到游戏行业，并不一定要把原来所有东西全部抛除掉，只需要把区块链加进来就可以。前文只谈到了一家运营商，游戏的可玩性其实是不够的。为此我们引入多家游戏运营商，如下图所示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132088\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>左边是A游戏运营商，右边是B游戏运营商，传统游戏的现状可能是这样：假设A和B游戏运营商都运营了两款游戏，拥有两台服务器。可以看出，A游戏运营商和B游戏运营商基本没有关系，即使有关系可能也只是支付关系。例如用户可能在游戏中产生一笔支付，都接入到第三方中介平台，如支付机构、登记机构等。这是一个非常弱的关系，跟游戏本身几乎没有任何联系。如果把中介拿掉，对游戏本身其实是没有任何影响的。而如果这两个游戏运营商都加入区块链的话，变成如下这样的拓扑结构，游戏立马就能被打通了。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022132089\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>将A、B游戏运营商的游戏资产，依照标准化协议了，登记到区块链上，形成标准化资产。如果两家公司的游戏资产都是标准化的，它们之间的NFT是否就能够进行交易呢？所以这可能也是未来的一个发展方向。</p> \n<p>最后再来谈谈区块链上游戏的可继承性，在正式描述之前可以先来介绍一下区块链上游戏的发展历史。之前以太坊上存在一款CryptoKitties（以太猫）的游戏，最开始的时候非常火，折合算下来需要花费数万元才能购买到一只猫。后来用户逐渐开始萎缩，到游戏几乎消失在大众视野。但是这款游戏的日活虽然降下去了，它里面所有的用户数据，用户的游戏资产仍然存在区块链上面。</p> \n<p>后面又有一家游戏公司，拿之前CryptoKitties在区块链上的公开数据，又做了一款游戏叫CryptoHats(以太帽子)，可以继续去玩这只猫。玩的方法不一样在于玩家可以给猫做一些个性化的帽子。这个游戏非常简单，它不一样的地方在于完美继承了「以太猫」的所有用户数据，它并不需要去拉新，只需要简单激活一下就可以。</p> \n<p>所以游戏的生命周期不再局限于某一家游戏运营商，当某款游戏消失以后，仍然可以在区块链的历史上把它找出来，再增加新的idea让它继续发展下去。所以在区块链中游戏的生命周期被极大延长了，可以被完美的继承下去，一代又一代。游戏的所有用户都被完美的继承下去了。</p> \n<p>区块链为游戏行业带来了新的想象力，游戏行业里面的策划可能就不再局限于自己的一块天地了，而是面对着全世界的策划一起接受挑战，比当下单纯构造自己的游戏世界要有趣的多。</p> \n<h2><strong>五、Q&amp;A</strong></h2> \n<hr> \n<p><strong>Q：</strong>区块链数据没有办法销毁，在这种情况下，数据的所有权归谁呢？如果有些不好的数据删除，应该怎么样处理？</p> \n<p><strong>A：</strong>首先，区块链上的数据确实没有办法销毁的，这是事实。重要的是掌握好展示的途径，展示就是人类可读这件事情，总的还是要用户端或者中发的服务器来进行二次传播，只要在用户终端进行控制，其也就可以了。数据的所有权归最后一棒，就是资产最后转到谁，所有权就归谁。如果一直不动的话，归属权也是不会变化的。</p> \n<p><strong>Q：</strong>现在玩这种游戏的人多吗？</p> \n<p><strong>A：</strong>前文介绍的几款游戏，总的来说游戏画面是很一般的，暂时还不能对它们的游戏性和美术资源有比较高的标准。更多的是它对游戏本身的创新，它的开放性，它的资产交易NFT这些理念上的创新。</p> \n<h2><strong>讲师简介</strong></h2> \n<hr> \n<p>陈浩，<strong>腾讯云最具价值专家TVP</strong>，元界区块链 CTO。区块链创业者，资深数字货币交易系统架构师，《区块链第一课》一书作者，区块链技术和Token经济布道者，C++码农，拥有公链架构和高并发系统架构双重经验，拥有丰富的区块链技术分析和讲演经验。主导团队设计实现了开源公链——Metaverse元界。</p>', 'https://segmentfault.com/img/remote/1460000022132075', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '7937aecb2ef543908ed511c9d5abceb3,9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-16 16:57:47', '2020-04-16 16:57:47');
INSERT INTO `tb_recommend` VALUES ('d1407895fb7f46a68e3413a2f8cee555', '译文丨为什么做程序员会让我成为一个更好的医生？', 'Stanford Medicine Unplugged 是一个为学生提供的论坛，记录他们在医学院的经历。学生们撰写的文章在学年期间每周在Scope上发表一次；整个系列博客可以在Stanford Medicine Unplugged分类中找到。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFQQO\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>Stanford Medicine Unplugged 是一个为学生提供的论坛，记录他们在医学院的经历。学生们撰写的文章在学年期间每周在Scope上发表一次；整个系列博客可以在Stanford Medicine Unplugged分类中找到。</p> \n<p>原文链接：<a href=\"https://scopeblog.stanford.edu/2020/03/18/why-being-a-programmer-will-make-me-a-better-doctor/\" rel=\"nofollow noreferrer\">https://scopeblog.stanford.ed...</a></p> \n<hr> \n<blockquote>\n Tim Keyes Published on March 18, 2020\n</blockquote> \n<p>作为一名医学博士生，我的研究方向更多的是机器学习和算法开发，而不是生物学，我花了大量的时间来思考我所需要的研究技能和作为一名未来的医生提供良好的临床护理所需要的技能之间的脱节。</p> \n<p>我的研究重点是建立小儿癌症治疗反应和复发的预测模型，所以我的大部分时间都是在写 R 和 Python 代码，用来整理、可视化和建模从患者那里收集的数据。然而，尽管我把大部分时间都花在了编程上，但我知道，在临床环境中，编码并不是护理病人所需的前 20 名（.........或者说前 100 名）的技能。</p> \n<p>不过，几年来在这两种环境下的经验告诉我，我从做程序员的过程中学到的一些教训，可以很好地应用到我作为一名医学生的生活中--这也是我未来平衡这两个世界的好兆头。</p> \n<p>以下是我的一些感悟。</p> \n<h2>将问题分解成子问题</h2> \n<p>对于任何数据科学或编程项目来说，将你的总体目标分解成一系列更小、更易管理的目标，每次都能处理好的目标是至关重要的。例如，如果你要实现一个有三个不同步骤的算法，一个最佳的策略通常是先写出分别实现每个步骤的代码，然后再写出一个将它们结合在一起的函数。通过这样做，你可以让你的代码保持有条理、高效和易懂。</p> \n<p>我发现自己在医学上也应用了同样的原则。例如，在记录病史时，将对话分成几个独立的步骤，即 「现在的病史」、「过去的病史」、「社会史」等，每一个步骤都对应着病人的背景和需求的一小部分。这样一来，我就能可靠地获得我所需要的所有信息，不会遗漏任何重要的信息。</p> \n<h2>备忘录式记忆法</h2> \n<p>在计算机科学中，「备忘录化」是一种编码技术，可以通过重用之前已经解决过的问题的答案来加快算法的速度。换句话说，「备忘录化」的算法只需要花时间从头开始解决一个问题一次 —— 以后每次遇到同样的问题，它就会简单地查找旧的解决方案（就像备忘一样），而不是第二次从头开始重新解决问题。这意味着，算法第一次解决问题的速度会比较慢，但在以后解决同样的问题时，效率会提高很多。</p> \n<p>从很多方面来说，我觉得做医学生就像上了一堂记忆力的大师课。很多东西刚开始学的时候都会让人应接不暇，必须要掌握好小的步骤，才能向大的方向发展。比如说，在医学院的第一个季度，我在听诊器上挣扎着要通过听诊器听出任何心脏的声音，我和同学们练习了好几遍才终于成功。他们向我展示了他们的听诊器放置方法，如果对我也有效，我就把它作为我的过程的一部分。</p> \n<p>一年后，全面的心脏检查 -- 包括听杂音、摩擦和心跳加速--成为我的反射性工作，以至于我几乎不需要考虑。尽管一开始很慢，但我最终还是掌握了每一个步骤，并结合过去对我（或我的同学们）有效的方法，形成了一套完全「备忘录式记忆」的方法。</p> \n<h2>经常检查边缘案例</h2> \n<p>在编程中，「边缘案例」指的是你通常不会想到的情况。例如，在一个计算机程序中，比较两个数字并告诉你哪一个大，「边缘情况」可能是指当两个数字完全相同时发生的情况（因为从技术上讲，两个数字都不比另一个大）。一般来说，思考和测试边缘案例对于确保你的代码不会在看到一些意料之外的东西时崩溃是很重要的 -- 这可能会导致灾难性的结果！</p> \n<p>在医学中，对边缘案例的核算需要对边缘案例进行核算，这就要求我们在编写代码时，要考虑到边缘案例的重要性。</p> \n<p>在医学上对边缘案例进行核算，需要和编程中一样的创造力和前瞻性思维。通常情况下，医生们必须进行「如果」的思考，以考虑到多种诊断的可能性，即使看起来只有一两个可能性。例如，我和我的顾问有一个病例，一个病人在开始化疗前一天就出现了流鼻涕。基于病人过去的季节性过敏史和那天的高花粉量，大多数迹象似乎表明没有什么可担心的。但是，为了排除病人感染了急性病毒性感染的可能性不大，当他的免疫系统被化疗压制后可能会变得严重的「边缘情况」，我的顾问在开始治疗前一定要做一些常见的虫子的测试。</p> \n<p>尽管计算机科学和医学看似不同，但我已经开始欣赏他们的许多相似的思维方式。其中包括对创造力、深思熟虑和高效解决问题的共同承诺。基于这些原因以及更多的原因，我希望 —— 尽管我不太可能在病房里直接使用我的编码技能 —— 但作为一名程序员最终会让我成为一名更好的医生。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFxVM\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbFQQO', '1894b118d35d44cb8fe8009529c4154b', '81a4561c1c294e0cae32c9fe6b5dc397,78b2eb8f68e34e6e8e8863c0ed281b45,db6b58ae709645f2b64166fd73f2f705', '0', '3', '1', '2020-04-16 16:59:44', '2020-04-16 16:59:44');
INSERT INTO `tb_recommend` VALUES ('d22ac1b09d9d45a0b332d6d7b4eb3337', 'GitHub 宣布向所有团队免费开放核心功能，高级企业功能月费大幅下调', '今天凌晨，GitHub 官方发布公告表示向所有团队免费开放核心功能。无论是个人免费账户还是商业项目团队，都可访问 GitHub 的无限私有存储库。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF3FJ\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>技术编辑：王治治丨发自 SiFou NewOffice <br>SegmentFault 思否报道丨公众号：SegmentFault</p> \n<hr> \n<p>今天凌晨，GitHub 官方发布公告表示向所有团队免费开放核心功能。无论是个人免费账户还是商业项目团队，都可访问 GitHub 的无限私有存储库。</p> \n<p>另外还提供每月 2000 分钟的 GitHub Actions 访问，后者是该公司的自动化和 CI / CD 平台。</p> \n<p>不过如想要使用高级企业功能的项目团队（例如 SAML 支持），仍需付费升级体验。不过当前月费已从 9 美元调整到 4 美元，企业套餐则是 21 美元起步。</p> \n<p>Nat Friedman 表示：“我们正在将 GitHub 从按隐私付费的模式，转向以功能为主的免费增值体验，以希望吸引全球所有开发者和团队”。</p> \n<p>目前 GitHub 已汇聚超过 4000 万开发人员，预计可在 2025 年达到 1 个亿。</p> \n<hr> \n<p>对于此事，SegmentFault 思否社区用户 <a href=\"https://segmentfault.com/u/jysperm\">@王子亭</a>发表了如下观点：</p> \n<blockquote>\n 现在 GitHub 不再有盈利压力，于是扩展了 CI、Package Registry 等业务，收购了 npm，对核心服务进行降价或直接免费。这些举措想必会对其他独立的代码托管平台的商业模式造成很大的影响，破坏整个开发者服务市场的平衡，新的垄断很可能正在形成。\n <p>以后对于开发者服务创业来说，最大的问题可能就是「你们的产品要是被 GitHub 抄了并且免费了，你怎么办？」。要是 GitHub 回头做个 serverless 平台的话 ... 想想就可怕。</p> \n</blockquote> \n<p>原文链接：<a href=\"https://github.blog/2020-04-14-github-is-now-free-for-teams/\" rel=\"nofollow noreferrer\">https://github.blog/2020-04-1...</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbFyLB\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbF3FJ', '1c5851dc916d4e70a60f0c957f548876', '634b81d655c74cb0adc4d0aa362b8819,6b3ff922b0dd4d378ac2f31d32e5f60d', '0', '3', '1', '2020-04-16 16:59:43', '2020-04-16 16:59:43');
INSERT INTO `tb_recommend` VALUES ('d5fb8aba8c134df5a4b9ba0b15d4956b', '基于 HTML5 WebGL 的楼宇智能化集成系统（三）', '      2018年7月，信息化部印发了《工业互联网平台建设及推广指南》和《工业互联网平台评价方法》，掀起了 工业互联网 的浪潮，并成为热词写入了报告中。同为信息发展下的产物 建筑智能化集成系统也是兼具着信息...', '<h4><strong>前言</strong></h4> \n<p>&nbsp; &nbsp; &nbsp;&nbsp;2018年7月，信息化部印发了《工业互联网平台建设及推广指南》和《工业互联网平台评价方法》，掀起了&nbsp;<strong>工业互联网&nbsp;</strong>的浪潮，并成为热词写入了报告中。同为信息发展下的产物&nbsp;<strong>建筑智能化集成系统</strong>也是兼具着信息与管理的重要体现，数据化信息通过可视化的管理系统展示出一套互联网智能优化的解决方案，而本系列文章便结合了<strong>HT</strong>&nbsp; 的<strong>2D/3D</strong>&nbsp;可视化工具的运用，结合面板的数据展示和大楼建模场景的可视化管理，前面的内容已经讲解了 3D 模型和 2D 面板的融合体现，本次的内容将带您探讨&nbsp;<strong>智慧楼宇管理系统、电梯监控系统</strong> 以及 <strong>停车场管理系统</strong>的实现方式和整体系统的联合优化体现。</p> \n<h4><strong>界面简介及效果预览</strong></h4> \n<p><strong>智慧楼宇管理系统优化效果</strong> </p> \n<p>&nbsp; &nbsp; &nbsp;&nbsp;主要包括冷站、热站和中央末端智慧群控的联合作用，以及楼层智慧照明，通过清晰的动画体现出整栋大楼智慧节能运作的流程，可以通过面板详情的演示细致地介绍每个场景的作用以及串联的用处。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022387107\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>电梯以及楼层监控效果</strong> </p> \n<p>&nbsp; &nbsp; &nbsp; 可视化地实时监控电梯在楼层间的工作运行状态，并且能够准确地浏览每个电梯内的实时监控画面。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022387108\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>停车场管理系统监控效果</strong> </p> \n<p>&nbsp; &nbsp; &nbsp; 停车场作为现在楼宇监控不可缺失的一环，这里主要可以体现出实时的车位监控，通过简单的动画演示来表现出整个停车场车辆的运行状态，方便管理。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022387109\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h4><strong>代码实现</strong></h4> \n<p><strong>一、</strong> <strong>智慧楼宇管理系统优化效果的实现</strong></p> \n<p>&nbsp; &nbsp; &nbsp; 在点击智慧楼宇管理系统的按钮后，场景视角会根据 moveCamera 转移到大楼正视的视角后，大楼整体呈现渐变虚化后透明展示大楼内部信息，这个动画是封装了一个 tweenColor 颜色变化的过渡效果，从一种颜色 rgba 状态上改变色值和透明度来体现视觉上的变化。在效果展示上有一种可视化浸入式查看大楼内部信息的体验，具体的 3D 模型属性的变化可参考<a href=\"https://www.hightopo.com/guide2/ht/guide/core/3d/ht-3d-guide.html\" rel=\"nofollow noreferrer\">&lt;HT 的 3D 手册&gt;</a>。</p> \n<pre><code>// 通过 moveCamera 改变 eye 和 center 来移动场景视角为大楼的正视面\nmoveCamera(g3d, [134, 399, 1617], [7, 40, 144], {\n    duration: 2000,\n    easing: t =&gt; t * t,\n    finishFunc: () =&gt; {\n        // 开启场景大楼模型的可透明为 true\n        this.building.eachChild(c =&gt; {\n            c.s({\n                \'shape3d.transparent\': true,\n            });\n        });\n        // 大楼模型线框的颜色变化\n        tweenColor(this.building, \'wf.color\', \'rgba(72,149,232,1)\', \'rgba(56,156,255,0.03)\', {\n            duration: 2000,\n            easing: t =&gt; t\n        });\n        // 大楼模型整体染色的颜色变化\n        tweenColor(this.building, \'shape3d.blend\', \'rgba(120,180,255,1)\', \'rgba(120,180,255,0)\', {\n            duration: 2000,\n            easing: t =&gt; t,\n            finishFunc: () =&gt; {\n                // 楼层设置为可见\n                this.floor.eachChild(c =&gt; {\n                    setNodeVisible(c, true);\n                });\n                this.floorLighting = 1;\n                // 显示大楼建筑信息的动画\n                this.showBuilding();\n            }\n        });\n    }\n});</code></pre> \n<p>&nbsp; &nbsp; &nbsp; 颜色变化函数的实现是传入参数来改变节点的颜色属性变化值：</p> \n<ul> \n <li> <strong>node：</strong>改变颜色的图元节点；</li> \n <li> <strong>startColor：</strong>起始颜色的 rgba 值；</li> \n <li> <strong>endColor：</strong>变化后颜色的 rgba 值；</li> \n <li> <strong>animParams：</strong>过渡动画参数；</li> \n</ul> \n<pre><code>tweenColor(node, property, startColor, endColor, animParams) {\n    animParams = animParams || {};\n    if (!animParams.frames &amp;&amp; !animParams.duration)\n        animParams.duration = 5000;\n    if (!animParams.easing)\n        animParams.easing = t =&gt; t;\n\n    startColor = ht.Default.toColorData(startColor);\n    endColor = ht.Default.toColorData(endColor);\n\n    const dx = endColor[0] - startColor[0];\n    const dy = endColor[1] - startColor[1];\n    const dz = endColor[2] - startColor[2];\n    const da = endColor[3] - startColor[3];\n    const postAction = animParams.postAction;\n    animParams.action = (v, t) =&gt; {\n        const x = startColor[0] + v * dx;\n        const y = startColor[1] + v * dy;\n        const z = startColor[2] + v * dz;\n        const a = (startColor[3] + v * da) / 255;\n\n        node.s(property, (\'rgba(\' + ([x, y, z, a]).join(\', \')) + \')\');\n\n        if (postAction) postAction((\'rgba(\' + ([x, y, z, a]).join(\', \')) + \')\');\n    }\n    return ht.Default.startAnim(animParams);\n}</code></pre> \n<p>&nbsp; &nbsp; &nbsp; 大楼透明化后展示内部信息，此时我们可以看到楼层的照明系统从底楼逐一向上亮起也是通过这种方法实现的。而后大楼两侧的系统介绍面板是通过改变面板的缩放属性来实现延展的效果：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022387110\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<pre><code>// 面板显示\nshowPanel(data) {\n    ht.Default.startAnim({\n        duration: 1000,\n        easing: t =&gt; t,\n        action: (v,t) =&gt; {\n            data.setScaleX(data.getScaleX() + (1 - data.getScaleX()) * v);\n        }\n    });\n}\n\n// 面板隐藏\nhidePanel(data) {\n    ht.Default.startAnim({\n        duration: 1000,\n        easing: t =&gt; t,\n        action: (v,t) =&gt; {\n            data.setScaleX(data.getScaleX() + (0 - data.getScaleX()) * v);\n        }\n    });\n}</code></pre> \n<p><strong>二、</strong> <strong>电梯以及楼层监控效果的实现</strong></p> \n<p>&nbsp; &nbsp; &nbsp; 电梯是大楼日常管理必不可少的一环，而通过可视化场景便可实时对接电梯运行的情况。电梯动画效果的实现原理是判断当前电梯所处楼层的位置和下一层随机楼层的位置，来实现楼梯运行动画，本栋大楼划分设定为每层楼层高50，所以只需要得到电梯所处的高度就很容易可以判断出所处的楼层，而电梯面板也是通过这个判断来实时展示楼层的信息。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022387111\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>&nbsp; &nbsp; &nbsp; 具体实现的伪代码如下：</p> \n<pre><code>elevatorAnimation(data) {\n    const g3d = this.g3d;\n    const tag = data.getTag();\n    const e = data.getElevation();\n    const label = data.getChildAt(0);\n    // 判断现在所处楼层\n    let now = Math.ceil(e / 50);\n    // 下一层楼层取1~7随机数\n    let next = randomNumber(1, 7);\n    // 根据现在的楼层和下一个楼层，判断电梯运行的范围\n    let range = numBetween(now, next);\n    this.animationElevatorMap[tag] = ht.Default.startAnim({\n        duration: range * 800,\n        easing: t =&gt; t,\n        action: (v, t) =&gt; {\n            // 电梯运行位置设定\n            data.setElevation(now &lt; next ? (e + (range * 50) * v) : (e - (range * 50) * v));\n            // 设置电梯楼层面板显示并根据电梯位置设定\n            if (!label) return;\n            const floor = Math.ceil(data.getElevation() / 50);\n            if (floor === label.a(\'text\')) return;\n            label.a(\'text\', floor);\n            // 手动刷新电梯面板信息\n            g3d.invalidateShape3dCachedImage(label);\n        },\n        finishFunc: () =&gt; {\n            // 销毁电梯间隔动画\n            delete this.timeoutElevatorMap[tag];\n\n            // 执行电梯间隔动画后回调电梯运行动画\n            this.timeoutElevatorMap[tag] = setTimeout(() =&gt; {\n                this.elevatorAnimation1(data);\n            }, Math.floor(Math.random() * 5000) + 2000);\n        }\n    });\n}</code></pre> \n<p><strong>三、</strong> <strong>停车场管理系统监控效果的实现</strong></p> \n<p>&nbsp; &nbsp; &nbsp; 停车场的车位信息可以直观地在 3D 场景中去实现管理，而车辆进出的可视化控制也可以用简单的管道动画去实现，实时监控车辆进出去调用这个动画就能很直观地反应停车场的实时情况。而停车场的具体实现方案是通过车辆节点的前进管道和倒退管道去调用封装的管道动画来实现车辆行驶和倒车入库的动画效果：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022387112\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>&nbsp; &nbsp; &nbsp; 每个车辆的停车动画都包含着 forwardPath 和 backwardPath 两条路线，分别对应着车辆的前进路线和倒车路线，具体的行驶伪代码如下：</p> \n<pre><code>park(car, key = \'Path\', finishFunc) {\n    const dm = car.dm();\n    const tag = car.getTag();\n    const forwardPath = dm.getDataByTag(tag + \'_forward\' + key);\n    const backwardPath = dm.getDataByTag(tag + \'_backward\' + key);\n    this.animationMap[tag] = move(car, forwardPath, \'forward\', undefined, 24, {\n        pathEndFunc: () =&gt; {\n            this.animationMap[tag].stop();\n\n            this.animationMap[tag] = move(car, backwardPath, \'backward\', undefined, undefined, {\n                pathEndFunc: () =&gt; {\n                    this.animationMap[tag].stop();\n                    delete this.animationMap[tag];\n\n                    if (finishFunc) finishFunc();\n                    return true;\n                }\n            });\n            return true;\n        }\n    });\n}</code></pre> \n<p>&nbsp; &nbsp; &nbsp; move 是节点沿着路径平滑移动的封装函数，主要参数为：</p> \n<ul> \n <li> <strong>node：</strong>动画节点；</li> \n <li> <strong>path：</strong>运行路径；</li> \n <li> <strong>direction：</strong>节点朝向 forward | backward;</li> \n <li> <strong>animParams：</strong>动画参数；</li> \n</ul> \n<p>&nbsp; &nbsp; &nbsp; 通过绘制一条运行路线的管道，ht.Default.getLineCacheInfo() 得到这条管道的点位和分割信息 cache，然后管道信息通过 ht.Default.getLineLength() 得到管道的长度，并且通过 ht.Default.getLineOffset() 来获取连线或者管道指定比例的偏移信息，从而达到移动的效果，注意的是，这里还设定了 direction 来规定动画节点的朝向，主要是为了通过 node.lookAtX() 来获取节点下一个面对的朝向的位置信息，并设置节点此时的位置，从而达到节点沿着路径平滑移动的效果。</p> \n<pre><code>move(node, path, direction, step = 6, interval = 75, animParams) {\n    let cache = path.__cache__;\n    if (!cache)\n        cache = path.__cache__ = ht.Default.getLineCacheInfo(path.getPoints(), path.getSegments());\n\n    const len = ht.Default.getLineLength(cache);\n\n    animParams = animParams || {};\n\n    const face = direction === \'forward\' ? \'front\' : direction === \'backward\' ? \'back\' : direction;\n    let currentLen = 0;\n    const pathEndFunc = animParams.pathEndFunc;\n    const action = animParams.action;\n    animParams.action = (v, t) =&gt; {\n        if (currentLen &gt;= len) {\n            // 档 pathEndFunc 返回 true 是，认为是要结束动画, 不执行后面档 action\n            if (pathEndFunc &amp;&amp; pathEndFunc())\n                return;\n        }\n        currentLen = currentLen % len;\n\n        const offset = ht.Default.getLineOffset(cache, currentLen);\n        const point = offset.point;\n\n        node.lookAtX([point.x, node.getElevation(), point.z], face);\n        node.p3(point.x, node.getElevation(), point.z);\n\n        currentLen = currentLen + step;\n\n        if (action) action();\n    };\n    return loop(animParams.action, interval);\n}</code></pre> \n<p>&nbsp; &nbsp; &nbsp; 与此同时，我们还可以看到车辆行驶到车位或者离开时，车位上方的红绿灯则表示着这个车位的停放信息，是根据车辆的情况实时设定车位的状况，通过改变其信号灯 image 的 json 图标并手动刷新缓存来实现的。而缓存机制对于整体场景的流畅度是至关重要的，对于一些不必要实时刷新的面板信息，我们可以采取缓存的方式，并且在下一次更新的时候调用 Graph3dView.invalidateShape3dCachedImage(node)来手动刷新这个节点，从而大大提高了场景的性能，有关 3D 面板的属性可以参考<a href=\"https://www.hightopo.com/guide2/ht/guide/core/3d/ht-3d-guide.html?search=invalidateCachedTexture&amp;module=%E6%A0%B8%E5%BF%83%E5%8C%85#anchor_0\" rel=\"nofollow noreferrer\">&lt;HT 的 3D 手册 billboard 公告板&gt;</a>。</p> \n<pre><code>updateLight(view, light, color) {\n    light.s(\'shape3d.image\', \'symbols/parking/\' + color + \'Light.json\');\n    view.invalidateShape3dCachedImage(light);\n}</code></pre> \n<h4><strong>总结</strong></h4> \n<p>&nbsp; &nbsp; &nbsp;&nbsp;IBMS 智能化集成系统管理结合数据信息、大楼模型以及每个系统的场景模型，完整地体现出一套系统之间的功能串联。在一栋大楼的功能上，每个子系统负责着各自信息数据的管理和操作，但是通过智能化集成管理系统的管理，便可将每部分子系统的数据信息汇总到一起去可视化 3D/2D 工具上完整地体现。在未来科技的进步下，也许不再需要亲临现场管理着整栋的日常运行，一套可视化的智能化集成管理系统就可以轻松解决日常维护的繁琐，充分的数据也可以实时地反映设备与大楼的关联信息。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022281564\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>&nbsp; &nbsp; &nbsp;&nbsp;2019 我们也更新了数百个工业互联网 2D/3D 可视化案例集，在这里你能发现许多新奇的实例，也能发掘出不一样的工业互联网：<a href=\"https://mp.weixin.qq.com/s/ZbhB6LO2kBRPrRIfHlKGQA\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s/ZbhB6LO2kBRPrRIfHlKGQA</a></p> \n<p>&nbsp; &nbsp; &nbsp; 同时，你也可以查看更多案例及效果：<a href=\"https://www.hightopo.com/demos/index.html\" rel=\"nofollow noreferrer\"><strong>https://www.hightopo.com/demos/index.html</strong></a></p>', 'https://segmentfault.com/img/remote/1460000022387107', '3f69fcc9b13843d1910b3dac597f5215', '63c4e1e7ec204b43a62065a3ced4c2ce,d79254c4ca5e45dca9d484307c935281,401f1c4dcfbc499e8f7129c091c299f8', '0', '3', '1', '2020-04-16 16:48:03', '2020-04-16 16:48:03');
INSERT INTO `tb_recommend` VALUES ('d662aae15a404edfa4d8561b75836067', '黑客入侵攻击下的银行 App，数据安全何去何从？', '2019 年 10 月，00 后田某因非法获取计算机信息系统数据罪判处有期徒刑三年，并处罚金人民币一万元。当事人田某只有初中文化，但却拥有极强的计算机天赋，在 2019 年 1 月 5 日到 1 月 15 日期间，通过软件抓包、...', '<p>2019 年 10 月，00 后田某因非法获取计算机信息系统数据罪判处有期徒刑三年，并处罚金人民币一万元。当事人田某只有初中文化，但却拥有极强的计算机天赋，在 2019 年 1 月 5 日到 1 月 15 日期间，通过软件抓包、PS 身份证、重放攻击等手段，在某银行手机银行 App 内使用虚假身份信息注册银行Ⅱ、Ⅲ类账户非法销售获利。</p> \n<h1>案例分析</h1> \n<p>很多人会好奇银行 App 是如何被一步步通过抓包、入侵、重放攻击，从而让黑客有利可图。让我们具体分析下作案过程：</p> \n<ul> \n <li>首先，田某通过本人身份证信息，在注册账号正常流程中，通过「软件抓包」技术将银行系统下发的人脸识别身份认证数据包进行拦截并保存。</li> \n <li>其次，在输入开卡密码环节，田某将 App 返回到第一步（上传个人身份证照片），并输入伪造的身份证信息，并在此进入人脸识别身份认证环节。</li> \n <li>最后，田某使用先前拦截的身份认证数据包（含本人信息）进行上传验证，使得银行系统误以为此环节需比对本人身份信息，遂而成功验证本人人脸，使得其能够成功利用虚假身份证信息注册到银行账户。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021973354\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h1>客户端 App 数据安全刻不容缓</h1> \n<p>我们应当如何重新审视客户端的数据安全问题？通过解析支付宝目前在“端上安全”的设计机制，也许能够带给我们一些新的启发。</p> \n<p><strong>App 开发期的安全机制设计</strong></p> \n<p>支付宝通过打造多层次的端上安全机制从而防止 App 被黑客或木马攻击，具体主要分为“本地域”、“线上运行”以及“App 端”三个层面。在本地域方面，通过代码混淆、加密等手段实现二进制防护；线上运行时，通过“安全黑匣子”打造的数据安全环境以及加密等手段实现数据防泄露；在 App 端，借助数据安全存储、安全签名等手段充分确保业务功能的稳定运行。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021973357\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>客户端 App 数据安全传输、安全存储</strong></p> \n<p>针对客户端的数据传输与验签，要做到精细化的安全一直是老大难的挑战。借助“安全黑匣子”，目前支付宝已实现针对应用级别数据如 AppSecret 采用加密存储，通过数据加签接口实现各类上层业务的封装。</p> \n<p>借助安全黑匣子，客户端通过应用公钥和秘钥加密针对生成的数据进行离散存储，保证加密秘钥的安全性。而安全黑匣子本身的代码混淆、多重反调试机制，使其安全性能极大提升保障。</p> \n<p>除此之外，安全黑匣子基于反调试技术使得常见的调试工具如 GDB、IDA Pro 的动态调试分析技术失效，基于导出表混淆、垃圾指令等手段充分提升攻击者静态分析应用的难度。如此动静结合，客户端数据传输及存储安全能够充分保障。</p> \n<p><strong>用户信息验证</strong></p> \n<p>随着终端设备算力的持续增强，目前移动端设备借助强大的 CPU 和 GPU 完全可以进行非常复杂的运算。而由此催生出的一系列移动端 AI 引擎，如支付宝的 xNN，帮助我们能够进一步加强用户信息验证的智能化。</p> \n<p>结合端上金融业务属性，如银行卡及身份证 OCR 识别、人脸识别、活体检测等智能服务，已经过近 2 亿用户验证，具备识别准确率高、速度快、模块丰富等特点，同时在支付宝小程序中也已开放。&nbsp;</p> \n<p><strong>App 全生命周期防护</strong></p> \n<p>关于客户端 App 安全，实际上是一套从 App 开发、上线及使用的一站式解决方案。在 App 开发阶段，提供代码混淆、数据加密、数据库加密等安全开发以及数据安全能力；在上线阶段，提供 App 加固的能力，通过 DEX 加壳、SO 加壳、防反编译、防重打包等能力，提升 App 的整体安全水位；在使用阶段，通过 API 签名、API 数据加密等手段来保障数据的完整性及安全性，同时借助安全加密键盘从而保护用户输入的信息安全性。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021973355\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h1>mPaaS 客户端 App 安全能力</h1> \n<p>作为源自支付宝的移动开发平台，mPaaS 目前已完成支付宝金融级的端上安全能力沉淀，不仅能够提升 App 应对高峰带宽下的服务质量挑战，同时在弱网情况下的可用性、针对网络请求的危险识别能力均属于行业前列。目前，借助 mPaaS 客户端的加固技术与黑匣子，能够保障移动端的代码安全和网络层的数据安全，提供加签、加密等方式，同时网关能够识别出客户端环境，并有能力针对可疑请求做拦截。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021973356\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>结合中国人民银行于 2019 年 9 月出台的《移动金融客户端应用软件安全管理规范》，针对客户端应用在数据安全、身份认证安全、功能安全设计、密码秘钥管理、数据安全、安全输入、抗攻击能力等方面均提出明确要求，全面覆盖客户端应用在设计、开发、发布及运维的全生命周期。</p> \n<p>mPaaS 产品目前已通过中国金融认证中心的安全测评，并服务银行、证券、政务、交通等众多行业超过 2000 家客户。同时，针对客户端安全方面 mPaaS 提供全方位安全防护方案，真正帮助企业打造安全稳定的移动应用，更好地做到技术驱动业务创新、为业务带来美好体验。</p>', 'https://segmentfault.com/img/remote/1460000021973354', '6fbfa4aaad3a43458f21c8acf0038ac5', '640c003521964678a2e591447f8be769,b7460efd3f3b4d6ea78254959a2aebff,cf84afe221f24e72b201344b3e15fa85,e75baefb206a4efe959a99aad77632a3,6aec6c8499c44483beecd569d05c7f4b', '0', '3', '1', '2020-04-16 16:59:07', '2020-04-16 16:59:07');
INSERT INTO `tb_recommend` VALUES ('d6f4a4c3a96846618de44f0c0e43d13b', '帮助phper理解RPC是怎么回事儿', '目前，主流的平台中都支持各种远程调用技术，以满足分布式系统架构中不同的系统之间的远程通信和相互调用。远程调用的应用场景极其广泛，实现的方式也各式各样。', '<h2>1.什么是rpc</h2> \n<p>RPC全称为Remote Procedure Call，翻译过来为“远程过程调用”。</p> \n<p>目前，主流的平台中都支持各种远程调用技术，以满足分布式系统架构中不同的系统之间的远程通信和相互调用。远程调用的应用场景极其广泛，实现的方式也各式各样。</p> \n<h2>2.从通信协议的层面</h2> \n<p>基于HTTP协议的（例如基于文本的SOAP（XML）、Rest（JSON），基于二进制Hessian（Binary））</p> \n<p>基于TCP协议的（通常会借助Mina、Netty等高性能网络框架）</p> \n<h1>RPC(远程过程调用)是什么</h1> \n<ul> \n <li>简单的说，RPC就是从一台机器（客户端）上通过参数传递的方式调用另一台机器（服务器）上的一个函数或方法（可以统称为服务）并得到返回的结果。</li> \n <li>RPC 会隐藏底层的通讯细节（不需要直接处理Socket通讯或Http通讯）</li> \n <li>RPC 是一个请求响应模型。客户端发起请求，服务器返回响应（类似于Http的工作方式）</li> \n <li>RPC 在使用形式上像调用本地函数（或方法）一样去调用远程的函数（或方法）。</li> \n</ul> \n<h2>远程过程调用发展历程</h2> \n<ul> \n <li>ONC RPC （开放网络计算的远程过程调用），OSF RPC（开放软件基金会的远程过程调用）</li> \n <li>CORBA（Common Object Request Broker Architecture公共对象请求代理体系结构）</li> \n <li>DCOM（分布式组件对象模型），COM+</li> \n <li>Java RMI</li> \n <li>.NET Remoting</li> \n <li>XML-RPC，SOAP，Web Service</li> \n <li>PHPRPC，Hessian，JSON-RPC</li> \n <li>Microsoft WCF，WebAPI</li> \n <li>ZeroC Ice，Thrift，GRPC</li> \n <li>Hprose</li> \n</ul> \n<h2>早期的 RPC</h2> \n<ul> \n <li>第一代 RPC（ONC RPC，OSF RPC）不支持对象的传递。</li> \n <li>CORBA 太复杂，各种不同实现不兼容，一般程序员也玩不转。</li> \n <li>DCOM，COM+ 逃不出 Windows 的手掌心。</li> \n <li>RMI 只能在 Java 里面玩。</li> \n <li>.NET Remoting 只能在 .NET 平台上玩。</li> \n</ul> \n<h2>XML-RPC，SOAP，WebService</h2> \n<ul> \n <li>冗余数据太多，处理速度太慢。</li> \n <li>RPC 风格的 Web Service 跨语言性不佳，而 Document 风格的 Web Service 又太过难用。</li> \n <li>Web Service 没有解决用户的真正问题，只是把一个问题变成了另一个问题。</li> \n <li>Web Service 的规范太过复杂，以至于在 .NET 和 Java 平台以外没有真正好用的实现，甚至没有可用的实现。</li> \n <li>跨语言跨平台只是 Web Service 的一个口号，虽然很多人迷信这一点，但事实上它并没有真正实现。</li> \n</ul> \n<h2>PHPRPC</h2> \n<ul> \n <li>基于 PHP 内置的序列化格式，在跨语言的类型映射上存在硬伤。</li> \n <li>通讯上依赖于 HTTP 协议，没有其它底层通讯方式的选择。</li> \n <li>内置的加密传输既是特点，也是缺点。</li> \n <li>虽然比基于 XML 的 RPC 速度快，但还不是足够快。</li> \n</ul> \n<h2>Hessian</h2> \n<ul> \n <li>二进制的数据格式完全不具有可读性。</li> \n <li>官方只提供了两个半语言的实现（Java，ActionScript 和不怎么完美的 Python 实现），其它语言的第三方实现良莠不齐。</li> \n <li>支持的语言不够多，对 Web 前端的 JavaScript 完全无视。</li> \n <li>虽然是动态 RPC，但动态性仍然欠佳。</li> \n <li>虽然比基于 XML 的 RPC 速度快，但还不是足够快。</li> \n</ul> \n<h2>JSON-RPC</h2> \n<ul> \n <li>JSON 具有文本可读性，且比 XML 更简洁。</li> \n <li>JSON 受 JavaScript 语言子集的限制，可表示的数据类型不够多。</li> \n <li>JSON 格式无法表示数据内的自引用，互引用和循环引用。</li> \n <li>某些语言具有多种版本的实现，但在类型影射上没有统一标准，存在兼容性问题。</li> \n <li>JSON-RPC 虽然有规范，但是却没有统一的实现。在不同语言中的各自实现存在兼容性问题，无法真正互通。</li> \n</ul> \n<h2>Microsoft WCF，WebAPI</h2> \n<ul> \n <li>它们是微软对已有技术的一个 .NET 平台上的统一封装，是对 .NET Remoting、WebService 和基于 JSON 、XML 等数据格式的 REST 风格的服务等技术的一个整合。</li> \n <li>虽然号称可以在 .NET 平台以外来调用它的这些服务，但实际上跟在 .NET 平台内调用完全是两码事。它没有提供任何在其他平台的语言中可以使用的任何工具。</li> \n</ul> \n<h2>ZeroC Ice，Thrift，GRPC</h2> \n<ul> \n <li>初代 RPC 技术的跨语言面向对象的回归。</li> \n <li>仍然需要通过中间语言来编写类型和接口定义。</li> \n <li>仍然需要用代码生成器来将中间语言编写的类型和接口定义翻译成你所使用的编程语言的客户端和服务器端的占位程序（stub）。</li> \n <li>你必须要基于生成的服务器代码来单独编写服务，而不能将已有代码直接作为服务发布。</li> \n <li>你必须要用生成的客户端代码来调用服务，而没有其它更灵活的方式。</li> \n <li>如果你的中间代码做了修改，以上所有步骤你都要至少重复一遍。</li> \n</ul> \n<h2>Hprose</h2> \n<ul> \n <li>无侵入式设计，不需要单独定义类型，不需要单独编写服务，已有代码可以直接发布为服务。</li> \n <li>具有丰富的数据类型和完美的跨语言类型映射，支持自引用，互引用和循环引用数据。</li> \n <li>支持众多传输方式，如 HTTP、TCP、Websocket 等。</li> \n <li>客户端具有更灵活的调用方式，支持同步调用，异步调用，动态参数，可变参数，引用参数传递，多结果返回（Golang）等语言特征，Hprose 2.0 甚至支持推送。</li> \n <li>具有良好的可扩展性，可以通过过滤器和中间件实现加密、压缩、缓存、代理等各种功能性扩展。</li> \n <li>兼容的无差别跨语言调用</li> \n <li>支持更多的常用语言和平台</li> \n <li>支持浏览器端的跨域调用</li> \n <li>没有中间语言，无需学习成本</li> \n <li>性能卓越，使用简单</li> \n</ul> \n<h2>RPC与Socket有什么区别？</h2> \n<p>两者都是调用远程的方法，都是client/server模式。</p> \n<p>RPC（远程过程调用）采用客户机/服务器模式实现两个进程之间相互通信。socket是RPC经常采用的通信手段之一，RPC是在Socket的基础上实现的，它比socket需要更多的网络和系统资源。除了Socket，RPC还有其他的通信方法，比如：http、操作系统自带的管道等技术来实现对于远程程序的调用。微软的Windows系统中，RPC就是采用命名管道进行通信。</p> \n<h2>RPC与REST有什么区别？</h2> \n<p>通过了解RPC后，我们知道是RPC是client/server模式的，调用远程的方法，REST也是我们熟悉的一套API调用协议方法，它也是基于client/server模式的，调用远程的方法的，那他俩又有啥区别呢？</p> \n<p>REST API 和 RPC 都是在 Server端 把一个个函数封装成接口暴露出去，以供 Client端 调用，不过 REST API 是基于HTTP协议的，REST致力于通过http协议中的POST/GET/PUT/DELETE等方法和一个可读性强的URL来提供一个http请求。而 RPC 则可以不基于 HTTP协议</p> \n<p>因此，如果是后端两种语言互相调用，用 RPC 可以获得更好的性能（省去了 HTTP 报头等一系列东西），应该也更容易配置。如果是前端通过 AJAX 调用后端，那么用 REST API 的形式比较好（因为无论如何也避不开 HTTP 这道坎）。</p> \n<p>1、<strong>HTTP和RPC同一级别，还是被RPC包含？</strong></p> \n<p>2、<strong>Restful也属于RPC么？</strong></p> \n<p><img alt=\"\" title=\"\"></p> \n<p>上图是一个比较完整的关系图，这时我们发现HTTP（图中蓝色框）出现了两次。其中一个是和RPC并列的，都是跨应用调用方法的解决方案；另一个则是被RPC包含的，是RPC通信过程的可选协议之一。</p> \n<p>因此，<strong>第一个问题的答案是都对。看指的是哪一个蓝色框。</strong>从题主的提问看，既然题主在纠结这两者，应该是指与RPC并列的蓝色框。</p> \n<p>第二个问题是在问远程过程调用（红色框）是不是包含了Restful（黄色框），这种理解的关键在于对RPC的理解。</p> \n<p>RPC字面理解是远程过程调用，即在一个应用中调用另一个应用的方法。那Restful是满足的，通过它可以实现在一个应用中调用另一个应用的方法。</p> \n<p>但是，上述理解使得RPC的定义过于宽泛。RPC通常特指在一个应用中调用另一个应用的接口而实现的远程调用，即红色框所指的范围。这样，RPC是不包含Restful的。</p> \n<p>因此，<strong>第二个问题的答案是Restful不属于RPC，除非对RPC有着非常规的宽泛理解。</strong></p> \n<p>RPC的英文全称是Remote Procedure Call，翻译为中文叫“远程过程调用”。其中稍显晦涩的其实就是“过程”，过程其实就是方法。所以，可以把RPC理解为“远程方法调用”。</p> \n<p>要了解远程过程调用，那先理解过程调用。非常简单，如下图，就是调用一个方法。这太常见了，不多解释。</p> \n<p><img alt=\"\" title=\"\"></p> \n<p>而在分布式系统中，因为每个服务的边界都很小，很有可能调用别的服务提供的方法。这就出现了服务A调用服务B中方法的需求，即远程过程调用。</p> \n<p>要想让服务A调用服务B中的方法，最先想到的就是通过HTTP请求实现。是的，这是很常见的，例如服务B暴露Restful接口，然后让服务A调用它的接口。基于Restful的调用方式因为可读性好（服务B暴露出的是Restful接口，可读性当然好）而且HTTP请求可以通过各种防火墙，因此非常不错。</p> \n<p>然而，如前面所述，基于Restful的远程过程调用有着明显的缺点，主要是效率低、封装调用复杂。当存在大量的服务间调用时，这些缺点变得更为突出。</p> \n<p>服务A调用服务B的过程是应用间的内部过程，<strong>牺牲可读性提升效率、易用性是可取的</strong>。基于这种思路，RPC产生了。</p> \n<h2>通过hprose实现rpc</h2> \n<p><strong>HPROSE</strong>&nbsp;是&nbsp;<em>High Performance Remote Object Service Engine</em>&nbsp;的缩写，翻译成中文就是“高性能远程对象服务引擎”。</p> \n<p>它是一个先进的轻量级的跨语言跨平台面向对象的高性能远程动态通讯中间件。它不仅简单易用，而且功能强大。你只需要稍许的时间去学习，就能用它轻松构建跨语言跨平台的分布式应用系统了。</p> \n<p>Hprose 支持众多流行的编程语言，例如：</p> \n<ul> \n <li>AAuto Quicker</li> \n <li>ActionScript</li> \n <li>ASP</li> \n <li>C++</li> \n <li>Delphi/Free Pascal</li> \n <li>dotNET(C#, Visual Basic...)</li> \n <li>Golang</li> \n <li>Java</li> \n <li>JavaScript</li> \n <li>Node.js</li> \n <li>Objective-C</li> \n <li>Perl</li> \n <li>PHP</li> \n <li>Python</li> \n <li>Ruby</li> \n</ul> \n<p>通过 Hprose，你就可以在这些语言之间方便高效的实现互通了。</p> \n<h2>基础实现</h2> \n<p>在同一个文件夹下，执行一下操作，分别是拉取组建的命令，创建两个文件和执行php文件。</p> \n<p>拉取hprose组件</p> \n<p>composer require hprose/hprose</p> \n<p>建立server.php</p> \n<p>&lt;?php</p> \n<p>require_once \"./vendor/autoload.php\";</p> \n<p>use HproseSocketServer;</p> \n<p>function hello($name) {</p> \n<p>return \"Hello $name!\";</p> \n<p>}</p> \n<p>$server = new Server(\"tcp://0.0.0.0:1314\");</p> \n<p>$server-&gt;setErrorTypes(E_ALL);</p> \n<p>$server-&gt;setDebugEnabled();</p> \n<p>$server-&gt;addFunction(\'hello\');</p> \n<p>$server-&gt;start();</p> \n<p>建立client.php</p> \n<p>&lt;?php</p> \n<p>require_once \"./vendor/autoload.php\";</p> \n<p>use HproseFuture;</p> \n<p>use HproseSocketClient;</p> \n<p>$test = new Client(\"tcp://127.0.0.1:1314\");</p> \n<p>$test-&gt;fullDuplex = true;</p> \n<p>Futureco(function() use ($test) {</p> \n<p>try {</p> \n<p>var_dump((yield $test-&gt;hello(\"yield world1\")));</p> \n<p>var_dump((yield $test-&gt;hello(\"yield world2\")));</p> \n<p>var_dump((yield $test-&gt;hello(\"yield world3\")));</p> \n<p>var_dump((yield $test-&gt;hello(\"yield world4\")));</p> \n<p>var_dump((yield $test-&gt;hello(\"yield world5\")));</p> \n<p>var_dump((yield $test-&gt;hello(\"yield world6\")));</p> \n<p>}</p> \n<p>catch (Exception $e) {</p> \n<p>echo ($e);</p> \n<p>}</p> \n<p>});</p> \n<p>执行</p> \n<p>php server.php</p> \n<p>php client.php</p> \n<p>结果</p> \n<p>string(19) \"Hello yield world1!\"</p> \n<p>string(19) \"Hello yield world2!\"</p> \n<p>string(19) \"Hello yield world3!\"</p> \n<p>string(19) \"Hello yield world4!\"</p> \n<p>string(19) \"Hello yield world5!\"</p> \n<p>string(19) \"Hello yield world6!\"</p> \n<p>可继续学习：</p> \n<p><a href=\"https://github.com/hprose/hprose-php/wiki\" rel=\"nofollow noreferrer\">Hprose for PHP 用户手册</a></p> \n<p>本文摘自：<br><a href=\"https://www.kancloud.cn/martist/micro_service\" rel=\"nofollow noreferrer\">https://www.kancloud.cn/marti...</a></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022392834\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"帮助phper理解RPC是怎么回事儿\" title=\"帮助phper理解RPC是怎么回事儿\"></span></p>', 'https://segmentfault.com/img/remote/1460000022392834', 'f53014d680884163a5bd5ce762e90cdf', '3300149da71245d9b748b46d3a41c628,84e1fca09c4340be87d5c1ef4601b026', '0', '3', '1', '2020-04-16 16:48:52', '2020-04-16 16:48:52');
INSERT INTO `tb_recommend` VALUES ('d7e8813d307b439c8b055d5eac8301bc', '框架设计：小程序框架与组件化如何选型定制', '如今早已是全民联网年代，可以发现自己的父母大姑大姨等亲戚甚至爷爷奶奶，只要他们在使用千元智能机了，无论是看头条还是微信还是抖音，都在参与整个互联网的流量和内容的产生，他/她们通过手机消费了自己的时间...', '<blockquote>\n 著作权归作者所有。商业转载请联系 Scott 获得授权，非商业转载请注明出处[务必保留全文，勿做删减]。\n</blockquote> \n<p>蚂蚁雄兵的年代，人人皆可为王。</p> \n<p>如今早已是全民联网年代，可以发现自己的父母大姑大姨等亲戚甚至爷爷奶奶，只要他们在使用千元智能机了，无论是看头条还是微信还是抖音，都在参与整个互联网的流量和内容的产生，他/她们通过手机消费了自己的时间，同时为所有的产品提供了更多人物画像的行为数据，无论是上翻下翻还是留言点赞，每一个 APP 都是一个独立的平台，而在这两年，冉冉升起的区别于 APP 的新应用平台，非小程序莫属:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1564468241133-734aa6af-b89e-489c-88bc-7170fbdcb011.png#align=left&amp;display=inline&amp;height=1044&amp;originHeight=1044&amp;originWidth=1884&amp;size=0&amp;status=done&amp;width=1884\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>上图是从阿拉丁公布的数据报告中截取引用过来的，整个 2018 年，基于小程序生态的融资规模是 80 亿，是 2017 年的整整 8 倍，小程序几乎扎根了所有领域的所有层面，而且除了微信小程序，其他小程序小应用也都在布局：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1564468241116-fbe087ba-444d-4658-a968-e352bfb7c289.png#align=left&amp;display=inline&amp;height=1054&amp;originHeight=1054&amp;originWidth=1898&amp;size=0&amp;status=done&amp;style=none&amp;width=1898\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在整个泛小程序生态崛起的过程中，许多创业公司都主动登船，小菜也不例外，我们是在 2018 年 3 月份开始技术预研和拥抱小程序生态，至此 1 年我们业务上收获颇丰，而技术这里，也略有积淀，就跟大家分享小程序这块我们的思考和沉淀。</p> \n<p><a></a></p> \n<h2>用原生还是用框架</h2> \n<p>小菜前端的个别同学，包括我都有过一些开发小程序的经验，没使用任何框架就用小程序原生语法来实现，但小程序的功能都比较简单，所以也自然没遇到太大的工程挑战，而我们 2018 年要启动的小程序产品具有两个特征：第一个是功能和交互足够的复杂，第二是迭代速度要非常快，两周就要首版上线，之后每周至少发一到两个版本，基于这样的业务背景，我们也就毅然的选择使用框架而非原生，但这个决策带来的后期风险也的确超出了我们的预期。</p> \n<p>如果我们再回到一年前做选型，估计还是会选择框架，但至少不会那么乐观的 All in 其中，而是择时机尽早切回原生（虽然我们目前已是半原生）。所以给大家的建议是：如果产品功能相对简单，一二十个页面也没有太奇怪的交互和太大的列表数据量，用框架用原生都可以，开发周期短的话就用框架，实际上市面上看到的绝大多数小程序都不属于是复杂应用，用框架都能很好很快的 hold 住，但反过来假如你要实现的产品交互和前端列表数据量较大，图片图表视频多媒体复杂搜索应有尽有，那么能用原生就用原生。</p> \n<p><a></a></p> \n<h2>如何选择框架</h2> \n<p>框架的核心价值就是效率，一旦我们决定使用框架，那么就要把当下及未来市面上可用的小程序框架，做一个必要的比较和选择，这个过程通常会比较纠结。因为截止到 2019 年，还并没有一个小程序框架足够足够的好，大家都在六七十分上下，那我们可以从哪些方面来考虑呢？</p> \n<p>小菜前端最初选型框架主要考虑如下几个方面（都很必要但优先级程度自上向下依次降低）：</p> \n<ul> \n <li>框架的成熟程度与开发效率 - 是否满足产品迭代需求</li> \n <li>多端（H5/小程序）的兼容程度 - 是否满足产品的端覆盖需求</li> \n <li>配置成本/易用性/拓展性 - 是否满足工程师的工程架构需求</li> \n <li>整体性能的表现 - 是否能顶得住复杂交互和大数据列表</li> \n <li>团队成员的学习成本 - 是否有必要的人员和技术栈储备</li> \n <li>框架背后的团队实力 - 是否有足够好的工程实践和开发支持</li> \n <li>框架在社区的沉淀和生态 - 是否有群众基础和社区方案</li> \n <li>框架是否是 KPI 产品 - 是否会慢慢 Bug 不修弃坑跑路</li> \n</ul> \n<p>总体做选型的路子是优先保产品，再看工程质量及合理性，最后看社区及开发者生态健康程度。</p> \n<p>很可惜，即便我们考虑了这么多，限于当时（2018 年 3~5 月）的小程序框架生态太过早期也太单薄，我们最终选择了美团的 MPVue（实际上没得选），但上面的参考项今天看来对大家依然是通用的，当时的比对过程我再给大家呈现下，帮大家加深下这个选型运用的过程：</p> \n<p>首先针对能否优先保产品，也就是框架成熟程度和开发效率，多端兼容程度这块，我们实际上只有 wepy，MPVue，Taro 可选，针对他们三个，我们是这样比对的：</p> \n<ul> \n <li>社区生态是否足够活跃</li> \n <li>跨端迁移成本</li> \n <li>框架核心团队是否背靠大厂，是否是 KPI 产物</li> \n <li>开发效率问题，更多是踩坑时间问题</li> \n</ul> \n<p>其次，针对工程质量与合理性，也就是框架的配置成本/易用性/拓展性，整体性能这块，我们是这样评估的：</p> \n<ul> \n <li>框架上手成本</li> \n <li>底层工程架构基建是否支持到位</li> \n <li>性能问题: 先上再说，过得去就好，剩下的就慢慢优化</li> \n</ul> \n<p>最后，针对社区/开发者生态，也就是团队成员既有技术栈、社区反馈和生态这块，我们是这样评估的：</p> \n<ul> \n <li>团队成员中是否有人具备相应的技术栈能力</li> \n <li>框架是否支持已有的库快速接入</li> \n <li>社区对于该框架的反应如何，是否还属于半成品或者存在 Bug 很多的问题</li> \n</ul> \n<p><a></a></p> \n<h2>如何做组件化</h2> \n<p>小菜最初的产品端载体主要是 APP 和 PC Web，尤其是 APP，有 7 个之多，所以 RN 的组件化在 2018 年是有过两个大版本的累计了好几十个，但这个对于小程序来讲远水解不了近渴，而小程序的页面数目越来越多，组件复用变成了刚需，所以我们开始了小程序的组件建设之旅。</p> \n<p>基于 MPVue 在小程序里写组件，也是比较神伤。因为小程序端代码是静态的(即提前编译好的模版)， 所以像 HOC 就没办法用了（还有很多其他一些 Vue 语法糖编译不了）, 我们这里用的都是 mixins，基础的 mixins&nbsp;有很多:</p> \n<ul> \n <li>函数调用相关(去抖/节流)</li> \n <li>列表加载相关</li> \n <li>用户基础信息/微信信息</li> \n <li>数据初始化相关</li> \n <li>分享调用相关</li> \n <li>页面下拉/滚动相关</li> \n <li>收集 Form Id</li> \n <li>授权处理相关</li> \n</ul> \n<p>基于 mixins 就可以来设计组件了，一旦决定要抽象出一个组件，我们主要考虑如下因素：</p> \n<ul> \n <li>UI/功能的耦合程度</li> \n <li>内外部调用的耦合程度</li> \n <li>组合组件（组件间的通信层）</li> \n <li>组件性质（基础/业务）</li> \n <li>兼容问题</li> \n <li>后期扩展能力</li> \n</ul> \n<p>我们已经沉淀的组件有：</p> \n<ul> \n <li>上传组件（Upload）</li> \n <li>Tabbar</li> \n <li>Spinner</li> \n <li>Radio/Radio Group</li> \n <li>Video</li> \n <li>Cell</li> \n <li>Input/Textarea</li> \n <li>SearchBar</li> \n <li>授权/登录弹窗 组件</li> \n <li>保存/预览图片 组件</li> \n <li>图片懒加载/占位 组件</li> \n <li>语音录制/播放 组件（Record-bubble/Record-button）</li> \n <li>页面异常状态组件 (102/404)</li> \n <li>其他业务组件......</li> \n</ul> \n<p>这些组件里面：</p> \n<p>比如 Input/Textarea 组件，它需要重点考虑 UI/功能的耦合，要如何设计？</p> \n<ul>\n <li>组件复杂度高的话，可以切分数据服务层与 UI 层，采用 Mixin 混合抽象方法到 UI 层里。</li>\n</ul> \n<p>比如授权/登录弹窗组件，它需要重点考虑内外部调用的耦合，要如何设计？</p> \n<ul> \n <li>组件需要具备单一职责，不能图方便把很多东西都耦合进去</li> \n <li>如何和其他组件配合使用</li> \n</ul> \n<p>比如 Upload Group 组件，它属于是组合组件，要如何设计？</p> \n<ul> \n <li>上传发生异常的处理与上抛。</li> \n <li>组合层之间调用的 Hook。</li> \n <li>注意 Props 的透传与值的双向绑定。</li> \n</ul> \n<p>比如语音录制/播放组件，它需要组件性质，要如何设计？</p> \n<ul> \n <li>业务级别的组件，在复杂度高的情况下，也可以考虑切分 UI/数据服务层。</li> \n <li>如果通信层较复杂的话，可以考虑类似 redux 的设计，下层组件 dispatch action 到上层，上层统一管理 action 并 分发数据/事件 给下层组件。</li> \n</ul> \n<p>除此以外，组件设计的时候还要兼顾小程序端上与 Vue 的差异性。比如生命周期（组件与页面），在 MPVue 编译完后，&nbsp;Vue 组件生命周期并不会编译成小程序组件的生命周期，说白了就是需要你熟悉两套生命周期:&nbsp;&nbsp;Vue&nbsp;组件生命周期与小程序组件/页面生命周期。</p> \n<ol> \n <li>MPVue&nbsp;编译完的 Vue&nbsp;组件生命周期并不会和 小程序组件生命周期的调用一致，比如<strong>第二次</strong>点开同一个页面，非页面级别的组件 <code>mounted</code>&nbsp;永远只会调用一次（除非你在组件或者组件上层挂了&nbsp;<code>v-if</code>&nbsp;），而实际上这个组件在小程序里被调用了两次 <code>attached</code>&nbsp;小程序组件生命周期。</li> \n <li>更不用说&nbsp;<code>beforeMount/onUnload</code>&nbsp;的问题了。</li> \n <li>页面数据缓存问题，小程序本身会缓存打开过的页面数据，常见场景就是商品详情页面，第二次打开的时候，在进行页面数据更新之前，页面并不是空状态，而是上一次详情的数据。处理的话就有很多种方法了，可以在 <code>beforeMount/onUnload/其他生命周期</code>&nbsp;里初始化页面数据及置空所有状态，具体就看你怎么设计和抽象了，最主要的目的还是让开发者尽可能少的感知/手动调用。</li> \n</ol> \n<p>除了要考虑以上这些问题之外，我们还需要去解决端上的兼容问题以及框架带来的问题。</p> \n<p>微信端的兼容问题简直是层出不穷，不仅和机型、系统版本有关，甚至还和微信版本有关。所以当遇到这一类问题的时候，我们只能求助于&nbsp;<a href=\"https://developers.weixin.qq.com/\" rel=\"nofollow noreferrer\">微信开发者社区</a>，期待有相应的解决方案。</p> \n<p>框架带来的问题有时候就有点恶心了。比如说 MPVue 并不支持动态的传入&nbsp;<code>input</code>&nbsp;的&nbsp;<code>type</code>&nbsp;属性，这就导致如果我们需要文本键盘、数字键盘、带小数点数字键盘等等这一类的&nbsp;<code>input</code>&nbsp;时，我们需要每种类型都写一个&nbsp;<code>input</code>&nbsp;组件，平白增加了代码量，并且定位到问题也不方便。</p> \n<p><a></a></p> \n<h2>逃不过的原生能力</h2> \n<p>以上我们探讨了框架选型和组件化设计，最后再回归到我们认为非常核心的一个能力，就是小程序的原生开发和优化能力，MPVue 编译完的代码运行时的性能在很多场景里并不达到你的要求，比如输入组件的双向绑定之光标闪烁/内容回退,，大数据量之操作延迟等等...... （没遇到过的同学<a href=\"https://github.com/Meituan-Dianping/mpvue/issues\" rel=\"nofollow noreferrer\">自行搜索</a>）。总的来说就是&nbsp;MPVue 底层对于数据的操作实现的很稀烂，这个问题也只有当我们将项目做大了才遇到。</p> \n<p>当遇到类似上面这种性能问题的时候，就避免不了去寻找解决方案。但所谓的解决方案很有限，要么换框架，这时候已经上车，全量换框架工程太过浩大不敢想。要么写原生，写原生不仅工程量也浩大，而且原生代码的复用成本也难度不小，这就是框架选型带来的后续维护成本和风险了。</p> \n<p>但问题是躲不过去的，终究要解决。除了上面这几点需要去衡量的之外, 还要衡量一些非技术因素:</p> \n<ul> \n <li>产品发展形态/可预见的趋势：随着业务的发展以及小程序的权限收缩，为了继续扩大产品的可触达范围，势必会新增更多的端。</li> \n <li>用户群体：需要去收集用户的地理信息、手机型号、网络环境等等，综合这些数据去优化相应的点，做到有的放矢。</li> \n</ul> \n<p>我们最终还是决定当部分组件替换为原生组件，比如：</p> \n<ul> \n <li>MPVue 写的 <code>input/textarea</code>&nbsp;在输入的时候就会出现光标闪烁/内容回滚的异常（原因就不赘述了），所以使用小程序原生语法重写了 <code>input/textarea</code>&nbsp;组件，主要目的就是让组件的输入能够脱离 MPVue 的更新，直接组件内部走小程序的 <code>setData</code>&nbsp;，因为当时 MPVue&nbsp;还没有对数据更新做&nbsp;<code>diff</code>&nbsp;操作，目前据说做了一层 <code>diff</code>&nbsp;（实际效果大家自己去测评吧）</li> \n <li>产品中的文章详情需要 Markdown 渲染，因为文章内容相对来说都是数据量比较大的，使用 MPVue 去对这部分数据进行解析的话性能会相对来说较差。因此我们也使用了原生去实现了一个 Markdown 渲染的组件。</li> \n</ul> \n<p>其实除了将组件替换为原生组件之外，我们还可以去优化原生的 <code>setData</code>&nbsp;方法，具体内容可以阅读 <a href=\"https://github.com/Tencent/westore\" rel=\"nofollow noreferrer\">westore</a>&nbsp;这个库，进一步提升性能。</p> \n<p>最终，我们的架构慢慢就会变成了这样：Vue 会慢慢成为一个数据注入/数据分析/事件分发三者集合的中心枢纽一样的存在，底层是由各种高性能的原生组件，上层是由 Vue 来分发事件给不同组件，注入数据到不同组件里，收集埋点行为/事件。</p> \n<p>这样一个现状依然有它新的问题，首先是多端复用成本低，现在还无法一套代码在 H5/小程序里全部通用，其次是小程序原生学习成本还是比框架要高，这对于不熟悉原生的同学都是一个不小的技术学习成本。</p> \n<p><a></a></p> \n<h2>当下的困境</h2> \n<p>当下来看，我们之前选择的 MPVue 已经不能很好地支撑业务需求了。其一是因为 Vue 与我们的主体技术栈的分割，二来 MPVue 并不能支持跨多个平台开发。</p> \n<p>跨多平台开发已经是当下的一个迫切需求。假如一个需求需要维护多端的代码，那么势必会需要更多的前端资源投入，这个成本是难以接受的。因此我们也开始考虑到底是使用市面上类似 Taro 这样的框架还是选择自研，两者的选择都有各自的好处。选择 Taro 这样的框架能够让我们迅速进入开发，但是长远来看免不了可能会出现 MPVue 类似的维护问题；选择自研的话虽然不会存在维护上的问题，但是会短期内需要投入更多的前端资源。</p> \n<p>以上这些问题就是我们当下遇到的一个困境，选择任何一个方案都可能对将来造成巨大的问题，就比如当初我们选择 MPVue 那样。</p> \n<blockquote>\n Scott 近两年无论是面试还是线下线上的技术分享，遇到许许多多前端同学，由于团队原因，个人原因，职业成长，技术方向，甚至家庭等等原因，在理想国与现实之间，在放弃与坚守之间，摇摆不停，心酸硬扛，大家可以找我聊聊南聊聊北，对工程师的宿命有更多的了解，有更多的看见与听见，Scott 微信： codingdream，也可以来\n <a href=\"https://www.yuque.com/iscott\" rel=\"nofollow noreferrer\">关注 Scott 跟进我的动态</a>。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882754189-781488ce-b345-45cf-a3b7-cb5309e9caa6.png#align=left&amp;display=inline&amp;height=399&amp;name=2.png&amp;originHeight=600&amp;originWidth=600&amp;size=158647&amp;status=done&amp;style=none&amp;width=399\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"2.png\" title=\"2.png\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882773713-309efa88-e1fc-481f-865b-3c0cb0d3ec43.png#align=left&amp;display=inline&amp;height=398&amp;name=1.png&amp;originHeight=600&amp;originWidth=600&amp;size=134434&amp;status=done&amp;style=none&amp;width=398\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"1.png\" title=\"1.png\"></span></p>', 'https://cdn.nlark.com/yuque/0/2019/png/87555/1564468241133-734aa6af-b89e-489c-88bc-7170fbdcb011.png#align=left&amp;display=inline&amp;height=1044&amp;originHeight=1044&amp;originWidth=1884&amp;size=0&amp;status=done&amp;width=1884', '1c5851dc916d4e70a60f0c957f548876', '63c4e1e7ec204b43a62065a3ced4c2ce,3b375646301546259a8fb29d74ae4447,ead69bffd58e43f2a5ead395c498cf8e', '0', '3', '1', '2020-04-16 16:49:23', '2020-04-16 16:49:23');
INSERT INTO `tb_recommend` VALUES ('d80baecf74b94bc1a53167a0af580337', 'Apache Jmeter 分布式压测与监控，真那么难搞定？', '对于运维工程师来说，需要对自己维护的服务器性能瓶颈了如指掌，比如我当前的架构每秒并发是多少，我服务器最大能接受的并发是多少，是什么导致我的性能有问题；如果当前架构快达到性能瓶颈了，是横向扩容性能提...', '<h2><strong>1.前言</strong></h2> \n<p>对于运维工程师来说，需要对自己维护的服务器性能瓶颈了如指掌，比如我当前的架构每秒并发是多少，我服务器最大能接受的并发是多少，是什么导致我的性能有问题；如果当前架构快达到性能瓶颈了，是横向扩容性能提升大，还是纵向扩容性能提升大。</p> \n<p>如果需要了解这些信息，需要在两方面下功夫，一个是对服务器进行性能测试，一个是对服务器进行性能监控。</p> \n<p><strong>通过对服务器进行性能测试：</strong>我们可以了解到当前架构的性能瓶颈，还可以对架构横向扩容和纵向扩容来进行测试，对后期的架构扩容提供数据参考。</p> \n<p><strong>通过对服务器进行性能监控：</strong>我们可以了解当前服务器的CPU、内存、IO等资源是否耗尽，我们可以在监控系统添加触发器，一旦服务器资源在快要达到瓶颈的时候，我们可以触发一个报警让运维人员来处理，也可以触发一个让架构进行自动化扩容（如果是云平台，直接调用api创建主机，ansible部署应用和程序）</p> \n<p>本文将介绍下，我在工作中使用jmeter测试性能瓶颈的一些实践。本文做性能测试适用于移动互联网架构，非移动互联网架构有其他更好的测试方法。</p> \n<h2><strong>2.Jmeter分布式压测介绍</strong></h2> \n<p>在工作中使用jmeter做大并发压力测试的场景下，单机受限内存、CPU、网络IO，会出现服务器压力还没有上去，但是压测服务器已经由于模拟的压力太大死机了。为了让jmeter工具提供更强大的负载能力，jmeter提供了多台机器同时产生负载的机制，下面是架构图。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391253\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>原理：</strong>比如我在jmeter server配置线程数为10，循环次数为100，也就是会对测试服务器发起1000次请求，我有3台agent服务器，如果我在server端选择远程启动压力测试，那么每台agent都会对测试服务器发起10*100次请求，那么这次压力测试产生的请求就是10*100*3=3000次。</p> \n<p>如果对原理不是很明白，看完下面的操作之后就会理解了。</p> \n<h2><strong>3.Jmeter分布式压测环境搭建</strong></h2> \n<h3>3.1.搭建前说明</h3> \n<p>服务器环境说明：做性能测试可以直接在在云平台按需购买压力机，一旦测试结束释放压力机即可。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391252\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>分布式环境压力服务器要求：</p> \n<ul> \n <li>需要server（控制机）和agent（压力机），agent搭建在linux（centos 6.5）服务器环境下，server搭建在windows（server 2012）环境下。</li> \n <li>压力测试瓶颈大都在带宽上面，需要保证压力机的带宽要比服务器的带宽高，不然压力上不去。</li> \n <li>需要保证agent和server都在一个网络中，且在多网卡环境需要保证启动的网卡都在一个网段。</li> \n <li>需要保证server和agent之间的时间同步。</li> \n <li>关闭防火墙。</li> \n</ul> \n<h3>3.2.Windows部署jmeter</h3> \n<p>（1）部署jdk环境,配置path变量，安装完成效果如下</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391254\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>（2）直接去官网下载最新的二进制源码包即可。</p> \n<p>（3）解压jmeter到指定目录，设置path变量，安装完成之后，在命令行运行jmeter命令，如果可以正常启动jmeter，说明环境配置ok。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391256\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>3.3.Linux部署jmeter</h3> \n<p>（1）下载安装</p> \n<pre><code>wget http://mirrors.tuna.tsinghua.edu.cn/apache//jmeter/binaries/apache-jmeter-3.1.zip\nunzip apache-jmeter-3.1.zip -d /usr/local/\ncd&nbsp;/usr/local/\nln&nbsp;-s apache-jmeter-3.1/ jmeter</code></pre> \n<p>（2）配置启动脚本</p> \n<pre><code>#!/bin/bash\n# chkconfig: 345 26 74\n# description: jmeter agent\nmyip=`ifconfig eth0 |awk&nbsp;\'/inet addr/{gsub(/addr:/,\"\");print $2}\'`\ncmd=\"/usr/local/jmeter/bin/jmeter-server -Djava.rmi.server.hostname=$myip\"\n\nstart(){&nbsp;&nbsp;\n    $cmd&nbsp;&amp;\n}\nstop(){\n   jmeter_pid=`ps aux | grep jmeter-server | grep -v grep | awk&nbsp;\'{print $2}\'`&nbsp;&nbsp;&nbsp;&nbsp;\n    for&nbsp;pid&nbsp;in&nbsp;$jmeter_pid;do&nbsp;&nbsp;&nbsp;&nbsp;\n    kill&nbsp;-9&nbsp;$pid&nbsp;&nbsp;&nbsp;&nbsp;     \n    done\n    }\n    \n    act=$1\n    case&nbsp;$act&nbsp;in&nbsp;\n    \'start\')&nbsp;&nbsp;&nbsp;\n       start;;&nbsp;\n    \'stop\')&nbsp;&nbsp;&nbsp;\n       stop;;&nbsp;\n    \'restart\')&nbsp;&nbsp;&nbsp;\n       stop&nbsp;&nbsp;&nbsp;\n       sleep 2&nbsp;&nbsp;&nbsp;\n       start;;&nbsp;&nbsp;\n    *)&nbsp;&nbsp;&nbsp;\n      echo&nbsp;\'[start|stop|restart]\';;\n    esac</code></pre> \n<p>（3）启动jmeter agent服务，验证是否监听1099端口</p> \n<pre><code>[root@jmeter-agent-01&nbsp;~]# /etc/init.d/jmeter-agent start\n[root@jmeter-agent-01&nbsp;~]# netstat -lntp | grep 1099\ntcp&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;0.0.0.0:1099&nbsp; &nbsp; &nbsp; &nbsp;&nbsp;0.0.0.0:*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;LISTEN&nbsp;414/java</code></pre> \n<h3>3.4.分布式环境配置</h3> \n<p>（1）确保server和agnet安装正确。</p> \n<p>（2）Agent启动，并监听1099端口。</p> \n<p>（3）在server机器的jmeter安装目录下bin目录下，找到properties文件，修改远程主机选项，添加3个agent服务器的地址。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391255\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>（4）启动jmeter server，多网卡模式需要指定IP地址启动</p> \n<pre><code>jmeter&nbsp;-Djava.rmi.server.hostname=192.168.10.61</code></pre> \n<p>（5）验证分布式环境是否搭建成功</p> \n<p>1、jmeter启动之后在如下选项中,会出现你添加的远程主机列表</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391257\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>2、创建一个请求测试：创建一个访问百度的请求，访问次数为一次，配置如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391258\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391260\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>直接点击启动，是jmeter server机器发起一次请求，结果如下</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391259\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>请求所有之前的请求数据之后，在选择远程全部启动，查看发起的请求就是三次，也就是每个agent服务器按照着server的配置，请求了一次。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391262\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391261\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>如果你的环境在选择全部启动之后，没有报错，且发起请求数量和agent服务器数量一致，说明jmeter分布式压力测试环境搭建成功，可以进行测试了。</p> \n<h2><strong>4.Jmeter断言</strong></h2> \n<h3><strong>4.1.断言介绍</strong></h3> \n<p>jmeter断言常用有两种，一种是响应断言，一种是响应时间断言，如果响应内容不满足断言的配置，则认为这次的请求是失败的。</p> \n<p>响应断言：判断响应内容是否包含指定的字符信息，用于判断api接口返回内容是否正确。</p> \n<p>响应时间断言：判断响应时间，是否超过预期的时间，用于判断api接口返回时间是否超过预期。</p> \n<h3><strong>4.2.断言配置</strong></h3> \n<p>（1）修改http为实际的api测试请求。</p> \n<p>（2）断言添加方式：右击测试计划的http请求，选择添加à断言à添加响应断言和断言持续时间。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391263\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>（3）配置响应断言：我们接口正常返回code值为2000，如果接口返回code值不是2000表示接口异常，为了测试，这里修改为接口返回code值不为2222则表示访问失败。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391264\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>（4）配置断言响应时间：设置请求接口时间超过1毫秒，则认为请求失败。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391266\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>（5）验证断言配置：发起http请求，由于返回内容code值不为2222，以及访问时间超过1毫秒，所以认为访问失败。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391265\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391267\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2><strong>5.Jmeter变量配置</strong></h2> \n<p>使用变量的场景举例：我们需要测试性能的曲线模型，也就是由轻压力慢慢变为重压力，来测试我们的性能拐点，这个时候jmeter就需要配置多个线程组，每个线程组需要设置http请求，比如下图；由于每次测试性能的曲线模型都是同一个接口，所以每次修改接口都需要修改http请求，这个时候如果使用了变量，就意味着每次修改api只需要修改api的变量即可。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391268\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>设置变量的方法：在测试计划中</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391270\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>引用变量：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391269\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2><strong>6.Jmeter性能测试结果分析</strong></h2> \n<p>下面是我执行一次性能曲线模型测试（请求从每秒3千递增到3万）的聚合报告：简单的看下，可以看到性能的拐点在每秒发起2.7万请求，TPS处理能力可以达到6000每秒，99%的用户响应时间在60毫秒，最大响应时间为71毫秒，性能还是不错的。</p> \n<p><strong>并发瓶颈：</strong>当请求从每秒2.7万递增到3万的过程中，我们的TPS由6000下降到了4500，可以看到并发瓶颈就在每秒最多处理6000请求</p> \n<p><strong>响应时间：</strong>我们可以看到TPS保持在3500或之下，99%用户用户的响应时间为11毫秒，随着TPS的升高，我们的响应时间也在随着升高，可以看到我们的TPS在每秒3500响应的时候，对响应时间是没有影响的。</p> \n<p>注意这个只是我的业务其中的一个接口，我们生产有上百个接口，不同的接口返回数据还有代码逻辑，以及执行的sql均不相同，如果需要做性能测试，应该选择其中的热点接口，对每个接口进行性能测试，得到结果之后在进行具体的分析性能瓶颈到低是什么？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391271\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>聚合报告参数说明：单位为毫秒</p> \n<ul> \n <li> <strong>Label：</strong>定义HTTP请求名称</li> \n <li> <strong>Samples：</strong>表示这次测试中发出了多少个请求</li> \n <li> <strong>Average：</strong>平均响应时长——默认情况下是单个request的平均响应时长</li> \n <li> <strong>Median：</strong>中位数，也就是50%用户的响应时长</li> \n <li> <strong>90% Line：</strong>90%用户的响应时长</li> \n <li> <strong>Min：</strong>访问页面的最小响应时长</li> \n <li> <strong>Max：</strong>访问页面的最大响应时长</li> \n <li> <strong>Error%：</strong>错误请求的数量/请求的总数</li> \n <li> <strong>Throughput：</strong>默认情况下表示每秒完成的请求数（request per second）</li> \n <li> <strong>KB/Sec：</strong>每秒从服务器端接收到的数据量</li> \n</ul> \n<h2><strong>7.测试中的监控</strong></h2> \n<h3><strong>7.1.并发测试监控</strong></h3> \n<p>并发测试直接发起指定数量的请求，比如一起发起10万请求看一下系统的处理能力，这个时候如果需要服务器的资源使用信息，就不能使用比如zabbix监控系统了，因为一般处理10万请求，对于我们来说20秒可以处理完毕，但是zabbix数据采集是每分钟一次，这样采集到的数据明显是不准的，这样就需要通过系统自带的监控命令，来实时查询服务器的性能，比如可以通过dstat或者glances等动态监控命令来分析系统的性能。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391272\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>补充：不是测试每一个接口都需要进行这样的实时监控，比如过测试我的大部分接口TPS可达5000，但是其中一个接口只能达到2000这个时候就需要在测试的时候实时监控，看一下到底是什么原因导致性能上不去。是由于返回数据太大导致网络带宽被占满；还是sql执行时间太长导致数据库负载高，还是代码有问题导致web服务cpu占用高。</p> \n<h3><strong>7.2.稳定性测试监控</strong></h3> \n<p>稳定性测试就是持续不断模拟指定数量请求，来访问服务器，比如我每秒向测试服务器发起4000请求，持续12小时，来看看服务器会出现什么情况，这个时候就需要用到zabbix来进行监控了，下面是我做性能测试的部分监控接口，包含tomcat每秒请求，服务器入口流量，整个集群每分钟请求的http状态码统计，还有服务器资源使用信息。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391273\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391274\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391275\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391276\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>欢迎大家关注我的微信公众号【<a href=\"https://mp.weixin.qq.com/mp/profile_ext?action=home&amp;__biz=MzI0MDQ4MTM5NQ==&amp;scene=124#wechat_redirect\" rel=\"nofollow noreferrer\">民工哥技术之路</a>】，最新整理的&nbsp;<strong>2TB</strong>&nbsp;技术干货：包括<strong>架构师实战教程、大数据、Docker容器、系统运维、数据库、redis、MogoDB、电子书、Java基础课程、Java实战项目、ELK Stack、机器学习、BAT面试精讲视频</strong>等。只需在<strong>「&nbsp;</strong><strong>民工哥技术之路」</strong>微信公众号对话框回复关键字：<strong>1024</strong>即可获取全部资料。</p>', 'https://segmentfault.com/img/remote/1460000022391253', '5ca4567d892841b087fac5246effac40', '55723db96b9f4593bae02bc1e49f1e87,d7416e100af54eb7a4d9274b9a462240,fb364499fe3f4b5bb7f0442e2fe0df82,753b5aee3913424e81fe2b5299626d8c,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 16:48:54', '2020-04-16 16:48:54');
INSERT INTO `tb_recommend` VALUES ('d9b3ff339ec947c3a984fbd59da67680', '从零开始的Flutter之旅: StatefulWidget', '往期回顾 从零开始的Flutter之旅: StatelessWidget 在之前的文章中，我们介绍了StatelessWidget的特性与它在Flutter中的呈现原理。 这次我们接着来聊聊它的兄弟StatefulWidget，俗称有状态小部件。 特性 如果你看...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037786\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>往期回顾</h2> \n<p><a href=\"https://segmentfault.com/a/1190000021938948\">从零开始的Flutter之旅: StatelessWidget</a></p> \n<p>在之前的文章中，我们介绍了StatelessWidget的特性与它在Flutter中的呈现原理。</p> \n<p>这次我们接着来聊聊它的兄弟StatefulWidget，俗称有状态小部件。</p> \n<h2>特性</h2> \n<p>如果你看了我之前的文章，你可能已经非常熟悉无状态小部件StatelessWidget。它们是由一个蓝图与不可变的element配置来实现的，实际安装到屏幕上的是各个StatelessElement。</p> \n<p>不可变的东西我是非常喜欢的，就像写代码一样，一旦定义了一个不可变的变量，我就不用再关心它之后的所有事情，因为它不可变的性质，致使它不会发生不可预期的问题，只需直接使用它即可。</p> \n<p>但一个程序只有不可变的配置是不行的，我们不可能编写一个只绘制一次后就停止的应用。因为一旦数据改变，不可变的配置是不可能帮助我们刷新ui，达到我们预期的效果；而有状态小部件StatefulWidget却可以轻松解决这些事情。</p> \n<p>StatefulWidget提供不可变的配置信息以及可以随着时间变化而触发的状态对象；通过监听状态的变化来达到ui的更新。</p> \n<p>简单点，我们从<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>挑选一个实例。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037791\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>当我们点击其中一个未读通知信息时，我们需要将其ui状态变成已读的样式。根据状态来改变ui，StatefulWidget能够很好的实现这种场景。来看一下其实现</p> \n<pre><code>class NotificationTabPage extends BasePage&lt;_NotificationPageState&gt; {\n  const NotificationTabPage();\n \n  @override\n  _NotificationPageState createBaseState() =&gt; _NotificationPageState();\n}\n \nclass _NotificationPageState\n    extends BaseState&lt;NotificationVM, NotificationTabPage&gt; {\n  @override\n  NotificationVM createVM() =&gt; NotificationVM(context);\n \n  @override\n  Widget createContentWidget() {\n    return RefreshIndicator(\n      onRefresh: vm.handlerRefresh,\n      child: Scrollbar(\n        child: ListView.builder(\n          itemCount: vm.notifications?.length ?? 0,\n          itemBuilder: (BuildContext context, int index) {\n            final NotificationModel item = vm.notifications[index];\n            return GestureDetector(\n              onTap: () {\n                vm.contentTap(index);\n              },\n              child: Container(\n                color: item.unread ? Colors.white : Color.fromARGB(13, 0, 0, 0),\n                padding: EdgeInsets.only(left: 15.0, top: 10.0, right: 15.0),\n                child: Column(\n                  crossAxisAlignment: CrossAxisAlignment.start,\n                  children: &lt;Widget&gt;[\n                    Text(\n                      item.repository.fullName,\n                      style: TextStyle(\n                        fontWeight: FontWeight.bold,\n                        fontSize: 16.0,\n                        color: item.unread\n                            ? Colors.black87\n                            : Color.fromARGB(255, 102, 102, 102),\n                      ),\n                    ),\n                    Row(\n                      children: &lt;Widget&gt;[\n                        Padding(\n                          padding: EdgeInsets.only(top: 5.0),\n                          child: Image.asset(\n                            vm.getTypeFlagSrc(item.subject.type),\n                            width: 18.0,\n                            height: 18.0,\n                          ),\n                        ),\n                        Expanded(\n                          child: Padding(\n                            padding: EdgeInsets.only(top: 5.0, left: 10.0),\n                            child: Text(\n                              item.subject.title,\n                              overflow: TextOverflow.ellipsis,\n                              maxLines: 1,\n                              style: TextStyle(\n                                fontSize: 14.0,\n                                color: item.unread\n                                    ? Color.fromARGB(255, 17, 17, 17)\n                                    : Color.fromARGB(255, 102, 102, 102),\n                              ),\n                            ),\n                          ),\n                        ),\n                      ],\n                    ),\n                    Padding(\n                      padding: EdgeInsets.only(top: 10.0),\n                      child: Divider(\n                        height: 1.0,\n                        endIndent: 0.0,\n                        color: Color.fromARGB(255, 207, 216, 220),\n                      ),\n                    ),\n                  ],\n                ),\n              ),\n            );\n          },\n        ),\n      ),\n    );\n  }\n}</code></pre> \n<p>这里的BasePage是<code>MSVM</code>架构中的基类，它继承于StatefulWidget；_NotificationPageState也是一样，它继承于State</p> \n<pre><code>abstract class BasePage&lt;S extends BaseState&gt;\n    extends StatefulWidget {\n    ...\n}\n \nabstract class BaseState&lt;VM extends BaseVM, T extends StatefulWidget&gt;\n    extends State implements VMSContract {\n    ...\n}</code></pre> \n<blockquote>\n 关于MSVM后续会专门开文章介绍，想了解的可以期待一下\n</blockquote> \n<p>我们来看createContentWidget方法中的布局，找到上述情况关联的ui，在ListView的item中。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037788\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>item布局的状态是根据item.unread来判断的，未读状态为ture。</p> \n<p>当用户onTap点击时，将会向服务器发送thread阅读请求，当请求成功之后，再将相应位置的item.unread值改为false。</p> \n<p>但就这样改变你会发现ui是不会刷新的，因为在StatefulWidget，如果你想改变某个值，同时要同步更新ui，需要使用setState方法。</p> \n<pre><code>  _markThreadRead(int index) async {\n    try {\n      Response response =\n          await dio.patch(\'/notifications/threads/${_notifications[index].id}\');\n      if (response != null &amp;&amp;\n          response.statusCode &gt;= 200 &amp;&amp;\n          response.statusCode &lt; 300) {\n        _notifications[index].unread = false;\n        notifyStateChanged();\n      }\n    } on DioError catch (e) {\n      Toast.show(\'makThreadRead error: ${e.message}\', context);\n    }\n  }</code></pre> \n<p>这里将setState方法封装到notifyStateChanged方法中。所以现在再回过去看ui，会发现ui已经刷新了。</p> \n<p>以上是使用StatefulWidget来达到ui的动态改变。再对比于之前的StatelessWidget，它们之间的区别显而易见了。</p> \n<h2>呈现原理</h2> \n<p>与StatelessWidget一样，接下来看下StatefulWidget的呈现原理。</p> \n<p>StatefulWidget也是继承于Widget，所以它的内部也是存在createElement方法。本质也是通过createElement来创建对应的Element Tree，只不过创建的是StatefulElement；然后再调用对应的Widget Tree中的build方法来获取相应的蓝图。</p> \n<p>但与StatelessWidget所不同的是，它还有另外一个方法</p> \n<pre><code>  @protected\n  State createState();</code></pre> \n<p>通过createState来创建对应的State。StatefulWidget保留了StatelessWidget的特性，即保证final数据的不变性，而对于非final可变数据，将通过Stete进行管理。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037790\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>上面是之前StatelessWidget呈现原理图，下面来对照看下StatefulWidget的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037787\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>除了Widget Tree与Element Tree，还有对应的State，它管理着可变的数据，例如item.unread。</p> \n<p>一旦item.unread改变了，且通知到State，State将会再下一帧重新要求Widget Tree进行刷新。重新构建一个Container</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037785\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>由于是同一种类型Container，将会直接被替换，同时使用更新后的item.unread，所以对应的Container的color也将发生改变。最终呈现的是布局的刷新。</p> \n<p>值得一提的是，State依附于Element Tree中，所以它的生命周期非常长，即使Widget Tree中的NotificationTabPage被移除重建，只要保证重建的类型是一致的，同时Widget Tree 与Element Tree的对应位置是没有变化的，那么Widget可以避免重建，只是会将其标记为脏状态，然后它的子widget将会通过build方法进行重建，替换State中的变化的值。</p> \n<p>如果你要监听Widget的变化，可以重写didUpdateWidget</p> \n<pre><code>  @override\n  void didUpdateWidget(StatefulWidget oldWidget) {\n    // TODO: implement didUpdateWidget\n    super.didUpdateWidget(oldWidget);\n  }</code></pre> \n<p>综上所述，StatefulWidget使你可以随时跟踪数据的变化并更新应用的ui。但你深入Flutter之后，你会发现自己写的更多的是StatelessWidget，因为需要用到的StatefulWidget基本上已经实现了，我们更多的是对StatelessWidget的封装，是不是很有意思呢，期待你的加入。</p> \n<p>文中的代码都是来自于<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>，这是一个基于Flutter的Github客户端同时支持Android与IOS，支持账户密码与认证登陆。使用dart语言进行开发，项目架构是基于Model/State/ViewModel的MSVM；使用Navigator进行页面的跳转；网络框架使用了dio。项目正在持续更新中，感兴趣的可以关注一下。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://segmentfault.com/img/bVbEdtZ\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>当然如果你想了解Android原生，相信<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>的纯Android版本<a href=\"https://github.com/idisfkj/AwesomeGithub\" rel=\"nofollow noreferrer\">AwesomeGithub</a>是一个不错的选择。</p> \n<h2>下期预告</h2> \n<p><strong>从零开始的Flutter之旅: InheritWidget</strong></p> \n<p>如果你喜欢我的文章模式，或者对我接下来的文章感兴趣，可以点击一下我的头像进行关注，当然您也可以关注我微信公众号：【Android补给站】</p> \n<p>或者扫描下方二维码，与我建立有效的沟通，同时更快更准的收到我的更新推送。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022037789\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p>', 'https://segmentfault.com/img/remote/1460000022037786', '6fbfa4aaad3a43458f21c8acf0038ac5', '14ab12176ade47da95ba97d7151eb1f9,8dfc62f227ae4076888ea4872e03cddd,85ee959b27f74072b13cc763b9bbf77e,63c4e1e7ec204b43a62065a3ced4c2ce,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 16:50:19', '2020-04-16 16:50:19');
INSERT INTO `tb_recommend` VALUES ('dbec1a13a4e6426fa153d0d25042050f', 'PHP分布式事务-两段式提交 2PC', '事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元 {代码...} 分布式事务：分布式事务的参与者、资源管理器、事务管理器等位于不用的节点上，这些不同的节点相互协作共同完成一个具有逻辑...', '<h2>事务(Transaction)是访问并可能更新数据库中各种数据项的一个程序执行单元</h2> \n<pre><code class=\"undefined\">事务应该具有4个属性：****原子性、一致性、隔离性、持续性、原子性（atomicity）\n    一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不。\n原子性（atomicity）\n    一个事务是一个不可分割的工作单位，事务中包括的诸操作要么都做，要么都不做。\n一致性（consistency）\n    事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的。\n隔离性（isolation）\n    一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。\n持久性（durability）\n    持续性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。\n</code></pre> \n<h2>分布式事务：分布式事务的参与者、资源管理器、事务管理器等位于不用的节点上，这些不同的节点相互协作共同完成一个具有逻辑完整性的事务。</h2> \n<pre><code class=\"undefined\">mysql从5.0开始支持XA DataSource。Connector/J 版本要使用5.0版本，5.0以下的不支持。\nXA协议由Tuxedo首先提出的，并交给X/Open组织，作为资源管理器（数据库）与事务管理器的接口标准。目前，Oracle、Informix、DB2和Sybase等各大数据库厂家都提供对XA的支持。XA协议采用两阶段提交方式来管理分布式事务。XA接口提供资源管理器与事务管理器之间进行通信的标准接口。XA协议包括两套函数，以xa_开头的及以ax_开头的。\n</code></pre> \n<pre><code class=\"undefined\">以下的函数使事务管理器可以对资源管理器进行的操作：\nxa_open,xa_close：建立和关闭与资源管理器的连接。\nxa_start,xa_end：开始和结束一个本地事务。\nxa_prepare,xa_commit,xa_rollback：预提交、提交和回滚一个本地事务。\nxa_recover：回滚一个已进行预提交的事务。\nax_开头的函数使资源管理器可以动态地在事务管理器中进行注册，并可以对XID(TRANSACTION IDS)进行操作。\nax_reg,ax_unreg；允许一个资源管理器在一个TMS(TRANSACTION MANAGER SERVER)中动态注册或撤消注册。\n</code></pre> \n<pre><code class=\"go\">MySQL XA分为两类，内部XA与外部XA;内部XA用于同一实例下跨多个引擎的事务，由大家熟悉的Binlog作为协调者;外部XA用于跨多MySQL实例的分 布式事务，需要应用层介入作为协调者(崩溃时的悬挂事务，全局提交还是回滚，需要由应用层决定，对应用层的实现要求较高);\nBinlog作为内部XA的协调者，在binlog中出现的内部xid，在crash recover时，由binlog负责提交。(这是因为，binlog不进行prepare， 只进行commit，因此在binlog中出现的内部xid，一定能够保证其在底层各存储引擎中已经完成prepare)。\nMySQL数据库外部XA可以用在分布式数据库代理层，实现对MySQL数据库的分布式事务支持，例如开源的代理工具：网易的DDB，淘宝的TDDL，B2B的Cobar等等。\n</code></pre> \n<h2>PHP简单2PC示例：</h2> \n<p><strong>数据库</strong></p> \n<pre><code class=\"sql\">order数据库\nCREATE TABLE `order` (\n`id` int(11) unsigned NOT NULL AUTO_INCREMENT,\n`order_no` varchar(32) DEFAULT NULL,\n`goods_id` int(11) DEFAULT NULL,\n`goods_name` varchar(255) DEFAULT NULL,\n`goods_num` int(11) DEFAULT NULL,\n`create_time` int(10) DEFAULT NULL,\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=20 DEFAULT CHARSET=utf8mb4\ngoods数据库\nCREATE TABLE `goods` (\n`id` int(10) unsigned NOT NULL AUTO_INCREMENT,\n`name` varchar(255) DEFAULT NULL,\n`num` int(11) unsigned DEFAULT NULL,\nPRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=0 DEFAULT CHARSET=utf8mb4\n</code></pre> \n<p><strong>PHP代码</strong></p> \n<pre><code class=\"php\">/**\n* 分布式事务测试\n*/\n//order\n$dns_order = new PDO(\'mysql:host=10.211.55.100;dbname=order\', \'orders\', \'123456aA!\');\n//goods\n$dns_goods = new PDO(\'mysql:host=10.211.55.101;dbname=goods\', \'goods\', \'123456aA!\');\nvar_dump($dns_order);\necho \'\n\';\nvar_dump($dns_goods);\necho \'\n\';\n$_grid = uniqid(\"\");\n$_o = false;\n$_g = false;\n//1.准备事务\n$dns_order-&gt;query(\'XA START \\\'\'.$_grid.\'\\\'\');\n$dns_goods-&gt;query(\'XA START \\\'\'.$_grid.\'\\\'\');\ntry {\n//2.更新order表\n$sql = \'INSERT INTO `order` (order_no, goods_id, goods_name, goods_num, create_time) VALUES (\\\'\'.time().\'\\\', 1, \\\'test\\\', 1, \\\'\'.time().\'\\\')\';\n$resultOrder = $dns_order-&gt;query($sql);\nif ($resultOrder === false) {\necho \'order更新失败\';\n} else {\nif ($resultOrder-&gt;rowCount() &gt; 0) {\n//4.成功通知准备提交\nvar_dump($dns_order-&gt;query(\'XA END \\\'\'.$_grid.\'\\\'\'));\nvar_dump($dns_order-&gt;query(\'XA PREPARE \\\'\'.$_grid.\'\\\'\'));\nvar_dump($resultOrder-&gt;rowCount());\n$_o = true;\n}\n}\nif($_o == true) {\necho \'\n\';\n//3.更新goods表\n$sql = \"UPDATE `goods` SET `num` = `num` - 1 WHERE `id` = 2\";\n$resultGoods = $dns_goods-&gt;query($sql);\nif ($resultGoods === false) {\necho \'goods更新失败\';\n} else {\nif ($resultGoods-&gt;rowCount() &gt; 0) {\n//4.成功通知准备提交\nvar_dump($dns_goods-&gt;query(\'XA END \\\'\'.$_grid.\'\\\'\'));\nvar_dump($dns_goods-&gt;query(\'XA PREPARE \\\'\'.$_grid.\'\\\'\'));\nvar_dump($resultGoods-&gt;rowCount());\n$_g = true;\n} else {\necho \'goods未更新记录\';\n}\n}\n}\necho \'\n\'.\'-----状态------\';\nvar_dump($_grid);\nvar_dump($_o);\nvar_dump($_g);\necho \'-----状态------\';\nif ($_o == true &amp;&amp; $_g == true) {\n//5.提交SQL\nvar_dump($dns_order-&gt;query(\'XA COMMIT \\\'\'.$_grid.\'\\\'\'));\nvar_dump($dns_goods-&gt;query(\'XA COMMIT \\\'\'.$_grid.\'\\\'\'));\necho \'\n\'.\'成功!!!!!!\';\n} else {\n//4.失败回滚\necho \'\n\'.\'失败回滚\';\n$dns_order-&gt;query(\'XA ROLLBACK \\\'\'.$_grid.\'\\\'\');\n$dns_goods-&gt;query(\'XA ROLLBACK \\\'\'.$_grid.\'\\\'\');\n}\n} catch (Exception $e) {\n//4.失败回滚\n$dns_order-&gt;query(\'XA ROLLBACK \\\'\'.$_grid.\'\\\'\');\n$dns_goods-&gt;query(\'XA ROLLBACK \\\'\'.$_grid.\'\\\'\');\nthrow new Exception(\'执行失败\');\n}\n</code></pre>', null, '1894b118d35d44cb8fe8009529c4154b', '1a77ff8ac4c54e58b5e6b22210cff64f,84e1fca09c4340be87d5c1ef4601b026', '0', '3', '1', '2020-04-16 16:48:54', '2020-04-16 16:48:54');
INSERT INTO `tb_recommend` VALUES ('dca1bcbfd4254e45a51d24533b5cee77', '技术路线：前端开发已进入深水区', '著作权归作者所有。商业转载请联系 Scott 获得授权，非商业转载请注明出处[务必保留全文，勿做删减]。 对于普通人，最大潜水深度一般不超过水下 30 米，极限为水下 40 米，超过 40 米就进入到技术潜水的范畴，就...', '<blockquote> \n <p>著作权归作者所有。商业转载请联系 Scott 获得授权，非商业转载请注明出处[务必保留全文，勿做删减]。</p> \n <p>对于普通人，最大潜水深度一般不超过水下 30 米，极限为水下 40 米，超过 40 米就进入到技术潜水的范畴，就会面临各种复杂的危险状况，需要各种装备的集成和系统化的训练才能保证一定的安全性。</p> \n <ul> \n  <li>为什么技术晋升越来越难了</li> \n  <li>为什么高薪资的岗位 Offer 越来越难拿了</li> \n  <li>为什么公司总是说做技术也要懂业务</li> \n  <li>为什么很多团队主管总把价值挂在嘴边</li> \n  <li>为什么 What/How/Why 必须要搞清楚</li> \n  <li>为什么单纯技术硬很难向前突破了</li> \n  <li>为什么前端开发往上走比之前更难了</li> \n  <li>为什么我想发力却总是懒于动手</li> \n  <li>为什么我趴键盘上看不到明天看不到希望</li> \n  <li>...</li> \n </ul> \n</blockquote> \n<p>红利已逝，今非昔比。对比 2010 年，整个前端生态已经翻新了好几遍，直到近几年的 Node BFF、IDE Cloud，抑或是客户端 AI，还是 Serverless 的建设，前端想要深度参与的话，单纯依靠原来的 HTML/CSS/JS 三件套技能也远远不够了，再抛开技术，整个互联网创业生态也重构了好几遍，生意的本质没变，但做生意的理念和方法论以及辅助的工具都发生了巨大的变化。</p> \n<p>新的商业环境下就有新的公司组织架构形态，以及新的产品研发流程和合作模式，这些也对今日的前端开发工程师提出更新更高的要求，无论是技术层面还是意识层面，如今的前端开发已经进入深水区，要在深水区中生存以及捕捞猎物，就需要有深水区所需要的系统化的技能体系以及配套的软硬件能力，以及从浅水区进往深水区所需要的进阶方法论，本文试图向大家传达这样一种观点，希望带给大家一些启示，无论是新人老人都要居安思危，提前做出储备，以应对新的职场挑战，更灵活的延展自己的职业路线。</p> \n<p>本文是小菜前端 TL 内训课程中， 《上手技术管理的初级套路》 这一节里面，关于前端已迎来深水区这个观点的展开陈述，文中会截取几页 PPT 来辅助叙述帮大家理解:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1562663531223-c21f1167-d054-4be1-bbd1-676ccadd58e0.png#align=left&amp;display=inline&amp;height=425&amp;name=image.png&amp;originHeight=730&amp;originWidth=1280&amp;size=485729&amp;status=done&amp;width=746\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p><a></a></p> \n<h2>浅水区需要哪些技能</h2> \n<p>站在 2019 年，通常一个工程师履历中体现的是跳槽历史、参与项目的难度、React/Vue/Angular 等框架底层熟悉度、编程方法论的掌握程度以及职位的变迁等，而在工作中的确与编程强相关的技能有很多（该图是我多年前整理修改而来，有同学知道出处可以告知我）：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1562638872275-f21ac36b-593b-4822-b342-0743e73500b0.png#align=left&amp;display=inline&amp;height=469&amp;name=image.png&amp;originHeight=1032&amp;originWidth=1828&amp;size=619426&amp;status=done&amp;width=830.9090728996217#align=left&amp;display=inline&amp;height=1032&amp;originHeight=1032&amp;originWidth=1828&amp;status=done&amp;style=none&amp;width=1828\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>抛开 BATMD 这种大体量的公司，放在市面上任意一个 50 人规模以下技术团队的公司里面，大概率掌握最好的是 IDE/框架/API 这一层，至于代码实现的足够优雅很难保障，更不要提程序设计的娴熟套路、项目背后沉淀的方法论等等，单纯在这张图上打怪升级花个 5 年 10 年丝毫不为怪，而对于前端工程师，这张图的技能点花个 7 年 10 年全部打满打透，此时也差不多三十而立了，而立之年也就是摸到了技术路线的第一个天花板，这个天花板就是技术专家，即便如此，用 10 年时间碰到这个天花板的人依然是极少数，大部分人需要花费更久甚至一直到不了这个高度，而所有这张图上我把它定义成浅水区技能，是肉眼可见的，是可以量化的，是最容易产生共鸣而形成学习动力的，但是放在如今的新商业环境中就显得很单薄了。</p> \n<p>为什么单薄呢？我们把图上的能力和知识体系打碎重组，提炼后就是三个关键字：架构、编程、运维，一个是意识和逻辑层面，一个是过程实现层面，一个是环境保障层面，这些能力依然是落纯技术体系内，并没有跟外部的商业和职场环境发生多少交集。</p> \n<p><a></a></p> \n<h2>深水区需要哪些技能</h2> \n<p>在深水区，脑海中如果只有编程二字是不够的，就算带一些沟通合作也还是远远不够，但是不是一定需要深水区技能才能把工作做好，答案也并不是，深水区技能是更长期性更深刻的，从长期看具备这些特质可以更快更好的跨过技术专家的这个天花板，走到更高的一个 Level，但不具备这些特质也未必会严重影响浅水区的表现。不过当更多同龄人具备深水区能力的时候，只具备浅水区能力的你慢慢就变成了裸泳，而更多更多的新人跳入到浅水区和你一起竞争，此时你跟深水区已经是隔绝的两个世界，看到的和收获也截然不同了。</p> \n<p>我把深水区的技能，更口语化的总结为： 技术创新、流程优化、团队合作、影响大盘、驱动业务、商业决策和团队管理，如下图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1562639725095-da5f6ec7-cb39-4013-b52c-c9166bfd4147.png#align=left&amp;display=inline&amp;height=469&amp;name=image.png&amp;originHeight=1032&amp;originWidth=1832&amp;size=653133&amp;status=done&amp;width=832.7272546783955#align=left&amp;display=inline&amp;height=1032&amp;originHeight=1032&amp;originWidth=1832&amp;status=done&amp;style=none&amp;width=1832\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>每一个能力的解释我也标注在了图上，再通俗的解释一下：</p> \n<ul> \n <li>技术创新，从技术面、业务和产品面出发，以技术作为突破点，取得技术上的突破，比如兼容多端的框架研发、客户端浅层次 AI 的实现</li> \n <li>流程优化，更多是从产品研发流程上发力，借助向上向下的管理，推动流程变得更高效，比如前后端的接口联调方式、比如产品 PRD 到测试流程的介入更敏捷的迭代方式，可能是规范可能是工具层面</li> \n <li>团队合作，这个最好理解也最难做好，同样是从管理和业务的视角切过去，促成团队成员之间有更高层面的共识达成，有更信任的纽带关系，以及有更匹配的使命目标驱动，比如与业务同学一起出差拜访客户，并在过程中发现更多共鸣点，从而驱动彼此更快调整协作方式，最终为客户解决问题</li> \n <li>影响大盘，所谓大盘就是公司或者部门的业务大盘，这个一定需要对业务的前景有较为客观深刻的认识，并且形成自己的独立判断和决策，去发现业务缺失哪些核心的因素点，并去补全这个遗漏甚至是发现一个机会点，去发掘实现一个新的业务可能性，比如公司的内容生产是一个核心业务，去发现它未来规模化生产会遇到人力瓶颈，有没有可能通过产品化背后的技术能力提供生产力，让业务看到一个新的可能性从而修正整个内容的规划方向</li> \n <li>驱动业务，与影响大盘不同，驱动业务更多是有实质性的推进而不仅仅是想法，比如通过配套的埋点监控工具，来捕捉用户一些有意义的行为，从而不断从中发现问题并推动业务去优化解决，或者发现有价值的方向，从而开放这些价值点背后的技术能力给到业务和产品，赋能他们更好的迭代业务流程</li> \n <li>商业决策，这一点更多是从数据价值层面，比如可视化很多时候是从前端来主导研发和推进，从各种展现模型中为业务提供更好的决策视角，但在它之前一定是对业务和产品有足够深的理解才会形成有效的决策路径和模型</li> \n <li>团队管理，这个则是一个很大的话题了，站在组织的视角把团队从弱带到强，从小带到大，从层次不齐带到规矩有章法能冲能创，成为公司具备核心影响力的团队</li> \n</ul> \n<p>经过我们再次简单分析后，可以发现这些技能背后，是四个核心能力，分别是：技术、产品、业务和管理能力，把它们再拆到每个能力上，按照影响的权重，是这样的对应关系：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1562640905313-dfefb33e-e46a-4241-b729-caa33fddbfd0.png#align=left&amp;display=inline&amp;height=461&amp;name=image.png&amp;originHeight=1014&amp;originWidth=1864&amp;size=808842&amp;status=done&amp;width=847.2727089085859#align=left&amp;display=inline&amp;height=1014&amp;originHeight=1014&amp;originWidth=1864&amp;status=done&amp;width=1864\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>大部分仅仅是靠技术都不可能去推进了，甚至技术都未必是它的重要影响权重，比如团队合作、影响大盘、商业决策等，统统这些能力的集合就是一个足够资深的工程师，他能在深水区存活，并且靠此打出一片天所需要的软实力了。</p> \n<p><a></a></p> \n<h2>怎么修炼深水区能力</h2> \n<p>聊清楚深水区对于工程师的 What 和 Why 以后，我们来聊一聊 How。开始之前我们必须认识到这些能力不是一蹴而就的，无论是你已经具备了部分能力，还是丝毫不具备，我们都要认识到它的习得需要一个过程，这个过程通常就分为这三个阶段：初级练习阶段、渐变娴熟的阶段、质变内化为能力的阶段，在初级练习阶段没有足够的沉淀前，直接跳往后两个阶段都是不切实际的。</p> \n<p>首先是初级阶段怎么练习，我把 PDCA 修改后形成这一个做事套路，大家可以参考：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1562641870792-9cc3eb77-f373-4688-8491-d4e78b729c3c.png#align=left&amp;display=inline&amp;height=294&amp;name=image.png&amp;originHeight=646&amp;originWidth=1768&amp;size=206707&amp;status=done&amp;width=803.636346218015#align=left&amp;display=inline&amp;height=646&amp;originHeight=646&amp;originWidth=1768&amp;status=done&amp;style=none&amp;width=1768\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>工作中的每一项具体的任务，都可以按照这个路子走一遍，一开始的时候会不适应，甚至有点僵硬的硬套模仿，多来几次慢慢就会成为一种习惯，举个例子：</p> \n<p>团队里有很多表单开发的场景，大家的效率都很低，开发很痛苦，我看到这个问题后，就想要做一个复杂表单组件，我首先就是研究各种市面方案，研究公司的业务场景，研究已有的端产品上业务表达的交互表达方式，团队有没有人研究过表单的方案，我去收集相关的信息，并且我也弄明白为什么要开发这个表单组件，它能为业务带来实际的价值么，这个表单应该承载什么核心功能呢，做完能推动落地么，我本人能推得动么.... 这个环节就是形成判断决策的时候，也就是捉摸。</p> \n<p>捉摸明白后，我开始制定目标，这个要符合 SMART 法则，尽量的可量化，比如：我要用 2 周时间开发一个表单组件，这个组件要可以被兼容替换到 AB 两个业务的 DEF 三个产品的 10 个页面的交互中，然后开始制定具体的开发计划，哪个时间点找老板征得同意，开始定出分几个版本来迭代，每个版本的周期是几天，每个版本完成的具体功能是什么，在这个过程中需要哪些资源，比如架构组同学的支持，业务组同学的反馈，交互组同学的设计配合，产品经理同学的理解和认同，然后把整个开发过程以可被感知的方式量化出来，透明化出来，这就是规划的阶段。</p> \n<p>规划后开始进行技术方案的设计，模块的设计，三方库等等直到编码完成，开始推动组件在匹配的业务线和产品中使用，推动并帮助其他同学使用该组件，跟踪组件使用的效果并及时的修理 Bug 优化交互等，这个就是执行阶段。</p> \n<p>在业务线用了一段时间后，组织一个小小复盘，针对实际应用中的问题做个收集整理，并且把过程中自己的不足也做一个检视，比如经常忘记跟老板同步进度，经常疏忽其他同学的吐槽建议等等，另外根据复盘和反馈来确保这个组件的确有提效的价值。</p> \n<p>最后是沉淀开发组件的方法论，相应的技术文档（这个往往在开发过程中就沉淀下来了），以及组件化立项开发的套路，自己个人能力有什么成长，这种能力如何快速复制给其他新手同学...也就是沉淀 Share 的阶段。</p> \n<p>实际工作中的问题，往往比一个组件要复杂的多的多，这就需要我们更加谨慎的对待每个阶段，把它们灵活应用并保障每次都比上一次拿到更好的结果，个人每次都比上一次方法论用的更纯熟。</p> \n<p>上面抛砖引玉介绍了单纯实现层面可以训练的方法论，这种方法论同样适用了任何能力的练习，但方法论毕竟是方法论，真正决定它们训练结果其实还有一个前置条件，就是你的做事驱动力，也就是能力和意愿的情况。</p> \n<p><a></a></p> \n<h2>能力意愿是前置条件</h2> \n<p>我们先讲了方法论，让大家更明确的感受到一些可执行的套路，然后再来看能力和意愿的重要性，所谓能力就是你判定问题和分析解决问题的能力，所谓意愿就是你面对任何一个突入飞来的难题或者任务，内心是抵触、认同还是兴奋这样的一种情绪。</p> \n<p>首先，我们分析下一个员工的做事动机，通常有这几类：</p> \n<ul> \n <li>不知道不关心，对这个任务不清楚 what/how/why，也不关心它做不做的价值有多大</li> \n <li>这么做是因为必须这么做，依然不理解它的价值，但知道这样做是因为我是前端工程师，这是我分内事</li> \n <li>不这么做会有罪疚感，老板对我有信任，我如果不做好会觉得不好意思，心理过不去</li> \n <li>这么做对我很重要，我认同这件事交给我做的原因和意义，这件事对我的成长及未来晋升都有意义，我很重视</li> \n <li>喜欢并专注去做，这件事是我一直以来期待的机会，我很喜欢很想去实现它，我很理解它做好的意义</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1562662079208-68c652dd-979a-4600-9f87-5b342c9caac9.png#align=left&amp;display=inline&amp;height=503&amp;name=image.png&amp;originHeight=1006&amp;originWidth=1864&amp;size=465804&amp;status=done&amp;width=932\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>所以一个同学有可能做不同的项目会有不同的动机，即便做同一个项目的不同阶段也会有不同的动机，这是一个完全主观的事情，但是它很重要，因为不同的动机会带来三个结果：老板及周围同事通过你做这件事所看出的你的做事态度，这件事你做完达成的结果，以及你由此而获得的成就感或者成长，当然所有的团队都希望你无论喜欢与否，都至少是理解并执行这个任务：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1562662354056-6f1bdd7e-4657-4ac5-8045-241a877dc9ec.png#align=left&amp;display=inline&amp;height=493&amp;name=image.png&amp;originHeight=986&amp;originWidth=1836&amp;size=563606&amp;status=done&amp;style=none&amp;width=918\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>最怕的是理解不执行和不理解和不执行，最终反映在能力和意愿上，在一个团队的分布中，你就有了不同的象限，是能力好意愿度高的，还是能力高意愿度低的，只有意愿高能力高的人才能获得最大程度的授权和自由空间，反之不仅获得授权会缩水，甚至必须听从具体的拆解后的任务去做执行的角色，所以如何让自己无论能力高低，先让自己具备一个高意愿度都是一个明智的选项。</p> \n<p>那么存不存在一些事情是无意义的，做了也是白做呢，一定存在，现在这样高节奏的创业环境中，试错始终是一种常态，做一件事而拿不到结果也是常有的事，但是不是因此就否定了组织的动机，从而把自己束缚的越来越紧，正面看过去好像自己不再亏什么了，反过来看自己却失去了进入深水区而该有的历练，这个历练中一定有汗水也有委屈。</p> \n<p><a></a></p> \n<h2>面对深水压力不需紧张</h2> \n<p>其实何止前端开发，整个技术行业都已步入深水区，只是前端工程师的感知来的晚一些而已。只要把眼光投向深水区，问题就会一个接一个的浮上来，当越来越多问题浮起来的时候，就是你慢慢沉向深水区的时候，这时候不需要太过紧张，此时的发生正在见证者你的成长，欢迎大家文后提问更多问题，我们可以再换一期来针对性讨论，本文主要帮大家引导到深水区已然到来，在它之上需要储备技能的必要性和重要性，目的就达到了。</p> \n<blockquote>\n Scott 近两年无论是面试还是线下线上的技术分享，遇到许许多多前端同学，由于团队原因，个人原因，职业成长，技术方向，甚至家庭等等原因，在理想国与现实之间，在放弃与坚守之间，摇摆不停，心酸硬扛，大家可以找我聊聊南聊聊北，对工程师的宿命有更多的了解，有更多的看见与听见，Scott 微信： codingdream，也可以来\n <a href=\"https://www.yuque.com/iscott\" rel=\"nofollow noreferrer\">关注 Scott 跟进我的动态</a>。\n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882754189-781488ce-b345-45cf-a3b7-cb5309e9caa6.png#align=left&amp;display=inline&amp;height=399&amp;name=2.png&amp;originHeight=600&amp;originWidth=600&amp;size=158647&amp;status=done&amp;style=none&amp;width=399\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"2.png\" title=\"2.png\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"https://cdn.nlark.com/yuque/0/2019/png/87555/1575882773713-309efa88-e1fc-481f-865b-3c0cb0d3ec43.png#align=left&amp;display=inline&amp;height=398&amp;name=1.png&amp;originHeight=600&amp;originWidth=600&amp;size=134434&amp;status=done&amp;style=none&amp;width=398\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"1.png\" title=\"1.png\"></span><br></p>', 'https://cdn.nlark.com/yuque/0/2019/png/87555/1562663531223-c21f1167-d054-4be1-bbd1-676ccadd58e0.png#align=left&amp;display=inline&amp;height=425&amp;name=image.png&amp;originHeight=730&amp;originWidth=1280&amp;size=485729&amp;status=done&amp;width=746', '1894b118d35d44cb8fe8009529c4154b', '63c4e1e7ec204b43a62065a3ced4c2ce,152de5fe7cc14dedb342ba8dd2800d42,3450238252414287a0b3fbac4a4e198b', '0', '3', '1', '2020-04-16 16:48:04', '2020-04-16 16:48:04');
INSERT INTO `tb_recommend` VALUES ('dcdb8ed0bc454e2c9483e3f871163b7a', 'iOS 滑动关后台会影响续航是真的，但并不会损伤你的电池', '对此事，苹果也在官方渠道发布声明表示“确实如此”。并表示 iPhone 电池寿命普遍偏短的原因，就是用户习惯性的手动关闭应用程序，这不仅会缩短电池的使用寿命，也会导致设备的速度变慢。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEkJ6\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>前不久，#苹果建议不要滑动关闭后台程序#这个话题上了微博的热搜。</p> \n<p>这个话题的源头，是因为英国的《太阳报》的一篇报道中写道“如果您经常关闭应用程序，则 iPhone 会变慢并损耗电池。”</p> \n<p>对此事，苹果也在官方渠道发布声明表示“确实如此”。并表示 iPhone 电池寿命普遍偏短的原因，就是用户习惯性的手动关闭应用程序，这不仅会缩短电池的使用寿命，也会导致设备的速度变慢。</p> \n<p>在此之前，我相信大部分人都和我一样，认为后台的应用程序会占用 CPU、消耗电量，因此会经常性的手动关闭很多应用程序。</p> \n<p>但苹果为什么这么说呢？原理是啥？电池寿命真的是被我们一下一下划没的么？</p> \n<h2>后台的应用程序其实已经被“冻结”</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEkJ9\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>这个观念差异的背后，其实是来源于用户和官方的认知差异。</p> \n<p>事实上早在 2016 年，时任苹果软件高级副总裁的 Craig Federighi 就针对用户的邮件进行了回复。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEkKa\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>但这个回复在当时并未被大部分人所了解。</p> \n<p>而事实上，iOS 为了让设备减少不必要的系统资源开销，并保持系统的流畅，它的后台更应该叫做「多任务切换界面」。而这得益于 iOS 特殊的「墓碑机制」。</p> \n<blockquote> \n <strong>名词解析：墓碑机制</strong>\n <p>简单来说，墓碑机制就是当 App 进入后台前将以某种形式持久化，然后释放其正在使用的资源（包括内存、CPU等），等待 App 再次被唤醒时，将再将这个保存的状态恢复出来，此时应用跟没有被杀死继续运行了一样。</p> \n <p>实际上 iOS 并不是严格意义上的墓碑机制，其在应用进入后台时可以向系统申请一定时间的后台运行时间（一般不超过10分钟），之后才会被完全挂起。</p> \n</blockquote> \n<p>根据这个机制我们可以知道，我们之前滑动关闭的并非是应用程序，而是类似于应用程序的快捷打开方式。</p> \n<p>而如果想真正的关闭一个应用程序，需要将这个应用从 RAM 中移除（比如重启手机），这时再次启动程序时系统需要重新调动资源，与冻结状态相比，所占用的 CPU 和消耗的电量更高，因此苹果方面建议除非应用程序无响应，否则不要滑动强制退出。</p> \n<p>当然，不排除一些应用程序会有更高的“权限”，在后台时也会占用系统资源，我们可以在「设置」中查看是否有哪些应用在滥用权限。</p> \n<h2>滑动关闭后台应用影响电池寿命？</h2> \n<p>先放结论：并不会。这是以讹传讹。</p> \n<p>我们能在很多媒体报道中看到“滑动关闭后台应用不仅没用，还会影响电池寿命”，这其实是因为翻译不精准导致的错误传言。</p> \n<p>《太阳报》的原文标题是《QUIT IT！Your iPhone gets SLOWER and loses battery life if you always swipe apps closed》，这里面提到的「battery life」被很多人翻译成了「电池寿命」，但实际上这个词一般表示电池的续航时间，英文语境中电池寿命一般会用「battery health」来表示。</p> \n<p>正如我们上文所示，滑动关闭后台应用后，重新启动将会消耗更多的 CPU 和电池电量，因此也会相应的降低电池的续航，和电池的使用寿命并没有关系。</p> \n<p>理论上影响电池寿命的因素目前有四个：</p> \n<ul> \n <li>充/放电速度</li> \n <li>电池温度</li> \n <li>放电深度（DOD）</li> \n <li>电池循环次数</li> \n</ul> \n<p>很多人在买卖二手笔记本的时候都会关注的参数就是「电池循环次数」，因为这个是影响电池寿命和健康程度的关键因素之一。</p> \n<p>如果想要通过健康的手机使用习惯来延长手机的电池寿命，这里有一个建议就是关闭某些应用程序的系统通知（也就是常说的弹窗广告）。</p> \n<h2>安卓手机可以滑动杀后台么？</h2> \n<p>iOS 系统不建议频繁滑动关闭后台的应用程序，那么 Android 系统可以么？</p> \n<p>答案是：可以。</p> \n<p>背后的原因是 iOS 与 Android 的后台机制并不相同。文章开头我们介绍了 iOS 系统的「墓碑机制」，而 Andriod 系统并没有采用这一机制，所以大部分 Android 系统的应用程序切换到后台后，仍然在占用着 CPU。而滑动关闭后台的程序也就真的是把程序给彻底关闭了。</p> \n<p>这也是为什么Andriod 系统的手机容易变卡、发烫。就是因为 Android 的运存总是很大，不过从安卓 5.0 之后，因为各大厂商对系统做的优化和硬件的迭代发展，这种情况现在也是越来越少了。</p> \n<hr> \n<p>总结一下我们今天的文章，大致有以下几个观点：</p> \n<ol> \n <li>对于广大的iPhone用户来说，还是乖乖按照苹果官方的说法操作，没事就别随便做出滑动退出APP这种“骗自己”的行为了；</li> \n <li>滑动关闭后台程序不会影响电池寿命；</li> \n <li>Andriod 系统手机因为后台机制与 iOS 系统不同，因此滑动关闭后台程序确实可以释放 CPU。</li> \n</ol> \n<p>你觉得这两种系统的机制，哪个更好一些？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCJ1M\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbEkJ6', '1c5851dc916d4e70a60f0c957f548876', '9276a7fb738f4d38aec0e4c23347fba7,85ee959b27f74072b13cc763b9bbf77e,8dfc62f227ae4076888ea4872e03cddd', '0', '3', '1', '2020-04-16 16:50:20', '2020-04-16 16:50:20');
INSERT INTO `tb_recommend` VALUES ('e41cb1b902aa43d69b1f4d5508f4609d', '限时0元免费领!!! 8门程序员进阶必修课、机械键盘等多重好礼等你来拿!', '2020开始，一场疫情突然袭来。 企业延迟开工、学校延迟开学、取消考试及比赛等事件打乱了每个人的计划。 很多人待在家浑浑噩噩，但他们不知道有一部分人却在这个时间段疯狂充实自己！ ​ 国内疫情已经基本控制住，...', '<p><strong>2020开始，一场疫情突然袭来。</strong></p> \n<p><strong>企业延迟开工、学校延迟开学、取消考试及比赛等事件打乱了每个人的计划。</strong></p> \n<p><strong>很多人待在家浑浑噩噩，但他们不知道有一部分人却在这个时间段疯狂充实自己！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365419\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span>​</p> \n<p><strong>国内疫情已经基本控制住，各地都在热火朝天的忙复工。你，在干嘛呢？</strong></p> \n<p><strong>疫情让求职市场竞争更加激烈，学习技能和掌握知识才是这个时候最应该做的！</strong></p> \n<p><strong>你是否后悔没有抓住这个宝贵时间好好充实自己？不用担心！思否编程来帮你！</strong></p> \n<p><strong>思否编程提供了8门程序员进阶必修课，掌握它们不仅能充实简历拿到好Offer，学完Python等语言后更能让你从简单重复的工作中脱离出来，感受到自动化办公的愉悦。当然提高薪资也会变成自然而然的事情。</strong></p> \n<p><strong>思否编程为了鼓励大家战胜疫情，精心选择了8门程序员必修课程免费提供给大家之外。还给前来学习的同学提供机械键盘、32G U盘等精美好礼。</strong></p> \n<p><strong>还等什么马上扫描下方海报中的二维码来领取吧！</strong><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF0EJ\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"WechatIMG104.jpeg\" title=\"WechatIMG104.jpeg\"></span></p> \n<p><strong>扫描海报二维码 奖品和课程免费领↑↑↑</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365418\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>本次战疫活动的福利解读！</strong></p> \n<h2>福利一：精美礼品轻松拿</h2> \n<p><strong>本次活动给大家带来了两个精美礼品。</strong></p> \n<p><strong>马上来拿价值300元的罗技机械键盘（限量，按排名）</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365417\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>马上来拿价值69元的思否定制U盘（限量，按排名）</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365416\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>福利二：8大进阶课程免费看</h2> \n<h5>跟我学用 Serverless 开发接龙小程序</h5> \n<p><strong>内容介绍：</strong></p> \n<ol> \n <li>Serverless 简介</li> \n <li>小程序简介</li> \n <li>开发接龙小程序</li> \n</ol> \n<p><strong>讲师：</strong>翟路佳 花名“肉山”，全栈工程师，就职于 OpenResty Inc.，关注前端里各种垂直深耕的领域</p> \n<h5>走进互联网应用—从单体应用到微服务</h5> \n<p><strong>内容介绍：</strong>绍目前互联网应用开发的主流框架，包括：Spring、SpringMVC、MyBatis、SpringBoot 以及 SpringCloud，讲解技术更新迭代的过程，以及大型项目的架构设计思想。 <br><strong>讲师：</strong>恒哥 资深Java高级工程师</p> \n<h5>Node.js 代码调试</h5> \n<p><strong>内容介绍：</strong>直播中会对 Node.js 代码调试进行简单的介绍与 ESLint 静态代码检查的展示，并将在直播当中进行打印调试与交互调试的讲解教学。 <br><strong>讲师：</strong>王顶 河北经贸大学讲师、企业研究生导师，微软认证工程师 MCSE、MCP、MCT</p> \n<h5>webpack性能优化-代码分割</h5> \n<p><strong>内容介绍：</strong>详细讲解webpack做代码分割的各种姿势 <br><strong>讲师：</strong>starkwang 资深前端工程师</p> \n<h5>Python最佳实践</h5> \n<p><strong>内容介绍：</strong>本次课程分享如何把Python写得优雅，并且达到工程上的最佳实践。 <br><strong>讲师：</strong>凯威 资深工程师</p> \n<h5>迎接Vue 3.0</h5> \n<p><strong>内容介绍：</strong></p> \n<ul> \n <li>Vue 3.0 的新变化</li> \n <li>开发团队的设计思路（为什么会有这些变化）</li> \n <li>我们应该怎么准备</li> \n</ul> \n<p><strong>讲师：</strong>翟路佳 全栈工程师</p> \n<h5>网络安全之 Kali 渗透入门实战</h5> \n<p><strong>内容介绍：</strong></p> \n<ul> \n <li>Kali 系统的安装与汉化</li> \n <li>使用 nmap 对目标安全扫描</li> \n <li>使用 MSF 对 Windows 渗透</li> \n <li>使用 ettercap 中间人欺骗</li> \n</ul> \n<p><strong>讲师：</strong>汤青松 PHP 高级工程师</p> \n<h5>玩转 CI/CD — 打造高效可靠的软件开发流程</h5> \n<p><strong>内容介绍：</strong></p> \n<ul> \n <li>利用 CI/CD 可以打造高效的开发流程。</li> \n <li>CI/CD 打造的全自动流程让你的软件系统无比可靠。</li> \n <li>CI/CD 本质上是一套方法论，可以用开源系统也可以用脚本实现，框架层面可以说没有难度。这个方法论鼓励你从繁琐的劳动中解放出来，把精力用在系统设计，写优雅的代码和接口，写测试代码，把一切能自动化的操作都交给机器。</li> \n</ul> \n<p><strong>讲师：</strong>凯威 资深工程师 </p> \n<p><strong>强大的师资力量</strong> </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365420\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365421\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>用户的评价</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365422\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365423\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365425\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365424\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>免费领取总计花费上千小时磨练，价格高达上千元的课程。帮助热爱学习的同学高效学习，快速转行，挑战高薪。</strong></p> \n<p><strong>重要提示：</strong></p> \n<blockquote>\n 活动时间：课程限量1000份，限量领完为止\n <p>奖品公告：中奖名单可在排行榜中自行查看 </p> \n <p>如有问题请扫描下方二维码↓↓↓<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbFYk8\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"思否小姐姐.png\" title=\"思否小姐姐.png\"></span></p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365426\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>好啦，看到这里估计大家已经迫不及待去领取了，原价上千元的课程，今天大家可以0元领取，不过最后提醒一下大家只有1000个名额哦！</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022365427\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><strong>扫描上方二维码↑↑↑马上领取好课与精美礼品</strong></p>', 'https://segmentfault.com/img/remote/1460000022365419', 'c56940aa8b004dab84568e86900b2ee6', '57f41641447a40eb9bde76ded2a16296,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 16:47:09', '2020-04-16 16:47:09');
INSERT INTO `tb_recommend` VALUES ('e702607368da40c1b48023451028257a', 'TiDB 在马上消费金融核心账务系统归档及跑批业务下的实践', '作者介绍：康文权，马上消费金融总账高级研发工程师。 李银龙，原腾讯云运维工程师，马上消费金融容器云 TiDB 负责人，西南区 TUG Leader。', '<blockquote> \n <strong>作者介绍：</strong>\n <p>康文权，马上消费金融总账高级研发工程师。</p> \n <p>李银龙，原腾讯云运维工程师，马上消费金融容器云 TiDB 负责人，西南区 TUG Leader。</p> \n</blockquote> \n<h2>背景介绍</h2> \n<p>马上消费金融于 2015 年 6 月营业，截止到 2020 年 1 月，历经 4 年多风雨，总注册用户数 8000 万，活跃用户数 2500 万，累计放贷 2900 多亿元人民币。公司于 2018 年 6 月增资到 40 亿，成为内资第一大的消费金融公司。</p> \n<p>在业务爆发式增长的 4 年多里，马上消费金融的数据库经历了从单表数十 GB 到数百 GB 的过程，单表的数据量正在往 TB 级别演进。基于数据量的升级变迁，我们的数据库也经历了 2 次架构迭代，并在探索</p> \n<p>第三代数据库架构：</p> \n<ul> \n <li> <strong>第一代数据库架构</strong>——核心系统以 Oracle 为主，MySQL 为辅的时代。</li> \n <li> <strong>第一代数据库架构</strong>——核心系统以 Oracle 为主，MySQL 为辅的时代。</li> \n <li> <strong>第三代数据库架构</strong>——核心系统以 MySQL 结合 NewSQL 为主，NewSQL、MySQL、NoSQL 并存的时代。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733791\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>马上金融第二代数据库架构痛点</h2> \n<h3>海量数据 OLTP 场景需求痛点</h3> \n<p>截止目前账务系统的核心表累计数据量已达到单表 15 亿行以上，还在高速增长中。监管要求金融行业历史数据至少保留 5 年以上。这给数据库系统带来了巨大挑战：</p> \n<ol> \n <li> <strong>海量的历史交易与账务数据堆积在 MySQL 数据库中，使数据库臃肿不堪，维护困难</strong>（在线 DDL 变更、数据迁移、磁盘容量瓶颈、磁盘 IO 瓶颈等）。</li> \n <li>用户对历史交易订单的查询（OLTP 场景）是必备功能，这些海量的历史数据会根据用户需求通过 Web 页面、APP 终端等渠道进行实时查询（内部、外部用户）。<strong>此场景决定了不能通过传统的离线大数据方案来满足需求。需要一种偏向于前台、中台的数据治理方案</strong>。</li> \n</ol> \n<h3>传统分库分表解决方案痛点</h3> \n<p>根据马上金融的经验，MySQL 单表在 5000 万行以内时，性能较好，单表超过 5000万行后，数据库性能、可维护性都会极剧下降。当我们的核心账务系统数据库单表超过 100GB 后（截止 2018 年 10 月该表累计已达到 528GB），经技术架构团队、业务需求团队联合调研后，选择了 sharding-jdbc 作为分库分表的技术方案。</p> \n<p><strong>此方案的优点非常明显，列举如下：</strong></p> \n<ol> \n <li>将大表拆分成小表，单表数据量控制在 5000 万行以内，使 MySQL 性能稳定可控。</li> \n <li>将单张大表拆分成小表后，能水平扩展，通过部署到多台服务器，提升整个集群的 QPS、TPS、latency 等数据库服务指标。</li> \n</ol> \n<p><strong>但是，此方案的缺点也非常明显：</strong></p> \n<ol> \n <li>分表跨实例后，产生分布式事务管理难题，一旦数据库服务器宕机，有事务不一致风险。</li> \n <li>分表后，对 SQL 语句有一定限制，对业务方功能需求大打折扣。尤其对于实时报表统计类需求，限制非常之大。事实上，报表大多都是提供给高层领导使用的，其重要性不言而喻。</li> \n <li>分表后，需要维护的对象呈指数增长（MySQL 实例数、需要执行的 SQL 变更数量等）。</li> \n</ol> \n<h3>传统 MySQL 在线 DDL 痛点</h3> \n<p>对超过账务系统的 528GB 大表分库表成 16 张表之后，每张表有 33GB，仍然是大表。我们采用了 gh-ost 工具进行加字段 DDL 操作，<strong>但是，业务仍然会有轻微感知。因此，必须要将大表的 DDL 操作放到凌晨来做，对业务的 7*24 小时服务有较大限制。</strong></p> \n<h3>原生 MySQL 的 HA 机制不完善痛点</h3> \n<p>MySQL 的集群基于 Binlog 主从异步复制来做，切集群主从角色以 instance 为单位，非常僵化。一旦主库出现故障，需要人工重建 MySQL 集群主从关系（也可以把人工操作落地成程序，比如 MHA 方案），截止目前（2020 年 1 月）<strong>原生 MySQL 仍然没有成熟可靠基于 Binlog 异步复制的 HA 方案。基于 Binlog 异步复制的 MySQL 主从架构实现金融级高可用有其本质困难。</strong></p> \n<h2>马上金融 NewSQL 技术选型</h2> \n<p>基于马上金融第二代数据库架构的核心痛点，我们需要探索新的数据库技术方案来应对业务爆发式增长所带来的挑战，为业务提供更好的数据库服务支撑。</p> \n<p>恰逢 NewSQL 愈渐火热，引起了我们的极大关注。NewSQL 技术有如下显著特点:</p> \n<ul> \n <li>无限水平扩展能力</li> \n <li>在线 DDL 操作不锁表</li> \n <li>分布式强一致性，确保金融数据 100% 安全</li> \n <li>完整的分布式事务处理能力与 ACID 特性</li> \n</ul> \n<p>在账务系统研发团队、公共平台研发团队、DBA 团队等联合推动下，我们开始对 NewSQL 技术进行调研选型。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733792\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在 GitHub的活跃度及社区贡献者方面，TiDB 与 CockcoachDB(CRDB) 都是国际化的全球开源级项目，是 NewSQL 行业中的代表性产品。</p> \n<p>由于马上金融的应用绝大部分对 MySQL 依赖较高，在协议兼容性方面，我们毫无疑问地将 MySQL 兼容性列为必选项。</p> \n<p>TiDB 从项目发起之初就将 MySQL 协议兼容性列为最 basic 的战略目标之一。而 CRDB 在项目发起之初，考虑的是兼容 PostgreSQL 协议。</p> \n<p>基于此，我们优先选择了 TiDB 技术产品。</p> \n<h2>马上金融实践案例分享（两则）</h2> \n<h3>案例一：核心账务系统归档场景</h3> \n<p>马上消费金融账务系统归档项目是公司第一个持续实践 TiDB 的项目，也是第一个对 NewSQL 技术提出迫切需求的项目，上线后 TiDB 架构如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733793\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>上游分库分表的 8 套 MySQL 集群通过 DM 聚合到一套 TiDB 里，TiDB 对外提供历史归档大表查询服务。</p> \n<p>应用架构关键机制：</p> \n<ul> \n <li> <strong>读写分离</strong>。通过 sharding-jdbc 实现应用程序读写分离，将历史数据查询请求分发到 TiDB 集群。</li> \n <li> <strong>熔断机制</strong>。应用架构设计了熔断机制，当请求 TiDB 超时或者失败后，会自动将请求重新转发到 MySQL，恢复业务。</li> \n</ul> \n<p>通过熔断机制可确保万一 TiDB 出现异常时，能快速恢复业务，确保业务的可用性。</p> \n<p><strong>账务 TiDB 集群每天业务高峰期将会承载约 1.3 万 QPS 的请求量（如下图所示），在做活动期间，请求量能冲击到近 3 万 QPS。</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733794\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>经过接近 1 年的不断优化提升，TiDB 集群表现越来越稳定，大部分请求能在 50ms 内返回：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733795\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>研发同事对 TiDB 的 Latency 与 TPS 的性能表现比较满意。</p> \n<p><strong>在 2019 年 4 月，账务系统 TiDB 项目已将 MySQL 数据库 2018 年以前的历史数据删除。极大地降低了账务系统 8 套 MySQL 数据库集群的 IO 压力。这部分历史数据仅保存在 TiDB 集群内，对业务提供实时查询支持。</strong></p> \n<h3>案例二：总账跑批业务场景</h3> \n<p><strong>马上消费金融总账项目是公司第一个完全运行在 TiDB 的项目，也是第一个从项目上线之初就放弃 MySQL，坚定不移选择 TiDB 的项目。</strong></p> \n<p>总账项目部分模块关键流程示意图如下:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733796\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>马上消费金融总账项目是公司第一个完全运行在 TiDB 的项目，也是第一个从项目上线之初就放弃 MySQL，坚定不移选择 TiDB 的项目。</p> \n<p>总账项目部分模块关键流程示意图如下:</p> \n<ul> \n <li> <strong>数据量基数大</strong>。总账项目吸纳了公司核心账务系统以及其他关联系统的所有数据，数据基数非常巨大，要求至少 10TB+ 空间，未来 2 年内可能会增长到 20TB 以上。这个基数 MySQL 难以承载。</li> \n <li> <strong>每日批量时限短</strong>。总账项目服务于管理层，每月初呈现公司当月的营收核算等信息。在总账项目数据量基数巨大的前提下，日增量 5 亿到 10 亿，希望每天能在 3 个小时内完成跑批，用 MySQL 单实例跑不下来。而分库分表技术方案对于总账系统出报表需求又具备其客观难题。</li> \n</ul> \n<p>TiDB 是分布式 NewSQL，计算与存储分离，且计算节点与存储节点都具备水平扩展能力，特别适用于总账项目的大数据量、大吞吐量、高并发量场景。</p> \n<p>项目上线已稳定运行半年左右，目前集群规模如下：</p> \n<ul> \n <li>8 TB+ 数据量</li> \n <li>12 POD TiDB 节点</li> \n <li>24 POD TiKV 节点</li> \n <li>跑批期间峰值超过 10 万 QPS</li> \n</ul> \n<p>总账项目目前完成了第二期开发，随着项目的继续发展，未来第三期的 ngls 正式接入后，数据量与并发量将再次成倍增长。</p> \n<p>总账项目上线后，跑批期间 QPS 如下:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733797\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>跑批期间的 SQL 响应时间如下:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733798\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>跑批期间的 TiKV CPU 使用率如下:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733799\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>跑批期间事务量与性能如下:</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021733800\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>马上金融 TiDB 经验总结分享</h2> \n<h3>TiDB 切入点经验</h3> \n<p>TiDB 是一个新潮的 NewSQL 数据库。想要将 TiDB 运用到生产环境，解决 MySQL 数据库面临的历史难题（而不是把问题搞得更大），并不是一件简单的事情。</p> \n<p>时至今日（2020 年 1 月 14 日），TiDB 已经在数千家企业有实践经验，其中不乏大型银行核心系统 TiDB 实践经验。且 TiDB 3.0 GA 之后，TiDB 在性能、稳定性方面比起之前版本都有了很大的提升。</p> \n<p>这意味着已经有数千家企业在向 PingCAP 官方反馈 TiDB 的各种问题并持续得到修复。在这样的背景下，TiDB 能在生产环境中稳定运行并持续为企业创造价值已是毋庸置疑。</p> \n<p><strong>对于企业而言，当前的关注焦点可能不再是 TiDB 是否稳定可靠，而是怎么才能快速获取到 TiDB 的最佳实践经验，将其纳入企业基础技术栈之内。</strong></p> \n<p><strong>那么，如何才能快速实践 TiDB，积累到第一手经验，使企业尽快享受到 TiDB 带来的福利呢？</strong></p> \n<p><strong>建议从两个方面切入:</strong></p> \n<ul> \n <li> <strong>选定一个归档项目着手尝试</strong>： 参考我们的账务系统 TiDB 归档技术方案作为企业的切入点。通过此方案，大家可以快速上手 TiDB，在技术风险可控的前提下积累到 TiDB 实践经验。</li> \n <li> <strong>联系官方或者 TUG 组织获取资源</strong>：TiDB 是一个全新的分布式数据库，整个体系架构的相比于 MySQL 要复杂得多。而截止目前（2020 年 1 月 14 日），TiDB 官方提供的文档相比 MySQL 等传统数据库要简陋得多。官方文档是入手 TiDB 的必读资料，但是，仅仅依靠官方文档是不充分的。最好能联系官方同学或者各地的 TUG 组织获得支持。</li> \n</ul> \n<h3>TiDB 服务器硬件实践经验</h3> \n<p>从我们过去近两年实践经验看，TiDB 是否能在生产环境运行稳定，硬件规划是至关重要的先决条件之一。其中，硬件规划最重要的环节包括两个：</p> \n<ul> \n <li> <strong>存储设备规划。</strong>TiDB 官方建议使用 NVME 协议的 SSD，时至今日（2020 年 1 月 14 日），主流的服务器 NVME 协议接口已不再是 pcie 口，而是 u.2 口。这个是大家都知道的，本无需赘言。真正需要关注的是 SSD 的品牌、型号。我们建议选择 Intel p4510 这一款 SSD，这款 SSD 的读 IOPS 理论值达到 60 万以上、写 IOPS 理论值达到 8 万以上，在生产实践对比结果来看，是 TiDB 的最佳搭档。</li> \n <li> <strong>网络设备规划。</strong>服务器、交换机都采用万兆网卡，比较简单，但非常重要。</li> \n</ul> \n<h3>TiDB 相关软件实践经验</h3> \n<p><strong>tidb-server 优化经验</strong></p> \n<p>tidb-server 可能发生性能异常的地方主要是 CBO 统计信息失效问题与索引设计不合理问题。这两个点并非 TiDB 独有的问题，MySQL、Oracle 等也有类似的问题。对于前者，建议对关键表定时做 analyze，以确保统计信息准确性。而索引相关的问题，根据常见的数据库优化技巧处理即可。<strong>从 3.0 版本开始，TiDB 支持 SQL 查询计划管理功能（SQL Plan Management），对这类问题提供了另一套解决方案。</strong></p> \n<p><strong>tikv-server 优化经验</strong></p> \n<p>TiKV 第一个最常见的问题是内存消耗过多被 OOM kill 的问题。TiDB 3.0 以后对 TiKV 内存配置做了优化，官方推荐将 block-cache-size 配置成 TiKV 实例占据总内存的 40%，我们在实践中发现，40% 的参数值在数据库压力极大的情况下仍然可能会出现 OOM 现象，需要基于 40% 继续往下调整才能找到与业务场景真正匹配的参数值。</p> \n<p>TiKV 另外一个问题是乐观锁适配问题。Oracle、MySQL 采用悲观锁模型，事务在做变更之前需要获取到行锁，然后才能做变更，如果没有获取到行锁，则会排队等待。而 TiDB则相反，采用乐观锁模型，先更新记录，在提交事务时，再做锁冲突检测，如果冲突了，则后提交事务的会话会报错 Write Conflict 错误引起应用程序异常。这个错误需要从 2 个方向进行处理。在 TiDB 3.0 版本下，默认关闭了事务提交重试功能，需要手工设置 tidb_disable_txn_auto_retry 参数，才能打开事务失败重试功能。另外，TiDB 的乐观锁模型决定了其不擅长处理事务冲突较大的场景，比如典型的“计数器”功能，这类场景最好将技术器功能放到第三方软件来实现会比较合适（比如 Redis）。<strong>另外，从 3.0 版本开始，TiDB 已经开始支持悲观锁功能，这个功能预计在 4.0 GA，我们也开始了这一块的测试工作。</strong></p> \n<p><strong>DM 实践经验</strong></p> \n<p>到目前为止（2020 年 1 月 14 日），DM 仍然没有发布高可用机制版本，官方正在紧锣密鼓实现高可用机制，我们建议将 TiDB 用做归档场景作为实践 TiDB 的起点，而不将其作为最终的目标。实践 TiDB 的目标是将 TiDB 作为对前台应用提供 OLTP 服务的数据库。</p> \n<p><strong>使用 DM 的关键是有效规避 MySQL 到 TiDB 同步的异常问题，使同步能持续稳定运行</strong>。对于刚接触 TiDB 的同学而言，建议从最简化的方式使用 DM:</p> \n<ul> \n <li>保持 MySQL 到 TiDB 同步的逻辑结构一致。也就是说，MySQL 里的库表是什么样子，DM 同步到 TiDB 就是什么样子。不做分表聚合。分表聚合长期实时同步有其本质困难，不适合作为初学者的目标。</li> \n <li>语法预验证确保兼容性。TiDB 与 MySQL 是“高度兼容”的，但没有人能承诺 100% 兼容（其他数据库也一样不敢夸口 100% 兼容 MySQL）。也就是说，如果一些生僻的 SQL 语句在 MySQL 上执行成功了，通过 DM 同步到 TiDB，可能会执行失败，引起同步中断异常。这类问题的最好解决方法是先将变更的 SQL 语句在测试环境 TiDB 执行一遍，确保正确后再到生产环境的 MySQL 执行。</li> \n</ul> \n<p><strong>TiDB 热点数据优化实践经验</strong></p> \n<p>TiDB 根据表主键 ID 做 range 分区，将数据拆分到各个不同的 region 内。当某个 region 的数据量达到最大 size 限制后，将会进行分裂。感性来看，一旦某个 region 分裂成两个 region 后，读写压力也会拆分到两个不同的 region。但是，假设一种场景，当我们不断对一张表进行 insert 操作，而且这张表是自增主键。那么，应用插入的数据永远会落在该表 range 范围最大的 region，永远处于“添油战术”的状态，最大 range 范围的 region 所在的 TiKV 实例一直处于高负载，整个 TiKV 集群的压力无法均摊下去，出现瓶颈。</p> \n<p>这类场景在跑批应用中比较常见。我们的优化实践建议如下：</p> \n<ul> \n <li>确保表主键是整形类型。</li> \n <li>确保表主键离散随机生成，而非自增。</li> \n</ul> \n<p>通过以上两种机制能确保批量 insert 操作的写压力随机分摊到各个 region 中去，提升整个集群的吞吐量。</p> \n<p><strong>关于 Cloud TiDB 技术方向引子</strong></p> \n<p>坊间传言我们是国内第一家将所有 TiDB 都运行在 Kubernetes 容器云上的（金融）企业。我们地处西南，平日疏于与业界优秀数据库同行交流心得，是否第一不得而知，但我们的 TiDB 确实都运行在 Kubernetes 容器云上。</p> \n<p><strong>将 TiDB 全部运行到容器云上主要是为了提升软件部署密度，充分利用服务器硬件资源，为日后大规模部署 TiDB 集群打下基础。</strong></p> \n<p>根据我们的实践经验，基于物理服务器部署 TiDB 集群，至少 6 台物理服务器（ pd-server 与 tidb-server 混合部署）起才能部署好一套生产环境 ready 的集群。</p> \n<p>当我们将 TiDB 全部迁移到容器云平台后，最小 TiDB 集群资源从 6 台服务器降低成了 2 pods tidb-server、3 pods pd-server、3 pods tikv-server，硬件成本降低为原来的 30% 左右。</p> \n<h2>马上金融 TiDB 项目未来展望</h2> \n<p>到目前为止，我们对 TiDB 技术的储备已经持续了近 2 年时间。我们积累了账务归档、总账跑批等大数据量、高并发量的 TiDB 实践经验。我们还将所有 TiDB 运行到了 Kubernetes 容器云平台之上，使数据库真正获得了 Cloud-native 能力。</p> \n<p>未来，我们将探索更多适用于 TiDB 的核心业务场景，提升 TiDB 在公司内基础技术栈的覆盖面，尤其对 TiDB 即将正式推出的 True HATP 功能充满了期待。我们将继续深度使用 TiDB，使其为消费金融行业赋能增效增效，共同创造更深远的社会价值。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbC8xz\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p>', 'https://segmentfault.com/img/remote/1460000021733791', '1894b118d35d44cb8fe8009529c4154b', '62f75a9c3455489e9e5128982e759700,83f62facb3b943ffa8e46abd1ebc64d9,277530c212aa4407b43c58c657fe8194', '0', '3', '1', '2020-04-16 16:59:08', '2020-04-16 16:59:08');
INSERT INTO `tb_recommend` VALUES ('e7a21b682bd64aee8594e4fad0bc9dd5', '小程序跨端图表组件，开箱即用（基于Antv F2）', '因为AntV F2官方实现只有微信原生和支付宝原生，刚好我需要使用跨端小程序组件，于是我就基于AntV F2封装了一个，基于该组件的支付宝小程序已上线，可以扫码体验下。', '<blockquote>\n <a href=\"https://ext.dcloud.net.cn/plugin?id=1659\" rel=\"nofollow noreferrer\">https://ext.dcloud.net.cn/plu...</a>\n</blockquote> \n<h2>组件说明</h2> \n<p>因为AntV F2官方实现只有微信原生和支付宝原生，刚好我需要使用跨端小程序组件，于是我就基于AntV F2封装了一个，基于该组件的支付宝小程序已上线，可以扫码体验下。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391766\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"支付宝小程序码\" title=\"支付宝小程序码\"></span></p> \n<h3>效果图</h3> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022391767\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"效果图\" title=\"效果图\"></span></p> \n<h2>使用说明</h2> \n<blockquote>\n 因为防止不少人踩小程序npm的坑，我已经把最新的f2、f2-context打包进js_sdk（持续更新），开箱即用。\n</blockquote> \n<h3>使用范例</h3> \n<p>使用图表只需要一行代码 <code>&lt;f2 :init=\"initChart\" /&gt;</code></p> \n<pre><code class=\"vue\">&lt;template&gt;\n    &lt;view class=\"container\"&gt;\n        &lt;f2 :init=\"initChart\" /&gt;\n    &lt;/view&gt;\n&lt;/template&gt;\n\n&lt;script&gt;\n    // 引入组件\n    import f2 from \'@/components/i-uni-f2/f2.vue\'\n    export default {\n        components: {\n            f2\n        },\n        methods: {\n            initChart(F2, config) {\n                // 实例化chart\n                const chart = new F2.Chart(config)\n                // 这里按照F2的调用方式正常使用即可，支持所有图表，以下是DEMO\n                const data = [\n                    { genre: \'Sports\', sold: 275 },\n                    { genre: \'Strategy\', sold: 115 },\n                    { genre: \'Action\', sold: 120 },\n                    { genre: \'Shooter\', sold: 350 },\n                    { genre: \'Other\', sold: 150 }\n                ]\n                chart.source(data);\n                chart.interval()\n                    .position(\'genre*sold\')\n                    .color(\'genre\')\n                // 渲染，然后返回chart\n                chart.render()\n                return chart\n            }\n        }\n    }\n&lt;/script&gt;\n\n&lt;style scoped&gt;\n    .container {\n        width: 100vw;\n        height: 800rpx;\n    }\n&lt;/style&gt;</code></pre> \n<p>关于更多图表实例请查看：<a href=\"https://antv-f2.gitee.io/zh\" rel=\"nofollow noreferrer\">官网文档</a></p> \n<h3>需要注意的点（重要）</h3> \n<ol> \n <li>支付宝小程序需要开启component2编译（在开发者工具点击详情，勾上component2编译，这里主要是因为props：Function的绑定问题，下个版本考虑使用事件+回调方式处理下，近期更新）；</li> \n <li>官方未对微信、支付宝外的小程序平台进行单独的兼容处理，目前其他小程序我使用的是针对微信的兼容方案。</li> \n</ol> \n<h3>有问题可以在下面评论或者联系我</h3> \n<p>邮箱: i@tech.top</p>', 'https://segmentfault.com/img/remote/1460000022391766', '1894b118d35d44cb8fe8009529c4154b', '3b375646301546259a8fb29d74ae4447,63c4e1e7ec204b43a62065a3ced4c2ce,754a84ad28ed43fea93a468acd8f727b,d79254c4ca5e45dca9d484307c935281,b350d9c92c524bb4b9feedd40e5eebcd', '0', '3', '1', '2020-04-16 16:48:01', '2020-04-16 16:48:01');
INSERT INTO `tb_recommend` VALUES ('e9d76a303daf4a46b9cadf28db64fa9e', 'iOS SpringBoard tweak插件，双击图标快速启动debugserver', 'debugserver+lldb很好用，但启动起来太麻烦？我们开发了一款iOS SpringBoard tweak小插件，简化debugserver启动过程。老铁，请双击！', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326917\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>debugserver+lldb很好用，但启动起来太麻烦？我们开发了一款iOS SpringBoard tweak小插件，简化debugserver启动过程。老铁，请双击！</p> \n<h2>0x00 懒是第一生产力</h2> \n<p>我们经常要通过debugserver对App进行调试，有<a href=\"https://book.douban.com/subject/25826902/\" rel=\"nofollow noreferrer\">书籍</a>和<a href=\"http://bbs.iosre.com/t/debugserver-lldb-gdb/65\" rel=\"nofollow noreferrer\">论坛</a>对相关的技术和实践进行了说明，但实际应用起来还是有些麻烦。先要重签拷贝，再要启动终端ssh到iPhone启动debugserver，各种ls加grep找到想调试的应用，敲命令启动debugserver，然后Mac本地终端启动lldb。这样折腾下来，至少要开两个终端，有的时候甚至更多。GitHub上有个<a href=\"https://github.com/4ch12dy/issh\" rel=\"nofollow noreferrer\">issh工具</a>对上述操作有封装和优化，但是还是需要敲命令找App，再运行debugserver。</p> \n<p>所以做个tweak提升一下生产力。只需<strong>双击应用图标，即可一键启动debugserver</strong>。</p> \n<p><strong>代码见：Github</strong></p> \n<p><em><a href=\"https://github.com/TalkingData/tap2debug\" rel=\"nofollow noreferrer\">https://github.com/TalkingDat...</a></em></p> \n<p><strong>运行界面</strong></p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022326916\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>我们所用的开发环境是iOS 13.3，但是并没有用到特殊版本的API，低版本手机应该也OK。</p> \n<p>下面简单分享开发过程：</p> \n<h2>0x01 通过图标找到应用执行路径</h2> \n<p>从界面找逻辑，逆向发现SpringBoard的图标是<strong>SBIconView</strong>。并且有一个叫属性 <strong>applicationBundleIdentifierForShortcuts</strong> 返回的是图标对应的App的Bundle ID。通过Bundle ID构造<strong>LSApplicationProxy</strong>对象，并且获得<strong>canonicalExecutablePath</strong>属性，也就是应用的可执行文件路径。</p> \n<pre><code>Class LSApplicationProxy_class = objc_getClass(\"LSApplicationProxy\");NSObject* proxyObj = [LSApplicationProxy_class performSelector:@selector(applicationProxyForIdentifier:) withObject:bundle];NSString * canonicalExecutablePath = [proxyObj performSelector:@selector(canonicalExecutablePath)];复制代码</code></pre> \n<h2>0x02 寻找注入点添加扩展</h2> \n<p>接续看<strong>SBIconView</strong>，图标上有两个手势对象：</p> \n<ul> \n <li>单击，用来启动App。</li> \n <li>长按，进入编辑状态，执行删除和排列图标等操作。</li> \n</ul> \n<p>所以，我们来给图标交互加个双击扩展。</p> \n<p>%hook SBIconView</p> \n<pre><code>- (void)didMoveToWindow{    %orig;    UITapGestureRecognizer *doubleTap = [[UITapGestureRecognizer alloc]initWithTarget:self action:@selector(handleDoubleClick:)];    [doubleTap setNumberOfTapsRequired:2];    [self addGestureRecognizer:doubleTap];    NSArray * ges = self.gestureRecognizers;    for(UITapGestureRecognizer * each in ges){        if([each isKindOfClass:[UITapGestureRecognizer class]]){            [each requireGestureRecognizerToFail: doubleTap];        }    }}复制代码</code></pre> \n<p>这里额外说一句，[each requireGestureRecognizerToFail: doubleTap]添加了双击手势指挥，由于iOS内部维护了手势的状态机，我们进行单击操作的时候，其实产生了两种Possible State。第一种是识别为单击，然后结束。第二种是识别为双击的第一下并等待第二下的发生，然后根据两次点击之时间间隔阈值来判断是不是合法的双击。</p> \n<p>所以我们手动增加了约束，相当于指定了识别的优先级，只有双击失败了，才继续执行单击回调。这种操作会带来一点几乎无感的瑕疵：单击后等待双击识别失败的延迟，延迟的值就是双击识别执行的阈值（大约零点几秒）。</p> \n<h2>0x03 debugserver启动和关闭</h2> \n<p>debugserver是一个二进制文件，狗神的教程里有如何重签，issh把这些过程给简化了。先看一下debugserver的权限： <br><strong>-rwxr-xr-x 1 root admin 9876848 Jan 19 11:28 /iOSRE/tools/debugserver*</strong></p> \n<p>再来看一下SpringBoard的权限: <br><strong>-rwxr-xr-x 1 root wheel 71264 Dec 5 13:15 SpringBoard*</strong></p> \n<p>属主用户都是root，没毛病。找个函数调用一下：</p> \n<ol> \n <li>system函数</li> \n <li>posix_spawn函数</li> \n <li>NSTask ，面向对象方便管理，异步执行，不会block UI，就用它了。</li> \n</ol> \n<p>代码如下：</p> \n<pre><code>task = [[NSTask alloc]init];[task setLaunchPath:bin_serverpath];[task setArguments:args];[task launch];复制代码</code></pre> \n<p>每次server在launch之前，要把之前的task结束掉。</p> \n<pre><code>- (void)interrupt; // Not always possible. Sends SIGINT.复制代码</code></pre> \n<pre><code>- (void)terminate; // Not always possible. Sends SIGTERM.复制代码</code></pre> \n<p><strong>NSTask</strong>头文件里竟然告诉我 <strong>Not always possible</strong>。事实上，在调用的时候，还真的不怎么possible，实际测试第一次server正常启动，后续由于没成功关闭，所以第二次就没法启动了。</p> \n<p>所以还是换种方式关闭吧。简单粗暴的 kill 函数：</p> \n<pre><code>NSTask * task = [TaskManager sharedManager].runningTask;if(task){    kill(task.processIdentifier,SIGKILL);    task = nil;}复制代码</code></pre> \n<h2>0x04 添加UI交互</h2> \n<p>直接用Alert，又有按钮又有输入框，不过UIAlertView已经被废弃掉了，需要用UIAlertController。由于弹出Controller需要父Controller，通过View找到当前的Controller，做正向的应该都写过这段代码吧：</p> \n<pre><code>@implementation UIView(find)-(UIViewController*)findViewController{    UIResponder* target= self;    while (target) {        target = target.nextResponder;        if ([target isKindOfClass:[UIViewController class]]) {            break;        }    }    return (UIViewController*)target;}@end复制代码</code></pre> \n<h2>0x05 优化一下用户体验</h2> \n<p>输入框里的IP和debugserver的path，每个人都不一样，所以在第一次输入完成之后，把这些值用NSUserDefault持久化存储起来，下次直接读取填充。</p> \n<h2>0x06后记</h2> \n<p>之前在相关技术论坛读到讨论用Root身份运行App的帖子，学习完帖子里的技巧，增强对操作系统的理解以及实践之后，发现如果真的想RootApp运行，其实SpringBoard本身就是一个RootApp，我们把SpringBoard当做RootViewController，很容易把一些系统工具做出界面，从而提升生产力。比如砸壳、重签、拷贝App等。</p> \n<p>**<br>作者：TalkingData小张同学</p> \n<p>本文版权归TalkingData所有，如需转载请注明来源**</p>', 'https://segmentfault.com/img/remote/1460000022326917', '692c6787030d4b8882077b2ab9279c52', '84564b2b178141059e2bf061053de54b,85ee959b27f74072b13cc763b9bbf77e,c0d2479bf6564cf5aa35b1b40604f199', '0', '3', '1', '2020-04-16 16:47:11', '2020-04-16 16:47:11');
INSERT INTO `tb_recommend` VALUES ('eaf6e5bf928b45378d9a829fdd54b372', '消息中间件ActiveMQ、RabbitMQ、RocketMQ、ZeroMQ、Kafka如何选型？', '最近要为公司的消息队列中间件进行选型，市面上相关的开源技术又非常多，如ActiveMQ、RabbitMQ、ZeroMQ、Kafka，还有阿里巴巴的RocketMQ等。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF6i4\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>最近要为公司的消息队列中间件进行选型，市面上相关的开源技术又非常多，如ActiveMQ、RabbitMQ、ZeroMQ、Kafka，还有阿里巴巴的RocketMQ等。</p> \n<p><strong>这么多技术，如何进行选型呢？</strong></p> \n<p>首先对于阿里的RocketMQ，因为是阿里开源的，对于国内开源的保持谨慎的态度，暂时不采取该中间件。</p> \n<p>所以只能在ActiveMQ、RabbitMQ、ZeroMQ、Kafka中间选一款作为消息队列中间件。</p> \n<p><strong>下面从几个维度来对比下</strong></p> \n<p><strong>1、社区活跃度</strong></p> \n<p>从目前网上的资料上看，RabbitMQ、activeMQ、ZeroMQ三者中RabbitMQ绝对是首选。 </p> \n<p><strong>2、消息持久化</strong></p> \n<p>ZeroMq不支持消息持久化，ActiveMQ和RabbitMQ都支持。</p> \n<p><strong>3、核心技术</strong></p> \n<p>可靠性、灵活的路由、集群、事务、高可用的队列、消息排序、问题追踪、可视化管理工具、插件系统等等。</p> \n<p>RabbitMq / Kafka最好，ActiveMQ次之，ZeroMQ最差。当然ZeroMQ也可以做到，不过自己必须手动写代码实现，工作量不小。尤其是可靠性中的：持久性、投递确认、发布者证实和高可用性。</p> \n<p><strong>4、高并发</strong></p> \n<p>毋庸置疑RabbitMQ最高，因为RabbitMQ是由天生具备高并发高可用特性的erlang语言实现的。</p> \n<p>以上对比参考来源网络，大同小异。总结就是需要从RabbitMQ和Kafka之间选一款适合自己的。RabbitMQ和Kafka这两款无疑也是现在市场上有得比较多的两款消息队列中间件，从网络资料和面试要求也可以看得出来。</p> \n<blockquote>\n 关于这两者非常全的评测，参考：\n <a href=\"https://mp.weixin.qq.com/s?__biz=MzI3NDAwNDUwNg==&amp;mid=2648307598&amp;idx=1&amp;sn=eeaa9d795ef6ba13368e7a76ca14bae7&amp;chksm=f337f8fbc44071ed8496f251a0b449f63f70c290947c642914f1f1c8349e1cccde4c1841323a#rd\" rel=\"nofollow noreferrer\">https://mp.weixin.qq.com/s?__...</a> \n</blockquote> \n<p><strong>如何抉择？？</strong></p> \n<p>总体来说，分布式消息中间件Kafka和RabbitMQ在行业认可、服务支持、可靠性、可维护性、兼容性、易用性等方面各有特色。Kafka在开源许可证、产品活跃度、性能、安全性、可扩展性等方面优于RabbitMQ，Kafka采用的许可证更宽松，活跃度更高，性能远高于RabbitMQ，在安全性和可扩展性方面能够提供更好的保障。Kafka仅在功能上略少于RabbitMQ，但是已经具备了主要的功能。</p> \n<p>综合上述所有评测结果，我们决定选择Kafka。</p> \n<p><strong>推荐去我的博客阅读更多：</strong></p> \n<p>1.<a href=\"http://www.javastack.cn/categories/Java/\" rel=\"nofollow noreferrer\">Java JVM、集合、多线程、新特性系列教程</a></p> \n<p>2.<a href=\"http://www.javastack.cn/categories/Spring/\" rel=\"nofollow noreferrer\">Spring MVC、Spring Boot、Spring Cloud 系列教程</a></p> \n<p>3.<a href=\"http://www.javastack.cn/categories/Tools/\" rel=\"nofollow noreferrer\">Maven、Git、Eclipse、Intellij IDEA 系列工具教程</a></p> \n<p>4.<a href=\"http://www.javastack.cn/categories/%E9%9D%A2%E8%AF%95%E9%A2%98/\" rel=\"nofollow noreferrer\">Java、后端、架构、阿里巴巴等大厂最新面试题</a></p> \n<p>生活很美好，明天见～</p>', 'https://segmentfault.com/img/bVbF6i4', '1894b118d35d44cb8fe8009529c4154b', '2294832fe5104d73ace4f14ad9549018', '0', '3', '1', '2020-04-16 16:48:56', '2020-04-16 16:48:56');
INSERT INTO `tb_recommend` VALUES ('ecf5adee987b4bbfbcd0dfd9f07fd175', '[译]Flutter - 使用Provider实现状态管理', '这篇文章好的的地方在于它不仅讲了Flutter Provider如何管理State的，还讲述了一个Flutter App可以采用哪一种架构。这种架构是基于clean architecture和FilledStacks这两种架构原则的（这里可能理解或者表达有误...', '<p>这篇文章好的的地方在于它不仅讲了Flutter Provider如何管理State的，还讲述了一个Flutter App可以采用哪一种架构。这种架构是基于<a href=\"https://pusher.com/tutorials/clean-architecture-introduction\" rel=\"nofollow noreferrer\">clean architecture</a>和<a href=\"https://www.filledstacks.com/post/flutter-architecture-my-provider-implementation-guide/\" rel=\"nofollow noreferrer\">FilledStacks</a>这两种架构原则的（这里可能理解或者表达有误，请指正）。但是文中最后采用的还是<strong>MVVM</strong>的模式。</p> \n<p>更加重要的一点，就是本文要讲述的Provider其实就是一种widget。搭配着<code>Consumer</code>这个widget一起使用，达到<strong>UI = f(state)</strong>这个<code>state</code>变化，UI跟着变的效果。</p> \n<p>最后，还是那句话要看原文的请到<a href=\"https://www.raywenderlich.com/6373413-state-management-with-provider\" rel=\"nofollow noreferrer\">这里</a>，文章本身有质量，而且写的不难。</p> \n<h2>正文</h2> \n<p>Flutter团队建议初学者使用<strong>Provider</strong>来管理state。但是Provider到底是什么，该如何使用？</p> \n<p>Provider是一个UI工具。如果你对于架构、state和架构之间有疑惑，那么并不只有你是这样。本文会帮助你理清这些概念，让你知道如何从无到有写一个app。</p> \n<p>本文会带你学习Provider管理state的方方面面。这里我们来写一个计算汇率的app，就叫做<strong>MoolaX</strong>。在写这个app的时候你会提升你的Flutter技能：</p> \n<ol> \n <li>app架构</li> \n <li>实现一个Provider</li> \n <li>熟练管理app的state</li> \n <li>根据state的更改来更新UI</li> \n</ol> \n<blockquote>\n 注意：本文假设你已经知道Dart和如何写一个Flutter的app了。如果在这方面还有不清楚的话请移步\n <a href=\"https://www.raywenderlich.com/4529993-getting-started-with-flutter\" rel=\"nofollow noreferrer\">Flutter入门</a>。\n</blockquote> \n<h2>开始</h2> \n<p>点击“下载材料”来下载项目的代码。然后你就可以一步一步的跟着本文添加代码完成开发。</p> \n<p>本文使用了Android Studio，但是Visual Studio Code也是可以用的。（其实VS Code更好用，译者观点）。</p> \n<p>在MoolaX里你可以选择不同的货币。App运行起来是这样的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263766\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"最终效果\" title=\"最终效果\"></span></p> \n<p>打开初始项目，解压后的starter目录。Android Studio会出现一个弹出框，点击<strong>Get dependencies</strong>。</p> \n<p>在初始项目里已经包含了一部分代码，本教程会带着你添加必要的代码，让你轻松学会下文的内容。</p> \n<p>现在这个app运行起来的时候是这样的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263767\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>搭建App的架构</h2> \n<p>如果你没听说过<a href=\"https://pusher.com/tutorials/clean-architecture-introduction\" rel=\"nofollow noreferrer\">clean architecture</a>，再继续之前请阅读这篇文章。</p> \n<p>主旨就是把核心业务逻辑从UI、数据库、网络请求和第三方包中分离出来。为什么？核心业务逻辑相对并不会那么频繁的更改。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263770\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>UI不应该直接请求网络。也不应该把数据库读写的代码写的到处都是。所有的数据都应该从一个统一的地方发出，这就是业务逻辑。</p> \n<p>这就形成了一个插件系统。即使你更换了一个数据库，app的其他部分也不会有任何的感知。你可以从一个移动端UI更换的一个桌面UI，app的其他部分也并不用关心。这对于开发一个易于维护、扩展的app来说十分有效。</p> \n<h2>使用Provider管理state</h2> \n<p>MoolaX的架构就符合这个原则。业务逻辑处理汇率相关的计算。Local Storage、网络请求和Flutter的UI、Provider这些全部都互相独立。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263774\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>Local storage使用的是shared preferences，但是这个和app的其他部分没有关联。同理网络请求如何获取数据和app的其他部分也没有任何关联。</p> \n<p>接下来要理解的是UI、Flutter和Provider都在同一个部分里。Flutter就是一个UI框架，Provider是这个框架里的一个widget。</p> \n<p>Provider是架构吗？不是。<br>Provider是状态管理吗？不是，至少在这个app里不是。</p> \n<p><strong>state</strong>是app的变量的当前值。这些变量是app的业务逻辑的一部分，分散、管理在不同的model对象里。所以，业务逻辑管理了state，而不是Provider。</p> \n<p>所以，Provider到底是什么呢？</p> \n<p>它是<strong>状态管理的helper</strong>，它是一个widget。通过这个widget可以把model对象传递给它的子widget。</p> \n<p><code>Consumer</code> widget，属于<a href=\"https://pub.dev/packages/provider\" rel=\"nofollow noreferrer\">Provider 包</a>的一部分，监听了Provider暴露的mode值的改变，并重新build它的全部子widget。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263777\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p><a href=\"https://www.raywenderlich.com/6011211-manage-state-with-provider\" rel=\"nofollow noreferrer\">使用Provider管理state系列</a>对state和provider做了更加全面的解析。Provider有很多种，不过多数不在本文的范围内。</p> \n<h2>和业务逻辑通信</h2> \n<p>文本的架构模式受到了<a href=\"https://www.filledstacks.com/post/flutter-architecture-my-provider-implementation-guide/\" rel=\"nofollow noreferrer\">FilledStacks</a>的启发。它可以让架构足够有条理而又不会太过复杂。对初学者也很友好。</p> \n<p>这个模型非常类似于<strong>MVVM</strong>（Model View ViewModel)。</p> \n<p><strong>model</strong>就是从数据库或者网络请求得到的数据。<strong>view</strong>就是UI，也可以是一个screen或者widget。<strong>viewmodel</strong>就是在UI和数据中间的业务逻辑，并提供了UI可以展示的数据。但是它对UI并无感知。这一单和<a href=\"https://www.youtube.com/watch?v=ugpC98LcNqA\" rel=\"nofollow noreferrer\">MVP</a>不同。viewmodel也不应该知道数据从哪里来。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263776\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>在MoolaX里，每页都有独立的view model。数据可以从网络和本地存储获得。处理这部分内容的类叫做services。MoolaX的架构基本是这样的：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263768\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>注意如下几点：</p> \n<ul> \n <li>UI页面监听view model的改变，也会给view model发送事件</li> \n <li>view model不会感知到UI的具体细节</li> \n <li>业务逻辑与货币抽象交互。它不会感知数据是从网络请求得来还是从本地存储得来。</li> \n</ul> \n<p>理论部分到此结束，现在开始代码部分！</p> \n<h2>创建核心业务逻辑</h2> \n<p>项目的目录结构如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263775\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>Models</h2> \n<p>我们来看看mdels目录：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263769\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>这些就是业务逻辑要用到的数据结构了。<a href=\"http://www.agilemodeling.com/artifacts/crcModel.htm\" rel=\"nofollow noreferrer\">类职责协同卡片模型</a>是一个很好的方法可以确定哪些model是需要的。卡片如下：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263779\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>最后会用到<code>Currency</code>和<code>Rate</code>两个model。他们代表了先进和汇率，就算你没哟计算机也需要这两个。</p> \n<h2>View Model</h2> \n<p>view mode的职责就是拿到数据，然后转化成UI可用的格式。</p> \n<p>展开<strong>view_models</strong>目录。你会看到两个view model，一个是给结算页用的，一个是给选择汇率页用的。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263780\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>打开<strong>choose_favorites_viewmodel.dart</strong>。你会看到下面的代码：</p> \n<pre><code class=\"dart\">// 1\nimport \'package:flutter/foundation.dart\';\n\n// 2\nclass ChooseFavoritesViewModel extends ChangeNotifier {\n  // 3\n  final CurrencyService _currencyService = serviceLocator&lt;CurrencyService&gt;();\n\n  List&lt;FavoritePresentation&gt; _choices = [];\n  List&lt;Currency&gt; _favorites = [];\n\n  // 4\n  List&lt;FavoritePresentation&gt; get choices =&gt; _choices;\n\n  void loadData() async {\n    // ...\n    // 5\n    notifyListeners();\n  }\n\n  void toggleFavoriteStatus(int choiceIndex) {\n    // ...\n    // 5\n    notifyListeners();\n  }\n}</code></pre> \n<p>解释：</p> \n<ol> \n <li>使用<code>ChangeNotifier</code>来实现UI对view model的监听。这个类在Flutter<code>foundation</code>包。</li> \n <li>view model类继承了<code>ChangeNotifier</code>类。另一个选项是使用mixin。<code>ChangeNotifier</code>里有一个<code>notifyListeners()</code>方法，你后面会用到。</li> \n <li>一个service来负责获取和保存货币以及汇率数据。<code>CurrencyService</code>是一个抽象类，它的具体实现隐藏在view model之外。你可以任意更换不同的实现。</li> \n <li>任意可以访问这个view mode的实例都可以访问到一个货币列表，然后从里面选出一个最喜欢的。UI会使用这个列表来创建一个可选的listview。</li> \n <li>在获取到货币列表或者修改了最喜欢的货币之后，都会调用<code>notifyListeners()</code>方法发出通知。UI会接受到通知，并作出更新。</li> \n</ol> \n<p>在<strong>choose_favorites_viewmodel.dart</strong>文件还有另外的一个类：<code>FavoritePresentation</code>:</p> \n<pre><code class=\"dart\">class FavoritePresentation {\n  final String flag;\n  final String alphabeticCode;\n  final String longName;\n  bool isFavorite;\n\n  FavoritePresentation(\n      {this.flag, this.alphabeticCode, this.longName, this.isFavorite,});\n}</code></pre> \n<p>这个类就是为UI展示用的。这里尽量不保存任何与UI无关的内容。</p> \n<p>在<code>ChooseFavoritesViewModel</code>，用下面的代码替换掉<code>loadData()</code>方法</p> \n<pre><code class=\"dart\">void loadData() async {\n    final rates = await _currencyService.getAllExchangeRates();\n    _favorites = await _currencyService.getFavoriteCurrencies();\n    _prepareChoicePresentation(rates);\n    notifyListeners();\n  }\n\n  void _prepareChoicePresentation(List&lt;Rate&gt; rates) {\n    List&lt;FavoritePresentation&gt; list = [];\n    for (Rate rate in rates) {\n      String code = rate.quoteCurrency;\n      bool isFavorite = _getFavoriteStatus(code);\n      list.add(FavoritePresentation(\n        flag: IsoData.flagOf(code),\n        alphabeticCode: code,\n        longName: IsoData.longNameOf(code),\n        isFavorite: isFavorite,\n      ));\n    }\n    _choices = list;\n  }\n\n  bool _getFavoriteStatus(String code) {\n    for (Currency currency in _favorites) {\n      if (code == currency.isoCode)\n        return true;\n    }\n    return false;\n  }</code></pre> \n<p><code>loadData</code>获取一列汇率。接着，<code>_prepareChoicePresentation()</code>方法把列表转化成UI可以直接显示的格式。<code>_getFavoriteStatus()</code>决定了一个货币是否为最喜欢货币。</p> \n<p>接着使用下面的代码替换掉<code>toggleFavoriteStatus()</code>方法：</p> \n<pre><code class=\"dart\">void toggleFavoriteStatus(int choiceIndex) {\n    final isFavorite = !_choices[choiceIndex].isFavorite;\n    final code = _choices[choiceIndex].alphabeticCode;\n    _choices[choiceIndex].isFavorite = isFavorite;\n    if (isFavorite) {\n      _addToFavorites(code);\n    } else {\n      _removeFromFavorites(code);\n    }\n    notifyListeners();\n  }\n\n  void _addToFavorites(String alphabeticCode) {\n    _favorites.add(Currency(alphabeticCode));\n    _currencyService.saveFavoriteCurrencies(_favorites);\n  }\n\n  void _removeFromFavorites(String alphabeticCode) {\n    for (final currency in _favorites) {\n      if (currency.isoCode == alphabeticCode) {\n        _favorites.remove(currency);\n        break;\n      }\n    }\n    _currencyService.saveFavoriteCurrencies(_favorites);\n  }</code></pre> \n<p>只要这个方法被调用，view model就会调用货币服务保存新的最喜欢货币。同时因为<code>notifyListeners</code>方法也被调用了，所以UI也会立刻显示最新的修改。</p> \n<p>恭喜你，你已经完成了view model了。</p> \n<p>总结一下，你的view model类需要做的就是继承<code>ChangeNotifier</code>类并在需要更新UI的地方调用<code>notifyListeners()</code>方法。</p> \n<h2>Services</h2> \n<p>我们这里有三种service，分别是：汇率交换，存储以及网络请求。看下面的架构图，所有服务都在右边红色的框表示：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263778\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ol> \n <li>创建一个抽象类，在里面添加所有会用到的方法</li> \n <li>给抽象类写一个具体的实现类</li> \n</ol> \n<p>因为每次创建一个service的方式都差不多，我们就用网络请求为例。初始项目中已经包含了<strong>汇率服务</strong>和<strong>存储服务</strong>了。</p> \n<h2>创建一个抽象service类</h2> \n<p>打开<strong>web_api.dart</strong>：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263771\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>你会看到如下的代码：</p> \n<pre><code class=\"dart\">import \'package:moolax/business_logic/models/rate.dart\';\n\nabstract class WebApi {\n  Future&lt;List&lt;Rate&gt;&gt; fetchExchangeRates();\n}</code></pre> \n<p>这是一个抽象类，所以它并不具体做什么。然而，它还是会反映出app需要它做什么：它应该从网络请求一串汇率回来。具体如何实现由你决定。</p> \n<h2>使用假数据</h2> \n<p>在<strong>web_api</strong>里，新建一个文件<strong>web_api_fake.dart</strong>。之后复制如下代码进去：</p> \n<pre><code class=\"dart\">import \'package:moolax/business_logic/models/rate.dart\';\nimport \'web_api.dart\';\n\nclass FakeWebApi implements WebApi {\n\n  @override\n  Future&lt;List&lt;Rate&gt;&gt; fetchExchangeRates() async {\n    List&lt;Rate&gt; list = [];\n    list.add(Rate(\n      baseCurrency: \'USD\',\n      quoteCurrency: \'EUR\',\n      exchangeRate: 0.91,\n    ));\n    list.add(Rate(\n      baseCurrency: \'USD\',\n      quoteCurrency: \'CNY\',\n      exchangeRate: 7.05,\n    ));\n    list.add(Rate(\n      baseCurrency: \'USD\',\n      quoteCurrency: \'MNT\',\n      exchangeRate: 2668.37,\n    ));\n    return list;\n  }\n\n}</code></pre> \n<p>这个类实现了抽象<code>WebApi</code>类，反回了某些写死的数据。现在你可以继续编写其他部分的代码了，网络请求的部分可以放心了。什么时候准备好了，可以回来实现真正的网络请求。</p> \n<h2>添加一个Service定位器</h2> \n<p>即使抽象类都实现了，你还是要告诉app去哪里找这些抽象类的具体实现类。</p> \n<p>有一个service定位器可以很快完成这个功能。一个service定位器是<a href=\"https://martinfowler.com/articles/injection.html\" rel=\"nofollow noreferrer\">一个依赖注入的替代</a>。它可以用来把一个service和app的其他部分解耦。</p> \n<p>在<code>ChooseFavoriatesViewModel</code>里有这么一行：</p> \n<pre><code class=\"dart\">final CurrencyService _currencyService = serviceLocator&lt;CurrencyService&gt;();</code></pre> \n<p><code>serviceLocator</code>是一个单例对象，它回到你用到的所有的service。</p> \n<p>在<strong>services</strong>目录下，打开<strong>service_locator.dart</strong>。你会看到下面的代码：</p> \n<pre><code class=\"dart\">// 1\nGetIt serviceLocator = GetIt.instance;\n\n// 2\nvoid setupServiceLocator() {\n\n  // 3\n  serviceLocator.registerLazySingleton&lt;StorageService&gt;(() =&gt; StorageServiceImpl());\n  serviceLocator.registerLazySingleton&lt;CurrencyService&gt;(() =&gt; CurrencyServiceFake());\n\n  // 4\n  serviceLocator.registerFactory&lt;CalculateScreenViewModel&gt;(() =&gt; CalculateScreenViewModel());\n  serviceLocator.registerFactory&lt;ChooseFavoritesViewModel&gt;(() =&gt; ChooseFavoritesViewModel());\n}</code></pre> \n<p>解释：</p> \n<ol> \n <li> <code>GetIt</code>是一个叫做<strong>get_it</strong>的service 定位包。这里已经预先添加到<code>pubspec.yaml</code>里了。<strong>get_it</strong>会通过一个全局的单例来保留所有注册的对象。</li> \n <li>这个方法就是用来注册服务的。在构建UI之前就需要调用这个方法了。</li> \n <li>你可以把你的服务注册为延迟加载的单例。注册为单例也就是说你每次取回的是同一个实例。注册为一个延迟加载的单例等于，在第一次使用的时候，只有在用的时候才会初始化。</li> \n <li>你也可以使用service定位器来注册view model。这样在UI里可以很容易拿到他们的引用。当然view models都是注册为一个factory了。每次取回来的都是一个新的view model实例。</li> \n</ol> \n<p>注意代码是在哪里调用<code>setupServiceLocator()</code>的。打开<strong>main.dart</strong>文件：</p> \n<pre><code class=\"dart\">void main() {\n  setupServiceLocator(); //              &lt;--- here\n  runApp(MyApp());\n}\n\nclass MyApp extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: \'Moola X\',\n      theme: ThemeData(\n        primarySwatch: Colors.indigo,\n      ),\n      home: CalculateCurrencyScreen(),\n    );\n  }\n}</code></pre> \n<h2>注册FakeWebApi</h2> \n<p>现在来注册<code>FakeWebApi</code>。</p> \n<pre><code class=\"dart\">serviceLocator.registerLazySingleton&lt;WebApi&gt;(() =&gt; FakeWebApi());</code></pre> \n<p>使用<code>CurrencyServiceImpl</code>替换<code>CurrencyServiceFake</code>：</p> \n<pre><code class=\"dart\">serviceLocator.registerLazySingleton&lt;CurrencyService&gt;(() =&gt; CurrencyServiceImpl());</code></pre> \n<p>初始项目里使用了<code>CurrencyServiceFake</code>，这样才能运行起来。</p> \n<p>引入缺失的类：</p> \n<pre><code class=\"dart\">import \'web_api/web_api.dart\';\nimport \'web_api/web_api_fake.dart\';\nimport \'currency/currency_service_implementation.dart\';</code></pre> \n<p>运行app，点击右上角的心形。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263773\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>Web API的具体实现</h2> \n<p>前面注册了假的web api实现，app已经可以运行了。下面就需要从真的web服务器上获取真正的数据了。在<strong>services/web_api</strong>目录下，新建文件<strong>web_api_implementation.dart</strong>。添加如下的代码：</p> \n<pre><code class=\"dart\">import \'dart:convert\';\nimport \'package:http/http.dart\' as http;\nimport \'package:moolax/business_logic/models/rate.dart\';\nimport \'web_api.dart\';\n\n// 1\nclass WebApiImpl implements WebApi {\n  final _host = \'api.exchangeratesapi.io\';\n  final _path = \'latest\';\n  final Map&lt;String, String&gt; _headers = {\'Accept\': \'application/json\'};\n\n  // 2\n  List&lt;Rate&gt; _rateCache;\n\n  Future&lt;List&lt;Rate&gt;&gt; fetchExchangeRates() async {\n    if (_rateCache == null) {\n      print(\'getting rates from the web\');\n      final uri = Uri.https(_host, _path);\n      final results = await http.get(uri, headers: _headers);\n      final jsonObject = json.decode(results.body);\n      _rateCache = _createRateListFromRawMap(jsonObject);\n    } else {\n      print(\'getting rates from cache\');\n    }\n    return _rateCache;\n  }\n\n  List&lt;Rate&gt; _createRateListFromRawMap(Map jsonObject) {\n    final Map rates = jsonObject[\'rates\'];\n    final String base = jsonObject[\'base\'];\n    List&lt;Rate&gt; list = [];\n    list.add(Rate(baseCurrency: base, quoteCurrency: base, exchangeRate: 1.0));\n    for (var rate in rates.entries) {\n      list.add(Rate(baseCurrency: base,\n          quoteCurrency: rate.key,\n          exchangeRate: rate.value as double));\n    }\n    return list;\n  }\n}，</code></pre> \n<p>注意下面的几点：</p> \n<ol> \n <li>如同<code>FakeWebApi</code>，这个类也实现了<code>WebApi</code>。它包含了从<strong>api.exchangeratesapi.io</strong>获取数据的逻辑。然而，app的其他部分并不知道这一点，所以如果你想换到别的web api，毫无疑问这里就是你唯一可以更改的地方。</li> \n <li>exchangeratesapi.io慷慨的提供了给定数据的货币的汇率，都不要额外的token。</li> \n</ol> \n<p>打开<strong>service_localtor.dart</strong>，把<code>FakeWebApi()</code>修改为<code>WebApiImp()</code>，并更新对应的<em>import</em>语句。</p> \n<pre><code class=\"dart\">import \'web_api/web_api_implementation.dart\';\n\nvoid setupServiceLocator() {\n  serviceLocator.registerLazySingleton&lt;WebApi&gt;(() =&gt; WebApiImpl());\n  // ...\n}</code></pre> \n<h2>实现Provider</h2> \n<p>现在总算轮到Provider了。这篇怎么说也是一个Provider的教程!</p> \n<p>我们等了这么久才开始Provider的部分，你应该意识到了Provider其实是一个app的很小一部分。它只是用来方便在更改发生的时候方便把值传递给子widget，但也不是架构或者状态管理的系统。</p> \n<p>在<strong>pubspec.yaml</strong>里找到Provider包：</p> \n<pre><code class=\"dart\">dependencies:\n  provider: ^4.0.1</code></pre> \n<p>有一个比较特殊的Provider：<code>ChangeNotifierProvider</code>。它监听实现了<code>ChangeNotifier</code>的view model的修改。</p> \n<p>在<strong>ui/views</strong>目录下，打开<strong>choose_favorites.dart</strong>文件。这个文件的内容替换为如下的代码：</p> \n<pre><code class=\"dart\">import \'package:flutter/material.dart\';\nimport \'package:moolax/business_logic/view_models/choose_favorites_viewmodel.dart\';\nimport \'package:moolax/services/service_locator.dart\';\nimport \'package:provider/provider.dart\';\n\nclass ChooseFavoriteCurrencyScreen extends StatefulWidget {\n  @override\n  _ChooseFavoriteCurrencyScreenState createState() =&gt;\n      _ChooseFavoriteCurrencyScreenState();\n}\n\nclass _ChooseFavoriteCurrencyScreenState\n    extends State&lt;ChooseFavoriteCurrencyScreen&gt; {\n\n  // 1\n  ChooseFavoritesViewModel model = serviceLocator&lt;ChooseFavoritesViewModel&gt;();\n\n  // 2\n  @override\n  void initState() {\n    model.loadData();\n    super.initState();\n  }\n\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\'Choose Currencies\'),\n      ),\n      body: buildListView(model),\n    );\n  }\n\n  // Add buildListView() here.\n}</code></pre> \n<p>你会发现<code>buildListView()</code>方法，注意如下的更改：</p> \n<ol> \n <li>servie定位器返回一个view model的实例</li> \n <li>使用<code>StatefulWidget</code>,它包含了<code>initState()</code>方法。这里你可以告诉view model加载货币数据。</li> \n</ol> \n<p>在<code>build()</code>方法下，添加如下的<code>buildListView()</code>实现：</p> \n<pre><code class=\"dart\">Widget buildListView(ChooseFavoritesViewModel viewModel) {\n    // 1\n    return ChangeNotifierProvider&lt;ChooseFavoritesViewModel&gt;(\n      // 2\n      create: (context) =&gt; viewModel,\n      // 3\n      child: Consumer&lt;ChooseFavoritesViewModel&gt;(\n        builder: (context, model, child) =&gt; ListView.builder(\n          itemCount: model.choices.length,\n          itemBuilder: (context, index) {\n            return Card(\n              child: ListTile(\n                leading: SizedBox(\n                  width: 60,\n                  child: Text(\n                    \'${model.choices[index].flag}\',\n                    style: TextStyle(fontSize: 30),\n                  ),\n                ),\n                // 4\n                title: Text(\'${model.choices[index].alphabeticCode}\'),\n                subtitle: Text(\'${model.choices[index].longName}\'),\n                trailing: (model.choices[index].isFavorite)\n                    ? Icon(Icons.favorite, color: Colors.red)\n                    : Icon(Icons.favorite_border),\n                onTap: () {\n                  // 5\n                  model.toggleFavoriteStatus(index);\n                },\n              ),\n            );\n          },\n        ),\n      ),\n    );\n  }</code></pre> \n<p>代码解析：</p> \n<ol> \n <li>添加<code>ChangeNotifierProvider</code>，一个特殊类型的provider，它监听了来自view model的修改。</li> \n <li> <code>ChangeNotifierProvider</code>有一个<code>create</code>方法。这个方法给子wdiget提供了view model值。在这里你已经有了view model的引用，那就直接使用。</li> \n <li> <code>Consumer</code>，当view model的<code>notifyListeners()</code>告知更改发生的时候重新build界面。Consumer的builder方法向下传递了view model值。这个view model是从<code>ChangeNotifierProvider</code>传下来的。</li> \n <li>使用<code>model</code>里的数据来重新build界面。注意UI里只有很少的逻辑。</li> \n <li>既然你有了view model的引用，那么完全可以调用里面的方法。<code>toggleFavoriteStatus()</code>调用了<code>notifyListeners()</code>。</li> \n</ol> \n<p>再次运行app。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022263772\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h2>在大型app中使用Provider</h2> \n<p>你可以按照本文所述的方式添加更多的界面。一旦你习惯了为每个界面添加view model就可以考虑为某些类创建基类来减少重复代码。本文没有这么做，因为这样的话理解这些代码要花更多的时间。</p> \n<h2>其他的架构和状态管理方法</h2> \n<p>如果你不喜欢本文所述的架构，可以考虑BLoC模式。<a href=\"https://www.raywenderlich.com/4074597-getting-started-with-the-bloc-pattern\" rel=\"nofollow noreferrer\">BLoC模式入门</a>也是一个很好的起点。你会发现BLoC模式也不像传说的那么难以理解。</p> \n<p>还有<a href=\"https://flutter.dev/docs/development/data-and-backend/state-mgmt/options\" rel=\"nofollow noreferrer\">其他</a>的，不过Provider和BLoC是目前最普遍采用的。</p>', 'https://segmentfault.com/img/remote/1460000022263766', 'c56940aa8b004dab84568e86900b2ee6', '14ab12176ade47da95ba97d7151eb1f9,80961fb9ea954af187319d2b8e8bd474', '0', '3', '1', '2020-04-16 16:47:19', '2020-04-16 16:47:19');
INSERT INTO `tb_recommend` VALUES ('ed48c0f49572417fb6a0d000230cefce', 'Android 11 第二个开发者预览版发布，目前支持 Pixel 2/3/3a/4 系列刷机', '今天，谷歌发布了Android 11的第二个开发者预览版。和此前发布的第一个预览版相同，该预览版也仅适用于开发人员，需要手动下载，目前支持Pixel 2/3/3a/4系列刷机。', '<p>今天，谷歌发布了Android 11的第二个开发者预览版。和此前发布的第一个预览版相同，该预览版也仅适用于开发人员，需要手动下载，目前支持Pixel 2/3/3a/4系列刷机。</p> \n<p>Android 11的第二个开发者预览版并没有引入任何突破性的新功能，很大程度上是首个预览版的维护升级版本。对此，谷歌研发副总裁 Dave Burke 表示：“它仍然是早期版本，但是您可以开始了解操作系统如何在此版本中实现新体验，从无缝5G连接到围绕着屏幕改进UI，再到更智能的键盘和更快的消息传递体验。”</p> \n<p>下面我们来看一下究竟有哪些更新。</p> \n<h2>全新体验</h2> \n<p><strong>一、5G 状态 API</strong></p> \n<p>DP2 增加了 5G 状态 API，可以让您快速检查用户当前是否连接至 5G New Radio (新空口) 或 Non-Standalone (非独立组网模式) 网络。您可以使用它来展示您的应用的 5G 体验，或是在用户连接成功后进行品牌宣传。您可以将此 API 与 5G 动态计费状态 API、带宽估测 API 以及现有的网络连接 (Connectivity Manager) API 结合使用，以充分活用 5G 更高的速度和更低的延迟。</p> \n<blockquote> \n <strong>动态计费状态 API：</strong>\n <p><a href=\"https://developer.android.google.cn/reference/android/net/NetworkCapabilities.html#NET_CAPABILITY_NOT_METERED\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n <p><strong>带宽估测 API</strong></p> \n <p><a href=\"https://developer.android.google.cn/reference/android/net/NetworkCapabilities.html#getLinkDownstreamBandwidthKbps()\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n <p><strong>现有的网络连接 (Connectivity Manager) API</strong></p> \n <p><a href=\"https://developer.android.google.cn/reference/android/net/ConnectivityManager\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<p><strong>二、可折叠设备的铰链角度</strong></p> \n<p>针对可折叠设备，开发者们提出的头号要求是通过 API 获取设备的屏幕折叠角度。Android 11 现在支持铰链角度传感器，应用可以直接查询，或通过新的 AndroidX API 获取精确的铰链角度，从而为可折叠设备打造自适应体验。</p> \n<blockquote> \n <strong>铰链角度传感器</strong>\n <p><a href=\"https://developer.android.google.cn/reference/android/hardware/Sensor#STRING_TYPE_HINGE_ANGLE\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<p><strong>三、呼叫过滤服务的改进</strong></p> \n<p>为了帮助用户管理语音自动电话 (robocall)，我们添加了新的 API，以使呼叫过滤应用可以为用户提供更多帮助。除了将来电的 STIR / SHAKEN 状态 (均为防范呼叫者 ID 欺诈的标准) 纳入其呼叫详细信息进行验证外，呼叫过滤应用还可以报告拒绝来电的原因，在获得许可的前提下，这些应用还可以查看电话是否通向或来自用户联系人中的号码。应用还可以自定义系统提供的呼叫后屏幕 (post call screen)，方便用户执行诸如 “将呼叫方标记为骚扰电话” 或 “添加到联系人” 之类的操作。我们将在近期与大家分享更多这方面的信息。</p> \n<blockquote> \n <strong>STIR / SHAKEN 状态</strong>\n <p><a href=\"https://developer.android.google.cn/reference/android/telecom/Call.Details.html#getCallerNumberVerificationStatus()\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n <p><strong>呼叫后屏幕 (post call screen)</strong></p> \n <p><a href=\"https://developer.android.google.cn/reference/android/telecom/TelecomManager.html#ACTION_POST_CALL\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<p><strong>五、Neural Networks API 的新算子和控制</strong></p> \n<p>激活函数控制着神经网络中节点的输出。Google AI 团队发现了一个 swish 激活函数，它可以在相当多样的任务中带来更快的训练速度和更高的准确度。现在我们将该函数的一个计算有效版本，hard-swish 算子，加入到了 Android 11 中。这个算子在加速下一代设备上视觉模型 (如 MobileNetV3) 中至关重要，该模型也是许多迁移学习用例的基础。另外，新增的控制算子使得支持分支和循环的更高级的机器学习模型成为可能。我们还添加了新的运行控制，以帮助您最大程度地减少常见用例的延迟: Asynchronous Command Queue API 减少了运行小型链接模型时的开销。请参见 NDK 样例代码了解如何使用这些新 API。</p> \n<blockquote> \n <strong>swish 激活函数</strong>\n <p><a href=\"https://arxiv.org/pdf/1710.05941.pdf\" rel=\"nofollow noreferrer\">https://arxiv.org/pdf/1710.05...</a></p> \n <p><strong>MobileNetV3</strong></p> \n <p><a href=\"https://ai.googleblog.com/2019/11/introducing-next-generation-on-device.html\" rel=\"nofollow noreferrer\">https://ai.googleblog.com/201...</a></p> \n <p><strong>NDK 样例代码</strong></p> \n <p><a href=\"https://github.com/android/ndk-samples/tree/master/nn-samples/\" rel=\"nofollow noreferrer\">https://github.com/android/nd...</a></p> \n</blockquote> \n<h2>隐私和安全</h2> \n<p><strong>一、摄像头和麦克风的前台服务类型</strong></p> \n<p>在 Android 10 中，我们引入了清单属性 foregroundServiceType，以进一步明晰特定用例的适用范围。最初，应用可以选择 “位置” 和其他几种类型。现在，我们在 Android 11 中添加了两种新类型: “摄像头” 和 “麦克风”。如果您的应用要从前台服务访问摄像头或麦克风数据，则需要将对应的 foregroundServiceType 值添加到清单中。</p> \n<p><strong>二、分区存储的更新</strong></p> \n<p>我们一直在致力于更好地保护外部存储上的应用和用户数据。在这个版本中，我们带来了进一步的强化和更改，比如我们现在支持将文件从旧模型迁移到新的分区存储模型，并且改善了缓存文件的管理方式。阅读官方文档了解更多信息，并请留意后续更新中的更多增强功能。</p> \n<blockquote> \n <strong>foregroundServiceType</strong>\n <br>\n <a href=\"https://developer.android.google.cn/preview/privacy/foreground-service-types\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a>\n <p><strong>官方文档: Android 11 中的存储更新</strong><br><a href=\"https://developer.android.google.cn/preview/privacy/storage\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> </p> \n <p><strong>官方文档:Android 11 中的隐私权</strong> <br><a href=\"https://developer.android.google.cn/preview/privacy\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<h2>优化与品质</h2> \n<p><strong>一、同步 IME 切换效果</strong></p> \n<p>这是一组全新的 API，让您可以在 IME (输入法编辑器，也叫软键盘) 和系统栏进出屏幕时同步调整应用中的内容，从而更轻松地创建出自然、直观、高品质的 IME 切换效果。为了确保切换时做到逐帧精确，新的边衬区动画监听器 (Insets Animation Listener) 会在 IME 或系统栏移动时逐帧告知应用边衬区的变化。此外，应用可以通过 WindowInsetsAnimationController API 控制 IME 和系统栏切换效果。由应用控制 IME 的切换效果可以让 IME 更精准地与应用 UI 同步，比如配合过度滚动 UI 时的动画。请上手体验这些新的 IME 切换效果，并告诉我们您还想要支持哪些其他切换效果。</p> \n<blockquote> \n <strong>新的边衬区动画监听器 (Insets Animation Listener)</strong>\n <br>\n <a href=\"https://developer.android.google.cn/reference/android/view/WindowInsetsAnimation.Callback\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a>\n <p><strong>WindowInsetsAnimationController</strong><br><a href=\"https://developer.android.google.cn/reference/android/view/WindowInsetsAnimationController\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<p><strong>二、可变刷新率</strong></p> \n<p>应用和游戏现在可以为其窗口设置首选帧率。大多数 Android 设备以 60Hz 的刷新率更新屏幕，但是某些设备支持多种刷新率，例如 90Hz 和 60Hz，并可在运行时切换。在这些设备上，系统会基于首选帧率来为应用选择最佳刷新率。您可以通过 SDK 和 NDK 来使用本 API。请前往官方文档了解更多信息。</p> \n<blockquote>\n 设置首选帧率\n <p><a href=\"https://developer.android.google.cn/reference/android/view/Surface#setFrameRate(float,%20int)\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> \n</blockquote> \n<p><strong>三、重启后恢复</strong></p> \n<p>Android 11 改进了夜间定时 OTA 软件更新的体验。和以往版本的 Android 一样，设备需要重启才能应用 OTA 更新，现在有了重启后恢复，应用得以在 OTA 重启后访问可信凭据加密 (Credential Encrypted) 存储，而无需用户解锁设备。这样应用就得以立刻恢复正常功能，并且继续正常接收消息——由于 OTA 更新往往被定时在夜间执行，这时设备无人操作，因此重启后恢复功能就十分必要了。应用依然可以支持直接启动 (Direct Boot)，从而在所有类型的重启后立刻访问设备加密 (Device Encrypted) 存储。请在您的下一个开发者预览版 OTA 更新时点击 \"在凌晨 2 点后重启\" 来体验一下重启后恢复功能吧。</p> \n<p><strong>四、模拟器中的摄像头支持</strong></p> \n<p>Android 模拟器现在可以模拟前置和后置摄像头。后置摄像头支持 Camera2 API HW Level 3 (包括 YUV 再处理和 RAW 捕获)。它是完全符合 CTS 第 3 级要求的设备，可用于测试高级功能，例如 ZSL 和 RAW / DNG 支持。前置摄像头通过逻辑摄像头 (一个逻辑设备及两个隐藏的物理设备) 支持 FULL HW 级别。它强调逻辑摄像头的支持，对应的物理设备则包括窄视角和宽视角摄像头。有了模拟摄像头的支持，您可以构建并测试 Android 11 中新增的任何摄像头功能。我们会在近期公布更多详细信息。</p> \n<blockquote> \n <strong>HW LEVEL_3 和 FULL 级别</strong>\n <br>\n <a href=\"https://source.android.google.cn/devices/camera/versioning#camera_api2\" rel=\"nofollow noreferrer\">https://source.android.google...</a> \n</blockquote> \n<h2>应用兼容性</h2> \n<p>在推出新的平台版本时，进一步通过推进应用兼容性来让用户使用更快速、更流畅的 Android 体验 。在 Android 11 中，添加了新的流程、工具以及发布里程碑版本，以最大程度地减少平台更新带来的影响，让开发者们更轻松地完成更新。</p> \n<p>通过这次发布的开发者预览版 2，在发布路线上更进一步迈向 Beta 版本。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbELwv\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p> \n<p>在推出平台稳定版本后，就意味着系统行为、非 SDK 灰名单和 API 已经处于完成状态。现在，可以在 Pixel 2、3、3a 或 4 设备以及 Android 模拟器上开始进行兼容性测试。只需刷新系统版本，安装当前版本的应用，然后测试其完整流程即可，无需更改应用的 targetSdkVersion。</p> \n<p>为了帮助进行测试，安卓此次将多项重大变更设定为可逐一开启/关闭。可以通过开发者选项或 adb 来强制启用或禁用它们，前往官方文档了解更多信息。</p> \n<blockquote> \n <strong>官方文档: 发布日程</strong> \n <br>\n <a href=\"https://developer.android.google.cn/preview/overview\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> \n <br>\n <strong>行为变更</strong>\n <br>\n <a href=\"https://developer.android.google.cn/preview/behavior-changes-all\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> \n <br>\n <strong>官方文档:打开或关闭变化项目</strong> \n <br>\n <a href=\"https://developer.android.google.cn/preview/test-changes\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a>\n <br>\n <strong>Android 11 中有关限制非 SDK 接口的更新</strong>\n <br>\n <a href=\"https://developer.android.google.cn/preview/non-sdk-11\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbCJ1M\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"clipboard.png\" title=\"clipboard.png\"></span></p>', 'https://segmentfault.com/img/bVbELwv', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '8dfc62f227ae4076888ea4872e03cddd', '0', '3', '1', '2020-04-16 16:54:51', '2020-04-16 16:54:51');
INSERT INTO `tb_recommend` VALUES ('efced32c398a44958868bcdf8882ea4b', '小程序框架运行时性能大测评', '随着小程序在商业上的巨大成功，小程序开发在国内前端领域越来越受到重视，为了方便广大开发者更好地进行小程序开发，各类小程序框架也层出不穷，呈现出百花齐放的态势。但是到目前为止，业内一直没有出现一份全...', '<blockquote>\n 作者：董宏平(hiyuki)，滴滴出行小程序负责人，mpx框架负责人及核心作者\n</blockquote> \n<p>随着小程序在商业上的巨大成功，小程序开发在国内前端领域越来越受到重视，为了方便广大开发者更好地进行小程序开发，各类小程序框架也层出不穷，呈现出百花齐放的态势。但是到目前为止，业内一直没有出现一份全面、详细、客观、公正的小程序框架测评报告，为小程序开发者在技术选型时提供参考。于是我便筹划推出一系列文章，对业内流行的小程序框架进行一次全方位的、客观公正的测评，本文是系列文章的第一篇——运行时性能篇。</p> \n<p>在本文中，我们会对下列框架进行运行时性能测试(排名不分先后):</p> \n<ul> \n <li>wepy2(<a href=\"https://github.com/Tencent/wepy)\" rel=\"nofollow noreferrer\">https://github.com/Tencent/wepy)</a> @2.0.0-alpha.20</li> \n <li>uniapp(<a href=\"https://github.com/dcloudio/uni-app)\" rel=\"nofollow noreferrer\">https://github.com/dcloudio/u...</a> @2.0.0-26120200226001</li> \n <li>mpx(<a href=\"https://github.com/didi/mpx)\" rel=\"nofollow noreferrer\">https://github.com/didi/mpx)</a> @2.5.3</li> \n <li>chameleon(<a href=\"https://github.com/didi/chameleon)\" rel=\"nofollow noreferrer\">https://github.com/didi/chame...</a> @1.0.5</li> \n <li>mpvue(<a href=\"https://github.com/Meituan-Dianping/mpvue)\" rel=\"nofollow noreferrer\">https://github.com/Meituan-Di...</a> @2.0.6</li> \n <li>kbone(<a href=\"https://github.com/Tencent/kbone)\" rel=\"nofollow noreferrer\">https://github.com/Tencent/kb...</a> @0.8.3</li> \n <li>taro next(<a href=\"https://github.com/NervJS/taro)\" rel=\"nofollow noreferrer\">https://github.com/NervJS/taro)</a> @3.0.0-alpha.5</li> \n</ul> \n<p>其中对于kbone和taro next均以vue作为业务框架进行测试。</p> \n<p>运行时性能的测试内容包括以下几个维度：</p> \n<ul> \n <li>框架运行时体积</li> \n <li>页面渲染耗时</li> \n <li>页面更新耗时</li> \n <li>局部更新耗时</li> \n <li>setData调用次数</li> \n <li>setData发送数据大小</li> \n</ul> \n<p>框架性能测试demo全部存放于<a href=\"https://github.com/hiyuki/mp-framework-benchmark\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a> 中，欢迎广大开发者进行验证纠错及补全；</p> \n<h2>测试方案</h2> \n<p>为了使测试结果真实有效，我基于常见的业务场景构建了两种测试场景，分别是动态测试场景和静态测试场景。</p> \n<h3>动态测试场景</h3> \n<p>动态测试中，视图基于数据动态渲染，静态节点较少，视图更新耗时和setData调用情况是该测试场景中的主要测试点。</p> \n<p>动态测试demo模拟了实际业务中常见的长列表+多tab场景，该demo中存在两份优惠券列表数据，一份为可用券数据，另一份为不可用券数据，其中同一时刻视图中只会渲染展示其中一份数据，可以在上方的操作区模拟对列表数据的各种操作及视图展示切换(切tab)。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022249437\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"动态测试demo\" title=\"动态测试demo\"></span></p> \n<p><em>动态测试demo</em></p> \n<p>在动态测试中，我在外部通过函数代理的方式在初始化之前将App、Page和Component构造器进行代理，通过mixin的方式在Page的onLoad和Component的created钩子中注入setData拦截逻辑，对所有页面和组件的setData调用进行监听，并统计小程序的视图更新耗时及setData调用情况。该测试方式能够做到对框架代码的零侵入，能够跟踪到小程序全量的setData行为并进行独立的耗时计算，具有很强的普适性，代码具体实现可以查看<a href=\"https://github.com/hiyuki/mp-framework-benchmark/blob/master/utils/proxy.js\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a></p> \n<h3>静态测试场景</h3> \n<p>静态测试模拟业务中静态页面的场景，如运营活动和文章等页面，页面内具备大量的静态节点，而没有数据动态渲染，初始ready耗时是该场景下测试的重心。</p> \n<p>静态测试demo使用了我去年发表的一篇技术文章的html代码进行小程序适配构建，其中包含大量静态节点及文本内容。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022249436\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"静态测试demo\" title=\"静态测试demo\"></span></p> \n<p><em>静态测试demo</em></p> \n<h2>测试流程及数据</h2> \n<blockquote>\n 以下所有耗时类的测试数据均为微信小程序中真机进行5次测试计算平均值得出，单位均为ms。Ios测试环境为手机型号iPhone 11，系统版本13.3.1，微信版本7.0.12，安卓测试环境为手机型号小米9，系统版本Android10，微信版本7.0.12。\n</blockquote> \n<blockquote>\n 为了使数据展示不过于混乱复杂，文章中所列的数据以Ios的测试结果为主，安卓测试结论与Ios相符，整体耗时比Ios高3~4倍左右，所有的原始测试数据存放在\n <a href=\"https://github.com/hiyuki/mp-framework-benchmark/blob/master/rawData.csv\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a> \n</blockquote> \n<blockquote>\n 由于transform-runtime引入的core-js会对框架的运行时体积和运行耗时带来一定影响，且不是所有的框架都会在编译时开启transform-runtime，为了对齐测试环境，下述测试均在transform-runtime关闭时进行。\n</blockquote> \n<h3>框架运行时体积</h3> \n<p>由于不是所有框架都能够使用<code>webpack-bundle-analyzer</code>得到精确的包体积占用，这里我通过将各框架生成的demo项目体积减去native编写的demo项目体积作为框架的运行时体积。</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>demo总体积(KB)</th> \n   <th>框架运行时体积(KB)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>27</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>66</td> \n   <td>39</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>114</td> \n   <td>87</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>78</td> \n   <td>51</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>136</td> \n   <td>109</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>103</td> \n   <td>76</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>395</td> \n   <td>368</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>183</td> \n   <td>156</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native &gt; wepy2 &gt; mpx &gt; mpvue &gt; uniapp &gt; chameleon &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>wepy2和mpx在框架运行时体积上控制得最好；</li> \n <li>taro next和kbone由于动态渲染的特性，在dist中会生成递归渲染模板/组件，所以占用体积较大。</li> \n</ul> \n<h3>页面渲染耗时(动态测试)</h3> \n<p>我们使用<code>刷新页面</code>操作触发页面重新加载，对于大部分框架来说，页面渲染耗时是从触发刷新操作到页面执行onReady的耗时，但是对于像kbone和taro next这样的动态渲染框架，页面执行onReady并不代表视图真正渲染完成，为此，我们设定了一个特殊规则，在页面onReady触发的1000ms内，在没有任何操作的情况下出现setData回调时，以最后触发的setData回调作为页面渲染完成时机来计算真实的页面渲染耗时，测试结果如下：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>页面渲染耗时</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>60.8</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>64</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>56.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>52.6</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>56.4</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>117.8</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>98.6</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>89.6</td> \n  </tr> \n </tbody> \n</table> \n<blockquote>\n 该项测试的耗时并不等同于真实的渲染耗时，由于小程序自身没有提供performance api，真实渲染耗时无法通过js准确测试得出，不过从得出的数据来看该项数据依然具备一定的参考意义。\n</blockquote> \n<p>该项测试的结论为： <br>mpx ≈ chameleon ≈ uniapp ≈ native ≈ wepy2 &gt; taro next ≈ kbone ≈ mpvue</p> \n<p>结论分析：</p> \n<ul>\n <li>由于mpvue全量在页面进行渲染，kbone和taro next采用了动态渲染技术，页面渲染耗时较长，其余框架并无太大区别。</li>\n</ul> \n<h3>页面更新耗时(无后台数据)</h3> \n<p>这里后台数据的定义为data中存在但当前页面渲染中未使用到的数据，在这个demo场景下即为不可用券的数据，当前会在不可用券为0的情况下，对可用券列表进行各种操作，并统计更新耗时。</p> \n<p>更新耗时的计算方式是从数据操作事件触发开始到对应的setData回调完成的耗时</p> \n<blockquote>\n mpvue中使用了当前时间戳(new Date)作为超时依据对setData进行了超时时间为50ms的节流操作，该方式存在严重问题，当vue内单次渲染同步流程执行耗时超过50ms时，后续组件patch触发的setData会突破这个节流限制，以50ms每次的频率对setData进行高频无效调用。在该性能测试demo中，当优惠券数量超过500时，界面就会完全卡死。为了顺利跑完整个测试流程，我对该问题进行了简单修复，使用setTimeout重写了节流部分，确保在vue单次渲染流程同步执行完毕后才会调用setData发送合并数据，之后mpvue的所有性能测试都是基于这个patch版本来进行的，该patch版本存放在\n <a href=\"https://github.com/hiyuki/mp-framework-benchmark/blob/master/frameworks/mpvue/runtime/patch/index.js\" rel=\"nofollow noreferrer\">https://github.com/hiyuki/mp-...</a> \n</blockquote> \n<blockquote>\n 理论上来讲native的性能在进行优化的前提下一定是所有框架的天花板，但是在日常业务开发中我们可能无法对每一次setData都进行优化，以下性能测试中所有的native数据均采用修改数据后全量发送的形式来实现。\n</blockquote> \n<p>第一项测试我们使用<code>新增可用券(100)</code>操作将可用券数量由0逐级递增到1000：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>100</th> \n   <th>200</th> \n   <th>300</th> \n   <th>400</th> \n   <th>500</th> \n   <th>600</th> \n   <th>700</th> \n   <th>800</th> \n   <th>900</th> \n   <th>1000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>84.6</td> \n   <td>69.8</td> \n   <td>71.6</td> \n   <td>75</td> \n   <td>77.2</td> \n   <td>78.8</td> \n   <td>82.8</td> \n   <td>93.2</td> \n   <td>93.4</td> \n   <td>105.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>118.4</td> \n   <td>168.6</td> \n   <td>204.6</td> \n   <td>246.4</td> \n   <td>288.6</td> \n   <td>347.8</td> \n   <td>389.2</td> \n   <td>434.2</td> \n   <td>496</td> \n   <td>539</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>121.2</td> \n   <td>100</td> \n   <td>96</td> \n   <td>98.2</td> \n   <td>97.8</td> \n   <td>99.6</td> \n   <td>104</td> \n   <td>102.4</td> \n   <td>109.4</td> \n   <td>107.6</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>110.4</td> \n   <td>87.2</td> \n   <td>82.2</td> \n   <td>83</td> \n   <td>80.6</td> \n   <td>79.6</td> \n   <td>86.6</td> \n   <td>90.6</td> \n   <td>89.2</td> \n   <td>96.4</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>116.8</td> \n   <td>115.4</td> \n   <td>117</td> \n   <td>119.6</td> \n   <td>122</td> \n   <td>125.2</td> \n   <td>133.8</td> \n   <td>133.2</td> \n   <td>144.8</td> \n   <td>145.6</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>112.8</td> \n   <td>121.2</td> \n   <td>140</td> \n   <td>169</td> \n   <td>198.8</td> \n   <td>234.2</td> \n   <td>278.8</td> \n   <td>318.4</td> \n   <td>361.4</td> \n   <td>408.2</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>556.4</td> \n   <td>762.4</td> \n   <td>991.6</td> \n   <td>1220.6</td> \n   <td>1468.8</td> \n   <td>1689.6</td> \n   <td>1933.2</td> \n   <td>2150.4</td> \n   <td>2389</td> \n   <td>2620.6</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>470</td> \n   <td>604.6</td> \n   <td>759.6</td> \n   <td>902.4</td> \n   <td>1056.2</td> \n   <td>1228</td> \n   <td>1393.4</td> \n   <td>1536.2</td> \n   <td>1707.8</td> \n   <td>1867.2</td> \n  </tr> \n </tbody> \n</table> \n<p>然后我们按顺序逐项点击<code>删除可用券(all)</code> &gt; <code>新增可用券(1000)</code> &gt; <code>更新可用券(1)</code> &gt; <code>更新可用券(all)</code> &gt; <code>删除可用券(1)</code>：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>delete(all)</th> \n   <th>add(1000)</th> \n   <th>update(1)</th> \n   <th>update(all)</th> \n   <th>delete(1)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>32.8</td> \n   <td>295.6</td> \n   <td>92.2</td> \n   <td>92.2</td> \n   <td>83</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>56.8</td> \n   <td>726.4</td> \n   <td>49.2</td> \n   <td>535</td> \n   <td>530.8</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>43.6</td> \n   <td>584.4</td> \n   <td>54.8</td> \n   <td>144.8</td> \n   <td>131.2</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>41.8</td> \n   <td>489.6</td> \n   <td>52.6</td> \n   <td>169.4</td> \n   <td>165.6</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>39</td> \n   <td>765.6</td> \n   <td>95.6</td> \n   <td>237.8</td> \n   <td>144.8</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>103.6</td> \n   <td>669.4</td> \n   <td>404.4</td> \n   <td>414.8</td> \n   <td>433.6</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>120.2</td> \n   <td>4978</td> \n   <td>2356.4</td> \n   <td>2419.4</td> \n   <td>2357</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>126.6</td> \n   <td>3930.6</td> \n   <td>1607.8</td> \n   <td>1788.6</td> \n   <td>2318.2</td> \n  </tr> \n </tbody> \n</table> \n<blockquote>\n 该项测试中初期我update(all)的逻辑是循环对每个列表项进行更新，形如\n <code>listData.forEach((item)=&gt;{item.count++})</code>，发现在chameleon框架中执行界面会完全卡死，追踪发现chameleon框架中没有对setData进行异步合并处理，而是在数据变动时直接同步发送，这样在数据量为1000的场景下用该方式进行更新会高频触发1000次setData，导致界面卡死；对此，我在chameleon框架的测试demo中，将update(all)的逻辑调整为深clone产生一份更新后的listData，再将其整体赋值到this.listData当中，以确保该项测试能够正常进行。\n</blockquote> \n<p>该项测试的结论为： <br>native &gt; mpx ≈ uniapp &gt; chameleon &gt; mpvue &gt; wepy2 &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>mpx和uniapp在框架内部进行了完善的diff优化，随着数据量的增加，两个框架的新增耗时没有显著上升；</li> \n <li>wepy2会在数据变更时对props数据也进行setData，在该场景下造成了大量的无效性能损耗，导致性能表现不佳；</li> \n <li>kbone和taro next采用了动态渲染方案，每次新增更新时会发送大量描述dom结构的数据，与此同时动态递归渲染的耗时也远大于常规的静态模板渲染，使得这两个框架在所有的更新场景下耗时都远大于其他框架。</li> \n</ul> \n<h3>页面更新耗时(有后台数据)</h3> \n<p>刷新页面后我们使用<code>新增不可用券(1000)</code>创建后台数据，观察该操作是否会触发setData并统计耗时</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>back add(1000)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>45.2</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>174.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>89.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>142.6</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>134</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>0</td> \n  </tr> \n </tbody> \n</table> \n<blockquote>\n mpx进行setData优化时inspired by vue，使用了编译时生成的渲染函数跟踪模板数据依赖，在后台数据变更时不会进行setData调用，而kbone和taro next采用了动态渲染技术模拟了web底层环境，在上层完整地运行了vue框架，也达到了同样的效果。\n</blockquote> \n<p>然后我们执行和上面无后台数据时相同的操作进行耗时统计，首先是递增100：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>100</th> \n   <th>200</th> \n   <th>300</th> \n   <th>400</th> \n   <th>500</th> \n   <th>600</th> \n   <th>700</th> \n   <th>800</th> \n   <th>900</th> \n   <th>1000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>88</td> \n   <td>69.8</td> \n   <td>71.2</td> \n   <td>80.8</td> \n   <td>79.4</td> \n   <td>84.4</td> \n   <td>89.8</td> \n   <td>93.2</td> \n   <td>99.6</td> \n   <td>108</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>121</td> \n   <td>173.4</td> \n   <td>213.6</td> \n   <td>250</td> \n   <td>298</td> \n   <td>345.6</td> \n   <td>383</td> \n   <td>434.8</td> \n   <td>476.8</td> \n   <td>535.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>135.4</td> \n   <td>112.4</td> \n   <td>110.6</td> \n   <td>106.4</td> \n   <td>109.6</td> \n   <td>107.2</td> \n   <td>114.4</td> \n   <td>116</td> \n   <td>118.8</td> \n   <td>117.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>112.6</td> \n   <td>86.2</td> \n   <td>84.6</td> \n   <td>86.8</td> \n   <td>90</td> \n   <td>87.2</td> \n   <td>91.2</td> \n   <td>88.8</td> \n   <td>92.4</td> \n   <td>93.4</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>178.4</td> \n   <td>178.2</td> \n   <td>186.4</td> \n   <td>184.6</td> \n   <td>192.6</td> \n   <td>203.8</td> \n   <td>210</td> \n   <td>217.6</td> \n   <td>232.6</td> \n   <td>236.8</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>139</td> \n   <td>151</td> \n   <td>173.4</td> \n   <td>194</td> \n   <td>231.4</td> \n   <td>258.8</td> \n   <td>303.4</td> \n   <td>340.4</td> \n   <td>384.6</td> \n   <td>429.4</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>559.8</td> \n   <td>746.6</td> \n   <td>980.6</td> \n   <td>1226.8</td> \n   <td>1450.6</td> \n   <td>1705.4</td> \n   <td>1927.2</td> \n   <td>2154.8</td> \n   <td>2367.8</td> \n   <td>2617</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>482.6</td> \n   <td>626.2</td> \n   <td>755</td> \n   <td>909.6</td> \n   <td>1085</td> \n   <td>1233.2</td> \n   <td>1384</td> \n   <td>1568.6</td> \n   <td>1740.6</td> \n   <td>1883.8</td> \n  </tr> \n </tbody> \n</table> \n<p>然后按下表操作顺序逐项点击统计</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>delete(all)</th> \n   <th>add(1000)</th> \n   <th>update(1)</th> \n   <th>update(all)</th> \n   <th>delete(1)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>43.4</td> \n   <td>299.8</td> \n   <td>89.2</td> \n   <td>89</td> \n   <td>87.2</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>43.2</td> \n   <td>762.4</td> \n   <td>50</td> \n   <td>533</td> \n   <td>522.4</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>57.8</td> \n   <td>589.8</td> \n   <td>62.6</td> \n   <td>160.6</td> \n   <td>154.4</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>45.8</td> \n   <td>490.8</td> \n   <td>52.8</td> \n   <td>167</td> \n   <td>166</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>93.8</td> \n   <td>837</td> \n   <td>184.6</td> \n   <td>318</td> \n   <td>220.8</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>124.8</td> \n   <td>696.2</td> \n   <td>423.4</td> \n   <td>419</td> \n   <td>430.6</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>121.4</td> \n   <td>4978.2</td> \n   <td>2331.2</td> \n   <td>2448.4</td> \n   <td>2348</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>129.8</td> \n   <td>3947.2</td> \n   <td>1610.4</td> \n   <td>1813.8</td> \n   <td>2290.2</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native &gt; mpx &gt; uniapp &gt; chameleon &gt; mpvue &gt; wepy2 &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>具备模板数据跟踪能力的三个框架mpx，kbone和taro next在有后台数据场景下耗时并没有显著增加；</li> \n <li>wepy2当中的diff精度不足，耗时也没有产生明显变化；</li> \n <li>其余框架由于每次更新都会对后台数据进行deep diff，耗时都产生了一定提升。</li> \n</ul> \n<h3>页面更新耗时(大数据量场景)</h3> \n<blockquote>\n 由于mpvue和taro next的渲染全部在页面中进行，而kbone的渲染方案会额外新增大量的自定义组件，这三个框架都会在优惠券数量达到2000时崩溃白屏，我们排除了这三个框架对其余框架进行大数据量场景下的页面更新耗时测试\n</blockquote> \n<p>首先还是在无后台数据场景下使用<code>新增可用券(1000)</code>将可用券数量递增至5000：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>1000</th> \n   <th>2000</th> \n   <th>3000</th> \n   <th>4000</th> \n   <th>5000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>332.6</td> \n   <td>350</td> \n   <td>412.6</td> \n   <td>498.2</td> \n   <td>569.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>970.2</td> \n   <td>1531.4</td> \n   <td>2015.2</td> \n   <td>2890.6</td> \n   <td>3364.2</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>655.2</td> \n   <td>593.4</td> \n   <td>655</td> \n   <td>675.6</td> \n   <td>718.8</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>532.2</td> \n   <td>496</td> \n   <td>548.6</td> \n   <td>564</td> \n   <td>601.8</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>805.4</td> \n   <td>839.6</td> \n   <td>952.8</td> \n   <td>1086.6</td> \n   <td>1291.8</td> \n  </tr> \n </tbody> \n</table> \n<p>然后点击<code>新增不可用券(5000)</code>将后台数据量增加至5000，再测试可用券数量递增至5000的耗时：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>back add(5000)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>117.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>511.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>285</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>0</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>824</td> \n  </tr> \n </tbody> \n</table> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>1000</th> \n   <th>2000</th> \n   <th>3000</th> \n   <th>4000</th> \n   <th>5000</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>349.8</td> \n   <td>348.4</td> \n   <td>430.4</td> \n   <td>497</td> \n   <td>594.8</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>1128</td> \n   <td>1872</td> \n   <td>2470.4</td> \n   <td>3263.4</td> \n   <td>4075.8</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>715</td> \n   <td>666.8</td> \n   <td>709.2</td> \n   <td>755.6</td> \n   <td>810.2</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>538.8</td> \n   <td>501.8</td> \n   <td>562.6</td> \n   <td>573.6</td> \n   <td>595.2</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>1509.2</td> \n   <td>1672.4</td> \n   <td>1951.8</td> \n   <td>2232.4</td> \n   <td>2586.2</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native &gt; mpx &gt; uniapp &gt; chameleon &gt; wepy2</p> \n<p>结论分析：</p> \n<ul>\n <li>在大数据量场景下，框架之间基础性能的差异会变得更加明显，mpx和uniapp依然保持了接近原生的良好性能表现，而chameleon和wepy2则产生了比较显著的性能劣化。</li>\n</ul> \n<h3>局部更新耗时</h3> \n<p>我们在可用券数量为1000的情况下，点击任意一张可用券触发选中状态，以测试局部更新性能</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>toggleSelect(ms)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>2</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>2.6</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>2.8</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>2.2</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>2</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>289.6</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>2440.8</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>1975</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>native ≈ chameleon ≈ mpx ≈ wepy2 ≈ uniapp &gt; mpvue &gt; taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>可以看出所有使用了原生自定义组件进行组件化实现的框架局部更新耗时都极低，这足以证明小程序原生自定义组件的优秀性和重要性；</li> \n <li>mpvue由于使用了页面更新，局部更新耗时显著增加；</li> \n <li>kbone和taro next由于递归动态渲染的性能开销巨大，导致局部更新耗时同样巨大。</li> \n</ul> \n<h3>setData调用</h3> \n<p>我们将<code>proxySetData</code>的count和size选项设置为true，开启setData的次数和体积统计，重新构建后按照以下流程执行系列操作，并统计setData的调用次数和发送数据的体积。</p> \n<p>操作流程如下：</p> \n<ol> \n <li>100逐级递增可用券(0-&gt;500)</li> \n <li>切换至不可用券</li> \n <li>新增不可用券(1000)</li> \n <li>100逐级递增可用券(500-&gt;1000)</li> \n <li>更新可用券(all)</li> \n <li>切换至可用券</li> \n</ol> \n<p>操作完成后我们使用<code>getCount</code>和<code>getSize</code>方法获取累积的setData调用次数和数据体积，其中数据体积计算方式为JSON.stringify后按照utf-8编码方式进行体积计算，统计结果为：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>count</th> \n   <th>size(KB)</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>14</td> \n   <td>803</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>3514</td> \n   <td>1124</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>16</td> \n   <td>2127</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>14</td> \n   <td>274</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>8</td> \n   <td>261</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>2515</td> \n   <td>319</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>22</td> \n   <td>10572</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>9</td> \n   <td>2321</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>mpx &gt; uniapp &gt; native &gt; chameleon &gt; wepy2 &gt; taro next &gt; mpvue &gt; kbone</p> \n<p>结论分析：</p> \n<ul> \n <li>mpx框架成功实现了理论上setData的最优；</li> \n <li>uniapp由于缺失模板追踪能力紧随其后；</li> \n <li>chameleon由于组件每次创建时都会进行一次不必要的setData，产生了大量无效setData调用，但是数据的发送本身经过diff，在数据发送量上表现不错；</li> \n <li>wepy2的组件会在数据更新时调用setData发送已经更新过的props数据，因此也产生了大量无效调用，且diff精度不足，发送的数据量也较大；</li> \n <li>taro next由于上层完全基于vue，在数据发送次数上控制到了9次，但由于需要发送大量的dom描述信息，数据发送量较大；</li> \n <li>mpvue由于使用较长的数据路径描述数据对应的组件，也产生了较大的数据发送量；</li> \n <li>kbone对于setData的调用控制得不是很好，在上层运行vue的情况依然进行了22次数据发送，且发送的数据量巨大，在此流程中达到了惊人的10MB。</li> \n</ul> \n<h3>页面渲染耗时(静态测试)</h3> \n<p>此处的页面渲染耗时与前面描述的动态测试场景中相同，测试结果如下：</p> \n<table> \n <thead>\n  <tr> \n   <th> </th> \n   <th>页面渲染耗时</th> \n  </tr>\n </thead> \n <tbody> \n  <tr> \n   <td>native</td> \n   <td>70.4</td> \n  </tr> \n  <tr> \n   <td>wepy2</td> \n   <td>86.6</td> \n  </tr> \n  <tr> \n   <td>mpvue</td> \n   <td>115.2</td> \n  </tr> \n  <tr> \n   <td>uniapp</td> \n   <td>69.6</td> \n  </tr> \n  <tr> \n   <td>mpx</td> \n   <td>66.6</td> \n  </tr> \n  <tr> \n   <td>chameleon</td> \n   <td>65</td> \n  </tr> \n  <tr> \n   <td>kbone</td> \n   <td>144.2</td> \n  </tr> \n  <tr> \n   <td>taro next</td> \n   <td>119.8</td> \n  </tr> \n </tbody> \n</table> \n<p>该项测试的结论为： <br>chameleon ≈ mpx ≈ uniapp ≈ native &gt; wepy2 &gt; mpvue ≈ taro next &gt; kbone</p> \n<p>结论分析：</p> \n<ul>\n <li>除了kbone和taro next采用动态渲染耗时增加，mpvue使用页面模板渲染性能稍差，其余框架的静态页面渲染表现都和原生差不多。</li>\n</ul> \n<h2>结论</h2> \n<p>综合上述测试数据，我们得到最终的小程序框架运行时性能排名为： <br>mpx &gt; uniapp &gt; chameleon &gt; wepy2 &gt; mpvue &gt; taro next &gt; kbone</p> \n<h2>一点私货</h2> \n<p>虽然kbone和taro next采用了动态渲染技术在性能表现上并不尽如人意，但是我依然认为这是很棒的技术方案。虽然本文从头到位都在进行性能测试和对比，但性能并不是框架的全部，开发效率和高可用性仍然是框架的重心，开发效率相信是所有框架设计的初衷，但是高可用性却在很大程度被忽视。从这个角度来说，kbone和taro next是非常成功的，不同于过去的转译思路，这种从抹平底层渲染环境的做法能够使上层web框架完整运行，在框架可用性上带来非常大的提升，非常适合于运营类简单小程序的迁移和开发。</p> \n<p>我主导开发的mpx框架(<a href=\"https://github.com/didi/mpx)\" rel=\"nofollow noreferrer\">https://github.com/didi/mpx)</a> 选择了另一条道路解决可用性问题，那就是基于小程序原生语法能力进行增强，这样既能避免转译web框架时带来的不确定性和不稳定性，同时也能带来非常接近于原生的性能表现，对于复杂业务小程序的开发者来说，非常推荐使用。在跨端输出方面，mpx目前能够完善支持业内全部小程序平台和web平台的同构输出，滴滴内部最重要最复杂的小程序——滴滴出行小程序完全基于mpx进行开发，并利用框架提供的跨端能力对微信和支付宝入口进行同步业务迭代，大大提升了业务开发效率。</p>', 'https://segmentfault.com/img/remote/1460000022249437', '6fbfa4aaad3a43458f21c8acf0038ac5', '63c4e1e7ec204b43a62065a3ced4c2ce,3b375646301546259a8fb29d74ae4447,2ff36c3d3aec49d8a19cd1d17c6e9a7e,66df11ef95064996ba39f328e25451f5', '0', '3', '1', '2020-04-16 16:47:20', '2020-04-16 16:47:20');
INSERT INTO `tb_recommend` VALUES ('f1dc5a6de51b4b58882a1c4ea7068dc1', 'xcode高版本启动RN项目常见错误', 'xcode编译报错：\'config.h\' file not found 解决方案 {代码...} 启动报错：Unknown argument type \'__attribute__\' in method -[RCTAppState getCurrentAppState:error:]. Extend RCTConvert to support this typ...', '<h4>xcode编译报错：\'config.h\' file not found</h4> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022317133\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image-20200409145441860\" title=\"image-20200409145441860\"></span></p> \n<p>解决方案</p> \n<pre><code class=\"js\">cd node_modules/react-native/third-party/glog-0.3.4\n../../scripts/ios-configure-glog.sh</code></pre> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022317134\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image-20200409150129405\" title=\"image-20200409150129405\"></span></p> \n<h4>启动报错：Unknown argument type \'__attribute__\' in method -[RCTAppState getCurrentAppState:error:]. Extend RCTConvert to support this type.</h4> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022317135\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Simulator Screen Shot - iPhone 11 Pro Max - 2020-04-09 at 15.07.23\" title=\"Simulator Screen Shot - iPhone 11 Pro Max - 2020-04-09 at 15.07.23\"></span></p> \n<p>我的xcode版本：Version 11.0 (11A420a) </p> \n<p>Mac系统版本：10.14.6 </p> \n<p><strong>原因</strong>：<code>Xcode11(iOS13)</code>中对未使用的接口选择器的参数<code>unused</code>字符串属性进行了更改成了<code>__unused__</code>，导致<code>ReactNative</code>动态收集接口时不能把声明的接口进行导入，运行时无法查找到该接口导致的错误。</p> \n<p><strong>解决方案</strong>：找到文件<code>/node_modules/react-native/React/Base/RCTModuleMethod.mm</code></p> \n<p>修改方法：</p> \n<pre><code class=\"objc\">static BOOL RCTParseUnused(const char **input)\n{\n  return RCTReadString(input, \"__unused\") ||\n         RCTReadString(input, \"__attribute__((unused))\");\n}</code></pre> \n<p>修改成：</p> \n<pre><code class=\"objc\">static BOOL RCTParseUnused(const char **input)\n{\n\n  return RCTReadString(input, \"attribute((unused))\") ||\n         RCTReadString(input, \"__attribute__((__unused__))\") ||\n         RCTReadString(input, \"__unused\");\n}</code></pre>', 'https://segmentfault.com/img/remote/1460000022317133', '1894b118d35d44cb8fe8009529c4154b', 'df5b4b0986d44f169be91f7496d1dbc5,bc0022273e34499a9bc31681102eb488', '0', '3', '1', '2020-04-16 16:50:15', '2020-04-16 16:50:15');
INSERT INTO `tb_recommend` VALUES ('f1f625c8a47541978bcd887642433d8d', '想进美团不知道选哪个技术岗位？这里有一份通关秘籍！', '随着互联网的高速发展，技术岗位在不断地细分，比如软件开发不仅分为前端和后端，前端会分为Web、iOS和Android三个方向，后端又分为后台、系统、数据等。现在异常火爆的AI方向更是让人「眼花缭乱」，深度学习、数...', '<p>春暖花开，美团春招已经启动，针对校招和社招开放了几千个职位，其中很大部分都是技术岗位。</p> \n<p>随着互联网的高速发展，技术岗位在不断地细分，比如软件开发不仅分为前端和后端，前端会分为Web、iOS和Android三个方向，后端又分为后台、系统、数据等。现在异常火爆的AI方向更是让人「眼花缭乱」，深度学习、数据挖掘、NLP、人脸识别、知识图谱等等。那么，我们应该如何更好地选择适合自己的技术岗位呢？</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159819\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>今天我们就逐一介绍各个技术岗位的区别以及对应的岗位要求，然后再解读一下美团面试官会考核的基本能力和软素质，最后我们还附上了来自美团学长学姐的建议，希望这份「通关秘籍」能帮助大家对号入座，找到自己理想的工作。</p> \n<h2>一、美团技术团队分哪些专业方向？</h2> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159822\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>经过多年耕耘和沉淀，美团技术团队已经建成了比较完备的技术体系，有基于主流开源技术加自研的大数据、基础架构、复杂业务系统平台，以及比较完备的运维、安全、风控系统。目前，美团技术团队主要分成前端、后台、系统、数据、测试、运维、算法等技术方向（内部称为通道），每个方向下面又可能包括几种岗位。</p> \n<p>特别要提醒大家注意的是，各个方向和岗位的竞争激烈程度每年是不一样的。今年的推荐算法和嵌入式系统、计算机视觉竞争比较激烈，而前端尤其是移动客户端开发、测试、硬件、安全、数据领域则相对平和。以下是2020年春季美团技术团队部分岗位（实习生）的投递录用比（已经收到的简历数：拟招聘的岗位数），供大家参考：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159821\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>前端开发工程师</h3> \n<p>前端也称为大前端，分为Web前端和终端两大方向。作为连接用户和企业的技术工种，前端涉及的领域越来越广泛，已经不再局限于桌面、手机等环境。在目前大前端融合、5G的趋势下，想象空间越来越大，给前端工程师带来广阔的成长发展前景。</p> \n<p><strong>选择前端的7大理由：</strong></p> \n<ul> \n <li>前端是最接近用户的技术团队，能够第一时间了解用户的需求，是那些对用户体验、交互感兴趣的同学的最佳选择。</li> \n <li>前端是最容易成为全栈工程师及技术「多面手」的岗位。前端能快速实现原型、快速给用户推出新产品或者新的用户体验，很容易获得职业层面的成就感。</li> \n <li>前端技术发展迅速，这里特别欢迎有创造力、有想法的同学，技术栈广，有众多的岗位选择和发展空间。</li> \n <li>前端是美团技术团队中交流最广泛、交流渠道最多、交流氛围最好的团队，在这里你能够认识足够多的技术大牛，也提供足够大的舞台让有想法的同学去展现自己的风采。</li> \n <li>相比有些学习曲线比较陡峭的技术岗位，前端的学习成长曲线相对平滑。因为绝大多数高校都不开设前端开发的相关课程，而且前端技术还在不断发展和更迭，前端开发领域对所有的新入门同学都比较友好，这是一片蓝海，等待有梦想的你去不断开拓。</li> \n <li>前端是代码和视觉的结合，是技术和艺术的交融，前端能带给用户最简单直接、最炫酷的视觉享受和用户体验。</li> \n <li>前端开发是目前互联网领域最炙手可热的技术方向之一，各个公司都高薪争夺前端领域的技术人才，未来可期。</li> \n</ul> \n<p><strong>Web前端</strong></p> \n<blockquote>\n 对应岗位名称：前端开发，Web前端开发。\n</blockquote> \n<p><strong>美团对前端工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ol> \n <li> <strong>专业背景</strong>：专业技能主要覆盖计算机专业的基础课程，包括数据结构、计算机组成原理、计算机网络、操作系统、数据库、软件工程、C++或Java编程语言等。此外，现在前端对算法的要求越来越高，在算法方面理解深刻的同学，会有加分。</li> \n <li> <strong>专业知识</strong>：扎实的6项基础知识：HTML、CSS、JavaScript、移动Web开发、调试、HTTP网络知识。</li> \n <li> <strong>技术能力</strong>：前端工程能力，构建和持续集成。特别是Coding能力，能够准确地理解需求，并快速实现高质量的代码。</li> \n <li> <strong>加分项</strong>：掌握Web安全基础知识、浏览器组成及原理方面的基础知识，熟练使用常用的前端框架（React/Vue等）并对其原理有一定的认识。</li> \n</ol> \n<p><strong>终端</strong></p> \n<blockquote>\n 对应岗位名称：iOS开发，Android开发，移动端开发，客户端开发。\n</blockquote> \n<p>目前，终端也称移动端、客户端，主要按两大平台分为Android开发和iOS开发。这个方向的优点是对同学们的经验要求较少，只要有较好的编程基础和比较扎实的计算机基础知识，都欢迎加入。</p> \n<p><strong>Android开发工程师</strong></p> \n<p>在过去十年中，Android已经成为和iOS并驾齐驱的移动开放平台。未来十年，Android必将在万物互联的生态中占据更加重要的位置，未来可期。虽然「移动端」的概念被提及的次数越来减少，但目前手机的应用市场中每天仍有几百万量级的App在活跃，而这都需要移动端工程师去开发完成。</p> \n<p>此外，App是企业和用户交互的桥梁，直接影响用户体验以及用户对公司品牌的感受，其重要性不言而喻。在美团Android开发团队，你写的代码可以影响到数亿用户，你可以把一个个创新的想法，在亲人和朋友的手机上变成实实在在、可以看得见摸得着的界面，相信这一定会让你收获满满的成就感。</p> \n<p><strong>美团对Android工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ol> \n <li> <strong>专业背景</strong>：了解计算机基础知识，包括计算机原理、操作系统、网络、算法等；</li> \n <li> <strong>技术知识</strong>：重点强调Java，其次是C/C++和数据结构，这些是最基本的要求，然后是Android开发的基础知识；</li> \n <li> <strong>编码能力</strong>：具备一定的编码能力，包括边界条件、编码风格等。</li> \n</ol> \n<p><strong>iOS开发工程师</strong></p> \n<p>如果你希望自己的工作成果被亿万人直接使用，那么就来做客户端吧！如果你觉得iPhone真香，那么就来做iOS开发工程师吧！在这里，你可以感受技术与体验的完美结合，在成就用户的同时成就自己。在美团，iOS工程师有着明确的培养路径，美团技术学院提供了丰富的技术文档和课程来帮助大家成长。值得一提的是，校招候选人不要求有iOS开发经验，只要具备良好的CS基础便可以。加入美团，我们会帮你快速成长为一名优秀的iOS工程师。</p> \n<p>在美团技术团队，iOS工程师主要责任就是打造美团和大众点评等超级App，为它「添砖加瓦」。我们追求更高的代码质量，让Bug远离用户；我们追求更高的编程效率，可以让新功能更快地交付给用户。当然，在做完业务需求之余，你可以投身研究一些OC语言的特性、App的性能优化、Hybrid技术等等。你也可以探索一些工程层面的奥义，比如组件化、平台化、插件化、动态化、自动化，任君遨游。</p> \n<p>目前，大家纷纷涌向人工智能、机器学习、图像识别等比较热门的技术领域，千军万马挤独木桥，其难度可想而知。殊不知iOS领域因近些年人才过度稀缺，市场发展前景非常好。更重要的是，当你成为一名iOS工程师以后，你将常年接触iOS与Mac系统，杜绝工作环境中的脏、乱、差，体验优雅、高效、丝滑的开发流程，这也将直接影响到你的生活习惯，让你变成一个有追求、有审美、有品位的「攻城狮」。</p> \n<p><strong>美团对iOS工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ol> \n <li> <strong>专业背景</strong>：了解计算机基础知识，包括计算机原理、操作系统、网络等，这是客户端开发的通用技能；</li> \n <li> <strong>技术能力</strong>：基本数据结构与算法，Coding能力；</li> \n <li> <strong>加分项</strong>：对OC语言特性能够熟练掌握，了解跨端技术，有一定的技术广度。</li> \n</ol> \n<p>技术细节请参考美团前端方向的技术文章：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2018/08/09/waimai-flutter-practice.html\" rel=\"nofollow noreferrer\">Flutter的原理及美团的实践</a></li> \n <li><a href=\"https://tech.meituan.com/2019/12/19/meituan-mrn-practice.html\" rel=\"nofollow noreferrer\">React Native在美团外卖客户端的实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/11/01/swift-compile-performance-optimization.html\" rel=\"nofollow noreferrer\">深入剖析Swift性能优化</a></li> \n <li><a href=\"https://tech.meituan.com/2018/03/16/front-end-web-architecture.html\" rel=\"nofollow noreferrer\">美团点评金融平台Web前端技术体系</a></li> \n <li><a href=\"https://tech.meituan.com/2019/10/17/android-java-8.html\" rel=\"nofollow noreferrer\">Android 兼容 Java 8 语法特性的原理分析</a></li> \n</ul> \n<h3>后台/系统开发工程师</h3> \n<blockquote>\n 对应岗位名称：Java开发，后端开发，系统开发，服务端开发。\n</blockquote> \n<p>后端在美团又分为后台和系统两个方向。这是最体现以互联网技术改造实体经济的方向。</p> \n<p>后台方向总体偏to C（消费者）的产品系统及其依赖的基础平台的研发，包括但不限于：Web API、商品/库存/价格系统、交易系统、促销引擎、支付系统、评价系统、存储系统、消息队列、OCTO、计算平台、检索架构等等。比如我们每一次点外卖时的交易履约都是由后台系统来提供服务的。</p> \n<p>后台方向承担了美团基础架构以及各条业务线工程系统的建设，为美团的业务提供了云端保障，包括功能开发、平台建设、基础架构升级等工作，在巨大流量下，为用户提供高性能、高扩展、高并发、高可用、高效率的服务，支撑美团各业务提升运营效率、决策效率，提供良好的用户和商家体验。后台通道也是美团内部最大的一个技术通道。</p> \n<p>系统方向偏商户端和公司内部的核心系统的研发，通过技术手段不断提升供给侧效率，降低成本，提升用户体验，促进业务目标达成。随着业务在不断发展变化，美团的新业务在不断涌现，系统方向面临着更复杂、更新鲜的业务场景，也有更多的业务挑战等待着你来解决。</p> \n<p>加入美团系统通道，你能够接触线上线下复杂业务，并通过技术手段为业务赋能，进而快速成长为一名懂业务的技术专家。对业务的深刻理解和实践经验会让你身价翻倍，在未来长期的职业发展上有更多选择。美团系统通道牛人多，学习机会多，个人成长快，可以帮你全方位进行提升。值得一提的是，系统通道的成长路径后半段是比较广阔的，离业务更近，能更好地理解公司的商业模式。对于那些有野心的、未来想去创业的同学来说，系统通道是比较合适的方向。</p> \n<p><strong>选择后台方向的5大理由：</strong></p> \n<ul> \n <li>互联网已经从「黄金时代」走到「青铜时代」，精细化运营对面向用户的后台业务系统提出更高的要求，业务场景复杂多变，后台/系统开发工程师面临更大的挑战，且招聘需求量也非常大。</li> \n <li>后台/系统是支持业务最核心的一环，技术体系广且深，对特别优秀的候选人来说，未来可以选择做业务，也可以选择做技术。发展空间几乎没有上限，只要你足够努力。</li> \n <li>在美团后台/系统通道，行业大牛众多，直接解决复杂业务系统架构设计，面向全社会的用户和商家，可以参与最前沿技术的研究与实践。</li> \n <li>美团后台/系统通道采用导师制，一对一培养。能帮助候选人提升分布式架构设计能力，在丰富的一线实践中，快速成长为优秀的互联网后台开发者。</li> \n <li>喜欢逻辑实现，喜欢高并发、高可用、高性能业务场景技术挑战同学比较适合选择后台/系统通道。</li> \n</ul> \n<p>这里是亿级用户规模的平台，这里有持续快速增长的业务，而后台/系统工程师能够负责驱动并引领业务的发展，这就是我们的价值。期待优秀的你加入我们！</p> \n<p><strong>美团对系统/后台开发工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ul> \n <li>计算机基础扎实，熟悉计算机相关的知识包括数据结构、算法、操作系统、计算机网络、面向对象编程、设计模式、多线程等等。</li> \n <li>Coding能力，掌握至少一门开发语言（Java/C++等）。</li> \n <li>了解常见的后台/系统开发技术，最好阅读过一些项目的源码。</li> \n</ul> \n<p>技术细节请参考美团后台/系统方向的技术文章：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2019/09/05/java-bytecode-enhancement.html\" rel=\"nofollow noreferrer\">字节码增强技术探索</a></li> \n <li><a href=\"https://tech.meituan.com/2018/11/15/java-lock.html\" rel=\"nofollow noreferrer\">不可不说的Java“锁”事</a></li> \n <li><a href=\"https://tech.meituan.com/2017/12/22/ddd-in-practice.html\" rel=\"nofollow noreferrer\">领域驱动设计在互联网业务开发中的实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/11/15/docker-architecture-and-evolution-practice.html\" rel=\"nofollow noreferrer\">美团容器平台架构及容器技术实践</a></li> \n <li><a href=\"https://tech.meituan.com/2016/02/04/high-availability-systems-dianping.html\" rel=\"nofollow noreferrer\">高可用性系统在大众点评的实践与经验</a></li> \n</ul> \n<h3>数据开发工程师</h3> \n<blockquote>\n 对应岗位名称：数据开发，数据仓库工程师，大数据工程师。\n</blockquote> \n<p>小数字成就小人生，大数据创造大未来。数据是DT时代的「石油」已经成为业内共识。数据技术是企业业务发展的根基，小到一个功能模块的设计优化、产品精细化运营、用户精准化营销，中到C端千人千面的产品体验、B端数字化赋能，大到公司战略定制和决策、创新业务人工智能的突破，数据的应用已经是面面俱到。而且大数据已经成为各个公司的基础设施，伴随着AI技术浪潮的到来，大数据也会变得越发重要。</p> \n<p>数据通道主要涵盖两大技术方向，一个是数据研发方向，涵盖面向数据资产的数据清洗、加工、整合、挖掘、管理、运营等技术领域，主要包括批处理和实时数据仓库的建设、数据管理、数据价值落地的同学，以及做数据运营的同学。另一个是数据系统研发方向，涵盖批处理、实时数仓开发工具链、BI系统、数据管理系统等数据系统研发同学。数据开发通道希望通过数仓建设、数据系统建设，来提升公司数据质量、数据效率、数据安全，以数据驱动的方式帮助美团完成业务目标，持续提高公司的运营效率和核心竞争力。</p> \n<p>美团数据通道负责上游系统数据的集成、建模、应用数据和系统的研发，支持和赋能业务、商分和产研等部门在业务运营、管理、策略迭代方面的决策。数据不是单纯的数字，我们已经通过对数据进行集成、处理、分析和管理，逐步将数据打造成为美团最为重要的资产。此外，数据通道还为美团提供基于大数据体系的基础数据平台、数仓平台和商业分析平台，为美团的数字化运营提供了提供高质量、高效率的数据服务。</p> \n<p><strong>选择美团数据通道的5大理由：</strong></p> \n<ul> \n <li>数据是一个非常综合的领域，同学们将有机会得到多种技能的训练和培养。数据通道同学可以选择大数据平台搭建、数据资产构建、数据分析、数据挖掘和数据服务化等不同方向，可学习的开发技能包括系统开发技能、数据建模技能、数据应用开发技能等不同方面。在美团，数据人才的发展会有更多的可能性。</li> \n <li>数据是与业务贴近程度最高的技术门类之一，同学们在为业务提供数据解决方案的过程中，将会得到商业思维和业务管理能力的训练。</li> \n <li>数据相关技术和技能「浩如烟海」，非常适合对技术追求长期有耐心的同学。而且任何行业和领域的工作都需要数据能力的直接支撑。未来数据人才培养难度较高，市场需求也非常旺盛。</li> \n <li>美团拥有本地生活领域海量的数据资源、丰富的数据应用场景以及极具挑战性的工作。在美团数据通道，你将有机会参与到PB级数据项目实践，参与业界一流的分析平台建设，应用到业界最先进的技术和知识，接触到吃喝玩乐住行的全链条数据。</li> \n <li>美团的数据体系属于国内顶尖级别，数据通道通过精准、专业的组织建设，为公司的数据开发者带来归属感，提供了专业学习交流机制以及职业晋升指导和渠道。特别是对校招生来说，美团还为大家提供贴心的技术学习和职业发展指导，能够帮助大家迅速成长为一名合格的大数据专业人才。</li> \n</ul> \n<p><strong>美团对数据开发工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ul> \n <li>计算机基础以及大数据通用技术的底层原理，包括数据结构与算法、操作系统、计算机网络、数据库原理、统计分析与概率、数学分析以及SQL语言等等；</li> \n <li>Coding的能力，掌握至少一门编程语言（Java/Python/C等）；</li> \n <li>加分项：有一定的数据逻辑能力，对大数据开源框架有认知，了解分布式计算、消息队列、KV存储等等，了解数据挖掘与机器学习基本理论和方法。</li> \n</ul> \n<p>细节可以通过美团数据方向的技术文章来体验：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2020/03/12/delivery-data-governance.html\" rel=\"nofollow noreferrer\">美团配送数据治理实践</a></li> \n <li><a href=\"https://tech.meituan.com/2017/08/25/dataplat-coalesce.html\" rel=\"nofollow noreferrer\">美团数据平台融合实践</a></li> \n <li><a href=\"https://tech.meituan.com/2013/12/05/meituan-datawarehouse-evolution.html\" rel=\"nofollow noreferrer\">美团数据仓库的演进</a></li> \n <li><a href=\"https://tech.meituan.com/2018/05/20/kerberos-big-data-platform.html\" rel=\"nofollow noreferrer\">美团数据平台Kerberos优化实战</a></li> \n <li><a href=\"https://tech.meituan.com/2018/03/20/user-funnel-analysis-design-build.html\" rel=\"nofollow noreferrer\">每天数百亿用户行为数据，美团点评怎么实现秒级转化分析？</a></li> \n</ul> \n<h3>测试工程师</h3> \n<blockquote>\n 对应岗位名称：测试开发，测试工程师，QA工程师。\n</blockquote> \n<p>互联网已逐步成为人们生活和工作中不可或缺的部分，相应的，用户对互联网产品的用户体验和质量要求随之「水涨船高」，质量低、体验差的产品也将越来越难以留在赛道上。这样的背景下，测试工程师的岗位面临着新的挑战和机遇。美团对测试工程师的期待远不止是传说中「点点点」式的「黑盒」功能测试，而是需要与产品、研发、业务团队密切协作，以专业能力保证数亿消费者的用户体验，支撑数百万商家的线上化运营。</p> \n<p>守住质量底线，交付用户价值。美团测试工程师的岗位职责除了基于对用户需求和被测系统的理解、设计并执行完备高效的测试用例从而保证交付质量外，还需要不断推动被测系统改进可测性设计、探索高效测试方法、持续提升自动化测试水平。在此过程中不断完善的测试工具、持续交付基础设施将使得我们的研发过程日趋高效，全过程、多维度的研发过程数据将驱动我们的技术团队持续进化。一个业务需求从发起到最终交付用户使用，测试工程师的角色无处不在，全方位的为稳定的交付质量和良好的用户体验保驾护航。</p> \n<p>美团测试通道能力模型全面且立体，测试工程师的成长路径涵盖测试技术专家、业务方向质量顾问、测试工具与基础设施开发者等不同诉求。针对上述细分领域，美团测试通道精心准备了适用于初、中、高阶的培训课程。目前培训课程已经过多轮评审和迭代，课程讲师均是公司内各个领域的佼佼者。期待有朝一日你也成为光荣的讲师团成员！</p> \n<p><strong>选择美团测试通道的4大理由：</strong></p> \n<ul> \n <li>适于不同类型人才发挥的空间，无论是热衷技术还是长于协作，热情洋溢或是冷静心细，都能找到展现个人精彩的舞台；</li> \n <li>有利于锻炼综合能力，从业务理解到技术架构，从沟通协作到效率提升，相较于「固守一隅」的开发人员拥有更为广阔的视角；</li> \n <li>测试通道拥有清晰的人才模型、健全的职级体系、多样化的成长路径，资深导师辅导、开放的技术氛围帮助每位同学成长；</li> \n <li>立足完整的测试理论基础和技术体系，面临万物互联和智能化时代伟大挑战，有机会与我们一同探索测试领域全新的未来。</li> \n</ul> \n<p>当然，在面对多种多样的被测系统时，测试工程师需要对它们的技术原理和实现方法有基本的了解，才能有针对性的进行更深入的测试。在遇到各式各样的可测性难题时，测试工程师需要打破边界、发散思维，从别的领域寻求启发，以突破本领域的思维定势。当然最重要的一点是学习能力，业务领域和技术领域的知识浩渺如大海，扎实的基础知识是成长的基石，而良好的学习习惯，快速的学习能力，以及驱动自己不断探索未知领域的好奇心才是成长的持续动力。</p> \n<p><strong>美团对测试工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ul> \n <li>计算机技术基础，包括网络、数据结构、数据库、操作系统、编程语言、软件测试/软件工程等等；对校招生不要求有丰富的工作经验，更注重技术基础能力是否扎实。</li> \n <li>了解经典的软件测试理论，熟悉基本的测试设计方法；对质量度量、流程把控、客户端专项、性能工具的使用较为熟悉；且具备一定的编码能力；</li> \n <li>加分项：测试工程师的岗位需要候选人有比较广泛的知识面，最好对计算机各个领域的知识均有涉猎，不求样样精通，但求能融会贯通。</li> \n</ul> \n<p>细节可以通过美团测试方向的技术文章来体验：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2018/05/11/quality-operation-in-zcm.html\" rel=\"nofollow noreferrer\">质量运营在智能支付业务测试中的初步实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/04/27/ruby-autotest.html\" rel=\"nofollow noreferrer\">“小众”之美——Ruby在QA自动化中的应用</a></li> \n <li><a href=\"https://tech.meituan.com/2018/03/11/dianping-shortvideo-battery-testcase.html\" rel=\"nofollow noreferrer\">大众点评App的短视频耗电量优化实战</a></li> \n <li><a href=\"https://tech.meituan.com/2018/01/09/lego-api-test.html\" rel=\"nofollow noreferrer\">Lego-美团接口自动化测试实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/12/13/smart-payment.html\" rel=\"nofollow noreferrer\">智能支付稳定性测试实战</a></li> \n</ul> \n<h3>运维工程师</h3> \n<blockquote>\n 对应岗位名称：运维开发，SRE，DevOps，DBA，网络工程师，安全工程师。\n</blockquote> \n<p>在美团做运维工程师，主要分为SRE、系统网络工程师和DBA三个方向，以及安全领域。鉴于安全的特殊地位，我们会将安全工程师，单独拿出来进行说明，本部分先介绍前三个方向。</p> \n<p>SRE会以「上帝视角」来运维全公司的业务系统，每一个操作都关乎亿万用户的使用，每一项优化都能帮助公司降低成本，增加效率。公司业务的持续发展离不开卓越的运营，稳定性保障领域还有很多难题需要我们去突破，SRE有很大的机会成长为优秀的架构师、管理者。</p> \n<p>系统网络工程师的主要职责是维护和保障美团基础设施的稳定，包括数据中心、网络、服务器等设施，及维护设施所需的运维平台建设与运维。这是涉及基础科学，垂直技术领域最多的一个通道，通过技术与运营相结合，为公司业务提供稳定、高效、低成本的基础设施资源。如果你成为一名系统工程师，就有机会接触大规模的基础设施资源，能够以软硬件结合的方式，系统性的参与到大规模的基础设施的运营。</p> \n<p>DBA团队负责保障美团数据库服务的稳定和安全，致力于为公司提供稳定、可靠、高效的在线存储服务。从传统的运维DBA起步，DBA团队在短时间内经历了脚本化、工具化、平台化、自动化的快速迭代，并开始了在智能运维领域的探索和实践。展望未来，我们将着力于应用AI技术推进数据库运维自动化与智能化的交叠演进，并借助NewSQL、容器化、软硬件一体化技术促进OLTP与OLAP更好的融合。如果你有志于服务万亿级的高并发、大流量、多租户的应用场景，欢迎加入美团DBA团队。</p> \n<ol> \n <li> <strong>SRE</strong>：扎实的计算机系统基础知识，丰富的网络知识，掌握常用算法，具备脚本编程能力；具备Linux操作系统的运维实操经验，具备小型网站的搭建能力；</li> \n <li> <strong>系统网络工程师</strong>：扎实的计算机系统基础知识，丰富的网络知识，掌握常用算法，具备脚本编程能力；具备Linux操作系统的运维实操经验；能够无障碍阅读英文技术Paper；</li> \n <li> <strong>DBA</strong>：能够掌握各种数据结构，如数组、链表、队列和栈，以及树、哈希表等；掌握数据库的基础知识，如范式、表结构设计，常用SQL语句，聚合函数的用法等；掌握Linux系统下的常用Shell命令；掌握简单的正则表达式和文本处理方法；掌握操作系统的基础知识；多参与实际的项目，在项目中积累编码经验，增强动手能力。</li> \n</ol> \n<p>细节可以通过美团运维方向的技术文章来体验：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2018/12/13/intelligent-operation-practice-in-meituan.html\" rel=\"nofollow noreferrer\">数据库智能运维探索与实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/05/20/sql-parser-used-in-mtdp.html\" rel=\"nofollow noreferrer\">SQL解析在美团的应用</a></li> \n <li><a href=\"https://tech.meituan.com/2017/08/03/meituanyun-sre.html\" rel=\"nofollow noreferrer\">云端的SRE发展与实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/03/16/redis-high-concurrency-optimization.html\" rel=\"nofollow noreferrer\">Redis 高负载下的中断优化</a></li> \n <li><a href=\"https://tech.meituan.com/2017/06/29/database-availability-architecture.html\" rel=\"nofollow noreferrer\">美团数据库高可用架构的演进与设想</a></li> \n <li><a href=\"https://tech.meituan.com/2016/09/18/the-construction-of-database-automation-system.html\" rel=\"nofollow noreferrer\">美团数据库运维自动化系统构建之路</a></li> \n</ul> \n<p><strong>安全工程师</strong></p> \n<p>在当今社会，企业的信息安全越来越重要，它关系到亿万用户的数据安全和隐私保护，关系到国计民生的基础设施可靠性，甚至可能还关系到国家安全。只有安全上不发生颠覆性的风险，用户和业务才能岁月静好。</p> \n<p>美团安全团队是一群有使命感的「守夜人」，他们用卓越的本领和超强的责任心守卫着美团数亿用户的数据和隐私。如果你也热爱安全攻防，愿意在网络空间里「除暴安良」、「保家卫国」，当一位「侠之大者」，欢迎加入美团安全团队！当你选择了信息安全，你会发现不仅是选择了一个行业，更是选择了一种责任。</p> \n<p>面对日益复杂的攻防对抗形式和海量数据场景，美团安全团队也在不断提升自己的标准，致力于成为追求卓越、业界领先的安全团队，并落地更多业界认可的实践安全项目。目前，美团安全团队人才济济，大多数核心成员拥有多年互联网以及不同安全领域实践经验，均参与过大型互联网公司的安全体系建设，其中不乏具备百万级IDC规模攻防对抗的经验的全球化安全人才、CVE挖掘圣手、业务全流程风控专家、国际顶级会议演讲者、以及知名媒体大V等。值得一提的是，美团安全团队的氛围非常的轻松和谐。我们不止有「格子衫文化」，更会吃喝玩乐，是一群热爱生活，并且享受生活的年轻人。</p> \n<ol> \n <li> <strong>专业背景</strong>：优先信息安全、计算机科学、统计学、数学等相关学历及专业背景的同学；</li> \n <li> <strong>技术技能</strong>：至少熟悉Python、Java、Go、C++等主流语言中的一门，有过至少一门语言的开发实践；了解行业政策与动向，关注最新安全漏洞，能分析漏洞原理和实现PoC编写；能够无障碍阅读英文技术Paper；</li> \n <li> <strong>覆盖领域</strong>：对网络安全、应用安全、数据安全、业务安全、移动安全、AI安全、IoT安全、内容风控、攻防对抗、安全算法等任意领域有实操经验，或有着一定的见解，并对此研究方向抱有热情；</li> \n <li> <strong>加分项</strong>：如果你是挖洞能手，有独立挖掘过知名开源应用/大型厂商高危漏洞经历，或在相关领域获奖、发表过Paper、做过分享；或者曾经在大型互联网公司有过相关实习经验；或者了解AI主流算法适用场景和调参，有相关的实践经验，都是加分项哦~</li> \n</ol> \n<p>细节可以通过美团安全领域的技术文章来体验：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2018/05/24/data-security-system-construction.html\" rel=\"nofollow noreferrer\">互联网企业数据安全体系建设</a></li> \n <li><a href=\"https://tech.meituan.com/2020/03/12/cloud-native-security.html\" rel=\"nofollow noreferrer\">云原生之容器安全实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/11/08/intrusion-detection-security-meituan.html\" rel=\"nofollow noreferrer\">浅谈大型互联网企业入侵检测及防护策略</a></li> \n <li><a href=\"https://tech.meituan.com/2018/01/26/network-isolation-access-control.html\" rel=\"nofollow noreferrer\">初探下一代网络隔离与访问控制</a></li> \n <li><a href=\"https://tech.meituan.com/2017/10/27/security-port-monitor.html\" rel=\"nofollow noreferrer\">互联网企业安全之端口监控</a></li> \n <li><a href=\"https://tech.meituan.com/2017/04/07/google-security-ayazero.html\" rel=\"nofollow noreferrer\">从Google白皮书看企业安全最佳实践</a></li> \n</ul> \n<h3>硬件开发工程师</h3> \n<blockquote>\n 对应岗位名称：硬件开发，嵌入式系统工程师。\n</blockquote> \n<p>硬件涉及面很广，这里不仅仅有硬件的设计和开发工作，同时包括了嵌入式软件方向、机械与结构方向、硬件质量管理等技术方向。这是一个需要能够「上通业务，下晓硬件」的技术领域，在这里工作的同学都是软硬结合的多面手。他们为美团的智能硬件平台提供最佳的解决方案，帮助美团拓展在IoT领域的战略布局。</p> \n<p>「硬件」的价值，看得见，摸得着。硬件是软件系统的载体，软件基于稳定可靠的硬件特性基础而扩展，硬件帮助软件技术价值触达用户。如果你是一位喜欢精雕细琢的「工匠」，欢迎加入我们，一起铸造精品！</p> \n<ol> \n <li>机械和电子专业技术知识，质量及项目管理专业技能，以及发现和解决问题能力。</li> \n <li>其中嵌入式软件方向：需要了解计算机体系结构，C/C++程序设计语言，数据结构，常用的网络通信结构，操作系统等基础知识。</li> \n</ol> \n<h3>算法工程师</h3> \n<blockquote>\n 对应岗位名称：算法工程师。\n</blockquote> \n<p>美团算法团队希望通过人工智能技术为业务创造价值。要求候选人能够在深入理解美团业务的基础上，进行有效场景的抽象和建模，并使用数据和算法优化上述模型；同时要求候选人能够从海量数据中总结规律，通过规则、模型、自适应学习系统等方式进行有效知识沉淀，通过数据驱动的方式帮助公司提升业务运营全链条的效率、效果。</p> \n<p>美团拥有丰富的算法应用场景、海量的数据、以及强大的算力平台。美团算法团队正在构建的AI相关技术，囊括了语音、视觉、自然语言处理、机器学习、知识图谱、搜索推荐、运筹优化、运动控制等领域；美团因为涉及线上和线下经济结合的众多业务，有丰富的应用场景，包括美团点评App内搜索推荐、面向外卖配送的定价和调度、无人配送的自动驾驶、无人机的飞行控制、智能耳机里的语音识别、人脸识别、智能语音客服系统、金融体系和供应链系统中的庞大知识图谱等。同时，美团的巨大的用户和商户以及订单体量，产生了PB量级的真实数据，例如海量的用户评价、商家经营数据、商场监控数据、餐馆菜单、无人车感知数据等，这些真实的数据对于算法研究人员是一个巨大的宝藏和修炼场。美团拥有数万高性能服务器以及数千张GPU卡，给模型训练提供了充足的算力。</p> \n<p>目前，美团算法团队比较急缺的岗位包括机器学习/数据挖掘算法工程师、运筹优化研发工程师、语音算法工程师、自然语言处理开发工程师、推荐算法工程师、计算机视觉工程师、无人车和无人机的感知/规划控制工程师等。</p> \n<p><strong>美团对算法工程师候选人重点考核的专业知识及专业技能</strong></p> \n<ol> \n <li>专业背景：算法基础知识与工程基础知识，包括数据结构、数学、机器学习理论等。</li> \n <li>专业知识：细分领域知识，包括数据挖掘、运筹优化、深度学习等基础知识，NLP、图像、3D空间定位、点云、运动规划控制等。</li> \n <li>专业能力：要求具备一定的文献阅读和调研能力，以及算法策略的实现能力。</li> \n</ol> \n<p>划重点：美团算法岗位的竞争非常激烈。如果你在算法方面不是特别自信的话，建议多考虑一下美团的工程方向。</p> \n<p>细节可以通过美团算法方向的技术文章来体验：</p> \n<ul> \n <li><a href=\"https://tech.meituan.com/2019/11/14/nlp-bert-practice.html\" rel=\"nofollow noreferrer\">美团BERT的探索和实践</a></li> \n <li><a href=\"https://tech.meituan.com/2015/01/22/mt-recommend-practice.html\" rel=\"nofollow noreferrer\">美团推荐算法实践</a></li> \n <li><a href=\"https://tech.meituan.com/2019/01/10/deep-learning-in-meituan-hotel-search-engine.html\" rel=\"nofollow noreferrer\">深度学习在搜索业务中的探索与实践</a></li> \n <li><a href=\"https://tech.meituan.com/2018/03/29/herenqing-ai-con.html\" rel=\"nofollow noreferrer\">美团外卖骑手背后的AI技术</a></li> \n <li><a href=\"https://tech.meituan.com/2017/07/28/dl.html\" rel=\"nofollow noreferrer\">深度学习在美团推荐平台排序中的运用</a></li> \n <li><a href=\"https://tech.meituan.com/2017/05/05/machine-learning-model-optimization.html\" rel=\"nofollow noreferrer\">机器学习中模型优化不得不思考的几个问题</a></li> \n <li><a href=\"https://tech.meituan.com/2019/02/21/meituan-delivery-eta-estimation-in-the-practice-of-deep-learning.html\" rel=\"nofollow noreferrer\">深度学习在美团配送ETA预估中的探索与实践</a></li> \n</ul> \n<p>以上就是美团技术团队岗位整体介绍以及对岗位的要求，如果大家想了解更多的招聘信息和岗位信息，欢迎关注「美团技术团队」、「美团点评招聘」微信公众号。</p> \n<h2>二、哪些软素质最受面试官的认可？</h2> \n<p><strong>基本能力</strong></p> \n<ul> \n <li> <strong>聆听的能力</strong>：希望你能够迅速Get到面试官的提出的问题核心以及前提条件，避免在未清晰获取到问题或者没有思考清晰的情况下，直接就回答面试官提出的问题。</li> \n <li> <strong>沟通表达的能力</strong>：口头和书面表达逻辑清晰，能够有条理地进行思考，清楚、有力地表达自身想法和观点。在美团的日常工作中，编写技术文档和发送邮件的情况非常普遍，希望你具备清晰的逻辑思考能力和优秀的写作能力。</li> \n <li> <strong>学习能力</strong>：美团有句经典老话：我不会但我可以学。我们希望你能够主动发现自己的短板，并有规划地为自身能力打补丁，更主动地了解行业相关信息，同时愿意主动学习新技术，包括但不限于经典的技术书籍、网络博客、教学视频等。鼓励大家在大学时尽可能参与一些开源项目，或者参加过一些编程相关的竞技比赛。</li> \n</ul> \n<p><strong>工作能力</strong></p> \n<ul> \n <li> <strong>协作能力</strong>：一个人可以走的更快，一群人可以走的更远。美团业务线比较多，经常涉及跨部门合作，希望你具备一定的团队协作能力。</li> \n <li> <strong>执行力</strong>：较好的计划制定和落地能力，较好的风险把控和应对能力，较好的应变和调整能力。</li> \n <li> <strong>管理能力</strong>：在时间管理方面，能够合理安排工作，以确保自己不被Deadline牵制；在自身管理能力方面，知道时间用在什么地方，重视对外界的贡献，善于发挥自身长处，集中精力于重要领域，善于做出有效决策。</li> \n</ul> \n<p><strong>个人素质</strong></p> \n<ul> \n <li> <strong>技术自驱力</strong>：我们希望你是真正发自心底的热爱技术，能够对技术保持好奇心，做到「知其然也知其所以然」，且喜欢动手实践。</li> \n <li> <strong>韧性</strong>：美团提倡「长期有耐心」，希望你在遇到挫折和失败时，不会轻言放弃。从学校到社会的过渡阶段，必然会面临很多挑战和困难，坚韧可以帮助战胜困难。</li> \n <li> <strong>积极开放的心态</strong>：希望你拥有较强的求知欲和好奇心，对新鲜技术充满探索欲，能够积极拓展圈内外的人际资源，跟大家一起交流、分享。同时能够不自我设限，不断突破自我。</li> \n</ul> \n<h2>三、学长有话对你说：</h2> \n<h3>潘魏增学长 | 南开大学 | 前端技术专家，2010年加入美团点评</h3> \n<p>第一，练好技术基本功，勿在浮沙筑高台。大家要把计算机基础理论、互联网基础知识以及前端开发的基本原理弄明白，这点对刚走上工作岗位的应届生来说尤为重要。第二，不要去追潮流，不要去做技术投机，看到人工智能、算法领域比较火爆，就一窝蜂冲上去，往往容易「折戟沉沙」。而且工程领域发展前景并不输于算法等领域。第三，主动了解所在公司所在部门最需要什么，了解影响业务成功的各种要素，在做好本职工作之外向前多走一步，成为懂业务、懂商业的技术多面手。最重要的一点，持续努力，不要懈怠。不要因为获得一点点成绩而沾沾自喜，千万不要把运气当做自己的能力。</p> \n<h3>王晓飞学长 | 北京邮电大学 | Android技术专家，2015年加入美团点评</h3> \n<p>首先建议学弟学妹，最好在大学期间就能认认真真地去完成一个App的设计、开发、上线的完整流程；第二，必要的面试笔试基本功不能丢（上面写的很详细呦）；第三，多一点耐心，多一点坚持；第四点，要有自己的想法，不要因为大家都去追逐一些新名词就随波逐流，找到适合自己的才是最重要的。</p> \n<h3>董尚先学长 | iOS技术专家，2015年4月加入美团点评</h3> \n<p>计算机知识体系很庞大，但是技术基础上都具备相通性，牢固的知识基础有助于在后续的学习中举一反三。作为一名iOS工程师，不代表你不能学习其他的技术栈。移动端的知识相对来说学习曲线比较平缓，对新同学来说比较友好的，非常适合作为互联网的入门行业。 当感觉到得心应手的时候，一定要及时走出舒适圈，严格要求自己，LLVM、跨端技术、持续集成、动态化、端智能技术等都是可以深入的学习方向。美团技术团队也提供了非常大的一个舞台，内部有无数的「活水」机会，大家可以去不同的业务线、不同的技术线去挑战自我。</p> \n<h3>刘铮学长 | 西安电子科技大学 | 后台技术专家，2017年加入美团点评</h3> \n<p>后台和系统相关的技术体系很庞大，一开始避免陷入细节，可以先从广度入手，了解各种技术的特性及使用场景，然后结合自己的事情或兴趣，进行某个领域的深入钻研。机会与能力同等重要。作为初出茅庐的毕业生，应该选择一个蓬勃发展的行业，在丰富的实践中快速成长。</p> \n<h3>陈彧学长 | 清华大学 | 数据技术专家，2015年加入美团点评</h3> \n<p>如果你想成为一名优秀的数据工程师，那么你需要知道，数据非常看重实战经验的长期积累。同学们需要具有稳健的职业发展观。在数据领域，毕业后3~5年的时期非常关键，就业的选择要重视未来经验的积累和视野的拓展。建议大家要重视基本功，认知好自己的兴趣和专长。时间若是足够的话，可在美团这样的大型互联网公司找到一份相关的实习工作，提前了解一下行业的实践。</p> \n<h3>陈阳学长 | 东北石油大学 | 测试技术专家，2019年加入美团点评</h3> \n<p>测试方向入门容易做精难，想在某一个方向做深入需要比研发工程师更广的知识面，也需要比产品更敏锐的需求提炼和转化能力。从工具的设计、开发再到运营，从技术规划到版本规划再到项目实施，考验的是全面协调以及解决问题的能力。此外，高段位的测试工程师还要根据不同项目的成熟度模型，引入规范的流程、敏捷开发模式、数据版本的管理、代码版本的管理、组件化服务化的升级等等，都需要对业务的深度理解，更需要多年的经验积累来确保软件的质量。建议学弟学妹们要重视知识的广度，夯实基础，在某一个方向持续深入学习，锻炼沟通能力和解决问题的能力。</p> \n<h3>赵应钢学长 | 华中科技大学 | 数据库专家，2015年8月加入美团点评</h3> \n<p>首先，尽量寻找到在大型互联网公司实习的机会，在实际工作中提升自己，做到理论实践相结合。通过实际工作，更能了解到企业的实际需要。其次，可以多参加一些认证考试，在考证的过程中掌握整个知识体系，形成全局视野。最后一点，多关注顶级企业对人才的招聘要求，提前储备相关技能。</p> \n<h3>赵弼政学长 | 武汉理工大学 | 安全技术专家，2018年加入美团点评</h3> \n<p>安全攻防是在计算机基本功之上的灵活运用，深刻理解原理才能化腐朽为神奇，所以首先建议大家注意打好基本功（编译原理、操作系统、网络、数据库等）。另一方面，安全领域的大多数前辈都是兴趣驱动的，在实践中培养自信、加深理解、融会贯通。所以一定要多动手，不能仅仅满足于老师和课本上提到的知识。无论是挖漏洞、渗透测试、打CTF比赛、写自动化工具还是做算法参数调优等，尽量把经典的场景都亲手反复实践过，有了这些实践，还要擅长总结（验证对计算机基本知识的理解深度），试着写一些文章或者Blog分享。做好这些技术储备的同时，要坚守初心，不碰黑产。</p> \n<h3>景华学长 | 北京航空航天大学 | 嵌入式软件技术专家，2018年加入美团点评</h3> \n<p>当与面试官讨论问题的时候，请用数据来征服TA。在这个领域，美团硬件通道不允许用召回率来表达，一个算法也许完成了90%就可以落地了，但是美团需要的是达到99.9999%的设计标准。所以数据是打开这个通道的大门，且对应的数字一定要准确。在这个通道，基本功尤其重要，任何出现在你简历中的内容，一定要解释的明明白白。</p> \n<h3>段航学长 | 比利时鲁汶大学 | 算法专家，2015年加入美团点评</h3> \n<p>写好简历，客观地陈述个人的经历，有针对性；做好准备，重视每一次的面试机会，心态平和；积极主动，关注目标企业招聘信息，踊跃申请。</p> \n<h2>四、欢迎加入美团技术团队：重要是跟什么样的人在一起做什么样的事情！</h2> \n<p>人是美团最重要的资产，美团技术团队以浓厚的学习和分享氛围享誉业界。</p> \n<ol>\n <li> <strong>完善的技术培训体系</strong>：美团技术学院开设几百门技术专业课程。从MRN介绍到Java并发编程，从系统复杂性问题方法论到机器学习算法，从后台用例设计到运维开发初体验......</li>\n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159824\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<ol> \n <li> <strong>丰富的技术图书资源</strong>：美团点评图书馆藏13000多册纸质书（90%以上为技术图书），306本电子书，并有O\'Reilly Safari英文电子书库（四万多计算机技术和管理图书！）、ACM Library、知网、极客时间等多种电子资源。</li> \n <li> <strong>浓厚的工程师文化</strong>：美团技术团队内部社区为技术同学提供一站式技术信息查询服务，内外部技术博客承载技术团队优质内容沉淀，TopTalk不定期邀请国内外技术大咖来公司做分享，1024程序员节狂欢、29个技术俱乐部聚集志同道合的小伙伴，各种学习路径帮助你每天前进30公里。</li> \n</ol> \n<h2>内推福利</h2> \n<p>送给大家一个小福利。下面这个是美团技术岗位<strong>社招</strong>官方内推码，微信扫码即可投递简历：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159820\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>参加<strong>校招</strong>的同学，可以使用微信扫描下面的内推码：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022159823\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>欢迎大家踊跃投递简历噢~ ~</p> \n<p>在帮大家「吃得更好，生活更好」的背后，有一群工程师小哥哥、小姐姐们在默默努力、默默付出。我们也希望优秀的你也能加入我们，用一行行代码，创造出美好的亿万生活！</p>', 'https://segmentfault.com/img/remote/1460000022159819', '1c5851dc916d4e70a60f0c957f548876', '81a4561c1c294e0cae32c9fe6b5dc397,63c4e1e7ec204b43a62065a3ced4c2ce,55723db96b9f4593bae02bc1e49f1e87,8dfc62f227ae4076888ea4872e03cddd,85ee959b27f74072b13cc763b9bbf77e', '0', '3', '1', '2020-04-16 16:50:16', '2020-04-16 16:50:16');
INSERT INTO `tb_recommend` VALUES ('f231bc3993ac4efe86a03c70bba744e5', '什么是HSTS，为什么要使用它？', '翻译自：What Is HSTS and Why Should I Use It?作者：Tomasz Andrzej Nidecki，一位非常专业的 Technical Content Writer ，目前是 Acunetix 的技术内容撰写人，他是一名拥有 25 年 IT 经验的记者、翻译和技术撰...', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316263\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<blockquote>\n 翻译自：\n <a href=\"https://www.acunetix.com/blog/articles/what-is-hsts-why-use-it/\" rel=\"nofollow noreferrer\">What Is HSTS and Why Should I Use It?</a>\n <p>作者：<a href=\"https://www.linkedin.com/in/tonid?originalSubdomain=mt\" rel=\"nofollow noreferrer\">Tomasz Andrzej Nidecki</a>，一位非常专业的 Technical Content Writer ，目前是 <a href=\"https://www.acunetix.com/\" rel=\"nofollow noreferrer\">Acunetix</a> 的技术内容撰写人，他是一名拥有 25 年 IT 经验的记者、翻译和技术撰稿人，Tomasz 早年曾担任《 hakin9 IT Security 》杂志的总编辑，并曾经运营过一个专门针对电子邮件安全的主要技术博客。</p> \n</blockquote> \n<p>HSTS 是 HTTP 严格传输安全（HTTP Strict Transport Security） 的缩写。 这是一种网站用来声明他们只能使用安全连接（HTTPS）访问的方法。 如果一个网站声明了 HSTS 策略，浏览器必须拒绝所有的 HTTP 连接并阻止用户接受不安全的 SSL 证书。 目前大多数主流浏览器都支持 HSTS (只有一些移动浏览器无法使用它)。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316265\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>在 2012 年的 <a href=\"https://tools.ietf.org/html/rfc6797\" rel=\"nofollow noreferrer\">RFC 6797</a> 中，HTTP严格传输安全被定义为网络安全标准。 创建这个标准的主要目的，是为了避免用户遭受使用 SSL stripping（剥离） 的 <a href=\"https://www.acunetix.com/blog/articles/man-in-the-middle-attacks/\" rel=\"nofollow noreferrer\">中间人攻击（man-in-The-middle，MITM）</a>。 SSL stripping 是一种攻击者强迫浏览器使用 HTTP 协议连接到站点的技术，这样他们就可以嗅探数据包，拦截或修改敏感信息。 另外，HSTS 也是一个很好的保护自己免受 cookie 劫持（cookie hijacking）的方法。</p> \n<h2>HSTS 工作原理</h2> \n<p>通常，当您在 Web 浏览器中输入 URL 时，您会跳过协议部分。 例如，你输入的是 <code>www.acunetix.com</code>，而不是 <code>http://www.acunetix.com</code>。 在这种情况下，浏览器假设你想使用 HTTP 协议，所以它在这个阶段发出一个 <a href=\"https://www.acunetix.com/blog/articles/http-security-introduction-to-http-part-1/\" rel=\"nofollow noreferrer\">HTTP 请求</a> 到 <code>www.acunetix.com</code>，同时，Web Server 会返回 301 状态码将请求重定向到 HTTPS 站点。 接下来浏览器使用 HTTPS 连接到 <code>www.acunetix.com</code>。 这时 HSTS 安全策略保护开始使用 HTTP 响应头：</p> \n<pre><code>Strict-Transport-Security: max-age=31536000; includeSubDomains; preload</code></pre> \n<p>响应头的 <code>Strict-Transport-Security</code> 给浏览器提供了详细的说明。 从现在开始，每个连接到该网站及其子域的下一年（31536000秒）从这个头被接收的时刻起必须是一个 HTTPS 连接。 HTTP 连接是完全不允许的。 <strong>如果浏览器接收到使用 HTTP 加载资源的请求，则必须尝试使用 HTTPS 请求替代。 如果 HTTPS 不可用，则必须直接终止连接</strong>。</p> \n<p>此外，如果证书无效，将阻止你建立连接。 通常来说，如果 HTTPS 证书无效（如：过期、自签名、由未知 CA 签名等），浏览器会显示一个可以规避的警告。 <strong>但是，如果站点有 HSTS，浏览器就不会让你绕过警告。 若要访问该站点，必须从浏览器内的 HSTS 列表中删除该站点</strong>。</p> \n<p>响应头的 <code>Strict-Transport-Security</code> 是针对一个特定的网站发送的，并且覆盖一个特定的域名（domain）。 因此，如果你有 HSTS 的 <code>www.acunetix.com</code> ，它不会覆盖 <code>acunetix. com</code>，而只覆盖 <code>www</code> 子域名。 这就是为什么，为了完全的保护，你的网站应该包含一个对 base domain 的调用（在本例中是 acunetix. com） ，并且接收该域名的 <code>Strict-Transport-Security</code> 头和 <code>includeSubDomains</code> 指令。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316264\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<h2>HSTS 是否完全安全？</h2> \n<p>不幸的是，你第一次访问这个网站，你不受 HSTS 的保护。 如果网站向 HTTP 连接添加 HSTS 头，则该报头将被忽略。 这是因为攻击者可以在中间人攻击（man-in-the-middle attack）中删除或添加头部。 HSTS 报头不可信，除非它是通过 HTTPS 传递的。</p> \n<p>你还应该知道，每次您的浏览器读取 header 时，HSTS <code>max-age</code> 都会刷新，最大值为两年。 这意味着保护是永久性的，只要两次访问之间不超过两年。 如果你两年没有访问一个网站，它会被视为一个新网站。 与此同时，如果你提供 <code>max-age</code> 0 的 HSTS header，浏览器将在下一次连接尝试时将该站点视为一个新站点（这对测试非常有用）。</p> \n<p>你可以使用称为 HSTS 预加载列表（HSTS preload list）的附加保护方法。<strong> Chromium 项目维护一个使用 HSTS 的网站列表，该列表通过浏览器发布</strong>。 如果你把你的网站添加到预加载列表中，浏览器会首先检查内部列表，这样你的网站就永远不会通过 HTTP 访问，甚至在第一次连接尝试时也不会。 这个方法不是 HSTS 标准的一部分，但是它被所有主流浏览器(Chrome、 Firefox、 Safari、 Opera、 IE11 和 Edge)使用。</p> \n<p>目前唯一可用于绕过 HSTS 的已知方法是基于 NTP 的攻击。 如果客户端计算机容易受到 <a href=\"https://www.blackhat.com/docs/eu-14/materials/eu-14-Selvi-Bypassing-HTTP-Strict-Transport-Security.pdf\" rel=\"nofollow noreferrer\">NTP 攻击（ NTP-based attack）</a>，它可能会被欺骗，使 HSTS 策略到期，并使用 HTTP 访问站点一次。</p> \n<h2>如何将域名添加到 HSTS 预加载列表？</h2> \n<p>要将域添加到 HSTS 预加载列表，该域的站点必须满足几个要求。 以下是添加域名所需的步骤：</p> \n<ol> \n <li>确保你的网站拥有有效的证书和最新的密码</li> \n <li>如果你的网站可以通过 HTTP 访问，请将所有请求重定向到 HTTPS</li> \n <li>确保以上第 1 点和第 2 点适用于你的所有域名和子域名（根据您的 DNS 记录）</li> \n <li>通过 HTTPS 服务返回 <code>Strict-Transport-Security</code> header ，带上 <code>base domain</code> 和 <code>max-age</code> ，<code>max-age </code> 至少为31536000 (1 年)，另外还有 <code>includeSubDomains</code> 指令和 <code>preload</code> 指令。 可以参考上面的 HSTS header。</li> \n <li>访问 hstspreload.org ，并使用表格提交你的域名。如果符合条件，您的域名将被加入队列。</li> \n</ol> \n<p>为了提高安全性，浏览器不能访问或下载 预加载列表（preload list）。 它作为硬编码资源（hard-coded resource）和新的浏览器版本一起分发。 这意味着结果出现在列表中需要相当长的时间，而域从列表中删除也需要相当长的时间。 <strong>如果你希望将你的站点添加到列表中，则必须确保您能够在较长时间内保持对所有资源的完全 HTTPS 访问。 如果不这样做，你的网站可能会完全无法访问</strong>。</p> \n<p>就像这样：<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316266\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<h2>如何从浏览器的 HSTS 缓存中删除域？</h2> \n<p>在设置 HSTS 并测试它时，可能需要清除浏览器中的 HSTS 缓存。 如果你设置 HSTS 不正确，你可能会访问网站出错，除非你清除数据。 下面是几种常用浏览器的方法。 还要注意，如果你的域在 HSTS 预加载列表中，清除 HSTS 缓存将是无效的，并且无法强制进行 HTTP 连接。</p> \n<p>要从 Chrome HSTS 缓存中删除一个域名，请按照以下步骤操作：</p> \n<ol> \n <li>访问 <code>chrome://net-internals/#hsts</code> </li> \n <li>在 <code>Delete domain security policies</code>下的文本框中输入要删除的域</li> \n <li>点击文本框旁边的 Delete 按钮</li> \n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316268\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>之后，你可以检查移除是否成功：</p> \n<ol> \n <li>在 <code>Query HSTS/PKP domain</code> 下的文本框中输入要验证的域</li> \n <li>点击文本框旁边的 Query 按钮</li> \n <li>返回应该是 not found</li> \n</ol> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022316267\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image\" title=\"image\"></span></p> \n<p>Mozilla Firefox 、Safari 和 Microsoft Edge 自行查看原文吧。</p>', 'https://segmentfault.com/img/remote/1460000022316263', '692c6787030d4b8882077b2ab9279c52', 'f0e336796bd94b8299ef69b2b2529ec4,e7ef2c314f5244fd810e87742ea22b53', '0', '3', '1', '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_recommend` VALUES ('f313355af89d415baa68ca1ee1995150', 'TiKV Committer 庄天翼：只要能提升 Codebase 质量，就值得提交 PR', '2020 年 2 月，TiKV 项目迎来了一位新晋 Committer —— 庄天翼（GitHub ID：TennyZhuang），他 2018 年毕业于清华大学，目前在旷视科技担任分布式存储开发工程师，平时爱看动漫，工作之余也喜欢写一些代码，实现自...', '<p>2020 年 2 月，TiKV 项目迎来了一位新晋 Committer —— 庄天翼（GitHub ID：TennyZhuang），他 2018 年毕业于清华大学，目前在旷视科技担任分布式存储开发工程师，平时爱看动漫，工作之余也喜欢写一些代码，实现自己的想法。前天，我们“正儿八经”地采访了庄天翼同学，在互相努力憋笑中，愉快地掉落了以下文字……</p> \n<h2>传说中的“天才少年”</h2> \n<p>天翼并不是普通意义上的计算机“天才少年”。</p> \n<p>虽然他在大四时和队友一起拿了 CCPC（中国大学生程序设计竞赛）区域赛金牌，但他第一次接触编程已经是高中了，当时并没有深入研究编程，只是觉得学起来挺喜欢。在拿到化学竞赛金牌并保送清华后他也没有选择计算机专业，而是在材料学院就读，直到大三才正式转专业到了软件学院。</p> \n<p>为了顺利转系到软件学院，他利用课余时间修了大一和大二的计算机课程。得力于之前给学院老师留下的深刻印象，大三一开学他就成为软件学院的助教，协助老师设计课程并分享自己做这门课程的心得。</p> \n<p><strong>天翼说突破舒适区，学习新的东西是一件很有成就感的事。</strong></p> \n<p>“大三时学院有一门 Haskell 课程，当时作业分级，我完成了最高难度的题并且做了拓展，写了一个比较完整的 scheme 解释器，这门课拿了满分。虽然现在看来没那么厉害，但当时觉得很有成就感。”</p> \n<h2>理解“开源社区”</h2> \n<h3>与开源结缘</h3> \n<p>当被问到第一次是怎么接触到开源时，天翼笑了笑说“这要定义一下开源了，一开始是学习 Git 的使用，因为本科提交作业需要版本管理，接触了 Git。当时就想要不把代码公开上传 GitHub 吧，电脑万一坏了作业也不会丢。等我到高年级时有些自己的小项目被学弟发现竟然还有些 star，这可能算是我第一个开源项目吧。后来也陆续给一些其他小的开源项目做贡献，主要是自己平时会用到。”</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022074911\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h3>对“社区贡献”的理解</h3> \n<p>天翼对社区的理解和我们不谋而合：<strong>只要对 Codebase 的质量有提升，就值得去提交 PR</strong>。</p> \n<p>“我之前给 Golang 提交过一个很小的 PR。当时我在调试 TiDB 的一个性能 regression 问题，感觉 Go 编译器在判断一个函数是否可以 inline 的调试日志里缺失了 cost 信息，于是我手动编译了 Go，在 debug 日志中添加了自己需要的信息来解决了我当时遇到的问题。很多人到这一步可能就结束了，但我还是将这行调试 log 作为一个 patch 提交给了 Golang。这个 PR 可能很小，但如果下一个 Go 开发者遇到了跟我相似的问题，也需要这行信息，他就可以省去自己完整编译一遍 Go 的时间，我觉得这就值得去提交一个 PR。我认为一个 PR 只要能提升 Codebase 的质量，就是对开源社区的贡献。”</p> \n<h2>TiDB 社区印象</h2> \n<p>谈到对 TiDB 社区的整体印象，天翼说道，“<strong>TiDB 社区建设是我见过开源项目中最好的。对任务的定义很明确并且每个组件都有明确的负责人。TiDB 社区对新人更友好，比如 issue 会标注难度，组建划分的很清楚，可以方便的找到适合自己的任务</strong>。另外源码阅读系列比较有意义，我一般不看源码的实现细节，但源码阅读指南会让我更理解组件之间调用关系。”</p> \n<h3>参与社区</h3> \n<p>天翼是分布式存储工程师，对存储和数据库相关的项目比较感兴趣，因此 TiDB 是他参与的第一个比较正式的开源项目。当时 TiDB 还有若干篇教你“如何十分钟成为 Contributor” 的指南，于是就来试了一下。</p> \n<p>在工作中天翼用 Go 比较多，大概是三四年前他就有接触过 Rust 了，当时就觉得这个语言设计得非常优美，但因为一直没有工程实践所以看完书之后总是容易忘记。通过贡献 TiKV，天翼有了真正的生产经验，对 Rust 特性理解也更加深刻。</p> \n<p><strong>“对我来说，参与社区贡献，除了增加了 Rust 使用经验和真正用于生产的数据库开发经验，同时也认识了很多人，扩大了社交圈，让我学到了很多东西。”</strong></p> \n<p>他也很喜欢参与社区的活动，在 Infra Meetup 中担任过讲师，在两届 TiDB Hackathon 和 TiDB 挑战赛并都取得了优异的成绩，可以说是收获满满。</p> \n<p>对于 Hackathon 这样 48 小时的脑暴活动，天翼有一些小心得：“<strong>无论拿不拿奖，idea 的实现很重要</strong>”，比如在 2019 年的 TiDB Hackathon 上，天翼和队友完成的项目 <a href=\"https://pingcap.com/blog-cn/geographic-data-distribution-traffic-and-latency-halved/\" rel=\"nofollow noreferrer\">解决了跨数据中心场景下 TiDB 的 latency 问题</a>，使得跨地域 SQL 查询延迟下降 50%，跨节点消息数减半（即网络流量减半），实现上方法上主要从 Raft 层面来解决的，比较巧妙地提升了 Follower Read 的性能，并用 Follower Replication 减少带宽成本。这个项目获得了评审们和 TiDB 用户的好评，并且斩获了二等奖。</p> \n<h3>感受最深的一个 PR</h3> \n<p>天翼说在他成为 Committer 之前解决了一个很繁琐的 PR，改动了 80 多个文件 1000 多行代码。虽然难度不高，但令他印象十分深刻，“当时必须修改一个 TiDB 大部分模块都引用的公共接口，于是导致今天改完明天不合并，马上就冲突，给合并带来很大困难，我差一点就要放弃了，但又不甘心，于是我和 breezewish（PingCAP 的小伙伴）一起改动这个 PR 直到凌晨四点，PR 才通过单元测试，被 review 完。第二天上午就迅速合并了，避免了和别的 PR 产生冲突，这次合作印象很深。”</p> \n<h3>进阶！进阶！</h3> \n<p>从 Contributor 到 Committer，天翼在 TiDB 社区得到了成长和认可，对于如何晋升到社区下一个角色 Maintainer，他也有自己的想法。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022074910\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>“Maintainer 是一个要求比较高的角色。我觉得提多少 PR 或者 Review 多少 PR 都不是很关键。比如 孙晓光，他给 TiKV 提了一个独立设计的 feature，我认为这样才配得上一个 Maintainer。参与社区这个过程对我来说是很有意思的，可能在我贡献的过程中慢慢就会达到这个要求。”</p> \n<h2>分享一个参加挑战赛的 Tip</h2> \n<p>在访谈最后，作为 <a href=\"https://pingcap.com/blog-cn/pcp-report-202002/\" rel=\"nofollow noreferrer\">第一季 TiDB 挑战赛</a> 的第一名，天翼为大家分享了一个小 Tip：比赛过程中时刻和 Mentor 保持同步。</p> \n<p>“参加第一季时，我队友有一个 2000 分的 PR，写着写着废弃了，因为当时改动涉及的模块较多，且修改破坏了原本的分层设计最终没能合并。因此有接口设计变更随时和 Mentor 保持同步，及时达成一致意见，对大项目是非常重要的。如果涉及的模块较多，建议优先提交 RFC，经过多个 Reviewer 评审再开始具体工作。避免最后 Review 的时候对设计的理解有冲突而需要大量更改甚至不能合并。”</p> \n<p>（注：天翼所在的 .* Team 也参加了第二季 TiDB 挑战赛之易用性挑战赛，已经斩获了上千积分，想在积分排行榜上与天翼“过过招”的同学，可以看看这份“捞分指南”哦）</p> \n<blockquote> \n <strong>最后在关麦之前……</strong>\n <p>我们请天翼对下一位采访嘉宾提一个问题。天翼说：“什么都可以问吗？” 我们：“对啊，反正不能露出的我们就会掐掉。”</p> \n <p>两个小时过后，天翼终于绞尽脑汁想出了一个问题：“<strong>不知道下一位嘉宾平时做饭么，最喜欢吃哪道菜？</strong>”</p> \n <p>行吧就它了（冷风吹过.gif ），话筒准备递给下一位嘉宾了！至于下一位嘉宾是谁，熟悉社区的小伙伴肯定都知道啦，先卖个关子，敬请期待～</p> \n</blockquote> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000021958757\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p>', 'https://segmentfault.com/img/remote/1460000022074911', '6fbfa4aaad3a43458f21c8acf0038ac5', '83f62facb3b943ffa8e46abd1ebc64d9,f3eb17e6e5664a97af3e9b1fca12b286', '0', '3', '1', '2020-04-16 16:59:34', '2020-04-16 16:59:34');
INSERT INTO `tb_recommend` VALUES ('f66e574e63834aeaa7c1dd9afbc3dfc7', 'LeanCloud 2019 回顾', '在过去的一年里，数万新用户选择了 LeanCloud，开发者在我们的平台上创建了数万新应用。尽管在 6 月遇到了一些因外部因素带来的困难，2019 年仍然是 LeanCloud 实现整体盈利的第一年。这离不开用户的长期支持，同...', '<p>在过去的一年里，数万新用户选择了 <a href=\"https://www.leancloud.cn\" rel=\"nofollow noreferrer\">LeanCloud</a>，开发者在我们的平台上创建了数万新应用。尽管在 6 月遇到了一些因外部因素带来的困难，2019 年仍然是 LeanCloud 实现整体盈利的第一年。这离不开用户的长期支持，同时健康的财务对于为用户提供持续、稳定、不断改进的服务也是至关重要的。</p> \n<p>在过去一年里我们正式推出了 LeanCloud 国际版，全面支持域名绑定，并为对稳定性、可控性、灵活性有更高要求的用户开发了全新的独立部署方案。多人对战 Client Engine 正式上线，同时为规模较大的游戏提供了独立部署选项。云引擎新增了云队列和 MySQL 支持。其他服务和 SDK 也有大量改进和优化。</p> \n<h2>国际版正式运行</h2> \n<p>为了适应用户的需求变化以及产品下一步的发展，让 LeanCloud 正式成为国际化的产品，我们推出了 LeanCloud 国际版。 国际版使用独立的顶级域名 <a href=\"https://leancloud.app\" rel=\"nofollow noreferrer\">leancloud.app</a> 和账户体系，由 LeanCloud 的境外公司作为主体运营，费用使用美元结算。 我们已经初步完成了网站、控制台、文档的国际化，也提供英语技术支持，让英文环境的开发者也可以使用 LeanCloud。</p> \n<h2>全面支持域名绑定</h2> \n<p>为了确保能长期稳定为开发者提供服务，按照相关法律法规和有关部门的要求，我们推动了使用 LeanCloud 服务的应用<a href=\"https://leancloud.cn/docs/custom-api-domain-guide.html\" rel=\"nofollow noreferrer\">绑定自有域名</a>。 绑定自有域名也有利于从域名层面做好应用隔离，确保业务稳定。 为了保证安全性，API 域名必须启用 SSL（云引擎域名、文件域名推荐启用 SSL），我们也推出了自动管理功能，支持 SSL 证书的自动申请和自动续期。</p> \n<h2>存储服务</h2> \n<h4>全新独立部署方案</h4> \n<p>为了满足众多企业客户对平台稳定性、后端可控性以及功能多样性方面的要求，我们推出了新的独立部署方案，希望减少使用中的限制，给开发者更大的灵活性，同时也提供一个更加稳定可靠的完整后端，满足业务系统的更高要求。</p> \n<p>新的独立部署方案里，我们会使用「独立的存储集群 + 独立的 API 集群 + 独立的扩展服务集群」的模式来构建一个完整的、物理隔离的公有云系统，供单个用户和应用独享使用。 这里的「扩展服务」是指基于存储到云端的结构化数据，解决特定业务需求的垂直服务，例如并行计算（原离线分析功能）、全文检索（原应用内搜索功能）等。</p> \n<p>新的 API Server 是完全重新开发的，我们针对单应用独立部署的使用场景进行了功能裁剪和架构优化，取消了共享集群方式下的一些请求限制（例如数据导入导出、并发线程上限等），增加了更多数据处理接口（例如提供了索引操作和聚合查询的 REST API），同时还有更好的并发处理性能和弹性伸缩能力。</p> \n<h2>云引擎</h2> \n<h4>云队列</h4> \n<p>我们推出了<a href=\"https://leancloud.cn/docs/leanengine_cloudqueue.html\" rel=\"nofollow noreferrer\">云队列</a>服务。云队列提供了一种在云引擎之外调度云函数的能力，它基于云引擎已有的「云函数」这个概念实现了重试、去重、结果查询、延时任务、定时任务等功能，是对云函数功能的一个补充。尚未运行的任务会以一种可靠的方式暂存在云队列，即使你的云引擎因部署、过载、崩溃而重启，任务也不会丢失，云队列会等待你的云引擎实例恢复正常后继续运行它们。我们也基于云队列重新实现了定时任务，它兼容之前的绝大部分用法，并支持以 JSON 形式向云函数传递自定义的参数，以及配置在超时情况下的行为（重试或放弃）。对了，我们还移除了定时任务的个数限制。</p> \n<h4>MySQL</h4> \n<p>我们在华北节点推出了高可用、高性价比的 <a href=\"https://leancloud.cn/docs/leandb_mysql_guide.html\" rel=\"nofollow noreferrer\">MySQL 数据库托管方案</a>。 <br>开发者可以在云引擎中使用通用的 MySQL 客户端类库，访问完整的 MySQL 功能。</p> \n<h4>其他</h4> \n<p>云引擎统计结果展示也进行了优化，现在开发者可以在控制台按照总览、网站托管请求以及单个云函数来分别查看请求数（按分钟聚合）和响应时间的变化趋势，还可以看到整体的 CPU、内存以及流量消耗，希望在程序运行状况和代码优化上给大家提供更多参考信息。</p> \n<p>云引擎命令行工具也发布了 0.21.0 版，修复了一些 bug，也支持指定 <code>--prod</code> 参数直接部署到生产环境，以及本地调试静态网站项目。</p> \n<p>云引擎 Java 环境支持指定 Java 版本，开发者可以选用 Java 8、11、12、13、14 来开发项目。</p> \n<p>云引擎 Node.js 环境新增了 <code>internal</code> 选项，用来禁止在客户端调用云函数。 <br>我们还推出了一个<a href=\"https://github.com/leancloud/leanengine-nodejs-demos\" rel=\"nofollow noreferrer\">常用功能和示例汇总代码仓库</a>，其中包括推荐的最佳实践和常用的代码片段，每个文件中都有较为详细的注释，适合云引擎的开发者阅读、参考，也可以将代码片段复制到你的项目中使用。</p> \n<h2>推送和即时通讯</h2> \n<p>Android 混合推送现已支持 <a href=\"https://leancloud.cn/docs/android_mixpush_guide.html#hash-29032758\" rel=\"nofollow noreferrer\">vivo</a>、<a href=\"https://leancloud.cn/docs/android_mixpush_guide.html#hash825173590\" rel=\"nofollow noreferrer\">oppo</a>、<a href=\"https://leancloud.cn/docs/android_mixpush_guide.html#hash1469908874\" rel=\"nofollow noreferrer\">小米推送国际版</a>，可以覆盖更多终端用户。</p> \n<p>我们还对即时通讯和推送服务做了一些其他改进和优化，以便为开发者提供更稳定的服务、更灵活的功能：</p> \n<ul> \n <li>即时通讯新增了<a href=\"https://leancloud.cn/docs/realtime-guide-systemconv.html#hash-2017196884\" rel=\"nofollow noreferrer\">客户端上下线 hook</a> 支持，在客户端登录成功、登出成功、意外下线后调用。</li> \n <li>通过 SDK 新建对话默认启用 <code>unique</code> 参数，更贴合大多数应用的使用场景。</li> \n <li>通过 REST API 发送消息现在也支持提醒用户（<code>mention_all</code> 和 <code>mention_client_ids</code> 参数）了。</li> \n <li>即时通讯的离线推送记录现在也加入到推送历史记录里面，可以在控制台一并查看。</li> \n <li>推送服务现在支持<a href=\"https://leancloud.cn/docs/push_guide.html#hash1858126366\" rel=\"nofollow noreferrer\">直接指定设备 ID 进行推送</a>，比<a href=\"https://leancloud.cn/docs/push_guide.html#hash-1836721397\" rel=\"nofollow noreferrer\">通过查询条件推送</a>更快，延迟更低。</li> \n <li>开发者现在能对<a href=\"https://leancloud.cn/docs/push_guide.html#hash137424715\" rel=\"nofollow noreferrer\">推送时间</a>和推送速度（<code>flow_control</code> 参数）进行更精细的控制。</li> \n</ul> \n<h2>游戏解决方案</h2> \n<p>为了更好服务较大规模的游戏开发者，我们推出了<a href=\"https://leancloud.cn/docs/multiplayer-server.html\" rel=\"nofollow noreferrer\">多人对战 GameServer 的独立部署版本</a>。独立部署的后端服务节点（集群），让业务完全独享所有的物理资源，以便给开发者带来更好的稳定性和灵活度。 </p> \n<p>相比于共享集群模式，独立部署的 GameServer 有如下优势：</p> \n<ul> \n <li>支持通过 <a href=\"https://leancloud.cn/docs/multiplayer-server-guide-java.html#hash290606338\" rel=\"nofollow noreferrer\">hook 函数</a> 的方式来编写服务端逻辑，业务扩展代码与 GameServer 在同一个进程内运行，与 Client Engine 方式相比在实时性上有显著提升。</li> \n <li>取消了部分使用限制，例如房间最大人数、最大消息下发频率、消息体大小限制等，在硬件能力许可范围内尽可能满足业务需求。</li> \n <li>对资源独占使用，支持自动扩容。</li> \n</ul> \n<p>此外，游戏解决方案迎来了以下改进：</p> \n<ul> \n <li>Client Engine 在完善底层架构、使用框架、文档之后，发布了正式版。</li> \n <li>排行榜增强了防作弊的策略，只放行可信环境的数据更新请求，避免被恶意刷榜。</li> \n <li>优化了游戏 SDK，简化了进入游戏大厅的逻辑，并且将消息序列化协议全部切换到 Protocol Buffers，进一步降低客户端的网络流量和传输延时。</li> \n</ul> \n<h2>控制台和官网</h2> \n<p>我们对控制台进行了改版，目前存储服务部分已经完成并上线。新版本的控制台，我们将存储相关的功能（如 LiveQuery、离线分析和应用内搜索）合并到了一起，对普通的结构化数据存储、文件、用户系统进行了拆分，并且将数据展示与权限设置、索引和性能优化等内容集中起来，希望控制台逻辑更清晰，可以给开发者带来便利。上文提到的云引擎统计结果展示界面的改进，就是基于新版控制台重新实现的。</p> \n<p>此外，控制台新增了激活归档应用和注销账号功能，个人实名认证也切换到了基于支付宝客户端的方案。我们也重新设计了<a href=\"https://www.leancloud.cn/pricing/\" rel=\"nofollow noreferrer\">官网的价格页面</a>，更加清晰、全面地展示各项服务的价格方案。</p> \n<h2>SDK</h2> \n<p>2019 年各 SDK 也发布了不少新版本，除了跟进上文提到的各服务的新功能外，主要还有以下改进：</p> \n<h4>Java</h4> \n<p>新推出的<a href=\"https://github.com/leancloud/java-unified-sdk\" rel=\"nofollow noreferrer\">统一的 Java SDK</a> 正式取代旧版的 Java SDK 和 Android SDK。 <br>新版的 SDK 全面采用了 Reactive 编程风格，同时也兼容老的 Callback 方式。在 Android 平台上，新版 SDK 切换到了 AndroidX。</p> \n<p>对于开发者担心的 Android 应用在客户端暴露 appKey 可能带来的潜在风险，我们现在允许应用程序<a href=\"https://leancloud.cn/docs/sdk_setup_android_securely.html\" rel=\"nofollow noreferrer\">只通过 appId 来完成 LeanCloud 服务初始化</a>，从而避免了暴露应用核心配置信息的风险。</p> \n<p>有些只使用推送服务的客户希望优化产品移动端体验，我们为此专门推出了<a href=\"https://github.com/leancloud/java-unified-sdk/tree/master/android-sdk/leancloud-push-lite\" rel=\"nofollow noreferrer\">精简版推送 SDK</a>，显著优化了安装包大小（1.2 MB -&gt; 180 KB）和启动时间（59 ms -&gt; 5 ms）。</p> \n<h4>Swift &amp; Objective C</h4> \n<p>Swift SDK 增加了对即时通讯、推送、云函数调用的支持，并完善了结构化存储方面的功能，在功能上基本对齐了 Android、Web 平台的 SDK。 <br>有许多 iOS 平台的开发者已经从 Objective C SDK 迁移到 Swift SDK， 还有一些新应用直接基于 Swift SDK 开发。</p> \n<p>Swift 语言的演进十分迅捷（swift），Swift SDK 同样如此，现已支持 Swift 5 和 Swift Package Manager。</p> \n<p>Objective C SDK 也增加了一些功能，修复了许多 bug。</p> \n<p>另外，为了精简代码和集中资源，Swift SDK 不再支持 iOS 10 之前的系统，Objective C SDK 不再支持 iOS 8 之前的系统。</p> \n<h4>JavaScript</h4> \n<p>JavaScript SDK 的主要改进有：</p> \n<ul> \n <li>小程序用户系统增加了 UnionId 支持。</li> \n <li>增加了手动启用、停用调试模式的开关：<code>debug.enable()</code> 和 <code>debug.disable()</code>。</li> \n <li> <code>AV.File#save</code> 方法增加了 <code>keepFileName</code> 参数允许保留文件的文件名。</li> \n <li>增加了 <code>AV.Object#revert</code> 方法撤销部分或全部修改了但未保存（save）的改动。</li> \n <li> <code>MESSAGE_UPDATE</code> 与 <code>MESSAGE_RECALL</code> 事件现在会额外返回一个 reason 参数来指示修改、撤回的原因（如果有的话）。</li> \n <li>修复和完善了大量 TypeScript 定义。</li> \n</ul> \n<h4>C Sharp</h4> \n<p>C# SDK 的主要改进有：</p> \n<ul> \n <li>简化、统一 portable 和 Unity 初始化方式，现在只需要在代码中初始化，不需要在 Unity Editor 拖拽和设置。</li> \n <li>增加消息撤回/修改功能。</li> \n</ul> \n<h2>结语</h2> \n<p>在这一年里，许多用户通过工单、论坛、邮件等各种渠道向我们反馈问题和意见，也有用户向我们开源的 SDK 提交代码。上面提到的很多新功能、改进、优化都源于用户的反馈。感谢大家的帮助和信赖，我们期待在新的一年里为用户提供更好的产品和服务。</p> \n<blockquote>\n 本文参与了 \n <a href=\"https://segmentfault.com/a/1190000021354599\">SegmentFault思否征文「2019 总结」</a>，欢迎正在阅读的你也加入。\n</blockquote>', null, '61cdf41d1e5e4f229b76f6a042e254b6', 'd684aaace0484f8dbc17e1e28457d432,ed28022185f44ae4ba91f8f8b36dc265,c825aa5f765543a1a8c96368462f9371,a0ac07cb5e6b446f8d1b9034d86fd880,9424c753324d4c6198c85fff4f681dd4', '0', '3', '1', '2020-04-16 16:57:49', '2020-04-16 16:57:49');
INSERT INTO `tb_recommend` VALUES ('f9572cc8ac0e4037a6e82758362f1756', 'Android 模拟器支持运行 ARM 应用，Android 11 系统映像可直接将 ARM 指令转换成 x86 指令', '此前，依赖 ARM 库且无法构建 x86 版本应用的开发者只能使用完整的 ARM 模拟系统映像 (其速度远低于在 x86 设备上运行 x86 系统映像) 或者实体机。Android 11 系统映像能够在不影响整个系统的前提下，直接将 ARM ...', '<p>技术编辑：鸣飞转载于<a href=\"https://mp.weixin.qq.com/s/sGGR7vuvLPSaCilrPT6F-g\" rel=\"nofollow noreferrer\">谷歌开发者</a>公众号</p> \n<hr> \n<p>随着 <a href=\"https://segmentfault.com/a/1190000022069857\">Android 11 开发者预览版的发布</a>，我们同时也推出了Android 11 系统映像。新的系统映像在执行 ARM 二进制文件方面取得了显著的性能提升。</p> \n<p>此前，依赖 ARM 库且无法构建 x86 版本应用的开发者只能使用完整的 ARM 模拟系统映像 (其速度远低于在 x86 设备上运行 x86 系统映像) 或者实体机。Android 11 系统映像能够在不影响整个系统的前提下，直接将 ARM 指令转换成 x86 指令。开发者无需搭建高负载的 ARM 环境即可执行 ARM 二进制文件并进行测试。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022298674\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>全新的 Android 11 (Google API) x86 系统映像支持 ARM 应用二进制接口 (ABI)，较旧版本的 Android Oreo 系统映像并不提供该支持</p> \n<ul>\n <li>Android 11 系统映像<a href=\"https://developer.android.google.cn/studio/releases/emulator\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> </li>\n</ul> \n<p><strong>技术细节</strong></p> \n<p>我们可能需要结合具体情景来说明这项新技术的重要性，尤其是如果您只使用 Kotlin 或 Java 编程语言来构建应用的话。Kotlin 和 Java 编程语言均在 ART (Android 运行时) 上执行，但 C++ 则与它们不同，Android 应用中的所有 C++ 指令会直接编译为机器指令，也就是说，目标设备的平台架构决定着 C++ 的编译方法。移动手机一般搭载 ARM 处理器，因此，您为应用添加的许多 C++ 依赖项 (例如摄像头条形码扫描库) 仅与 ARM 处理器兼容。在这种情形下，如果您使用基于 x86 处理器的设备进行开发工作，便会遇到应用无法运行的问题。</p> \n<p>过去，开发者需要通过模拟器镜系统映像搭建一个完整的 ARM 环境，才能绕过这个限制并在 x86 机器上执行 ARM 应用。但是，把整个系统的 ARM 指令都转换成 x86 指令会造成过高的性能负荷，因此与基于 x86 的系统映像相比，完整的 ARM 系统映像在 x86 宿主机上的运行速度会慢很多，而且它还无法使用 x86 处理器提供的硬件加速和 CPU 虚拟化技术。</p> \n<p>全新的Android 11 系统映像与 ARM 兼容，它不仅允许整个系统在本机运行 x86 指令，而且还可以照常使用虚拟化技术。当应用的某个进程需要使用 ARM 二进制代码时，代码仅会在该进程内被转换成 x86 指令，其余进程将继续在 x86 环境内执行，包括 Android 运行时 (ART) 以及其它性能关键库，例如libGLES和libvulkan。除此以外，指令转换器也不会执行低层的硬件特定库，从而避免高成本的内存访问检测和相应的性能影响。在 ARM 公司的协作下，新的模拟器系统映像在本地和持续集成框架内均可运行。</p> \n<ul> \n <li>Android 11 系统映像<br><a href=\"https://developer.android.google.cn/studio/releases/emulator\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> </li> \n <li>libGLES <a href=\"https://developer.android.google.cn/ndk/guides/stable_apis#graphics\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a> </li> \n <li>libvulkan<p><a href=\"https://developer.android.google.cn/ndk/guides/graphics/design-notes\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> </li> \n</ul> \n<p><strong>下一步</strong></p> \n<p>如果您之前由于缺乏高性能的 ARM 支持，去选择了实体机而非模拟器，不妨尝试一下Android 11 系统映像。此映像文件目前已随 Android 11 开发者预览版一同开放下载。您可通过 SDK Manager 或者Android Virtual Device Manager将最新版本的系统映像下载至 Android Studio。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022298673\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>使用 Android Virtual Device Manager 创建一个运行 Android 11 的 AVD</p> \n<ul> \n <li>Android 11 系统映像<p><a href=\"https://developer.android.google.cn/studio/releases/emulator\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> </li> \n <li>Android Virtual Device Manager&nbsp;<p><a href=\"https://developer.android.google.cn/studio/run/managing-avds#createavd\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> </li> \n</ul> \n<p>一旦应用在模拟器中成功运行后，请考虑适配 Chrome OS。Chrome OS 同样也支持在 x86 笔记本上执行 ARM 版本的 Android 应用。通过构建适用于 Chrome OS 的应用，您可以挖掘大屏幕设备生态圈所蕴含的海量机遇，让全球更多的用户认识您的应用。</p> \n<ul>\n <li>适配 Chrome OS<p><a href=\"https://developer.android.google.cn/topic/arc\" rel=\"nofollow noreferrer\">https://developer.android.goo...</a></p> </li>\n</ul> \n<p>这项技术可以帮助更多开发者在 Android 模拟器上进行测试。我们建议开发者同时构建 x86 和 ARM ABI 两个版本的应用，使其在物理设备上拥有最佳的运行性能并吸引尽可能多的用户。接下来，我们计划在多个 API 级别普及这项技术，同时确保它能和实体机一样支持所有测试用例。欢迎大家向我们提交反馈，帮助我们进一步优化这项新技术。</p> \n<ul>\n <li>提交反馈<p><a href=\"https://issuetracker.google.com/issues?q=componentid:192727%20status:open\" rel=\"nofollow noreferrer\">https://issuetracker.google.com/issues?q=componentid:192727%20status:open</a></p> </li>\n</ul> \n<p><em>请注意: ARM - x86 指令转换技术可用于执行 ARM 公司旗下的产品。该技术只可通过 Google API 和 Play Store 系统映像获取，且仅用于在 x86 台式机、笔记本、客户端本地服务器或自购的云环境上进行应用开发和调试。该技术不可在商用托管服务下使用。</em></p> \n<p><em>Java 是 Oracle 和/或其附属公司的注册商标。</em></p> \n<p>原文链接：<a href=\"https://mp.weixin.qq.com/s/sGGR7vuvLPSaCilrPT6F-g\" rel=\"nofollow noreferrer\">在 Android 模拟器上运行 ARM 应用</a></p>', 'https://segmentfault.com/img/remote/1460000022298674', '92fd98d1f9ce496dbe8c80ffd3bb7bdf', '8dfc62f227ae4076888ea4872e03cddd,9cf3a084c4d94f4da9a6423ab27b8649,6224a68b52f54990a07d51854b320f32', '0', '3', '1', '2020-04-16 16:54:49', '2020-04-16 16:54:49');
INSERT INTO `tb_recommend` VALUES ('f9b93ad945b344319f53bd397d0dbb2c', 'MySQL 同步复制及高可用方案总结', 'mysql作为应用程序的数据存储服务，要实现mysql数据库的高可用。必然要使用的技术就是数据库的复制，如果主节点出现故障可以手动的切换应用到从节点，这点相信运维同学都是知道，并且可以实现的。但是这种情况只...', '<h4><strong>1.前言</strong></h4> \n<p>mysql作为应用程序的数据存储服务，要实现mysql数据库的高可用。必然要使用的技术就是数据库的复制，如果主节点出现故障可以手动的切换应用到从节点，这点相信运维同学都是知道，并且可以实现的。但是这种情况只是手动的切换，对可用性有要求的业务需要分别实现主库和从库的高可用，保障在数据库出现down机的情况下，可以自动实现数据库的故障转移，保障应用的可用性和用户体验。</p> \n<p>本文将会对一些常用的数据库高可用方案进行介绍，根据你不同的场景，选择合适的高可用方案即可。</p> \n<h4><strong>2.MMM高可用方案</strong></h4> \n<hr> \n<h6><strong>2.1.Mysql-MMM介绍</strong></h6> \n<p>MMM(Master-Master replication managerfor Mysql，Mysql主主复制管理器)是一套灵活的脚本程序，基于perl实现，用来对mysql replication进行监控和故障迁移，并能管理mysql Master-Master复制的配置(同一时间只有一个节点是可写的)。</p> \n<h6><strong>2.2.组件</strong></h6> \n<p><strong>mmm_mond：</strong>监控进程，负责所有的监控工作，决定和处理所有节点角色活动。此脚本需要在监管机上运行。</p> \n<p><strong>mmm_agentd：</strong>运行在每个mysql服务器上的代理进程，完成监控的探针工作和执行简单的远端服务设置。此脚本需要在被监管机上运行。</p> \n<p><strong>mmm_control：</strong>一个简单的脚本，提供管理mmm_mond进程的命令。</p> \n<p>mysql-mmm的监管端会提供多个虚拟IP（VIP），包括一个可写VIP，多个可读VIP，通过监管的管理，这些IP会绑定在可用mysql之上，当某一台mysql宕机时，监管会将VIP迁移至其他mysql。</p> \n<p>在整个监管过程中，需要在mysql中添加相关授权用户，以便让mysql可以支持监理机的维护。授权的用户包括一个mmm_monitor用户和一个mmm_agent用户，如果想使用mmm的备份工具则还要添加一个mmm_tools用户。</p> \n<h6><strong>2.3.架构图</strong></h6> \n<p>正常工作时： </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313467\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>主节点故障时： </p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313468\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h6><strong>2.4.MMM优点</strong></h6> \n<p>（1）高可用性，扩展性好，出现故障自动转移，对于主主同步，在同一时间只提供一台数据库写操作，保证数据的一致性。</p> \n<p>（2）配置简单，容易操作。</p> \n<h6><strong>2.5.MMM缺点</strong></h6> \n<p>（1）需要一台备份服务器，浪费资源</p> \n<p>（2）需要多个虚拟IP</p> \n<p>（3）agent可能意外终止，引起裂脑。</p> \n<h4><strong>3.MHA介绍</strong></h4> \n<hr> \n<p>MHA（Master High Availability）目前在MySQL高可用方面是一个相对成熟的解决方案，它由日本DeNA公司youshimaton（现就职于Facebook公司）开发，是一套优秀的作为MySQL高可用性环境下故障切换和主从提升的高可用软件。在MySQL故障切换过程中，MHA能做到在0~30秒之内自动完成数据库的故障切换操作，并且在进行故障切换的过程中，MHA能在最大程度上保证数据的一致性，以达到真正意义上的高可用。</p> \n<h6><strong>3.1.MHA架构介绍</strong></h6> \n<p>该软件由两部分组成：MHA Manager（管理节点）和MHA Node（数据节点）。MHA Manager可以单独部署在一台独立的机器上管理多个master-slave集群，也可以部署在一台slave节点上。MHA Node运行在每台MySQL服务器上，MHA Manager会定时探测集群中的master节点，当master出现故障时，它可以自动将最新数据的slave提升为新的master，然后将所有其他的slave重新指向新的master。整个故障转移过程对应用程序完全透明。</p> \n<p>在MHA自动故障切换过程中，MHA试图从宕机的主服务器上保存二进制日志，最大程度的保证数据的不丢失(配合mysql半同步复制效果更佳)，但这并不总是可行的。例如，如果主服务器硬件故障或无法通过ssh访问，MHA没法保存二进制日志，只进行故障转移而丢失了最新的数据。使用MySQL 5.5的半同步复制，可以大大降低数据丢失的风险。MHA可以与半同步复制结合起来。如果只有一个slave已经收到了最新的二进制日志，MHA可以将最新的二进制日志应用于其他所有的slave服务器上，因此可以保证所有节点的数据一致性。</p> \n<p>注意：目前MHA主要支持一主多从的架构，要搭建MHA,要求一个复制集群中必须最少有三台数据库服务器，一主二从，即一台充当master，一台充当备用master，另外一台充当从库，因为至少需要三台服务器，出于机器成本的考虑，淘宝也在该基础上进行了改造，目前淘宝TMHA已经支持一主一从。</p> \n<h6><strong>3.2.MHA架构图</strong></h6> \n<p>正常工作时架构图：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313469\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>主库down机时架构：</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313466\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h6><strong>3.3.故障转移过程</strong></h6> \n<p>（1）从宕机崩溃的master保存二进制日志事件（binlog events）;</p> \n<p>（2）识别含有最新更新的slave；</p> \n<p>（3）应用差异的中继日志（relay log）到其他的slave；</p> \n<p>（4）应用从master保存的二进制日志事件（binlog events）；</p> \n<p>（5）提升一个slave为新的master；</p> \n<p>（6）使其他的slave连接新的master进行复制；</p> \n<p>（7）在新的master启动vip地址，保证前端请求可以发送到新的master。</p> \n<h6><strong>3.4.MHA优点</strong></h6> \n<p>（1）不需要备份服务器</p> \n<p>（2）不改变现有环境</p> \n<p>（3）操作非常简单</p> \n<p>（4）可以进行日志的差异修复</p> \n<p>（5）可以将任意slave提升为master</p> \n<h6><strong>3.5.MHA缺点</strong></h6> \n<p>（1）需要全部节点做ssh秘钥</p> \n<p>（2）MHA出现故障后配置文件会被修改，如果再次故障转移需要重新修改配置文件。</p> \n<p>（3）自带的脚本还需要进一步补充完善，且用perl开发，二次开发困难。</p> \n<h4><strong>4.DRBD+（heartbeat,corosync）</strong></h4> \n<hr> \n<h6>4.1.<strong>方案简介</strong> </h6> \n<p>本方案采用Heartbeat或者corosync双机热备软件来保证数据库的高稳定性和连续性，数据的一致性由DRBD这个工具来保证（如果可以尽量放到分布式存储上面）。默认情况下只有一台mysql在工作，当主mysql服务器出现问题后，系统将自动切换到备机上继续提供服务，当主数据库修复完毕，又将服务切回继续由主mysql提供服务。</p> \n<h6>4.2.<strong>组件</strong> </h6> \n<p>Heartbeat,corosync作为心跳检测机制，监控primary节点的状态。当主节点宕掉之后，迅速提升secondary节点为新的主节点，并切换IP；</p> \n<p><strong>drbd</strong>负责数据同步</p> \n<h6>4.3.<strong>架构图</strong> </h6> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313465\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<h6>4.4.<strong>数据同步过程</strong> </h6> \n<p>mysql进行刷盘时，会通过不同的sync方式，最终将数据写入disk；</p> \n<p>drbd收到刷盘成功的信息后，将对应的磁盘块位置，和变更动作，通过网络传递至secondary节点；</p> \n<p>secondary的drbd接收到变更信息后，将这些信息落盘；</p> \n<h6>4.5.<strong>切换过程</strong> </h6> \n<p>前提：secondary节点的mysql服务不启动；</p> \n<p>heartbeat检测到primary的mysql服务停止，则摘掉IP、umount掉数据盘、将primary切换为secondary；</p> \n<p>在原来的secondary上，提升drbd同步为primary，挂载数据盘，启动mysql服务、绑定IP；</p> \n<p>从库跟着IP和端口自动进行迁移；</p> \n<h6>4.6.<strong>方案优点</strong> </h6> \n<p>（1）历史悠久、安全性高、稳定性高、可用性高、出现故障自动切换。</p> \n<p>（2）数据一致性强</p> \n<h6>4.7.<strong>方案缺点</strong> </h6> \n<p>（1）需要一台备份服务器，浪费资源</p> \n<p>（2）不方便扩展</p> \n<p>（3）无论drbd还是headbetart，corosync都可能发生裂脑</p> \n<h4><strong>5.Mysql route介绍</strong></h4> \n<hr> \n<h6><strong>5.1.什么是mysql route</strong></h6> \n<p>MySQL Router是处于应用client和dbserver之间的轻量级代理程序，它能检测，分析和转发查询到后端数据库实例，并把结果返回给client。是mysql-proxy的一个替代品。其架构图和功能如下。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022313470\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"\" title=\"\"></span></p> \n<p>（1）Router实现读写分离，程序不是直接连接数据库IP，而是固定连接到mysql router。MySQL Router对前端应用是透明的。应用程序把MySQL Router当作是普通的mysql实例，把查询发给MySQL Router,而MySQL Router会把查询结果返回给前端的应用程序。</p> \n<p>（2）从数据库服务器故障，业务可以正常运行。由MySQL Router来进行自动下线不可用服务器。程序配置不需要任何修改。</p> \n<p>（3）主数据库故障，由MySQL Router来决定主从自动切换，业务可以正常访问。程序配置不需要做任何修改。</p> \n<h6><strong>5.2.读写分离原理</strong></h6> \n<p>MySQL Router接受前端应用程序请求后，根据不同的端口来区分读写，把连接读写端口的所有查询发往主库，把连接只读端口的select查询以轮询方式发往多个从库，从而实现读写分离的目的。读写返回的结果会交给MySQL Router,由MySQL Router返回给客户端的应用程序。</p> \n<h6><strong>5.3.Mysql router用途</strong></h6> \n<p>MySQL Router的主要用途是读写分离，主主故障自动切换，负载均衡，连接池等。</p> \n<h6><strong>5.4.Mysql router主主故障自动切换的坑</strong></h6> \n<p>Mysql router主主故障切换功能经过测试没有问题，但是有一个比较大的坑需要注意，主库发生切换之后，从库的连接的master服务器地址不会发生改变，需要自己写脚本进行判断。</p> \n<h6>5.5.优点</h6> \n<p>（1）基于DAL层实现mysql的高可用。</p> \n<p>（2）可以同时实现主主故障切换和读写分离。</p> \n<p>（3）插件式架构允许用户进行额外的功能扩展。</p> \n<h6><strong>5.6.缺点</strong></h6> \n<p>（1）高可用功能需要进一步完善：存在主库切换之后，从库不会自动切换主库地址的坑。</p> \n<p>（2）读写情况使用不同端口，需要修改应用程序。</p> \n<h4><strong>6.mysql Cluster</strong></h4> \n<hr> \n<p>国内用的非常少，主要因为一下三点：</p> \n<p>（1）需要更改存储引擎</p> \n<p>（2）付费</p> \n<p>（3）国内几乎没有使用案例</p> \n<p><strong>优点：</strong></p> \n<p>高可用，可用率达99.999%</p> \n<h4>7.结束语</h4> \n<p>上面的高可用方案，只是我自己比较熟悉的，而且也是应用比较多的。mysql毕竟发展了有20多年了，各种高可用方案还是很多的，其他的高可用方案各位钥匙有兴趣，可以自己研究。</p>', 'https://segmentfault.com/img/remote/1460000022313467', '3f69fcc9b13843d1910b3dac597f5215', '1a77ff8ac4c54e58b5e6b22210cff64f,83f62facb3b943ffa8e46abd1ebc64d9,d7416e100af54eb7a4d9274b9a462240,55723db96b9f4593bae02bc1e49f1e87,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 16:47:13', '2020-04-16 16:47:13');
INSERT INTO `tb_recommend` VALUES ('fc7c3d61ab3f48f69b7efe4055c7e4d4', '玩玩生命游戏', '康威生命游戏，元胞自动机的一种，属于简单形态变幻出复杂形态的案例 简述一下其规则 每个格子表示一个细胞，分活的和死的两种；格子周围表示8个位置(边界除外) 当为活细胞时 周围有0个或1个活细胞，下一回合该细...', '<p>康威生命游戏，元胞自动机的一种，属于简单形态变幻出复杂形态的案例</p> \n<p>简述一下其规则</p> \n<blockquote>\n 每个格子表示一个细胞，分活的和死的两种；格子周围表示8个位置(边界除外)\n</blockquote> \n<ul> \n <li> <p>当为活细胞时</p> \n  <ul> \n   <li>周围有0个或1个活细胞，下一回合该细胞死亡(资源不足)</li> \n   <li>周围有2个或3个活细胞，下一回合依然存活</li> \n   <li>周围大于3个，下一回合也死亡(竞争)</li> \n  </ul> </li> \n <li> <p>当为死细胞时</p> \n  <ul> \n   <li>只有周围恰好为3个活细胞的时候，下一回合复活</li> \n   <li>否则依然是死的</li> \n  </ul> </li> \n</ul> \n<p>规则就这么简单，以下是展示，给定一个初始状态，最终会到什么状态终止，或者不能终止，随便玩玩，看看有能有什么新发现！！！</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbF6qi\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"QQ截图20200416092318.png\" title=\"QQ截图20200416092318.png\"></span></p> \n<p>喜欢的点赞收藏吧！！！</p>', 'https://segmentfault.com/img/bVbF6qi', '1c5851dc916d4e70a60f0c957f548876', 'd79254c4ca5e45dca9d484307c935281,63c4e1e7ec204b43a62065a3ced4c2ce,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 16:48:02', '2020-04-16 16:48:02');
INSERT INTO `tb_recommend` VALUES ('fccc4bd0640f443c9b490cfc44880e75', '看完这一篇，再也不用担心 Git 的“黑魔法”', '简介：相信大部分开发者对 Git 都不陌生，Git 也已成为大部分开发者日常开发必用的工具。本文分享 Git 使用上的一些基础知识，通俗易懂，非常有用。', '<p><strong>简介：</strong>相信大部分开发者对 Git 都不陌生，Git 也已成为大部分开发者日常开发必用的工具。本文分享 Git 使用上的一些基础知识，通俗易懂，非常有用。</p> \n<h5>更多相关内容：<a href=\"https://developer.aliyun.com/article/754374?utm_content=g_1000111743\" rel=\"nofollow noreferrer\">点击这里</a>​</h5> \n<p>在 Git Rev News #48 期的 LightReading 中有一篇文章（地址：<a href=\"https://hacker-tools.github.io/version-control/\" rel=\"nofollow noreferrer\">https://hacker-tools.github.io/version-control/</a>） 写的不错，不仅干货满满而且还附带了操作视频。其中的内容不仅覆盖了很多 Git 使用上的基础知识，也从使用角度上解答了很多刚接触 Git 的开发者的疑问。为了便于读者理解，我在翻译的同时也添加了一些内容。以下为正文部分。本文内容较长，建议收藏慢慢学习。</p> \n<h3>担忧</h3> \n<p>很多人怕使用 Git，我个人觉得主要可能是两部分的原因：</p> \n<ul> \n <li>没接触过：平时接触的代码还托管在 SVN 或 CVS 等工具上。</li> \n <li>不太熟悉：可能对 Git 的使用还不太熟悉和全面，导致了在使用 git 时步步为营。</li> \n</ul> \n<blockquote>\n Never Be Afraid To Try Something New.\n</blockquote> \n<p>代码对于开发者是劳作成果的结晶，对于公司而言是核心资产，有一些担忧也是正常的。但 Git 也并没有我们想象中的那么复杂，需要让我们每次使用都心有余悸，其实我们只需要稍微花一点时间尝试多多了解它，在很多时候你会发现，非但 Git 不会让你产生担忧，而且会让自己的交付过程更加高效。</p> \n<h3>Version Control</h3> \n<p>谈及 Git 就不得不提到版本控制，我们不妨先来看下版本控制是做什么的，这将有助于后续对 Git 的理解。</p> \n<p>当你在工作中面对的是一些经常变化的文档、代码等交付物的时候，考虑如何去追踪和记录这些 changes 就变得非常重要，原因可能是：对于频繁改动和改进的交付物，非常有必要去记录下每次变更的内容，每次记录的内容汇成了一段修改的历史，有了历史我们才知道我们曾经做了什么。</p> \n<p>记录的历史中必须要包含一些重要的信息，这样追溯才变得有意义，比如：</p> \n<ul> \n <li>Who：是谁执行的变更？</li> \n <li>When：什么时候做出的变更？</li> \n <li>What：这次变更做了什么事情？</li> \n</ul> \n<p>最好可以支持撤销变更，不让某一个提交的严重问题，去污染整个提交历史。</p> \n<p>版本控制系统（VCS: Version Control System），正会为你提供这种记录和追溯变更的能力。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022325226\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>大多数的 VCS 支持在多个使用者之间共享变更的提交历史，这从实质上让团队协同变为了可能，简单说来就是：</p> \n<ul> \n <li>你可以看到我的变更提交。</li> \n <li>我也可以看到你的变更提交。</li> \n <li>如果双方都进行了变更提交，也可以以某种方式方法进行比对和合并，最终作出统一的变更版本。</li> \n</ul> \n<p>VCS 历经多年的发展，目前业界中有许多 VCS 工具可供我们选择。在本文中，我们将会针对目前最流行的 Git 来介绍。</p> \n<h3>Git 是黑魔法么？</h3> \n<p>刚接触 Git 时，Git 确实有让人觉得有点像黑魔法一样神秘，但是又有哪个技术不是这样呢？当我们了解其基本的数据结构结构后，会发现 Git 从使用角度来讲其实并不复杂，我们甚至可以更进一步的学习 Git 的一些优良的软件设计理论，从中获益。首先，让我们先从 commit 说起。</p> \n<h4>git object commit</h4> \n<p>提交对象(git commit object)：每一个提交在 Git 中都通过 git commit object 存储，对象具有一个全局唯一的名称，叫做 revision hash。它的名字是由 SHA-1 算法生成，形如\"<code>998622294a6c520db718867354bf98348ae3c7e2</code>\"，我们通常会取其缩写方便使用，如\"<code>9986222</code>\"。</p> \n<ul> \n <li>对象构成：commit 对象包含了 author + commit message 的基本信息。</li> \n <li>对象存储：git commit object 保存一次变更提交内的所有变更内容，而不是增量变化的数据 delta (很多人都理解错了这一点)，所以 Git 对于每次改动存储的都是全部状态的数据。</li> \n <li>大对象存储：因对于大文件的修改和存储，同样也是存储全部状态的数据，所以可能会影响 Git 使用时的性能(glfs 可以改进这一点）。</li> \n <li>提交树：多个 commit 对象会组成一个提交树，它让我们可以轻松的追溯 commit 的历史，也能对比树上 commit 与 commit 之间的变更差异。</li> \n</ul> \n<h4>git commit 练习</h4> \n<p>让我们通过实战来帮助理解，第一步我们来初始化一个 repository（Git 仓库），默认初始化之后仓库是空的，其中既没有保存任何文本内容也没有附带任何提交：</p> \n<pre><code>$ git init hackers\n$ cd hackers\n$ git status</code></pre> \n<p>第二步，让我们来看下执行过后 Git 给出的输出内容，它会指引我们进行进一步的了解：</p> \n<pre><code>➜  hackers git:(master) git status\nOn branch master\nNo commits yet\nnothing to commit (create/copy files anduse \"git add\" to track)</code></pre> \n<p>1）output 1: On branch master</p> \n<p>对于刚刚创建空仓库来说，master 是我们的默认分支，一个 Git 仓库下可以有很多分支 (branches)，具体某一个分支的命名可以完全由你自己决定，通常会起便于理解的名字，如果用 hash 号的话肯定不是一个好主意。</p> \n<p>branches 是一种引用 (ref)，他们指向了一个确定的 commit hash 号，这样我们就可以明确我们的分支当前的内容。</p> \n<p>除了 branches 引用以外，还有一种引用叫做 tags，相信大家也不会陌生。</p> \n<p>master 通常被我们更加熟知，因为大多数的分支开发模式都是用 master 来指向“最新”的 commit。</p> \n<p>On branch master 代表着我们当前是在 master 分支下操作，所以每次当我们在提交新的 commit 时，Git 会自动将 master 指向我们新的 commit，当工作在其他分支上时，同理。</p> \n<p>有一个很特殊的 ref 名称叫做 \"HEAD\"，它指向我们当前正在操作的 branches 或 tags (正常工作时)，其命名上非常容易理解，表示当前的引用状态。</p> \n<p>通过<code>git branch</code>(或<code>git tag</code>) 命令你可以灵活的操作和修改 branches 或 tags。</p> \n<p>2）output 2：No commits yet</p> \n<p>对于空仓库来说，目前我们还没有进行任意的提交。</p> \n<blockquote>\n nothing to commit (create/copy files anduse \"git add\" to track)\n</blockquote> \n<p>output 中提示我们需要使用<code>git add</code>命令，说到这里就必须要提到暂存或索引 (stage)，那么如何去理解暂存呢？</p> \n<h4>暂存</h4> \n<p>一个文件从改动到提交到 Git 仓库，需要经历三个状态：</p> \n<ul> \n <li>工作区：工作区指的是我们本地工作的目录，比如我们可以在刚才创建的 hackers 目录下新增一个 readme 文件，readme 文件这时只是本地文件系统上的修改，还未存储到 Git。</li> \n <li>暂存(索引)区：暂存实际上是将我们本地文件系统的改动转化为 Git 的对象存储的过程。</li> \n <li>仓库：git commit 后将提交对象存储到 Git 仓库。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022325227\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>git add 的帮助文档中很详细的解释了暂存这一过程：</p> \n<blockquote>\n This command updates the index using thecurrent content found in the working tree, to prepare the content stagedfor the next commit.\n</blockquote> \n<p>git add 命令将更新暂存区，为接下来的提交做准备。</p> \n<blockquote>\n It typically adds the current content ofexisting paths as a whole, but with some options it can also be used toadd content with only part of the changes made to the working tree filesapplied, or remove paths that do not exist in the working tree anymore.\n <p>The \"index\" holds a snapshot ofthe content of the working tree, and it is this snapshot that is taken as thecontents of the next commit.</p> \n</blockquote> \n<p>暂存区的 index 保存的是改动的完整文件和目录的快照 (非 delta）。</p> \n<blockquote>\n Thus after making any changes to theworking tree, and before running the commit command, you must use the addcommand to add any new or modified files to the index.\n</blockquote> \n<p>暂存是我们将改动提交到 git 仓库之前必须经历的状态。</p> \n<p>对 Git 暂存有一定了解后，其相关操作的使用其实也非常简单，简要的说明如下：</p> \n<p>1）暂存区操作</p> \n<ul> \n <li>通过<code>git add</code>命令将改动暂存。</li> \n <li>可以使用<code>git add -p</code>来依次暂存每一个文件改动，过程中我们可以灵活选择文件。中的变更内容，从而决定哪些改动暂存。</li> \n <li>如果<code>git add</code>不会暂存被 ignore 的文件改动。</li> \n <li>通过<code>git rm</code>命令，我们可以删除文件的同时将其从暂存区中剔除。</li> \n</ul> \n<p>2）暂存区修正</p> \n<ul> \n <li>通过<code>git reset</code>命令进行修正，可以先将暂存区的内容清空，在使用<code>git add -p</code>命令对改动 review 和暂存。</li> \n <li>这个过程不会对你的文件进行任何修改操作，只是 Git 会认为目前没有改动需要被提交 。</li> \n <li>如果我们想分阶段(or 分文件)进行 reset，可以使用<code>git reset FILE</code>或<code>git reset -p</code>命令。</li> \n</ul> \n<p>3）暂存区状态</p> \n<ul> \n <li>可以用<code>git diff --staged</code>依次检查暂存区内每一个文件的修改。</li> \n <li>用<code>git diff</code>查看剩余的还未暂存内容的修改。</li> \n</ul> \n<h4>Just Commit！</h4> \n<p>当你对需要修改的内容和范围满意时，你就可以将暂存区的内容进行 commit 了，命令为：<code>git commit</code>。</p> \n<p>如果你觉得需要把所有当前工作空间的修改全部 commit，可以执行<code>git commit -a</code>，这相当于先执行<code>git add</code>后执行<code>git commit</code>，将暂存和提交的指令合二为一，这对于一些开发者来说是很高效的，但是如果提交过大这样做通常不合适。</p> \n<p>我们建议一个提交中只做一件事，这在符合单一职责的同时，也可以让我们明确的知道每一个 commit 中做了一件什么事情而不是多个事情。所以通常我们的使用习惯都是执行<code>git add -p</code>来 review 我们将要暂存内容是否合理？是否需要更细的拆分提交？这些优秀的工程实践，将会让代码库中的 commits 更加优雅。</p> \n<p>ok，我们已经在不知不觉中了解了很多内容，我们来回顾下，它们包括了：</p> \n<ul> \n <li>commit 包含的信息？</li> \n <li>commit 是如何表示的？</li> \n <li>暂存区是什么？如何全部添加、一次添加、删除、查询和修正？</li> \n <li>如何将暂存区的改动内容 commit？</li> \n <li>不要做大提交，一个提交只做一件事。</li> \n</ul> \n<p>附带的，在了解 commit 过程中我们知道了从本地改动到提交到 Git 仓库，经历的几个关键的状态：</p> \n<ul> \n <li>工作区 (Working Directory)</li> \n <li>暂存区 (Index)</li> \n <li>Git 仓库 (Git Repo)</li> \n</ul> \n<p>下图为上述过程中各个状态的转换过程：</p> \n<ul> \n <li>本地改动文件时，此时还仅仅是工作区内的改动</li> \n <li>当执行 git add 之后，工作区内的改动被索引在暂存区</li> \n <li>当执行<code>git commit</code>之后，暂存区的内容对象将会存储在 Git 仓库中，并执行更新 HEAD 指向等后续操作，这样就完成了引用与提交、提交与改动快照的——对应了。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022325229\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>正是因为 Git 本身对于这几个区域(状态)的设计，为 Git 在本地开发过程带来了灵活的管理空间。我们可以根据自己的情况，自由的选择哪些改动暂存、哪些暂存的改动可以 commit、commit 可以关联到那个引用，从而进一步与其他人进行协同。</p> \n<h3>提交之后</h3> \n<p>我们已经有了一个 commit，现在我们可以围绕 commit 做更多有趣的事情：</p> \n<ul> \n <li>查看 commit 历史：<code>git log</code>(或<code>git log --oneline</code>)。</li> \n <li>在 commit 中查看改动的<code>diff:git log -p</code>。</li> \n <li>查看 ref 与提交的关联关系，如当前 master 指向的 commit: git show master 。</li> \n <li>检出覆盖：<code>git checkout NAME</code>（如果 NAME 是一个具体的提交哈希值时，Git 会认为状态是 “detached (分离的)”，因为<code>git checkout</code>过程中重要的一步是将 HEAD 指向那个分支的最后一次 commit。所以如果这样做，将意味着没有分支在引用此提交，所以若我们这时候进行提交的话，没有人会知道它们的存在）。</li> \n <li>使用<code>git revert NAME</code>来对 commit 进行反转操作。</li> \n <li>使用<code>git diff NAME</code>将旧版本与当前版本进行比较，查看 diff。</li> \n <li>使用<code>git log NAME</code>查看指定区间的提交。</li> \n <li>使用<code>git reset NAME</code>进行提交重置操作。</li> \n <li>使用<code>git reset --hard NAME</code>：将所有文件的状态强制重置为 NAME 的状态，使用上需要小心。</li> \n</ul> \n<h3>引用基本操作</h3> \n<p>引用 (refs) 包含两种分别是 branches 和 tags， 我们接下来简单介绍下相关操作：</p> \n<ul> \n <li> <code>git branch b</code>命令可以让我们创建一个名称为 b 的分支。</li> \n <li>当我们创建了一个 b 分支后，这也相当于意味着 b 的指向就是 HEAD 对应的commit。</li> \n <li>我们可以先在 b 分支上创建一个新的 commit A ，然后假如切回 master 分支上，这时再提交了一个新的 commit B，那么 master 和 HEAD 将会指向了新的commit __B，而 b 分支指向的还是原来的 commit A。</li> \n <li> <code>git checkout b</code>可以切换到b分支上,切换后新的提交都会在b分支上，理所应当。</li> \n <li> <code>git checkout master</code>切换回 master 后，b 分支的提交也不会带回 master 上，分支隔离。</li> \n</ul> \n<p>分支上提交隔离的设计，可以让我们非常轻松的切换我们的修改，非常方便的做各类测试。</p> \n<p>tags 的名称不会改变，而且它们有自己的描述信息 (比如可以作为 release note 以及标记发布的版本号等)。</p> \n<h3>做好你的提交</h3> \n<p>可能很多人的提交历史是长这个样子的：</p> \n<pre><code>commit 14: add feature x – maybe even witha commit message about x!\ncommit 13: forgot to add file\ncommit 12: fix bug \ncommit 11: typo\ncommit 10: typo2\ncommit 9: actually fix\ncommit 8: actually actually fix\ncommit 7: tests pass\ncommit 6: fix example code\ncommit 5: typo\ncommit 4: x\ncommit 3: x\ncommit 2: x\ncommit 1: x</code></pre> \n<p>单就 Git 而言，这看上去是没有问题而且合法的，但对于那些对你修改感兴趣的人（很可能是未来的你!），这样的提交在信息在追溯历史时可能并没有多大帮助。但是如果你的提交已经长成这个样子，我们该怎么办？</p> \n<p>没关系，Git 有办法可以弥补这一些：</p> \n<h4>git commit --amend</h4> \n<p>我们可以将新的改动提交到当前最近的提交上，比如你发现少改了什么，但是又不想多出一个提交时会很有用。</p> \n<p>如果我们认为我们的提交信息写的并不好，我要修改修改，这也是一种办法，但是并不是最好的办法。</p> \n<p>这个操作会更改先前的提交，并为其提供新的 hash 值。</p> \n<h4>git rebase -i HEAD~13</h4> \n<p>这个命令非常强大，可以说是 Git 提交管理的神器，此命令含义是我们可以针对之前的 13 次的提交在 VI 环境中进行重新修改设计：</p> \n<p>操作选项 p 意味着保持原样什么都不做，我们可以通过 vim 中编辑提交的顺序，使其在提交树上生效。</p> \n<p>操作选项 r：我们可以修改提交信息，这种方式比<code>commit --amend</code>要好的多，因为不会新生成一个 commit。</p> \n<p>操作选项 e：我们可以修改 commit，比如新增或者删除某些文件改动。</p> \n<p>操作选项 s：我们可以将这个提交与其上一次的提交进行合并，并重新编辑提交信息。</p> \n<p>操作选项 f：f代表着 \"fixup\"。例如我们如果想针对之前一个老的提交进行 fixup，又不想做一次新的提交破坏提交树的历史的逻辑含义，可以采用这种方式，这种处理方式非常优雅。</p> \n<h3>关于 Git</h3> \n<p>版本控制的一个常见功能是允许多个人对一组文件进行更改，而不会互相影响。或者更确切地说，为了确保如果他们不会踩到彼此的脚趾，不会在提交代码到服务端时偷偷的覆盖彼此的变化。</p> \n<p>在 Git 中我们如何保证这一点呢？</p> \n<p>Git 与 SVN 不同，Git 不存在本地文件存在 lock 的情况，这是一种避免出现写作问题的方式，但是并不方便，而 Git 与 SVN 最大的不同在于它是一个分布式 VCS，这意味着：</p> \n<ul> \n <li>每个人都有整个存储库的本地副本（其中不仅包含了自己的，也包含了其他人的提交到仓库的所有内容）。</li> \n <li>一些 VCS 是集中式的（例如 SVN）：服务器具有所有提交，而客户端只有他们“已检出”的文件。所以基本上在本地我们只有当前文件，每次涉及本地不存在的文件操作时，都需要访问服务端进行进一步交互。</li> \n <li>每一个本地副本都可以当作服务端对外提供 Git 服务。</li> \n <li>我们可以用<code>git push</code>推送本地内容到任意我们有权限的 Git 远端仓库。</li> \n <li>不管是集团的 force、Github、Gitlab 等工具，其实本质上都是提供的 Git 仓库存储的相关服务，在这一点上其实并没有特别之处，针对 Git 本身和其协议上是透明的。</li> \n</ul> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022325228\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>SVN，图片出自 git-scm</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022325230\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"image.png\" title=\"image.png\"></span></p> \n<p>Git，图片出自 git-scm</p> \n<h3>Git 冲突解决</h3> \n<p>冲突的产生几乎是不可避免的，当冲突产生时你需要将一个分支中的更改与另一个分支中的更改合并，对应 Git 的命令为<code>git merge NAME</code>，一般过程如下：</p> \n<ul> \n <li>找到 HEAD 和 NAME 的一个共同祖先 (common base)。</li> \n <li>尝试将这些 NAME 到共同祖先之间的修改合并到 HEAD 上。</li> \n <li>新创建一个 merge commit 对象，包含所有的这些变更内容。</li> \n <li>HEAD 指向这个新的 merge commit。</li> \n</ul> \n<p>Git 将会保证这个过程改动不会丢失，另外一个命令你可能会比较熟悉，那就是<code>git pull</code>命令，<code>git pull</code>命令实际上包含了<code>git merge</code>的过程，具体过程为：</p> \n<ul> \n <li><code>git fetch REMOTE</code></li> \n <li><code>git merge REMOTE/BRANCH</code></li> \n <li>和 git push 一样，有的时候需要先设置 \"tracking\"(-u) ，这样可以将本地和远程的分支一一对应。</li> \n</ul> \n<p>如果每次 merge 都如此顺利，那肯定是非常完美的，但有时候你会发现在合并时产生了冲突文件，这时候也不用担心，如何处理冲突的简要介绍如下：</p> \n<ul> \n <li>冲突只是因为 Git 不清楚你最终要合并后的文本是什么样子，这是很正常的情况。</li> \n <li>产生冲突时，Git 会中断合并操作，并指导你解决好所有的冲突文件。</li> \n <li>打开你的冲突文件，找到<code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code>，这是你需要开始处理冲突的地方，然后找到<code>=======</code>，等号上面的内容是 HEAD 到共同祖先之间的改动，等号下面是 NAME 到共同祖先之间的改动。用 git mergetool 通常是比较好的选择，当然现在大多数 IDE 都集成了不错的冲突解决工具。</li> \n <li>当你把冲突全部解决完毕，请用<code>git add.</code>来暂存这些改动吧。</li> \n <li>最后进行<code>git commit</code>，如果你想放弃当前修改重新解决可以使用<code>git merge --abort</code>，非常方便。</li> \n</ul> \n<p>当你完成了以上这些艰巨的任务，最后<code>git push</code>吧！</p> \n<h3>push 失败？</h3> \n<p>排除掉远端的 Git 服务存在问题以外，我们 push 失败的大多数原因都是因为我们在工作的内容其他人也在工作的关系。</p> \n<p>Git 是这样判断的：</p> \n<p>1）会判断 REMOTE 的当前 commit 是不是你当前正在 pushing commit 的祖先。</p> \n<p>2）如果是的话，代表你的提交是相对比较新的，push 是可以成功的 (fast-forwarding)。</p> \n<p>3）否则 push 失败并提示你其他人已经在你 push 之前执行更新 (push is rejected)。</p> \n<p>当发生“push is rejected”后我们的几个处理方法如下:</p> \n<ul> \n <li>使用<code>git pull</code>合并远程的最新更改（<code>git pull</code>相当于<code>git fetch</code>+<code>git merge</code>)。</li> \n <li>使用 --force 强制推送本地变化到远端引用进行覆盖，需要注意的是 这种覆盖操作可能会丢失其他人的提交内容。</li> \n <li>可以使用<code>--force-with-lease</code>参数，这样只有远端的 ref 自上次从 fetch 后没有改变时才会强制进行更改，否则“reject the push”，这样的操作更安全，是一种非常推荐使用的方式。</li> \n <li>如果 rebase 操作了本地的一些提交，而这些提交之前已经 push 过了的话，你可能需要进行 force push 了，可以想象看为什么？</li> \n</ul> \n<p>本文只是选取部分 Git 基本命令进行介绍，目的是抛砖引玉，让大家对 Git 有一个基本的认识。当我们深入挖掘 Git 时，你会发现它本身有着如此多优秀的设计理念，值得我们学习和探究。</p> \n<p>不要让 Git 成为你认知领域的黑魔法，而是让 Git 成为你掌握的魔法。</p>', 'https://segmentfault.com/img/remote/1460000022325226', '3f69fcc9b13843d1910b3dac597f5215', 'f4fda25145b9451a9b0d77d6a2a63712', '0', '3', '1', '2020-04-16 16:59:45', '2020-04-16 16:59:45');
INSERT INTO `tb_recommend` VALUES ('feb97397bcf34ad59d52175d5dede38f', 'Flutter异常监测与上报', '众所周知，软件项目的交付是一个复杂的过程，任何原因都有可能导致交付的失败。很多时候经常遇到的一个现象是，应用在开发测试时没有任何异常，但一旦上线就问题频出。出现这些异常，可能是因为不充分的机型适配...', '<h1>Flutter异常</h1> \n<p>众所周知，软件项目的交付是一个复杂的过程，任何原因都有可能导致交付的失败。很多时候经常遇到的一个现象是，应用在开发测试时没有任何异常，但一旦上线就问题频出。出现这些异常，可能是因为不充分的机型适配或者用户糟糕的网络状况造成的，也可能是Flutter框架自身缺陷造成的，甚至是操作系统底层的问题。</p> \n<p>而处理此类异常的最佳方式是捕获用户的异常信息，将异常现场保存起来并上传至服务器，然后通过分析异常上下文来定位引起异常的原因，并最终解决此类问题。</p> \n<p>所谓Flutter异常，指的是Flutter程序中Dart代码运行时发生的错误。与Java和OC等多线程模型的编程语言不同，Dart是一门单线程的编程语言，采用事件循环机制来运行任务，所以各个任务的运行状态是互相独立的。也即是说，当程序运行过程中出现异常时，并不需要像Java那样使用try-catch机制来捕获异常，因为即便某个任务出现了异常，Dart程序也不会退出，只会导致当前任务后续的代码不会被执行，而其它功能仍然可以继续使用。</p> \n<p>在Flutter开发中，根据异常来源的不同，可以将异常分为Framework异常和Dart异常。Flutter对这两种异常提供了不同的捕获方式，Framework异常是由Flutter框架引发的异常，通常是由于错误的应用代码造成Flutter框架底层的异常判断引起的，当出现Framework异常时，Flutter会自动弹出一个的红色错误界面。而对于Dart异常，则可以使用try-catch机制和catchError语句进行处理。</p> \n<p>除此之外，Flutter还提供了集中处理框架异常的方案。集中处理框架异常需要使用Flutter提供的FlutterError类，此类的onError属性会在接收到框架异常时执行相应的回调。因此，要实现自定义捕获异常逻辑，只需要为它提供一个自定义的错误处理回调函数即可。</p> \n<h1>异常捕获</h1> \n<p>在Flutter开发中，根据异常来源的不同，可以将异常分为Framework异常和Dart异常。所谓Dart异常，指的是应用代码引起的异常。根据异常代码的执行时序，Dart异常可以分为同步异常和异步异常两类。对于同步异常，可以使用try-catch机制来进行捕获，而异步异常的捕获则比较麻烦，需要使用Future提供的catchError语句来进行捕获，如下所示。</p> \n<pre><code>//使用try-catch捕获同步异常\ntry {\n  throw StateError(\'This is a Dart exception\');\n}catch(e) {\n  print(e);\n}\n\n//使用catchError捕获异步异常\nFuture.delayed(Duration(seconds: 1))\n    .then((e) =&gt; throw StateError(\'This is a Dart exception in Future.\'))\n    .catchError((e)=&gt;print(e));\n</code></pre> \n<p>需要说明的是，对于异步调用所抛出的异常是无法使用try-catch语句进行捕获的，因此下面的写法就是错误的。</p> \n<pre><code>//以下代码无法捕获异步异常\ntry {\n  Future.delayed(Duration(seconds: 1))\n      .then((e) =&gt; throw StateError(\'This is a Dart exception in Future\'))\n}catch(e) {\n  print(\"This line will never be executed\");\n}\n</code></pre> \n<p>因此，对于Dart中出现的异常，同步异常使用的是try-catch，异步异常则使用的是catchError。如果想集中管理代码中的所有异常，那么可以Flutter提供的Zone.runZoned()方法。在Dart语言中，Zone表示一个代码执行的环境范围，其概念类似沙盒，不同沙盒之间是互相隔离的。如果想要处理沙盒中代码执行出现的异常，可以使用沙盒提供的onError回调函数来拦截那些在代码执行过程中未捕获的异常，如下所示。</p> \n<pre><code>//同步抛出异常\nrunZoned(() {\n  throw StateError(\'This is a Dart exception.\');\n}, onError: (dynamic e, StackTrace stack) {\n  print(\'Sync error caught by zone\');\n});\n\n//异步抛出异常\nrunZoned(() {\n  Future.delayed(Duration(seconds: 1))\n      .then((e) =&gt; throw StateError(\'This is a Dart exception in Future.\'));\n}, onError: (dynamic e, StackTrace stack) {\n  print(\'Async error aught by zone\');\n});\n</code></pre> \n<p>可以看到，在没有使用try-catch、catchError语句的情况下，无论是同步异常还是异步异常，都可以使用Zone直接捕获到。<br>同时，如果需要集中捕获Flutter应用中未处理的异常，那么可以把main函数中的runApp语句也放置在Zone中，这样就可以在检测到代码运行异常时对捕获的异常信息进行统一处理，如下所示。</p> \n<pre><code>runZoned&lt;Future&lt;Null&gt;&gt;(() async {\n  runApp(MyApp());\n}, onError: (error, stackTrace) async {\n  //异常处理\n});\n</code></pre> \n<p>除了Dart异常外，Flutter应用开发中另一个比较常见的异常是Framework异常。Framework异常指的是Flutter框架引起的异常，通常是由于执行错误的应用代码造成Flutter框架底层异常判断引起的，当出现Framework异常时，系统会自动弹出一个的红色错误界面，如下图所示。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280731\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>之所以会弹出一个错误提示页面，是由于系统在调用build()方法构建页面时会进行try-catch处理，如果出现任何错误就会调用ErrorWidget页面展示异常信息，并且Flutter框架在很多关键位置都自动进行了异常捕获处理。</p> \n<p>通常，此页面反馈的错误信息对于开发环境的问题定位还是很有帮助的，但如果让线上用户也看到这样的错误页面，体验上就不是很友好比较了。对于Framework异常，最通用的处理方式就是重写ErrorWidget.builder()方法，然后将默认的错误提示页面替换成一个更加友好的自定义提示页面，如下所示。</p> \n<pre><code>ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails){\n  //自定义错误提示页面\n  return Scaffold(\n    body: Center(\n      child: Text(\"Custom Error Widget\"),\n    )\n  );\n};\n</code></pre> \n<h1>应用示例</h1> \n<p>通常，只有当代码运行出现错误时，系统才会给出异常错误提示。为了说明Flutter捕获异常的工作流程，首先来看一个越界访问的示例。首先，新建一个Flutter项目，然后修改main.dart文件的代码，如下所示。</p> \n<pre><code>class MyHomePage extends StatelessWidget {\n @override\n Widget build(BuildContext context) {\n   List&lt;String&gt; numList = [\'1\', \'2\'];\n   print(numList[5]);\n   return Container();\n }\n}\n</code></pre> \n<p>上面的代码模拟的是一个越界访问的异常场景。当运行上面的代码时，控制台会给出如下的错误信息。</p> \n<pre><code>RangeError (index): Invalid value: Not in range 0..2, inclusive: 5</code></pre> \n<p>对于程序中出现的异常，通常只需要在Flutter应用程序的入口main.dart文件中，使用Flutter提供的FlutterError类集中处理即可，如下所示。</p> \n<pre><code>Future&lt;Null&gt; main() async {\n  FlutterError.onError = (FlutterErrorDetails details) async {\n    Zone.current.handleUncaughtError(details.exception, details.stack);\n  };\n  \n  runZoned&lt;Future&lt;void&gt;&gt;(() async {\n    runApp(MyApp());\n  },  onError: (error, stackTrace) async {\n    await _reportError(error, stackTrace);\n  });\n}\n\nFuture&lt;Null&gt; _reportError(dynamic error, dynamic stackTrace) async {\n  print(\'catch error=\'+error);\n}\n</code></pre> \n<p>同时，对于开发环境和线上环境还需要区别对待。因为，对于开发环境遇到的错误，一般是可以立即定位并修复问题的，而对于线上问题才需要对日志进行上报。因此，对于错误日志上报，需要对开发环境和线上环境进行区分对待，如下所示。</p> \n<pre><code>Future&lt;Null&gt; main() async {\n  FlutterError.onError = (FlutterErrorDetails details) async {\n    if (isDebugMode) {\n      FlutterError.dumpErrorToConsole(details);\n    } else {\n      Zone.current.handleUncaughtError(details.exception, details.stack);\n    }\n  };\n   … //省略其他代码\n}\n\nbool get isDebugMode {\n  bool inDebugMode = false;\n  assert(inDebugMode = true);\n  return inDebugMode;\n}\n</code></pre> \n<h1>异常上报</h1> \n<p>目前为止，我们已经对应用中出现的所有未处理异常进行了捕获，不过这些异常还只能被保存在移动设备中，如果想要将这些异常上报到服务器还需要做很多的工作。<br>目前，支持Flutter异常的日志上报的方案有Sentry、Crashlytics等。其中，Sentry是收费的且免费天数只有13天左右，不过它提供的Flutter插件可以帮助开发者快速接入日志上报功能。Crashlytics是Flutter官方支持的日志上报方案，开源且免费，缺点是没有公开的Flutter插件，而flutter_crashlytics插件接入起来也比较麻烦。</p> \n<h2>Sentry方案</h2> \n<p>Sentry是一个商业级的日志管理系统，支持自动上报和手动上报两种方方。在Flutter开发中，由于Sentry提供了Flutter插件，因此如果有日志上报的需求，Sentry是一个不错的选择。<br>使用Sentry之前，需要先在官方网站注册开发者账号。如果还没有Sentry账号，可以先注册一个，然后再创建一个App工程。等待工程创建完成之后，系统会自动生成一个DSN，可以依次点击【Project】→【Settings 】→【Client Keys】来打开DSN，如下图所示。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280734\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>接下来，使用Android Studio打开Flutter工程，在pubspec.yaml文件中添加Sentry插件依赖，如下所示。</p> \n<pre><code>dependencies:\n  sentry: \"&gt;=3.0.0 &lt;4.0.0\"\n</code></pre> \n<p>然后，使用flutter packages get命令将插件拉取到本地。使用Sentry之前，需要先创建一个SentryClient对象，如下所示。</p> \n<pre><code>const dsn=\'\';\nfinal SentryClient _sentry = new SentryClient(dsn: dsn);\n</code></pre> \n<p>为了方便对错误日志进行上传，可以提供一个日志的上报方法，然后在需要进行日志上报的地方调用日志上报方法即可，如下所示。</p> \n<pre><code>Future&lt;void&gt; _reportError(dynamic error, dynamic stackTrace) async {\n  _sentry.captureException(\n      exception: error,\n      stackTrace: stackTrace,\n    );\n}\n\nrunZoned&lt;Future&lt;void&gt;&gt;(() async {\n  runApp(MyApp());\n}, onError: (error, stackTrace) {\n  _reportError(error, stackTrace);         //上传异常日志\n});\n</code></pre> \n<p>同时，开发环境遇到的异常通常是不需要上报的，因为可以立即定位并修复问题，线上遇到的问题才需要进行上报，因此在进行异常上报时还需要区分开发环境和线上环境。</p> \n<pre><code>const dsn=\'https://872ea62a55494a73b73ee139da1c1449@sentry.io/5189144\';\nfinal SentryClient _sentry = new SentryClient(dsn: dsn);\n\nFuture&lt;Null&gt; main() async {\n  FlutterError.onError = (FlutterErrorDetails details) async {\n    if (isInDebugMode) {\n      FlutterError.dumpErrorToConsole(details);\n    } else {\n      Zone.current.handleUncaughtError(details.exception, details.stack);\n    }\n  };\n\n  runZoned&lt;Future&lt;Null&gt;&gt;(() async {\n    runApp(MyApp());\n  }, onError: (error, stackTrace) async {\n    await _reportError(error, stackTrace);\n  });\n}\n\nFuture&lt;Null&gt; _reportError(dynamic error, dynamic stackTrace) async {\n  if (isInDebugMode) {\n    print(stackTrace);\n    return;\n  }\n  final SentryResponse response = await _sentry.captureException(\n    exception: error,\n    stackTrace: stackTrace,\n  );\n\n  //上报结果处理\n  if (response.isSuccessful) {\n    print(\'Success! Event ID: ${response.eventId}\');\n  } else {\n    print(\'Failed to report to Sentry.io: ${response.error}\');\n  }\n}\n\nbool get isInDebugMode {\n  bool inDebugMode = false;\n  assert(inDebugMode = true);\n  return inDebugMode;\n}\n</code></pre> \n<p>在真机上运行Flutter应用，如果出现错误，就可以在Sentry服务器端看到对应的错误日志，如下图所示。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280735\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>除此之外，目前市面上还有很多优秀的日志采集服务厂商，如Testin、Bugly和友盟等，不过它们大多还没有提供Flutter接入方案，因此需要开发者在原生平台进行接入。</p> \n<h2>Bugly方案</h2> \n<p>目前，Bugly还没有提供Flutter插件，那么，我们针对混合工程，可以采用下面的方案。接入Bugly时，只需要完成一些前置应用信息关联绑定和 SDK 初始化工作，就可以使用 Dart 层封装好的数据上报接口去上报异常了。可以看到，对于一个应用而言，接入数据上报服务的过程，总体上可以分为两个步骤：</p> \n<ol> \n <li>初始化 Bugly SDK；</li> \n <li>使用数据上报接口。</li> \n</ol> \n<p>这两步对应着在 Dart 层需要封装的 2 个原生接口调用，即 setup 和 postException，它们都是在方法通道上调用原生代码宿主提供的方法。考虑到数据上报是整个应用共享的能力，因此我们将数据上报类 FlutterCrashPlugin 的接口都封装成了单例，如下所示。</p> \n<pre><code>\nclass FlutterCrashPlugin {\n  //初始化方法通道\n  static const MethodChannel _channel =\n      const MethodChannel(\'flutter_crash_plugin\');\n\n  static void setUp(appID) {\n    //使用app_id进行SDK注册\n    _channel.invokeMethod(\"setUp\",{\'app_id\':appID});\n  }\n  static void postException(error, stack) {\n    //将异常和堆栈上报至Bugly\n    _channel.invokeMethod(\"postException\",{\'crash_message\':error.toString(),\'crash_detail\':stack.toString()});\n  }\n}</code></pre> \n<p>Dart 层是原生代码宿主的代理，可以看到这一层的接口设计还是比较简单的。接下来，我们分别去接管数据上报的 Android 和 iOS 平台上完成相应的实现即可。</p> \n<h3>iOS 接口实现</h3> \n<p>考虑到 iOS 平台的数据上报配置工作相对较少，因此我们先用 Xcode 打开 example 下的 iOS 工程进行插件开发工作。需要注意的是，由于 iOS 子工程的运行依赖于 Flutter 工程编译构建产物，所以在打开 iOS 工程进行开发前，你需要确保整个工程代码至少 build 过一次，否则 IDE 会报错。以下是<a href=\"https://bugly.qq.com/docs/user-guide/instruction-manual-ios/?v=20190712210424\" rel=\"nofollow noreferrer\">Bugly 异常上报 iOS SDK 接入指南</a></p> \n<p>首先，我们需要在插件工程下的 flutter_crash_plugin.podspec 文件中引入 Bugly SDK，即 Bugly，这样我们就可以在原生工程中使用 Bugly 提供的数据上报功能了。</p> \n<pre><code>\nPod::Spec.new do |s|\n  ...\n  s.dependency \'Bugly\'\nend</code></pre> \n<p>然后，在原生接口 FlutterCrashPlugin 类中，依次初始化插件实例、绑定方法通道，并在方法通道中先后为 setup 与 postException 提供 Bugly iOS SDK 的实现版本，如下所示。</p> \n<pre><code>\n@implementation FlutterCrashPlugin\n+ (void)registerWithRegistrar:(NSObject&lt;FlutterPluginRegistrar&gt;*)registrar {\n    //注册方法通道\n    FlutterMethodChannel* channel = [FlutterMethodChannel\n      methodChannelWithName:@\"flutter_crash_plugin\"\n            binaryMessenger:[registrar messenger]];\n    //初始化插件实例，绑定方法通道 \n    FlutterCrashPlugin* instance = [[FlutterCrashPlugin alloc] init];\n    //注册方法通道回调函数\n    [registrar addMethodCallDelegate:instance channel:channel];\n}\n\n- (void)handleMethodCall:(FlutterMethodCall*)call result:(FlutterResult)result {\n    if([@\"setUp\" isEqualToString:call.method]) {\n        //Bugly SDK初始化方法\n        NSString *appID = call.arguments[@\"app_id\"];\n        [Bugly startWithAppId:appID];\n    } else if ([@\"postException\" isEqualToString:call.method]) {\n      //获取Bugly数据上报所需要的各个参数信息\n      NSString *message = call.arguments[@\"crash_message\"];\n      NSString *detail = call.arguments[@\"crash_detail\"];\n\n      NSArray *stack = [detail componentsSeparatedByString:@\"\\n\"];\n      //调用Bugly数据上报接口\n      [Bugly reportExceptionWithCategory:4 name:message reason:stack[0] callStack:stack extraInfo:@{} terminateApp:NO];\n      result(@0);\n  }\n  else {\n    //方法未实现\n    result(FlutterMethodNotImplemented);\n  }\n}\n\n@end</code></pre> \n<p>至此，在完成了 Bugly iOS SDK 的接口封装之后，FlutterCrashPlugin 插件的 iOS 部分也就搞定了。</p> \n<h3>Android 接口实现</h3> \n<p>与 iOS 类似，我们需要使用 Android Studio 打开 example 下的 android 工程进行插件开发工作。同样，在打开 android 工程前，你需要确保整个工程代码至少 build 过一次，否则 IDE 会报错。以下是<a href=\"https://bugly.qq.com/docs/user-guide/instruction-manual-android/\" rel=\"nofollow noreferrer\">Bugly 异常上报 Android SDK 接入指南</a>。</p> \n<p>首先，我们需要在插件工程下的 build.gradle 文件引入 Bugly SDK，即 crashreport 与 nativecrashreport，其中前者提供了 Java 和自定义异常的的数据上报能力，而后者则是 JNI 的异常上报封装，如下所示。</p> \n<pre><code>\ndependencies {\n    implementation \'com.tencent.bugly:crashreport:latest.release\' \n    implementation \'com.tencent.bugly:nativecrashreport:latest.release\' \n}</code></pre> \n<p>然后，在原生接口 FlutterCrashPlugin 类中，依次初始化插件实例、绑定方法通道，并在方法通道中先后为 setup 与 postException 提供 Bugly Android SDK 的实现版本，代码如下。</p> \n<pre><code>\npublic class FlutterCrashPlugin implements MethodCallHandler {\n  //注册器，通常为MainActivity\n  public final Registrar registrar;\n  //注册插件\n  public static void registerWith(Registrar registrar) {\n    //注册方法通道\n    final MethodChannel channel = new MethodChannel(registrar.messenger(), \"flutter_crash_plugin\");\n    //初始化插件实例，绑定方法通道，并注册方法通道回调函数 \n    channel.setMethodCallHandler(new FlutterCrashPlugin(registrar));\n  }\n\n  private FlutterCrashPlugin(Registrar registrar) {\n    this.registrar = registrar;\n  }\n\n  @Override\n  public void onMethodCall(MethodCall call, Result result) {\n    if(call.method.equals(\"setUp\")) {\n      //Bugly SDK初始化方法\n      String appID = call.argument(\"app_id\");\n\n      CrashReport.initCrashReport(registrar.activity().getApplicationContext(), appID, true);\n      result.success(0);\n    }\n    else if(call.method.equals(\"postException\")) {\n      //获取Bugly数据上报所需要的各个参数信息\n      String message = call.argument(\"crash_message\");\n      String detail = call.argument(\"crash_detail\");\n      //调用Bugly数据上报接口\n      CrashReport.postException(4,\"Flutter Exception\",message,detail,null);\n      result.success(0);\n    }\n    else {\n      result.notImplemented();\n    }\n  }\n}</code></pre> \n<p>在完成了 Bugly Android 接口的封装之后，由于 Android 系统的权限设置较细，考虑到 Bugly 还需要网络、日志读取等权限，因此我们还需要在插件工程的 AndroidManifest.xml 文件中，将这些权限信息显示地声明出来，如下所示。</p> \n<pre><code>\n&lt;manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n  package=\"com.hangchen.flutter_crash_plugin\"&gt;\n    &lt;!-- 电话状态读取权限 --&gt; \n    &lt;uses-permission android:name=\"android.permission.READ_PHONE_STATE\" /&gt;\n    &lt;!-- 网络权限 --&gt; \n    &lt;uses-permission android:name=\"android.permission.INTERNET\" /&gt;\n    &lt;!-- 访问网络状态权限 --&gt; \n    &lt;uses-permission android:name=\"android.permission.ACCESS_NETWORK_STATE\" /&gt;\n    &lt;!-- 访问wifi状态权限 --&gt; \n    &lt;uses-permission android:name=\"android.permission.ACCESS_WIFI_STATE\" /&gt;\n    &lt;!-- 日志读取权限 --&gt; \n    &lt;uses-permission android:name=\"android.permission.READ_LOGS\" /&gt;\n&lt;/manifest&gt;</code></pre> \n<p>至此，在完成了极光 Android SDK 的接口封装和权限配置之后，FlutterCrashPlugin 插件的 Android 部分也搞定了。FlutterCrashPlugin 插件为 Flutter 应用提供了数据上报的封装，不过要想 Flutter 工程能够真正地上报异常消息，我们还需要为 Flutter 工程关联 Bugly 的应用配置。</p> \n<h3>应用工程配置</h3> \n<p>在单独为 Android/iOS 应用进行数据上报配置之前，我们首先需要去Bugly 的官方网站，为应用注册唯一标识符（即 AppKey）。这里需要注意的是，在 Bugly 中，Android 应用与 iOS 应用被视为不同的产品，所以我们需要分别注册。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280732\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280736\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span><br>在得到了 AppKey 之后，我们需要依次进行 Android 与 iOS 的配置工作。iOS 的配置工作相对简单，整个配置过程完全是应用与 Bugly SDK 的关联工作，而这些关联工作仅需要通过 Dart 层调用 setUp 接口，访问原生代码宿主所封装的 Bugly API 就可以完成，因此无需额外操作。</p> \n<p>而 Android 的配置工作则相对繁琐些。由于涉及 NDK 和 Android P 网络安全的适配，我们还需要分别在 build.gradle 和 AndroidManifest.xml 文件进行相应的配置工作。首先，由于 Bugly SDK 需要支持 NDK，因此我们需要在 App 的 build.gradle 文件中为其增加 NDK 的架构支持，如下所示。</p> \n<pre><code>\ndefaultConfig {\n    ndk {\n        // 设置支持的SO库架构\n        abiFilters \'armeabi\' , \'x86\', \'armeabi-v7a\', \'x86_64\', \'arm64-v8a\'\n    }\n}</code></pre> \n<p>然后，由于 Android P 默认限制 http 明文传输数据，因此我们需要为 Bugly 声明一项网络安全配置 network_security_config.xml，允许其使用 http 传输数据，并在 AndroidManifest.xml 中新增同名网络安全配置。</p> \n<pre><code>\n//res/xml/network_security_config.xml\n&lt;?xml version=\"1.0\" encoding=\"utf-8\"?&gt;\n&lt;!-- 网络安全配置 --&gt; \n&lt;network-security-config&gt;\n    &lt;!-- 允许明文传输数据 --&gt;  \n    &lt;domain-config cleartextTrafficPermitted=\"true\"&gt;\n        &lt;!-- 将Bugly的域名加入白名单 --&gt; \n        &lt;domain includeSubdomains=\"true\"&gt;android.bugly.qq.com&lt;/domain&gt;\n    &lt;/domain-config&gt;\n&lt;/network-security-config&gt;\n\n//AndroidManifest/xml\n&lt;application\n  ...\n  android:networkSecurityConfig=\"@xml/network_security_config\"\n  ...&gt;\n&lt;/application&gt;</code></pre> \n<p>至此，Flutter 工程所需的原生配置工作和接口实现，就全部搞定了。接下来，我们就可以在 Flutter 工程中的 main.dart 文件中，使用 FlutterCrashPlugin 插件来实现异常数据上报能力了。当然，我们首先还需要在 pubspec.yaml 文件中，将工程对它的依赖显示地声明出来，如下所示。</p> \n<pre><code>\ndependencies:\n  flutter_push_plugin:\n    git:\n      url: xxx</code></pre> \n<p>在下面的代码中，我们在 main 函数里为应用的异常提供了统一的回调，并在回调函数内使用 postException 方法将异常上报至 Bugly。而在 SDK 的初始化方法里，由于 Bugly 视 iOS 和 Android 为两个独立的应用，因此我们判断了代码的运行宿主，分别使用两个不同的 App ID 对其进行了初始化工作。</p> \n<p>此外，为了与你演示具体的异常拦截功能，我们还在两个按钮的点击事件处理中分别抛出了同步和异步两类异常，代码如下：</p> \n<pre><code>\n//上报数据至Bugly\nFuture&lt;Null&gt; _reportError(dynamic error, dynamic stackTrace) async {\n  FlutterCrashPlugin.postException(error, stackTrace);\n}\n\nFuture&lt;Null&gt; main() async {\n  //注册Flutter框架的异常回调\n  FlutterError.onError = (FlutterErrorDetails details) async {\n    //转发至Zone的错误回调\n    Zone.current.handleUncaughtError(details.exception, details.stack);\n  };\n  //自定义错误提示页面\n  ErrorWidget.builder = (FlutterErrorDetails flutterErrorDetails){\n    return Scaffold(\n      body: Center(\n        child: Text(\"Custom Error Widget\"),\n      )\n    );\n  };\n  //使用runZone方法将runApp的运行放置在Zone中，并提供统一的异常回调\n  runZoned&lt;Future&lt;Null&gt;&gt;(() async {\n    runApp(MyApp());\n  }, onError: (error, stackTrace) async {\n    await _reportError(error, stackTrace);\n  });\n}\n\nclass MyApp extends StatefulWidget {\n  @override\n  State&lt;StatefulWidget&gt; createState() =&gt; _MyAppState();\n}\n\nclass _MyAppState extends State&lt;MyApp&gt; {\n  @override\n  void initState() {\n    //由于Bugly视iOS和Android为两个独立的应用，因此需要使用不同的App ID进行初始化\n    if(Platform.isAndroid){\n      FlutterCrashPlugin.setUp(\'43eed8b173\');\n    }else if(Platform.isIOS){\n      FlutterCrashPlugin.setUp(\'088aebe0d5\');\n    }\n    super.initState();\n  }\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      home: MyHomePage(),\n    );\n  }\n}\n\nclass MyHomePage extends StatelessWidget {\n  @override\n  Widget build(BuildContext context) {\n    return Scaffold(\n      appBar: AppBar(\n        title: Text(\'Crashy\'),\n      ),\n      body: Center(\n        child: Column(\n          mainAxisAlignment: MainAxisAlignment.center,\n          children: &lt;Widget&gt;[\n            RaisedButton(\n              child: Text(\'Dart exception\'),\n              onPressed: () {\n                //触发同步异常\n                throw StateError(\'This is a Dart exception.\');\n              },\n            ),\n            RaisedButton(\n              child: Text(\'async Dart exception\'),\n              onPressed: () {\n                //触发异步异常\n                Future.delayed(Duration(seconds: 1))\n                      .then((e) =&gt; throw StateError(\'This is a Dart exception in Future.\'));\n              },\n            )\n          ],\n        ),\n      ),\n    );\n  }\n}</code></pre> \n<p>运行上面的代码，模拟异常上传，然后我们<a href=\"https://bugly.qq.com/v2/workbench/apps\" rel=\"nofollow noreferrer\">打开Bugly 开发者后台</a>，选择对应的 App，切换到错误分析选项查看对应的面板信息。可以看到，Bugly 已经成功接收到上报的异常上下文了，如下图所示。<br><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/remote/1460000022280733\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"在这里插入图片描述\" title=\"在这里插入图片描述\"></span></p> \n<h1>总结</h1> \n<p>对于 Flutter 应用的异常捕获，可以分为单个异常捕获和多异常统一拦截两种情况。其中，单异常捕获，使用 Dart 提供的同步异常 try-catch，以及异步异常 catchError 机制即可实现。而对多个异常的统一拦截，可以细分为如下两种情况：一是 App 异常，我们可以将代码执行块放置到 Zone 中，通过 onError 回调进行统一处理；二是 Framework 异常，我们可以使用 FlutterError.onError 回调进行拦截。</p> \n<p>需要注意的是，Flutter 提供的异常拦截只能拦截 Dart 层的异常，而无法拦截 Engine 层的异常。这是因为，Engine 层的实现大部分是 C++ 的代码，一旦出现异常，整个程序就直接 Crash 掉了。不过通常来说，这类异常出现的概率极低，一般都是 Flutter 底层的 Bug，与我们在应用层的实现没太大关系，所以我们也无需过度担心。</p> \n<p>如果我们想要追踪 Engine 层的异常（比如给 Flutter 提 Issue），则需要借助于原生系统提供的 Crash 监听机制。不过，这方面的内容比较繁琐，具体可以参考：<a href=\"https://github.com/flutter/flutter/wiki/Crashes\" rel=\"nofollow noreferrer\">Flutter官方文档</a></p>', 'https://segmentfault.com/img/remote/1460000022280731', '6fbfa4aaad3a43458f21c8acf0038ac5', '14ab12176ade47da95ba97d7151eb1f9', '0', '3', '1', '2020-04-16 16:47:17', '2020-04-16 16:47:17');
INSERT INTO `tb_recommend` VALUES ('ffb589bcf9004a01aa607824a2a07ddd', 'Remax One - 重新设计小程序的跨平台开发', '小程序作为一项非标准的技术，各个小程序平台之间虽然大体上相似，但依然有非常多的差异。“一次开发多端运行”当然是非常美好的愿望，但我们在设计 Remax 之初就意识到各个小程序平台之间的差异是无法被抹平的，每...', '<h3>跨平台开发的挑战</h3> \n<p>小程序作为一项非标准的技术，各个小程序平台之间虽然大体上相似，但依然有非常多的差异。“一次开发多端运行”当然是非常美好的愿望，但我们在设计 Remax 之初就意识到各个小程序平台之间的差异是无法被抹平的，每家小程序平台有太多的私货，更没有一个标准来指导我们该如何抹平这些差异。</p> \n<p>所以我们在最开始，为每个小程序平台提供了独立的基础组件。开发者如果要做跨平台开发，需要自己去封装基础组件。但很快，我们也意识到这对开发者来说是一件很麻烦的事情，特别是后面我们要支持更多平台的话。</p> \n<h3>Remax One</h3> \n<p>受 CSS 属性名前缀的启发，我们重新设计了 Remax 的跨平台方案。我们非常克制地选取了 9 个基础组件，统一了他们之间非平台私有的属性，并且以属性名前缀的方式来支持各个平台私有的特性。我们希望开发者在做跨平台开发时能清楚地意识到你写下的这行代码只会在特定的平台上生效。</p> \n<p><a href=\"https://remaxjs.org/one/intro\" rel=\"nofollow noreferrer\">Remax One</a> 就是我们提供的跨平台解决方案。通过<code>remax/one</code>提供跨平台的组件。</p> \n<pre><code class=\"js\">import * as React from \'react\';\nimport { View, Button } from \'remax/one\';\n\nexport default () =&gt; {\n  const [count, setCount] = React.useState(0);\n\n  return (\n    &lt;View alipay-onAppear={() =&gt; console.log(\'Aha!\')}&gt;\n      &lt;View&gt;{count}&lt;/View&gt;\n      &lt;Button onTap={() =&gt; setCount(count + 1)}&gt;+1&lt;/Button&gt;\n    &lt;/View&gt;\n  );\n};\n</code></pre> \n<p>可以看到，对于<code>onTap</code>这样通用的属性我们进行了统一，而支付宝独有的<code>onAppear</code>属性，则需要加上<code>alipay-</code>的前缀。</p> \n<p><a href=\"https://link.zhihu.com/?target=https%3A//github.com/remaxjs/examples/tree/master/one\" rel=\"nofollow noreferrer\">完整的示例项目</a></p> \n<h3>使用</h3> \n<p>从模板创建项目：</p> \n<pre><code class=\"bash\">$ npx degit remaxjs/template-one my-app\n$ cd my-app</code></pre> \n<p>或者在已有的项目中引入：</p> \n<pre><code class=\"js\">// remax.config.js\nmodule.export = {\n  // 通过设置 one: true 来开启 Remax One。\n  one: true,\n  // 通过环境变量区分不同平台的输出目录\n  output: \'dist/\' + process.env.REMAX_PLATFORM,\n};\n</code></pre> \n<h2>小程序配置</h2> \n<p><code>app.config.js</code>以及页面的<code>config.js</code>配置文件支持多端配置方式：</p> \n<pre><code class=\"js\">// app.config.js\nconst title = \'小程序标题\';\nconst bgColor = \'#fff\';\nconst pages = [\'pages/index/index\'];\n\n// 支付宝\nexports.alipay = {\n  pages,\n  window: {\n    defaultTitle: title,\n    titleBarColor: backgroundColor,\n  },\n};\n\n// 微信\nexports.wechat = {\n  pages,\n  window: {\n    navigationBarTitleText: title,\n    navigationBarBackgroundColor: backgroundColor,\n  },\n};\n</code></pre> \n<h2>使用文件名后缀区分不同平台代码</h2> \n<p>通过创建不同平台的同名文件来封装跨平台组件和 API。例如：</p> \n<pre><code class=\"js\">// src/api/showToast/index.js\nimport { showToast } from \'remax/alipay\';\n\nexport default showToast;\n// src/api/showToast/index.wechat.js\nimport { showToast } from \'remax/wechat\';\n\nexport default options =&gt; {\n  showToast({\n    ...options,\n    title: options.content,\n  });\n};\n// src/pages/index.js\nimport { View } from \'remax-one\';\nimport showToast from \'@/api/showToast\';\n\nexport default () =&gt; {\n  return (\n    &lt;View\n      onClick={() =&gt; {\n        showToast({ content: \'Hello World!\' });\n      }}\n    &gt;\n      CLICK ME!\n    &lt;/View&gt;\n  );\n};\n</code></pre> \n<p><code>remax-cli</code>会优先读取<code>[target].js</code>文件，这个规则针对 CSS 等其他文件同样有效。</p> \n<h2>组件</h2> \n<p>如上面所说，我们非常克制谨慎地对<code>remax/one</code>中提供的组件做了筛选和重新设计，只保留了我们能保证在各个平台之间行为一致的组件和属性。</p> \n<p>如果需要使用某个平台特有的组件，可以直接从对应平台导入。如：</p> \n<pre><code class=\"js\">import * as React from \'react\';\nimport { View, Text } from \'remax/one\';\nimport { ScrollView } from \'remax/wechat\';\n\nexport default () =&gt; {\n  return (\n    &lt;ScrollView&gt;\n      &lt;View&gt;view&lt;/View&gt;\n      &lt;Text&gt;text&lt;/Text&gt;\n    &lt;/ScrollView&gt;\n  );\n};\n</code></pre> \n<p>如果需要使用某个平台特有的属性，可以通过<code>{平台前缀}-{平台原生属性名称}</code>来设置，例如：</p> \n<pre><code class=\"js\">import * as React from \'react\';\nimport { View, TapEvent } from \'remax-one\';\n\nexport default () =&gt; {\n  return (\n    &lt;View\n      id=\"id\"\n      className=\"class\"\n      alipay-onAppear={() =&gt; {}}\n      wechat-bindanimationend={() =&gt; {}}\n      wechat-disable-scroll={true}\n      onTap={(event: TapEvent) =&gt; {\n        console.log(event);\n      }}\n    &gt;\n      view\n    &lt;/View&gt;\n  );\n};\n</code></pre> \n<p>通过 Remax One 开发者可以非常方便地构建跨小程序平台的应用。</p> \n<p>另外社区同学开发的跨平台组件也正在路上：<a href=\"https://github.com/AnnaSearl/anna-remax-ui\" rel=\"nofollow noreferrer\">https://github.com/AnnaSearl/...</a></p>', null, '1894b118d35d44cb8fe8009529c4154b', '63c4e1e7ec204b43a62065a3ced4c2ce,3b375646301546259a8fb29d74ae4447,15941dc0af92453481b8a0626f963283,219d7aff8dfe4ffc9c8f368e2987187f', '0', '3', '1', '2020-04-16 16:49:28', '2020-04-16 16:49:28');
INSERT INTO `tb_recommend` VALUES ('ffe56d78a1574beba1e27bf4f293cfab', '从零开始的Flutter之旅: StatelessWidget', '小部件是Flutter应用程序的基本构建模块，每一个都是不可变的声明，也是用户界面的一部分。例如button，text，color以及布局所用到的padding等等。', '<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEdtJ\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Flutter - Beautiful native apps in record time.png\" title=\"Flutter - Beautiful native apps in record time.png\"></span></p> \n<p>这次要展示的是什么是Flutter的Widget，即小部件；以及如何在Flutter中使用StatelessWidget，即无状态小部件。</p> \n<p>至于Flutter，通俗的讲是开发者可以通一套简单的代码来同时构建Android与IOS应用程序。</p> \n<h2>特性</h2> \n<p>小部件是Flutter应用程序的基本构建模块，每一个都是不可变的声明，也是用户界面的一部分。例如button，text，color以及布局所用到的padding等等。</p> \n<p>下面我们来看<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>中的一个实例。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEdtU\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"stateless_widget_1.png\" title=\"stateless_widget_1.png\"></span></p> \n<p>圈选中的item只有两个信息，头像与名称。为了避免代码的重复使用，将其抽离成一个独立的widget，具体代码如下</p> \n<pre><code>class FollowersItemView extends StatelessWidget {\n  final GestureTapCallback tapCallback;\n  final String avatarUrl;\n  final String name;\n \n  const FollowersItemView(\n      {Key key, this.avatarUrl, this.name, this.tapCallback})\n      : super(key: key);\n \n  @override\n  Widget build(BuildContext context) {\n    return Container(\n      padding: EdgeInsets.symmetric(horizontal: 15.0),\n      child: GestureDetector(\n        behavior: HitTestBehavior.opaque,\n        onTap: tapCallback,\n        child: Column(\n          children: &lt;Widget&gt;[\n            Row(\n              children: &lt;Widget&gt;[\n                FadeInImage.assetNetwork(\n                  placeholder: \'images/app_welcome.png\',\n                  image: avatarUrl,\n                  width: 80.0,\n                  height: 80.0,\n                ),\n                Expanded(\n                  child: Padding(\n                    padding: EdgeInsets.only(left: 15.0),\n                    child: Text(\n                      name,\n                      overflow: TextOverflow.ellipsis,\n                      maxLines: 1,\n                      style: TextStyle(\n                        color: Colors.grey[600],\n                        fontSize: 20.0,\n                        fontWeight: FontWeight.bold,\n                      ),\n                    ),\n                  ),\n                )\n              ],\n            ),\n            Padding(\n              padding: EdgeInsets.symmetric(vertical: 15.0),\n              child: Divider(\n                thickness: 1.0,\n                color: colorEAEAEA,\n                height: 1.0,\n                endIndent: 0.0,\n              ),\n            ),\n          ],\n        ),\n      ),\n    );\n  }\n}</code></pre> \n<p>它继承于StatelessWidget，StatelessWidget的特性是无状态，数据不可变化。这个性质正好符合我们将要抽离的部件。抽离的部件需要做头像与名称的展示，没有任何形式上的交互变化。唯一的一个交互也是点击，但它并没有涉及数据的改变。所以在代码中将这些数据定义成final类型。本质就如Text部件，并没有如输入文本或者带有动画的部件一样随着时间内部属性会有所变化。</p> \n<p>既然没有任何变化，那么我们也可以将其构造函数定义为const类型。</p> \n<p>有了上面的部件抽离，我们就可以直接在ListView中使用该无状态部件</p> \n<pre><code>  @override\n  Widget createContentWidget() {\n    return RefreshIndicator(\n      onRefresh: vm.handlerRefresh,\n      child: Scrollbar(\n        child: ListView.builder(\n            padding: EdgeInsets.only(top: 15.0),\n            itemCount: vm.list?.length ?? 0,\n            itemBuilder: (BuildContext context, int index) {\n              final item = vm.list[index];\n              return FollowersItemView(\n                avatarUrl: item.avatar_url,\n                name: item.login,\n                tapCallback: () {\n                  Navigator.push(context, MaterialPageRoute(builder: (_) {\n                    return WebViewPage(title: item.login, url: item.html_url);\n                  }));\n                },\n              );\n            }),\n      ),\n    );\n  }</code></pre> \n<p>在ListView中引用FollowItemView，并传入不变的数据即可。</p> \n<h2>呈现原理</h2> \n<p>现在StatelessWidget的使用大家都会了，那它是如何调用的呢？</p> \n<p>下面我们来看下它的呈现原理。</p> \n<p>正如开头所说的将小部件作为Flutter应用构建的基础，在Flutter中我们将小部件的构建称作为Widget Tree，即小部件树。它就像是应用程序的蓝图，我们将蓝图创建好，然后内部会通过蓝图去创建对应显示在屏幕上的element元素。它包含了蓝图上对应的小部件的配置信息。所以对应的还有一个Element Tree，即元素树。</p> \n<p>每一个StatelWidget都有一个StatelessElement，内部会通过createElement()方法进行创建其实例</p> \n<pre><code>  @override\n  StatelessElement createElement() =&gt; StatelessElement(this);</code></pre> \n<p>同时在StatelessElement中会通过buid()方法来获取StalessWidget中所构建的蓝图Widget，并将元素显示到屏幕上。</p> \n<p>Widget Tree与Element Tree之间的交互如下</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEdtW\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"stateless_widget_2.png\" title=\"stateless_widget_2.png\"></span></p> \n<p>FollowerItemView中的StatelessElement会调用build方法来获取它是否有子部件，如果有的话对应的子部件也会创建它们自己的Element，并把它安装到元素树上。</p> \n<p>所以我们的程序有两颗对应的树，其中一颗代表屏幕上显示的内容Element；另一颗树代表其展示的蓝图Widget，它们由许多的小部件组成。</p> \n<p>而我们开发人员所做的就是将这些不同的小部件构建成我们所需要的应用程序。</p> \n<p>最后，我们再来了解下最初的安装入口。</p> \n<pre><code>void main() {\n  runApp(GithubApp());\n}</code></pre> \n<p>在我们的main文件中，有一个main函数，其中调用了runApp方法，传入的是GithubApp。我们再来看下GithubApp是什么？</p> \n<pre><code>class GithubApp extends StatefulWidget {\n  @override\n  _GithubAppState createState() {\n    return _GithubAppState();\n  }\n}\n \nclass _GithubAppState extends State&lt;GithubApp&gt; {\n  @override\n  Widget build(BuildContext context) {\n    return MaterialApp(\n      title: \'Flutter Github\',\n      theme: ThemeData.light(),\n      initialRoute: welcomeRoute.routeName,\n      routes: {\n        welcomeRoute.routeName: (BuildContext context) =&gt; WelcomePage(),\n        loginRoute.routeName: (BuildContext context) =&gt; LoginPage(),\n        homeRoute.routeName: (BuildContext context) =&gt; HomePage(),\n        repositoryRoute.routeName: (BuildContext context) =&gt; RepositoryPage(),\n        followersRoute.routeName: (BuildContext context) =&gt;\n            FollowersPage(followersRoute.pageType),\n        followingRoute.routeName: (BuildContext context) =&gt;\n            FollowersPage(followingRoute.pageType),\n        webViewRoute.routeName: (BuildContext context) =&gt; WebViewPage(title: \'\',),\n      },\n    );\n  }\n}</code></pre> \n<p>发现没它其实也是一个Widget，正如文章开头所说的，Flutter是由各个Widget组成。main是程序的入口，而其中的runApp中的Widget是整个程序挂载的起点。它会创建成一个具有与屏幕宽高一致的根元素，并把它装载到屏幕中。</p> \n<p>所以在Flutter中一直都是通过创建Element，然后调用build方法来获取其后续的子Widget，最终构建成我们所看到的程序。</p> \n<p>文中的代码都是来自于<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>，这是一个基于Flutter的Github客户端同时支持Android与IOS，支持账户密码与认证登陆。使用dart语言进行开发，项目架构是基于Model/State/ViewModel的MSVM；使用Navigator进行页面的跳转；网络框架使用了dio。项目正在持续更新中，感兴趣的可以关注一下。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbEdtZ\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"flutter_github.png\" title=\"flutter_github.png\"></span></p> \n<p>当然如果你想了解Android原生，相信<a href=\"https://github.com/idisfkj/flutter_github\" rel=\"nofollow noreferrer\">flutter_github</a>的纯Android版本<a href=\"https://github.com/idisfkj/AwesomeGithub\" rel=\"nofollow noreferrer\">AwesomeGithub</a>是一个不错的选择。</p> \n<h2>下期预告</h2> \n<p><strong>从零开始的Flutter之旅: StatefulWidget</strong></p> \n<p>如果你喜欢我的文章模式，或者对我接下来的文章感兴趣，建议您关注我的微信公众号：【Android补给站】</p> \n<p>或者扫描下方二维码，与我建立有效的沟通，同时更快更准的收到我的更新推送。</p> \n<p><span class=\"img-wrap\"><img referrerpolicy=\"no-referrer\" data-src=\"/img/bVbsh4i\" src=\"https://cdn.segmentfault.com/v-5e8d8dec/global/img/squares.svg\" alt=\"Android补给站.jpg\" title=\"Android补给站.jpg\"></span></p>', 'https://segmentfault.com/img/bVbEdtJ', '61cdf41d1e5e4f229b76f6a042e254b6', '8dfc62f227ae4076888ea4872e03cddd,14ab12176ade47da95ba97d7151eb1f9,63c4e1e7ec204b43a62065a3ced4c2ce,85ee959b27f74072b13cc763b9bbf77e,81a4561c1c294e0cae32c9fe6b5dc397', '0', '3', '1', '2020-04-16 16:50:20', '2020-04-16 16:50:20');

-- ----------------------------
-- Table structure for tb_recommend_vote
-- ----------------------------
DROP TABLE IF EXISTS `tb_recommend_vote`;
CREATE TABLE `tb_recommend_vote` (
  `uuid` varchar(50) NOT NULL,
  `recommend_id` varchar(50) DEFAULT NULL COMMENT '文章id/问答id',
  `user_id` varchar(50) DEFAULT NULL COMMENT '用户id',
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='文章、问答点赞表';

-- ----------------------------
-- Records of tb_recommend_vote
-- ----------------------------
INSERT INTO `tb_recommend_vote` VALUES ('03c55003e5d6447ca7c4184de302f100', '1ae15e992d764346af4945cf729d2f4d', 'd6754affc7864ea9b67b61e493d28614');
INSERT INTO `tb_recommend_vote` VALUES ('738fe06a7cbf4203ab6d518a53db0448', '03ab3eb0493e471a8410aaf7325866eb', 'd6754affc7864ea9b67b61e493d28614');

-- ----------------------------
-- Table structure for tb_users
-- ----------------------------
DROP TABLE IF EXISTS `tb_users`;
CREATE TABLE `tb_users` (
  `uuid` varchar(50) NOT NULL,
  `nickname` varchar(10) DEFAULT NULL COMMENT '昵称',
  `password` varchar(50) DEFAULT NULL COMMENT '密码',
  `username` varchar(10) DEFAULT NULL COMMENT '真实姓名',
  `phone` varchar(11) DEFAULT NULL COMMENT '手机号码',
  `website` varchar(50) DEFAULT NULL COMMENT '个人网站',
  `email` varchar(50) DEFAULT NULL COMMENT '邮箱',
  `image_url` varchar(255) DEFAULT NULL COMMENT '头像',
  `location_city` varchar(10) DEFAULT NULL COMMENT '所在城市',
  `address` varchar(50) DEFAULT NULL COMMENT '通讯地址',
  `resume_description` varchar(255) DEFAULT NULL COMMENT '履历说明',
  `good_at_technology` varchar(255) DEFAULT NULL COMMENT '擅长技术（逗号隔开）',
  `description` varchar(255) DEFAULT NULL COMMENT '个人简介',
  `create_time` datetime DEFAULT NULL,
  `modify_time` datetime DEFAULT NULL,
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户表';

-- ----------------------------
-- Records of tb_users
-- ----------------------------
INSERT INTO `tb_users` VALUES ('1894b118d35d44cb8fe8009529c4154b', 'kuitos', 'e10adc3949ba59abbe56e057f20f883e', null, '17680697447', null, null, null, null, null, null, null, null, '2020-04-16 16:28:32', '2020-04-16 16:28:32');
INSERT INTO `tb_users` VALUES ('1c5851dc916d4e70a60f0c957f548876', '一点痕寂', 'e10adc3949ba59abbe56e057f20f883e', null, '18588773304', null, null, null, null, null, null, null, null, '2020-04-16 16:20:50', '2020-04-16 16:20:50');
INSERT INTO `tb_users` VALUES ('3f69fcc9b13843d1910b3dac597f5215', 'champyin', 'e10adc3949ba59abbe56e057f20f883e', null, '15581603443', null, null, null, null, null, null, null, null, '2020-04-16 16:28:11', '2020-04-16 16:28:11');
INSERT INTO `tb_users` VALUES ('5ca4567d892841b087fac5246effac40', '疯狂的技术宅', 'e10adc3949ba59abbe56e057f20f883e', null, '13272452662', null, null, null, null, null, null, null, null, '2020-04-16 16:28:48', '2020-04-16 16:28:48');
INSERT INTO `tb_users` VALUES ('61cdf41d1e5e4f229b76f6a042e254b6', '陈东民', 'e10adc3949ba59abbe56e057f20f883e', null, '15974253641', null, null, null, null, null, null, null, null, '2020-04-16 16:21:38', '2020-04-16 16:21:38');
INSERT INTO `tb_users` VALUES ('692c6787030d4b8882077b2ab9279c52', 'ConardLi', 'e10adc3949ba59abbe56e057f20f883e', null, '15575974664', null, null, null, null, null, null, null, null, '2020-04-16 16:29:06', '2020-04-16 16:29:06');
INSERT INTO `tb_users` VALUES ('6fbfa4aaad3a43458f21c8acf0038ac5', '前端小智', 'e10adc3949ba59abbe56e057f20f883e', null, '13036784774', null, null, null, null, null, null, null, null, '2020-04-16 16:29:29', '2020-04-16 16:29:29');
INSERT INTO `tb_users` VALUES ('92fd98d1f9ce496dbe8c80ffd3bb7bdf', '我叫mt', 'e10adc3949ba59abbe56e057f20f883e', null, '13135284774', null, null, null, null, null, null, null, null, '2020-04-16 16:24:10', '2020-04-16 16:24:10');
INSERT INTO `tb_users` VALUES ('c56940aa8b004dab84568e86900b2ee6', '漃寞、誰買單', 'e10adc3949ba59abbe56e057f20f883e', null, '13187014224', null, null, null, null, null, null, null, null, '2020-04-16 16:24:28', '2020-04-16 16:24:28');
INSERT INTO `tb_users` VALUES ('f53014d680884163a5bd5ce762e90cdf', '回忆积累在胸口', 'e10adc3949ba59abbe56e057f20f883e', null, '18525854114', null, null, null, null, null, null, null, null, '2020-04-16 16:24:56', '2020-04-16 16:24:56');

-- ----------------------------
-- Table structure for tb_users_info
-- ----------------------------
DROP TABLE IF EXISTS `tb_users_info`;
CREATE TABLE `tb_users_info` (
  `uuid` varchar(50) NOT NULL,
  `name` varchar(20) DEFAULT NULL COMMENT '名称',
  `name_sub` varchar(20) DEFAULT NULL COMMENT '子标题',
  `start_time` datetime DEFAULT NULL COMMENT '开始时间',
  `end_time` datetime DEFAULT NULL COMMENT '结束时间',
  `is_time` bit(1) DEFAULT NULL COMMENT '判断结束时间是否要填',
  `city` varchar(50) DEFAULT NULL COMMENT '所在城市',
  `label_id` varchar(255) DEFAULT NULL COMMENT '标签id',
  `desc` varchar(255) DEFAULT NULL COMMENT '描述',
  `type` int(1) DEFAULT NULL COMMENT '1、工作经历 2、教育经历 3、开源项目',
  PRIMARY KEY (`uuid`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8 COMMENT='用户信息表(工作经历,教育经历,开源项目 & 文章著作)';

-- ----------------------------
-- Records of tb_users_info
-- ----------------------------
